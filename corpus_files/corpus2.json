{"path": "lake-packages/std/Std/Tactic/SimpTrace.lean", "imports": ["lake-packages/std/Std/Lean/Parser.lean", "lake-packages/std/Std/Tactic/TryThis.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Simp.lean"], "premises": [{"full_name": "Std.Tactic.mkSimpCallStx", "code": "def mkSimpCallStx (stx : Syntax) (usedSimps : UsedSimps) : MetaM (TSyntax `tactic) := do\n  let mut stx := stx.unsetTrailing\n  if stx[3].isNone then\n    stx := stx.setArg 3 (mkNullNode #[mkAtom \"only\"])\n  let mut args := #[]\n  let mut localsOrStar := some #[]\n  let lctx \u2190 getLCtx\n  let env \u2190 getEnv\n  for (thm, _) in usedSimps.toArray.qsort (\u00b7.2 < \u00b7.2) do\n    match thm with\n    | .decl declName inv => if env.contains declName && !simpOnlyBuiltins.contains declName then\n        args := args.push (\u2190 if inv then\n          `(Parser.Tactic.simpLemma| \u2190 $(mkIdent (\u2190 unresolveNameGlobal declName)):ident)\n        else\n          `(Parser.Tactic.simpLemma| $(mkIdent (\u2190 unresolveNameGlobal declName)):ident))\n    | .fvar fvarId => if let some ldecl := lctx.find? fvarId then\n        localsOrStar := localsOrStar.bind fun locals =>\n          if !ldecl.userName.isInaccessibleUserName &&\n              (lctx.findFromUserName? ldecl.userName).get!.fvarId == ldecl.fvarId then\n            some (locals.push ldecl.userName)\n          else\n            none\n      | .stx _ thmStx => args := args.push thmStx\n    | .other _ => pure ()     if let some locals := localsOrStar then\n    args := args ++ (\u2190 locals.mapM fun id => `(Parser.Tactic.simpLemma| $(mkIdent id):ident))\n  else\n    args := args.push (\u2190 `(Parser.Tactic.simpStar| *))\n  let argsStx := if args.isEmpty then #[] else #[mkAtom \"[\", (mkAtom \",\").mkSep args, mkAtom \"]\"]\n  pure <| stx.setArg 4 (mkNullNode argsStx)", "start": [40, 1], "end": [76, 44], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.dsimpLocation'", "code": "def dsimpLocation' (ctx : Simp.Context) (loc : Location) : TacticM Simp.UsedSimps := do\n  match loc with\n  | Location.targets hyps simplifyTarget =>\n    withMainContext do\n      let fvarIds \u2190 getFVarIds hyps\n      go fvarIds simplifyTarget\n  | Location.wildcard =>\n    withMainContext do\n      go (\u2190 (\u2190 getMainGoal).getNondepPropHyps) (simplifyTarget := true)\nwhere\n  \n  go (fvarIdsToSimp : Array FVarId) (simplifyTarget : Bool) : TacticM Simp.UsedSimps := do\n    let mvarId \u2190 getMainGoal\n    let (result?, usedSimps) \u2190\n      dsimpGoal mvarId ctx (simplifyTarget := simplifyTarget) (fvarIdsToSimp := fvarIdsToSimp)\n    match result? with\n    | none => replaceMainGoal []\n    | some mvarId => replaceMainGoal [mvarId]\n    pure usedSimps", "start": [119, 1], "end": [138, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Phase.toNat", "code": "def Phase.toNat : Phase \u2192 Nat\n  | .base => 0\n  | .mono => 1\n  | .impure => 2", "start": [13, 1], "end": [16, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Phase.le_refl", "code": "@[simp] theorem Phase.le_refl (p : Phase) : p \u2264 p", "start": [27, 1], "end": [28, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Pass", "code": "structure Pass where\n  \n  occurrence : Nat := 0\n  \n  phase : Phase\n  \n  phaseOut : Phase := phase\n  phaseInv : phaseOut \u2265 phase := by simp\n  \n  name : Name\n  \n  run : Array Decl \u2192 CompilerM (Array Decl)", "start": [30, 1], "end": [57, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller", "code": "structure PassInstaller where\n  \n  install : Array Pass \u2192 CoreM (Array Pass)\n  deriving Inhabited", "start": [62, 1], "end": [73, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassManager", "code": "structure PassManager where\n  passes : Array Pass\n  deriving Inhabited", "start": [75, 1], "end": [81, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Pass.mkPerDeclaration", "code": "def mkPerDeclaration (name : Name) (run : Decl \u2192 CompilerM Decl) (phase : Phase) (occurrence : Nat := 0) : Pass where\n  occurrence := occurrence\n  phase := phase\n  name := name\n  run := fun xs => xs.mapM run", "start": [91, 1], "end": [95, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassManager.validate", "code": "def validate (manager : PassManager) : CoreM Unit := do\n  let mut current := .base\n  for pass in manager.passes do\n    if \u00ac(current \u2264 pass.phase) then\n      throwError s!\"{pass.name} has phase {pass.phase} but should at least have {current}\"\n    current := pass.phase", "start": [101, 1], "end": [106, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassManager.findHighestOccurrence", "code": "def findHighestOccurrence (targetName : Name) (passes : Array Pass) : CoreM Nat := do\n  let mut highest := none\n  for pass in passes do\n      if pass.name == targetName then\n        highest := some pass.occurrence\n  let some val := highest | throwError s!\"Could not find any occurrence of {targetName}\"\n  return val", "start": [108, 1], "end": [114, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.installAtEnd", "code": "def installAtEnd (p : Pass) : PassInstaller where\n  install passes := return passes.push p", "start": [120, 1], "end": [121, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.append", "code": "def append (passesNew : Array Pass) : PassInstaller where\n  install passes := return passes ++ passesNew", "start": [123, 1], "end": [124, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.withEachOccurrence", "code": "def withEachOccurrence (targetName : Name) (f : Nat \u2192 PassInstaller) : PassInstaller where\n  install passes := do\n    let highestOccurrence \u2190 PassManager.findHighestOccurrence targetName passes\n    let mut passes := passes\n    for occurrence in [0:highestOccurrence+1] do\n      passes \u2190 f occurrence |>.install passes\n    return passes", "start": [126, 1], "end": [132, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.installAfter", "code": "def installAfter (targetName : Name) (p : Pass \u2192 Pass) (occurrence : Nat := 0) : PassInstaller where\n  install passes :=\n    if let some idx := passes.findIdx? (fun p => p.name == targetName && p.occurrence == occurrence) then\n      let passUnderTest := passes[idx]!\n      return passes.insertAt! (idx + 1) (p passUnderTest)\n    else\n      throwError s!\"Tried to insert pass after {targetName}, occurrence {occurrence} but {targetName} is not in the pass list\"", "start": [134, 1], "end": [140, 127], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.installAfterEach", "code": "def installAfterEach (targetName : Name) (p : Pass \u2192 Pass) : PassInstaller :=\n    withEachOccurrence targetName (installAfter targetName p \u00b7)", "start": [142, 1], "end": [143, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.installBefore", "code": "def installBefore (targetName : Name) (p : Pass \u2192 Pass) (occurrence : Nat := 0): PassInstaller where\n  install passes :=\n    if let some idx := passes.findIdx? (fun p => p.name == targetName && p.occurrence == occurrence) then\n      let passUnderTest := passes[idx]!\n      return passes.insertAt! idx (p passUnderTest)\n    else\n      throwError s!\"Tried to insert pass after {targetName}, occurrence {occurrence} but {targetName} is not in the pass list\"", "start": [145, 1], "end": [151, 127], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.installBeforeEachOccurrence", "code": "def installBeforeEachOccurrence (targetName : Name) (p : Pass \u2192 Pass) : PassInstaller :=\n    withEachOccurrence targetName (installBefore targetName p \u00b7)", "start": [153, 1], "end": [154, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.replacePass", "code": "def replacePass (targetName : Name) (p : Pass \u2192 Pass) (occurrence : Nat := 0) : PassInstaller where\n  install passes := do\n    let some idx := passes.findIdx? (fun p => p.name == targetName && p.occurrence == occurrence) | throwError s!\"Tried to replace {targetName}, occurrence {occurrence} but {targetName} is not in the pass list\"\n    let target := passes[idx]!\n    let replacement := p target\n    return passes.set! idx replacement", "start": [156, 1], "end": [161, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.replaceEachOccurrence", "code": "def replaceEachOccurrence (targetName : Name) (p : Pass \u2192 Pass) : PassInstaller :=\n    withEachOccurrence targetName (replacePass targetName p \u00b7)", "start": [163, 1], "end": [164, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.run", "code": "def run (manager : PassManager) (installer : PassInstaller) : CoreM PassManager := do\n  return { manager with passes := (\u2190 installer.install manager.passes) }", "start": [166, 1], "end": [167, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.getPassInstallerUnsafe", "code": "private unsafe def getPassInstallerUnsafe (declName : Name) : CoreM PassInstaller := do\n  ofExcept <| (\u2190 getEnv).evalConstCheck PassInstaller (\u2190 getOptions) ``PassInstaller declName", "start": [169, 1], "end": [170, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.getPassInstaller", "code": "@[implemented_by getPassInstallerUnsafe]\nprivate opaque getPassInstaller (declName : Name) : CoreM PassInstaller", "start": [172, 1], "end": [173, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassInstaller.runFromDecl", "code": "def runFromDecl (manager : PassManager) (declName : Name) : CoreM PassManager := do\n  let installer \u2190 getPassInstaller declName\n  let newState \u2190 installer.run manager\n  newState.validate\n  return newState", "start": [175, 1], "end": [179, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/MonoTypes.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Util.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/BaseTypes.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/InferType.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.getRelevantCtorFields", "code": "def getRelevantCtorFields (ctorName : Name) : CoreM (Array Bool) := do\n  let .ctorInfo info \u2190 getConstInfo ctorName | unreachable!\n  Meta.MetaM.run' do\n    Meta.forallTelescopeReducing info.type fun xs _ => do\n      let mut result := #[]\n      for x in xs[info.numParams:] do\n        let type \u2190 Meta.inferType x\n        result := result.push !(\u2190 Meta.isProp type <||> Meta.isTypeFormerType type)\n      return result", "start": [13, 1], "end": [25, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.TrivialStructureInfo", "code": "structure TrivialStructureInfo where\n  ctorName  : Name\n  numParams : Nat\n  fieldIdx  : Nat\n  deriving Inhabited, Repr", "start": [27, 1], "end": [35, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.hasTrivialStructure?", "code": "def hasTrivialStructure? (declName : Name) : CoreM (Option TrivialStructureInfo) := do\n  if isRuntimeBultinType declName then return none\n  let .inductInfo info \u2190 getConstInfo declName | return none\n  if info.isUnsafe || info.isRec then return none\n  let [ctorName] := info.ctors | return none\n  let mask \u2190 getRelevantCtorFields ctorName\n  let mut result := none\n  for i in [:mask.size] do\n    if mask[i]! then\n      if result.isSome then return none\n      result := some { ctorName, fieldIdx := i, numParams := info.numParams }\n  return result", "start": [37, 1], "end": [54, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getParamTypes", "code": "def getParamTypes (type : Expr) : Array Expr :=\n  go type #[]\nwhere\n  go (type : Expr) (r : Array Expr) :=\n    match type with\n    | .forallE _ d b _ => go b (r.push d)\n    | _ => r", "start": [56, 1], "end": [62, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.toMonoType", "code": "partial def toMonoType (type : Expr) : CoreM Expr := do\n  let type := type.headBeta\n  if type.isErased then\n    return erasedExpr\n  else if type.isErased then\n    return erasedExpr\n  else if isTypeFormerType type then\n    return erasedExpr\n  else match type with\n    | .const ..        => visitApp type #[]\n    | .app ..          => type.withApp visitApp\n    | .forallE _ d b _ => mkArrow (\u2190 toMonoType d) (\u2190 toMonoType (b.instantiate1 erasedExpr))\n    | _                => return erasedExpr\nwhere\n  visitApp (f : Expr) (args : Array Expr) : CoreM Expr := do\n    match f with\n    | .const declName us =>\n      if declName == ``Decidable then\n        return mkConst ``Bool\n      if let some info \u2190 hasTrivialStructure? declName then\n        let ctorType \u2190 getOtherDeclBaseType info.ctorName []\n        toMonoType (getParamTypes (\u2190 instantiateForall ctorType args[:info.numParams]))[info.fieldIdx]!\n      else\n        let mut result := mkConst declName\n        let mut type \u2190 getOtherDeclBaseType declName us\n        for arg in args do\n          let .forallE _ d b _ := type.headBeta | unreachable!\n          let arg := arg.headBeta\n          if arg.isErased then\n            result := mkApp result arg\n          else if d.isErased || d matches .sort _ then\n            result := mkApp result (\u2190 toMonoType arg)\n          else\n            result := mkApp result erasedExpr\n          type := b.instantiate1 arg\n        return result\n    | _ => return erasedExpr", "start": [64, 1], "end": [108, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.MonoTypeExtState", "code": "structure MonoTypeExtState where\n  \n  mono : PHashMap Name Expr := {}\n  deriving Inhabited", "start": [110, 1], "end": [118, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getOtherDeclMonoType", "code": "def getOtherDeclMonoType (declName : Name) : CoreM Expr := do\n  match monoTypeExt.getState (\u2190 getEnv) |>.mono.find? declName with\n  | some type => return type\n  | none =>\n    let type \u2190 toMonoType (\u2190 getOtherDeclBaseType declName [])\n    modifyEnv fun env => monoTypeExt.modifyState env fun s => { s with mono := s.mono.insert declName type }\n    return type", "start": [123, 1], "end": [129, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Lint/Misc.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/CollectLevelParams.lean", "lake-packages/lean4/src/lean/Lean/Meta/ForEachExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Tactic/Lint/Basic.lean", "lake-packages/std/Std/Data/Array/Basic.lean"], "premises": [{"full_name": "Std.Tactic.Lint.dupNamespace", "code": "@[std_linter] def dupNamespace : Linter where\n  noErrorsFound := \"No declarations have a duplicate namespace.\"\n  errorsFound := \"DUPLICATED NAMESPACES IN NAME:\"\n  test declName := do\n    if \u2190 isAutoDecl declName then return none\n    if isGlobalInstance (\u2190 getEnv) declName then return none\n    let nm := declName.components\n    let some (dup, _) := nm.zip nm.tail! |>.find? fun (x, y) => x == y\n      | return none\n    return m!\"The namespace {dup} is duplicated in the name\"", "start": [21, 1], "end": [31, 61], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.unusedArguments", "code": "@[std_linter] def unusedArguments : Linter where\n  noErrorsFound := \"No unused arguments.\"\n  errorsFound := \"UNUSED ARGUMENTS.\"\n  test declName := do\n    if \u2190 isAutoDecl declName then return none\n    if \u2190 isProjectionFn declName then return none\n    let info \u2190 getConstInfo declName\n    let ty := info.type\n    let some val := info.value? | return none\n    if val.hasSorry || ty.hasSorry then return none\n    forallTelescope ty fun args ty => do\n      let mut e := (mkAppN val args).headBeta\n      e := mkApp e ty\n      for arg in args do\n        let ldecl \u2190 getFVarLocalDecl arg\n        e := mkApp e ldecl.type\n        if let some val := ldecl.value? then\n          e := mkApp e val\n      let unused := args.zip (.range args.size) |>.filter fun (arg, _) =>\n        !e.containsFVar arg.fvarId!\n      if unused.isEmpty then return none\n      addMessageContextFull <| .joinSep (\u2190 unused.toList.mapM fun (arg, i) =>\n          return m!\"argument {i+1} {arg} : {\u2190 inferType arg}\") m!\", \"", "start": [33, 1], "end": [57, 70], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.docBlame", "code": "@[std_linter] def docBlame : Linter where\n  noErrorsFound := \"No definitions are missing documentation.\"\n  errorsFound := \"DEFINITIONS ARE MISSING DOCUMENTATION STRINGS:\"\n  test declName := do\n    if (\u2190 isAutoDecl declName) || isGlobalInstance (\u2190 getEnv) declName then\n      return none if let .str _ s := declName then\n      if s == \"parenthesizer\" || s == \"formatter\" || s == \"delaborator\" || s == \"quot\" then\n      return none\n    let kind \u2190 match \u2190 getConstInfo declName with\n      | .axiomInfo .. => pure \"axiom\"\n      | .opaqueInfo .. => pure \"constant\"\n      | .defnInfo info =>\n          if \u2190 isProjectionFn declName <&&> isProp info.type then\n            return none\n          pure \"definition\"\n      | .inductInfo .. => pure \"inductive\"\n      | _ => return none\n    let (none) \u2190 findDocString? (\u2190 getEnv) declName | return none\n    return m!\"{kind} missing documentation string\"", "start": [59, 1], "end": [81, 51], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.docBlameThm", "code": "@[std_linter disabled] def docBlameThm : Linter where\n  noErrorsFound := \"No theorems are missing documentation.\"\n  errorsFound := \"THEOREMS ARE MISSING DOCUMENTATION STRINGS:\"\n  test declName := do\n    if \u2190 isAutoDecl declName then\n      return none\n    let kind \u2190 match \u2190 getConstInfo declName with\n      | .thmInfo .. => pure \"theorem\"\n      | .defnInfo info =>\n          if \u2190 isProjectionFn declName <&&> isProp info.type then\n            pure \"Prop projection\"\n          else\n            return none\n      | _ => return none\n    let (none) \u2190 findDocString? (\u2190 getEnv) declName | return none\n    return m!\"{kind} missing documentation string\"", "start": [83, 1], "end": [101, 51], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.defLemma", "code": "@[std_linter] def defLemma : Linter where\n  noErrorsFound := \"All declarations correctly marked as def/lemma.\"\n  errorsFound := \"INCORRECT DEF/LEMMA:\"\n  test declName := do\n    if (\u2190 isAutoDecl declName) || isGlobalInstance (\u2190 getEnv) declName then\n      return none\n    if \u2190 isProjectionFn declName then return none\n    let info \u2190 getConstInfo declName\n    let isThm \u2190 match info with\n      | .defnInfo .. => pure false\n      | .thmInfo .. => pure true\n      | _ => return none\n    match isThm, \u2190 isProp info.type with\n    | true, false => pure \"is a lemma/theorem, should be a def\"\n    | false, true => pure \"is a def, should be lemma/theorem\"\n    | _, _ => return none", "start": [103, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.checkType", "code": "@[std_linter] def checkType : Linter where\n  noErrorsFound :=\n    \"The statements of all declarations type-check with default reducibility settings.\"\n  errorsFound := \"THE STATEMENTS OF THE FOLLOWING DECLARATIONS DO NOT TYPE-CHECK.\"\n  isFast := true\n  test declName := do\n    if \u2190 isAutoDecl declName then return none\n    if \u2190 isTypeCorrect (\u2190 getConstInfo declName).type then return none\n    return m!\"the statement doesn't type check.\"", "start": [124, 1], "end": [133, 49], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.univParamsGrouped", "code": "private def univParamsGrouped (e : Expr) (nm\u2080 : Name) : Lean.HashSet (Array Name) :=\n  runST fun \u03c3 => do\n    let res \u2190 ST.mkRef (\u03c3 := \u03c3) {}\n    e.forEach fun\n      | .sort u =>\n        res.modify (\u00b7.insert (CollectLevelParams.visitLevel u {}).params)\n      | .const n us => do\n        if let .str n s .. := n then\n          if n == nm\u2080 && s.startsWith \"proof_\" then\n            return\n        res.modify <| us.foldl (\u00b7.insert <| CollectLevelParams.visitLevel \u00b7 {} |>.params)\n      | _ => pure ()\n    res.get", "start": [135, 1], "end": [154, 12], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.badParams", "code": "private partial def badParams (l : Array (Array Name)) : Array Name :=\n  let goodLevels := l.filterMap fun\n    | #[u] => some u\n    | _ => none\n  if goodLevels.isEmpty then\n    l.flatten.toList.eraseDups.toArray\n  else\n    badParams <| l.map (\u00b7.filter (!goodLevels.contains \u00b7))", "start": [156, 1], "end": [168, 59], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.checkUnivs", "code": "@[std_linter] def checkUnivs : Linter where\n  noErrorsFound :=\n    \"All declarations have good universe levels.\"\n  errorsFound := \"THE STATEMENTS OF THE FOLLOWING DECLARATIONS HAVE BAD UNIVERSE LEVELS. \" ++\n\"This usually means that there is a `max u v` in the type where neither `u` nor `v` \" ++\n\"occur by themselves. Solution: Find the type (or type bundled with data) that has this \" ++\n\"universe argument and provide the universe level explicitly. If this happens in an implicit \" ++\n\"argument of the declaration, a better solution is to move this argument to a `variables` \" ++\n\"command (then it's not necessary to provide the universe level).\nIt is possible that this linter gives a false positive on definitions where the value of the \" ++\n\"definition has the universes occur separately, and the definition will usually be used with \" ++\n\"explicit universe arguments. In this case, feel free to add `@[nolint checkUnivs]`.\"\n  isFast := true\n  test declName := do\n    if \u2190 isAutoDecl declName then return none\n    let bad := badParams (univParamsGrouped (\u2190 getConstInfo declName).type declName).toArray\n    if bad.isEmpty then return none\n    return m!\"universes {bad} only occur together.\"", "start": [170, 1], "end": [196, 52], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.synTaut", "code": "@[std_linter] def synTaut : Linter where\n  noErrorsFound :=\n    \"No declarations are syntactic tautologies.\"\n  errorsFound := \"THE FOLLOWING DECLARATIONS ARE SYNTACTIC TAUTOLOGIES. \" ++\n\"This usually means that they are of the form `\u2200 a b ... z, e\u2081 = e\u2082` where `e\u2081` and `e\u2082` are \" ++\n\"identical expressions. We call declarations of this form syntactic tautologies. \" ++\n\"Such lemmas are (mostly) useless and sometimes introduced unintentionally when proving \" ++\n\"basic facts using `rfl`, when elaboration results in a different term than the user intended. \" ++\n\"You should check that the declaration really says what you think it does.\"\n  isFast := true\n  test declName := do\n    if \u2190 isAutoDecl declName then return none\n    forallTelescope (\u2190 getConstInfo declName).type fun _ ty => do\n      let some (lhs, rhs) := ty.eq?.map (fun (_, l, r) => (l, r)) <|> ty.iff?\n        | return none\n      if lhs == rhs then\n        return m!\"LHS equals RHS syntactically\"\n      return none", "start": [198, 1], "end": [221, 18], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.findUnusedHaves", "code": "def findUnusedHaves (e : Expr) : MetaM (Array MessageData) := do\n  let res \u2190 IO.mkRef #[]\n  forEachExpr e fun e => do\n    let some e := letFunAnnotation? e | return\n    let Expr.app (Expr.lam n t b ..) _ .. := e | return\n    if n.isInternal then return\n    if b.hasLooseBVars then return\n    let msg \u2190 addMessageContextFull m!\"unnecessary have {n.eraseMacroScopes} : {t}\"\n    res.modify (\u00b7.push msg)\n  res.get", "start": [223, 1], "end": [236, 10], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.unusedHavesSuffices", "code": "@[std_linter] def unusedHavesSuffices : Linter where\n  noErrorsFound := \"No declarations have unused term mode have statements.\"\n  errorsFound := \"THE FOLLOWING DECLARATIONS HAVE INEFFECTUAL TERM MODE HAVE/SUFFICES BLOCKS. \" ++\n    \"In the case of `have` this is a term of the form `have h := foo, bar` where `bar` does not \" ++\n    \"refer to `foo`. Such statements have no effect on the generated proof, and can just be \" ++\n    \"replaced by `bar`, in addition to being ineffectual, they may make unnecessary assumptions \" ++\n    \"in proofs appear as if they are used. \" ++\n    \"For `suffices` this is a term of the form `suffices h : foo, proof_of_goal, proof_of_foo`\" ++\n    \" where `proof_of_goal` does not refer to `foo`. \" ++\n    \"Such statements have no effect on the generated proof, and can just be replaced by \" ++\n    \"`proof_of_goal`, in addition to being ineffectual, they may make unnecessary assumptions \" ++\n    \"in proofs appear as if they are used. \"\n  test declName := do\n    if \u2190 isAutoDecl declName then return none\n    let info \u2190 getConstInfo declName\n    let mut unused \u2190 findUnusedHaves info.type\n    if let some value := info.value? then\n      unused := unused ++ (\u2190 findUnusedHaves value)\n    unless unused.isEmpty do\n      return some <| .joinSep unused.toList \", \"\n    return none", "start": [238, 1], "end": [261, 16], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.explicitVarsOfIff", "code": "@[std_linter disabled] def explicitVarsOfIff : Linter where\n  noErrorsFound := \"No explicit variables on both sides of iff\"\n  errorsFound := \"EXPLICIT VARIABLES ON BOTH SIDES OF IFF\"\n  test declName := do\n    if \u2190 isAutoDecl declName then return none\n    forallTelescope (\u2190 getConstInfo declName).type fun args ty => do\n      let some (lhs, rhs) := ty.iff? | return none\n      let explicit \u2190 args.filterM fun arg =>\n        return (\u2190 getFVarLocalDecl arg).binderInfo.isExplicit &&\n          lhs.containsFVar arg.fvarId! && rhs.containsFVar arg.fvarId!\n      if explicit.isEmpty then return none\n      addMessageContextFull m!\"should be made implicit: {\n        MessageData.joinSep (explicit.toList.map (m!\"{\u00b7}\")) \", \"}\"", "start": [263, 1], "end": [279, 67], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Basic.lean", "imports": ["lake-packages/std/Std/Tactic/SimpTrace.lean", "lake-packages/std/Std/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/std/Std/Tactic/SeqFocus.lean", "lake-packages/std/Std/Lean/Tactic.lean", "lake-packages/std/Std/Tactic/ShowTerm.lean", "lake-packages/std/Std/Tactic/NoMatch.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Tactic/GuardExpr.lean", "lake-packages/std/Std/Tactic/ByCases.lean", "lake-packages/std/Std/Linter.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.DeclExtState", "code": "abbrev DeclExtState := PHashMap Name Decl", "start": [10, 1], "end": [10, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.declLt", "code": "private abbrev declLt (a b : Decl) :=\n  Name.quickLt a.name b.name", "start": [12, 1], "end": [13, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.sortDecls", "code": "private abbrev sortDecls (decls : Array Decl) : Array Decl :=\n  decls.qsort declLt", "start": [15, 1], "end": [16, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.findAtSorted?", "code": "private abbrev findAtSorted? (decls : Array Decl) (declName : Name) : Option Decl :=\n  let tmpDecl : Decl := default\n  let tmpDecl := { tmpDecl with name := declName }\n  decls.binSearch tmpDecl declLt", "start": [18, 1], "end": [21, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.DeclExt", "code": "abbrev DeclExt := PersistentEnvExtension Decl Decl DeclExtState", "start": [23, 1], "end": [23, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkDeclExt", "code": "def mkDeclExt (name : Name := by exact decl_name%) : IO DeclExt := do\n  registerPersistentEnvExtension {\n    name            := name\n    mkInitial       := return {}\n    addImportedFn   := fun _ => return {}\n    addEntryFn      := fun decls decl => decls.insert decl.name decl\n    exportEntriesFn := fun s =>\n      let decls := s.foldl (init := #[]) fun decls _ decl => decls.push decl\n      sortDecls decls\n  }", "start": [25, 1], "end": [34, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getDeclCore?", "code": "def getDeclCore? (env : Environment) (ext : DeclExt) (declName : Name) : Option Decl :=\n  match env.getModuleIdxFor? declName with\n  | some modIdx => findAtSorted? (ext.getModuleEntries env modIdx) declName\n  | none        => ext.getState env |>.find? declName", "start": [39, 1], "end": [42, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getBaseDecl?", "code": "def getBaseDecl? (declName : Name) : CoreM (Option Decl) := do\n  return getDeclCore? (\u2190 getEnv) baseExt declName", "start": [44, 1], "end": [45, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getMonoDecl?", "code": "def getMonoDecl? (declName : Name) : CoreM (Option Decl) := do\n  return getDeclCore? (\u2190 getEnv) monoExt declName", "start": [47, 1], "end": [48, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.saveBaseDeclCore", "code": "def saveBaseDeclCore (env : Environment) (decl : Decl) : Environment :=\n  baseExt.addEntry (env.addExtraName decl.name) decl", "start": [50, 1], "end": [51, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.saveMonoDeclCore", "code": "def saveMonoDeclCore (env : Environment) (decl : Decl) : Environment :=\n  monoExt.addEntry (env.addExtraName decl.name) decl", "start": [53, 1], "end": [54, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.saveBase", "code": "def Decl.saveBase (decl : Decl) : CoreM Unit :=\n  modifyEnv (saveBaseDeclCore \u00b7 decl)", "start": [56, 1], "end": [57, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.saveMono", "code": "def Decl.saveMono (decl : Decl) : CoreM Unit :=\n  modifyEnv (saveMonoDeclCore \u00b7 decl)", "start": [59, 1], "end": [60, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.save", "code": "def Decl.save (decl : Decl) : CompilerM Unit := do\n  match (\u2190 getPhase) with\n  | .base => decl.saveBase\n  | .mono => decl.saveMono\n  | _ => unreachable!", "start": [62, 1], "end": [66, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getDeclAt?", "code": "def getDeclAt? (declName : Name) (phase : Phase) : CoreM (Option Decl) :=\n  match phase with\n  | .base => getBaseDecl? declName\n  | .mono => getMonoDecl? declName\n  | _  => return none", "start": [68, 1], "end": [72, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getDecl?", "code": "def getDecl? (declName : Name) : CompilerM (Option Decl) := do\n  getDeclAt? declName (\u2190 getPhase)", "start": [74, 1], "end": [75, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getExt", "code": "def getExt (phase : Phase) : DeclExt :=\n  match phase with\n  | .base => baseExt\n  | .mono => monoExt\n  | _ => unreachable!", "start": [77, 1], "end": [81, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.forEachDecl", "code": "def forEachDecl (f : Decl \u2192 CoreM Unit) (phase := Phase.base) : CoreM Unit := do\n  let ext := getExt phase\n  let env \u2190 getEnv\n  for modIdx in [:env.allImportedModuleNames.size] do\n    for decl in ext.getModuleEntries env modIdx do\n      f decl\n  ext.getState env |>.forM fun _ decl => f decl", "start": [83, 1], "end": [89, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.forEachModuleDecl", "code": "def forEachModuleDecl (moduleName : Name) (f : Decl \u2192 CoreM Unit) (phase := Phase.base) : CoreM Unit := do\n  let ext := getExt phase\n  let env \u2190 getEnv\n  let some modIdx := env.getModuleIdx? moduleName | throwError \"module `{moduleName}` not found\"\n  for decl in ext.getModuleEntries env modIdx do\n    f decl", "start": [91, 1], "end": [96, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.forEachMainModuleDecl", "code": "def forEachMainModuleDecl (f : Decl \u2192 CoreM Unit) (phase := Phase.base) : CoreM Unit := do\n  (getExt phase).getState (\u2190 getEnv) |>.forM fun _ decl => f decl", "start": [98, 1], "end": [99, 66], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/OtherDecl.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/MonoTypes.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/BaseTypes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.getOtherDeclType", "code": "def getOtherDeclType (declName : Name) (us : List Level := []) : CompilerM Expr := do\n  match (\u2190 getPhase) with\n  | .base => getOtherDeclBaseType declName us\n  | .mono => getOtherDeclMonoType declName\n  | _ => unreachable!", "start": [11, 1], "end": [18, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Classes/Dvd.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Dvd", "code": "class Dvd (\u03b1 : Type _) where\n  \n  dvd : \u03b1 \u2192 \u03b1 \u2192 Prop", "start": [7, 1], "end": [10, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Logic.lean", "imports": ["lake-packages/std/Std/Tactic/Basic.lean", "lake-packages/std/Std/Tactic/Lint/Misc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Not.intro", "code": "theorem Not.intro {a : Prop} (h : a \u2192 False) : \u00aca", "start": [14, 1], "end": [14, 55], "kind": "commanddeclaration"}, {"full_name": "Not.elim", "code": "def Not.elim {\u03b1 : Sort _} (H1 : \u00aca) (H2 : a) : \u03b1 := absurd H2 H1", "start": [16, 1], "end": [18, 65], "kind": "commanddeclaration"}, {"full_name": "Not.imp", "code": "theorem Not.imp {a b : Prop} (H2 : \u00acb) (H1 : a \u2192 b) : \u00aca", "start": [20, 1], "end": [20, 69], "kind": "commanddeclaration"}, {"full_name": "not_congr", "code": "theorem not_congr (h : a \u2194 b) : \u00aca \u2194 \u00acb", "start": [22, 1], "end": [22, 60], "kind": "commanddeclaration"}, {"full_name": "not_not_not", "code": "theorem not_not_not : \u00ac\u00ac\u00aca \u2194 \u00aca", "start": [24, 1], "end": [24, 69], "kind": "commanddeclaration"}, {"full_name": "not_not_of_not_imp", "code": "theorem not_not_of_not_imp : \u00ac(a \u2192 b) \u2192 \u00ac\u00aca", "start": [26, 1], "end": [26, 59], "kind": "commanddeclaration"}, {"full_name": "not_of_not_imp", "code": "theorem not_of_not_imp {a : Prop} : \u00ac(a \u2192 b) \u2192 \u00acb", "start": [28, 1], "end": [28, 69], "kind": "commanddeclaration"}, {"full_name": "imp_not_self", "code": "@[simp] theorem imp_not_self : (a \u2192 \u00aca) \u2194 \u00aca", "start": [30, 1], "end": [30, 84], "kind": "commanddeclaration"}, {"full_name": "iff_def", "code": "theorem iff_def : (a \u2194 b) \u2194 (a \u2192 b) \u2227 (b \u2192 a)", "start": [38, 1], "end": [38, 80], "kind": "commanddeclaration"}, {"full_name": "iff_def'", "code": "theorem iff_def' : (a \u2194 b) \u2194 (b \u2192 a) \u2227 (a \u2192 b)", "start": [40, 1], "end": [40, 73], "kind": "commanddeclaration"}, {"full_name": "Iff.elim", "code": "def Iff.elim (f : (a \u2192 b) \u2192 (b \u2192 a) \u2192 \u03b1) (h : a \u2194 b) : \u03b1 := f h.1 h.2", "start": [42, 1], "end": [43, 70], "kind": "commanddeclaration"}, {"full_name": "Eq.to_iff", "code": "theorem Eq.to_iff : a = b \u2192 (a \u2194 b)", "start": [45, 1], "end": [45, 53], "kind": "commanddeclaration"}, {"full_name": "iff_of_eq", "code": "theorem iff_of_eq : a = b \u2192 (a \u2194 b)", "start": [47, 1], "end": [47, 49], "kind": "commanddeclaration"}, {"full_name": "neq_of_not_iff", "code": "theorem neq_of_not_iff : \u00ac(a \u2194 b) \u2192 a \u2260 b", "start": [49, 1], "end": [49, 58], "kind": "commanddeclaration"}, {"full_name": "iff_iff_eq", "code": "theorem iff_iff_eq : (a \u2194 b) \u2194 a = b", "start": [51, 1], "end": [51, 61], "kind": "commanddeclaration"}, {"full_name": "eq_iff_iff", "code": "@[simp] theorem eq_iff_iff {p q : Prop} : (p = q) \u2194 (p \u2194 q)", "start": [53, 1], "end": [53, 79], "kind": "commanddeclaration"}, {"full_name": "of_iff_true", "code": "theorem of_iff_true (h : a \u2194 True) : a", "start": [55, 1], "end": [55, 49], "kind": "commanddeclaration"}, {"full_name": "not_of_iff_false", "code": "theorem not_of_iff_false : (a \u2194 False) \u2192 \u00aca", "start": [57, 1], "end": [57, 54], "kind": "commanddeclaration"}, {"full_name": "iff_of_true", "code": "theorem iff_of_true (ha : a) (hb : b) : a \u2194 b", "start": [59, 1], "end": [59, 76], "kind": "commanddeclaration"}, {"full_name": "iff_of_false", "code": "theorem iff_of_false (ha : \u00aca) (hb : \u00acb) : a \u2194 b", "start": [61, 1], "end": [61, 71], "kind": "commanddeclaration"}, {"full_name": "iff_true_left", "code": "theorem iff_true_left (ha : a) : (a \u2194 b) \u2194 b", "start": [63, 1], "end": [63, 82], "kind": "commanddeclaration"}, {"full_name": "iff_true_right", "code": "theorem iff_true_right (ha : a) : (b \u2194 a) \u2194 b", "start": [65, 1], "end": [65, 83], "kind": "commanddeclaration"}, {"full_name": "iff_false_left", "code": "theorem iff_false_left (ha : \u00aca) : (a \u2194 b) \u2194 \u00acb", "start": [67, 1], "end": [67, 89], "kind": "commanddeclaration"}, {"full_name": "iff_false_right", "code": "theorem iff_false_right (ha : \u00aca) : (b \u2194 a) \u2194 \u00acb", "start": [69, 1], "end": [69, 87], "kind": "commanddeclaration"}, {"full_name": "iff_true_intro", "code": "theorem iff_true_intro (h : a) : a \u2194 True", "start": [71, 1], "end": [71, 62], "kind": "commanddeclaration"}, {"full_name": "iff_false_intro", "code": "theorem iff_false_intro (h : \u00aca) : a \u2194 False", "start": [73, 1], "end": [73, 66], "kind": "commanddeclaration"}, {"full_name": "not_iff_false_intro", "code": "theorem not_iff_false_intro (h : a) : \u00aca \u2194 False", "start": [75, 1], "end": [75, 86], "kind": "commanddeclaration"}, {"full_name": "iff_congr", "code": "theorem iff_congr (h\u2081 : a \u2194 c) (h\u2082 : b \u2194 d) : (a \u2194 b) \u2194 (c \u2194 d)", "start": [77, 1], "end": [78, 79], "kind": "commanddeclaration"}, {"full_name": "not_true", "code": "@[simp] theorem not_true : (\u00acTrue) \u2194 False", "start": [80, 1], "end": [80, 81], "kind": "commanddeclaration"}, {"full_name": "not_false_iff", "code": "theorem not_false_iff : (\u00acFalse) \u2194 True", "start": [82, 1], "end": [82, 68], "kind": "commanddeclaration"}, {"full_name": "ne_self_iff_false", "code": "theorem ne_self_iff_false (a : \u03b1) : a \u2260 a \u2194 False", "start": [84, 1], "end": [84, 77], "kind": "commanddeclaration"}, {"full_name": "eq_self_iff_true", "code": "theorem eq_self_iff_true (a : \u03b1) : a = a \u2194 True", "start": [86, 1], "end": [86, 70], "kind": "commanddeclaration"}, {"full_name": "heq_self_iff_true", "code": "theorem heq_self_iff_true (a : \u03b1) : HEq a a \u2194 True", "start": [88, 1], "end": [88, 77], "kind": "commanddeclaration"}, {"full_name": "iff_not_self", "code": "theorem iff_not_self : \u00ac(a \u2194 \u00aca)", "start": [90, 1], "end": [90, 70], "kind": "commanddeclaration"}, {"full_name": "not_iff_self", "code": "@[simp] theorem not_iff_self : \u00ac(\u00aca \u2194 a)", "start": [92, 1], "end": [92, 68], "kind": "commanddeclaration"}, {"full_name": "true_iff_false", "code": "theorem true_iff_false : (True \u2194 False) \u2194 False", "start": [94, 1], "end": [94, 85], "kind": "commanddeclaration"}, {"full_name": "false_iff_true", "code": "theorem false_iff_true : (False \u2194 True) \u2194 False", "start": [96, 1], "end": [96, 85], "kind": "commanddeclaration"}, {"full_name": "false_of_true_iff_false", "code": "theorem false_of_true_iff_false : (True \u2194 False) \u2192 False", "start": [98, 1], "end": [98, 76], "kind": "commanddeclaration"}, {"full_name": "false_of_true_eq_false", "code": "theorem false_of_true_eq_false : (True = False) \u2192 False", "start": [100, 1], "end": [100, 80], "kind": "commanddeclaration"}, {"full_name": "true_eq_false_of_false", "code": "theorem true_eq_false_of_false : False \u2192 (True = False)", "start": [102, 1], "end": [102, 70], "kind": "commanddeclaration"}, {"full_name": "eq_comm", "code": "theorem eq_comm {a b : \u03b1} : a = b \u2194 b = a", "start": [104, 1], "end": [104, 64], "kind": "commanddeclaration"}, {"full_name": "imp_intro", "code": "@[nolint unusedArguments]\ntheorem imp_intro {\u03b1 \u03b2 : Prop} (h : \u03b1) : \u03b2 \u2192 \u03b1", "start": [108, 1], "end": [109, 61], "kind": "commanddeclaration"}, {"full_name": "imp_imp_imp", "code": "theorem imp_imp_imp {a b c d : Prop} (h\u2080 : c \u2192 a) (h\u2081 : b \u2192 d) : (a \u2192 b) \u2192 (c \u2192 d)", "start": [111, 1], "end": [111, 100], "kind": "commanddeclaration"}, {"full_name": "imp_iff_right", "code": "theorem imp_iff_right {a : Prop} (ha : a) : (a \u2192 b) \u2194 b", "start": [113, 1], "end": [113, 86], "kind": "commanddeclaration"}, {"full_name": "imp_true_iff", "code": "theorem imp_true_iff (\u03b1 : Sort u) : (\u03b1 \u2192 True) \u2194 True", "start": [116, 1], "end": [116, 89], "kind": "commanddeclaration"}, {"full_name": "false_imp_iff", "code": "theorem false_imp_iff (a : Prop) : (False \u2192 a) \u2194 True", "start": [118, 1], "end": [118, 83], "kind": "commanddeclaration"}, {"full_name": "true_imp_iff", "code": "theorem true_imp_iff (\u03b1 : Prop) : (True \u2192 \u03b1) \u2194 \u03b1", "start": [120, 1], "end": [120, 87], "kind": "commanddeclaration"}, {"full_name": "imp_self", "code": "@[simp] theorem imp_self : (a \u2192 a) \u2194 True", "start": [122, 1], "end": [122, 63], "kind": "commanddeclaration"}, {"full_name": "imp_false", "code": "theorem imp_false : (a \u2192 False) \u2194 \u00aca", "start": [124, 1], "end": [124, 48], "kind": "commanddeclaration"}, {"full_name": "imp.swap", "code": "theorem imp.swap : (a \u2192 b \u2192 c) \u2194 (b \u2192 a \u2192 c)", "start": [126, 1], "end": [126, 61], "kind": "commanddeclaration"}, {"full_name": "imp_not_comm", "code": "theorem imp_not_comm : (a \u2192 \u00acb) \u2194 (b \u2192 \u00aca)", "start": [128, 1], "end": [128, 55], "kind": "commanddeclaration"}, {"full_name": "imp_congr_left", "code": "theorem imp_congr_left (h : a \u2194 b) : (a \u2192 c) \u2194 (b \u2192 c)", "start": [130, 1], "end": [131, 59], "kind": "commanddeclaration"}, {"full_name": "imp_congr_right", "code": "theorem imp_congr_right (h : a \u2192 (b \u2194 c)) : (a \u2192 b) \u2194 (a \u2192 c)", "start": [133, 1], "end": [134, 69], "kind": "commanddeclaration"}, {"full_name": "imp_congr_ctx", "code": "theorem imp_congr_ctx (h\u2081 : a \u2194 c) (h\u2082 : c \u2192 (b \u2194 d)) : (a \u2192 b) \u2194 (c \u2192 d)", "start": [136, 1], "end": [137, 49], "kind": "commanddeclaration"}, {"full_name": "imp_congr", "code": "theorem imp_congr (h\u2081 : a \u2194 c) (h\u2082 : b \u2194 d) : (a \u2192 b) \u2194 (c \u2192 d)", "start": [139, 1], "end": [139, 96], "kind": "commanddeclaration"}, {"full_name": "imp_iff_not", "code": "theorem imp_iff_not (hb : \u00acb) : a \u2192 b \u2194 \u00aca", "start": [141, 1], "end": [141, 90], "kind": "commanddeclaration"}, {"full_name": "And.elim", "code": "abbrev And.elim (f : a \u2192 b \u2192 \u03b1) (h : a \u2227 b) : \u03b1 := f h.1 h.2", "start": [145, 1], "end": [146, 61], "kind": "commanddeclaration"}, {"full_name": "And.symm", "code": "theorem And.symm : a \u2227 b \u2192 b \u2227 a", "start": [148, 1], "end": [148, 56], "kind": "commanddeclaration"}, {"full_name": "And.imp", "code": "theorem And.imp (f : a \u2192 c) (g : b \u2192 d) (h : a \u2227 b) : c \u2227 d", "start": [150, 1], "end": [150, 78], "kind": "commanddeclaration"}, {"full_name": "And.imp_left", "code": "theorem And.imp_left (h : a \u2192 b) : a \u2227 c \u2192 b \u2227 c", "start": [152, 1], "end": [152, 62], "kind": "commanddeclaration"}, {"full_name": "And.imp_right", "code": "theorem And.imp_right (h : a \u2192 b) : c \u2227 a \u2192 c \u2227 b", "start": [154, 1], "end": [154, 63], "kind": "commanddeclaration"}, {"full_name": "and_congr", "code": "theorem and_congr (h\u2081 : a \u2194 c) (h\u2082 : b \u2194 d) : a \u2227 b \u2194 c \u2227 d", "start": [156, 1], "end": [157, 41], "kind": "commanddeclaration"}, {"full_name": "and_comm", "code": "theorem and_comm : a \u2227 b \u2194 b \u2227 a", "start": [159, 1], "end": [159, 45], "kind": "commanddeclaration"}, {"full_name": "and_congr_right", "code": "theorem and_congr_right (h : a \u2192 (b \u2194 c)) : a \u2227 b \u2194 a \u2227 c", "start": [161, 1], "end": [162, 71], "kind": "commanddeclaration"}, {"full_name": "and_congr_left", "code": "theorem and_congr_left (h : c \u2192 (a \u2194 b)) : a \u2227 c \u2194 b \u2227 c", "start": [164, 1], "end": [165, 55], "kind": "commanddeclaration"}, {"full_name": "and_congr_left'", "code": "theorem and_congr_left' (h : a \u2194 b) : a \u2227 c \u2194 b \u2227 c", "start": [167, 1], "end": [167, 72], "kind": "commanddeclaration"}, {"full_name": "and_congr_right'", "code": "theorem and_congr_right' (h : b \u2194 c) : a \u2227 b \u2194 a \u2227 c", "start": [169, 1], "end": [169, 73], "kind": "commanddeclaration"}, {"full_name": "and_congr_right_eq", "code": "theorem and_congr_right_eq (h : a \u2192 b = c) : (a \u2227 b) = (a \u2227 c)", "start": [171, 1], "end": [172, 51], "kind": "commanddeclaration"}, {"full_name": "and_congr_left_eq", "code": "theorem and_congr_left_eq (h : c \u2192 a = b) : (a \u2227 c) = (b \u2227 c)", "start": [174, 1], "end": [175, 50], "kind": "commanddeclaration"}, {"full_name": "and_assoc", "code": "theorem and_assoc : (a \u2227 b) \u2227 c \u2194 a \u2227 (b \u2227 c)", "start": [177, 1], "end": [178, 75], "kind": "commanddeclaration"}, {"full_name": "and_left_comm", "code": "theorem and_left_comm : a \u2227 (b \u2227 c) \u2194 b \u2227 (a \u2227 c)", "start": [180, 1], "end": [181, 47], "kind": "commanddeclaration"}, {"full_name": "and_right_comm", "code": "theorem and_right_comm : (a \u2227 b) \u2227 c \u2194 (a \u2227 c) \u2227 b", "start": [183, 1], "end": [184, 38], "kind": "commanddeclaration"}, {"full_name": "and_rotate", "code": "theorem and_rotate : a \u2227 b \u2227 c \u2194 b \u2227 c \u2227 a", "start": [186, 1], "end": [187, 38], "kind": "commanddeclaration"}, {"full_name": "and_and_and_comm", "code": "theorem and_and_and_comm : (a \u2227 b) \u2227 c \u2227 d \u2194 (a \u2227 c) \u2227 b \u2227 d", "start": [189, 1], "end": [190, 49], "kind": "commanddeclaration"}, {"full_name": "and_and_left", "code": "theorem and_and_left : a \u2227 b \u2227 c \u2194 (a \u2227 b) \u2227 a \u2227 c", "start": [192, 1], "end": [193, 34], "kind": "commanddeclaration"}, {"full_name": "and_and_right", "code": "theorem and_and_right : (a \u2227 b) \u2227 c \u2194 (a \u2227 c) \u2227 b \u2227 c", "start": [195, 1], "end": [196, 34], "kind": "commanddeclaration"}, {"full_name": "and_iff_left_of_imp", "code": "theorem and_iff_left_of_imp (h : a \u2192 b) : (a \u2227 b) \u2194 a", "start": [198, 1], "end": [199, 35], "kind": "commanddeclaration"}, {"full_name": "and_iff_right_of_imp", "code": "theorem and_iff_right_of_imp (h : b \u2192 a) : (a \u2227 b) \u2194 b", "start": [201, 1], "end": [202, 36], "kind": "commanddeclaration"}, {"full_name": "and_iff_left", "code": "theorem and_iff_left (hb : b) : a \u2227 b \u2194 a", "start": [204, 1], "end": [204, 77], "kind": "commanddeclaration"}, {"full_name": "and_iff_right", "code": "theorem and_iff_right (ha : a) : a \u2227 b \u2194 b", "start": [206, 1], "end": [206, 79], "kind": "commanddeclaration"}, {"full_name": "and_iff_left_iff_imp", "code": "@[simp] theorem and_iff_left_iff_imp : ((a \u2227 b) \u2194 a) \u2194 (a \u2192 b)", "start": [208, 1], "end": [209, 48], "kind": "commanddeclaration"}, {"full_name": "and_iff_right_iff_imp", "code": "@[simp] theorem and_iff_right_iff_imp : ((a \u2227 b) \u2194 b) \u2194 (b \u2192 a)", "start": [211, 1], "end": [212, 49], "kind": "commanddeclaration"}, {"full_name": "iff_self_and", "code": "@[simp] theorem iff_self_and : (p \u2194 p \u2227 q) \u2194 (p \u2192 q)", "start": [214, 1], "end": [215, 41], "kind": "commanddeclaration"}, {"full_name": "iff_and_self", "code": "@[simp] theorem iff_and_self : (p \u2194 q \u2227 p) \u2194 (p \u2192 q)", "start": [217, 1], "end": [217, 87], "kind": "commanddeclaration"}, {"full_name": "and_congr_right_iff", "code": "@[simp] theorem and_congr_right_iff : (a \u2227 b \u2194 a \u2227 c) \u2194 (a \u2192 (b \u2194 c))", "start": [219, 1], "end": [220, 60], "kind": "commanddeclaration"}, {"full_name": "and_congr_left_iff", "code": "@[simp] theorem and_congr_left_iff : (a \u2227 c \u2194 b \u2227 c) \u2194 c \u2192 (a \u2194 b)", "start": [222, 1], "end": [223, 46], "kind": "commanddeclaration"}, {"full_name": "and_self_left", "code": "@[simp] theorem and_self_left : a \u2227 a \u2227 b \u2194 a \u2227 b", "start": [225, 1], "end": [226, 52], "kind": "commanddeclaration"}, {"full_name": "and_self_right", "code": "@[simp] theorem and_self_right : (a \u2227 b) \u2227 b \u2194 a \u2227 b", "start": [228, 1], "end": [229, 54], "kind": "commanddeclaration"}, {"full_name": "not_and_of_not_left", "code": "theorem not_and_of_not_left (b : Prop) : \u00aca \u2192 \u00ac(a \u2227 b)", "start": [231, 1], "end": [231, 70], "kind": "commanddeclaration"}, {"full_name": "not_and_of_not_right", "code": "theorem not_and_of_not_right (a : Prop) {b : Prop} : \u00acb \u2192 \u00ac(a \u2227 b)", "start": [233, 1], "end": [233, 83], "kind": "commanddeclaration"}, {"full_name": "and_not_self", "code": "@[simp] theorem and_not_self : \u00ac(a \u2227 \u00aca)", "start": [235, 1], "end": [235, 61], "kind": "commanddeclaration"}, {"full_name": "not_and_self", "code": "@[simp] theorem not_and_self : \u00ac(\u00aca \u2227 a)", "start": [237, 1], "end": [237, 61], "kind": "commanddeclaration"}, {"full_name": "and_not_self_iff", "code": "theorem and_not_self_iff (a : Prop) : a \u2227 \u00aca \u2194 False", "start": [239, 1], "end": [239, 85], "kind": "commanddeclaration"}, {"full_name": "not_and_self_iff", "code": "theorem not_and_self_iff (a : Prop) : \u00aca \u2227 a \u2194 False", "start": [241, 1], "end": [241, 85], "kind": "commanddeclaration"}, {"full_name": "not_not_em", "code": "theorem not_not_em (a : Prop) : \u00ac\u00ac(a \u2228 \u00aca)", "start": [245, 1], "end": [245, 75], "kind": "commanddeclaration"}, {"full_name": "Or.symm", "code": "theorem Or.symm : a \u2228 b \u2192 b \u2228 a", "start": [247, 1], "end": [247, 50], "kind": "commanddeclaration"}, {"full_name": "Or.imp", "code": "theorem Or.imp (f : a \u2192 c) (g : b \u2192 d) (h : a \u2228 b) : c \u2228 d", "start": [249, 1], "end": [249, 89], "kind": "commanddeclaration"}, {"full_name": "Or.imp_left", "code": "theorem Or.imp_left (f : a \u2192 b) : a \u2228 c \u2192 b \u2228 c", "start": [251, 1], "end": [251, 61], "kind": "commanddeclaration"}, {"full_name": "Or.imp_right", "code": "theorem Or.imp_right (f : b \u2192 c) : a \u2228 b \u2192 a \u2228 c", "start": [253, 1], "end": [253, 62], "kind": "commanddeclaration"}, {"full_name": "or_congr", "code": "theorem or_congr (h\u2081 : a \u2194 c) (h\u2082 : b \u2194 d) : (a \u2228 b) \u2194 (c \u2228 d)", "start": [255, 1], "end": [255, 99], "kind": "commanddeclaration"}, {"full_name": "or_congr_left", "code": "theorem or_congr_left (h : a \u2194 b) : a \u2228 c \u2194 b \u2228 c", "start": [257, 1], "end": [257, 69], "kind": "commanddeclaration"}, {"full_name": "or_congr_right", "code": "theorem or_congr_right (h : b \u2194 c) : a \u2228 b \u2194 a \u2228 c", "start": [259, 1], "end": [259, 70], "kind": "commanddeclaration"}, {"full_name": "Or.comm", "code": "theorem Or.comm : a \u2228 b \u2194 b \u2228 a", "start": [261, 1], "end": [261, 54], "kind": "commanddeclaration"}, {"full_name": "or_comm", "code": "theorem or_comm : a \u2228 b \u2194 b \u2228 a", "start": [263, 1], "end": [263, 43], "kind": "commanddeclaration"}, {"full_name": "or_assoc", "code": "theorem or_assoc : (a \u2228 b) \u2228 c \u2194 a \u2228 (b \u2228 c)", "start": [265, 1], "end": [266, 78], "kind": "commanddeclaration"}, {"full_name": "Or.resolve_left", "code": "theorem Or.resolve_left {a b : Prop} (h: a \u2228 b) (na : \u00aca) : b", "start": [268, 1], "end": [268, 89], "kind": "commanddeclaration"}, {"full_name": "Or.neg_resolve_left", "code": "theorem Or.neg_resolve_left (h : \u00aca \u2228 b) (ha : a) : b", "start": [270, 1], "end": [270, 79], "kind": "commanddeclaration"}, {"full_name": "Or.resolve_right", "code": "theorem Or.resolve_right {a b : Prop} (h: a \u2228 b) (nb : \u00acb) : a", "start": [272, 1], "end": [272, 90], "kind": "commanddeclaration"}, {"full_name": "Or.neg_resolve_right", "code": "theorem Or.neg_resolve_right (h : a \u2228 \u00acb) (nb : b) : a", "start": [274, 1], "end": [274, 80], "kind": "commanddeclaration"}, {"full_name": "or_left_comm", "code": "theorem or_left_comm : a \u2228 (b \u2228 c) \u2194 b \u2228 (a \u2228 c)", "start": [276, 1], "end": [276, 97], "kind": "commanddeclaration"}, {"full_name": "or_right_comm", "code": "theorem or_right_comm : (a \u2228 b) \u2228 c \u2194 (a \u2228 c) \u2228 b", "start": [278, 1], "end": [278, 92], "kind": "commanddeclaration"}, {"full_name": "or_or_or_comm", "code": "theorem or_or_or_comm : (a \u2228 b) \u2228 c \u2228 d \u2194 (a \u2228 c) \u2228 b \u2228 d", "start": [280, 1], "end": [281, 46], "kind": "commanddeclaration"}, {"full_name": "or_or_distrib_left", "code": "theorem or_or_distrib_left : a \u2228 b \u2228 c \u2194 (a \u2228 b) \u2228 a \u2228 c", "start": [283, 1], "end": [283, 91], "kind": "commanddeclaration"}, {"full_name": "or_or_distrib_right", "code": "theorem or_or_distrib_right : (a \u2228 b) \u2228 c \u2194 (a \u2228 c) \u2228 b \u2228 c", "start": [285, 1], "end": [285, 94], "kind": "commanddeclaration"}, {"full_name": "or_rotate", "code": "theorem or_rotate : a \u2228 b \u2228 c \u2194 b \u2228 c \u2228 a", "start": [287, 1], "end": [287, 82], "kind": "commanddeclaration"}, {"full_name": "or_iff_right_of_imp", "code": "theorem or_iff_right_of_imp (ha : a \u2192 b) : (a \u2228 b) \u2194 b", "start": [289, 1], "end": [289, 79], "kind": "commanddeclaration"}, {"full_name": "or_iff_left_of_imp", "code": "theorem or_iff_left_of_imp (hb : b \u2192 a) : (a \u2228 b) \u2194 a", "start": [291, 1], "end": [291, 78], "kind": "commanddeclaration"}, {"full_name": "not_or_intro", "code": "theorem not_or_intro {a b : Prop} (ha : \u00aca) (hb : \u00acb) : \u00ac(a \u2228 b)", "start": [293, 1], "end": [293, 83], "kind": "commanddeclaration"}, {"full_name": "or_iff_left_iff_imp", "code": "@[simp] theorem or_iff_left_iff_imp : (a \u2228 b \u2194 a) \u2194 (b \u2192 a)", "start": [295, 1], "end": [296, 52], "kind": "commanddeclaration"}, {"full_name": "or_iff_right_iff_imp", "code": "@[simp] theorem or_iff_right_iff_imp : (a \u2228 b \u2194 b) \u2194 (a \u2192 b)", "start": [298, 1], "end": [299, 36], "kind": "commanddeclaration"}, {"full_name": "or_iff_left", "code": "theorem or_iff_left (hb : \u00acb) : a \u2228 b \u2194 a", "start": [301, 1], "end": [301, 75], "kind": "commanddeclaration"}, {"full_name": "or_iff_right", "code": "theorem or_iff_right (ha : \u00aca) : a \u2228 b \u2194 b", "start": [303, 1], "end": [303, 77], "kind": "commanddeclaration"}, {"full_name": "not_imp_of_and_not", "code": "theorem not_imp_of_and_not : a \u2227 \u00acb \u2192 \u00ac(a \u2192 b)", "start": [307, 1], "end": [308, 30], "kind": "commanddeclaration"}, {"full_name": "imp_and", "code": "theorem imp_and {\u03b1} : (\u03b1 \u2192 b \u2227 c) \u2194 (\u03b1 \u2192 b) \u2227 (\u03b1 \u2192 c)", "start": [310, 1], "end": [311, 84], "kind": "commanddeclaration"}, {"full_name": "and_imp", "code": "@[simp] theorem and_imp : (a \u2227 b \u2192 c) \u2194 (a \u2192 b \u2192 c)", "start": [313, 1], "end": [314, 57], "kind": "commanddeclaration"}, {"full_name": "not_and", "code": "@[simp] theorem not_and : \u00ac(a \u2227 b) \u2194 (a \u2192 \u00acb)", "start": [316, 1], "end": [316, 57], "kind": "commanddeclaration"}, {"full_name": "not_and'", "code": "theorem not_and' : \u00ac(a \u2227 b) \u2194 b \u2192 \u00aca", "start": [318, 1], "end": [318, 67], "kind": "commanddeclaration"}, {"full_name": "and_or_left", "code": "theorem and_or_left : a \u2227 (b \u2228 c) \u2194 (a \u2227 b) \u2228 (a \u2227 c)", "start": [320, 1], "end": [322, 97], "kind": "commanddeclaration"}, {"full_name": "or_and_right", "code": "theorem or_and_right : (a \u2228 b) \u2227 c \u2194 (a \u2227 c) \u2228 (b \u2227 c)", "start": [324, 1], "end": [326, 31], "kind": "commanddeclaration"}, {"full_name": "or_and_left", "code": "theorem or_and_left : a \u2228 (b \u2227 c) \u2194 (a \u2228 b) \u2227 (a \u2228 c)", "start": [328, 1], "end": [331, 60], "kind": "commanddeclaration"}, {"full_name": "and_or_right", "code": "theorem and_or_right : (a \u2227 b) \u2228 c \u2194 (a \u2228 c) \u2227 (b \u2228 c)", "start": [333, 1], "end": [335, 30], "kind": "commanddeclaration"}, {"full_name": "or_imp", "code": "theorem or_imp : (a \u2228 b \u2192 c) \u2194 (a \u2192 c) \u2227 (b \u2192 c)", "start": [337, 1], "end": [338, 64], "kind": "commanddeclaration"}, {"full_name": "not_or", "code": "theorem not_or : \u00ac(p \u2228 q) \u2194 \u00acp \u2227 \u00acq", "start": [340, 1], "end": [340, 46], "kind": "commanddeclaration"}, {"full_name": "not_and_of_not_or_not", "code": "theorem not_and_of_not_or_not (h : \u00aca \u2228 \u00acb) : \u00ac(a \u2227 b)", "start": [342, 1], "end": [342, 87], "kind": "commanddeclaration"}, {"full_name": "or_self_left", "code": "@[simp] theorem or_self_left : a \u2228 a \u2228 b \u2194 a \u2228 b", "start": [344, 1], "end": [344, 92], "kind": "commanddeclaration"}, {"full_name": "or_self_right", "code": "@[simp] theorem or_self_right : (a \u2228 b) \u2228 b \u2194 a \u2228 b", "start": [346, 1], "end": [346, 95], "kind": "commanddeclaration"}, {"full_name": "forall_imp", "code": "theorem forall_imp (h : \u2200 a, p a \u2192 q a) : (\u2200 a, p a) \u2192 \u2200 a, q a", "start": [353, 1], "end": [354, 23], "kind": "commanddeclaration"}, {"full_name": "forall_exists_index", "code": "@[simp] theorem forall_exists_index {q : (\u2203 x, p x) \u2192 Prop} :\n    (\u2200 h, q h) \u2194 \u2200 x (h : p x), q \u27e8x, h\u27e9", "start": [356, 1], "end": [358, 57], "kind": "commanddeclaration"}, {"full_name": "Exists.imp", "code": "theorem Exists.imp (h : \u2200 a, p a \u2192 q a) : (\u2203 a, p a) \u2192 \u2203 a, q a", "start": [360, 1], "end": [361, 27], "kind": "commanddeclaration"}, {"full_name": "Exists.imp'", "code": "theorem Exists.imp' {\u03b2} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (hpq : \u2200 a, p a \u2192 q (f a)) :\n    (\u2203 a, p a) \u2192 \u2203 b, q b", "start": [363, 1], "end": [365, 29], "kind": "commanddeclaration"}, {"full_name": "exists_imp", "code": "theorem exists_imp : ((\u2203 x, p x) \u2192 b) \u2194 \u2200 x, p x \u2192 b", "start": [367, 1], "end": [367, 76], "kind": "commanddeclaration"}, {"full_name": "exists_const", "code": "@[simp] theorem exists_const (\u03b1) [i : Nonempty \u03b1] : (\u2203 _ : \u03b1, b) \u2194 b", "start": [369, 1], "end": [370, 41], "kind": "commanddeclaration"}, {"full_name": "forall_congr'", "code": "theorem forall_congr' (h : \u2200 a, p a \u2194 q a) : (\u2200 a, p a) \u2194 \u2200 a, q a", "start": [376, 1], "end": [377, 55], "kind": "commanddeclaration"}, {"full_name": "exists_congr", "code": "theorem exists_congr (h : \u2200 a, p a \u2194 q a) : (\u2203 a, p a) \u2194 \u2203 a, q a", "start": [379, 1], "end": [380, 61], "kind": "commanddeclaration"}, {"full_name": "forall\u2082_congr", "code": "theorem forall\u2082_congr {p q : \u2200 a, \u03b2 a \u2192 Prop} (h : \u2200 a b, p a b \u2194 q a b) :\n    (\u2200 a b, p a b) \u2194 \u2200 a b, q a b", "start": [383, 1], "end": [385, 46], "kind": "commanddeclaration"}, {"full_name": "exists\u2082_congr", "code": "theorem exists\u2082_congr {p q : \u2200 a, \u03b2 a \u2192 Prop} (h : \u2200 a b, p a b \u2194 q a b) :\n    (\u2203 a b, p a b) \u2194 \u2203 a b, q a b", "start": [387, 1], "end": [389, 44], "kind": "commanddeclaration"}, {"full_name": "forall\u2083_congr", "code": "theorem forall\u2083_congr {p q : \u2200 a b, \u03b3 a b \u2192 Prop} (h : \u2200 a b c, p a b c \u2194 q a b c) :\n    (\u2200 a b c, p a b c) \u2194 \u2200 a b c, q a b c", "start": [392, 1], "end": [394, 46], "kind": "commanddeclaration"}, {"full_name": "exists\u2083_congr", "code": "theorem exists\u2083_congr {p q : \u2200 a b, \u03b3 a b \u2192 Prop} (h : \u2200 a b c, p a b c \u2194 q a b c) :\n    (\u2203 a b c, p a b c) \u2194 \u2203 a b c, q a b c", "start": [396, 1], "end": [398, 45], "kind": "commanddeclaration"}, {"full_name": "forall\u2084_congr", "code": "theorem forall\u2084_congr {p q : \u2200 a b c, \u03b4 a b c \u2192 Prop} (h : \u2200 a b c d, p a b c d \u2194 q a b c d) :\n    (\u2200 a b c d, p a b c d) \u2194 \u2200 a b c d, q a b c d", "start": [401, 1], "end": [403, 46], "kind": "commanddeclaration"}, {"full_name": "exists\u2084_congr", "code": "theorem exists\u2084_congr {p q : \u2200 a b c, \u03b4 a b c \u2192 Prop} (h : \u2200 a b c d, p a b c d \u2194 q a b c d) :\n    (\u2203 a b c d, p a b c d) \u2194 \u2203 a b c d, q a b c d", "start": [405, 1], "end": [407, 45], "kind": "commanddeclaration"}, {"full_name": "forall\u2085_congr", "code": "theorem forall\u2085_congr {p q : \u2200 a b c d, \u03b5 a b c d \u2192 Prop}\n    (h : \u2200 a b c d e, p a b c d e \u2194 q a b c d e) :\n    (\u2200 a b c d e, p a b c d e) \u2194 \u2200 a b c d e, q a b c d e", "start": [410, 1], "end": [413, 46], "kind": "commanddeclaration"}, {"full_name": "exists\u2085_congr", "code": "theorem exists\u2085_congr {p q : \u2200 a b c d, \u03b5 a b c d \u2192 Prop}\n    (h : \u2200 a b c d e, p a b c d e \u2194 q a b c d e) :\n    (\u2203 a b c d e, p a b c d e) \u2194 \u2203 a b c d e, q a b c d e", "start": [415, 1], "end": [418, 45], "kind": "commanddeclaration"}, {"full_name": "not_exists", "code": "@[simp] theorem not_exists : (\u00ac\u2203 x, p x) \u2194 \u2200 x, \u00acp x", "start": [422, 1], "end": [422, 67], "kind": "commanddeclaration"}, {"full_name": "forall_not_of_not_exists", "code": "theorem forall_not_of_not_exists (hne : \u00ac\u2203 x, p x) (x) : \u00acp x", "start": [424, 1], "end": [424, 82], "kind": "commanddeclaration"}, {"full_name": "forall_and", "code": "theorem forall_and : (\u2200 x, p x \u2227 q x) \u2194 (\u2200 x, p x) \u2227 (\u2200 x, q x)", "start": [426, 1], "end": [427, 82], "kind": "commanddeclaration"}, {"full_name": "exists_or", "code": "theorem exists_or : (\u2203 x, p x \u2228 q x) \u2194 (\u2203 x, p x) \u2228 \u2203 x, q x", "start": [429, 1], "end": [431, 66], "kind": "commanddeclaration"}, {"full_name": "exists_false", "code": "@[simp] theorem exists_false : \u00ac(\u2203 _a : \u03b1, False)", "start": [433, 1], "end": [433, 69], "kind": "commanddeclaration"}, {"full_name": "forall_const", "code": "@[simp] theorem forall_const (\u03b1 : Sort _) [i : Nonempty \u03b1] : (\u03b1 \u2192 b) \u2194 b", "start": [435, 1], "end": [436, 27], "kind": "commanddeclaration"}, {"full_name": "Exists.nonempty", "code": "theorem Exists.nonempty : (\u2203 x, p x) \u2192 Nonempty \u03b1", "start": [438, 1], "end": [438, 66], "kind": "commanddeclaration"}, {"full_name": "Exists.choose", "code": "@[reducible] noncomputable def Exists.choose (P : \u2203 a, p a) : \u03b1 := Classical.choose P", "start": [440, 1], "end": [442, 86], "kind": "commanddeclaration"}, {"full_name": "Exists.choose_spec", "code": "theorem Exists.choose_spec {p : \u03b1 \u2192 Prop} (P : \u2203 a, p a) : p P.choose", "start": [444, 1], "end": [445, 97], "kind": "commanddeclaration"}, {"full_name": "not_forall_of_exists_not", "code": "theorem not_forall_of_exists_not {p : \u03b1 \u2192 Prop} : (\u2203 x, \u00acp x) \u2192 \u00ac\u2200 x, p x", "start": [447, 1], "end": [448, 27], "kind": "commanddeclaration"}, {"full_name": "forall_eq", "code": "@[simp] theorem forall_eq {p : \u03b1 \u2192 Prop} {a' : \u03b1} : (\u2200 a, a = a' \u2192 p a) \u2194 p a'", "start": [450, 1], "end": [451, 47], "kind": "commanddeclaration"}, {"full_name": "forall_eq'", "code": "@[simp] theorem forall_eq' {a' : \u03b1} : (\u2200 a, a' = a \u2192 p a) \u2194 p a'", "start": [453, 1], "end": [453, 92], "kind": "commanddeclaration"}, {"full_name": "exists_eq", "code": "@[simp] theorem exists_eq : \u2203 a, a = a'", "start": [455, 1], "end": [455, 52], "kind": "commanddeclaration"}, {"full_name": "exists_eq'", "code": "@[simp] theorem exists_eq' : \u2203 a, a' = a", "start": [457, 1], "end": [457, 53], "kind": "commanddeclaration"}, {"full_name": "exists_eq_left", "code": "@[simp] theorem exists_eq_left : (\u2203 a, a = a' \u2227 p a) \u2194 p a'", "start": [459, 1], "end": [460, 49], "kind": "commanddeclaration"}, {"full_name": "exists_eq_right", "code": "@[simp] theorem exists_eq_right : (\u2203 a, p a \u2227 a = a') \u2194 p a'", "start": [462, 1], "end": [463, 68], "kind": "commanddeclaration"}, {"full_name": "exists_and_left", "code": "@[simp] theorem exists_and_left : (\u2203 x, b \u2227 p x) \u2194 b \u2227 (\u2203 x, p x)", "start": [465, 1], "end": [466, 63], "kind": "commanddeclaration"}, {"full_name": "exists_and_right", "code": "@[simp] theorem exists_and_right : (\u2203 x, p x \u2227 b) \u2194 (\u2203 x, p x) \u2227 b", "start": [468, 1], "end": [468, 89], "kind": "commanddeclaration"}, {"full_name": "exists_eq_left'", "code": "@[simp] theorem exists_eq_left' : (\u2203 a, a' = a \u2227 p a) \u2194 p a'", "start": [470, 1], "end": [470, 88], "kind": "commanddeclaration"}, {"full_name": "forall_eq_or_imp", "code": "@[simp] theorem forall_eq_or_imp : (\u2200 a, a = a' \u2228 q a \u2192 p a) \u2194 p a' \u2227 \u2200 a, q a \u2192 p a", "start": [473, 1], "end": [474, 44], "kind": "commanddeclaration"}, {"full_name": "exists_eq_or_imp", "code": "@[simp] theorem exists_eq_or_imp : (\u2203 a, (a = a' \u2228 q a) \u2227 p a) \u2194 p a' \u2228 \u2203 a, q a \u2227 p a", "start": [476, 1], "end": [477, 54], "kind": "commanddeclaration"}, {"full_name": "exists_eq_right_right", "code": "@[simp] theorem exists_eq_right_right : (\u2203 (a : \u03b1), p a \u2227 b \u2227 a = a') \u2194 p a' \u2227 b", "start": [479, 1], "end": [480, 21], "kind": "commanddeclaration"}, {"full_name": "exists_eq_right_right'", "code": "@[simp] theorem exists_eq_right_right' : (\u2203 (a : \u03b1), p a \u2227 b \u2227 a' = a) \u2194 p a' \u2227 b", "start": [482, 1], "end": [483, 38], "kind": "commanddeclaration"}, {"full_name": "exists_prop", "code": "@[simp] theorem exists_prop : (\u2203 _h : a, b) \u2194 a \u2227 b", "start": [485, 1], "end": [486, 55], "kind": "commanddeclaration"}, {"full_name": "exists_apply_eq_apply", "code": "@[simp] theorem exists_apply_eq_apply (f : \u03b1 \u2192 \u03b2) (a' : \u03b1) : \u2203 a, f a = f a'", "start": [488, 1], "end": [488, 90], "kind": "commanddeclaration"}, {"full_name": "forall_prop_of_true", "code": "theorem forall_prop_of_true {p : Prop} {q : p \u2192 Prop} (h : p) : (\u2200 h' : p, q h') \u2194 q h", "start": [490, 1], "end": [491, 28], "kind": "commanddeclaration"}, {"full_name": "forall_comm", "code": "theorem forall_comm {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2200 a b, p a b) \u2194 (\u2200 b a, p a b)", "start": [493, 1], "end": [494, 43], "kind": "commanddeclaration"}, {"full_name": "exists_comm", "code": "theorem exists_comm {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2203 a b, p a b) \u2194 (\u2203 b a, p a b)", "start": [496, 1], "end": [497, 59], "kind": "commanddeclaration"}, {"full_name": "forall_apply_eq_imp_iff", "code": "@[simp] theorem forall_apply_eq_imp_iff {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} :\n    (\u2200 b a, f a = b \u2192 p b) \u2194 \u2200 a, p (f a)", "start": [499, 1], "end": [500, 67], "kind": "commanddeclaration"}, {"full_name": "forall_eq_apply_imp_iff", "code": "@[simp] theorem forall_eq_apply_imp_iff {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} :\n    (\u2200 b a, b = f a \u2192 p b) \u2194 \u2200 a, p (f a)", "start": [502, 1], "end": [503, 67], "kind": "commanddeclaration"}, {"full_name": "forall_apply_eq_imp_iff\u2082", "code": "@[simp] theorem forall_apply_eq_imp_iff\u2082 {f : \u03b1 \u2192 \u03b2} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} :\n    (\u2200 b a, p a \u2192 f a = b \u2192 q b) \u2194 \u2200 a, p a \u2192 q (f a)", "start": [505, 1], "end": [507, 67], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_not", "code": "theorem Decidable.not_not [Decidable p] : \u00ac\u00acp \u2194 p", "start": [513, 1], "end": [513, 81], "kind": "commanddeclaration"}, {"full_name": "Decidable.by_contra", "code": "theorem Decidable.by_contra [Decidable p] : (\u00acp \u2192 False) \u2192 p", "start": [515, 1], "end": [515, 75], "kind": "commanddeclaration"}, {"full_name": "Or.by_cases", "code": "protected def Or.by_cases [Decidable p] {\u03b1 : Sort u} (h : p \u2228 q) (h\u2081 : p \u2192 \u03b1) (h\u2082 : q \u2192 \u03b1) : \u03b1 :=\n  if hp : p then h\u2081 hp else h\u2082 (h.resolve_left hp)", "start": [517, 1], "end": [519, 51], "kind": "commanddeclaration"}, {"full_name": "Or.by_cases'", "code": "protected def Or.by_cases' [Decidable q] {\u03b1 : Sort u} (h : p \u2228 q) (h\u2081 : p \u2192 \u03b1) (h\u2082 : q \u2192 \u03b1) : \u03b1 :=\n  if hq : q then h\u2082 hq else h\u2081 (h.resolve_right hq)", "start": [521, 1], "end": [523, 52], "kind": "commanddeclaration"}, {"full_name": "exists_prop_decidable", "code": "instance exists_prop_decidable {p} (P : p \u2192 Prop)\n  [Decidable p] [\u2200 h, Decidable (P h)] : Decidable (\u2203 h, P h) :=\nif h : p then\n  decidable_of_decidable_of_iff \u27e8fun h2 => \u27e8h, h2\u27e9, fun \u27e8_, h2\u27e9 => h2\u27e9\nelse isFalse fun \u27e8h', _\u27e9 => h h'", "start": [525, 1], "end": [529, 33], "kind": "commanddeclaration"}, {"full_name": "forall_prop_decidable", "code": "instance forall_prop_decidable {p} (P : p \u2192 Prop)\n  [Decidable p] [\u2200 h, Decidable (P h)] : Decidable (\u2200 h, P h) :=\nif h : p then\n  decidable_of_decidable_of_iff \u27e8fun h2 _ => h2, fun al => al h\u27e9\nelse isTrue fun h2 => absurd h2 h", "start": [531, 1], "end": [535, 34], "kind": "commanddeclaration"}, {"full_name": "decide_eq_true_iff", "code": "theorem decide_eq_true_iff (p : Prop) [Decidable p] : (decide p = true) \u2194 p", "start": [537, 1], "end": [537, 87], "kind": "commanddeclaration"}, {"full_name": "decide_eq_false_iff_not", "code": "@[simp] theorem decide_eq_false_iff_not (p : Prop) [Decidable p] : (decide p = false) \u2194 \u00acp", "start": [539, 1], "end": [540, 40], "kind": "commanddeclaration"}, {"full_name": "decide_eq_decide", "code": "@[simp] theorem decide_eq_decide {p q : Prop} [Decidable p] [Decidable q] :\n    decide p = decide q \u2194 (p \u2194 q)", "start": [542, 1], "end": [544, 89], "kind": "commanddeclaration"}, {"full_name": "Decidable.of_not_imp", "code": "theorem Decidable.of_not_imp [Decidable a] (h : \u00ac(a \u2192 b)) : a", "start": [546, 1], "end": [547, 41], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_imp_symm", "code": "theorem Decidable.not_imp_symm [Decidable a] (h : \u00aca \u2192 b) (hb : \u00acb) : a", "start": [549, 1], "end": [550, 28], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_imp_comm", "code": "theorem Decidable.not_imp_comm [Decidable a] [Decidable b] : (\u00aca \u2192 b) \u2194 (\u00acb \u2192 a)", "start": [552, 1], "end": [553, 31], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_imp_self", "code": "theorem Decidable.not_imp_self [Decidable a] : (\u00aca \u2192 a) \u2194 a", "start": [555, 1], "end": [556, 52], "kind": "commanddeclaration"}, {"full_name": "Decidable.or_iff_not_imp_left", "code": "theorem Decidable.or_iff_not_imp_left [Decidable a] : a \u2228 b \u2194 (\u00aca \u2192 b)", "start": [558, 1], "end": [559, 53], "kind": "commanddeclaration"}, {"full_name": "Decidable.or_iff_not_imp_right", "code": "theorem Decidable.or_iff_not_imp_right [Decidable b] : a \u2228 b \u2194 (\u00acb \u2192 a)", "start": [561, 1], "end": [562, 34], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_imp_not", "code": "theorem Decidable.not_imp_not [Decidable a] : (\u00aca \u2192 \u00acb) \u2194 (b \u2192 a)", "start": [564, 1], "end": [565, 43], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_or_of_imp", "code": "theorem Decidable.not_or_of_imp [Decidable a] (h : a \u2192 b) : \u00aca \u2228 b", "start": [567, 1], "end": [568, 42], "kind": "commanddeclaration"}, {"full_name": "Decidable.imp_iff_not_or", "code": "theorem Decidable.imp_iff_not_or [Decidable a] : (a \u2192 b) \u2194 (\u00aca \u2228 b)", "start": [570, 1], "end": [571, 39], "kind": "commanddeclaration"}, {"full_name": "Decidable.imp_iff_or_not", "code": "theorem Decidable.imp_iff_or_not [Decidable b] : b \u2192 a \u2194 a \u2228 \u00acb", "start": [573, 1], "end": [574, 41], "kind": "commanddeclaration"}, {"full_name": "Decidable.imp_or", "code": "theorem Decidable.imp_or [Decidable a] : (a \u2192 b \u2228 c) \u2194 (a \u2192 b) \u2228 (a \u2192 c)", "start": [576, 1], "end": [577, 26], "kind": "commanddeclaration"}, {"full_name": "Decidable.imp_or'", "code": "theorem Decidable.imp_or' [Decidable b] : (a \u2192 b \u2228 c) \u2194 (a \u2192 b) \u2228 (a \u2192 c)", "start": [579, 1], "end": [581, 88], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_imp", "code": "theorem Decidable.not_imp [Decidable a] : \u00ac(a \u2192 b) \u2194 a \u2227 \u00acb", "start": [583, 1], "end": [584, 66], "kind": "commanddeclaration"}, {"full_name": "Decidable.peirce", "code": "theorem Decidable.peirce (a b : Prop) [Decidable a] : ((a \u2192 b) \u2192 a) \u2192 a", "start": [586, 1], "end": [587, 53], "kind": "commanddeclaration"}, {"full_name": "peirce'", "code": "theorem peirce' {a : Prop} (H : \u2200 b : Prop, (a \u2192 b) \u2192 a) : a", "start": [589, 1], "end": [589, 71], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_iff_not", "code": "theorem Decidable.not_iff_not [Decidable a] [Decidable b] : (\u00aca \u2194 \u00acb) \u2194 (a \u2194 b)", "start": [591, 1], "end": [592, 75], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_iff_comm", "code": "theorem Decidable.not_iff_comm [Decidable a] [Decidable b] : (\u00aca \u2194 b) \u2194 (\u00acb \u2194 a)", "start": [594, 1], "end": [595, 79], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_iff", "code": "theorem Decidable.not_iff [Decidable b] : \u00ac(a \u2194 b) \u2194 (\u00aca \u2194 b)", "start": [597, 1], "end": [598, 51], "kind": "commanddeclaration"}, {"full_name": "Decidable.iff_not_comm", "code": "theorem Decidable.iff_not_comm [Decidable a] [Decidable b] : (a \u2194 \u00acb) \u2194 (b \u2194 \u00aca)", "start": [600, 1], "end": [601, 73], "kind": "commanddeclaration"}, {"full_name": "Decidable.iff_iff_and_or_not_and_not", "code": "theorem Decidable.iff_iff_and_or_not_and_not [Decidable b] : (a \u2194 b) \u2194 (a \u2227 b) \u2228 (\u00aca \u2227 \u00acb)", "start": [603, 1], "end": [605, 56], "kind": "commanddeclaration"}, {"full_name": "Decidable.iff_iff_not_or_and_or_not", "code": "theorem Decidable.iff_iff_not_or_and_or_not [Decidable a] [Decidable b] :\n    (a \u2194 b) \u2194 (\u00aca \u2228 b) \u2227 (a \u2228 \u00acb)", "start": [607, 1], "end": [609, 76], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_and_not_right", "code": "theorem Decidable.not_and_not_right [Decidable b] : \u00ac(a \u2227 \u00acb) \u2194 (a \u2192 b)", "start": [611, 1], "end": [612, 76], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_and", "code": "theorem Decidable.not_and [Decidable a] : \u00ac(a \u2227 b) \u2194 \u00aca \u2228 \u00acb", "start": [614, 1], "end": [615, 81], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_and'", "code": "theorem Decidable.not_and' [Decidable b] : \u00ac(a \u2227 b) \u2194 \u00aca \u2228 \u00acb", "start": [617, 1], "end": [618, 81], "kind": "commanddeclaration"}, {"full_name": "Decidable.or_iff_not_and_not", "code": "theorem Decidable.or_iff_not_and_not [Decidable a] [Decidable b] : a \u2228 b \u2194 \u00ac(\u00aca \u2227 \u00acb)", "start": [620, 1], "end": [621, 25], "kind": "commanddeclaration"}, {"full_name": "Decidable.and_iff_not_or_not", "code": "theorem Decidable.and_iff_not_or_not [Decidable a] [Decidable b] : a \u2227 b \u2194 \u00ac(\u00aca \u2228 \u00acb)", "start": [623, 1], "end": [624, 26], "kind": "commanddeclaration"}, {"full_name": "Decidable.imp_iff_right_iff", "code": "theorem Decidable.imp_iff_right_iff [Decidable a] : (a \u2192 b \u2194 b) \u2194 a \u2228 b", "start": [626, 1], "end": [628, 73], "kind": "commanddeclaration"}, {"full_name": "Decidable.and_or_imp", "code": "theorem Decidable.and_or_imp [Decidable a] : a \u2227 b \u2228 (a \u2192 c) \u2194 a \u2192 b \u2228 c", "start": [630, 1], "end": [632, 61], "kind": "commanddeclaration"}, {"full_name": "Decidable.or_congr_left'", "code": "theorem Decidable.or_congr_left' [Decidable c] (h : \u00acc \u2192 (a \u2194 b)) : a \u2228 c \u2194 b \u2228 c", "start": [634, 1], "end": [635, 75], "kind": "commanddeclaration"}, {"full_name": "Decidable.or_congr_right'", "code": "theorem Decidable.or_congr_right' [Decidable a] (h : \u00aca \u2192 (b \u2194 c)) : a \u2228 b \u2194 a \u2228 c", "start": [637, 1], "end": [638, 73], "kind": "commanddeclaration"}, {"full_name": "decidable_of_iff", "code": "@[inline] def decidable_of_iff (a : Prop) (h : a \u2194 b) [Decidable a] : Decidable b :=\n  decidable_of_decidable_of_iff h", "start": [640, 1], "end": [645, 34], "kind": "commanddeclaration"}, {"full_name": "decidable_of_iff'", "code": "@[inline] def decidable_of_iff' (b : Prop) (h : a \u2194 b) [Decidable b] : Decidable a :=\n  decidable_of_decidable_of_iff h.symm", "start": [647, 1], "end": [650, 39], "kind": "commanddeclaration"}, {"full_name": "Decidable.predToBool", "code": "instance Decidable.predToBool (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    CoeDep (\u03b1 \u2192 Prop) p (\u03b1 \u2192 Bool) := \u27e8fun b => decide <| p b\u27e9", "start": [652, 1], "end": [653, 63], "kind": "commanddeclaration"}, {"full_name": "Bool.false_ne_true", "code": "theorem Bool.false_ne_true : false \u2260 true", "start": [655, 1], "end": [655, 50], "kind": "commanddeclaration"}, {"full_name": "decidable_of_bool", "code": "def decidable_of_bool : \u2200 (b : Bool), (b \u2194 a) \u2192 Decidable a\n  | true, h => isTrue (h.1 rfl)\n  | false, h => isFalse (mt h.2 Bool.false_ne_true)", "start": [657, 1], "end": [661, 52], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_forall", "code": "protected theorem Decidable.not_forall {p : \u03b1 \u2192 Prop} [Decidable (\u2203 x, \u00acp x)]\n    [\u2200 x, Decidable (p x)] : (\u00ac\u2200 x, p x) \u2194 \u2203 x, \u00acp x", "start": [663, 1], "end": [666, 29], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_forall_not", "code": "protected theorem Decidable.not_forall_not {p : \u03b1 \u2192 Prop} [Decidable (\u2203 x, p x)] :\n    (\u00ac\u2200 x, \u00acp x) \u2194 \u2203 x, p x", "start": [668, 1], "end": [670, 89], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_exists_not", "code": "protected theorem Decidable.not_exists_not {p : \u03b1 \u2192 Prop} [\u2200 x, Decidable (p x)] :\n    (\u00ac\u2203 x, \u00acp x) \u2194 \u2200 x, p x", "start": [672, 1], "end": [674, 44], "kind": "commanddeclaration"}, {"full_name": "Classical.not_not", "code": "@[scoped simp] theorem not_not : \u00ac\u00aca \u2194 a", "start": [680, 1], "end": [683, 62], "kind": "commanddeclaration"}, {"full_name": "Classical.not_forall", "code": "@[simp]\ntheorem not_forall {p : \u03b1 \u2192 Prop} : (\u00ac\u2200 x, p x) \u2194 \u2203 x, \u00acp x", "start": [685, 1], "end": [687, 23], "kind": "commanddeclaration"}, {"full_name": "Classical.not_forall_not", "code": "theorem not_forall_not {p : \u03b1 \u2192 Prop} : (\u00ac\u2200 x, \u00acp x) \u2194 \u2203 x, p x", "start": [689, 1], "end": [689, 92], "kind": "commanddeclaration"}, {"full_name": "Classical.not_exists_not", "code": "theorem not_exists_not {p : \u03b1 \u2192 Prop} : (\u00ac\u2203 x, \u00acp x) \u2194 \u2200 x, p x", "start": [691, 1], "end": [691, 92], "kind": "commanddeclaration"}, {"full_name": "Classical.forall_or_exists_not", "code": "theorem forall_or_exists_not (P : \u03b1 \u2192 Prop) : (\u2200 a, P a) \u2228 \u2203 a, \u00ac P a", "start": [693, 1], "end": [694, 32], "kind": "commanddeclaration"}, {"full_name": "Classical.exists_or_forall_not", "code": "theorem exists_or_forall_not (P : \u03b1 \u2192 Prop) : (\u2203 a, P a) \u2228 \u2200 a, \u00ac P a", "start": [696, 1], "end": [697, 32], "kind": "commanddeclaration"}, {"full_name": "heq_iff_eq", "code": "theorem heq_iff_eq : HEq a b \u2194 a = b", "start": [703, 1], "end": [703, 63], "kind": "commanddeclaration"}, {"full_name": "proof_irrel_heq", "code": "theorem proof_irrel_heq {p q : Prop} (hp : p) (hq : q) : HEq hp hq", "start": [705, 1], "end": [706, 41], "kind": "commanddeclaration"}, {"full_name": "eq_rec_constant", "code": "@[simp] theorem eq_rec_constant {\u03b1 : Sort _} {a a' : \u03b1} {\u03b2 : Sort _} (y : \u03b2) (h : a = a') :\n    (@Eq.rec \u03b1 a (fun \u03b1 _ => \u03b2) y a' h) = y", "start": [708, 1], "end": [709, 63], "kind": "commanddeclaration"}, {"full_name": "congrArg\u2082", "code": "theorem congrArg\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {x x' : \u03b1} {y y' : \u03b2}\n    (hx : x = x') (hy : y = y') : f x y = f x' y'", "start": [711, 1], "end": [712, 73], "kind": "commanddeclaration"}, {"full_name": "ne_of_mem_of_not_mem", "code": "theorem ne_of_mem_of_not_mem (h : a \u2208 s) : b \u2209 s \u2192 a \u2260 b", "start": [719, 1], "end": [719, 78], "kind": "commanddeclaration"}, {"full_name": "ne_of_mem_of_not_mem'", "code": "theorem ne_of_mem_of_not_mem' (h : a \u2208 s) : a \u2209 t \u2192 s \u2260 t", "start": [721, 1], "end": [721, 79], "kind": "commanddeclaration"}, {"full_name": "if_true", "code": "@[simp] theorem if_true {h : Decidable True} (t e : \u03b1) : ite True t e = t", "start": [727, 1], "end": [727, 92], "kind": "commanddeclaration"}, {"full_name": "if_false", "code": "@[simp] theorem if_false {h : Decidable False} (t e : \u03b1) : ite False t e = e", "start": [729, 1], "end": [729, 90], "kind": "commanddeclaration"}, {"full_name": "ite_id", "code": "theorem ite_id [Decidable c] {\u03b1} (t : \u03b1) : (if c then t else t) = t", "start": [731, 1], "end": [731, 88], "kind": "commanddeclaration"}, {"full_name": "apply_dite", "code": "theorem apply_dite (f : \u03b1 \u2192 \u03b2) (P : Prop) [Decidable P] (x : P \u2192 \u03b1) (y : \u00acP \u2192 \u03b1) :\n    f (dite P x y) = dite P (fun h => f (x h)) (fun h => f (y h))", "start": [733, 1], "end": [736, 30], "kind": "commanddeclaration"}, {"full_name": "apply_ite", "code": "theorem apply_ite (f : \u03b1 \u2192 \u03b2) (P : Prop) [Decidable P] (x y : \u03b1) :\n    f (ite P x y) = ite P (f x) (f y)", "start": [738, 1], "end": [741, 43], "kind": "commanddeclaration"}, {"full_name": "dite_not", "code": "@[simp] theorem dite_not (P : Prop) [Decidable P]  (x : \u00acP \u2192 \u03b1) (y : \u00ac\u00acP \u2192 \u03b1) :\n    dite (\u00acP) x y = dite P (fun h => y (not_not_intro h)) x", "start": [743, 1], "end": [746, 30], "kind": "commanddeclaration"}, {"full_name": "ite_not", "code": "@[simp] theorem ite_not (P : Prop) [Decidable P] (x y : \u03b1) : ite (\u00acP) x y = ite P y x", "start": [748, 1], "end": [750, 39], "kind": "commanddeclaration"}, {"full_name": "Empty.elim", "code": "def Empty.elim : Empty \u2192 C := fun.", "start": [756, 1], "end": [757, 35], "kind": "commanddeclaration"}, {"full_name": "PEmpty.elim", "code": "def PEmpty.elim : PEmpty \u2192 C := fun.", "start": [763, 1], "end": [764, 37], "kind": "commanddeclaration"}, {"full_name": "not_nonempty_empty", "code": "@[simp] theorem not_nonempty_empty : \u00acNonempty Empty", "start": [770, 1], "end": [770, 74], "kind": "commanddeclaration"}, {"full_name": "not_nonempty_pempty", "code": "@[simp] theorem not_nonempty_pempty : \u00acNonempty PEmpty", "start": [772, 1], "end": [772, 76], "kind": "commanddeclaration"}, {"full_name": "eq_iff_true_of_subsingleton", "code": "theorem eq_iff_true_of_subsingleton [Subsingleton \u03b1] (x y : \u03b1) : x = y \u2194 True", "start": [790, 1], "end": [791, 40], "kind": "commanddeclaration"}, {"full_name": "subsingleton_of_forall_eq", "code": "theorem subsingleton_of_forall_eq (x : \u03b1) (h : \u2200 y, y = x) : Subsingleton \u03b1", "start": [793, 1], "end": [795, 31], "kind": "commanddeclaration"}, {"full_name": "subsingleton_iff_forall_eq", "code": "theorem subsingleton_iff_forall_eq (x : \u03b1) : Subsingleton \u03b1 \u2194 \u2200 y, y = x", "start": [797, 1], "end": [798, 66], "kind": "commanddeclaration"}, {"full_name": "false_ne_true", "code": "theorem false_ne_true : False \u2260 True", "start": [803, 1], "end": [803, 66], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_false_or_eq_true", "code": "theorem Bool.eq_false_or_eq_true : (b : Bool) \u2192 b = true \u2228 b = false", "start": [805, 1], "end": [807, 22], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_false_iff", "code": "theorem Bool.eq_false_iff {b : Bool} : b = false \u2194 b \u2260 true", "start": [809, 1], "end": [810, 45], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_iff_iff", "code": "theorem Bool.eq_iff_iff {a b : Bool} : a = b \u2194 (a \u2194 b)", "start": [812, 1], "end": [812, 78], "kind": "commanddeclaration"}, {"full_name": "ne_comm", "code": "theorem ne_comm {\u03b1} {a b : \u03b1} : a \u2260 b \u2194 b \u2260 a", "start": [814, 1], "end": [814, 68], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/OtherDecl.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.InferType.InferTypeM", "code": "abbrev InferTypeM := ReaderT LocalContext CompilerM", "start": [60, 1], "end": [64, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.getBinderName", "code": "def getBinderName (fvarId : FVarId) : InferTypeM Name := do\n  match (\u2190 read).find? fvarId with\n  | some localDecl => return localDecl.userName\n  | none => LCNF.getBinderName fvarId", "start": [66, 1], "end": [69, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.getType", "code": "def getType (fvarId : FVarId) : InferTypeM Expr := do\n  match (\u2190 read).find? fvarId with\n  | some localDecl => return localDecl.type\n  | none => LCNF.getType fvarId", "start": [71, 1], "end": [74, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.mkForallFVars", "code": "def mkForallFVars (xs : Array Expr) (type : Expr) : InferTypeM Expr :=\n  let b := type.abstract xs\n  xs.size.foldRevM (init := b) fun i b => do\n    let x := xs[i]!\n    let n \u2190 InferType.getBinderName x.fvarId!\n    let ty \u2190 InferType.getType x.fvarId!\n    let ty := ty.abstractRange i xs;\n    return .forallE n ty b .default", "start": [76, 1], "end": [83, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.mkForallParams", "code": "def mkForallParams (params : Array Param) (type : Expr) : InferTypeM Expr :=\n  let xs := params.map fun p => .fvar p.fvarId\n  mkForallFVars xs type |>.run {}", "start": [85, 1], "end": [87, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.withLocalDecl", "code": "@[inline] def withLocalDecl (binderName : Name) (type : Expr) (binderInfo : BinderInfo) (k : Expr \u2192 InferTypeM \u03b1) : InferTypeM \u03b1 := do\n  let fvarId \u2190 mkFreshFVarId\n  withReader (fun lctx => lctx.mkLocalDecl fvarId binderName type binderInfo) do\n    k (.fvar fvarId)", "start": [89, 1], "end": [92, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferConstType", "code": "def inferConstType (declName : Name) (us : List Level) : CompilerM Expr := do\n  if declName == ``lcErased then\n    return erasedExpr\n  else if let some decl \u2190 getDecl? declName then\n    return decl.instantiateTypeLevelParams us\n  else\n    \n    getOtherDeclType declName us", "start": [94, 1], "end": [101, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferLitValueType", "code": "def inferLitValueType (value : LitValue) : Expr :=\n  match value with\n  | .natVal .. => mkConst ``Nat\n  | .strVal .. => mkConst ``String", "start": [103, 1], "end": [106, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferArgType", "code": "partial def inferArgType (arg : Arg) : InferTypeM Expr :=\n    match arg with\n    | .erased => return erasedExpr\n    | .type e => inferType e\n    | .fvar fvarId => LCNF.getType fvarId", "start": [109, 3], "end": [113, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferType", "code": "partial def inferType (e : Expr) : InferTypeM Expr :=\n    match e with\n    | .const c us    => inferConstType c us\n    | .app ..        => inferAppType e\n    | .fvar fvarId   => InferType.getType fvarId\n    | .sort lvl      => return .sort (mkLevelSucc lvl)\n    | .forallE ..    => inferForallType e\n    | .lam ..        => inferLambdaType e\n    | .letE .. | .mvar .. | .mdata .. | .lit .. | .bvar .. | .proj .. => unreachable!", "start": [115, 3], "end": [123, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferLetValueType", "code": "partial def inferLetValueType (e : LetValue) : InferTypeM Expr := do\n    match e with\n    | .erased => return erasedExpr\n    | .value v => return inferLitValueType v\n    | .proj structName idx fvarId => inferProjType structName idx fvarId\n    | .const declName us args => inferAppTypeCore (\u2190 inferConstType declName us) args\n    | .fvar fvarId args => inferAppTypeCore (\u2190 getType fvarId) args", "start": [125, 3], "end": [131, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferAppTypeCore", "code": "partial def inferAppTypeCore (fType : Expr) (args : Array Arg) : InferTypeM Expr := do\n    let mut j := 0\n    let mut fType := fType\n    for i in [:args.size] do\n      fType := fType.headBeta\n      match fType with\n      | .forallE _ _ b _ => fType := b\n      | _ =>\n        fType := instantiateRevRangeArgs fType j i args |>.headBeta\n        match fType with\n        | .forallE _ _ b _ => j := i; fType := b\n        | _ => return erasedExpr\n    return instantiateRevRangeArgs fType j args.size args |>.headBeta", "start": [133, 3], "end": [145, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferAppType", "code": "partial def inferAppType (e : Expr) : InferTypeM Expr := do\n    let mut j := 0\n    let mut fType \u2190 inferType e.getAppFn\n    let args := e.getAppArgs\n    for i in [:args.size] do\n      fType := fType.headBeta\n      match fType with\n      | .forallE _ _ b _ => fType := b\n      | _ =>\n        fType := fType.instantiateRevRange j i args |>.headBeta\n        match fType with\n        | .forallE _ _ b _ => j := i; fType := b\n        | _ => return erasedExpr\n    return fType.instantiateRevRange j args.size args |>.headBeta", "start": [147, 3], "end": [160, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferProjType", "code": "partial def inferProjType (structName : Name) (idx : Nat) (s : FVarId) : InferTypeM Expr := do\n    let failed {\u03b1} : Unit \u2192 InferTypeM \u03b1 := fun _ =>\n      throwError \"invalid projection{indentExpr (mkProj structName idx (mkFVar s))}\"\n    let structType := (\u2190 getType s).headBeta\n    if structType.isErased then\n      \n      return erasedExpr\n    else\n      matchConstStruct structType.getAppFn failed fun structVal structLvls ctorVal =>\n        let n := structVal.numParams\n        let structParams := structType.getAppArgs\n        if n != structParams.size then\n          failed ()\n        else do\n          let mut ctorType \u2190 inferAppType (mkAppN (mkConst ctorVal.name structLvls) structParams)\n          for _ in [:idx] do\n            match ctorType with\n            | .forallE _ _ body _ =>\n              if body.hasLooseBVars then\n                ctorType := body.instantiate1 erasedExpr\n              else\n                ctorType := body\n            | _ =>\n              if ctorType.isErased then return erasedExpr\n              failed ()\n          match ctorType with\n          | .forallE _ d _ _ => return d\n          | _ =>\n            if ctorType.isErased then return erasedExpr\n            failed ()", "start": [162, 3], "end": [192, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.getLevel?", "code": "partial def getLevel? (type : Expr) : InferTypeM (Option Level) := do\n    match (\u2190 inferType type) with\n    | .sort u => return some u\n    | _ => return none", "start": [194, 3], "end": [197, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferForallType", "code": "partial def inferForallType (e : Expr) : InferTypeM Expr :=\n    go e #[]\n  where\n    go (e : Expr) (fvars : Array Expr) : InferTypeM Expr := do\n      match e with\n      | .forallE n d b bi =>\n        withLocalDecl n (d.instantiateRev fvars) bi fun fvar =>\n          go b (fvars.push fvar)\n      | _ =>\n        let e := e.instantiateRev fvars\n        let some u \u2190 getLevel? e | return erasedExpr\n        let mut u := u\n        for x in fvars.reverse do\n          let xType \u2190 inferType x\n          let some v \u2190 getLevel? xType | return erasedExpr\n          u := mkLevelIMax' v u\n        return .sort u.normalize", "start": [199, 3], "end": [215, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.inferLambdaType", "code": "partial def inferLambdaType (e : Expr) : InferTypeM Expr :=\n    go e #[] #[]\n  where\n    go (e : Expr) (fvars : Array Expr) (all : Array Expr) : InferTypeM Expr := do\n      match e with\n      | .lam n d b bi =>\n        withLocalDecl n (d.instantiateRev all) bi fun fvar => go b (fvars.push fvar) (all.push fvar)\n      | .letE n t _ b _ =>\n        withLocalDecl n (t.instantiateRev all) .default fun fvar => go b fvars (all.push fvar)\n      | e =>\n        let type \u2190 inferType (e.instantiateRev all)\n        mkForallFVars fvars type", "start": [217, 3], "end": [228, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.inferType", "code": "def inferType (e : Expr) : CompilerM Expr :=\n  InferType.inferType e |>.run {}", "start": [233, 1], "end": [234, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.inferAppType", "code": "def inferAppType (fnType : Expr) (args : Array Arg) : CompilerM Expr :=\n  InferType.inferAppTypeCore fnType args |>.run {}", "start": [236, 1], "end": [237, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getLevel", "code": "def getLevel (type : Expr) : CompilerM Level := do\n  match (\u2190 inferType type) with\n  | .sort u => return u\n  | e => if e.isErased then return levelOne else throwError \"type expected{indentExpr type}\"", "start": [239, 1], "end": [242, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.inferType", "code": "def Arg.inferType (arg : Arg) : CompilerM Expr :=\n  InferType.inferArgType arg |>.run {}", "start": [244, 1], "end": [245, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.inferType", "code": "def LetValue.inferType (e : LetValue) : CompilerM Expr :=\n  InferType.inferLetValueType e |>.run {}", "start": [247, 1], "end": [248, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.inferType", "code": "def Code.inferType (code : Code) : CompilerM Expr := do\n  match code with\n  | .let _ k | .fun _ k | .jp _ k => k.inferType\n  | .return fvarId => getType fvarId\n  | .jmp fvarId args => InferType.inferAppTypeCore (\u2190 getType fvarId) args |>.run {}\n  | .unreach type => return type\n  | .cases c => return c.resultType", "start": [250, 1], "end": [256, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.inferParamType", "code": "def Code.inferParamType (params : Array Param) (code : Code) : CompilerM Expr := do\n  let type \u2190 code.inferType\n  let xs := params.map fun p => .fvar p.fvarId\n  InferType.mkForallFVars xs type |>.run {}", "start": [258, 1], "end": [261, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AltCore.inferType", "code": "def AltCore.inferType (alt : Alt) : CompilerM Expr :=\n  alt.getCode.inferType", "start": [263, 1], "end": [264, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkAuxLetDecl", "code": "def mkAuxLetDecl (e : LetValue) (prefixName := `_x) : CompilerM LetDecl := do\n  mkLetDecl (\u2190 mkFreshBinderName prefixName) (\u2190 e.inferType) e", "start": [266, 1], "end": [267, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkForallParams", "code": "def mkForallParams (params : Array Param) (type : Expr) : CompilerM Expr :=\n  InferType.mkForallParams params type |>.run {}", "start": [269, 1], "end": [270, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkAuxFunDecl", "code": "def mkAuxFunDecl (params : Array Param) (code : Code) (prefixName := `_f) : CompilerM FunDecl := do\n  let type \u2190 mkForallParams params (\u2190 code.inferType)\n  let binderName \u2190 mkFreshBinderName prefixName\n  mkFunDecl binderName type params code", "start": [272, 1], "end": [275, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkAuxJpDecl", "code": "def mkAuxJpDecl (params : Array Param) (code : Code) (prefixName := `_jp) : CompilerM FunDecl := do\n  mkAuxFunDecl params code prefixName", "start": [277, 1], "end": [278, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkAuxJpDecl'", "code": "def mkAuxJpDecl' (param : Param) (code : Code) (prefixName := `_jp) : CompilerM FunDecl := do\n  let params := #[param]\n  mkAuxFunDecl params code prefixName", "start": [280, 1], "end": [282, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkCasesResultType", "code": "def mkCasesResultType (alts : Array Alt) : CompilerM Expr := do\n  if alts.isEmpty then\n    throwError \"`Code.bind` failed, empty `cases` found\"\n  let mut resultType \u2190 alts[0]!.inferType\n  for alt in alts[1:] do\n    resultType := joinTypes resultType (\u2190 alt.inferType)\n  return resultType", "start": [284, 1], "end": [290, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isErasedCompatible", "code": "partial def isErasedCompatible (type : Expr) (predVars : Array Bool := #[]): CompilerM Bool :=\n  go type predVars\nwhere\n  go (type : Expr) (predVars : Array Bool) : CompilerM Bool := do\n    let type := type.headBeta\n    match type with\n    | .const ..        => return type.isErased\n    | .sort ..         => return false\n    | .mdata _ e       => go e predVars\n    | .forallE _ t b _\n    | .lam _ t b _     => go b (predVars.push <| isPredicateType t)\n    | .app f _         => go f predVars\n    | .bvar idx        => return predVars[predVars.size - idx - 1]!\n    | .fvar fvarId     => return isPredicateType (\u2190 getType fvarId)\n    | .proj .. | .mvar .. | .letE .. | .lit .. => unreachable!", "start": [292, 1], "end": [313, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eqvTypes", "code": "partial def eqvTypes (a b : Expr) : Bool :=\n  if a == b then\n    true\n  else if a.isErased && b.isErased then\n    true\n  else\n    let a' := a.headBeta\n    let b' := b.headBeta\n    if a != a' || b != b' then\n      eqvTypes a' b'\n    else\n      match a, b with\n      | .mdata _ a, b => eqvTypes a b\n      | a, .mdata _ b => eqvTypes a b\n      | .app f a, .app g b => eqvTypes f g && eqvTypes a b\n      | .forallE _ d\u2081 b\u2081 _, .forallE _ d\u2082 b\u2082 _ => eqvTypes d\u2081 d\u2082 && eqvTypes b\u2081 b\u2082\n      | .lam _ d\u2081 b\u2081 _, .lam _ d\u2082 b\u2082 _ => eqvTypes d\u2081 d\u2082 && eqvTypes b\u2081 b\u2082\n      | .sort u, .sort v => Level.isEquiv u v\n      | .const n us, .const m vs => n == m && List.isEqv us vs Level.isEquiv\n      | _, _ => false", "start": [315, 1], "end": [339, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Nat/Basic.lean", "imports": ["lake-packages/std/Std/Classes/Dvd.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.recAux", "code": "@[elab_as_elim]\nprotected def recAux {motive : Nat \u2192 Sort _}\n    (zero : motive 0) (succ : \u2200 n, motive n \u2192 motive (n+1)) : (t : Nat) \u2192 motive t\n  | 0 => zero\n  | _+1 => succ _ (Nat.recAux zero succ _)", "start": [10, 1], "end": [17, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.recAuxOn", "code": "@[elab_as_elim]\nprotected def recAuxOn {motive : Nat \u2192 Sort _} (t : Nat) (zero : motive 0)\n  (succ : \u2200 n, motive n \u2192 motive (n+1)) : motive t := Nat.recAux zero succ t", "start": [19, 1], "end": [24, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.casesAuxOn", "code": "@[elab_as_elim]\nprotected def casesAuxOn {motive : Nat \u2192 Sort _} (t : Nat) (zero : motive 0)\n  (succ : \u2200 n, motive (n+1)) : motive t := Nat.recAux zero (fun n _ => succ n) t", "start": [26, 1], "end": [31, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.strongRec", "code": "@[elab_as_elim]\nprotected def strongRec {motive : Nat \u2192 Sort _} (ind : \u2200 n, (\u2200 m, m < n \u2192 motive m) \u2192 motive n)\n  (t : Nat) : motive t := ind t fun m _ => Nat.strongRec ind m", "start": [33, 1], "end": [38, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.strongRecOn", "code": "@[elab_as_elim]\nprotected def strongRecOn (t : Nat) {motive : Nat \u2192 Sort _}\n  (ind : \u2200 n, (\u2200 m, m < n \u2192 motive m) \u2192 motive n) : motive t := Nat.strongRec ind t", "start": [40, 1], "end": [45, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiagAux", "code": "@[elab_as_elim]\nprotected def recDiagAux {motive : Nat \u2192 Nat \u2192 Sort _}\n  (zero_left : \u2200 n, motive 0 n)\n  (zero_right : \u2200 m, motive m 0)\n  (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) :\n    (m n : Nat) \u2192 motive m n\n  | 0, _ => zero_left _\n  | _, 0 => zero_right _\n  | _+1, _+1 => succ_succ _ _ (Nat.recDiagAux zero_left zero_right succ_succ _ _)", "start": [47, 1], "end": [58, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiag", "code": "@[elab_as_elim]\nprotected def recDiag {motive : Nat \u2192 Nat \u2192 Sort _}\n  (zero_zero : motive 0 0)\n  (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1))\n  (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n  (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) :\n    (m n : Nat) \u2192 motive m n := Nat.recDiagAux left right succ_succ\nwhere\n  \n  left : \u2200 n, motive 0 n\n  | 0 => zero_zero\n  | _+1 => zero_succ _ (left _)\n  \n  right : \u2200 m, motive m 0\n  | 0 => zero_zero\n  | _+1 => succ_zero _ (right _)", "start": [60, 1], "end": [78, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiagOn", "code": "@[elab_as_elim]\nprotected def recDiagOn {motive : Nat \u2192 Nat \u2192 Sort _} (m n : Nat)\n  (zero_zero : motive 0 0)\n  (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1))\n  (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n  (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) :\n    motive m n := Nat.recDiag zero_zero zero_succ succ_zero succ_succ m n", "start": [80, 1], "end": [89, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.casesDiagOn", "code": "@[elab_as_elim]\nprotected def casesDiagOn {motive : Nat \u2192 Nat \u2192 Sort _} (m n : Nat)\n  (zero_zero : motive 0 0)\n  (zero_succ : \u2200 n, motive 0 (n+1))\n  (succ_zero : \u2200 m, motive (m+1) 0)\n  (succ_succ : \u2200 m n, motive (m+1) (n+1)) :\n    motive m n :=\n  Nat.recDiag zero_zero (fun _ _ => zero_succ _) (fun _ _ => succ_zero _)\n    (fun _ _ _ => succ_succ _ _) m n", "start": [91, 1], "end": [102, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.sum", "code": "protected def sum (l : List Nat) : Nat := l.foldr (\u00b7+\u00b7) 0", "start": [110, 1], "end": [111, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt", "code": "def sqrt (n : Nat) : Nat :=\n  if n \u2264 1 then n else\n  iter n (n / 2)\nwhere\n  \n  iter (n guess : Nat) : Nat :=\n    let next := (guess + n / guess) / 2\n    if _h : next < guess then\n      iter n next\n    else\n      guess\ntermination_by iter guess => guess", "start": [113, 1], "end": [128, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "imports": ["lake-packages/std/Std/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.succ_sub", "code": "theorem succ_sub {m n : Nat} (h : n \u2264 m) : succ m - n = succ (m - n)", "start": [10, 1], "end": [12, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_le_sub_right", "code": "protected theorem sub_le_sub_right {n m : Nat} (h : n \u2264 m) : \u2200 k, n - k \u2264 m - k", "start": [14, 1], "end": [16, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_lt_left_of_lt_add", "code": "protected theorem sub_lt_left_of_lt_add {n k m : Nat} (H : n \u2264 k) (h : k < n + m) : k - n < m", "start": [18, 1], "end": [20, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_lt_right_of_lt_add", "code": "protected theorem sub_lt_right_of_lt_add {n k m : Nat} (H : n \u2264 k) (h : k < m + n) : k - n < m", "start": [22, 1], "end": [23, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_ne_zero", "code": "protected theorem pos_of_ne_zero {n : Nat} : n \u2260 0 \u2192 0 < n", "start": [25, 1], "end": [25, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.min_eq_min", "code": "protected theorem min_eq_min (a : Nat) : Nat.min a b = min a b", "start": [27, 1], "end": [27, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.max_eq_max", "code": "protected theorem max_eq_max (a : Nat) : Nat.max a b = max a b", "start": [29, 1], "end": [29, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.min_comm", "code": "protected theorem min_comm (a b : Nat) : min a b = min b a", "start": [31, 1], "end": [34, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.min_le_right", "code": "protected theorem min_le_right (a b : Nat) : min a b \u2264 b", "start": [36, 1], "end": [36, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.min_le_left", "code": "protected theorem min_le_left (a b : Nat) : min a b \u2264 a", "start": [38, 1], "end": [38, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.max_comm", "code": "protected theorem max_comm (a b : Nat) : max a b = max b a", "start": [40, 1], "end": [44, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.le_max_left", "code": "protected theorem le_max_left (a b : Nat) : a \u2264 max a b", "start": [46, 1], "end": [46, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.le_max_right", "code": "protected theorem le_max_right (a b : Nat) : b \u2264 max a b", "start": [48, 1], "end": [48, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_two_pos", "code": "protected theorem pow_two_pos (w : Nat) : 0 < 2^w", "start": [50, 1], "end": [50, 86], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/RecAppSyntax.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.recAppKey", "code": "private def recAppKey := `_recApp", "start": [10, 1], "end": [10, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRecAppWithSyntax", "code": "def mkRecAppWithSyntax (e : Expr) (stx : Syntax) : Expr :=\n  mkMData (KVMap.empty.insert recAppKey (DataValue.ofSyntax stx)) e", "start": [12, 1], "end": [17, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.getRecAppSyntax?", "code": "def getRecAppSyntax? (e : Expr) : Option Syntax :=\n  match e with\n  | Expr.mdata d _ =>\n    match d.find recAppKey with\n    | some (DataValue.ofSyntax stx) => some stx\n    | _ => none\n  | _                => none", "start": [19, 1], "end": [28, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Bind.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.MonadCodeBind", "code": "class MonadCodeBind (m : Type \u2192 Type) where\n  codeBind : (c : Code) \u2192 (f : FVarId \u2192 m Code) \u2192 m Code", "start": [10, 1], "end": [12, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.bind", "code": "abbrev Code.bind [MonadCodeBind m] (c : Code) (f : FVarId \u2192 m Code) : m Code :=\n  MonadCodeBind.codeBind c f", "start": [14, 1], "end": [24, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CompilerM.codeBind", "code": "partial def CompilerM.codeBind (c : Code) (f : FVarId \u2192 CompilerM Code) : CompilerM Code := do\n  go c |>.run {}\nwhere\n  go (c : Code) : ReaderT FVarIdSet CompilerM Code := do\n    match c with\n    | .let decl k => return .let decl (\u2190 go k)\n    | .fun decl k => return .fun decl (\u2190 go k)\n    | .jp decl k =>\n      let value \u2190 go decl.value\n      let type \u2190 value.inferParamType decl.params\n      let decl \u2190 decl.update' type value\n      withReader (fun s => s.insert decl.fvarId) do\n        return .jp decl (\u2190 go k)\n    | .cases c =>\n      let alts \u2190 c.alts.mapM fun\n        | .alt ctorName params k => return .alt ctorName params (\u2190 go k)\n        | .default k => return .default (\u2190 go k)\n      if alts.isEmpty then\n        throwError \"`Code.bind` failed, empty `cases` found\"\n      let resultType \u2190 mkCasesResultType alts\n      return .cases { c with alts, resultType }\n    | .return fvarId => f fvarId\n    | .jmp fvarId .. =>\n      unless (\u2190 read).contains fvarId do\n        throwError \"`Code.bind` failed, it contains a out of scope join point\"\n      return c\n    | .unreach type =>\n      \n      let auxParam \u2190 mkAuxParam type\n      let k \u2190 f auxParam.fvarId\n      let typeNew \u2190 k.inferType\n      eraseCode k\n      eraseParam auxParam\n      return .unreach typeNew", "start": [26, 1], "end": [63, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkNewParams", "code": "partial def mkNewParams (type : Expr) : CompilerM (Array Param) :=\n  go type #[] #[]\nwhere\n  go (type : Expr) (xs : Array Expr) (ps : Array Param) : CompilerM (Array Param) := do\n    match type with\n    | .forallE _ d b _ =>\n      let d := d.instantiateRev xs\n      let p \u2190 mkAuxParam d\n      go b (xs.push (.fvar p.fvarId)) (ps.push p)\n    | _ =>\n      let type := type.instantiateRev xs\n      let type' := type.headBeta\n      if type' != type then\n        go type' #[] ps\n      else\n        return ps", "start": [74, 1], "end": [94, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isEtaExpandCandidateCore", "code": "def isEtaExpandCandidateCore (type : Expr) (params : Array Param) : Bool :=\n  let typeArity := getArrowArity type\n  let valueArity := params.size\n  typeArity > valueArity", "start": [96, 1], "end": [99, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.isEtaExpandCandidate", "code": "abbrev FunDeclCore.isEtaExpandCandidate (decl : FunDecl) : Bool :=\n  isEtaExpandCandidateCore decl.type decl.params", "start": [101, 1], "end": [102, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.etaExpandCore", "code": "def etaExpandCore (type : Expr) (params : Array Param) (value : Code) : CompilerM (Array Param \u00d7 Code) := do\n  let valueType \u2190 instantiateForall type (params.map (mkFVar \u00b7.fvarId))\n  let psNew \u2190 mkNewParams valueType\n  let params := params ++ psNew\n  let xs := psNew.map fun p => .fvar p.fvarId\n  let value \u2190 value.bind fun fvarId => do\n    let auxDecl \u2190 mkAuxLetDecl (.fvar fvarId xs)\n    return .let auxDecl (.return auxDecl.fvarId)\n  return (params, value)", "start": [104, 1], "end": [112, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.etaExpandCore?", "code": "def etaExpandCore? (type : Expr) (params : Array Param) (value : Code) : CompilerM (Option (Array Param \u00d7 Code)) := do\n  if isEtaExpandCandidateCore type params then\n    etaExpandCore type params value\n  else\n    return none", "start": [114, 1], "end": [118, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.etaExpand", "code": "def FunDeclCore.etaExpand (decl : FunDecl) : CompilerM FunDecl := do\n  let some (params, value) \u2190 etaExpandCore? decl.type decl.params decl.value | return decl\n  decl.update decl.type params value", "start": [120, 1], "end": [122, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.etaExpand", "code": "def Decl.etaExpand (decl : Decl) : CompilerM Decl := do\n  let some (params, value) \u2190 etaExpandCore? decl.type decl.params decl.value | return decl\n  return { decl with params, value }", "start": [124, 1], "end": [126, 37], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/InlineAttrs.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Instances.lean", "lake-packages/lean4/src/lean/Lean/Compiler/Specialize.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.findFunDecl'?", "code": "partial def findFunDecl'? (fvarId : FVarId) : CompilerM (Option FunDecl) := do\n  if let some decl \u2190 findFunDecl? fvarId then\n    return decl\n  else if let some (.fvar fvarId' #[]) \u2190 findLetValue? fvarId then\n    findFunDecl'? fvarId'\n  else\n    return none", "start": [14, 1], "end": [29, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Nat/Lemmas.lean", "imports": ["lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "lake-packages/std/Std/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Logic.lean", "lake-packages/std/Std/Tactic/Basic.lean"], "premises": [{"full_name": "Nat.recAux_zero", "code": "@[simp] theorem recAux_zero {motive : Nat \u2192 Sort _} (zero : motive 0)\n    (succ : \u2200 n, motive n \u2192 motive (n+1)) :\n    Nat.recAux zero succ 0 = zero", "start": [15, 1], "end": [17, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.recAux_succ", "code": "theorem recAux_succ {motive : Nat \u2192 Sort _} (zero : motive 0)\n    (succ : \u2200 n, motive n \u2192 motive (n+1)) (n) :\n    Nat.recAux zero succ (n+1) = succ n (Nat.recAux zero succ n)", "start": [19, 1], "end": [21, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.recAuxOn_zero", "code": "@[simp] theorem recAuxOn_zero {motive : Nat \u2192 Sort _} (zero : motive 0)\n    (succ : \u2200 n, motive n \u2192 motive (n+1)) :\n    Nat.recAuxOn 0 zero succ = zero", "start": [23, 1], "end": [25, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.recAuxOn_succ", "code": "theorem recAuxOn_succ {motive : Nat \u2192 Sort _} (zero : motive 0)\n    (succ : \u2200 n, motive n \u2192 motive (n+1)) (n) :\n    Nat.recAuxOn (n+1) zero succ = succ n (Nat.recAuxOn n zero succ)", "start": [27, 1], "end": [29, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.casesAuxOn_zero", "code": "@[simp] theorem casesAuxOn_zero {motive : Nat \u2192 Sort _} (zero : motive 0)\n    (succ : \u2200 n, motive (n+1)) :\n    Nat.casesAuxOn 0 zero succ = zero", "start": [31, 1], "end": [33, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.casesAuxOn_succ", "code": "@[simp] theorem casesAuxOn_succ {motive : Nat \u2192 Sort _} (zero : motive 0)\n    (succ : \u2200 n, motive (n+1)) (n) :\n    Nat.casesAuxOn (n+1) zero succ = succ n", "start": [35, 1], "end": [37, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.strongRec_eq", "code": "theorem strongRec_eq {motive : Nat \u2192 Sort _} (ind : \u2200 n, (\u2200 m, m < n \u2192 motive m) \u2192 motive n)\n    (t : Nat) : Nat.strongRec ind t = ind t fun m _ => Nat.strongRec ind m", "start": [39, 1], "end": [41, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.strongRecOn_eq", "code": "theorem strongRecOn_eq {motive : Nat \u2192 Sort _} (ind : \u2200 n, (\u2200 m, m < n \u2192 motive m) \u2192 motive n)\n    (t : Nat) : Nat.strongRecOn t ind = ind t fun m _ => Nat.strongRecOn m ind", "start": [43, 1], "end": [45, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiagAux_zero_left", "code": "@[simp] theorem recDiagAux_zero_left {motive : Nat \u2192 Nat \u2192 Sort _}\n    (zero_left : \u2200 n, motive 0 n) (zero_right : \u2200 m, motive m 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) (n) :\n    Nat.recDiagAux zero_left zero_right succ_succ 0 n = zero_left n", "start": [47, 1], "end": [50, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiagAux_zero_right", "code": "@[simp] theorem recDiagAux_zero_right {motive : Nat \u2192 Nat \u2192 Sort _}\n    (zero_left : \u2200 n, motive 0 n) (zero_right : \u2200 m, motive m 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) (m)\n    (h : zero_left 0 = zero_right 0 := by first | assumption | trivial) :\n    Nat.recDiagAux zero_left zero_right succ_succ m 0 = zero_right m", "start": [52, 1], "end": [56, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiagAux_succ_succ", "code": "theorem recDiagAux_succ_succ {motive : Nat \u2192 Nat \u2192 Sort _}\n    (zero_left : \u2200 n, motive 0 n) (zero_right : \u2200 m, motive m 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) (m n) :\n    Nat.recDiagAux zero_left zero_right succ_succ (m+1) (n+1)\n      = succ_succ m n (Nat.recDiagAux zero_left zero_right succ_succ m n)", "start": [58, 1], "end": [62, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiag_zero_zero", "code": "@[simp] theorem recDiag_zero_zero {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1)) (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) :\n    Nat.recDiag (motive:=motive) zero_zero zero_succ succ_zero succ_succ 0 0 = zero_zero", "start": [64, 1], "end": [67, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiag_zero_succ", "code": "theorem recDiag_zero_succ {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1)) (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) (n) :\n    Nat.recDiag zero_zero zero_succ succ_zero succ_succ 0 (n+1)\n      = zero_succ n (Nat.recDiag zero_zero zero_succ succ_zero succ_succ 0 n)", "start": [69, 1], "end": [74, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiag_succ_zero", "code": "theorem recDiag_succ_zero {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1)) (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) (m) :\n    Nat.recDiag zero_zero zero_succ succ_zero succ_succ (m+1) 0\n      = succ_zero m (Nat.recDiag zero_zero zero_succ succ_zero succ_succ m 0)", "start": [76, 1], "end": [81, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiag_succ_succ", "code": "theorem recDiag_succ_succ {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1)) (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) (m n) :\n    Nat.recDiag zero_zero zero_succ succ_zero succ_succ (m+1) (n+1)\n      = succ_succ m n (Nat.recDiag zero_zero zero_succ succ_zero succ_succ m n)", "start": [83, 1], "end": [87, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiagOn_zero_zero", "code": "@[simp] theorem recDiagOn_zero_zero {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1)) (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) :\n    Nat.recDiagOn (motive:=motive) 0 0 zero_zero zero_succ succ_zero succ_succ = zero_zero", "start": [89, 1], "end": [92, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiagOn_zero_succ", "code": "theorem recDiagOn_zero_succ {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1)) (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) (n) :\n    Nat.recDiagOn 0 (n+1) zero_zero zero_succ succ_zero succ_succ\n      = zero_succ n (Nat.recDiagOn 0 n zero_zero zero_succ succ_zero succ_succ)", "start": [94, 1], "end": [99, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiagOn_succ_zero", "code": "theorem recDiagOn_succ_zero {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1)) (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) (m) :\n    Nat.recDiagOn (m+1) 0 zero_zero zero_succ succ_zero succ_succ\n      = succ_zero m (Nat.recDiagOn m 0 zero_zero zero_succ succ_zero succ_succ)", "start": [101, 1], "end": [106, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.recDiagOn_succ_succ", "code": "theorem recDiagOn_succ_succ {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 n \u2192 motive 0 (n+1)) (succ_zero : \u2200 m, motive m 0 \u2192 motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive m n \u2192 motive (m+1) (n+1)) (m n) :\n    Nat.recDiagOn (m+1) (n+1) zero_zero zero_succ succ_zero succ_succ\n      = succ_succ m n (Nat.recDiagOn m n zero_zero zero_succ succ_zero succ_succ)", "start": [108, 1], "end": [112, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.casesDiagOn_zero_zero", "code": "@[simp] theorem casesDiagOn_zero_zero {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 (n+1)) (succ_zero : \u2200 m, motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive (m+1) (n+1)) :\n    Nat.casesDiagOn 0 0 (motive:=motive) zero_zero zero_succ succ_zero succ_succ = zero_zero", "start": [114, 1], "end": [117, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.casesDiagOn_zero_succ", "code": "@[simp] theorem casesDiagOn_zero_succ {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 (n+1)) (succ_zero : \u2200 m, motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive (m+1) (n+1)) (n) :\n    Nat.casesDiagOn 0 (n+1) zero_zero zero_succ succ_zero succ_succ = zero_succ n", "start": [119, 1], "end": [122, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.casesDiagOn_succ_zero", "code": "@[simp] theorem casesDiagOn_succ_zero {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 (n+1)) (succ_zero : \u2200 m, motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive (m+1) (n+1)) (m) :\n    Nat.casesDiagOn (m+1) 0 zero_zero zero_succ succ_zero succ_succ = succ_zero m", "start": [124, 1], "end": [127, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.casesDiagOn_succ_succ", "code": "@[simp] theorem casesDiagOn_succ_succ {motive : Nat \u2192 Nat \u2192 Sort _} (zero_zero : motive 0 0)\n    (zero_succ : \u2200 n, motive 0 (n+1)) (succ_zero : \u2200 m, motive (m+1) 0)\n    (succ_succ : \u2200 m n, motive (m+1) (n+1)) (m n) :\n    Nat.casesDiagOn (m+1) (n+1) zero_zero zero_succ succ_zero succ_succ = succ_succ m n", "start": [129, 1], "end": [132, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.ne_of_gt", "code": "theorem ne_of_gt {a b : Nat} (h : b < a) : a \u2260 b", "start": [136, 1], "end": [136, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_not_le", "code": "protected theorem le_of_not_le {a b : Nat} : \u00ac a \u2264 b \u2192 b \u2264 a", "start": [138, 1], "end": [138, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_iff_le_not_le", "code": "protected theorem lt_iff_le_not_le {m n : Nat} : m < n \u2194 m \u2264 n \u2227 \u00ac n \u2264 m", "start": [140, 1], "end": [141, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_iff_le_and_ne", "code": "protected theorem lt_iff_le_and_ne {m n : Nat} : m < n \u2194 m \u2264 n \u2227 m \u2260 n", "start": [143, 1], "end": [145, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.not_le", "code": "@[simp] protected theorem not_le {a b : Nat} : \u00ac a \u2264 b \u2194 b < a", "start": [147, 1], "end": [148, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.not_lt", "code": "@[simp] protected theorem not_lt {a b : Nat} : \u00ac a < b \u2194 b \u2264 a", "start": [150, 1], "end": [151, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.le_lt_antisymm", "code": "theorem le_lt_antisymm {n m : Nat} (h\u2081 : n \u2264 m) (h\u2082 : m < n) : False", "start": [153, 1], "end": [154, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_le_antisymm", "code": "theorem lt_le_antisymm {n m : Nat} (h\u2081 : n < m) (h\u2082 : m \u2264 n) : False", "start": [156, 1], "end": [157, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_asymm", "code": "protected theorem lt_asymm {n m : Nat} (h\u2081 : n < m) : \u00ac m < n", "start": [159, 1], "end": [160, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_sum_ge", "code": "protected def lt_sum_ge (a b : Nat) : a < b \u2295' b \u2264 a :=\n  if h : a < b then .inl h else .inr (Nat.not_lt.1 h)", "start": [162, 1], "end": [164, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_trichotomy", "code": "protected def sum_trichotomy (a b : Nat) : a < b \u2295' a = b \u2295' b < a :=\n  match a.lt_sum_ge b with\n  | .inl h => .inl h\n  | .inr h\u2082 => match b.lt_sum_ge a with\n    | .inl h => .inr <| .inr h\n    | .inr h\u2081 => .inr <| .inl <| Nat.le_antisymm h\u2081 h\u2082", "start": [166, 1], "end": [172, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_trichotomy", "code": "protected theorem lt_trichotomy (a b : Nat) : a < b \u2228 a = b \u2228 b < a", "start": [174, 1], "end": [178, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_or_lt_of_not_lt", "code": "protected theorem eq_or_lt_of_not_lt {a b : Nat} (hnlt : \u00ac a < b) : a = b \u2228 b < a", "start": [180, 1], "end": [181, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.not_lt_of_le", "code": "protected theorem not_lt_of_le {n m : Nat} (h\u2081 : m \u2264 n) : \u00ac n < m", "start": [183, 1], "end": [183, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.not_le_of_lt", "code": "protected theorem not_le_of_lt {n m : Nat} : m < n \u2192 \u00ac n \u2264 m", "start": [185, 1], "end": [185, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_not_le", "code": "protected theorem lt_of_not_le {a b : Nat} : \u00ac a \u2264 b \u2192 b < a", "start": [187, 1], "end": [187, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_not_lt", "code": "protected theorem le_of_not_lt {a b : Nat} : \u00ac a < b \u2192 b \u2264 a", "start": [189, 1], "end": [189, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.le_or_le", "code": "protected theorem le_or_le (a b : Nat) : a \u2264 b \u2228 b \u2264 a", "start": [191, 1], "end": [191, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_or_eq_of_le", "code": "protected theorem lt_or_eq_of_le {n m : Nat} (h : n \u2264 m) : n < m \u2228 n = m", "start": [193, 1], "end": [194, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.le_iff_lt_or_eq", "code": "protected theorem le_iff_lt_or_eq {n m : Nat} : n \u2264 m \u2194 n < m \u2228 n = m", "start": [196, 1], "end": [197, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.le_antisymm_iff", "code": "protected theorem le_antisymm_iff {n m : Nat} : n = m \u2194 n \u2264 m \u2227 m \u2264 n", "start": [199, 1], "end": [200, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_iff_ne_zero", "code": "protected theorem pos_iff_ne_zero {n : Nat} : 0 < n \u2194 n \u2260 0", "start": [204, 1], "end": [204, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.le_zero", "code": "theorem le_zero {i : Nat} : i \u2264 0 \u2194 i = 0", "start": [206, 1], "end": [207, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.one_pos", "code": "theorem one_pos : 0 < 1", "start": [209, 1], "end": [209, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.add_one_ne_zero", "code": "theorem add_one_ne_zero (n : Nat) : n + 1 \u2260 0", "start": [211, 1], "end": [211, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_nonpos", "code": "protected theorem eq_zero_of_nonpos : \u2200 (n : Nat), \u00ac0 < n \u2192 n = 0", "start": [213, 1], "end": [215, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_le", "code": "theorem succ_le {n m : Nat} : succ n \u2264 m \u2194 n < m", "start": [221, 1], "end": [221, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_succ", "code": "theorem lt_succ {m n : Nat} : m < succ n \u2194 m \u2264 n", "start": [223, 1], "end": [224, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_succ_of_lt", "code": "theorem lt_succ_of_lt (h : a < b) : a < succ b", "start": [226, 1], "end": [226, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_ne_self", "code": "theorem succ_ne_self : \u2200 n : Nat, succ n \u2260 n", "start": [228, 1], "end": [230, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_pred_eq_of_pos", "code": "theorem succ_pred_eq_of_pos : \u2200 {n : Nat}, 0 < n \u2192 succ (pred n) = n", "start": [232, 1], "end": [233, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_or_eq_succ_pred", "code": "theorem eq_zero_or_eq_succ_pred (n : Nat) : n = 0 \u2228 n = succ (pred n)", "start": [235, 1], "end": [236, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_eq_succ_of_ne_zero", "code": "theorem exists_eq_succ_of_ne_zero {n : Nat} (H : n \u2260 0) : \u2203 k, n = succ k", "start": [238, 1], "end": [239, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_eq_one_add", "code": "theorem succ_eq_one_add (n : Nat) : n.succ = 1 + n", "start": [241, 1], "end": [242, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_inj'", "code": "theorem succ_inj' : succ n = succ m \u2194 n = m", "start": [244, 1], "end": [245, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_inj", "code": "theorem pred_inj : \u2200 {a b : Nat}, 0 < a \u2192 0 < b \u2192 Nat.pred a = Nat.pred b \u2192 a = b", "start": [247, 1], "end": [251, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_lt_pred", "code": "theorem pred_lt_pred : \u2200 {n m : Nat}, n \u2260 0 \u2192 n < m \u2192 pred n < pred m", "start": [253, 1], "end": [255, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_le_succ_iff", "code": "theorem succ_le_succ_iff {a b : Nat} : succ a \u2264 succ b \u2194 a \u2264 b", "start": [257, 1], "end": [258, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_lt_succ_iff", "code": "theorem succ_lt_succ_iff {a b : Nat} : succ a < succ b \u2194 a < b", "start": [260, 1], "end": [261, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.le_succ_of_pred_le", "code": "theorem le_succ_of_pred_le {n m : Nat} : pred n \u2264 m \u2192 n \u2264 succ m", "start": [263, 1], "end": [266, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.le_pred_of_lt", "code": "theorem le_pred_of_lt {m n : Nat} (h : m < n) : m \u2264 n - 1", "start": [268, 1], "end": [269, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_add_eq_zero_right", "code": "protected theorem eq_zero_of_add_eq_zero_right : \u2200 {n m : Nat}, n + m = 0 \u2192 n = 0", "start": [273, 1], "end": [277, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_add_eq_zero_left", "code": "protected theorem eq_zero_of_add_eq_zero_left {n m : Nat} (h : n + m = 0) : m = 0", "start": [279, 1], "end": [280, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_add_eq_succ_add", "code": "theorem succ_add_eq_succ_add (n m : Nat) : succ n + m = n + succ m", "start": [282, 1], "end": [283, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.one_add", "code": "theorem one_add (n : Nat) : 1 + n = succ n", "start": [285, 1], "end": [285, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_add_eq_zero", "code": "theorem eq_zero_of_add_eq_zero {n m : Nat} (H : n + m = 0) : n = 0 \u2227 m = 0", "start": [287, 1], "end": [288, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.add_left_cancel_iff", "code": "protected theorem add_left_cancel_iff {n m k : Nat} : n + m = n + k \u2194 m = k", "start": [290, 1], "end": [291, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.add_right_cancel_iff", "code": "protected theorem add_right_cancel_iff {n m k : Nat} : n + m = k + m \u2194 n = k", "start": [293, 1], "end": [294, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.add_le_add_iff_left", "code": "protected theorem add_le_add_iff_left (k n m : Nat) : k + n \u2264 k + m \u2194 n \u2264 m", "start": [296, 1], "end": [297, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.add_le_add_iff_right", "code": "protected theorem add_le_add_iff_right (k n m : Nat) : n + k \u2264 m + k \u2194 n \u2264 m", "start": [299, 1], "end": [300, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_add_lt_add_left", "code": "protected theorem lt_of_add_lt_add_left {k n m : Nat} (h : k + n < k + m) : n < m", "start": [302, 1], "end": [304, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_add_lt_add_right", "code": "protected theorem lt_of_add_lt_add_right {a b c : Nat} (h : a + b < c + b) : a < c", "start": [306, 1], "end": [307, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.add_lt_add_iff_left", "code": "protected theorem add_lt_add_iff_left (k n m : Nat) : k + n < k + m \u2194 n < m", "start": [309, 1], "end": [310, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.add_lt_add_iff_right", "code": "protected theorem add_lt_add_iff_right (k n m : Nat) : n + k < m + k \u2194 n < m", "start": [312, 1], "end": [313, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_add_right", "code": "protected theorem lt_add_right (a b c : Nat) (h : a < b) : a < b + c", "start": [315, 1], "end": [316, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_add_of_pos_right", "code": "protected theorem lt_add_of_pos_right {n k : Nat} (h : 0 < k) : n < n + k", "start": [318, 1], "end": [319, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_add_of_pos_left", "code": "protected theorem lt_add_of_pos_left {n k : Nat} (h : 0 < k) : n < k + n", "start": [321, 1], "end": [322, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_lt_add_right", "code": "protected theorem pos_of_lt_add_right {n k : Nat} (h : n < n + k) : 0 < k", "start": [324, 1], "end": [325, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_lt_add_left", "code": "protected theorem pos_of_lt_add_left {n k : Nat} (h : n < k + n) : 0 < k", "start": [327, 1], "end": [328, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_add_right_iff_pos", "code": "protected theorem lt_add_right_iff_pos {n k : Nat} : n < n + k \u2194 0 < k", "start": [330, 1], "end": [331, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_add_left_iff_pos", "code": "protected theorem lt_add_left_iff_pos {n k : Nat} : n < k + n \u2194 0 < k", "start": [333, 1], "end": [334, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.add_pos_left", "code": "theorem add_pos_left (h : 0 < m) (n : Nat) : 0 < m + n", "start": [336, 1], "end": [337, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.add_pos_right", "code": "theorem add_pos_right (m : Nat) (h : 0 < n) : 0 < m + n", "start": [339, 1], "end": [341, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.add_self_ne_one", "code": "protected theorem add_self_ne_one : \u2200 (n : Nat), n + n \u2260 1", "start": [343, 1], "end": [346, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_lt_succ", "code": "theorem sub_lt_succ (a b : Nat) : a - b < succ a", "start": [352, 1], "end": [353, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_le_of_sub_le_sub_right", "code": "protected theorem le_of_le_of_sub_le_sub_right :\n    \u2200 {n m k : Nat}, k \u2264 m \u2192 n - k \u2264 m - k \u2192 n \u2264 m", "start": [355, 1], "end": [362, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_le_sub_iff_right", "code": "protected theorem sub_le_sub_iff_right {n m k : Nat} (h : k \u2264 m) : n - k \u2264 m - k \u2194 n \u2264 m", "start": [364, 1], "end": [365, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.add_le_to_le_sub", "code": "protected theorem add_le_to_le_sub (x : Nat) {y k : Nat} (h : k \u2264 y) :\n    x + k \u2264 y \u2194 x \u2264 y - k", "start": [367, 1], "end": [369, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_lt_of_pos_le", "code": "protected theorem sub_lt_of_pos_le {a b : Nat} (h\u2080 : 0 < a) (h\u2081 : a \u2264 b) : b - a < b", "start": [371, 1], "end": [372, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_one", "code": "protected theorem sub_one (n : Nat) : n - 1 = pred n", "start": [374, 1], "end": [374, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_sub_one", "code": "theorem succ_sub_one (n : Nat) : succ n - 1 = n", "start": [376, 1], "end": [376, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_sub_eq_zero", "code": "protected theorem le_of_sub_eq_zero : \u2200 {n m : Nat}, n - m = 0 \u2192 n \u2264 m", "start": [378, 1], "end": [382, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_eq_zero_iff_le", "code": "protected theorem sub_eq_zero_iff_le : n - m = 0 \u2194 n \u2264 m", "start": [384, 1], "end": [385, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_eq_iff_eq_add", "code": "protected theorem sub_eq_iff_eq_add {a b c : Nat} (ab : b \u2264 a) : a - b = c \u2194 a = c + b", "start": [387, 1], "end": [389, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_sub_eq_succ", "code": "protected theorem lt_of_sub_eq_succ (H : m - n = succ l) : n < m", "start": [391, 1], "end": [392, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_le_sub_left", "code": "protected theorem sub_le_sub_left (k : Nat) (h : n \u2264 m) : k - m \u2264 k - n", "start": [394, 1], "end": [396, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_sub_sub_succ", "code": "theorem succ_sub_sub_succ (n m k : Nat) : succ n - m - succ k = n - m - k", "start": [398, 1], "end": [399, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_right_comm", "code": "protected theorem sub_right_comm (m n k : Nat) : m - n - k = m - k - n", "start": [401, 1], "end": [402, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_pos_of_lt", "code": "protected theorem sub_pos_of_lt (h : m < n) : 0 < n - m", "start": [404, 1], "end": [406, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_sub_self", "code": "protected theorem sub_sub_self {n m : Nat} (h : m \u2264 n) : n - (n - m) = m", "start": [408, 1], "end": [409, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_add_comm", "code": "protected theorem sub_add_comm {n m k : Nat} (h : k \u2264 n) : n + m - k = n - k + m", "start": [411, 1], "end": [413, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_one_sub_lt", "code": "theorem sub_one_sub_lt (h : i < n) : n - 1 - i < n", "start": [415, 1], "end": [418, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_lt_self", "code": "theorem sub_lt_self {a b : Nat} (h\u2080 : 0 < a) (h\u2081 : a \u2264 b) : b - a < b", "start": [420, 1], "end": [422, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_cancel'", "code": "protected theorem add_sub_cancel' {n m : Nat} (h : m \u2264 n) : m + (n - m) = n", "start": [424, 1], "end": [425, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.add_le_of_le_sub_left", "code": "protected theorem add_le_of_le_sub_left {n k m : Nat} (H : m \u2264 k) (h : n \u2264 k - m) : m + n \u2264 k", "start": [427, 1], "end": [428, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.le_sub_iff_add_le", "code": "theorem le_sub_iff_add_le {x y k : Nat} (h : k \u2264 y) : x \u2264 y - k \u2194 x + k \u2264 y", "start": [430, 1], "end": [431, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_le_iff_le_add", "code": "protected theorem sub_le_iff_le_add {a b c : Nat} : a - b \u2264 c \u2194 a \u2264 c + b", "start": [433, 1], "end": [434, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_le_iff_le_add'", "code": "protected theorem sub_le_iff_le_add' {a b c : Nat} : a - b \u2264 c \u2194 a \u2264 b + c", "start": [436, 1], "end": [437, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_le_sub_iff_left", "code": "protected theorem sub_le_sub_iff_left {n m k : Nat} (hn : n \u2264 k) : k - m \u2264 k - n \u2194 n \u2264 m", "start": [439, 1], "end": [443, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_add_lt_sub", "code": "protected theorem sub_add_lt_sub {n m k : Nat} (h\u2081 : m + k \u2264 n) (h\u2082 : 0 < k) :\n    n - (m + k) < n - m", "start": [445, 1], "end": [452, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.le_min", "code": "protected theorem le_min {a b c : Nat} : a \u2264 min b c \u2194 a \u2264 b \u2227 a \u2264 c", "start": [456, 1], "end": [458, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_min", "code": "protected theorem lt_min {a b c : Nat} : a < min b c \u2194 a < b \u2227 a < c", "start": [460, 1], "end": [460, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.min_eq_left", "code": "protected theorem min_eq_left {a b : Nat} (h : a \u2264 b) : min a b = a", "start": [462, 1], "end": [462, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.min_eq_right", "code": "protected theorem min_eq_right {a b : Nat} (h : b \u2264 a) : min a b = b", "start": [464, 1], "end": [465, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_min", "code": "protected theorem zero_min (a : Nat) : min 0 a = 0", "start": [467, 1], "end": [467, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.min_zero", "code": "protected theorem min_zero (a : Nat) : min a 0 = 0", "start": [469, 1], "end": [469, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.max_le", "code": "protected theorem max_le {a b c : Nat} : max a b \u2264 c \u2194 a \u2264 c \u2227 b \u2264 c", "start": [471, 1], "end": [473, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.max_eq_right", "code": "protected theorem max_eq_right {a b : Nat} (h : a \u2264 b) : max a b = b", "start": [475, 1], "end": [476, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.max_eq_left", "code": "protected theorem max_eq_left {a b : Nat} (h : b \u2264 a) : max a b = a", "start": [478, 1], "end": [479, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.min_succ_succ", "code": "theorem min_succ_succ (x y : Nat) : min (succ x) (succ y) = succ (min x y)", "start": [482, 1], "end": [483, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_eq_sub_min", "code": "theorem sub_eq_sub_min (n m : Nat) : n - m = n - min n m", "start": [485, 1], "end": [488, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_add_min_cancel", "code": "@[simp] protected theorem sub_add_min_cancel (n m : Nat) : n - m + min n m = n", "start": [490, 1], "end": [491, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_add_eq_max", "code": "protected theorem sub_add_eq_max {a b : Nat} : a - b + b = max a b", "start": [493, 1], "end": [496, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_right_comm", "code": "protected theorem mul_right_comm (n m k : Nat) : n * m * k = n * k * m", "start": [500, 1], "end": [501, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_mul_mul_comm", "code": "protected theorem mul_mul_mul_comm (a b c d : Nat) : (a * b) * (c * d) = (a * c) * (b * d)", "start": [503, 1], "end": [504, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_two", "code": "protected theorem mul_two (n : Nat) : n * 2 = n + n", "start": [506, 1], "end": [506, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.two_mul", "code": "protected theorem two_mul (n : Nat) : 2 * n = n + n", "start": [508, 1], "end": [508, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_eq_zero", "code": "theorem mul_eq_zero {n m : Nat} : n * m = 0 \u2194 n = 0 \u2228 m = 0", "start": [510, 1], "end": [514, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_ne_zero_iff", "code": "protected theorem mul_ne_zero_iff : n * m \u2260 0 \u2194 n \u2260 0 \u2227 m \u2260 0", "start": [516, 1], "end": [516, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_ne_zero", "code": "protected theorem mul_ne_zero (n0 : n \u2260 0) (m0 : m \u2260 0) : n * m \u2260 0", "start": [518, 1], "end": [519, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_le_mul_of_nonneg_left", "code": "protected theorem mul_le_mul_of_nonneg_left {a b c : Nat} (h\u2081 : a \u2264 b) : c * a \u2264 c * b", "start": [521, 1], "end": [524, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_le_mul_of_nonneg_right", "code": "protected theorem mul_le_mul_of_nonneg_right {a b c : Nat} (h\u2081 : a \u2264 b) : a * c \u2264 b * c", "start": [526, 1], "end": [529, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_lt_mul", "code": "protected theorem mul_lt_mul (hac : a < c) (hbd : b \u2264 d) (pos_b : 0 < b) : a * b < c * d", "start": [531, 1], "end": [532, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_lt_mul'", "code": "protected theorem mul_lt_mul' (h1 : a \u2264 c) (h2 : b < d) (h3 : 0 < c) : a * b < c * d", "start": [534, 1], "end": [535, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_mul_succ_eq", "code": "theorem succ_mul_succ_eq (a b : Nat) : succ a * succ b = a * b + a + b + 1", "start": [537, 1], "end": [538, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_self_sub_mul_self_eq", "code": "protected theorem mul_self_sub_mul_self_eq (a b : Nat) : a * a - b * b = (a + b) * (a - b)", "start": [540, 1], "end": [542, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_add_div", "code": "theorem mod_add_div (m k : Nat) : m % k + k * (m / k) = m", "start": [550, 1], "end": [553, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.div_one", "code": "@[simp] protected theorem div_one (n : Nat) : n / 1 = n", "start": [555, 1], "end": [557, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.div_zero", "code": "@[simp] protected theorem div_zero (n : Nat) : n / 0 = 0", "start": [559, 1], "end": [560, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_div", "code": "@[simp] protected theorem zero_div (b : Nat) : 0 / b = 0", "start": [562, 1], "end": [563, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.le_div_iff_mul_le", "code": "theorem le_div_iff_mul_le (k0 : 0 < k) : x \u2264 y / k \u2194 x * k \u2264 y", "start": [565, 1], "end": [574, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.div_le_of_le_mul", "code": "protected theorem div_le_of_le_mul {m n : Nat} : \u2200 {k}, m \u2264 k * n \u2192 m / k \u2264 n", "start": [576, 1], "end": [585, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_sub_div", "code": "theorem div_eq_sub_div (h\u2081 : 0 < b) (h\u2082 : b \u2264 a) : a / b = (a - b) / b + 1", "start": [587, 1], "end": [588, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_of_lt", "code": "theorem div_eq_of_lt (h\u2080 : a < b) : a / b = 0", "start": [590, 1], "end": [593, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.div_lt_iff_lt_mul", "code": "theorem div_lt_iff_lt_mul (Hk : 0 < k) : x / k < y \u2194 x < y * k", "start": [595, 1], "end": [596, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_mul_div", "code": "theorem sub_mul_div (x n p : Nat) (h\u2081 : n*p \u2264 x) : (x - n*p) / n = x / n - p", "start": [598, 1], "end": [611, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.div_mul_le_self", "code": "theorem div_mul_le_self : \u2200 (m n : Nat), m / n * n \u2264 m", "start": [613, 1], "end": [615, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.add_div_right", "code": "@[simp] theorem add_div_right (x : Nat) {z : Nat} (H : 0 < z) : (x + z) / z = succ (x / z)", "start": [617, 1], "end": [618, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.add_div_left", "code": "@[simp] theorem add_div_left (x : Nat) {z : Nat} (H : 0 < z) : (z + x) / z = succ (x / z)", "start": [620, 1], "end": [621, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_right", "code": "@[simp] theorem mul_div_right (n : Nat) {m : Nat} (H : 0 < m) : m * n / m = n", "start": [623, 1], "end": [624, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_left", "code": "@[simp] theorem mul_div_left (m : Nat) {n : Nat} (H : 0 < n) : m * n / n = m", "start": [626, 1], "end": [627, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.div_self", "code": "protected theorem div_self (H : 0 < n) : n / n = 1", "start": [629, 1], "end": [631, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mul_div_left", "code": "theorem add_mul_div_left (x z : Nat) {y : Nat} (H : 0 < y) : (x + y * z) / y = x / y + z", "start": [633, 1], "end": [636, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mul_div_right", "code": "theorem add_mul_div_right (x y : Nat) {z : Nat} (H : 0 < z) : (x + y * z) / z = x / z + y", "start": [638, 1], "end": [639, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_cancel", "code": "protected theorem mul_div_cancel (m : Nat) {n : Nat} (H : 0 < n) : m * n / n = m", "start": [641, 1], "end": [643, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_cancel_left", "code": "protected theorem mul_div_cancel_left (m : Nat) {n : Nat} (H : 0 < n) : n * m / n = m", "start": [645, 1], "end": [646, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_of_eq_mul_left", "code": "protected theorem div_eq_of_eq_mul_left (H1 : 0 < n) (H2 : m = k * n) : m / n = k", "start": [648, 1], "end": [649, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_of_eq_mul_right", "code": "protected theorem div_eq_of_eq_mul_right (H1 : 0 < n) (H2 : m = n * k) : m / n = k", "start": [651, 1], "end": [652, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_of_lt_le", "code": "protected theorem div_eq_of_lt_le (lo : k * n \u2264 m) (hi : m < succ k * n) : m / n = k", "start": [654, 1], "end": [659, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_sub_div", "code": "theorem mul_sub_div (x n p : Nat) (h\u2081 : x < n*p) : (n * p - succ x) / n = p - succ (x / n)", "start": [661, 1], "end": [672, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.div_div_eq_div_mul", "code": "protected theorem div_div_eq_div_mul (m n k : Nat) : m / n / k = m / (n * k)", "start": [674, 1], "end": [689, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_mul_left", "code": "protected theorem mul_div_mul_left {m : Nat} (n k : Nat) (H : 0 < m) :\n    m * n / (m * k) = n / k", "start": [691, 1], "end": [692, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_mul_right", "code": "protected theorem mul_div_mul_right {m : Nat} (n k : Nat) (H : 0 < m) :\n    n * m / (k * m) = n / k", "start": [694, 1], "end": [695, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_le", "code": "theorem mul_div_le (m n : Nat) : n * (m / n) \u2264 m", "start": [697, 1], "end": [700, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_two_eq_zero_or_one", "code": "theorem mod_two_eq_zero_or_one (n : Nat) : n % 2 = 0 \u2228 n % 2 = 1", "start": [702, 1], "end": [705, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_mod_lt", "code": "theorem le_of_mod_lt {a b : Nat} (h : a % b < a) : b \u2264 a", "start": [707, 1], "end": [708, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod_right", "code": "@[simp] theorem add_mod_right (x z : Nat) : (x + z) % z = x % z", "start": [710, 1], "end": [711, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod_left", "code": "@[simp] theorem add_mod_left (x z : Nat) : (x + z) % x = z % x", "start": [713, 1], "end": [714, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mul_mod_self_left", "code": "@[simp] theorem add_mul_mod_self_left (x y z : Nat) : (x + y * z) % y = x % y", "start": [716, 1], "end": [719, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mul_mod_self_right", "code": "@[simp] theorem add_mul_mod_self_right (x y z : Nat) : (x + y * z) % z = x % z", "start": [721, 1], "end": [722, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_mod_right", "code": "@[simp] theorem mul_mod_right (m n : Nat) : (m * n) % m = 0", "start": [724, 1], "end": [725, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_mod_left", "code": "@[simp] theorem mul_mod_left (m n : Nat) : (m * n) % n = 0", "start": [727, 1], "end": [728, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_mod_mul_left", "code": "theorem mul_mod_mul_left (z x y : Nat) : (z * x) % (z * y) = z * (x % y)", "start": [730, 1], "end": [745, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_mod_mul_right", "code": "theorem mul_mod_mul_right (z x y : Nat) : (x * z) % (y * z) = (x % y) * z", "start": [747, 1], "end": [748, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_mul_mod", "code": "theorem sub_mul_mod {x k n : Nat} (h\u2081 : n*k \u2264 x) : (x - n*k) % n = x % n", "start": [752, 1], "end": [761, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_mod", "code": "@[simp] theorem mod_mod (a n : Nat) : (a % n) % n = a % n", "start": [763, 1], "end": [766, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_mod", "code": "theorem mul_mod (a b n : Nat) : a * b % n = (a % n) * (b % n) % n", "start": [768, 1], "end": [772, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_add_mod", "code": "@[simp] theorem mod_add_mod (m n k : Nat) : (m % n + k) % n = (m + k) % n", "start": [774, 1], "end": [776, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod_mod", "code": "@[simp] theorem add_mod_mod (m n k : Nat) : (m + n % k) % k = (m + n) % k", "start": [778, 1], "end": [779, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod", "code": "theorem add_mod (a b n : Nat) : (a + b) % n = ((a % n) + (b % n)) % n", "start": [781, 1], "end": [782, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_succ'", "code": "theorem pow_succ' {m n : Nat} : m ^ n.succ = m * m ^ n", "start": [786, 1], "end": [787, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_eq", "code": "@[simp] theorem pow_eq {m n : Nat} : m.pow n = m ^ n", "start": [789, 1], "end": [789, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft_eq", "code": "@[simp] theorem shiftLeft_eq (a b : Nat) : a <<< b = a * 2 ^ b", "start": [791, 1], "end": [795, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.one_shiftLeft", "code": "theorem one_shiftLeft (n : Nat) : 1 <<< n = 2 ^ n", "start": [797, 1], "end": [797, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_pow", "code": "protected theorem zero_pow {n : Nat} (H : 0 < n) : 0 ^ n = 0", "start": [801, 1], "end": [804, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.one_pow", "code": "@[simp] protected theorem one_pow (n : Nat) : 1 ^ n = 1", "start": [806, 1], "end": [809, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_one", "code": "@[simp] protected theorem pow_one (a : Nat) : a ^ 1 = a", "start": [811, 1], "end": [812, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_two", "code": "protected theorem pow_two (a : Nat) : a ^ 2 = a * a", "start": [814, 1], "end": [814, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_add", "code": "protected theorem pow_add (a m n : Nat) : a ^ (m + n) = a ^ m * a ^ n", "start": [816, 1], "end": [819, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_add'", "code": "protected theorem pow_add' (a m n : Nat) : a ^ (m + n) = a ^ n * a ^ m", "start": [821, 1], "end": [822, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_mul", "code": "protected theorem pow_mul (a m n : Nat) : a ^ (m * n) = (a ^ m) ^ n", "start": [824, 1], "end": [827, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_mul'", "code": "protected theorem pow_mul' (a m n : Nat) : a ^ (m * n) = (a ^ n) ^ m", "start": [829, 1], "end": [830, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_right_comm", "code": "protected theorem pow_right_comm (a m n : Nat) : (a ^ m) ^ n = (a ^ n) ^ m", "start": [832, 1], "end": [833, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_pow", "code": "protected theorem mul_pow (a b n : Nat) : (a * b) ^ n = a ^ n * b ^ n", "start": [835, 1], "end": [838, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.le_log2", "code": "theorem le_log2 (h : n \u2260 0) : k \u2264 n.log2 \u2194 2 ^ k \u2264 n", "start": [842, 1], "end": [851, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.log2_lt", "code": "theorem log2_lt (h : n \u2260 0) : n.log2 < k \u2194 n < 2 ^ k", "start": [853, 1], "end": [854, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.log2_self_le", "code": "theorem log2_self_le (h : n \u2260 0) : 2 ^ n.log2 \u2264 n", "start": [856, 1], "end": [856, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_log2_self", "code": "theorem lt_log2_self (h : n \u2260 0) : n < 2 ^ (n.log2 + 1)", "start": [858, 1], "end": [858, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_refl", "code": "protected theorem dvd_refl (a : Nat) : a \u2223 a", "start": [862, 1], "end": [862, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_zero", "code": "protected theorem dvd_zero (a : Nat) : a \u2223 0", "start": [864, 1], "end": [864, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_mul_left", "code": "protected theorem dvd_mul_left (a b : Nat) : a \u2223 b * a", "start": [866, 1], "end": [866, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_mul_right", "code": "protected theorem dvd_mul_right (a b : Nat) : a \u2223 a * b", "start": [868, 1], "end": [868, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_trans", "code": "protected theorem dvd_trans {a b c : Nat} (h\u2081 : a \u2223 b) (h\u2082 : b \u2223 c) : a \u2223 c", "start": [870, 1], "end": [873, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_zero_dvd", "code": "protected theorem eq_zero_of_zero_dvd {a : Nat} (h : 0 \u2223 a) : a = 0", "start": [875, 1], "end": [876, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_add", "code": "protected theorem dvd_add {a b c : Nat} (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c", "start": [878, 1], "end": [879, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_add_iff_right", "code": "protected theorem dvd_add_iff_right {k m n : Nat} (h : k \u2223 m) : k \u2223 n \u2194 k \u2223 m + n", "start": [881, 1], "end": [885, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_add_iff_left", "code": "protected theorem dvd_add_iff_left {k m n : Nat} (h : k \u2223 n) : k \u2223 m \u2194 k \u2223 m + n", "start": [887, 1], "end": [888, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_sub", "code": "theorem dvd_sub {k m n : Nat} (H : n \u2264 m) (h\u2081 : k \u2223 m) (h\u2082 : k \u2223 n) : k \u2223 m - n", "start": [890, 1], "end": [891, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_dvd_mul", "code": "protected theorem mul_dvd_mul {a b c d : Nat} : a \u2223 b \u2192 c \u2223 d \u2192 a * c \u2223 b * d", "start": [893, 1], "end": [895, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_dvd_mul_left", "code": "protected theorem mul_dvd_mul_left (a : Nat) (h : b \u2223 c) : a * b \u2223 a * c", "start": [897, 1], "end": [898, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_dvd_mul_right", "code": "protected theorem mul_dvd_mul_right (h: a \u2223 b) (c : Nat) : a * c \u2223 b * c", "start": [900, 1], "end": [901, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_mod_iff", "code": "theorem dvd_mod_iff {k m n : Nat} (h: k \u2223 n) : k \u2223 m % n \u2194 k \u2223 m", "start": [903, 1], "end": [905, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_dvd", "code": "theorem le_of_dvd {m n : Nat} (h : 0 < n) : m \u2223 n \u2192 m \u2264 n", "start": [907, 1], "end": [916, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_antisymm", "code": "protected theorem dvd_antisymm : \u2200 {m n : Nat}, m \u2223 n \u2192 n \u2223 m \u2192 m = n", "start": [918, 1], "end": [921, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_dvd_of_pos", "code": "theorem pos_of_dvd_of_pos {m n : Nat} (H1 : m \u2223 n) (H2 : 0 < n) : 0 < m", "start": [923, 1], "end": [924, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_one_of_dvd_one", "code": "theorem eq_one_of_dvd_one {n : Nat} (H : n \u2223 1) : n = 1", "start": [926, 1], "end": [927, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_mod_eq_zero", "code": "theorem dvd_of_mod_eq_zero {m n : Nat} (H : n % m = 0) : m \u2223 n", "start": [929, 1], "end": [932, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_eq_zero_of_dvd", "code": "theorem mod_eq_zero_of_dvd {m n : Nat} (H : m \u2223 n) : n % m = 0", "start": [934, 1], "end": [935, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_iff_mod_eq_zero", "code": "theorem dvd_iff_mod_eq_zero (m n : Nat) : m \u2223 n \u2194 n % m = 0", "start": [937, 1], "end": [938, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.decidable_dvd", "code": "instance decidable_dvd : @DecidableRel Nat (\u00b7\u2223\u00b7) :=\n  fun _ _ => decidable_of_decidable_of_iff (dvd_iff_mod_eq_zero _ _).symm", "start": [940, 1], "end": [941, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_cancel'", "code": "protected theorem mul_div_cancel' {n m : Nat} (H : n \u2223 m) : n * (m / n) = m", "start": [943, 1], "end": [945, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.div_mul_cancel", "code": "protected theorem div_mul_cancel {n m : Nat} (H : n \u2223 m) : m / n * n = m", "start": [947, 1], "end": [948, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_assoc", "code": "protected theorem mul_div_assoc (m : Nat) (H : k \u2223 n) : m * n / k = m * (n / k)", "start": [950, 1], "end": [955, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_mul_dvd_mul_left", "code": "protected theorem dvd_of_mul_dvd_mul_left\n    (kpos : 0 < k) (H : k * m \u2223 k * n) : m \u2223 n", "start": [957, 1], "end": [961, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_mul_dvd_mul_right", "code": "protected theorem dvd_of_mul_dvd_mul_right (kpos : 0 < k) (H : m * k \u2223 n * k) : m \u2223 n", "start": [963, 1], "end": [964, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_nil", "code": "@[simp] theorem sum_nil : Nat.sum [] = 0", "start": [968, 1], "end": [968, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_cons", "code": "@[simp] theorem sum_cons : Nat.sum (a :: l) = a + Nat.sum l", "start": [970, 1], "end": [970, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_append", "code": "@[simp] theorem sum_append : Nat.sum (l\u2081 ++ l\u2082) = Nat.sum l\u2081 + Nat.sum l\u2082", "start": [972, 1], "end": [973, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftRight_zero", "code": "@[simp] theorem shiftRight_zero : n >>> 0 = n", "start": [977, 1], "end": [977, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftRight_succ", "code": "@[simp] theorem shiftRight_succ (m n) : m >>> (n + 1) = (m >>> n) / 2", "start": [979, 1], "end": [979, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_shiftRight", "code": "@[simp] theorem zero_shiftRight : \u2200 n, 0 >>> n = 0", "start": [981, 1], "end": [983, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftRight_add", "code": "theorem shiftRight_add (m n : Nat) : \u2200 k, m >>> (n + k) = (m >>> n) >>> k", "start": [985, 1], "end": [987, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftRight_eq_div_pow", "code": "theorem shiftRight_eq_div_pow (m : Nat) : \u2200 n, m >>> n = m / 2 ^ n", "start": [989, 1], "end": [993, 50], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Generalize.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Generalize.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Lean/Elab/Binders.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.evalGeneralize", "code": "@[builtin_tactic Lean.Parser.Tactic.generalize] def evalGeneralize : Tactic := fun stx =>\n  withMainContext do\n    let mut xIdents := #[]\n    let mut hIdents := #[]\n    let mut args := #[]\n    for arg in stx[1].getSepArgs do\n      let hName? \u2190 if arg[0].isNone then\n        pure none\n      else\n        hIdents := hIdents.push arg[0][0]\n        pure (some arg[0][0].getId)\n      let expr \u2190 elabTerm arg[1] none\n      xIdents := xIdents.push arg[3]\n      args := args.push { hName?, expr, xName? := arg[3].getId : GeneralizeArg }\n    let hyps \u2190 match expandOptLocation stx[2] with\n    | .targets hyps _ => getFVarIds hyps\n    | .wildcard => pure (\u2190 getLCtx).getFVarIds\n    let mvarId \u2190 getMainGoal\n    mvarId.withContext do\n      let (_, newVars, mvarId) \u2190 mvarId.generalizeHyp args hyps\n      mvarId.withContext do\n        for v in newVars, id in xIdents ++ hIdents do\n          Term.addLocalVarInfo id (.fvar v)\n        replaceMainGoal [mvarId]", "start": [16, 1], "end": [39, 33], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/App.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Arg.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/ElimInfo.lean", "lake-packages/lean4/src/lean/Lean/Meta/KAbstract.lean", "lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/Binders.lean", "lake-packages/lean4/src/lean/Lean/Elab/RecAppSyntax.lean", "lake-packages/lean4/src/lean/Lean/Util/FindMVar.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean"], "premises": [{"full_name": "Lean.Elab.Term.hasElabWithoutExpectedType", "code": "def hasElabWithoutExpectedType (env : Environment) (declName : Name) : Bool :=\n  elabWithoutExpectedTypeAttr.hasTag env declName", "start": [22, 1], "end": [23, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.throwInvalidNamedArg", "code": "def throwInvalidNamedArg (namedArg : NamedArg) (fn? : Option Name) : TermElabM \u03b1 :=\n  withRef namedArg.ref <| match fn? with\n    | some fn => throwError \"invalid argument name '{namedArg.name}' for function '{fn}'\"\n    | none    => throwError \"invalid argument name '{namedArg.name}' for function\"", "start": [33, 1], "end": [36, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ensureArgType", "code": "private def ensureArgType (f : Expr) (arg : Expr) (expectedType : Expr) : TermElabM Expr := do\n  try\n    ensureHasType expectedType arg none f\n  catch\n    | ex@(.error ..) =>\n      if (\u2190 read).errToSorry then\n        exceptionToSorry ex expectedType\n      else\n        throw ex\n    | ex => throw ex", "start": [38, 1], "end": [47, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkProjAndCheck", "code": "private def mkProjAndCheck (structName : Name) (idx : Nat) (e : Expr) : MetaM Expr := do\n  let r := mkProj structName idx e\n  let eType \u2190 inferType e\n  if (\u2190 isProp eType) then\n    let rType \u2190 inferType r\n    if !(\u2190 isProp rType) then\n      throwError \"invalid projection, the expression{indentExpr e}\\nis a proposition and has type{indentExpr eType}\\nbut the projected value is not, it has type{indentExpr rType}\"\n  return r", "start": [49, 1], "end": [56, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeAppInstMVars", "code": "def synthesizeAppInstMVars (instMVars : Array MVarId) (app : Expr) : TermElabM Unit :=\n  for mvarId in instMVars do\n    unless (\u2190 synthesizeInstMVarCore mvarId) do\n      registerSyntheticMVarWithCurrRef mvarId SyntheticMVarKind.typeClass\n      registerMVarErrorImplicitArgInfo mvarId (\u2190 getRef) app", "start": [58, 1], "end": [62, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.findBinderName?", "code": "private def findBinderName? (namedArgs : List NamedArg) (binderName : Name) : Option NamedArg :=\n  namedArgs.find? fun namedArg => namedArg.name == binderName", "start": [64, 1], "end": [66, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.eraseNamedArg", "code": "def eraseNamedArg (namedArgs : List NamedArg) (binderName : Name) : List NamedArg :=\n  namedArgs.filter (\u00b7.name != binderName)", "start": [68, 1], "end": [70, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.hasOptAutoParams", "code": "private def hasOptAutoParams (type : Expr) : MetaM Bool := do\n  forallTelescopeReducing type fun xs _ =>\n    xs.anyM fun x => do\n      let xType \u2190 inferType x\n      return xType.getOptParamDefault?.isSome || xType.getAutoParamTactic?.isSome", "start": [72, 1], "end": [77, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.Context", "code": "structure Context where\n  \n  ellipsis      : Bool  \n  explicit      : Bool\n  \n  resultIsOutParamSupport : Bool", "start": [83, 1], "end": [123, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.State", "code": "structure State where\n  f                    : Expr\n  fType                : Expr\n  \n  args                 : List Arg\n  \n  namedArgs            : List NamedArg\n  expectedType?        : Option Expr\n  \n  etaArgs              : Array Expr   := #[]\n  \n  toSetErrorCtx        : Array MVarId := #[]\n  \n  instMVars            : Array MVarId := #[]\n  \n  propagateExpected    : Bool\n  \n  resultTypeOutParam?  : Option MVarId := none", "start": [125, 1], "end": [159, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.M", "code": "abbrev M := ReaderT Context (StateRefT State TermElabM)", "start": [161, 1], "end": [161, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.addInstMVar", "code": "private def addInstMVar (mvarId : MVarId) : M Unit :=\n  modify fun s => { s with instMVars := s.instMVars.push mvarId }", "start": [163, 1], "end": [165, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.trySynthesizeAppInstMVars", "code": "def trySynthesizeAppInstMVars : M Unit := do\n  let instMVars \u2190 (\u2190 get).instMVars.filterM fun instMVar => do\n    unless (\u2190 instantiateMVars (\u2190 inferType (.mvar instMVar))).isMVar do try\n      if (\u2190 synthesizeInstMVarCore instMVar) then\n        return false\n      catch _ => pure ()\n    return true\n  modify ({ \u00b7 with instMVars })", "start": [167, 1], "end": [181, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.synthesizeAppInstMVars", "code": "def synthesizeAppInstMVars : M Unit := do\n  Term.synthesizeAppInstMVars (\u2190 get).instMVars (\u2190 get).f\n  modify ({ \u00b7 with instMVars := #[] })", "start": [183, 1], "end": [189, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.synthesizePendingAndNormalizeFunType", "code": "private def synthesizePendingAndNormalizeFunType : M Unit := do\n  trySynthesizeAppInstMVars\n  synthesizeSyntheticMVars\n  let s \u2190 get\n  let fType \u2190 whnfForall s.fType\n  if fType.isForall then\n    modify fun s => { s with fType }\n  else\n    if let some f \u2190 coerceToFunction? s.f then\n      let fType \u2190 inferType f\n      modify fun s => { s with f, fType }\n    else\n      for namedArg in s.namedArgs do\n        let f := s.f.getAppFn\n        if f.isConst then\n          throwInvalidNamedArg namedArg f.constName!\n        else\n          throwInvalidNamedArg namedArg none\n      throwError \"function expected at{indentExpr s.f}\\nterm has type{indentExpr fType}\"", "start": [191, 1], "end": [210, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.normalizeFunType", "code": "private def normalizeFunType : M Expr := do\n  let s \u2190 get\n  let fType \u2190 whnfForall s.fType\n  modify fun s => { s with fType }\n  return fType", "start": [212, 1], "end": [217, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.getBindingName", "code": "private def getBindingName : M Name := return (\u2190 get).fType.bindingName!", "start": [219, 1], "end": [220, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.getArgExpectedType", "code": "private def getArgExpectedType : M Expr := return (\u2190 get).fType.bindingDomain!", "start": [222, 1], "end": [223, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.eraseNamedArg", "code": "def eraseNamedArg (binderName : Name) : M Unit :=\n  modify fun s => { s with namedArgs := Term.eraseNamedArg s.namedArgs binderName }", "start": [225, 1], "end": [227, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.addNewArg", "code": "private def addNewArg (argName : Name) (arg : Expr) : M Unit := do\n  modify fun s => { s with f := mkApp s.f arg, fType := s.fType.bindingBody!.instantiate1 arg }\n  if arg.isMVar then\n    let mvarId := arg.mvarId!\n    if let some mvarErrorInfo \u2190 getMVarErrorInfo? mvarId then\n      registerMVarErrorInfo { mvarErrorInfo with argName? := argName }", "start": [229, 1], "end": [237, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.elabAndAddNewArg", "code": "private def elabAndAddNewArg (argName : Name) (arg : Arg) : M Unit := do\n  let s \u2190 get\n  let expectedType := (\u2190 getArgExpectedType).consumeTypeAnnotations\n  match arg with\n  | Arg.expr val =>\n    let arg \u2190 ensureArgType s.f val expectedType\n    addNewArg argName arg\n  | Arg.stx stx  =>\n    let val \u2190 elabTerm stx expectedType\n    let arg \u2190 withRef stx <| ensureArgType s.f val expectedType\n    addNewArg argName arg", "start": [239, 1], "end": [252, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.fTypeHasOptAutoParams", "code": "private def fTypeHasOptAutoParams : M Bool := do\n  hasOptAutoParams (\u2190 get).fType", "start": [254, 1], "end": [256, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.getForallBody", "code": "private partial def getForallBody (explicit : Bool) : Nat \u2192 List NamedArg \u2192 Expr \u2192 Option Expr\n  | i, namedArgs, type@(.forallE n d b bi) =>\n    match findBinderName? namedArgs n with\n    | some _ => getForallBody explicit i (Term.eraseNamedArg namedArgs n) b\n    | none =>\n      if !explicit && !bi.isExplicit then\n        getForallBody explicit i namedArgs b\n      else if i > 0 then\n        getForallBody explicit (i-1) namedArgs b\n      else if d.isAutoParam || d.isOptParam then\n        getForallBody explicit i namedArgs b\n      else\n        some type\n  | 0, [], type => some type\n  | _, _,  _    => none", "start": [258, 1], "end": [276, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.shouldPropagateExpectedTypeFor", "code": "private def shouldPropagateExpectedTypeFor (nextArg : Arg) : Bool :=\n  match nextArg with\n  | .expr _  => false | .stx stx =>\n    stx.getKind != ``Lean.Parser.Term.hole &&\n    stx.getKind != ``Lean.Parser.Term.syntheticHole &&\n    stx.getKind != ``Lean.Parser.Term.byTactic", "start": [278, 1], "end": [285, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.propagateExpectedType", "code": "private def propagateExpectedType (arg : Arg) : M Unit := do\n  if shouldPropagateExpectedTypeFor arg then\n    let s \u2190 get\n    unless !s.etaArgs.isEmpty || !s.propagateExpected do\n      match s.expectedType? with\n      | none              => pure ()\n      | some expectedType =>\n        \n        if expectedType.isProp then\n          modify fun s => { s with propagateExpected := false }\n        else\n          let numRemainingArgs := s.args.length\n          trace[Elab.app.propagateExpectedType] \"etaArgs.size: {s.etaArgs.size}, numRemainingArgs: {numRemainingArgs}, fType: {s.fType}\"\n          match getForallBody (\u2190 read).explicit numRemainingArgs s.namedArgs s.fType with\n          | none           => pure ()\n          | some fTypeBody =>\n            unless fTypeBody.hasLooseBVars do\n              unless (\u2190 hasOptAutoParams fTypeBody) do\n                trySynthesizeAppInstMVars\n                trace[Elab.app.propagateExpectedType] \"{expectedType} =?= {fTypeBody}\"\n                if (\u2190 isDefEq expectedType fTypeBody) then\n                  \n                  modify fun s => { s with propagateExpected := false }", "start": [287, 1], "end": [369, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.finalize", "code": "private def finalize : M Expr := do\n  let s \u2190 get\n  let mut e := s.f\n  trace[Elab.app.finalize] e\n  let ref \u2190 getRef\n  for mvarId in s.toSetErrorCtx do\n    registerMVarErrorImplicitArgInfo mvarId ref e\n  if !s.etaArgs.isEmpty then\n    e \u2190 mkLambdaFVars s.etaArgs e\n  \n  let eType \u2190 inferType e\n  trace[Elab.app.finalize] \"after etaArgs, {e} : {eType}\"\n  \n  if let some outParamMVarId := s.resultTypeOutParam? then\n    synthesizeAppInstMVars\n    \n    if !(\u2190 outParamMVarId.isAssigned) && eType.isMVar && eType.mvarId! == outParamMVarId then\n      synthesizeSyntheticMVarsUsingDefault\n      return e\n    else\n      return e\n  if let some expectedType := s.expectedType? then\n    trySynthesizeAppInstMVars\n    trace[Elab.app.finalize] \"expected type: {expectedType}\"\n    discard <| isDefEq expectedType eType\n  synthesizeAppInstMVars\n  return e", "start": [371, 1], "end": [412, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.anyNamedArgDependsOnCurrent", "code": "private def anyNamedArgDependsOnCurrent : M Bool := do\n  let s \u2190 get\n  if s.namedArgs.isEmpty then\n    return false\n  else\n    forallTelescopeReducing s.fType fun xs _ => do\n      let curr := xs[0]!\n      for i in [1:xs.size] do\n        let xDecl \u2190 xs[i]!.fvarId!.getDecl\n        if s.namedArgs.any fun arg => arg.name == xDecl.userName then\n          \n          if (\u2190 exprDependsOn xDecl.type.cleanupAnnotations curr.fvarId!) then\n            return true\n      return false", "start": [414, 1], "end": [428, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.hasArgsToProcess", "code": "private def hasArgsToProcess : M Bool := do\n  let s \u2190 get\n  return !s.args.isEmpty || !s.namedArgs.isEmpty", "start": [431, 1], "end": [434, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.isNextArgHole", "code": "private def isNextArgHole : M Bool := do\n  match (\u2190 get).args with\n  | Arg.stx (Syntax.node _ ``Lean.Parser.Term.hole _) :: _ => pure true\n  | _ => pure false", "start": [436, 1], "end": [440, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.isNextOutParamOfLocalInstanceAndResult", "code": "private partial def isNextOutParamOfLocalInstanceAndResult : M Bool := do\n  if !(\u2190 read).resultIsOutParamSupport then\n    return false\n  let type := (\u2190 get).fType.bindingBody!\n  unless isResultType type 0 do\n    return false\n  if (\u2190 hasLocalInstaceWithOutParams type) then\n    let x := mkFVar (\u2190 mkFreshFVarId)\n    isOutParamOfLocalInstance x (type.instantiate1 x)\n  else\n    return false\nwhere\n  isResultType (type : Expr) (i : Nat) : Bool :=\n    match type with\n    | .forallE _ _ b _ => isResultType b (i + 1)\n    | .bvar idx        => idx == i\n    | _                => false\n\n  \n  hasLocalInstaceWithOutParams (type : Expr) : CoreM Bool := do\n    let .forallE _ d b bi := type | return false\n    if bi.isInstImplicit then\n      if let .const declName .. := d.getAppFn then\n        if hasOutParams (\u2190 getEnv) declName then\n          return true\n    hasLocalInstaceWithOutParams b\n\n  isOutParamOfLocalInstance (x : Expr) (type : Expr) : MetaM Bool := do\n    let .forallE _ d b bi := type | return false\n    if bi.isInstImplicit then\n      if let .const declName .. := d.getAppFn then\n        if hasOutParams (\u2190 getEnv) declName then\n          let cType \u2190 inferType d.getAppFn\n          if (\u2190 isOutParamOf x 0 d.getAppArgs cType) then\n            return true\n    isOutParamOfLocalInstance x b\n\n  isOutParamOf (x : Expr) (i : Nat) (args : Array Expr) (cType : Expr) : MetaM Bool := do\n    if h : i < args.size then\n      match (\u2190 whnf cType) with\n      | .forallE _ d b _ =>\n        let arg := args.get \u27e8i, h\u27e9\n        if arg == x && d.isOutParam then\n          return true\n        isOutParamOf x (i+1) args b\n      | _ => return false\n    else\n      return false", "start": [442, 1], "end": [511, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.addEtaArg", "code": "private partial def addEtaArg (argName : Name) : M Expr := do\n    let n    \u2190 getBindingName\n    let type \u2190 getArgExpectedType\n    withLocalDeclD n type fun x => do\n      modify fun s => { s with etaArgs := s.etaArgs.push x }\n      addNewArg argName x\n      main", "start": [514, 3], "end": [523, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.addImplicitArg", "code": "private partial def addImplicitArg (argName : Name) : M Expr := do\n    let argType \u2190 getArgExpectedType\n    let arg \u2190 if (\u2190 isNextOutParamOfLocalInstanceAndResult) then\n      let arg \u2190 mkFreshExprMVar argType\n      \n      modify fun s => { s with resultTypeOutParam? := some arg.mvarId!, propagateExpected := false }\n      pure arg\n    else\n      mkFreshExprMVar argType\n    modify fun s => { s with toSetErrorCtx := s.toSetErrorCtx.push arg.mvarId! }\n    addNewArg argName arg\n    main", "start": [525, 3], "end": [539, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.processExplictArg", "code": "private partial def processExplictArg (argName : Name) : M Expr := do\n    match (\u2190 get).args with\n    | arg::args =>\n      if (\u2190 anyNamedArgDependsOnCurrent) then\n        \n        return (\u2190 addImplicitArg argName)\n      propagateExpectedType arg\n      modify fun s => { s with args }\n      elabAndAddNewArg argName arg\n      main\n    | _ =>\n      let argType \u2190 getArgExpectedType\n      match (\u2190 read).explicit, argType.getOptParamDefault?, argType.getAutoParamTactic? with\n      | false, some defVal, _  => addNewArg argName defVal; main\n      | false, _, some (.const tacticDecl _) =>\n        let env \u2190 getEnv\n        let opts \u2190 getOptions\n        match evalSyntaxConstant env opts tacticDecl with\n        | Except.error err       => throwError err\n        | Except.ok tacticSyntax =>\n          let tacticBlock \u2190 `(by $(\u27e8tacticSyntax\u27e9))\n          let argNew := Arg.stx tacticBlock\n          propagateExpectedType argNew\n          elabAndAddNewArg argName argNew\n          main\n      | false, _, some _ =>\n        throwError \"invalid autoParam, argument must be a constant\"\n      | _, _, _ =>\n        if !(\u2190 get).namedArgs.isEmpty then\n          if (\u2190 anyNamedArgDependsOnCurrent) then\n            addImplicitArg argName\n          else if (\u2190 read).ellipsis then\n            addImplicitArg argName\n          else\n            addEtaArg argName\n        else if !(\u2190 read).explicit then\n          if (\u2190 read).ellipsis then\n            addImplicitArg argName\n          else if (\u2190 fTypeHasOptAutoParams) then\n            addEtaArg argName\n          else\n            finalize\n        else\n          finalize", "start": [541, 3], "end": [611, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.processImplicitArg", "code": "private partial def processImplicitArg (argName : Name) : M Expr := do\n    if (\u2190 read).explicit then\n      processExplictArg argName\n    else\n      addImplicitArg argName", "start": [613, 3], "end": [620, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.processStrictImplicitArg", "code": "private partial def processStrictImplicitArg (argName : Name) : M Expr := do\n    if (\u2190 read).explicit then\n      processExplictArg argName\n    else if (\u2190 hasArgsToProcess) then\n      addImplicitArg argName\n    else\n      finalize", "start": [622, 3], "end": [631, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.processInstImplicitArg", "code": "private partial def processInstImplicitArg (argName : Name) : M Expr := do\n    if (\u2190 read).explicit then\n      if (\u2190 isNextArgHole) then\n        \n        let arg \u2190 mkFreshExprMVar (\u2190 getArgExpectedType) MetavarKind.synthetic\n        modify fun s => { s with args := s.args.tail! }\n        addInstMVar arg.mvarId!\n        addNewArg argName arg\n        main\n      else\n        processExplictArg argName\n    else\n      let arg \u2190 mkFreshExprMVar (\u2190 getArgExpectedType) MetavarKind.synthetic\n      addInstMVar arg.mvarId!\n      addNewArg argName arg\n      main", "start": [633, 3], "end": [651, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabAppArgs.main", "code": "partial def main : M Expr := do\n    let fType \u2190 normalizeFunType\n    if fType.isForall then\n      let binderName := fType.bindingName!\n      let binfo := fType.bindingInfo!\n      let s \u2190 get\n      match findBinderName? s.namedArgs binderName with\n      | some namedArg =>\n        propagateExpectedType namedArg.val\n        eraseNamedArg binderName\n        elabAndAddNewArg binderName namedArg.val\n        main\n      | none          =>\n        match binfo with\n        | .implicit       => processImplicitArg binderName\n        | .instImplicit   => processInstImplicitArg binderName\n        | .strictImplicit => processStrictImplicitArg binderName\n        | _               => processExplictArg binderName\n    else if (\u2190 hasArgsToProcess) then\n      synthesizePendingAndNormalizeFunType\n      main\n    else\n      finalize", "start": [653, 3], "end": [676, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.Context", "code": "structure Context where\n  elimInfo : ElimInfo\n  expectedType : Expr\n  \n  extraArgsPos : Array Nat", "start": [702, 1], "end": [716, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.State", "code": "structure State where\n  \n  f            : Expr\n  \n  fType        : Expr\n  \n  namedArgs    : List NamedArg\n  \n  args         : List Arg\n  \n  discrs       : Array Expr := #[]\n  \n  instMVars    : Array MVarId := #[]\n  \n  idx          : Nat := 0\n  \n  motive?      : Option Expr := none", "start": [718, 1], "end": [735, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.M", "code": "abbrev M := ReaderT Context $ StateRefT State TermElabM", "start": [737, 1], "end": [737, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.mkMotive", "code": "def mkMotive (discrs : Array Expr) (expectedType : Expr): MetaM Expr := do\n  discrs.foldrM (init := expectedType) fun discr motive => do\n    let discr \u2190 instantiateMVars discr\n    let motiveBody \u2190 kabstract motive discr\n    \n    let discrType \u2190 transform (usedLetOnly := true) (\u2190 instantiateMVars (\u2190 inferType discr))\n    return Lean.mkLambda (\u2190 mkFreshBinderName) BinderInfo.default discrType motiveBody", "start": [739, 1], "end": [746, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.revertArgs", "code": "def revertArgs (args : List Arg) (f : Expr) (expectedType : Expr) : TermElabM (Expr \u00d7 Expr) :=\n  args.foldrM (init := (f, expectedType)) fun arg (f, expectedType) => do\n    let val \u2190\n      match arg with\n      | .expr val => pure val\n      | .stx stx => elabTerm stx none\n    let val \u2190 instantiateMVars val\n    let expectedTypeBody \u2190 kabstract expectedType val\n    \n    let valType \u2190 transform (usedLetOnly := true) (\u2190 instantiateMVars (\u2190 inferType val))\n    return (mkApp f val, mkForall (\u2190 mkFreshBinderName) BinderInfo.default valType expectedTypeBody)", "start": [748, 1], "end": [759, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.finalize", "code": "def finalize : M Expr := do\n  unless (\u2190 get).namedArgs.isEmpty do\n    throwError \"failed to elaborate eliminator, unused named arguments: {(\u2190 get).namedArgs.map (\u00b7.name)}\"\n  let some motive := (\u2190 get).motive?\n    | throwError \"failed to elaborate eliminator, insufficient number of arguments\"\n  forallTelescope (\u2190 get).fType fun xs _ => do\n    let mut expectedType := (\u2190 read).expectedType\n    let mut f := (\u2190 get).f\n    if xs.size > 0 then\n      assert! (\u2190 get).args.isEmpty\n      try\n        expectedType \u2190 instantiateForall expectedType xs\n      catch _ =>\n        throwError \"failed to elaborate eliminator, insufficient number of arguments, expected type:{indentExpr expectedType}\"\n    else\n      (f, expectedType) \u2190 revertArgs (\u2190 get).args f expectedType\n    let result := mkAppN f xs\n    let mut discrs := (\u2190 get).discrs\n    let idx := (\u2190 get).idx\n    if (\u2190 get).discrs.size < (\u2190 read).elimInfo.targetsPos.size then\n      for i in [idx:idx + xs.size], x in xs do\n        if (\u2190 read).elimInfo.targetsPos.contains i then\n          discrs := discrs.push x\n    let motiveVal \u2190 mkMotive discrs expectedType\n    unless (\u2190 isDefEq motive motiveVal) do\n      throwError \"failed to elaborate eliminator, invalid motive{indentExpr motiveVal}\"\n    synthesizeAppInstMVars (\u2190 get).instMVars result\n    let result \u2190 mkLambdaFVars xs (\u2190 instantiateMVars result)\n    return result", "start": [761, 1], "end": [794, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.getNextArg?", "code": "def getNextArg? (binderName : Name) (binderInfo : BinderInfo) : M (LOption Arg) := do\n  match findBinderName? (\u2190 get).namedArgs binderName with\n  | some namedArg =>\n    modify fun s => { s with namedArgs := eraseNamedArg s.namedArgs binderName }\n    return .some namedArg.val\n  | none =>\n    if binderInfo.isExplicit then\n      match (\u2190 get).args with\n      | [] => return .undef\n      | arg :: args =>\n        modify fun s => { s with args }\n        return .some arg\n    else\n      return .none", "start": [796, 1], "end": [814, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.setMotive", "code": "def setMotive (motive : Expr) : M Unit :=\n  modify fun s => { s with motive? := motive }", "start": [816, 1], "end": [818, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.addDiscr", "code": "def addDiscr (discr : Expr) : M Unit :=\n  modify fun s => { s with discrs := s.discrs.push discr }", "start": [820, 1], "end": [822, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.elabArg", "code": "private def elabArg (arg : Arg) (argExpectedType : Expr) : M Expr := do\n  match arg with\n  | Arg.expr val => ensureArgType (\u2190 get).f val argExpectedType\n  | Arg.stx stx  =>\n    let val \u2190 elabTerm stx argExpectedType\n    withRef stx <| ensureArgType (\u2190 get).f val argExpectedType", "start": [824, 1], "end": [830, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.saveArgInfo", "code": "def saveArgInfo (arg : Expr) (binderName : Name) : M Unit := do\n  if arg.isMVar then\n    let mvarId := arg.mvarId!\n    if let some mvarErrorInfo \u2190 getMVarErrorInfo? mvarId then\n      registerMVarErrorInfo { mvarErrorInfo with argName? := binderName }", "start": [832, 1], "end": [837, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.mkImplicitArg", "code": "def mkImplicitArg (argExpectedType : Expr) (bi : BinderInfo) : M Expr := do\n  let arg \u2190 mkFreshExprMVar argExpectedType (if bi.isInstImplicit then .synthetic else .natural)\n  if bi.isInstImplicit then\n    modify fun s => { s with instMVars := s.instMVars.push arg.mvarId! }\n  return arg", "start": [839, 1], "end": [844, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabElim.main", "code": "partial def main : M Expr := do\n  let .forallE binderName binderType body binderInfo \u2190 whnfForall (\u2190 get).fType |\n    finalize\n  let addArgAndContinue (arg : Expr) : M Expr := do\n    modify fun s => { s with idx := s.idx + 1, f := mkApp s.f arg, fType := body.instantiate1 arg }\n    saveArgInfo arg binderName\n    main\n  let idx := (\u2190 get).idx\n  if (\u2190 read).elimInfo.motivePos == idx then\n    let motive \u2190 mkImplicitArg binderType binderInfo\n    setMotive motive\n    addArgAndContinue motive\n  else if (\u2190 read).elimInfo.targetsPos.contains idx then\n    match (\u2190 getNextArg? binderName binderInfo) with\n    | .some arg => let discr \u2190 elabArg arg binderType; addDiscr discr; addArgAndContinue discr\n    | .undef => finalize\n    | .none => let discr \u2190 mkImplicitArg binderType binderInfo; addDiscr discr; addArgAndContinue discr\n  else match (\u2190 getNextArg? binderName binderInfo) with\n    | .some (.stx stx) =>\n      if (\u2190 read).extraArgsPos.contains idx then\n        let arg \u2190 elabArg (.stx stx) binderType\n        addArgAndContinue arg\n      else\n        addArgAndContinue (\u2190 postponeElabTerm stx binderType)\n    | .some (.expr val) => addArgAndContinue (\u2190 ensureArgType (\u2190 get).f val binderType)\n    | .undef => finalize\n    | .none => addArgAndContinue (\u2190 mkImplicitArg binderType binderInfo)", "start": [846, 1], "end": [873, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.shouldElabAsElim", "code": "private def shouldElabAsElim (declName : Name) : CoreM Bool := do\n  if (\u2190 isRec declName) then return true\n  let env \u2190 getEnv\n  if isCasesOnRecursor env declName then return true\n  if isBRecOnRecursor env declName then return true\n  if isRecOnRecursor env declName then return true\n  return elabAsElim.hasTag env declName", "start": [877, 1], "end": [884, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.propagateExpectedTypeFor", "code": "private def propagateExpectedTypeFor (f : Expr) : TermElabM Bool :=\n  match f.getAppFn.constName? with\n  | some declName => return !hasElabWithoutExpectedType (\u2190 getEnv) declName\n  | _ => return true", "start": [886, 1], "end": [889, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabAppArgs", "code": "def elabAppArgs (f : Expr) (namedArgs : Array NamedArg) (args : Array Arg)\n    (expectedType? : Option Expr) (explicit ellipsis : Bool) (resultIsOutParamSupport := true) : TermElabM Expr := do\n  let resultIsOutParamSupport := ((\u2190 getEnv).contains ``Lean.Internal.coeM) && resultIsOutParamSupport && !explicit\n  let fType \u2190 inferType f\n  let fType \u2190 instantiateMVars fType\n  unless namedArgs.isEmpty && args.isEmpty do\n    tryPostponeIfMVar fType\n  trace[Elab.app.args] \"explicit: {explicit}, ellipsis: {ellipsis}, {f} : {fType}\"\n  trace[Elab.app.args] \"namedArgs: {namedArgs}\"\n  trace[Elab.app.args] \"args: {args}\"\n  if let some elimInfo \u2190 elabAsElim? then\n    tryPostponeIfNoneOrMVar expectedType?\n    let some expectedType := expectedType? | throwError \"failed to elaborate eliminator, expected type is not available\"\n    let expectedType \u2190 instantiateMVars expectedType\n    if expectedType.getAppFn.isMVar then throwError \"failed to elaborate eliminator, expected type is not available\"\n    let extraArgsPos \u2190 getElabAsElimExtraArgsPos elimInfo\n    ElabElim.main.run { elimInfo, expectedType, extraArgsPos } |>.run' {\n      f, fType\n      args := args.toList\n      namedArgs := namedArgs.toList\n    }\n  else\n    ElabAppArgs.main.run { explicit, ellipsis, resultIsOutParamSupport } |>.run' {\n      args := args.toList\n      expectedType?, f, fType\n      namedArgs := namedArgs.toList\n      propagateExpected := (\u2190 propagateExpectedTypeFor f)\n    }\nwhere\n  \n  elabAsElim? : TermElabM (Option ElimInfo) := do\n    if explicit || ellipsis then return none\n    let .const declName _ := f | return none\n    unless (\u2190 shouldElabAsElim declName) do return none\n    let elimInfo \u2190 getElimInfo declName\n    forallTelescopeReducing (\u2190 inferType f) fun xs _ => do\n      if h : elimInfo.motivePos < xs.size then\n        let x := xs[elimInfo.motivePos]\n        let localDecl \u2190 x.fvarId!.getDecl\n        if findBinderName? namedArgs.toList localDecl.userName matches some _ then\n          return none\n        return some elimInfo\n      else\n        return none\n\n  \n  getElabAsElimExtraArgsPos (elimInfo : ElimInfo) : MetaM (Array Nat) := do\n    let cinfo \u2190 getConstInfo elimInfo.name\n    forallTelescope cinfo.type fun xs type => do\n      let resultArgs := type.getAppArgs\n      let mut extraArgsPos := #[]\n      for i in [:xs.size] do\n        let x := xs[i]!\n        unless elimInfo.targetsPos.contains i do\n          let xType \u2190 inferType x\n          \n          if isFirstOrder xType\n             && Option.isSome (xType.find? fun e => e.isFVar && resultArgs.contains e) then\n            extraArgsPos := extraArgsPos.push i\n      return extraArgsPos\n\n  \n  isFirstOrder (e : Expr) : Bool :=\n    Option.isNone <| e.find? fun e =>\n      e.isApp && !e.getAppFn.isConst", "start": [893, 1], "end": [980, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.LValResolution", "code": "inductive LValResolution where\n  | projFn   (baseStructName : Name) (structName : Name) (fieldName : Name)\n  | projIdx  (structName : Name) (idx : Nat)\n  | const    (baseStructName : Name) (structName : Name) (constName : Name)\n  | localRec (baseName : Name) (fullName : Name) (fvar : Expr)", "start": [982, 1], "end": [987, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.throwLValError", "code": "private def throwLValError (e : Expr) (eType : Expr) (msg : MessageData) : TermElabM \u03b1 :=\n  throwError \"{msg}{indentExpr e}\\nhas type{indentExpr eType}\"", "start": [989, 1], "end": [990, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.findMethod?", "code": "private partial def findMethod? (env : Environment) (structName fieldName : Name) : Option (Name \u00d7 Name) :=\n  let fullName := structName ++ fieldName\n  match env.find? fullName with\n  | some _ => some (structName, fullName)\n  | none   =>\n    let fullNamePrv := mkPrivateName env fullName\n    match env.find? fullNamePrv with\n    | some _ => some (structName, fullNamePrv)\n    | none   =>\n      if isStructure env structName then\n        (getParentStructures env structName).findSome? fun parentStructName => findMethod? env parentStructName fieldName\n      else\n        none", "start": [992, 1], "end": [1010, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.findMethodAlias?", "code": "private def findMethodAlias? (env : Environment) (structName fieldName : Name) : Option (Name \u00d7 Name) :=\n  let fullName := structName ++ fieldName\n  let aliasesCandidates := getAliases env fullName (skipProtected := false) |>.filterMap fun alias =>\n    match alias.eraseSuffix? fieldName with\n    | none => none\n    | some structName' => some (structName', alias)\n  match aliasesCandidates with\n  | [r] => some r\n  | _   => none", "start": [1012, 1], "end": [1028, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.throwInvalidFieldNotation", "code": "private def throwInvalidFieldNotation (e eType : Expr) : TermElabM \u03b1 :=\n  throwLValError e eType \"invalid field notation, type is not of the form (C ...) where C is a constant\"", "start": [1030, 1], "end": [1031, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.resolveLValAux", "code": "private def resolveLValAux (e : Expr) (eType : Expr) (lval : LVal) : TermElabM LValResolution := do\n  if eType.isForall then\n    match lval with\n    | LVal.fieldName _ fieldName _ _ =>\n      let fullName := `Function ++ fieldName\n      if (\u2190 getEnv).contains fullName then\n        return LValResolution.const `Function `Function fullName\n    | _ => pure ()\n  match eType.getAppFn.constName?, lval with\n  | some structName, LVal.fieldIdx _ idx =>\n    if idx == 0 then\n      throwError \"invalid projection, index must be greater than 0\"\n    let env \u2190 getEnv\n    unless isStructureLike env structName do\n      throwLValError e eType \"invalid projection, structure expected\"\n    let numFields := getStructureLikeNumFields env structName\n    if idx - 1 < numFields then\n      if isStructure env structName then\n        let fieldNames := getStructureFields env structName\n        return LValResolution.projFn structName structName fieldNames[idx - 1]!\n      else\n        \n        return LValResolution.projIdx structName (idx - 1)\n    else\n      throwLValError e eType m!\"invalid projection, structure has only {numFields} field(s)\"\n  | some structName, LVal.fieldName _ fieldName _ _ =>\n    let env \u2190 getEnv\n    let searchEnv : Unit \u2192 TermElabM LValResolution := fun _ => do\n      if let some (baseStructName, fullName) := findMethod? env structName fieldName then\n        return LValResolution.const baseStructName structName fullName\n      else if let some (structName', fullName) := findMethodAlias? env structName fieldName then\n        return LValResolution.const structName' structName' fullName\n      else\n        throwLValError e eType\n          m!\"invalid field '{fieldName}', the environment does not contain '{Name.mkStr structName fieldName}'\"\n    let searchCtx : Unit \u2192 TermElabM LValResolution := fun _ => do\n      let fullName := Name.mkStr structName fieldName\n      for localDecl in (\u2190 getLCtx) do\n        if localDecl.isAuxDecl then\n          if let some localDeclFullName := (\u2190 read).auxDeclToFullName.find? localDecl.fvarId then\n            if fullName == (privateToUserName? localDeclFullName).getD localDeclFullName then\n              \n              return LValResolution.localRec structName fullName localDecl.toExpr\n      searchEnv ()\n    if isStructure env structName then\n      match findField? env structName (Name.mkSimple fieldName) with\n      | some baseStructName => return LValResolution.projFn baseStructName structName (Name.mkSimple fieldName)\n      | none                => searchCtx ()\n    else\n      searchCtx ()\n  | none, LVal.fieldName _ _ (some suffix) _ =>\n    if e.isConst then\n      throwUnknownConstant (e.constName! ++ suffix)\n    else\n      throwInvalidFieldNotation e eType\n  | _, _ => throwInvalidFieldNotation e eType", "start": [1033, 1], "end": [1090, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.consumeImplicits", "code": "private partial def consumeImplicits (stx : Syntax) (e eType : Expr) (hasArgs : Bool) : TermElabM (Expr \u00d7 Expr) := do\n  let eType \u2190 whnfCore eType\n  match eType with\n  | .forallE _ d b bi =>\n    if bi.isImplicit || (hasArgs && bi.isStrictImplicit) then\n      let mvar \u2190 mkFreshExprMVar d\n      registerMVarErrorHoleInfo mvar.mvarId! stx\n      consumeImplicits stx (mkApp e mvar) (b.instantiate1 mvar) hasArgs\n    else if bi.isInstImplicit then\n      let mvar \u2190 mkInstMVar d\n      let r := mkApp e mvar\n      registerMVarErrorImplicitArgInfo mvar.mvarId! stx r\n      consumeImplicits stx r (b.instantiate1 mvar) hasArgs\n    else match d.getOptParamDefault? with\n      | some defVal => consumeImplicits stx (mkApp e defVal) (b.instantiate1 defVal) hasArgs\n      | _ => return (e, eType)\n  | _ => return (e, eType)", "start": [1092, 1], "end": [1111, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.resolveLValLoop", "code": "private partial def resolveLValLoop (lval : LVal) (e eType : Expr) (previousExceptions : Array Exception) (hasArgs : Bool) : TermElabM (Expr \u00d7 LValResolution) := do\n  let (e, eType) \u2190 consumeImplicits lval.getRef e eType hasArgs\n  tryPostponeIfMVar eType\n  \n  if (\u2190 isMVarApp eType) then\n    synthesizeSyntheticMVarsUsingDefault\n  let eType \u2190 instantiateMVars eType\n  try\n    let lvalRes \u2190 resolveLValAux e eType lval\n    return (e, lvalRes)\n  catch\n    | ex@(Exception.error _ _) =>\n      let eType? \u2190 unfoldDefinition? eType\n      match eType? with\n      | some eType => resolveLValLoop lval e eType (previousExceptions.push ex) hasArgs\n      | none       =>\n        previousExceptions.forM fun ex => logException ex\n        throw ex\n    | ex@(Exception.internal _ _) => throw ex", "start": [1113, 1], "end": [1131, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.resolveLVal", "code": "private def resolveLVal (e : Expr) (lval : LVal) (hasArgs : Bool) : TermElabM (Expr \u00d7 LValResolution) := do\n  let eType \u2190 inferType e\n  resolveLValLoop lval e eType #[] hasArgs", "start": [1133, 1], "end": [1135, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkBaseProjections", "code": "private partial def mkBaseProjections (baseStructName : Name) (structName : Name) (e : Expr) : TermElabM Expr := do\n  let env \u2190 getEnv\n  match getPathToBaseStructure? env baseStructName structName with\n  | none => throwError \"failed to access field in parent structure\"\n  | some path =>\n    let mut e := e\n    for projFunName in path do\n      let projFn \u2190 mkConst projFunName\n      e \u2190 elabAppArgs projFn #[{ name := `self, val := Arg.expr e }] (args := #[]) (expectedType? := none) (explicit := false) (ellipsis := false)\n    return e", "start": [1137, 1], "end": [1146, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.typeMatchesBaseName", "code": "private def typeMatchesBaseName (type : Expr) (baseName : Name) : MetaM Bool := do\n  if baseName == `Function then\n    return (\u2190 whnfR type).isForall\n  else if type.consumeMData.isAppOf baseName then\n    return true\n  else\n    return (\u2190 whnfR type).isAppOf baseName", "start": [1148, 1], "end": [1154, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addLValArg", "code": "private def addLValArg (baseName : Name) (fullName : Name) (e : Expr) (args : Array Arg) (namedArgs : Array NamedArg) (fType : Expr)\n    : TermElabM (Array Arg \u00d7 Array NamedArg) :=\n  forallTelescopeReducing fType fun xs _ => do\n    let mut argIdx := 0 let mut remainingNamedArgs := namedArgs\n    for i in [:xs.size] do\n      let x := xs[i]!\n      let xDecl \u2190 x.fvarId!.getDecl\n      \n      match remainingNamedArgs.findIdx? (fun namedArg => namedArg.name == xDecl.userName) with\n      | some idx =>\n        remainingNamedArgs := remainingNamedArgs.eraseIdx idx\n      | none =>\n        let type := xDecl.type\n        if (\u2190 typeMatchesBaseName type baseName) then\n          \n          if argIdx \u2264 args.size && xDecl.binderInfo.isExplicit then\n            \n            return (args.insertAt! argIdx (Arg.expr e), namedArgs)\n          \n          for j in [:i] do\n            let prev := xs[j]!\n            let prevDecl \u2190 prev.fvarId!.getDecl\n            if prevDecl.userName == xDecl.userName then\n              throwError \"invalid field notation, function '{fullName}' has argument with the expected type{indentExpr type}\\nbut it cannot be used\"\n          return (args, namedArgs.push { name := xDecl.userName, val := Arg.expr e })\n        if xDecl.binderInfo.isExplicit then\n          argIdx := argIdx + 1\n    throwError \"invalid field notation, function '{fullName}' does not have argument with type ({baseName} ...) that can be used, it must be explicit or implicit with a unique name\"", "start": [1156, 1], "end": [1194, 182], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabAppLValsAux", "code": "private def elabAppLValsAux (namedArgs : Array NamedArg) (args : Array Arg) (expectedType? : Option Expr) (explicit ellipsis : Bool)\n    (f : Expr) (lvals : List LVal) : TermElabM Expr :=\n  let rec loop : Expr \u2192 List LVal \u2192 TermElabM Expr\n  | f, []          => elabAppArgs f namedArgs args expectedType? explicit ellipsis\n  | f, lval::lvals => do\n    if let LVal.fieldName (ref := fieldStx) (targetStx := targetStx) .. := lval then\n      addDotCompletionInfo targetStx f expectedType? fieldStx\n    let hasArgs := !namedArgs.isEmpty || !args.isEmpty\n    let (f, lvalRes) \u2190 resolveLVal f lval hasArgs\n    match lvalRes with\n    | LValResolution.projIdx structName idx =>\n      let f \u2190 mkProjAndCheck structName idx f\n      let f \u2190 addTermInfo lval.getRef f\n      loop f lvals\n    | LValResolution.projFn baseStructName structName fieldName =>\n      let f \u2190 mkBaseProjections baseStructName structName f\n      if let some info := getFieldInfo? (\u2190 getEnv) baseStructName fieldName then\n        if isPrivateNameFromImportedModule (\u2190 getEnv) info.projFn then\n          throwError \"field '{fieldName}' from structure '{structName}' is private\"\n        let projFn \u2190 mkConst info.projFn\n        let projFn \u2190 addTermInfo lval.getRef projFn\n        if lvals.isEmpty then\n          let namedArgs \u2190 addNamedArg namedArgs { name := `self, val := Arg.expr f }\n          elabAppArgs projFn namedArgs args expectedType? explicit ellipsis\n        else\n          let f \u2190 elabAppArgs projFn #[{ name := `self, val := Arg.expr f }] #[] (expectedType? := none) (explicit := false) (ellipsis := false)\n          loop f lvals\n      else\n        unreachable!\n    | LValResolution.const baseStructName structName constName =>\n      let f \u2190 if baseStructName != structName then mkBaseProjections baseStructName structName f else pure f\n      let projFn \u2190 mkConst constName\n      let projFn \u2190 addTermInfo lval.getRef projFn\n      if lvals.isEmpty then\n        let projFnType \u2190 inferType projFn\n        let (args, namedArgs) \u2190 addLValArg baseStructName constName f args namedArgs projFnType\n        elabAppArgs projFn namedArgs args expectedType? explicit ellipsis\n      else\n        let f \u2190 elabAppArgs projFn #[] #[Arg.expr f] (expectedType? := none) (explicit := false) (ellipsis := false)\n        loop f lvals\n    | LValResolution.localRec baseName fullName fvar =>\n      let fvar \u2190 addTermInfo lval.getRef fvar\n      if lvals.isEmpty then\n        let fvarType \u2190 inferType fvar\n        let (args, namedArgs) \u2190 addLValArg baseName fullName f args namedArgs fvarType\n        elabAppArgs fvar namedArgs args expectedType? explicit ellipsis\n      else\n        let f \u2190 elabAppArgs fvar #[] #[Arg.expr f] (expectedType? := none) (explicit := false) (ellipsis := false)\n        loop f lvals\n  loop f lvals", "start": [1196, 1], "end": [1245, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabAppLVals", "code": "private def elabAppLVals (f : Expr) (lvals : List LVal) (namedArgs : Array NamedArg) (args : Array Arg)\n    (expectedType? : Option Expr) (explicit ellipsis : Bool) : TermElabM Expr := do\n  if !lvals.isEmpty && explicit then\n    throwError \"invalid use of field notation with `@` modifier\"\n  elabAppLValsAux namedArgs args expectedType? explicit ellipsis f lvals", "start": [1247, 1], "end": [1251, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabExplicitUnivs", "code": "def elabExplicitUnivs (lvls : Array Syntax) : TermElabM (List Level) := do\n  lvls.foldrM (init := []) fun stx lvls => return (\u2190 elabLevel stx)::lvls", "start": [1253, 1], "end": [1254, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabAppFnId", "code": "private partial def elabAppFnId (fIdent : Syntax) (fExplicitUnivs : List Level) (lvals : List LVal)\n    (namedArgs : Array NamedArg) (args : Array Arg) (expectedType? : Option Expr) (explicit ellipsis overloaded : Bool) (acc : Array (TermElabResult Expr))\n    : TermElabM (Array (TermElabResult Expr)) := do\n  let funLVals \u2190 withRef fIdent <| resolveName' fIdent fExplicitUnivs expectedType?\n  let overloaded := overloaded || funLVals.length > 1\n  withReader (fun ctx => { ctx with errToSorry := funLVals.length == 1 && ctx.errToSorry }) do\n    funLVals.foldlM (init := acc) fun acc (f, fIdent, fields) => do\n      let lvals' := toLVals fields (first := true)\n      let s \u2190 observing do\n        let f \u2190 addTermInfo fIdent f expectedType?\n        let e \u2190 elabAppLVals f (lvals' ++ lvals) namedArgs args expectedType? explicit ellipsis\n        if overloaded then ensureHasType expectedType? e else return e\n      return acc.push s\nwhere\n  toName (fields : List Syntax) : Name :=\n    let rec go\n      | []              => .anonymous\n      | field :: fields => .mkStr (go fields) field.getId.toString\n    go fields.reverse\n\n  toLVals : List Syntax \u2192 (first : Bool) \u2192 List LVal\n    | [],            _     => []\n    | field::fields, true  => .fieldName field field.getId.getString! (toName (field::fields)) fIdent :: toLVals fields false\n    | field::fields, false => .fieldName field field.getId.getString! none fIdent :: toLVals fields false", "start": [1277, 1], "end": [1301, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.resolveDotName", "code": "private partial def resolveDotName (id : Syntax) (expectedType? : Option Expr) : TermElabM Name := do\n  tryPostponeIfNoneOrMVar expectedType?\n  let some expectedType := expectedType?\n    | throwError \"invalid dotted identifier notation, expected type must be known\"\n  forallTelescopeReducing expectedType fun _ resultType => do\n    go resultType expectedType #[]\nwhere\n  go (resultType : Expr) (expectedType : Expr) (previousExceptions : Array Exception) : TermElabM Name := do\n    let resultType \u2190 instantiateMVars resultType\n    let resultTypeFn := resultType.cleanupAnnotations.getAppFn\n    try\n      tryPostponeIfMVar resultTypeFn\n      let .const declName .. := resultTypeFn.cleanupAnnotations\n        | throwError \"invalid dotted identifier notation, expected type is not of the form (... \u2192 C ...) where C is a constant{indentExpr expectedType}\"\n      let idNew := declName ++ id.getId.eraseMacroScopes\n      unless (\u2190 getEnv).contains idNew do\n        throwError \"invalid dotted identifier notation, unknown identifier `{idNew}` from expected type{indentExpr expectedType}\"\n      return idNew\n    catch\n      | ex@(.error ..) =>\n        match (\u2190 unfoldDefinition? resultType) with\n        | some resultType =>\n          go (\u2190 whnfCore resultType) expectedType (previousExceptions.push ex)\n        | none =>\n          previousExceptions.forM fun ex => logException ex\n          throw ex\n      | ex@(.internal _ _) => throw ex", "start": [1303, 1], "end": [1330, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabAppFn", "code": "private partial def elabAppFn (f : Syntax) (lvals : List LVal) (namedArgs : Array NamedArg) (args : Array Arg)\n    (expectedType? : Option Expr) (explicit ellipsis overloaded : Bool) (acc : Array (TermElabResult Expr)) : TermElabM (Array (TermElabResult Expr)) := do\n  if f.getKind == choiceKind then\n    withReader (fun ctx => { ctx with errToSorry := false }) do\n      f.getArgs.foldlM (init := acc) fun acc f => elabAppFn f lvals namedArgs args expectedType? explicit ellipsis true acc\n  else\n    let elabFieldName (e field : Syntax) := do\n      let newLVals := field.identComponents.map fun comp =>\n        LVal.fieldName comp comp.getId.getString! none e\n      elabAppFn e (newLVals ++ lvals) namedArgs args expectedType? explicit ellipsis overloaded acc\n    let elabFieldIdx (e idxStx : Syntax) := do\n      let some idx := idxStx.isFieldIdx? | throwError \"invalid field index\"\n      elabAppFn e (LVal.fieldIdx idxStx idx :: lvals) namedArgs args expectedType? explicit ellipsis overloaded acc\n    match f with\n    | `($(e).$idx:fieldIdx) => elabFieldIdx e idx\n    | `($e |>.$idx:fieldIdx) => elabFieldIdx e idx\n    | `($(e).$field:ident) => elabFieldName e field\n    | `($e |>.$field:ident) => elabFieldName e field\n    | `($_:ident@$_:term) =>\n      throwError \"unexpected occurrence of named pattern\"\n    | `($id:ident) => do\n      elabAppFnId id [] lvals namedArgs args expectedType? explicit ellipsis overloaded acc\n    | `($id:ident.{$us,*}) => do\n      let us \u2190 elabExplicitUnivs us\n      elabAppFnId id us lvals namedArgs args expectedType? explicit ellipsis overloaded acc\n    | `(@$id:ident) =>\n      elabAppFn id lvals namedArgs args expectedType? (explicit := true) ellipsis overloaded acc\n    | `(@$_:ident.{$_us,*}) =>\n      elabAppFn (f.getArg 1) lvals namedArgs args expectedType? (explicit := true) ellipsis overloaded acc\n    | `(@$_)     => throwUnsupportedSyntax | `(_)       => throwError \"placeholders '_' cannot be used where a function is expected\"\n    | `(.$id:ident) =>\n        addCompletionInfo <| CompletionInfo.dotId f id.getId (\u2190 getLCtx) expectedType?\n        let fConst \u2190 mkConst (\u2190 resolveDotName id expectedType?)\n        let s \u2190 observing do\n          let fConst \u2190 addTermInfo f fConst expectedType? (force := true)\n          let e \u2190 elabAppLVals fConst lvals namedArgs args expectedType? explicit ellipsis\n          if overloaded then ensureHasType expectedType? e else return e\n        return acc.push s\n    | _ => do\n      let catchPostpone := !overloaded\n      \n      if lvals.isEmpty && namedArgs.isEmpty && args.isEmpty then\n        \n        let s \u2190 observing do\n          if overloaded then\n            elabTermEnsuringType f expectedType? catchPostpone\n          else\n            elabTerm f expectedType?\n        return acc.push s\n      else\n        let s \u2190 observing do\n          let f \u2190 elabTerm f none catchPostpone\n          let e \u2190 elabAppLVals f lvals namedArgs args expectedType? explicit ellipsis\n          if overloaded then ensureHasType expectedType? e else return e\n        return acc.push s", "start": [1332, 1], "end": [1392, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getSuccesses", "code": "private def getSuccesses (candidates : Array (TermElabResult Expr)) : TermElabM (Array (TermElabResult Expr)) := do\n  let r\u2081 := candidates.filter fun | EStateM.Result.ok .. => true | _ => false\n  if r\u2081.size \u2264 1 then return r\u2081\n  let r\u2082 \u2190 candidates.filterM fun\n    | .ok e s => do\n      if e.isMVar then\n        \n        try\n          s.restore\n          synthesizeSyntheticMVars let e \u2190 instantiateMVars e\n          if e.isMVar then\n          \n            if let some synDecl \u2190 getSyntheticMVarDecl? e.mvarId! then\n              if synDecl.kind matches SyntheticMVarKind.coe .. then\n                return false\n        catch _ =>\n          return false\n      return true\n    | _ => return false\n  if r\u2082.size == 0 then return r\u2081 else return r\u2082", "start": [1394, 1], "end": [1419, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mergeFailures", "code": "private def mergeFailures (failures : Array (TermElabResult Expr)) : TermElabM \u03b1 := do\n  let exs := failures.map fun | .error ex _ => ex | _ => unreachable!\n  throwErrorWithNestedErrors \"overloaded\" exs", "start": [1421, 1], "end": [1427, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabAppAux", "code": "private def elabAppAux (f : Syntax) (namedArgs : Array NamedArg) (args : Array Arg) (ellipsis : Bool) (expectedType? : Option Expr) : TermElabM Expr := do\n  let candidates \u2190 elabAppFn f [] namedArgs args expectedType? (explicit := false) (ellipsis := ellipsis) (overloaded := false) #[]\n  if h : candidates.size = 1 then\n    have : 0 < candidates.size := by rw [h]; decide\n    applyResult candidates[0]\n  else\n    let successes \u2190 getSuccesses candidates\n    if h : successes.size = 1 then\n      have : 0 < successes.size := by rw [h]; decide\n      applyResult successes[0]\n    else if successes.size > 1 then\n      let msgs : Array MessageData \u2190 successes.mapM fun success => do\n        match success with\n        | .ok e s => withMCtx s.meta.meta.mctx <| withEnv s.meta.core.env do addMessageContext m!\"{e} : {\u2190 inferType e}\"\n        | _       => unreachable!\n      throwErrorAt f \"ambiguous, possible interpretations {toMessageList msgs}\"\n    else\n      withRef f <| mergeFailures candidates", "start": [1429, 1], "end": [1446, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.annotateIfRec", "code": "private def annotateIfRec (stx : Syntax) (e : Expr) : TermElabM Expr := do\n  if (\u2190 read).saveRecAppSyntax then\n    let resultFn := e.getAppFn\n    if resultFn.isFVar then\n      let localDecl \u2190 resultFn.fvarId!.getDecl\n      if localDecl.isAuxDecl then\n        return mkRecAppWithSyntax e stx\n  return e", "start": [1448, 1], "end": [1463, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabApp", "code": "@[builtin_term_elab app] def elabApp : TermElab := fun stx expectedType? =>\n  universeConstraintsCheckpoint do\n    let (f, namedArgs, args, ellipsis) \u2190 expandApp stx\n    annotateIfRec stx (\u2190 elabAppAux f namedArgs args (ellipsis := ellipsis) expectedType?)", "start": [1465, 1], "end": [1468, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabAtom", "code": "private def elabAtom : TermElab := fun stx expectedType? => do\n  annotateIfRec stx (\u2190 elabAppAux stx #[] #[] (ellipsis := false) expectedType?)", "start": [1470, 1], "end": [1471, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabIdent", "code": "@[builtin_term_elab ident] def elabIdent : TermElab := elabAtom", "start": [1473, 1], "end": [1473, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabNamedPattern", "code": "@[builtin_term_elab namedPattern] def elabNamedPattern : TermElab := elabAtom", "start": [1474, 1], "end": [1474, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabDotIdent", "code": "@[builtin_term_elab dotIdent] def elabDotIdent : TermElab := elabAtom", "start": [1475, 1], "end": [1475, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabExplicitUniv", "code": "@[builtin_term_elab explicitUniv] def elabExplicitUniv : TermElab := elabAtom", "start": [1476, 1], "end": [1476, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabPipeProj", "code": "@[builtin_term_elab pipeProj] def elabPipeProj : TermElab\n  | `($e |>.$f $args*), expectedType? =>\n    universeConstraintsCheckpoint do\n      let (namedArgs, args, ellipsis) \u2190 expandArgs args\n      elabAppAux (\u2190 `($e |>.$f)) namedArgs args (ellipsis := ellipsis) expectedType?\n  | _, _ => throwUnsupportedSyntax", "start": [1477, 1], "end": [1482, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabExplicit", "code": "@[builtin_term_elab explicit] def elabExplicit : TermElab := fun stx expectedType? =>\n  match stx with\n  | `(@$_:ident)         => elabAtom stx expectedType?  | `(@$_:ident.{$_us,*}) => elabAtom stx expectedType?\n  | `(@($t))             => elabTerm t expectedType? (implicitLambda := false)    | `(@$t)               => elabTerm t expectedType? (implicitLambda := false)   | _                    => throwUnsupportedSyntax", "start": [1484, 1], "end": [1490, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabChoice", "code": "@[builtin_term_elab choice] def elabChoice : TermElab := elabAtom", "start": [1492, 1], "end": [1492, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabProj", "code": "@[builtin_term_elab proj] def elabProj : TermElab := elabAtom", "start": [1493, 1], "end": [1493, 62], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Internalize.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Bind.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.refreshBinderName", "code": "private def refreshBinderName (binderName : Name) : CompilerM Name := do\n  match binderName with\n  | .num p _ =>\n    let r := .num p (\u2190 get).nextIdx\n    modify fun s => { s with nextIdx := s.nextIdx + 1 }\n    return r\n  | _ => return binderName", "start": [12, 1], "end": [18, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Internalize.InternalizeM", "code": "abbrev InternalizeM := StateRefT FVarSubst CompilerM", "start": [22, 1], "end": [22, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Internalize.mkNewFVarId", "code": "private def mkNewFVarId (fvarId : FVarId) : InternalizeM FVarId := do\n  let fvarId' \u2190 Lean.mkFreshFVarId\n  addFVarSubst fvarId fvarId'\n  return fvarId'", "start": [35, 1], "end": [38, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Internalize.internalizeParam", "code": "def internalizeParam (p : Param) : InternalizeM Param := do\n  let binderName \u2190 refreshBinderName p.binderName\n  let type \u2190 normExpr p.type\n  let fvarId \u2190 mkNewFVarId p.fvarId\n  let p := { p with binderName, fvarId, type }\n  modifyLCtx fun lctx => lctx.addParam p\n  return p", "start": [40, 1], "end": [46, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Internalize.internalizeLetDecl", "code": "def internalizeLetDecl (decl : LetDecl) : InternalizeM LetDecl := do\n  let binderName \u2190 refreshBinderName decl.binderName\n  let type \u2190 normExpr decl.type\n  let value \u2190 normLetValue decl.value\n  let fvarId \u2190 mkNewFVarId decl.fvarId\n  let decl := { decl with binderName, fvarId, type, value }\n  modifyLCtx fun lctx => lctx.addLetDecl decl\n  return decl", "start": [48, 1], "end": [55, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Internalize.internalizeFunDecl", "code": "partial def internalizeFunDecl (decl : FunDecl) : InternalizeM FunDecl := do\n  let type \u2190 normExpr decl.type\n  let binderName \u2190 refreshBinderName decl.binderName\n  let params \u2190 decl.params.mapM internalizeParam\n  let value \u2190 internalizeCode decl.value\n  let fvarId \u2190 mkNewFVarId decl.fvarId\n  let decl := { decl with binderName, fvarId, params, type, value }\n  modifyLCtx fun lctx => lctx.addFunDecl decl\n  return decl", "start": [59, 1], "end": [67, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Internalize.internalizeCode", "code": "partial def internalizeCode (code : Code) : InternalizeM Code := do\n  match code with\n  | .let decl k => return .let (\u2190 internalizeLetDecl decl) (\u2190 internalizeCode k)\n  | .fun decl k => return .fun (\u2190 internalizeFunDecl decl) (\u2190 internalizeCode k)\n  | .jp decl k => return .jp (\u2190 internalizeFunDecl decl) (\u2190 internalizeCode k)\n  | .return fvarId => withNormFVarResult (\u2190 normFVar fvarId) fun fvarId => return .return fvarId\n  | .jmp fvarId args => withNormFVarResult (\u2190 normFVar fvarId) fun fvarId => return .jmp fvarId (\u2190 args.mapM normArg)\n  | .unreach type => return .unreach (\u2190 normExpr type)\n  | .cases c =>\n    withNormFVarResult (\u2190 normFVar c.discr) fun discr => do\n      let resultType \u2190 normExpr c.resultType\n      let internalizeAltCode (k : Code) : InternalizeM Code :=\n        internalizeCode k\n      let alts \u2190 c.alts.mapM fun\n        | .alt ctorName params k => return .alt ctorName (\u2190 params.mapM internalizeParam) (\u2190 internalizeAltCode k)\n        | .default k => return .default (\u2190 internalizeAltCode k)\n      return .cases { c with discr, alts, resultType }", "start": [69, 1], "end": [85, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Internalize.internalizeCodeDecl", "code": "partial def internalizeCodeDecl (decl : CodeDecl) : InternalizeM CodeDecl := do\n  match decl with\n  | .let decl => return .let (\u2190 internalizeLetDecl decl)\n  | .fun decl => return .fun (\u2190 internalizeFunDecl decl)\n  | .jp decl => return .jp (\u2190 internalizeFunDecl decl)", "start": [89, 1], "end": [93, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.internalize", "code": "partial def Code.internalize (code : Code) (s : FVarSubst := {}) : CompilerM Code :=\n  Internalize.internalizeCode code |>.run' s", "start": [97, 1], "end": [101, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.internalize", "code": "def Decl.internalize (decl : Decl) (s : FVarSubst := {}): CompilerM Decl :=\n  go decl |>.run' s\nwhere\n  go (decl : Decl) : InternalizeM Decl := do\n    let type \u2190 normExpr decl.type\n    let params \u2190 decl.params.mapM internalizeParam\n    let value \u2190 internalizeCode decl.value\n    return { decl with type, params, value }", "start": [104, 1], "end": [111, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.cleanup", "code": "def cleanup (decl : Array Decl) : CompilerM (Array Decl) := do\n  modify fun _ => {}\n  decl.mapM fun decl => do\n    modify fun s => { s with nextIdx := 1 }\n    decl.internalize", "start": [113, 1], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normalizeFVarIds", "code": "def normalizeFVarIds (decl : Decl) : CoreM Decl := do\n  let ngenSaved \u2190 getNGen\n  setNGen {}\n  try\n    CompilerM.run <| decl.internalize\n  finally\n    setNGen ngenSaved", "start": [122, 1], "end": [128, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/DependsOn.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.M", "code": "private abbrev M := ReaderT FVarIdSet Id", "start": [10, 1], "end": [10, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.fvarDepOn", "code": "private def fvarDepOn (fvarId : FVarId) : M Bool :=\n  return (\u2190 read).contains fvarId", "start": [12, 1], "end": [13, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.typeDepOn", "code": "private def typeDepOn (e : Expr) : M Bool := do\n  let s \u2190 read\n  return e.hasAnyFVar fun fvarId => s.contains fvarId", "start": [15, 1], "end": [17, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.argDepOn", "code": "private def argDepOn (a : Arg) : M Bool := do\n  match a with\n  | .erased => return false\n  | .fvar fvarId => fvarDepOn fvarId\n  | .type e => typeDepOn e", "start": [19, 1], "end": [23, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.letValueDepOn", "code": "private def letValueDepOn (e : LetValue) : M Bool :=\n  match e with\n  | .erased | .value .. => return false\n  | .proj _ _ fvarId => fvarDepOn fvarId\n  | .fvar fvarId args => fvarDepOn fvarId <||> args.anyM argDepOn\n  | .const _ _ args => args.anyM argDepOn", "start": [25, 1], "end": [30, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl.depOn", "code": "private def LetDecl.depOn (decl : LetDecl) : M Bool :=\n  typeDepOn decl.type <||> letValueDepOn decl.value", "start": [32, 1], "end": [33, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.depOn", "code": "private partial def depOn (c : Code) : M Bool :=\n  match c with\n  | .let decl k => decl.depOn <||> depOn k\n  | .jp decl k | .fun decl k => typeDepOn decl.type <||> depOn decl.value <||> depOn k\n  | .cases c => typeDepOn c.resultType <||> fvarDepOn c.discr <||> c.alts.anyM fun alt => depOn alt.getCode\n  | .jmp fvarId args => fvarDepOn fvarId <||> args.anyM argDepOn\n  | .return fvarId => fvarDepOn fvarId\n  | .unreach _ => return false", "start": [35, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl.dependsOn", "code": "abbrev LetDecl.dependsOn (decl : LetDecl) (s : FVarIdSet) :  Bool :=\n  decl.depOn s", "start": [44, 1], "end": [45, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDecl.dependsOn", "code": "abbrev FunDecl.dependsOn (decl : FunDecl) (s : FVarIdSet) :  Bool :=\n  typeDepOn decl.type s || depOn decl.value s", "start": [47, 1], "end": [48, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CodeDecl.dependsOn", "code": "def CodeDecl.dependsOn (decl : CodeDecl) (s : FVarIdSet) : Bool :=\n  match decl with\n  | .let decl => decl.dependsOn s\n  | .jp decl | .fun decl => decl.dependsOn s", "start": [50, 1], "end": [53, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.dependsOn", "code": "def Code.dependsOn (c : Code) (s : FVarIdSet) : Bool :=\n  depOn c s", "start": [55, 1], "end": [59, 12], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/DiscrM.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.CtorInfo", "code": "inductive CtorInfo where\n  | ctor (val : ConstructorVal) (args : Array Arg)\n  | \n    natVal (n : Nat)", "start": [14, 1], "end": [17, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.CtorInfo.getName", "code": "def CtorInfo.getName : CtorInfo \u2192 Name\n  | .ctor val _ => val.name\n  | .natVal 0   => ``Nat.zero\n  | .natVal _   => ``Nat.succ", "start": [19, 1], "end": [22, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.CtorInfo.getNumParams", "code": "def CtorInfo.getNumParams : CtorInfo \u2192 Nat\n  | .ctor val _ => val.numParams\n  | .natVal _ => 0", "start": [24, 1], "end": [26, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.CtorInfo.getNumFields", "code": "def CtorInfo.getNumFields : CtorInfo \u2192 Nat\n  | .ctor val _ => val.numFields\n  | .natVal 0   => 0\n  | .natVal _   => 1", "start": [28, 1], "end": [31, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.DiscrM.Context", "code": "structure DiscrM.Context where\n  \n  discrCtorMap : FVarIdMap CtorInfo := {}\n  \n  ctorDiscrMap : PersistentExprMap FVarId := {}", "start": [33, 1], "end": [41, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.DiscrM", "code": "abbrev DiscrM := ReaderT DiscrM.Context CompilerM", "start": [43, 1], "end": [47, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.findCtor?", "code": "def findCtor? (fvarId : FVarId) : DiscrM (Option CtorInfo) := do\n  match (\u2190 findLetDecl? fvarId) with\n  | some { value := .value (.natVal n), .. } =>\n    return some <| .natVal n\n  | some { value := .const declName _ args, .. } =>\n    let some (.ctorInfo val) := (\u2190 getEnv).find? declName | return none\n    return some <| .ctor val args\n  | some _ => return none\n  | none => return (\u2190 read).discrCtorMap.find? fvarId", "start": [49, 1], "end": [62, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.findCtorName?", "code": "def findCtorName? (fvarId : FVarId) : DiscrM (Option Name) := do\n  let some ctorInfo \u2190 findCtor? fvarId | return none\n  return ctorInfo.getName", "start": [64, 1], "end": [66, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.getIndInfo?", "code": "def getIndInfo? (type : Expr) : CoreM (Option (List Level \u00d7 Array Arg)) := do\n  let type := type.headBeta\n  let .const declName us := type.getAppFn | return none\n  let .inductInfo info \u2190 getConstInfo declName | return none\n  unless type.getAppNumArgs >= info.numParams do return none\n  let args := type.getAppArgs[:info.numParams].toArray.map fun\n    | .fvar fvarId => .fvar fvarId\n    | e => if e.isErased then .erased else .type e\n  return some (us, args)", "start": [68, 1], "end": [79, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.withDiscrCtorImp", "code": "@[inline] def withDiscrCtorImp (discr : FVarId) (ctorName : Name) (ctorFields : Array Param) (x : DiscrM \u03b1) : DiscrM \u03b1 := do\n  let ctx \u2190 updateCtx\n  withReader (fun _ => ctx) x\nwhere\n  updateCtx : DiscrM DiscrM.Context := do\n    let ctorVal \u2190 getConstInfoCtor ctorName\n    let fieldArgs := ctorFields.map (Arg.fvar \u00b7.fvarId)\n    let ctx \u2190 read\n    if let some (us, params) \u2190 getIndInfo? (\u2190 getType discr) then\n      let ctorArgs := params ++ fieldArgs\n      let ctorInfo := .ctor ctorVal ctorArgs\n      let ctor := LetValue.const ctorVal.name us ctorArgs\n      return { ctx with discrCtorMap := ctx.discrCtorMap.insert discr ctorInfo, ctorDiscrMap := ctx.ctorDiscrMap.insert ctor.toExpr discr }\n    else\n      let ctorInfo := .ctor ctorVal (mkArray ctorVal.numParams Arg.erased ++ fieldArgs)\n      return { ctx with discrCtorMap := ctx.discrCtorMap.insert discr ctorInfo }", "start": [81, 1], "end": [101, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.withDiscrCtor", "code": "@[inline, inherit_doc withDiscrCtorImp] def withDiscrCtor [MonadFunctorT DiscrM m] (discr : FVarId) (ctorName : Name) (ctorFields : Array Param) : m \u03b1 \u2192 m \u03b1 :=\n  monadMap (m := DiscrM) <| withDiscrCtorImp discr ctorName ctorFields", "start": [103, 1], "end": [104, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.simpCtorDiscrCore?", "code": "def simpCtorDiscrCore? (e : Expr) : DiscrM (Option FVarId) := do\n  let some discr := (\u2190 read).ctorDiscrMap.find? e | return none\n  unless eqvTypes (\u2190 getType discr) (\u2190 inferType e) do return none\n  return some <| discr", "start": [106, 1], "end": [109, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Meta/Expr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Data/Array/Merge.lean", "imports": ["lake-packages/std/Std/Data/Ord.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Array.mergeSortedPreservingDuplicates", "code": "def mergeSortedPreservingDuplicates [ord : Ord \u03b1] (xs ys : Array \u03b1) :\n    Array \u03b1 :=\n  let acc := Array.mkEmpty (xs.size + ys.size)\n  go acc 0 0\nwhere\n  \n  go (acc : Array \u03b1) (i j : Nat) : Array \u03b1 :=\n    if hi : i \u2265 xs.size then\n      acc ++ ys[j:]\n    else if hj : j \u2265 ys.size then\n      acc ++ xs[i:]\n    else\n      have hi : i < xs.size := Nat.lt_of_not_le hi\n      have hj : j < ys.size := Nat.lt_of_not_le hj\n      have hij : i + j < xs.size + ys.size := Nat.add_lt_add hi hj\n      let x := xs[i]\n      let y := ys[j]\n      if compare x y |>.isLE then\n        have : xs.size + ys.size - (i + 1 + j) < xs.size + ys.size - (i + j) := by\n          rw [show i + 1 + j = i + j + 1 by simp_arith]\n          exact Nat.sub_succ_lt_self _ _ hij\n        go (acc.push x) (i + 1) j\n      else\n        have : xs.size + ys.size - (i + j + 1) < xs.size + ys.size - (i + j) :=\n          Nat.sub_succ_lt_self _ _ hij\n        go (acc.push y) i (j + 1)\ntermination_by go => xs.size + ys.size - (i + j)", "start": [12, 1], "end": [43, 49], "kind": "commanddeclaration"}, {"full_name": "Array.mergeSortedMergingDuplicates", "code": "def mergeSortedMergingDuplicates [ord : Ord \u03b1] (xs ys : Array \u03b1)\n    (merge : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Array \u03b1 :=\n  let acc := Array.mkEmpty (xs.size + ys.size)\n  go acc 0 0\nwhere\n  \n  go (acc : Array \u03b1) (i j : Nat) : Array \u03b1 :=\n    if hi : i \u2265 xs.size then\n      acc ++ ys[j:]\n    else if hj : j \u2265 ys.size then\n      acc ++ xs[i:]\n    else\n      have hi : i < xs.size := Nat.lt_of_not_le hi\n      have hj : j < ys.size := Nat.lt_of_not_le hj\n      have hij : i + j < xs.size + ys.size := Nat.add_lt_add hi hj\n      let x := xs[i]\n      let y := ys[j]\n      match compare x y with\n      | Ordering.lt =>\n        have : xs.size + ys.size - (i + 1 + j) < xs.size + ys.size - (i + j) := by\n          rw [show i + 1 + j = i + j + 1 by simp_arith]\n          exact Nat.sub_succ_lt_self _ _ hij\n        go (acc.push x) (i + 1) j\n      | Ordering.gt =>\n        have : xs.size + ys.size - (i + j + 1) < xs.size + ys.size - (i + j) :=\n          Nat.sub_succ_lt_self _ _ hij\n        go (acc.push y) i (j + 1)\n      | Ordering.eq =>\n        have : xs.size + ys.size - (i + 1 + (j + 1)) < xs.size + ys.size - (i + j) := by\n          rw [show i + 1 + (j + 1) = i + j + 2 by simp_arith]\n          apply Nat.sub_add_lt_sub _ (by decide)\n          rw [show i + j + 2 = (i + 1) + (j + 1) by simp_arith]\n          exact Nat.add_le_add hi hj\n        go (acc.push (merge x y)) (i + 1) (j + 1)\ntermination_by go => xs.size + ys.size - (i + j)", "start": [45, 1], "end": [86, 49], "kind": "commanddeclaration"}, {"full_name": "Array.mergeSortedDeduplicating", "code": "@[inline]\ndef mergeSortedDeduplicating [ord : Ord \u03b1] (xs ys : Array \u03b1) : Array \u03b1 :=\n  mergeSortedMergingDuplicates (ord := ord) xs ys fun x _ => x", "start": [88, 1], "end": [95, 63], "kind": "commanddeclaration"}, {"full_name": "Array.mergeUnsortedDeduplicating", "code": "def mergeUnsortedDeduplicating [eq : BEq \u03b1] (xs ys : Array \u03b1) : Array \u03b1 :=\n  if xs.size < ys.size then go ys xs else go xs ys\nwhere\n  \n  @[inline]\n  go (xs ys : Array \u03b1) :=\n    let xsSize := xs.size\n    ys.foldl (init := xs) fun xs y =>\n      if xs[:xsSize].contains y then xs else xs.push y", "start": [98, 1], "end": [113, 55], "kind": "commanddeclaration"}, {"full_name": "Array.mergeAdjacentDuplicates", "code": "def mergeAdjacentDuplicates [eq : BEq \u03b1] (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (xs : Array \u03b1) :\n    Array \u03b1 :=\n  if h : 0 < xs.size then go #[] 1 (xs.get \u27e80, h\u27e9) else xs\nwhere\n  \n  go (acc : Array \u03b1) (i : Nat) (hd : \u03b1) :=\n    if h : i < xs.size then\n      let x := xs[i]\n      if x == hd then\n        go acc (i + 1) (f hd x)\n      else\n        go (acc.push hd) (i + 1) x\n    else\n      acc.push hd\ntermination_by _ i _ => xs.size - i", "start": [115, 1], "end": [133, 36], "kind": "commanddeclaration"}, {"full_name": "Array.deduplicateSorted", "code": "def deduplicateSorted [eq : BEq \u03b1] (xs : Array \u03b1) : Array \u03b1 :=\n  xs.mergeAdjacentDuplicates (eq := eq) fun x _ => x", "start": [135, 1], "end": [140, 53], "kind": "commanddeclaration"}, {"full_name": "Array.sortAndDeduplicate", "code": "def sortAndDeduplicate [ord : Ord \u03b1] (xs : Array \u03b1) : Array \u03b1 :=\n  have := ord.toBEq\n  deduplicateSorted <| xs.qsort (compare \u00b7 \u00b7 |>.isLT)", "start": [142, 1], "end": [147, 54], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/PersistentHashMap.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/PersistentHashMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PersistentHashMap.insert'", "code": "def insert' (m : PersistentHashMap \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) : PersistentHashMap \u03b1 \u03b2 \u00d7 Bool :=\n  let oldSize := m.size\n  let m := m.insert a b\n  (m, m.size == oldSize)", "start": [13, 1], "end": [20, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.toArray", "code": "def toArray (m : PersistentHashMap \u03b1 \u03b2) : Array (\u03b1 \u00d7 \u03b2) :=\n  m.foldl (init := Array.mkEmpty m.size) fun xs k v => xs.push (k, v)", "start": [22, 1], "end": [26, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.ofList", "code": "def ofList (xs : List (\u03b1 \u00d7 \u03b2)) : PersistentHashMap \u03b1 \u03b2 :=\n  xs.foldl (init := {}) fun m (k, v) => m.insert k v", "start": [28, 1], "end": [33, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.ofListWith", "code": "def ofListWith (xs : List (\u03b1 \u00d7 \u03b2)) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2) :\n    PersistentHashMap \u03b1 \u03b2 :=\n  xs.foldl (init := {}) fun m (k, v) =>\n    match m.find? k with\n    | none    => m.insert k v\n    | some v' => m.insert k <| f k v v'", "start": [35, 1], "end": [44, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.ofArray", "code": "def ofArray (xs : Array (\u03b1 \u00d7 \u03b2)) : PersistentHashMap \u03b1 \u03b2 :=\n  xs.foldl (init := {}) fun m (k, v) => m.insert k v", "start": [46, 1], "end": [51, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.ofArrayWith", "code": "def ofArrayWith (xs : Array (\u03b1 \u00d7 \u03b2)) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2) :\n    PersistentHashMap \u03b1 \u03b2 :=\n  xs.foldl (init := {}) fun m (k, v) =>\n    match m.find? k with\n    | none    => m.insert k v\n    | some v' => m.insert k <| f k v v'", "start": [53, 1], "end": [62, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.mergeWithM", "code": "@[specialize]\ndef mergeWithM [Monad m] (self other : PersistentHashMap \u03b1 \u03b2)\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 m \u03b2) : m (PersistentHashMap \u03b1 \u03b2) :=\n  other.foldlM (init := self) fun map k v\u2082 =>\n    match map.find? k with\n    | none => return map.insert k v\u2082\n    | some v\u2081 => return map.insert k (\u2190 f k v\u2081 v\u2082)", "start": [64, 1], "end": [74, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.mergeWith", "code": "@[inline]\ndef mergeWith (self other : PersistentHashMap \u03b1 \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2) :\n    PersistentHashMap \u03b1 \u03b2 :=\n  other.foldl (init := self) fun map k v\u2082 =>\n    match map.find? k with\n    | none => map.insert k v\u2082\n    | some v\u2081 => map.insert k <| f k v\u2081 v\u2082", "start": [76, 1], "end": [88, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Induction.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/GeneralizeVars.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Induction.lean", "lake-packages/lean4/src/lean/Lean/Meta/CollectMVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/ElimInfo.lean", "lake-packages/lean4/src/lean/Lean/Elab/App.lean", "lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Generalize.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/RecursorInfo.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectFVars.lean", "lake-packages/lean4/src/lean/Lean/AuxRecursor.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.getFirstAltLhs", "code": "private def getFirstAltLhs (alt : Syntax) : Syntax :=\n  alt[0][0]", "start": [29, 1], "end": [30, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getAltName", "code": "private def getAltName (alt : Syntax) : Name :=\n  let lhs := getFirstAltLhs alt\n  if !lhs[1].isOfKind ``Parser.Term.hole then lhs[1][1].getId.eraseMacroScopes else `_", "start": [31, 1], "end": [34, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getAltNameStx", "code": "private def getAltNameStx (alt : Syntax) : Syntax :=\n  let lhs := getFirstAltLhs alt\n  if lhs[1].isOfKind ``Parser.Term.hole then lhs[1] else lhs[1][1]", "start": [35, 1], "end": [38, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.altHasExplicitModifier", "code": "private def altHasExplicitModifier (alt : Syntax) : Bool :=\n  let lhs := getFirstAltLhs alt\n  !lhs[1].isOfKind ``Parser.Term.hole && !lhs[1][0].isNone", "start": [39, 1], "end": [42, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getAltVars", "code": "private def getAltVars (alt : Syntax) : Array Syntax :=\n  let lhs := getFirstAltLhs alt\n  lhs[2].getArgs", "start": [43, 1], "end": [46, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getAltRHS", "code": "private def getAltRHS (alt : Syntax) : Syntax :=\n  alt[2]", "start": [47, 1], "end": [48, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getAltDArrow", "code": "private def getAltDArrow (alt : Syntax) : Syntax :=\n  alt[1]", "start": [49, 1], "end": [50, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.isHoleRHS", "code": "def isHoleRHS (rhs : Syntax) : Bool :=\n  rhs.isOfKind ``Parser.Term.syntheticHole || rhs.isOfKind ``Parser.Term.hole", "start": [53, 1], "end": [54, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalAlt", "code": "def evalAlt (mvarId : MVarId) (alt : Syntax) (addInfo : TermElabM Unit) (remainingGoals : Array MVarId) : TacticM (Array MVarId) :=\n  let rhs := getAltRHS alt\n  withCaseRef (getAltDArrow alt) rhs do\n    if isHoleRHS rhs then\n      addInfo\n      let gs' \u2190 mvarId.withContext <| withRef rhs do\n        let mvarDecl \u2190 mvarId.getDecl\n        let val \u2190 elabTermEnsuringType rhs mvarDecl.type\n        mvarId.assign val\n        let gs' \u2190 getMVarsNoDelayed val\n        tagUntaggedGoals mvarDecl.userName `induction gs'.toList\n        pure gs'\n      return remainingGoals ++ gs'\n    else\n      setGoals [mvarId]\n      closeUsingOrAdmit (withTacticInfoContext alt (addInfo *> evalTactic rhs))\n      return remainingGoals", "start": [56, 1], "end": [72, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.Alt", "code": "structure Alt where\n  \n  name      : Name\n  \n  declName? : Option Name\n  \n  mvarId    : MVarId\n  deriving Inhabited", "start": [79, 1], "end": [89, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.Context", "code": "structure Context where\n  elimInfo : ElimInfo\n  targets  : Array Expr", "start": [91, 1], "end": [93, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.State", "code": "structure State where\n  argPos    : Nat := 0 targetPos : Nat := 0 f         : Expr\n  fType     : Expr\n  alts      : Array Alt := #[]\n  insts     : Array MVarId := #[]", "start": [95, 1], "end": [101, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.M", "code": "abbrev M := ReaderT Context $ StateRefT State TermElabM", "start": [103, 1], "end": [103, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.addNewArg", "code": "private def addNewArg (arg : Expr) : M Unit :=\n  modify fun s => { s with argPos := s.argPos+1, f := mkApp s.f arg, fType := s.fType.bindingBody!.instantiate1 arg }", "start": [105, 1], "end": [106, 118], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.getBindingName", "code": "private def getBindingName : M Name := return (\u2190 get).fType.bindingName!", "start": [108, 1], "end": [109, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.getArgExpectedType", "code": "private def getArgExpectedType : M Expr := return (\u2190 get).fType.bindingDomain!", "start": [110, 1], "end": [111, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.getFType", "code": "private def getFType : M Expr := do\n  let fType \u2190 whnfForall (\u2190 get).fType\n  modify fun s => { s with fType := fType }\n  pure fType", "start": [113, 1], "end": [116, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.Result", "code": "structure Result where\n  elimApp : Expr\n  alts    : Array Alt := #[]\n  others  : Array MVarId := #[]", "start": [118, 1], "end": [121, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.mkElimApp", "code": "partial def mkElimApp (elimInfo : ElimInfo) (targets : Array Expr) (tag : Name) : TermElabM Result := do\n  let rec loop : M Unit := do\n    match (\u2190 getFType) with\n    | .forallE binderName _ _ c =>\n      let ctx \u2190 read\n      let argPos := (\u2190 get).argPos\n      if ctx.elimInfo.motivePos == argPos then\n        let motive \u2190 mkFreshExprMVar (\u2190 getArgExpectedType) MetavarKind.syntheticOpaque\n        addNewArg motive\n      else if ctx.elimInfo.targetsPos.contains argPos then\n        let s \u2190 get\n        let ctx \u2190 read\n        unless s.targetPos < ctx.targets.size do\n          throwError \"insufficient number of targets for '{elimInfo.name}'\"\n        let target := ctx.targets[s.targetPos]!\n        let expectedType \u2190 getArgExpectedType\n        let target \u2190 withAssignableSyntheticOpaque <| Term.ensureHasType expectedType target\n        modify fun s => { s with targetPos := s.targetPos + 1 }\n        addNewArg target\n      else match c with\n        | .implicit =>\n          let arg \u2190 mkFreshExprMVar (\u2190 getArgExpectedType)\n          addNewArg arg\n        | .strictImplicit =>\n          let arg \u2190 mkFreshExprMVar (\u2190 getArgExpectedType)\n          addNewArg arg\n        | .instImplicit =>\n          let arg \u2190 mkFreshExprMVar (\u2190 getArgExpectedType) (kind := MetavarKind.synthetic) (userName := appendTag tag binderName)\n          modify fun s => { s with insts := s.insts.push arg.mvarId! }\n          addNewArg arg\n        | _ =>\n          let arg \u2190 mkFreshExprSyntheticOpaqueMVar (\u2190 getArgExpectedType) (tag := appendTag tag binderName)\n          let x   \u2190 getBindingName\n          modify fun s =>\n            let declName? := elimInfo.altsInfo[s.alts.size]!.declName?\n            { s with alts := s.alts.push \u27e8x, declName?, arg.mvarId!\u27e9 }\n          addNewArg arg\n      loop\n    | _ =>\n      pure ()\n  let f \u2190 Term.mkConst elimInfo.name\n  let fType \u2190 inferType f\n  let (_, s) \u2190 (loop).run { elimInfo := elimInfo, targets := targets } |>.run { f := f, fType := fType }\n  let mut others := #[]\n  for mvarId in s.insts do\n    try\n      unless (\u2190 Term.synthesizeInstMVarCore mvarId) do\n        mvarId.setKind .syntheticOpaque\n        others := others.push mvarId\n    catch _ =>\n      mvarId.setKind .syntheticOpaque\n      others := others.push mvarId\n  let alts \u2190 s.alts.filterM fun alt => return !(\u2190 alt.mvarId.isAssigned)\n  return { elimApp := (\u2190 instantiateMVars s.f), alts, others := others }", "start": [123, 1], "end": [182, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.setMotiveArg", "code": "def setMotiveArg (mvarId : MVarId) (motiveArg : MVarId) (targets : Array FVarId) : MetaM Unit := do\n  let type \u2190 inferType (mkMVar mvarId)\n  let motive \u2190 mkLambdaFVars (targets.map mkFVar) type\n  let motiverInferredType \u2190 inferType motive\n  let motiveType \u2190 inferType (mkMVar motiveArg)\n  unless (\u2190 isDefEqGuarded motiverInferredType motiveType) do\n    throwError \"type mismatch when assigning motive{indentExpr motive}\\n{\u2190 mkHasTypeButIsExpectedMsg motiverInferredType motiveType}\"\n  motiveArg.assign motive", "start": [184, 1], "end": [193, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.getAltNumFields", "code": "private def getAltNumFields (elimInfo : ElimInfo) (altName : Name) : TermElabM Nat := do\n  for altInfo in elimInfo.altsInfo do\n    if altInfo.name == altName then\n      return altInfo.numFields\n  throwError \"unknown alternative name '{altName}'\"", "start": [195, 1], "end": [199, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.checkAltNames", "code": "private def checkAltNames (alts : Array Alt) (altsSyntax : Array Syntax) : TacticM Unit :=\n  for i in [:altsSyntax.size] do\n    let altStx := altsSyntax[i]!\n    if getAltName altStx == `_ && i != altsSyntax.size - 1 then\n      withRef altStx <| throwError \"invalid occurrence of wildcard alternative, it must be the last alternative\"\n    let altName := getAltName altStx\n    if altName != `_ then\n      unless alts.any (\u00b7.name == altName) do\n        throwErrorAt altStx \"invalid alternative name '{altName}'\"", "start": [201, 1], "end": [209, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.getNumExplicitFields", "code": "private def getNumExplicitFields (altMVarId : MVarId) (numFields : Nat) : MetaM Nat := altMVarId.withContext do\n  let target \u2190 altMVarId.getType\n  withoutModifyingState do\n    let (_, bis, _) \u2190 forallMetaBoundedTelescope target numFields\n    return bis.foldl (init := 0) fun r bi => if bi.isExplicit then r + 1 else r", "start": [211, 1], "end": [218, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.saveAltVarsInfo", "code": "private def saveAltVarsInfo (altMVarId : MVarId) (altStx : Syntax) (fvarIds : Array FVarId) : TermElabM Unit :=\n  withSaveInfoContext <| altMVarId.withContext do\n    let useNamesForExplicitOnly := !altHasExplicitModifier altStx\n    let mut i := 0\n    let altVars := getAltVars altStx\n    for fvarId in fvarIds do\n      if !useNamesForExplicitOnly || (\u2190 fvarId.getDecl).binderInfo.isExplicit then\n        if i < altVars.size then\n          Term.addLocalVarInfo altVars[i]! (mkFVar fvarId)\n          i := i + 1", "start": [220, 1], "end": [229, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.reorderAlts", "code": "def reorderAlts (alts : Array Alt) (altsSyntax : Array Syntax) : Array Alt := Id.run do\n  if altsSyntax.isEmpty then\n    return alts\n  else\n    let mut alts := alts\n    let mut result := #[]\n    for altStx in altsSyntax do\n      let altName := getAltName altStx\n      let some i := alts.findIdx? (\u00b7.1 == altName) | return result ++ alts\n      result := result.push alts[i]!\n      alts := alts.eraseIdx i\n    return result ++ alts", "start": [231, 1], "end": [262, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElimApp.evalAlts", "code": "def evalAlts (elimInfo : ElimInfo) (alts : Array Alt) (optPreTac : Syntax) (altsSyntax : Array Syntax)\n    (initialInfo : Info)\n    (numEqs : Nat := 0) (numGeneralized : Nat := 0) (toClear : Array FVarId := #[]) : TacticM Unit := do\n  checkAltNames alts altsSyntax\n  let hasAlts := altsSyntax.size > 0\n  if hasAlts then\n    let treesSaved \u2190 getResetInfoTrees\n    withInfoContext ((modifyInfoState fun s => { s with trees := treesSaved }) *> go) (pure initialInfo)\n  else go\nwhere\n  go := do\n    let alts := reorderAlts alts altsSyntax\n    let hasAlts := altsSyntax.size > 0\n    let mut usedWildcard := false\n    let mut subgoals := #[] let mut altsSyntax := altsSyntax\n    for { name := altName, declName?, mvarId := altMVarId } in alts do\n      let numFields \u2190 getAltNumFields elimInfo altName\n      let mut isWildcard := false\n      let altStx? \u2190\n        match altsSyntax.findIdx? (fun alt => getAltName alt == altName) with\n        | some idx =>\n          let altStx := altsSyntax[idx]!\n          altsSyntax := altsSyntax.eraseIdx idx\n          pure (some altStx)\n        | none => match altsSyntax.findIdx? (fun alt => getAltName alt == `_) with\n          | some idx =>\n            isWildcard := true\n            pure (some altsSyntax[idx]!)\n          | none =>\n            pure none\n      match altStx? with\n      | none =>\n        let mut (_, altMVarId) \u2190 altMVarId.introN numFields\n        match (\u2190 Cases.unifyEqs? numEqs altMVarId {}) with\n        | none   => pure () | some (altMVarId', _) =>\n          (_, altMVarId) \u2190 altMVarId'.introNP numGeneralized\n          for fvarId in toClear do\n            altMVarId \u2190 altMVarId.tryClear fvarId\n          let altMVarIds \u2190 applyPreTac altMVarId\n          if !hasAlts then\n            subgoals := subgoals ++ altMVarIds.toArray\n          else if altMVarIds.isEmpty then\n            pure ()\n          else\n            logError m!\"alternative '{altName}' has not been provided\"\n            altMVarIds.forM fun mvarId => admitGoal mvarId\n      | some altStx =>\n        (subgoals, usedWildcard) \u2190 withRef altStx do\n          let altVars := getAltVars altStx\n          let numFieldsToName \u2190 if altHasExplicitModifier altStx then pure numFields else getNumExplicitFields altMVarId numFields\n          if altVars.size > numFieldsToName then\n            logError m!\"too many variable names provided at alternative '{altName}', #{altVars.size} provided, but #{numFieldsToName} expected\"\n          let mut (fvarIds, altMVarId) \u2190 altMVarId.introN numFields (altVars.toList.map getNameOfIdent') (useNamesForExplicitOnly := !altHasExplicitModifier altStx)\n          let addInfo := do\n            if (\u2190 getInfoState).enabled then\n              if let some declName := declName? then\n                addConstInfo (getAltNameStx altStx) declName\n              saveAltVarsInfo altMVarId altStx fvarIds\n          let unusedAlt := do\n            addInfo\n            if isWildcard then\n              pure (#[], usedWildcard)\n            else\n              throwError \"alternative '{altName}' is not needed\"\n          match (\u2190 Cases.unifyEqs? numEqs altMVarId {}) with\n          | none => unusedAlt\n          | some (altMVarId', _) =>\n            (_, altMVarId) \u2190 altMVarId'.introNP numGeneralized\n            for fvarId in toClear do\n              altMVarId \u2190 altMVarId.tryClear fvarId\n            let altMVarIds \u2190 applyPreTac altMVarId\n            if altMVarIds.isEmpty then\n              unusedAlt\n            else\n              let mut subgoals := subgoals\n              for altMVarId' in altMVarIds do\n                subgoals \u2190 evalAlt altMVarId' altStx addInfo subgoals\n              pure (subgoals, usedWildcard || isWildcard)\n    if usedWildcard then\n      altsSyntax := altsSyntax.filter fun alt => getAltName alt != `_\n    unless altsSyntax.isEmpty do\n      logErrorAt altsSyntax[0]! \"unused alternative\"\n    setGoals subgoals.toList\n  applyPreTac (mvarId : MVarId) : TacticM (List MVarId) :=\n    if optPreTac.isNone then\n      return [mvarId]\n    else\n      evalTacticAt optPreTac[0] mvarId", "start": [264, 1], "end": [360, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getUserGeneralizingFVarIds", "code": "private def getUserGeneralizingFVarIds (stx : Syntax) : TacticM (Array FVarId) :=\n  withRef stx do\n    let generalizingStx := stx[3]\n    if generalizingStx.isNone then\n      pure #[]\n    else\n      trace[Elab.induction] \"{generalizingStx}\"\n      let vars := generalizingStx[1].getArgs\n      getFVarIds vars", "start": [371, 1], "end": [379, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.generalizeVars", "code": "private def generalizeVars (mvarId : MVarId) (stx : Syntax) (targets : Array Expr) : TacticM (Nat \u00d7 MVarId) :=\n  mvarId.withContext do\n    let userFVarIds \u2190 getUserGeneralizingFVarIds stx\n    let forbidden \u2190 mkGeneralizationForbiddenSet targets\n    let mut s \u2190 getFVarSetToGeneralize targets forbidden\n    for userFVarId in userFVarIds do\n      if forbidden.contains userFVarId then\n        throwError \"variable cannot be generalized because target depends on it{indentExpr (mkFVar userFVarId)}\"\n      if s.contains userFVarId then\n        throwError \"unnecessary 'generalizing' argument, variable '{mkFVar userFVarId}' is generalized automatically\"\n      s := s.insert userFVarId\n    let fvarIds \u2190 sortFVarIds s.toArray\n    let (fvarIds, mvarId') \u2190 mvarId.revert fvarIds\n    return (fvarIds.size, mvarId')", "start": [382, 1], "end": [395, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getAltsOfInductionAlts", "code": "private def getAltsOfInductionAlts (inductionAlts : Syntax) : Array Syntax :=\n  inductionAlts[2].getArgs", "start": [397, 1], "end": [405, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getAltsOfOptInductionAlts", "code": "private def getAltsOfOptInductionAlts (optInductionAlts : Syntax) : Array Syntax :=\n  if optInductionAlts.isNone then #[] else getAltsOfInductionAlts optInductionAlts[0]", "start": [407, 1], "end": [408, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getOptPreTacOfOptInductionAlts", "code": "private def getOptPreTacOfOptInductionAlts (optInductionAlts : Syntax) : Syntax :=\n  if optInductionAlts.isNone then mkNullNode else optInductionAlts[0][1]", "start": [410, 1], "end": [411, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.isMultiAlt", "code": "private def isMultiAlt (alt : Syntax) : Bool :=\n  alt[0].getNumArgs > 1", "start": [413, 1], "end": [414, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.expandMultiAlt?", "code": "private def expandMultiAlt? (alt : Syntax) : Option (Array Syntax) := Id.run do\n  if isMultiAlt alt then\n    some <| alt[0].getArgs.map fun lhs => alt.setArg 0 (mkNullNode #[lhs])\n  else\n    none", "start": [416, 1], "end": [421, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.expandInductionAlts?", "code": "private def expandInductionAlts? (inductionAlts : Syntax) : Option Syntax := Id.run do\n  let alts := getAltsOfInductionAlts inductionAlts\n  if alts.any isMultiAlt then\n    let mut altsNew := #[]\n    for alt in alts do\n      if let some alt' := expandMultiAlt? alt then\n        altsNew := altsNew ++ alt'\n      else\n        altsNew := altsNew.push alt\n    some <| inductionAlts.setArg 2 (mkNullNode altsNew)\n  else\n    none", "start": [423, 1], "end": [444, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.expandInduction?", "code": "private def expandInduction? (induction : Syntax) : Option Syntax := do\n  let optInductionAlts := induction[4]\n  guard <| !optInductionAlts.isNone\n  let inductionAlts' \u2190 expandInductionAlts? optInductionAlts[0]\n  return induction.setArg 4 (mkNullNode #[inductionAlts'])", "start": [446, 1], "end": [457, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.expandCases?", "code": "private def expandCases? (induction : Syntax) : Option Syntax := do\n  let optInductionAlts := induction[3]\n  guard <| !optInductionAlts.isNone\n  let inductionAlts' \u2190 expandInductionAlts? optInductionAlts[0]\n  return induction.setArg 3 (mkNullNode #[inductionAlts'])", "start": [459, 1], "end": [470, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.checkAltsOfOptInductionAlts", "code": "private def checkAltsOfOptInductionAlts (optInductionAlts : Syntax) : TacticM Unit :=\n  unless optInductionAlts.isNone do\n    let mut found := false\n    for alt in getAltsOfInductionAlts optInductionAlts[0] do\n      let n := getAltName alt\n      if n == `_ then\n        unless (getAltVars alt).isEmpty do\n          throwErrorAt alt \"wildcard alternative must not specify variable names\"\n        if found then\n          throwErrorAt alt \"more than one wildcard alternative '| _ => ...' used\"\n        found := true", "start": [472, 1], "end": [485, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getInductiveValFromMajor", "code": "def getInductiveValFromMajor (major : Expr) : TacticM InductiveVal :=\n  liftMetaMAtMain fun mvarId => do\n    let majorType \u2190 inferType major\n    let majorType \u2190 whnf majorType\n    matchConstInduct majorType.getAppFn\n      (fun _ => Meta.throwTacticEx `induction mvarId m!\"major premise type is not an inductive type {indentExpr majorType}\")\n      (fun val _ => pure val)", "start": [487, 1], "end": [493, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getElimNameInfo", "code": "private def getElimNameInfo (optElimId : Syntax) (targets : Array Expr) (induction : Bool): TacticM ElimInfo := do\n  if optElimId.isNone then\n    if let some elimInfo \u2190 getCustomEliminator? targets then\n      return elimInfo\n    unless targets.size == 1 do\n      throwError \"eliminator must be provided when multiple targets are used (use 'using <eliminator-name>'), and no default eliminator has been registered using attribute `[eliminator]`\"\n    let indVal \u2190 getInductiveValFromMajor targets[0]!\n    if induction && indVal.all.length != 1 then\n      throwError \"'induction' tactic does not support mutually inductive types, the eliminator '{mkRecName indVal.name}' has multiple motives\"\n    if induction && indVal.isNested then\n      throwError \"'induction' tactic does not support nested inductive types, the eliminator '{mkRecName indVal.name}' has multiple motives\"\n    let elimName := if induction then mkRecName indVal.name else mkCasesOnName indVal.name\n    getElimInfo elimName indVal.name\n  else\n    let elimId := optElimId[1]\n    let elimName \u2190 withRef elimId do resolveGlobalConstNoOverloadWithInfo elimId\n    let baseName? := if \u2190 isInductive elimName.getPrefix then some elimName.getPrefix else none\n    withRef elimId <| getElimInfo elimName baseName?", "start": [496, 1], "end": [515, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.shouldGeneralizeTarget", "code": "private def shouldGeneralizeTarget (e : Expr) : MetaM Bool := do\n  if let .fvar fvarId .. := e then\n    return (\u2190  fvarId.getDecl).hasValue else\n    return true", "start": [517, 1], "end": [521, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.generalizeTargets", "code": "private def generalizeTargets (exprs : Array Expr) : TacticM (Array Expr) := do\n  if (\u2190 withMainContext <| exprs.anyM (shouldGeneralizeTarget \u00b7)) then\n    liftMetaTacticAux fun mvarId => do\n      let (fvarIds, mvarId) \u2190 mvarId.generalize (exprs.map fun expr => { expr })\n      return (fvarIds.map mkFVar, [mvarId])\n  else\n    return exprs", "start": [523, 1], "end": [529, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalInduction", "code": "@[builtin_tactic Lean.Parser.Tactic.induction] def evalInduction : Tactic := fun stx =>\n  match expandInduction? stx with\n  | some stxNew => withMacroExpansion stx stxNew <| evalTactic stxNew\n  | _ => focus do\n    let optInductionAlts := stx[4]\n    let alts := getAltsOfOptInductionAlts optInductionAlts\n    let targets \u2190 withMainContext <| stx[1].getSepArgs.mapM (elabTerm \u00b7 none)\n    let targets \u2190 generalizeTargets targets\n    let elimInfo \u2190 withMainContext <| getElimNameInfo stx[2] targets (induction := true)\n    let mvarId \u2190 getMainGoal\n    let initInfo \u2190 mkTacticInfo (\u2190 getMCtx) (\u2190 getUnsolvedGoals) (\u2190 getRef)\n    let tag \u2190 mvarId.getTag\n    mvarId.withContext do\n      let targets \u2190 addImplicitTargets elimInfo targets\n      checkTargets targets\n      let targetFVarIds := targets.map (\u00b7.fvarId!)\n      let (n, mvarId) \u2190 generalizeVars mvarId stx targets\n      mvarId.withContext do\n        let result \u2190 withRef stx[1] do ElimApp.mkElimApp elimInfo targets tag\n        trace[Elab.induction] \"elimApp: {result.elimApp}\"\n        let elimArgs := result.elimApp.getAppArgs\n        ElimApp.setMotiveArg mvarId elimArgs[elimInfo.motivePos]!.mvarId! targetFVarIds\n        let optPreTac := getOptPreTacOfOptInductionAlts optInductionAlts\n        mvarId.assign result.elimApp\n        ElimApp.evalAlts elimInfo result.alts optPreTac alts initInfo (numGeneralized := n) (toClear := targetFVarIds)\n        appendGoals result.others.toList\nwhere\n  checkTargets (targets : Array Expr) : MetaM Unit := do\n    let mut foundFVars : FVarIdSet := {}\n    for target in targets do\n      unless target.isFVar do\n        throwError \"index in target's type is not a variable (consider using the `cases` tactic instead){indentExpr target}\"\n      if foundFVars.contains target.fvarId! then\n        throwError \"target (or one of its indices) occurs more than once{indentExpr target}\"", "start": [531, 1], "end": [566, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.elabCasesTargets", "code": "def elabCasesTargets (targets : Array Syntax) : TacticM (Array Expr) :=\n  withMainContext do\n    let args \u2190 targets.mapM fun target => do\n      let hName? := if target[0].isNone then none else some target[0][0].getId\n      let expr \u2190 elabTerm target[1] none\n      return { expr, hName? : GeneralizeArg }\n    if (\u2190 withMainContext <| args.anyM fun arg => shouldGeneralizeTarget arg.expr <||> pure arg.hName?.isSome) then\n      liftMetaTacticAux fun mvarId => do\n        let argsToGeneralize \u2190 args.filterM fun arg => shouldGeneralizeTarget arg.expr <||> pure arg.hName?.isSome\n        let (fvarIdsNew, mvarId) \u2190 mvarId.generalize argsToGeneralize\n        let mut result := #[]\n        let mut j := 0\n        for arg in args do\n          if (\u2190 shouldGeneralizeTarget arg.expr) || arg.hName?.isSome then\n            result := result.push (mkFVar fvarIdsNew[j]!)\n            j := j+1\n          else\n            result := result.push arg.expr\n        return (result, [mvarId])\n    else\n      return args.map (\u00b7.expr)", "start": [568, 1], "end": [588, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalCases", "code": "@[builtin_tactic Lean.Parser.Tactic.cases] def evalCases : Tactic := fun stx =>\n  match expandCases? stx with\n  | some stxNew => withMacroExpansion stx stxNew <| evalTactic stxNew\n  | _ => focus do\n    let targets \u2190 elabCasesTargets stx[1].getSepArgs\n    let optInductionAlts := stx[3]\n    let optPreTac := getOptPreTacOfOptInductionAlts optInductionAlts\n    let alts :=  getAltsOfOptInductionAlts optInductionAlts\n    let targetRef := stx[1]\n    let elimInfo \u2190 withMainContext <| getElimNameInfo stx[2] targets (induction := false)\n    let mvarId \u2190 getMainGoal\n    let initInfo \u2190 mkTacticInfo (\u2190 getMCtx) (\u2190 getUnsolvedGoals) (\u2190 getRef)\n    let tag \u2190 mvarId.getTag\n    mvarId.withContext do\n      let targets \u2190 addImplicitTargets elimInfo targets\n      let result \u2190 withRef targetRef <| ElimApp.mkElimApp elimInfo targets tag\n      let elimArgs := result.elimApp.getAppArgs\n      let targets \u2190 elimInfo.targetsPos.mapM fun i => instantiateMVars elimArgs[i]!\n      let motiveType \u2190 inferType elimArgs[elimInfo.motivePos]!\n      let mvarId \u2190 generalizeTargetsEq mvarId motiveType targets\n      let (targetsNew, mvarId) \u2190 mvarId.introN targets.size\n      mvarId.withContext do\n        ElimApp.setMotiveArg mvarId elimArgs[elimInfo.motivePos]!.mvarId! targetsNew\n        mvarId.assign result.elimApp\n        ElimApp.evalAlts elimInfo result.alts optPreTac alts initInfo (numEqs := targets.size) (toClear := targetsNew)", "start": [590, 1], "end": [616, 119], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Util/ExtendedBinder.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/MacroArgUtil.lean", "lake-packages/lean4/src/lean/Lean/Linter/MissingDocs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.ExtendedBinder.checkBinderPredicate", "code": "@[missing_docs_handler binderPredicate]\ndef checkBinderPredicate : SimpleHandler := fun stx => do\n  if stx[0].isNone && stx[2][0][0].getKind != ``\u00ablocal\u00bb then\n    if stx[4].isNone then lint stx[3] \"binder predicate\"\n    else lintNamed stx[4][0][3] \"binder predicate\"", "start": [124, 1], "end": [129, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ElimDead.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.UsedLocalDecls", "code": "abbrev UsedLocalDecls := FVarIdHashSet", "start": [10, 1], "end": [10, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectLocalDeclsType", "code": "def collectLocalDeclsType (s : UsedLocalDecls) (type : Expr) : UsedLocalDecls :=\n  go s type\nwhere\n  go (s : UsedLocalDecls) (e : Expr) : UsedLocalDecls :=\n    match e with\n    | .forallE .. => s\n    | .lam _ _ b _ => go s b\n    | .app f a => go (go s a) f\n    | .fvar fvarId => s.insert fvarId\n    | .letE .. | .proj .. | .mdata .. => unreachable! | _ => s", "start": [12, 1], "end": [26, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectLocalDeclsArg", "code": "def collectLocalDeclsArg (s : UsedLocalDecls) (arg : Arg) : UsedLocalDecls :=\n  match arg with\n  | .erased => s\n  | .type e => collectLocalDeclsType s e\n  | .fvar fvarId => s.insert fvarId", "start": [28, 1], "end": [32, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectLocalDeclsArgs", "code": "def collectLocalDeclsArgs (s : UsedLocalDecls) (args : Array Arg) : UsedLocalDecls :=\n  args.foldl (init := s) collectLocalDeclsArg", "start": [34, 1], "end": [35, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectLocalDeclsLetValue", "code": "def collectLocalDeclsLetValue (s : UsedLocalDecls) (e : LetValue) : UsedLocalDecls :=\n  match e with\n  | .erased  | .value .. => s\n  | .proj _ _ fvarId => s.insert fvarId\n  | .const _ _ args => collectLocalDeclsArgs s args\n  | .fvar fvarId args => collectLocalDeclsArgs (s.insert fvarId) args", "start": [37, 1], "end": [42, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ElimDead.M", "code": "abbrev M := StateRefT UsedLocalDecls CompilerM", "start": [46, 1], "end": [46, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ElimDead.collectArgM", "code": "private abbrev collectArgM (arg : Arg) : M Unit :=\n  modify (collectLocalDeclsArg \u00b7 arg)", "start": [48, 1], "end": [49, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ElimDead.collectLetValueM", "code": "private abbrev collectLetValueM (e : LetValue) : M Unit :=\n  modify (collectLocalDeclsLetValue \u00b7 e)", "start": [51, 1], "end": [52, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ElimDead.collectFVarM", "code": "private abbrev collectFVarM (fvarId : FVarId) : M Unit :=\n  modify (\u00b7.insert fvarId)", "start": [54, 1], "end": [55, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ElimDead.visitFunDecl", "code": "partial def visitFunDecl (funDecl : FunDecl) : M FunDecl := do\n  let value \u2190 elimDead funDecl.value\n  funDecl.updateValue value", "start": [58, 1], "end": [60, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ElimDead.elimDead", "code": "partial def elimDead (code : Code) : M Code := do\n  match code with\n  | .let decl k =>\n    let k \u2190 elimDead k\n    if (\u2190 get).contains decl.fvarId then\n      \n      collectLetValueM decl.value\n      return code.updateCont! k\n    else\n      eraseLetDecl decl\n      return k\n  | .fun decl k | .jp decl k =>\n    let k \u2190 elimDead k\n    if (\u2190 get).contains decl.fvarId then\n      let decl \u2190 visitFunDecl decl\n      return code.updateFun! decl k\n    else\n      eraseFunDecl decl\n      return k\n  | .cases c =>\n    let alts \u2190 c.alts.mapMonoM fun alt => return alt.updateCode (\u2190 elimDead alt.getCode)\n    collectFVarM c.discr\n    return code.updateAlts! alts\n  | .return fvarId => collectFVarM fvarId; return code\n  | .jmp fvarId args => collectFVarM fvarId; args.forM collectArgM; return code\n  | .unreach .. => return code", "start": [62, 1], "end": [87, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.elimDead", "code": "def Code.elimDead (code : Code) : CompilerM Code :=\n  ElimDead.elimDead code |>.run' {}", "start": [93, 1], "end": [94, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.elimDead", "code": "def Decl.elimDead (decl : Decl) : CompilerM Decl := do\n  return { decl with value := (\u2190 decl.value.elimDead) }", "start": [96, 1], "end": [97, 56], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PrettyPrinter.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Internalize.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.indentD", "code": "private abbrev indentD := Std.Format.indentD", "start": [12, 1], "end": [12, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.M", "code": "abbrev M := ReaderT LocalContext CompilerM", "start": [16, 1], "end": [16, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.join", "code": "private def join (as : Array \u03b1) (f : \u03b1 \u2192 M Format) : M Format := do\n  if h : 0 < as.size then\n    let mut result \u2190 f as[0]\n    for a in as[1:] do\n      result := f!\"{result} {\u2190 f a}\"\n    return result\n  else\n    return .nil", "start": [18, 1], "end": [25, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.prefixJoin", "code": "private def prefixJoin (pre : Format) (as : Array \u03b1) (f : \u03b1 \u2192 M Format) : M Format := do\n  let mut result := .nil\n  for a in as do\n    result := f!\"{result}{pre}{\u2190 f a}\"\n  return result", "start": [27, 1], "end": [31, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppFVar", "code": "def ppFVar (fvarId : FVarId) : M Format :=\n  try\n    return format (\u2190 getBinderName fvarId)\n  catch _ =>\n    return format fvarId.name", "start": [33, 1], "end": [37, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppExpr", "code": "def ppExpr (e : Expr) : M Format := do\n  Meta.ppExpr e |>.run' { lctx := (\u2190 read) }", "start": [39, 1], "end": [40, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppArg", "code": "def ppArg (e : Arg) : M Format := do\n  match e with\n  | .erased => return \"\u25fe\"\n  | .fvar fvarId => ppFVar fvarId\n  | .type e =>\n    if pp.explicit.get (\u2190 getOptions) then\n      if e.isConst || e.isProp || e.isType0 || e.isFVar then\n        ppExpr e\n      else\n        return Format.paren (\u2190  ppExpr e)\n    else\n      return \"_\"", "start": [42, 1], "end": [53, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppArgs", "code": "def ppArgs (args : Array Arg) : M Format := do\n  prefixJoin \" \" args ppArg", "start": [55, 1], "end": [56, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppLetValue", "code": "def ppLetValue (e : LetValue) : M Format := do\n  match e with\n  | .erased => return \"\u25fe\"\n  | .value v => ppExpr v.toExpr\n  | .proj _ i fvarId => return f!\"{\u2190 ppFVar fvarId} # {i}\"\n  | .fvar fvarId args => return f!\"{\u2190 ppFVar fvarId}{\u2190 ppArgs args}\"\n  | .const declName us args => return f!\"{\u2190 ppExpr (.const declName us)}{\u2190 ppArgs args}\"", "start": [58, 1], "end": [64, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppParam", "code": "def ppParam (param : Param) : M Format := do\n  let borrow := if param.borrow then \"@&\" else \"\"\n  if pp.funBinderTypes.get (\u2190 getOptions) then\n    return Format.paren f!\"{param.binderName} : {borrow}{\u2190 ppExpr param.type}\"\n  else\n    return format s!\"{borrow}{param.binderName}\"", "start": [66, 1], "end": [71, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppParams", "code": "def ppParams (params : Array Param) : M Format := do\n  prefixJoin \" \" params ppParam", "start": [73, 1], "end": [74, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppLetDecl", "code": "def ppLetDecl (letDecl : LetDecl) : M Format := do\n  if pp.letVarTypes.get (\u2190 getOptions) then\n    return f!\"let {letDecl.binderName} : {\u2190 ppExpr letDecl.type} := {\u2190 ppLetValue letDecl.value}\"\n  else\n    return f!\"let {letDecl.binderName} := {\u2190 ppLetValue letDecl.value}\"", "start": [76, 1], "end": [80, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.getFunType", "code": "def getFunType (ps : Array Param) (type : Expr) : CoreM Expr :=\n  instantiateForall type (ps.map (mkFVar \u00b7.fvarId))", "start": [82, 1], "end": [83, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppFunDecl", "code": "partial def ppFunDecl (funDecl : FunDecl) : M Format := do\n    return f!\"{funDecl.binderName}{\u2190 ppParams funDecl.params} : {\u2190 ppExpr (\u2190 getFunType funDecl.params funDecl.type)} :={indentD (\u2190 ppCode funDecl.value)}\"", "start": [86, 3], "end": [87, 156], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppAlt", "code": "partial def ppAlt (alt : Alt) : M Format := do\n    match alt with\n    | .default k => return f!\"| _ =>{indentD (\u2190 ppCode k)}\"\n    | .alt ctorName params k => return f!\"| {ctorName}{\u2190 ppParams params} =>{indentD (\u2190 ppCode k)}\"", "start": [89, 3], "end": [92, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.ppCode", "code": "partial def ppCode (c : Code) : M Format := do\n    match c with\n    | .let decl k => return (\u2190 ppLetDecl decl) ++ \";\" ++ .line ++ (\u2190 ppCode k)\n    | .fun decl k => return f!\"fun \" ++ (\u2190 ppFunDecl decl) ++ \";\" ++ .line ++ (\u2190 ppCode k)\n    | .jp decl k => return f!\"jp \" ++ (\u2190 ppFunDecl decl) ++ \";\" ++ .line ++ (\u2190 ppCode k)\n    | .cases c => return f!\"cases {\u2190 ppFVar c.discr} : {\u2190 ppExpr c.resultType}{\u2190 prefixJoin .line c.alts ppAlt}\"\n    | .return fvarId => return f!\"return {\u2190 ppFVar fvarId}\"\n    | .jmp fvarId args => return f!\"goto {\u2190 ppFVar fvarId}{\u2190 ppArgs args}\"\n    | .unreach type =>\n      if pp.all.get (\u2190 getOptions) then\n        return f!\"\u22a5 : {\u2190 ppExpr type}\"\n      else\n        return \"\u22a5\"", "start": [94, 3], "end": [106, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PP.run", "code": "def run (x : M \u03b1) : CompilerM \u03b1 :=\n  withOptions (pp.sanitizeNames.set \u00b7 false) do\n    x |>.run (\u2190 get).lctx.toLocalContext", "start": [109, 1], "end": [111, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ppCode", "code": "def ppCode (code : Code) : CompilerM Format :=\n  PP.run <| PP.ppCode code", "start": [115, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ppLetValue", "code": "def ppLetValue (e : LetValue) : CompilerM Format :=\n  PP.run <| PP.ppLetValue e", "start": [118, 1], "end": [119, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ppDecl", "code": "def ppDecl (decl : Decl) : CompilerM Format :=\n  PP.run do\n    return f!\"def {decl.name}{\u2190 PP.ppParams decl.params} : {\u2190 PP.ppExpr (\u2190 PP.getFunType decl.params decl.type)} :={indentD (\u2190 PP.ppCode decl.value)}\"", "start": [121, 1], "end": [123, 151], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ppFunDecl", "code": "def ppFunDecl (decl : FunDecl) : CompilerM Format :=\n  PP.run do\n    return f!\"fun {\u2190 PP.ppFunDecl decl}\"", "start": [125, 1], "end": [127, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.runCompilerWithoutModifyingState", "code": "def runCompilerWithoutModifyingState (x : CompilerM \u03b1) : CoreM \u03b1 := do\n  let s \u2190 get\n  try\n    x |>.run {}\n  finally\n    set s", "start": [129, 1], "end": [138, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ppDecl'", "code": "def ppDecl' (decl : Decl) : CoreM Format := do\n  runCompilerWithoutModifyingState do\n    ppDecl (\u2190 decl.internalize)", "start": [140, 1], "end": [147, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ppCode'", "code": "def ppCode' (code : Code) : CoreM Format := do\n  runCompilerWithoutModifyingState do\n    ppCode (\u2190 code.internalize)", "start": [149, 1], "end": [155, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Config.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.Config", "code": "structure Config where\n  \n  etaPoly : Bool := false\n  \n  inlinePartial := false\n  \n  implementedBy := false\n  \n  inlineDefs := true\n  deriving Inhabited", "start": [9, 1], "end": [38, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/AlphaEqv.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.AlphaEqv.EqvM", "code": "abbrev EqvM := ReaderM (FVarIdMap FVarId)", "start": [16, 1], "end": [16, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.eqvFVar", "code": "def eqvFVar (fvarId\u2081 fvarId\u2082 : FVarId) : EqvM Bool := do\n  let fvarId\u2082 := (\u2190 read).find? fvarId\u2082 |>.getD fvarId\u2082\n  return fvarId\u2081 == fvarId\u2082", "start": [18, 1], "end": [20, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.eqvType", "code": "def eqvType (e\u2081 e\u2082 : Expr) : EqvM Bool := do\n  match e\u2081, e\u2082 with\n  | .app f\u2081 a\u2081, .app f\u2082 a\u2082 => eqvType a\u2081 a\u2082 <&&> eqvType f\u2081 f\u2082\n  | .fvar fvarId\u2081, .fvar fvarId\u2082 => eqvFVar fvarId\u2081 fvarId\u2082\n  | .forallE _ d\u2081 b\u2081 _, .forallE _ d\u2082 b\u2082 _ => eqvType d\u2081 d\u2082 <&&> eqvType b\u2081 b\u2082\n  | _, _ => return e\u2081 == e\u2082", "start": [22, 1], "end": [27, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.eqvTypes", "code": "def eqvTypes (es\u2081 es\u2082 : Array Expr) : EqvM Bool := do\n  if es\u2081.size = es\u2082.size then\n    for e\u2081 in es\u2081, e\u2082 in es\u2082 do\n      unless (\u2190 eqvType e\u2081 e\u2082) do\n        return false\n    return true\n  else\n    return false", "start": [29, 1], "end": [36, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.eqvArg", "code": "def eqvArg (a\u2081 a\u2082 : Arg) : EqvM Bool := do\n  match a\u2081, a\u2082 with\n  | .type e\u2081, .type e\u2082 => eqvType e\u2081 e\u2082\n  | .fvar x\u2081, .fvar x\u2082 => eqvFVar x\u2081 x\u2082\n  | .erased, .erased => return true\n  | _, _ => return false", "start": [38, 1], "end": [43, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.eqvArgs", "code": "def eqvArgs (as\u2081 as\u2082 : Array Arg) : EqvM Bool := do\n  if as\u2081.size = as\u2082.size then\n    for a\u2081 in as\u2081, a\u2082 in as\u2082 do\n      unless (\u2190 eqvArg a\u2081 a\u2082) do\n        return false\n    return true\n  else\n    return false", "start": [45, 1], "end": [52, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.eqvLetValue", "code": "def eqvLetValue (e\u2081 e\u2082 : LetValue) : EqvM Bool := do\n  match e\u2081, e\u2082 with\n  | .value v\u2081, .value v\u2082 => return v\u2081 == v\u2082\n  | .erased, .erased => return true\n  | .proj s\u2081 i\u2081 x\u2081, .proj s\u2082 i\u2082 x\u2082 => pure (s\u2081 == s\u2082 && i\u2081 == i\u2082) <&&> eqvFVar x\u2081 x\u2082\n  | .const n\u2081 us\u2081 as\u2081, .const n\u2082 us\u2082 as\u2082 => pure (n\u2081 == n\u2082 && us\u2081 == us\u2082) <&&> eqvArgs as\u2081 as\u2082\n  | .fvar f\u2081 as\u2081, .fvar f\u2082 as\u2082 => eqvFVar f\u2081 f\u2082 <&&> eqvArgs as\u2081 as\u2082\n  | _, _ => return false", "start": [54, 1], "end": [61, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.withFVar", "code": "@[inline] def withFVar (fvarId\u2081 fvarId\u2082 : FVarId) (x : EqvM \u03b1) : EqvM \u03b1 :=\n  withReader (\u00b7.insert fvarId\u2082 fvarId\u2081) x", "start": [63, 1], "end": [64, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.withParams", "code": "@[inline] def withParams (params\u2081 params\u2082 : Array Param) (x : EqvM Bool) : EqvM Bool := do\n  if h : params\u2082.size = params\u2081.size then\n    let rec @[specialize] go (i : Nat) : EqvM Bool := do\n      if h : i < params\u2081.size then\n        let p\u2081 := params\u2081[i]\n        have : i < params\u2082.size := by simp_all_arith\n        let p\u2082 := params\u2082[i]\n        unless (\u2190 eqvType p\u2081.type p\u2082.type) do return false\n        withFVar p\u2081.fvarId p\u2082.fvarId do\n          go (i+1)\n      else\n        x\n    go 0\n  else\n    return false\ntermination_by go i => params\u2081.size - i", "start": [66, 1], "end": [81, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.sortAlts", "code": "def sortAlts (alts : Array Alt) : Array Alt :=\n  alts.qsort fun\n    | .alt .., .default .. => true\n    | .alt ctorName\u2081 .., .alt ctorName\u2082 .. => Name.lt ctorName\u2081 ctorName\u2082\n    | _, _  => false", "start": [83, 1], "end": [87, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.eqvAlts", "code": "partial def eqvAlts (alts\u2081 alts\u2082 : Array Alt) : EqvM Bool := do\n  if alts\u2081.size = alts\u2082.size then\n    let alts\u2081 := sortAlts alts\u2081\n    let alts\u2082 := sortAlts alts\u2082\n    for alt\u2081 in alts\u2081, alt\u2082 in alts\u2082 do\n      match alt\u2081, alt\u2082 with\n      | .alt ctorName\u2081 ps\u2081 k\u2081, .alt ctorName\u2082 ps\u2082 k\u2082 =>\n        unless ctorName\u2081 == ctorName\u2082 do return false\n        unless (\u2190 withParams ps\u2081 ps\u2082 (eqv k\u2081 k\u2082)) do return false\n      | .default k\u2081, .default k\u2082 => unless (\u2190 eqv k\u2081 k\u2082) do return false\n      | _, _ => return false\n    return true\n  else\n    return false", "start": [91, 1], "end": [104, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AlphaEqv.eqv", "code": "partial def eqv (code\u2081 code\u2082 : Code) : EqvM Bool := do\n  match code\u2081, code\u2082 with\n  | .let decl\u2081 k\u2081, .let decl\u2082 k\u2082 =>\n    eqvType decl\u2081.type decl\u2082.type <&&>\n    eqvLetValue decl\u2081.value decl\u2082.value <&&>\n    withFVar decl\u2081.fvarId decl\u2082.fvarId (eqv k\u2081 k\u2082)\n  | .fun decl\u2081 k\u2081, .fun decl\u2082 k\u2082\n  | .jp decl\u2081 k\u2081, .jp decl\u2082 k\u2082 =>\n    eqvType decl\u2081.type decl\u2082.type <&&>\n    withParams decl\u2081.params decl\u2082.params (eqv decl\u2081.value decl\u2082.value) <&&>\n    withFVar decl\u2081.fvarId decl\u2082.fvarId (eqv k\u2081 k\u2082)\n  | .return fvarId\u2081, .return fvarId\u2082 => eqvFVar fvarId\u2081 fvarId\u2082\n  | .unreach type\u2081, .unreach type\u2082 => eqvType type\u2081 type\u2082\n  | .jmp fvarId\u2081 args\u2081, .jmp fvarId\u2082 args\u2082 => eqvFVar fvarId\u2081 fvarId\u2082 <&&> eqvArgs args\u2081 args\u2082\n  | .cases c\u2081, .cases c\u2082 =>\n    eqvFVar c\u2081.discr c\u2082.discr <&&>\n    eqvType c\u2081.resultType c\u2082.resultType <&&>\n    eqvAlts c\u2081.alts c\u2082.alts\n  | _, _ => return false", "start": [106, 1], "end": [124, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.alphaEqv", "code": "def Code.alphaEqv (c\u2081 c\u2082 : Code) : Bool :=\n  AlphaEqv.eqv c\u2081 c\u2082 |>.run {}", "start": [130, 1], "end": [134, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/JpCases.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/DiscrM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/DependsOn.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Internalize.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.isJpCases?", "code": "def isJpCases? (decl : FunDecl) : CompilerM (Option Nat) := do\n  if decl.params.size == 0 then\n    return none\n  else\n    let small := (\u2190 getConfig).smallThreshold\n    let rec go (code : Code) (prefixSize : Nat) : Option Nat :=\n      if prefixSize > small then none else\n      match code with\n      | .let _ k => go k (prefixSize + 1) \n      | .cases c => decl.params.findIdx? fun param => c.discr == param.fvarId\n      | _ => none\n    return go decl.value 0", "start": [15, 1], "end": [37, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.JpCasesInfo", "code": "structure JpCasesInfo where\n  \n  paramIdx  : Nat\n  \n  ctorNames : NameSet := {}\n  deriving Inhabited", "start": [39, 1], "end": [50, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.JpCasesInfoMap", "code": "abbrev JpCasesInfoMap := FVarIdMap JpCasesInfo", "start": [52, 1], "end": [52, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.JpCasesInfoMap.isCandidate", "code": "def JpCasesInfoMap.isCandidate (info : JpCasesInfoMap) : Bool :=\n  info.any fun _ s => !s.ctorNames.isEmpty", "start": [54, 1], "end": [56, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.collectJpCasesInfo", "code": "partial def collectJpCasesInfo (code : Code) : CompilerM JpCasesInfoMap := do\n  let (_, s) \u2190 go code |>.run {} |>.run {}\n  return s\nwhere\n  go (code : Code) : StateRefT JpCasesInfoMap DiscrM Unit := do\n    match code with\n    | .let _ k => go k\n    | .fun decl k => go decl.value; go k\n    | .jp decl k =>\n      if let some paramIdx \u2190 isJpCases? decl then\n        modify fun s => s.insert decl.fvarId { paramIdx }\n      go decl.value; go k\n    | .cases c => c.alts.forM fun alt =>\n      match alt with\n      | .default k => go k\n      | .alt ctorName ps k => withDiscrCtor c.discr ctorName ps <| go k\n    | .return .. | .unreach .. => return ()\n    | .jmp fvarId args =>\n      if let some info := (\u2190 get).find? fvarId then\n        let .fvar argFVarId := args[info.paramIdx]! | return ()\n        let some ctorName \u2190 findCtorName? argFVarId | return ()\n        modify fun map => map.insert fvarId <| { info with ctorNames := info.ctorNames.insert ctorName }", "start": [58, 1], "end": [85, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.extractJpCases", "code": "private def extractJpCases (code : Code) : Array CodeDecl \u00d7 Cases :=\n  go code #[]\nwhere\n  go (code : Code) (decls : Array CodeDecl) :=\n    match code with\n    | .let decl k => go k <| decls.push (.let decl)\n    | .cases c => (decls, c)\n    | _ => unreachable!", "start": [87, 1], "end": [97, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.JpCasesAlt", "code": "structure JpCasesAlt where\n  decl           : FunDecl\n  default        : Bool\n  dependsOnDiscr : Bool", "start": [99, 1], "end": [102, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.Ctor2JpCasesAlt", "code": "abbrev Ctor2JpCasesAlt := FVarIdMap (NameMap JpCasesAlt)", "start": [104, 1], "end": [104, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.mkJpAlt", "code": "private def mkJpAlt (decls : Array CodeDecl) (params : Array Param) (targetParamIdx : Nat) (fields : Array Param) (k : Code) (default : Bool) : CompilerM JpCasesAlt := do\n  go |>.run' {}\nwhere\n  go : InternalizeM JpCasesAlt := do\n    let mut paramsNew := #[]\n    let singleton : FVarIdSet := ({} : FVarIdSet).insert params[targetParamIdx]!.fvarId\n    let dependsOnDiscr := k.dependsOn singleton || decls.any (\u00b7.dependsOn singleton)\n    for i in [:params.size] do\n      let param := params[i]!\n      if targetParamIdx == i then\n        if dependsOnDiscr then\n          paramsNew := paramsNew.push (\u2190 internalizeParam param)\n        paramsNew := paramsNew ++ (\u2190 fields.mapM internalizeParam)\n      else\n        paramsNew := paramsNew.push (\u2190 internalizeParam param)\n    let decls \u2190 decls.mapM internalizeCodeDecl\n    let k \u2190 internalizeCode k\n    let value := LCNF.attachCodeDecls decls k\n    return { decl := (\u2190 mkAuxJpDecl paramsNew value), default, dependsOnDiscr }", "start": [107, 1], "end": [134, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.mkJmpNewArgs", "code": "private def mkJmpNewArgs (args : Array Arg) (targetParamIdx : Nat) (fields : Array Arg) (dependsOnTarget : Bool) : Array Arg :=\n  if dependsOnTarget then\n    args[:targetParamIdx+1] ++ fields ++ args[targetParamIdx+1:]\n  else\n    args[:targetParamIdx] ++ fields ++ args[targetParamIdx+1:]", "start": [136, 1], "end": [141, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.mkJmpArgsAtJp", "code": "private def mkJmpArgsAtJp (params : Array Param) (targetParamIdx : Nat) (fields : Array Param) (dependsOnTarget : Bool) : Array Arg := Id.run do\n  mkJmpNewArgs (params.map (Arg.fvar \u00b7.fvarId)) targetParamIdx (fields.map (Arg.fvar \u00b7.fvarId)) dependsOnTarget", "start": [143, 1], "end": [148, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.simpJpCases?", "code": "partial def simpJpCases? (code : Code) : CompilerM (Option Code) := do\n  let map \u2190 collectJpCasesInfo code\n  unless map.isCandidate do return none\n  traceM `Compiler.simp.jpCases do\n    let mut msg : MessageData := \"candidates\"\n    for (fvarId, info) in map.toList do\n      msg := msg ++ indentD m!\"{mkFVar fvarId} \u21a6 {info.ctorNames.toList}\"\n    return msg\n  visit code map |>.run' {} |>.run {}\nwhere\n  visit (code : Code) : ReaderT JpCasesInfoMap (StateRefT Ctor2JpCasesAlt DiscrM) Code := do\n    match code with\n    | .let decl k =>\n      return code.updateLet! decl (\u2190 visit k)\n    | .fun decl k =>\n      let value \u2190 visit decl.value\n      let decl \u2190 decl.updateValue value\n      return code.updateFun! decl (\u2190 visit k)\n    | .jp decl k =>\n      if let some code \u2190 visitJp? decl k then\n        return code\n      else\n        let value \u2190 visit decl.value\n        let decl \u2190 decl.updateValue value\n        return code.updateFun! decl (\u2190 visit k)\n    | .cases c =>\n      let alts \u2190 c.alts.mapMonoM fun alt =>\n        match alt with\n        | .alt ctorName ps k =>\n          withDiscrCtor c.discr ctorName ps do\n            return alt.updateCode (\u2190 visit k)\n        | .default k => return alt.updateCode (\u2190 visit k)\n      return code.updateAlts! alts\n    | .return _ | .unreach _ => return code\n    | .jmp fvarId args =>\n      let some code \u2190 visitJmp? fvarId args | return code\n      return code\n\n  visitJp? (decl : FunDecl) (k : Code) : ReaderT JpCasesInfoMap (StateRefT Ctor2JpCasesAlt DiscrM) (Option Code) := do\n    let some info := (\u2190 read).find? decl.fvarId | return none\n    if info.ctorNames.isEmpty then return none\n    let (decls, cases) := extractJpCases decl.value\n    let mut jpAltMap := {}\n    let mut jpAltDecls := #[]\n    let mut altsNew := #[]\n    for alt in cases.alts do\n      match alt with\n      | .default k =>\n        let k \u2190 visit k\n        let explicitCtorNames := cases.getCtorNames\n        if info.ctorNames.any fun ctorNameInJump => !explicitCtorNames.contains ctorNameInJump then\n          let jpAlt \u2190 mkJpAlt decls decl.params info.paramIdx #[] k (default := true)\n          jpAltDecls := jpAltDecls.push (.jp jpAlt.decl)\n          eraseCode k\n          for ctorNameInJmp in info.ctorNames do\n            unless explicitCtorNames.contains ctorNameInJmp do\n              jpAltMap := jpAltMap.insert ctorNameInJmp jpAlt\n          let args := mkJmpArgsAtJp decl.params info.paramIdx #[] jpAlt.dependsOnDiscr\n          altsNew := altsNew.push (alt.updateCode (.jmp jpAlt.decl.fvarId args))\n        else\n          altsNew := altsNew.push (alt.updateCode k)\n      | .alt ctorName fields k =>\n        let k \u2190 withDiscrCtor cases.discr ctorName fields <| visit k\n        if info.ctorNames.contains ctorName then\n          let jpAlt \u2190 mkJpAlt decls decl.params info.paramIdx fields k (default := false)\n          jpAltDecls := jpAltDecls.push (.jp jpAlt.decl)\n          jpAltMap := jpAltMap.insert ctorName jpAlt\n          let args := mkJmpArgsAtJp decl.params info.paramIdx fields jpAlt.dependsOnDiscr\n          eraseCode k\n          altsNew := altsNew.push (alt.updateCode (.jmp jpAlt.decl.fvarId args))\n        else\n          altsNew := altsNew.push (alt.updateCode k)\n    modify fun s => s.insert decl.fvarId jpAltMap\n    let value := LCNF.attachCodeDecls decls (.cases { cases with alts := altsNew })\n    let decl \u2190 decl.updateValue value\n    let code := .jp decl (\u2190 visit k)\n    return LCNF.attachCodeDecls jpAltDecls code\n\n  visitJmp? (fvarId : FVarId) (args : Array Arg) : ReaderT JpCasesInfoMap (StateRefT Ctor2JpCasesAlt DiscrM) (Option Code) := do\n    let some ctorJpAltMap := (\u2190 get).find? fvarId | return none\n    let some info := (\u2190 read).find? fvarId | return none\n    let .fvar argFVarId := args[info.paramIdx]! | return none\n    let some ctorInfo \u2190 findCtor? argFVarId | return none\n    let some jpAlt := ctorJpAltMap.find? ctorInfo.getName | return none\n    if jpAlt.default then\n      let argsNew := mkJmpNewArgs args info.paramIdx #[] jpAlt.dependsOnDiscr\n      return some <| .jmp jpAlt.decl.fvarId argsNew\n    else\n      match ctorInfo with\n      | .ctor ctorVal ctorArgs =>\n         let fields := ctorArgs[ctorVal.numParams:]\n         let argsNew := mkJmpNewArgs args info.paramIdx fields jpAlt.dependsOnDiscr\n         return some <| .jmp jpAlt.decl.fvarId argsNew\n      | .natVal 0 =>\n        let argsNew := mkJmpNewArgs args info.paramIdx #[] jpAlt.dependsOnDiscr\n        return some <| .jmp jpAlt.decl.fvarId argsNew\n      | .natVal (n+1) =>\n        let auxDecl \u2190 mkAuxLetDecl (.value (.natVal n))\n        let argsNew := mkJmpNewArgs args info.paramIdx #[.fvar auxDecl.fvarId] jpAlt.dependsOnDiscr\n        return some <| .let auxDecl (.jmp jpAlt.decl.fvarId argsNew)", "start": [150, 1], "end": [294, 69], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/FunDeclInfo.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.FunDeclInfo", "code": "inductive FunDeclInfo where\n  \n  | once\n  \n  | many\n  \n  | mustInline\n  deriving Repr, Inhabited", "start": [11, 1], "end": [33, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.FunDeclInfoMap", "code": "structure FunDeclInfoMap where\n  \n  map : HashMap FVarId FunDeclInfo := {}\n  deriving Inhabited", "start": [35, 1], "end": [43, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.FunDeclInfoMap.format", "code": "def FunDeclInfoMap.format (s : FunDeclInfoMap) : CompilerM Format := do\n  let mut result := Format.nil\n  for (fvarId, info) in s.map.toList do\n    let binderName \u2190 getBinderName fvarId\n    result := result ++ \"\\n\" ++ f!\"{binderName} \u21a6 {repr info}\"\n  return result", "start": [45, 1], "end": [50, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.FunDeclInfoMap.add", "code": "def FunDeclInfoMap.add (s : FunDeclInfoMap) (fvarId : FVarId) : FunDeclInfoMap :=\n  match s with\n  | { map } =>\n    match map.find? fvarId with\n    | some .once => { map := map.insert fvarId .many }\n    | none       => { map := map.insert fvarId .once }\n    | _          => { map }", "start": [52, 1], "end": [61, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.FunDeclInfoMap.addHo", "code": "def FunDeclInfoMap.addHo (s : FunDeclInfoMap) (fvarId : FVarId) : FunDeclInfoMap :=\n  match s with\n  | { map } =>\n    match map.find? fvarId with\n    | some .once | none => { map := map.insert fvarId .many }\n    | _ => { map }", "start": [63, 1], "end": [71, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.FunDeclInfoMap.addMustInline", "code": "def FunDeclInfoMap.addMustInline (s : FunDeclInfoMap) (fvarId : FVarId) : FunDeclInfoMap :=\n  match s with\n  | { map } => { map := map.insert fvarId .mustInline }", "start": [73, 1], "end": [78, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.FunDeclInfoMap.restore", "code": "def FunDeclInfoMap.restore (s : FunDeclInfoMap) (fvarId : FVarId) (saved? : Option FunDeclInfo) : FunDeclInfoMap :=\n  match s, saved? with\n  | { map }, none => { map := map.erase fvarId }\n  | { map }, some saved => { map := map.insert fvarId saved }", "start": [80, 1], "end": [83, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.FunDeclInfoMap.update", "code": "partial def FunDeclInfoMap.update (s : FunDeclInfoMap) (code : Code) (mustInline := false) : CompilerM FunDeclInfoMap := do\n  let (_, s) \u2190 go code |>.run s\n  return s\nwhere\n  addArgOcc (arg : Arg) : StateRefT FunDeclInfoMap CompilerM Unit := do\n    match arg with\n    | .fvar fvarId =>\n      let some funDecl \u2190 findFunDecl'? fvarId | return ()\n      modify fun s => s.addHo funDecl.fvarId\n    | .erased .. | .type .. => return ()\n\n  addLetValueOccs (e : LetValue) : StateRefT FunDeclInfoMap CompilerM Unit := do\n    match e with\n    | .erased | .value .. | .proj .. => return ()\n    | .const _ _ args => args.forM addArgOcc\n    | .fvar fvarId args =>\n      let some funDecl \u2190 findFunDecl'? fvarId | return ()\n      modify fun s => s.add funDecl.fvarId\n      args.forM addArgOcc\n\n  go (code : Code) : StateRefT FunDeclInfoMap CompilerM Unit := do\n    match code with\n    | .let decl k =>\n      addLetValueOccs decl.value\n      go k\n    | .fun decl k =>\n      if mustInline then\n        modify fun s => s.addMustInline decl.fvarId\n      go decl.value; go k\n    | .jp decl k => go decl.value; go k\n    | .cases c => c.alts.forM fun alt => go alt.getCode\n    | .jmp fvarId args =>\n      let funDecl \u2190 getFunDecl fvarId\n      modify fun s => s.add funDecl.fvarId\n      args.forM addArgOcc\n    | .return .. | .unreach .. => return ()", "start": [85, 1], "end": [127, 44], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Renaming.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Renaming", "code": "abbrev Renaming := FVarIdMap Name", "start": [9, 1], "end": [12, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Param.applyRenaming", "code": "def Param.applyRenaming (param : Param) (r : Renaming) : CompilerM Param := do\n  if let some binderName := r.find? param.fvarId then\n    let param := { param with binderName }\n    modifyLCtx fun lctx => lctx.addParam param\n    return param\n  else\n    return param", "start": [14, 1], "end": [20, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl.applyRenaming", "code": "def LetDecl.applyRenaming (decl : LetDecl) (r : Renaming) : CompilerM LetDecl := do\n  if let some binderName := r.find? decl.fvarId then\n    let decl := { decl with binderName }\n    modifyLCtx fun lctx => lctx.addLetDecl decl\n    return decl\n  else\n    return decl", "start": [22, 1], "end": [28, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.applyRenaming", "code": "partial def FunDeclCore.applyRenaming (decl : FunDecl) (r : Renaming) : CompilerM FunDecl := do\n  if let some binderName := r.find? decl.fvarId then\n    let decl := { decl with binderName }\n    modifyLCtx fun lctx => lctx.addFunDecl decl\n    decl.updateValue (\u2190 decl.value.applyRenaming r)\n  else\n    decl.updateValue (\u2190 decl.value.applyRenaming r)", "start": [31, 1], "end": [37, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.applyRenaming", "code": "partial def Code.applyRenaming (code : Code) (r : Renaming) : CompilerM Code := do\n  match code with\n  | .let decl k => return code.updateLet! (\u2190 decl.applyRenaming r) (\u2190 k.applyRenaming r)\n  | .fun decl k | .jp decl k => return code.updateFun! (\u2190 decl.applyRenaming r) (\u2190 k.applyRenaming r)\n  | .cases c =>\n    let alts \u2190 c.alts.mapMonoM fun alt =>\n      match alt with\n      | .default k => return alt.updateCode (\u2190 k.applyRenaming r)\n      | .alt _ ps k => return alt.updateAlt! (\u2190 ps.mapMonoM (\u00b7.applyRenaming r)) (\u2190 k.applyRenaming r)\n    return code.updateAlts! alts\n  | .jmp .. | .unreach .. | .return .. => return code", "start": [39, 1], "end": [49, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.applyRenaming", "code": "def Decl.applyRenaming (decl : Decl) (r : Renaming) : CompilerM Decl := do\n  if r.isEmpty then\n    return decl\n  else\n    let params \u2190 decl.params.mapMonoM (\u00b7.applyRenaming r)\n    let value \u2190 decl.value.applyRenaming r\n    return { decl with params, value }", "start": [52, 1], "end": [58, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Meta/DiscrTree.lean", "imports": ["lake-packages/std/Std/Lean/PersistentHashMap.lean", "lake-packages/std/Std/Data/Ord.lean", "lake-packages/std/Std/Data/Array/Merge.lean", "lake-packages/std/Std/Lean/Meta/Expr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/DiscrTree.lean"], "premises": [{"full_name": "Lean.Meta.DiscrTree.Key.cmp", "code": "protected def cmp : Key s \u2192 Key s \u2192 Ordering\n  | .lit v\u2081,        .lit v\u2082        => compare v\u2081 v\u2082\n  | .fvar n\u2081 a\u2081,    .fvar n\u2082 a\u2082    => n\u2081.name.quickCmp n\u2082.name |>.then <| compare a\u2081 a\u2082\n  | .const n\u2081 a\u2081,   .const n\u2082 a\u2082   => n\u2081.quickCmp n\u2082 |>.then <| compare a\u2081 a\u2082\n  | .proj s\u2081 i\u2081 a\u2081, .proj s\u2082 i\u2082 a\u2082 =>\n    s\u2081.quickCmp s\u2082 |>.then <| compare i\u2081 i\u2082 |>.then <| compare a\u2081 a\u2082\n  | k\u2081,             k\u2082             => compare k\u2081.ctorIdx k\u2082.ctorIdx", "start": [17, 1], "end": [27, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.foldMUnsafe", "code": "private unsafe def foldMUnsafe [Monad m] (initialKeys : Array (Key s))\n    (f : \u03c3 \u2192 Array (Key s) \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3) : Trie \u03b1 s \u2192 m \u03c3\n  | Trie.node vs children => do\n    let s \u2190 vs.foldlM (init := init) fun s v => f s initialKeys v\n    children.foldlM (init := s) fun s (k, t) =>\n      t.foldMUnsafe (initialKeys.push k) f s", "start": [39, 1], "end": [44, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.foldM", "code": "@[implemented_by foldMUnsafe]\nopaque foldM [Monad m] (initalKeys : Array (Key s))\n    (f : \u03c3 \u2192 Array (Key s) \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3) (t : Trie \u03b1 s) : m \u03c3 :=\n  pure init", "start": [46, 1], "end": [52, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.fold", "code": "@[inline]\ndef fold (initialKeys : Array (Key s)) (f : \u03c3 \u2192 Array (Key s) \u2192 \u03b1 \u2192 \u03c3)\n    (init : \u03c3) (t : Trie \u03b1 s) : \u03c3 :=\n  Id.run <| t.foldM initialKeys (init := init) fun s k a => return f s k a", "start": [54, 1], "end": [60, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.foldValuesMUnsafe", "code": "private unsafe def foldValuesMUnsafe [Monad m] (f : \u03c3 \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3) :\n    Trie \u03b1 s \u2192 m \u03c3\n| node vs children => do\n  let s \u2190 vs.foldlM (init := init) f\n  children.foldlM (init := s) fun s (_, c) => c.foldValuesMUnsafe (init := s) f", "start": [64, 1], "end": [68, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.foldValuesM", "code": "@[implemented_by foldValuesMUnsafe]\nopaque foldValuesM [Monad m] (f : \u03c3 \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3) (t : Trie \u03b1 s) : m \u03c3 := pure init", "start": [70, 1], "end": [74, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.foldValues", "code": "@[inline]\ndef foldValues (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3) (init : \u03c3) (t : Trie \u03b1 s) : \u03c3 :=\n  Id.run <| t.foldValuesM (init := init) f", "start": [76, 1], "end": [81, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.size", "code": "partial def size : Trie \u03b1 s \u2192 Nat\n  | Trie.node vs children =>\n    children.foldl (init := vs.size) fun n (_, c) => n + size c", "start": [83, 1], "end": [88, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.mergePreservingDuplicates", "code": "partial def mergePreservingDuplicates : Trie \u03b1 s \u2192 Trie \u03b1 s \u2192 Trie \u03b1 s\n  | node vs\u2081 cs\u2081, node vs\u2082 cs\u2082 =>\n    node (vs\u2081 ++ vs\u2082) (mergeChildren cs\u2081 cs\u2082)\nwhere\n  \n  mergeChildren (cs\u2081 cs\u2082 : Array (Key s \u00d7 Trie \u03b1 s)) :\n      Array (Key s \u00d7 Trie \u03b1 s) :=\n    Array.mergeSortedMergingDuplicates\n      (ord := \u27e8compareOn (\u00b7.fst)\u27e9) cs\u2081 cs\u2082\n      (fun (k\u2081, t\u2081) (_, t\u2082) => (k\u2081, mergePreservingDuplicates t\u2081 t\u2082))", "start": [90, 1], "end": [102, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.foldM", "code": "@[inline]\ndef foldM [Monad m] (f : \u03c3 \u2192 Array (Key s) \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3)\n    (t : DiscrTree \u03b1 s) : m \u03c3 :=\n  t.root.foldlM (init := init) fun s k t => t.foldM #[k] (init := s) f", "start": [107, 1], "end": [113, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.fold", "code": "@[inline]\ndef fold (f : \u03c3 \u2192 Array (Key s) \u2192 \u03b1 \u2192 \u03c3) (init : \u03c3) (t : DiscrTree \u03b1 s) : \u03c3 :=\n  Id.run <| t.foldM (init := init) fun s keys a => return f s keys a", "start": [115, 1], "end": [120, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.foldValuesM", "code": "@[inline]\ndef foldValuesM [Monad m] (f : \u03c3 \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3) (t : DiscrTree \u03b1 s) :\n    m \u03c3 :=\n  t.root.foldlM (init := init) fun s _ t => t.foldValuesM (init := s) f", "start": [122, 1], "end": [128, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.foldValues", "code": "@[inline]\ndef foldValues (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3) (init : \u03c3) (t : DiscrTree \u03b1 s) : \u03c3 :=\n  Id.run <| t.foldValuesM (init := init) f", "start": [130, 1], "end": [135, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.values", "code": "@[inline]\ndef values (t : DiscrTree \u03b1 s) : Array \u03b1 :=\n  t.foldValues (init := #[]) fun as a => as.push a", "start": [137, 1], "end": [142, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.toArray", "code": "@[inline]\ndef toArray (t : DiscrTree \u03b1 s) : Array (Array (Key s) \u00d7 \u03b1) :=\n  t.fold (init := #[]) fun as keys a => as.push (keys, a)", "start": [144, 1], "end": [149, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.size", "code": "@[inline]\ndef size (t : DiscrTree \u03b1 s) : Nat :=\n  t.root.foldl (init := 0) fun n _ t => n + t.size", "start": [151, 1], "end": [156, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.mergePreservingDuplicates", "code": "@[inline]\ndef mergePreservingDuplicates (t u : DiscrTree \u03b1 s) : DiscrTree \u03b1 s :=\n  \u27e8t.root.mergeWith u.root fun _ trie\u2081 trie\u2082 =>\n    trie\u2081.mergePreservingDuplicates trie\u2082\u27e9", "start": [158, 1], "end": [164, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/RCases.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Induction.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.FVarSubst.append", "code": "def Lean.Meta.FVarSubst.append (s t : FVarSubst) : FVarSubst :=\n  s.1.foldl (fun s' k v => s'.insert k (t.apply v)) t", "start": [59, 1], "end": [64, 54], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt", "code": "inductive RCasesPatt : Type\n  \n  | paren (ref : Syntax) : RCasesPatt \u2192 RCasesPatt\n  \n  | one (ref : Syntax) : Name \u2192 RCasesPatt\n  \n  | clear (ref : Syntax) : RCasesPatt\n  \n  | explicit (ref : Syntax) : RCasesPatt \u2192 RCasesPatt\n  \n  | typed (ref : Syntax) : RCasesPatt \u2192 Term \u2192 RCasesPatt\n  \n  | tuple (ref : Syntax) : List\u03a0 RCasesPatt \u2192 RCasesPatt\n  \n  | alts (ref : Syntax) : List\u03a3 RCasesPatt \u2192 RCasesPatt\n  deriving Repr", "start": [128, 1], "end": [163, 16], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.name?", "code": "partial def name? : RCasesPatt \u2192 Option Name\n  | one _ `_    => none\n  | one _ `rfl  => none\n  | one _ n     => n\n  | paren _ p\n  | typed _ p _\n  | alts _ [p]  => p.name?\n  | _           => none", "start": [169, 1], "end": [177, 24], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.ref", "code": "def ref : RCasesPatt \u2192 Syntax\n  | paren ref _\n  | one ref _\n  | clear ref\n  | explicit ref _\n  | typed ref _ _\n  | tuple ref _\n  | alts ref _ => ref", "start": [179, 1], "end": [187, 22], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.asTuple", "code": "def asTuple : RCasesPatt \u2192 Bool \u00d7 List\u03a0 RCasesPatt\n  | paren _ p    => p.asTuple\n  | explicit _ p => (true, p.asTuple.2)\n  | tuple _ ps   => (false, ps)\n  | p            => (false, [p])", "start": [189, 1], "end": [196, 33], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.asAlts", "code": "def asAlts : RCasesPatt \u2192 List\u03a3 RCasesPatt\n  | paren _ p => p.asAlts\n  | alts _ ps => ps\n  | p         => [p]", "start": [198, 1], "end": [205, 21], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.typed?", "code": "def typed? (ref : Syntax) : RCasesPatt \u2192 Option Term \u2192 RCasesPatt\n  | p, none => p\n  | p, some ty => typed ref p ty", "start": [207, 1], "end": [210, 33], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.tuple'", "code": "def tuple' : List\u03a0 RCasesPatt \u2192 RCasesPatt\n  | [p] => p\n  | ps  => tuple (ps.head?.map (\u00b7.ref) |>.getD .missing) ps", "start": [212, 1], "end": [215, 60], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.alts'", "code": "def alts' (ref : Syntax) : List\u03a3 RCasesPatt \u2192 RCasesPatt\n  | [p] => p\n  | ps  => alts ref ps", "start": [217, 1], "end": [223, 23], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.tuple\u2081Core", "code": "def tuple\u2081Core : List\u03a0 RCasesPatt \u2192 List\u03a0 RCasesPatt\n  | []         => []\n  | [tuple ref []] => [tuple ref []]\n  | [tuple _ ps] => ps\n  | p :: ps    => p :: tuple\u2081Core ps", "start": [225, 1], "end": [238, 37], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.tuple\u2081", "code": "def tuple\u2081 : List\u03a0 RCasesPatt \u2192 RCasesPatt\n  | []      => default\n  | [one ref n] => one ref n\n  | ps      => tuple ps.head!.ref $ tuple\u2081Core ps", "start": [240, 1], "end": [248, 50], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.alts\u2081Core", "code": "def alts\u2081Core : List\u03a3 (List\u03a0 RCasesPatt) \u2192 List\u03a3 RCasesPatt\n  | []          => []\n  | [[alts _ ps]] => ps\n  | p :: ps     => tuple\u2081 p :: alts\u2081Core ps", "start": [250, 1], "end": [260, 44], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.alts\u2081", "code": "def alts\u2081 (ref : Syntax) : List\u03a3 (List\u03a0 RCasesPatt) \u2192 RCasesPatt\n  | [[]]        => tuple .missing []\n  | [[alts ref ps]] => tuple ref ps\n  | ps          => alts' ref $ alts\u2081Core ps", "start": [262, 1], "end": [272, 44], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.processConstructor", "code": "def processConstructor (ref : Syntax) (info : Array ParamInfo)\n    (explicit : Bool) (idx : Nat) (ps : List\u03a0 RCasesPatt) : List\u03a0 Name \u00d7 List\u03a0 RCasesPatt :=\n  if _ : idx < info.size then\n    if !explicit && info[idx].binderInfo != .default then\n      let (ns, tl) := processConstructor ref info explicit (idx+1) ps\n      (`_ :: ns, default :: tl)\n    else if idx+1 < info.size then\n      let p := ps.headD default\n      let (ns, tl) := processConstructor ref info explicit (idx+1) (ps.tailD [])\n      (p.name?.getD `_ :: ns, p :: tl)\n    else match ps with\n      | []  => ([`_], [default])\n      | [p] => ([p.name?.getD `_], [p])\n      | ps  => ([`_], [(bif explicit then .explicit ref else id) (.tuple ref ps)])\n  else ([], [])\ntermination_by _ => info.size - idx", "start": [291, 1], "end": [313, 36], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.processConstructors", "code": "def processConstructors (ref : Syntax) (params : Nat) (altVarNames : Array AltVarNames := #[]) :\n    List\u03a3 Name \u2192 List\u03a3 RCasesPatt \u2192 MetaM (Array AltVarNames \u00d7 List\u03a3 (Name \u00d7 List\u03a0 RCasesPatt))\n  | [], _ => pure (altVarNames, [])\n  | c :: cs, ps => do\n    let info := (\u2190 getFunInfo (\u2190 mkConstWithLevelParams c)).paramInfo\n    let p := ps.headD default\n    let t := ps.tailD []\n    let ((explicit, h), t) := match cs, t with\n    | [], _ :: _ => ((false, [RCasesPatt.alts ref ps]), [])\n    | _,  _      => (p.asTuple, t)\n    let (ns, ps) := processConstructor p.ref info explicit params h\n    let (altVarNames, r) \u2190 processConstructors ref params (altVarNames.push \u27e8true, ns\u27e9) cs t\n    pure (altVarNames, (c, ps) :: r)", "start": [315, 1], "end": [333, 37], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.subst'", "code": "def subst' (goal : MVarId) (hFVarId : FVarId)\n  (fvarSubst : FVarSubst := {}) : MetaM (FVarSubst \u00d7 MVarId) := do\n  let hLocalDecl \u2190 hFVarId.getDecl\n  let error {\u03b1} _ : MetaM \u03b1 := throwTacticEx `subst goal\n    m!\"invalid equality proof, it is not of the form (x = t) or (t = x){indentExpr hLocalDecl.type}\"\n  let some (_, lhs, rhs) \u2190 matchEq? hLocalDecl.type | error ()\n  let substReduced (newType : Expr) (symm : Bool) : MetaM (FVarSubst \u00d7 MVarId) := do\n    let goal \u2190 goal.assert hLocalDecl.userName newType (mkFVar hFVarId)\n    let (hFVarId', goal) \u2190 goal.intro1P\n    let goal \u2190 goal.clear hFVarId\n    substCore goal hFVarId' (symm := symm) (tryToSkip := true) (fvarSubst := fvarSubst)\n  let rhs' \u2190 whnf rhs\n  if rhs'.isFVar then\n    if rhs != rhs' then\n      substReduced (\u2190 mkEq lhs rhs') true\n    else\n      substCore goal hFVarId (symm := true) (tryToSkip := true) (fvarSubst := fvarSubst)\n  else\n    let lhs' \u2190 whnf lhs\n    if lhs'.isFVar then\n      if lhs != lhs' then\n        substReduced (\u2190 mkEq lhs' rhs) false\n      else\n        substCore goal hFVarId (symm := false) (tryToSkip := true) (fvarSubst := fvarSubst)\n    else error ()", "start": [338, 1], "end": [363, 18], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.rcasesCore", "code": "partial def rcasesCore (g : MVarId) (fs : FVarSubst) (clears : Array FVarId) (e : Expr) (a : \u03b1)\n    (pat : RCasesPatt) (cont : MVarId \u2192 FVarSubst \u2192 Array FVarId \u2192 \u03b1 \u2192 TermElabM \u03b1) :\n    TermElabM \u03b1 := do\n  let asFVar : Expr \u2192 MetaM _\n    | .fvar e => pure e\n    | e => throwError \"rcases tactic failed: {e} is not a fvar\"\n  withRef pat.ref <| g.withContext do match pat with\n  | .one ref `rfl =>\n    Term.addTermInfo' ref (.mdata {} e)\n    let (fs, g) \u2190 subst' g (\u2190 asFVar (fs.apply e)) fs\n    cont g fs clears a\n  | .one ref _ =>\n    if e.isFVar then\n      Term.addLocalVarInfo ref e\n    cont g fs clears a\n  | .clear ref =>\n    Term.addTermInfo' ref (.mdata {} e)\n    cont g fs (if let .fvar e := e then clears.push e else clears) a\n  | .typed ref pat ty =>\n    Term.addTermInfo' ref (.mdata {} e)\n    let expected \u2190 Term.elabType ty\n    let e := fs.apply e\n    let etype \u2190 inferType e\n    unless \u2190 isDefEq etype expected do\n      Term.throwTypeMismatchError \"rcases: scrutinee\" expected etype e\n    let g \u2190 if let .fvar e := e then g.replaceLocalDeclDefEq e expected else pure g\n    rcasesCore g fs clears e a pat cont\n  | .paren ref p\n  | .alts ref [p] =>\n    Term.addTermInfo' ref (.mdata {} e)\n    rcasesCore g fs clears e a p cont\n  | _ =>\n    Term.addTermInfo' pat.ref (.mdata {} e)\n    let e := fs.apply e\n    let _ \u2190 asFVar e\n    Term.synthesizeSyntheticMVarsNoPostponing\n    let type \u2190 whnfD (\u2190 inferType e)\n    let failK {\u03b1} _ : TermElabM \u03b1 :=\n      throwError \"rcases tactic failed: {e} : {type} is not an inductive datatype\"\n    let (r, subgoals) \u2190 matchConst type.getAppFn failK fun\n      | ConstantInfo.quotInfo info, _ => do\n        unless info.kind matches QuotKind.type do failK ()\n        let pat := pat.asAlts.headD default\n        let (explicit, pat\u2081) := pat.asTuple\n        let ([x], ps) := processConstructor pat.ref #[{}] explicit 0 pat\u2081 | unreachable!\n        let (vars, g) \u2190 g.revert (\u2190 getFVarsToGeneralize #[e])\n        g.withContext do\n          let elimInfo \u2190 getElimInfo `Quot.ind\n          let res \u2190 ElimApp.mkElimApp elimInfo #[e] (\u2190 g.getTag)\n          let elimArgs := res.elimApp.getAppArgs\n          ElimApp.setMotiveArg g elimArgs[elimInfo.motivePos]!.mvarId! #[e.fvarId!]\n          g.assign res.elimApp\n          let #[{ name := n, mvarId := g, .. }] := res.alts | unreachable!\n          let (v, g) \u2190 g.intro x\n          let (varsOut, g) \u2190 g.introNP vars.size\n          let fs' := (vars.zip varsOut).foldl (init := fs) fun fs (v, w) => fs.insert v (mkFVar w)\n          pure ([(n, ps)], #[\u27e8\u27e8g, #[mkFVar v], fs'\u27e9, n\u27e9])\n      | ConstantInfo.inductInfo info, _ => do\n        let (altVarNames, r) \u2190 processConstructors pat.ref info.numParams #[] info.ctors pat.asAlts\n        (r, \u00b7) <$> g.cases e.fvarId! altVarNames\n      | _, _ => failK ()\n    (\u00b7.2) <$> subgoals.foldlM (init := (r, a)) fun (r, a) \u27e8goal, ctorName\u27e9 => do\n      let rec\n      \n      align : List\u03a0 (Name \u00d7 List\u03a0 RCasesPatt) \u2192 TermElabM (List\u03a0 (Name \u00d7 List\u03a0 RCasesPatt) \u00d7 \u03b1)\n      | [] => pure ([], a)\n      | (tgt, ps) :: as => do\n        if tgt == ctorName then\n          let fs := fs.append goal.subst\n          (as, \u00b7) <$> rcasesContinue goal.mvarId fs clears a (ps.zip goal.fields.toList) cont\n        else\n          align as\n      align r", "start": [367, 1], "end": [456, 14], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.rcasesContinue", "code": "partial def rcasesContinue (g : MVarId) (fs : FVarSubst) (clears : Array FVarId) (a : \u03b1)\n  (pats : List\u03a0 (RCasesPatt \u00d7 Expr)) (cont : MVarId \u2192 FVarSubst \u2192 Array FVarId \u2192 \u03b1 \u2192 TermElabM \u03b1) :\n  TermElabM \u03b1 :=\n  match pats with\n  | []  => cont g fs clears a\n  | ((pat, e) :: ps) =>\n    rcasesCore g fs clears e a pat fun g fs clears a =>\n      rcasesContinue g fs clears a ps cont", "start": [458, 1], "end": [472, 43], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.tryClearMany'", "code": "def tryClearMany' (goal : MVarId) (fvarIds : Array FVarId) : MetaM MVarId := do\n  let mut toErase := fvarIds\n  for localDecl in (\u2190 goal.getDecl).lctx do\n    if \u2190 findLocalDeclDependsOn localDecl toErase.contains then\n      toErase := toErase.push localDecl.fvarId\n  goal.tryClearMany toErase", "start": [476, 1], "end": [482, 28], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.finish", "code": "def finish (g : MVarId) (fs : FVarSubst) (clears : Array FVarId)\n  (gs : Array MVarId) : TermElabM (Array MVarId) := do\n  let cs : Array Expr := (clears.map fs.get).filter Expr.isFVar\n  gs.push <$> tryClearMany' g (cs.map Expr.fvarId!)", "start": [484, 1], "end": [492, 52], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.RCasesPatt.parse", "code": "partial def RCasesPatt.parse (stx : Syntax) : MetaM RCasesPatt :=\n  match stx with\n  | `(rcasesPatMed| $ps:rcasesPat|*) => return .alts' stx (\u2190 ps.getElems.toList.mapM (parse \u00b7.raw))\n  | `(rcasesPatLo| $pat:rcasesPatMed : $t:term) => return .typed stx (\u2190 parse pat) t\n  | `(rcasesPatLo| $pat:rcasesPatMed) => parse pat\n  | `(rcasesPat| _) => return .one stx `_\n  | `(rcasesPat| $h:ident) => return .one h h.getId\n  | `(rcasesPat| -) => return .clear stx\n  | `(rcasesPat| @$pat) => return .explicit stx (\u2190 parse pat)\n  | `(rcasesPat| \u27e8$ps,*\u27e9) => return .tuple stx (\u2190 ps.getElems.toList.mapM (parse \u00b7.raw))\n  | `(rcasesPat| ($pat)) => return .paren stx (\u2190 parse pat)\n  | _ => throwUnsupportedSyntax", "start": [496, 1], "end": [508, 32], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.generalizeExceptFVar", "code": "def generalizeExceptFVar (goal : MVarId) (args : Array GeneralizeArg) :\n    MetaM (Array Expr \u00d7 MVarId) := do\n  let argsToGeneralize := args.filter fun arg => !(arg.expr.isFVar && arg.hName?.isNone)\n  let (fvarIdsNew, goal) \u2190 goal.generalize argsToGeneralize\n  let mut result := #[]\n  let mut j := 0\n  for arg in args do\n    if arg.expr.isFVar && arg.hName?.isNone then\n      result := result.push arg.expr\n    else\n      result := result.push (mkFVar fvarIdsNew[j]!)\n      j := j+1\n  pure (result, goal)", "start": [511, 1], "end": [524, 22], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.rcases", "code": "def rcases (tgts : Array (Option Name \u00d7 Syntax))\n  (pat : RCasesPatt) (g : MVarId) : TermElabM (List MVarId) := do\n  let pats \u2190 match tgts.size with\n  | 0 => return [g]\n  | 1 => pure [pat]\n  | _ => pure (processConstructor pat.ref (tgts.map fun _ => {}) false 0 pat.asTuple.2).2\n  let (pats, args) := Array.unzip <|\u2190 (tgts.zip pats.toArray).mapM fun ((hName?, tgt), pat) => do\n    let (pat, ty) \u2190 match pat with\n    | .typed ref pat ty => withRef ref do\n      let ty \u2190 Term.elabType ty\n      pure (.typed ref pat (\u2190 Term.exprToSyntax ty), some ty)\n    | _ => pure (pat, none)\n    let expr \u2190 Term.ensureHasType ty (\u2190 Term.elabTerm tgt ty)\n    pure (pat, { expr, xName? := pat.name?, hName? : GeneralizeArg })\n  let (vs, g) \u2190 generalizeExceptFVar g args\n  let gs \u2190 rcasesContinue g {} #[] #[] (pats.zip vs).toList finish\n  pure gs.toList", "start": [526, 1], "end": [546, 17], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.obtainNone", "code": "def obtainNone (pat : RCasesPatt) (ty : Syntax) (g : MVarId) : TermElabM (List MVarId) := do\n  let ty \u2190 Term.elabType ty\n  let g\u2081 \u2190 mkFreshExprMVar (some ty)\n  let (v, g\u2082) \u2190 (\u2190 g.assert (pat.name?.getD default) ty g\u2081).intro1\n  let gs \u2190 rcasesCore g\u2082 {} #[] (.fvar v) #[] pat finish\n  pure (g\u2081.mvarId! :: gs.toList)", "start": [548, 1], "end": [558, 33], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.expandRIntroPat", "code": "partial def expandRIntroPat (pat : TSyntax `rintroPat)\n    (acc : Array (TSyntax `rcasesPat) := #[]) (ty? : Option Term := none) :\n    Array (TSyntax `rcasesPat) :=\n  match pat with\n  | `(rintroPat| $p:rcasesPat) => match ty? with\n    | some ty => acc.push <| Unhygienic.run <| withRef p `(rcasesPat| ($p:rcasesPat : $ty))\n    | none => acc.push p\n  | `(rintroPat| ($(pats)* $[: $ty?']?)) => expandRIntroPats pats acc (ty?' <|> ty?)\n  | _ => acc", "start": [563, 1], "end": [572, 13], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.expandRIntroPats", "code": "partial def expandRIntroPats (pats : Array (TSyntax `rintroPat))\n    (acc : Array (TSyntax `rcasesPat) := #[]) (ty? : Option Term := none) :\n    Array (TSyntax `rcasesPat) :=\n  pats.foldl (fun acc p => expandRIntroPat p acc ty?) acc", "start": [574, 1], "end": [578, 58], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.rintroCore", "code": "partial def rintroCore (g : MVarId) (fs : FVarSubst) (clears : Array FVarId) (a : \u03b1)\n  (ref : Syntax) (pat : TSyntax `rintroPat) (ty? : Option Term)\n  (cont : MVarId \u2192 FVarSubst \u2192 Array FVarId \u2192 \u03b1 \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  match pat with\n  | `(rintroPat| $pat:rcasesPat) =>\n    let pat := (\u2190 RCasesPatt.parse pat).typed? ref ty?\n    let (v, g) \u2190 g.intro (pat.name?.getD `_)\n    rcasesCore g fs clears (.fvar v) a pat cont\n  | `(rintroPat| ($(pats)* $[: $ty?']?)) =>\n    let ref := if pats.size == 1 then pat.raw else .missing\n    rintroContinue g fs clears ref pats (ty?' <|> ty?) a cont\n  | _ => throwUnsupportedSyntax", "start": [584, 1], "end": [599, 32], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.rintroContinue", "code": "partial def rintroContinue (g : MVarId) (fs : FVarSubst) (clears : Array FVarId)\n  (ref : Syntax) (pats : TSyntaxArray `rintroPat) (ty? : Option Term) (a : \u03b1)\n  (cont : MVarId \u2192 FVarSubst \u2192 Array FVarId \u2192 \u03b1 \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  g.withContext (loop 0 g fs clears a)\nwhere\n  \n  loop i g fs clears a := do\n    if h : i < pats.size then\n      rintroCore g fs clears a ref (pats.get \u27e8i, h\u27e9) ty? (loop (i+1))\n    else cont g fs clears a", "start": [601, 1], "end": [614, 28], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.RCases.rintro", "code": "def rintro (pats : TSyntaxArray `rintroPat) (ty? : Option Term)\n  (g : MVarId) : TermElabM (List MVarId) :=\n  (\u00b7.toList) <$> rintroContinue g {} #[] .missing pats ty? #[] finish", "start": [618, 1], "end": [624, 70], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/HaveI.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.haveI", "code": "@[term_parser] def \u00abhaveI\u00bb := leading_parser\n  withPosition (\"haveI \" >> haveDecl) >> optSemicolon termParser", "start": [19, 1], "end": [21, 65], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.letI", "code": "@[term_parser] def \u00abletI\u00bb := leading_parser\n  withPosition (\"letI \" >> haveDecl) >> optSemicolon termParser", "start": [22, 1], "end": [24, 64], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Classes/LawfulMonad.lean", "imports": ["lake-packages/std/Std/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LawfulMonad.mk'", "code": "theorem LawfulMonad.mk' (m : Type u \u2192 Type v) [Monad m]\n    (id_map : \u2200 {\u03b1} (x : m \u03b1), id <$> x = x)\n    (pure_bind : \u2200 {\u03b1 \u03b2} (x : \u03b1) (f : \u03b1 \u2192 m \u03b2), pure x >>= f = f x)\n    (bind_assoc : \u2200 {\u03b1 \u03b2 \u03b3} (x : m \u03b1) (f : \u03b1 \u2192 m \u03b2) (g : \u03b2 \u2192 m \u03b3),\n      x >>= f >>= g = x >>= fun x => f x >>= g)\n    (map_const : \u2200 {\u03b1 \u03b2} (x : \u03b1) (y : m \u03b2),\n      Functor.mapConst x y = Function.const \u03b2 x <$> y := by intros; rfl)\n    (seqLeft_eq : \u2200 {\u03b1 \u03b2} (x : m \u03b1) (y : m \u03b2),\n      x <* y = (x >>= fun a => y >>= fun _ => pure a) := by intros; rfl)\n    (seqRight_eq : \u2200 {\u03b1 \u03b2} (x : m \u03b1) (y : m \u03b2), x *> y = (x >>= fun _ => y) := by intros; rfl)\n    (bind_pure_comp : \u2200 {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (x : m \u03b1),\n      x >>= (fun y => pure (f y)) = f <$> x := by intros; rfl)\n    (bind_map : \u2200 {\u03b1 \u03b2} (f : m (\u03b1 \u2192 \u03b2)) (x : m \u03b1), f >>= (. <$> x) = f <*> x := by intros; rfl)\n    : LawfulMonad m", "start": [8, 1], "end": [36, 93], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM", "code": "def SatisfiesM {m : Type u \u2192 Type v} [Functor m] (p : \u03b1 \u2192 Prop) (x : m \u03b1) : Prop :=\n  \u2203 x' : m {a // p a}, Subtype.val <$> x' = x", "start": [64, 1], "end": [70, 46], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.of_true", "code": "theorem of_true [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (h : \u2200 a, p a) : SatisfiesM p x", "start": [74, 1], "end": [77, 67], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.trivial", "code": "protected theorem trivial [Applicative m] [LawfulApplicative m] {x : m \u03b1} :\n  SatisfiesM (fun _ => True) x", "start": [79, 1], "end": [84, 59], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.imp", "code": "theorem imp [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (h : SatisfiesM p x) (H : \u2200 {a}, p a \u2192 q a) : SatisfiesM q x", "start": [86, 1], "end": [89, 82], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.map", "code": "protected theorem map [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (hx : SatisfiesM p x) (hf : \u2200 {a}, p a \u2192 q (f a)) : SatisfiesM q (f <$> x)", "start": [91, 1], "end": [96, 46], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.map_post", "code": "theorem map_post [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (hx : SatisfiesM p x) : SatisfiesM (fun b => \u2203 a, p a \u2227 b = f a) (f <$> x)", "start": [98, 1], "end": [104, 30], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.map_pre", "code": "theorem map_pre [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (hx : SatisfiesM (fun a => p (f a)) x) : SatisfiesM p (f <$> x)", "start": [106, 1], "end": [112, 20], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.mapConst", "code": "protected theorem mapConst [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (hx : SatisfiesM q x) (ha : \u2200 {b}, q b \u2192 p a) : SatisfiesM p (Functor.mapConst a x)", "start": [114, 1], "end": [117, 33], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.pure", "code": "protected theorem pure [Applicative m] [LawfulApplicative m]\n    (h : p a) : SatisfiesM (m := m) p (pure a)", "start": [119, 1], "end": [121, 73], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.seq", "code": "protected theorem seq [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hf : SatisfiesM p\u2081 f) (hx : SatisfiesM p\u2082 x)\n    (H : \u2200 {f a}, p\u2081 f \u2192 p\u2082 a \u2192 q (f a)) : SatisfiesM q (f <*> x)", "start": [123, 1], "end": [130, 58], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.seq_post", "code": "protected theorem seq_post [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hf : SatisfiesM p\u2081 f) (hx : SatisfiesM p\u2082 x) :\n    SatisfiesM (fun c => \u2203 f a, p\u2081 f \u2227 p\u2082 a \u2227 c = f a) (f <*> x)", "start": [132, 1], "end": [136, 46], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.seq_pre", "code": "protected theorem seq_pre [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hf : SatisfiesM (fun f => \u2200 {a}, p\u2082 a \u2192 q (f a)) f) (hx : SatisfiesM p\u2082 x) :\n    SatisfiesM q (f <*> x)", "start": [138, 1], "end": [145, 31], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.seq_pre'", "code": "protected theorem seq_pre' [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hf : SatisfiesM p\u2081 f) (hx : SatisfiesM (fun a => \u2200 {f}, p\u2081 f \u2192 q (f a)) x) :\n    SatisfiesM q (f <*> x)", "start": [147, 1], "end": [154, 31], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.seqLeft", "code": "protected theorem seqLeft [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hx : SatisfiesM p\u2081 x) (hy : SatisfiesM p\u2082 y)\n    (H : \u2200 {a b}, p\u2081 a \u2192 p\u2082 b \u2192 q a) : SatisfiesM q (x <* y)", "start": [156, 1], "end": [160, 54], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.seqRight", "code": "protected theorem seqRight [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hx : SatisfiesM p\u2081 x) (hy : SatisfiesM p\u2082 y)\n    (H : \u2200 {a b}, p\u2081 a \u2192 p\u2082 b \u2192 q b) : SatisfiesM q (x *> y)", "start": [162, 1], "end": [166, 55], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.bind", "code": "protected theorem bind [Monad m] [LawfulMonad m] {f : \u03b1 \u2192 m \u03b2}\n    (hx : SatisfiesM p x) (hf : \u2200 a, p a \u2192 SatisfiesM q (f a)) :\n    SatisfiesM q (x >>= f)", "start": [168, 1], "end": [175, 86], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM.bind_pre", "code": "protected theorem bind_pre [Monad m] [LawfulMonad m] {f : \u03b1 \u2192 m \u03b2}\n    (hx : SatisfiesM (fun a => SatisfiesM q (f a)) x) :\n    SatisfiesM q (x >>= f)", "start": [177, 1], "end": [180, 51], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM_Id_eq", "code": "@[simp] theorem SatisfiesM_Id_eq : SatisfiesM (m := Id) p x \u2194 p x", "start": [184, 1], "end": [185, 52], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM_Option_eq", "code": "@[simp] theorem SatisfiesM_Option_eq : SatisfiesM (m := Option) p x \u2194 \u2200 a, x = some a \u2192 p a", "start": [187, 1], "end": [189, 85], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM_Except_eq", "code": "@[simp] theorem SatisfiesM_Except_eq : SatisfiesM (m := Except \u03b5) p x \u2194 \u2200 a, x = .ok a \u2192 p a", "start": [191, 1], "end": [193, 91], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM_ReaderT_eq", "code": "@[simp] theorem SatisfiesM_ReaderT_eq [Monad m] :\n    SatisfiesM (m := ReaderT \u03c1 m) p x \u2194 \u2200 s, SatisfiesM p (x s)", "start": [195, 1], "end": [197, 94], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM_StateRefT_eq", "code": "theorem SatisfiesM_StateRefT_eq [Monad m] :\n    SatisfiesM (m := StateRefT' \u03c9 \u03c3 m) p x \u2194 \u2200 s, SatisfiesM p (x s)", "start": [199, 1], "end": [200, 80], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM_StateT_eq", "code": "@[simp] theorem SatisfiesM_StateT_eq [Monad m] [LawfulMonad m] :\n    SatisfiesM (m := StateT \u03c1 m) (\u03b1 := \u03b1) p x \u2194 \u2200 s, SatisfiesM (m := m) (p \u00b7.1) (x s)", "start": [202, 1], "end": [208, 51], "kind": "commanddeclaration"}, {"full_name": "SatisfiesM_ExceptT_eq", "code": "@[simp] theorem SatisfiesM_ExceptT_eq [Monad m] [LawfulMonad m] :\n    SatisfiesM (m := ExceptT \u03c1 m) (\u03b1 := \u03b1) p x \u2194 SatisfiesM (m := m) (\u2200 a, \u00b7 = .ok a \u2192 p a) x", "start": [210, 1], "end": [216, 97], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Classes/SetNotation.lean", "imports": ["lake-packages/std/Std/Util/ExtendedBinder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasSubset", "code": "class HasSubset (\u03b1 : Type u) where\n  \n  Subset : \u03b1 \u2192 \u03b1 \u2192 Prop", "start": [8, 1], "end": [11, 24], "kind": "commanddeclaration"}, {"full_name": "HasSSubset", "code": "class HasSSubset (\u03b1 : Type u) where\n  \n  SSubset : \u03b1 \u2192 \u03b1 \u2192 Prop", "start": [17, 1], "end": [20, 25], "kind": "commanddeclaration"}, {"full_name": "Superset", "code": "abbrev Superset [HasSubset \u03b1] (a b : \u03b1) := b \u2286 a", "start": [26, 1], "end": [27, 49], "kind": "commanddeclaration"}, {"full_name": "SSuperset", "code": "abbrev SSuperset [HasSSubset \u03b1] (a b : \u03b1) := b \u2282 a", "start": [31, 1], "end": [32, 51], "kind": "commanddeclaration"}, {"full_name": "Union", "code": "class Union (\u03b1 : Type u) where\n  \n  union : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [36, 1], "end": [39, 20], "kind": "commanddeclaration"}, {"full_name": "Inter", "code": "class Inter (\u03b1 : Type u) where\n  \n  inter : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [43, 1], "end": [46, 20], "kind": "commanddeclaration"}, {"full_name": "SDiff", "code": "class SDiff (\u03b1 : Type u) where\n  \n  sdiff : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [50, 1], "end": [56, 20], "kind": "commanddeclaration"}, {"full_name": "Insert", "code": "class Insert (\u03b1 : outParam <| Type u) (\u03b3 : Type v) where\n  \n  insert : \u03b1 \u2192 \u03b3 \u2192 \u03b3", "start": [63, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "Singleton", "code": "class Singleton (\u03b1 : outParam <| Type u) (\u03b2 : Type v) where\n  \n  singleton : \u03b1 \u2192 \u03b2", "start": [72, 1], "end": [78, 20], "kind": "commanddeclaration"}, {"full_name": "Sep", "code": "class Sep (\u03b1 : outParam <| Type u) (\u03b3 : Type v) where\n  \n  sep : (\u03b1 \u2192 Prop) \u2192 \u03b3 \u2192 \u03b3", "start": [81, 1], "end": [84, 27], "kind": "commanddeclaration"}, {"full_name": "singletonUnexpander", "code": "@[app_unexpander singleton]\ndef singletonUnexpander : Lean.PrettyPrinter.Unexpander\n  | `($_ $a) => `({ $a:term })\n  | _ => throw ()", "start": [100, 1], "end": [104, 18], "kind": "commanddeclaration"}, {"full_name": "insertUnexpander", "code": "@[app_unexpander insert]\ndef insertUnexpander : Lean.PrettyPrinter.Unexpander\n  | `($_ $a { $ts:term,* }) => `({$a:term, $ts,*})\n  | _ => throw ()", "start": [106, 1], "end": [110, 18], "kind": "commanddeclaration"}, {"full_name": "IsLawfulSingleton", "code": "class IsLawfulSingleton (\u03b1 : Type u) (\u03b2 : Type v) [EmptyCollection \u03b2] [Insert \u03b1 \u03b2] [Singleton \u03b1 \u03b2] :\n    Prop where\n  \n  insert_emptyc_eq (x : \u03b1) : (insert x \u2205 : \u03b2) = {x}", "start": [112, 1], "end": [116, 52], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpM.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Bind.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ImplementedByAttr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Renaming.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/FunDeclInfo.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/JpCases.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/AlphaEqv.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Internalize.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Config.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ElimDead.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/DiscrM.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.Context", "code": "structure Context where\n  \n  declName : Name\n  config : Config := {}\n  \n  inlineStack : List Name := []\n  \n  inlineStackOccs : PHashMap Name Nat := {}", "start": [21, 1], "end": [36, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.State", "code": "structure State where\n  \n  subst : FVarSubst := {}\n  \n  used : UsedLocalDecls := {}\n  \n  binderRenaming : Renaming := {}\n  \n  funDeclInfoMap : FunDeclInfoMap := {}\n  \n  simplified : Bool := false\n  \n  visited : Nat := 0\n  \n  inline : Nat := 0\n  \n  inlineLocal : Nat := 0", "start": [38, 1], "end": [74, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.SimpM", "code": "abbrev SimpM := ReaderT Context $ StateRefT State DiscrM", "start": [76, 1], "end": [76, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.markSimplified", "code": "def markSimplified : SimpM Unit :=\n  modify fun s => { s with simplified := true }", "start": [87, 1], "end": [89, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.incVisited", "code": "def incVisited : SimpM Unit :=\n  modify fun s => { s with visited := s.visited + 1 }", "start": [91, 1], "end": [93, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.incInline", "code": "def incInline : SimpM Unit :=\n  modify fun s => { s with inline := s.inline + 1 }", "start": [95, 1], "end": [97, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.incInlineLocal", "code": "def incInlineLocal : SimpM Unit :=\n  modify fun s => { s with inlineLocal := s.inlineLocal + 1 }", "start": [99, 1], "end": [101, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.addMustInline", "code": "def addMustInline (fvarId : FVarId) : SimpM Unit :=\n  modify fun s => { s with funDeclInfoMap := s.funDeclInfoMap.addMustInline fvarId }", "start": [103, 1], "end": [105, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.addFunOcc", "code": "def addFunOcc (fvarId : FVarId) : SimpM Unit :=\n  modify fun s => { s with funDeclInfoMap := s.funDeclInfoMap.add fvarId }", "start": [107, 1], "end": [109, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.addFunHoOcc", "code": "def addFunHoOcc (fvarId : FVarId) : SimpM Unit :=\n  modify fun s => { s with funDeclInfoMap := s.funDeclInfoMap.addHo fvarId }", "start": [111, 1], "end": [113, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.updateFunDeclInfo", "code": "@[inherit_doc FunDeclInfoMap.update]\npartial def updateFunDeclInfo (code : Code) (mustInline := false) : SimpM Unit := do\n  let map \u2190 modifyGet fun s => (s.funDeclInfoMap, { s with funDeclInfoMap := {} })\n  let map \u2190 map.update code mustInline\n  modify fun s => { s with funDeclInfoMap := map }", "start": [115, 1], "end": [119, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.withInlining", "code": "@[inline] def withInlining (value : LetValue) (recursive : Bool) (x : SimpM \u03b1) : SimpM \u03b1 := do\n  if let .const declName _ _ := value then\n    let numOccs \u2190 check declName\n    withReader (fun ctx => { ctx with inlineStack := declName :: ctx.inlineStack, inlineStackOccs := ctx.inlineStackOccs.insert declName numOccs }) x\n  else\n    x\nwhere\n  check (declName : Name) : SimpM Nat := do\n    trace[Compiler.simp.inline] \"{declName}\"\n    let numOccs := (\u2190 read).inlineStackOccs.find? declName |>.getD 0\n    let numOccs := numOccs + 1\n    let inlineIfReduce \u2190 if let some decl \u2190 getDecl? declName then pure decl.inlineIfReduceAttr else pure false\n    if recursive && inlineIfReduce && numOccs > (\u2190 getConfig).maxRecInlineIfReduce then\n      throwError \"function `{declName}` has been recursively inlined more than #{(\u2190 getConfig).maxRecInlineIfReduce}, consider removing the attribute `[inline_if_reduce]` from this declaration or increasing the limit using `set_option compiler.maxRecInlineIfReduce <num>`\"\n    return numOccs", "start": [121, 1], "end": [139, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.withIncRecDepth", "code": "@[inline] def withIncRecDepth (x : SimpM \u03b1) : SimpM \u03b1 := do\n  let curr \u2190 MonadRecDepth.getRecDepth\n  let max  \u2190 MonadRecDepth.getMaxRecDepth\n  if curr == max then\n    throwMaxRecDepth\n  else\n    MonadRecDepth.withRecDepth (curr+1) x\nwhere\n  throwMaxRecDepth : SimpM \u03b1 := do\n    match (\u2190 read).inlineStack with\n    | [] => throwError maxRecDepthErrorMessage\n    | declName :: stack =>\n      let mut fmt  := f!\"{declName}\\n\"\n      let mut prev := declName\n      let mut ellipsis := false\n      for declName in stack do\n        if prev == declName then\n          unless ellipsis do\n            ellipsis := true\n            fmt := fmt ++ \"...\\n\"\n        else\n          fmt := fmt ++ f!\"{declName}\\n\"\n          prev := declName\n          ellipsis := false\n      throwError \"maximum recursion depth reached in the code generator\\nfunction inline stack:\\n{fmt}\"", "start": [141, 1], "end": [168, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.withAddMustInline", "code": "def withAddMustInline (fvarId : FVarId) (x : SimpM \u03b1) : SimpM \u03b1 := do\n  let saved? := (\u2190 get).funDeclInfoMap.map.find? fvarId\n  try\n    addMustInline fvarId\n    x\n  finally\n    modify fun s => { s with funDeclInfoMap := s.funDeclInfoMap.restore fvarId saved? }", "start": [170, 1], "end": [180, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.isOnceOrMustInline", "code": "def isOnceOrMustInline (fvarId : FVarId) : SimpM Bool := do\n  match (\u2190 get).funDeclInfoMap.map.find? fvarId with\n    | some .once | some .mustInline  => return true\n    | _ => return false", "start": [182, 1], "end": [189, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.isSmall", "code": "def isSmall (code : Code) : SimpM Bool :=\n  return code.sizeLe (\u2190 getConfig).smallThreshold", "start": [191, 1], "end": [195, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.shouldInlineLocal", "code": "def shouldInlineLocal (decl : FunDecl) : SimpM Bool := do\n  if (\u2190 isOnceOrMustInline decl.fvarId) then\n    return true\n  else\n    isSmall decl.value", "start": [197, 1], "end": [204, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.betaReduce", "code": "def betaReduce (params : Array Param) (code : Code) (args : Array Arg) (mustInline := false) : SimpM Code := do\n  let mut subst := {}\n  for param in params, arg in args do\n    subst := subst.insert param.fvarId arg.toExpr\n  let code \u2190 code.internalize subst\n  updateFunDeclInfo code mustInline\n  return code", "start": [206, 1], "end": [217, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.eraseLetDecl", "code": "def eraseLetDecl (decl : LetDecl) : SimpM Unit := do\n  LCNF.eraseLetDecl decl\n  markSimplified", "start": [219, 1], "end": [225, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.eraseFunDecl", "code": "def eraseFunDecl (decl : FunDecl) : SimpM Unit := do\n  LCNF.eraseFunDecl decl\n  markSimplified", "start": [227, 1], "end": [233, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.addFVarSubst", "code": "def addFVarSubst (fvarId : FVarId) (fvarId' : FVarId) : SimpM Unit := do\n  LCNF.addFVarSubst fvarId fvarId'\n  let binderName \u2190 getBinderName fvarId\n  unless binderName.isInternal do\n    let binderName' \u2190 getBinderName fvarId'\n    if binderName'.isInternal then\n      modify fun s => { s with binderRenaming := s.binderRenaming.insert fvarId' binderName }", "start": [235, 1], "end": [248, 94], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/DeclUtil.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.forallTelescopeCompatibleAux", "code": "def forallTelescopeCompatibleAux {\u03b1} (k : Array Expr \u2192 Expr \u2192 Expr \u2192 MetaM \u03b1) : Nat \u2192 Expr \u2192 Expr \u2192 Array Expr \u2192 MetaM \u03b1\n  | 0, type\u2081, type\u2082, xs   => k xs type\u2081 type\u2082\n  | i+1, type\u2081, type\u2082, xs => do\n    let type\u2081 \u2190 whnf type\u2081\n    let type\u2082 \u2190 whnf type\u2082\n    match type\u2081, type\u2082 with\n    | Expr.forallE n\u2081 d\u2081 b\u2081 c\u2081, Expr.forallE n\u2082 d\u2082 b\u2082 c\u2082 =>\n      unless n\u2081 == n\u2082 do\n        throwError \"parameter name mismatch '{n\u2081}', expected '{n\u2082}'\"\n      unless (\u2190 isDefEq d\u2081 d\u2082) do\n        throwError \"parameter '{n\u2081}' {\u2190 mkHasTypeButIsExpectedMsg d\u2081 d\u2082}\"\n      unless c\u2081 == c\u2082 do\n        throwError \"binder annotation mismatch at parameter '{n\u2081}'\"\n      withLocalDecl n\u2081 c\u2081 d\u2081 fun x =>\n        let type\u2081 := b\u2081.instantiate1 x\n        let type\u2082 := b\u2082.instantiate1 x\n        forallTelescopeCompatibleAux k i type\u2081 type\u2082 (xs.push x)\n    | _, _ => throwError \"unexpected number of parameters\"", "start": [11, 1], "end": [28, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallTelescopeCompatible", "code": "def forallTelescopeCompatible {\u03b1 m} [Monad m] [MonadControlT MetaM m] (type\u2081 type\u2082 : Expr) (numParams : Nat) (k : Array Expr \u2192 Expr \u2192 Expr \u2192 m \u03b1) : m \u03b1 :=\n  controlAt MetaM fun runInBase =>\n    forallTelescopeCompatibleAux (fun xs type\u2081 type\u2082 => runInBase $ k xs type\u2081 type\u2082) numParams type\u2081 type\u2082 #[]", "start": [30, 1], "end": [34, 112], "kind": "commanddeclaration"}, {"full_name": "Elab.expandOptDeclSig", "code": "def expandOptDeclSig (stx : Syntax) : Syntax \u00d7 Option Syntax :=\n  let binders := stx[0]\n  let optType := stx[1] if optType.isNone then\n    (binders, none)\n  else\n    let typeSpec := optType[0]\n    (binders, some typeSpec[1])", "start": [40, 1], "end": [48, 32], "kind": "commanddeclaration"}, {"full_name": "Elab.expandDeclSig", "code": "def expandDeclSig (stx : Syntax) : Syntax \u00d7 Syntax :=\n  let binders  := stx[0]\n  let typeSpec := stx[1]\n  (binders, typeSpec[1])", "start": [50, 1], "end": [54, 25], "kind": "commanddeclaration"}, {"full_name": "Elab.mkFreshInstanceName", "code": "def mkFreshInstanceName (env : Environment) (nextIdx : Nat) : Name :=\n  (env.mainModule ++ `_instance).appendIndexAfter nextIdx", "start": [56, 1], "end": [57, 58], "kind": "commanddeclaration"}, {"full_name": "Elab.isFreshInstanceName", "code": "def isFreshInstanceName (name : Name) : Bool :=\n  match name with\n  | .str _ s => \"_instance\".isPrefixOf s\n  | _        => false", "start": [59, 1], "end": [62, 22], "kind": "commanddeclaration"}, {"full_name": "Elab.sortDeclLevelParams", "code": "def sortDeclLevelParams (scopeParams : List Name) (allUserParams : List Name) (usedParams : Array Name) : Except String (List Name) :=\n  match allUserParams.find? fun u => !usedParams.contains u && !scopeParams.elem u with\n  | some u => throw s!\"unused universe parameter '{u}'\"\n  | none   =>\n    let result := allUserParams.foldl (fun result levelName => if usedParams.elem levelName then levelName :: result else result) []\n    let remaining := usedParams.filter (fun levelParam => !allUserParams.elem levelParam)\n    let remaining := remaining.qsort Name.lt\n    pure $ result ++ remaining.toList", "start": [64, 1], "end": [82, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Ext/Attr.lean", "imports": ["lake-packages/std/Std/Lean/Command.lean", "lake-packages/std/Std/Tactic/RCases.lean", "lake-packages/std/Std/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.Ext.ExtTheorem", "code": "structure ExtTheorem where\n  \n  declName : Name\n  \n  priority : Nat\n  \n  keys : Array (DiscrTree.Key true)\n  deriving Inhabited, Repr, BEq, Hashable", "start": [16, 1], "end": [24, 42], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.ExtTheorems", "code": "structure ExtTheorems where\n  \n  tree   : DiscrTree ExtTheorem true := {}\n  \n  erased  : PHashSet Name := {}\n  deriving Inhabited", "start": [26, 1], "end": [32, 21], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.getExtLemmas", "code": "@[inline] def getExtLemmas (ty : Expr) : MetaM (Array ExtTheorem) := do\n  let extTheorems := extExtension.getState (\u2190 getEnv)\n  let arr \u2190 extTheorems.tree.getMatch ty\n  let erasedArr := arr.filter fun thm => !extTheorems.erased.contains thm.declName\n  return erasedArr.insertionSort (\u00b7.priority < \u00b7.priority) |>.reverse", "start": [43, 1], "end": [51, 70], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.ExtTheorems.eraseCore", "code": "def ExtTheorems.eraseCore (d : ExtTheorems) (declName : Name) : ExtTheorems :=\n { d with erased := d.erased.insert declName }", "start": [53, 1], "end": [56, 47], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.ExtTheorems.erase", "code": "def ExtTheorems.erase [Monad m] [MonadError m] (d : ExtTheorems) (declName : Name) :\n    m ExtTheorems := do\n  unless d.tree.values.any (\u00b7.declName == declName) && !d.erased.contains declName do\n    throwError \"'{declName}' does not have [ext] attribute\"\n  return d.eraseCore declName", "start": [58, 1], "end": [67, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Option/Init/Lemmas.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Option.getD_none", "code": "@[simp] theorem getD_none : getD none a = a", "start": [16, 1], "end": [16, 51], "kind": "commanddeclaration"}, {"full_name": "Option.getD_some", "code": "@[simp] theorem getD_some : getD (some a) b = a", "start": [17, 1], "end": [17, 55], "kind": "commanddeclaration"}, {"full_name": "Option.map_none'", "code": "@[simp] theorem map_none' (f : \u03b1 \u2192 \u03b2) : none.map f = none", "start": [19, 1], "end": [19, 65], "kind": "commanddeclaration"}, {"full_name": "Option.map_some'", "code": "@[simp] theorem map_some' (a) (f : \u03b1 \u2192 \u03b2) : (some a).map f = some (f a)", "start": [20, 1], "end": [20, 79], "kind": "commanddeclaration"}, {"full_name": "Option.none_bind", "code": "@[simp] theorem none_bind (f : \u03b1 \u2192 Option \u03b2) : none.bind f = none", "start": [22, 1], "end": [22, 73], "kind": "commanddeclaration"}, {"full_name": "Option.some_bind", "code": "@[simp] theorem some_bind (a) (f : \u03b1 \u2192 Option \u03b2) : (some a).bind f = f a", "start": [23, 1], "end": [23, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Array/Init/Lemmas.lean", "imports": ["lake-packages/std/Std/Classes/LawfulMonad.lean", "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "lake-packages/std/Std/Tactic/NoMatch.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/Array/Init/Basic.lean", "lake-packages/std/Std/Tactic/HaveI.lean"], "premises": [{"full_name": "Array.mkEmpty_eq", "code": "@[simp] theorem mkEmpty_eq (\u03b1 n) : @mkEmpty \u03b1 n = #[]", "start": [22, 1], "end": [22, 61], "kind": "commanddeclaration"}, {"full_name": "Array.size_toArray", "code": "@[simp] theorem size_toArray (as : List \u03b1) : as.toArray.size = as.length", "start": [24, 1], "end": [24, 91], "kind": "commanddeclaration"}, {"full_name": "Array.size_mk", "code": "@[simp] theorem size_mk (as : List \u03b1) : (Array.mk as).size = as.length", "start": [26, 1], "end": [26, 89], "kind": "commanddeclaration"}, {"full_name": "Array.getElem_eq_data_get", "code": "theorem getElem_eq_data_get (a : Array \u03b1) (h : i < a.size) : a[i] = a.data.get \u27e8i, h\u27e9", "start": [28, 1], "end": [29, 49], "kind": "commanddeclaration"}, {"full_name": "Array.foldlM_eq_foldlM_data.aux", "code": "theorem foldlM_eq_foldlM_data.aux [Monad m]\n    (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (arr : Array \u03b1) (i j) (H : arr.size \u2264 i + j) (b) :\n    foldlM.loop f arr arr.size (Nat.le_refl _) i j b = (arr.data.drop j).foldlM f b", "start": [31, 1], "end": [40, 57], "kind": "commanddeclaration"}, {"full_name": "Array.foldlM_eq_foldlM_data", "code": "theorem foldlM_eq_foldlM_data [Monad m]\n    (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (init : \u03b2) (arr : Array \u03b1) :\n    arr.foldlM f init = arr.data.foldlM f init", "start": [42, 1], "end": [45, 43], "kind": "commanddeclaration"}, {"full_name": "Array.foldl_eq_foldl_data", "code": "theorem foldl_eq_foldl_data (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (init : \u03b2) (arr : Array \u03b1) :\n    arr.foldl f init = arr.data.foldl f init", "start": [47, 1], "end": [49, 53], "kind": "commanddeclaration"}, {"full_name": "Array.foldrM_eq_reverse_foldlM_data.aux", "code": "theorem foldrM_eq_reverse_foldlM_data.aux [Monad m]\n    (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (arr : Array \u03b1) (init : \u03b2) (i h) :\n    (arr.data.take i).reverse.foldlM (fun x y => f y x) init = foldrM.fold f arr 0 i h init", "start": [51, 1], "end": [57, 76], "kind": "commanddeclaration"}, {"full_name": "Array.foldrM_eq_reverse_foldlM_data", "code": "theorem foldrM_eq_reverse_foldlM_data [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (init : \u03b2) (arr : Array \u03b1) :\n    arr.foldrM f init = arr.data.reverse.foldlM (fun x y => f y x) init", "start": [59, 1], "end": [64, 74], "kind": "commanddeclaration"}, {"full_name": "Array.foldrM_eq_foldrM_data", "code": "theorem foldrM_eq_foldrM_data [Monad m]\n    (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (init : \u03b2) (arr : Array \u03b1) :\n    arr.foldrM f init = arr.data.foldrM f init", "start": [66, 1], "end": [69, 58], "kind": "commanddeclaration"}, {"full_name": "Array.foldr_eq_foldr_data", "code": "theorem foldr_eq_foldr_data (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) (arr : Array \u03b1) :\n    arr.foldr f init = arr.data.foldr f init", "start": [71, 1], "end": [73, 53], "kind": "commanddeclaration"}, {"full_name": "Array.push_data", "code": "@[simp] theorem push_data (arr : Array \u03b1) (a : \u03b1) : (arr.push a).data = arr.data ++ [a]", "start": [75, 1], "end": [76, 37], "kind": "commanddeclaration"}, {"full_name": "Array.foldrM_push", "code": "theorem foldrM_push [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (init : \u03b2) (arr : Array \u03b1) (a : \u03b1) :\n    (arr.push a).foldrM f init = f a init >>= arr.foldrM f", "start": [78, 1], "end": [80, 51], "kind": "commanddeclaration"}, {"full_name": "Array.foldrM_push'", "code": "@[simp] theorem foldrM_push' [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (init : \u03b2) (arr : Array \u03b1) (a : \u03b1) :\n    (arr.push a).foldrM f init (start := arr.size + 1) = f a init >>= arr.foldrM f", "start": [82, 1], "end": [84, 23], "kind": "commanddeclaration"}, {"full_name": "Array.foldr_push", "code": "theorem foldr_push (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) (arr : Array \u03b1) (a : \u03b1) :\n    (arr.push a).foldr f init = arr.foldr f (f a init)", "start": [86, 1], "end": [87, 73], "kind": "commanddeclaration"}, {"full_name": "Array.foldr_push'", "code": "@[simp] theorem foldr_push' (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) (arr : Array \u03b1) (a : \u03b1) :\n    (arr.push a).foldr f init (start := arr.size + 1) = arr.foldr f (f a init)", "start": [89, 1], "end": [90, 98], "kind": "commanddeclaration"}, {"full_name": "Array.toListAppend_eq", "code": "@[simp] theorem toListAppend_eq (arr : Array \u03b1) (l) : arr.toListAppend l = arr.data ++ l", "start": [92, 1], "end": [93, 43], "kind": "commanddeclaration"}, {"full_name": "Array.toList_eq", "code": "@[simp] theorem toList_eq (arr : Array \u03b1) : arr.toList = arr.data", "start": [95, 1], "end": [96, 37], "kind": "commanddeclaration"}, {"full_name": "Array.toListRev", "code": "@[inline] def toListRev (arr : Array \u03b1) : List \u03b1 := arr.foldl (fun l t => t :: l) []", "start": [98, 1], "end": [99, 85], "kind": "commanddeclaration"}, {"full_name": "Array.toListRev_eq", "code": "@[simp] theorem toListRev_eq (arr : Array \u03b1) : arr.toListRev = arr.data.reverse", "start": [101, 1], "end": [102, 77], "kind": "commanddeclaration"}, {"full_name": "Array.SatisfiesM_foldlM", "code": "theorem SatisfiesM_foldlM [Monad m] [LawfulMonad m]\n    {as : Array \u03b1} (motive : Nat \u2192 \u03b2 \u2192 Prop) {init : \u03b2} (h0 : motive 0 init) {f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2}\n    (hf : \u2200 i : Fin as.size, \u2200 b, motive i.1 b \u2192 SatisfiesM (motive (i.1 + 1)) (f b as[i])) :\n    SatisfiesM (motive as.size) (as.foldlM f init)", "start": [104, 1], "end": [116, 61], "kind": "commanddeclaration"}, {"full_name": "Array.foldl_induction", "code": "theorem foldl_induction\n    {as : Array \u03b1} (motive : Nat \u2192 \u03b2 \u2192 Prop) {init : \u03b2} (h0 : motive 0 init) {f : \u03b2 \u2192 \u03b1 \u2192 \u03b2}\n    (hf : \u2200 i : Fin as.size, \u2200 b, motive i.1 b \u2192 motive (i.1 + 1) (f b as[i])) :\n    motive as.size (as.foldl f init)", "start": [118, 1], "end": [124, 16], "kind": "commanddeclaration"}, {"full_name": "Array.get_push_lt", "code": "theorem get_push_lt (a : Array \u03b1) (x : \u03b1) (i : Nat) (h : i < a.size) :\n    haveI : i < (a.push x).size := by simp [*, Nat.lt_succ_of_le, Nat.le_of_lt]\n    (a.push x)[i] = a[i]", "start": [126, 1], "end": [129, 88], "kind": "commanddeclaration"}, {"full_name": "Array.get_push_eq", "code": "@[simp] theorem get_push_eq (a : Array \u03b1) (x : \u03b1) : (a.push x)[a.size] = x", "start": [131, 1], "end": [133, 60], "kind": "commanddeclaration"}, {"full_name": "Array.get_push", "code": "theorem get_push (a : Array \u03b1) (x : \u03b1) (i : Nat) (h : i < (a.push x).size) :\n    (a.push x)[i] = if h : i < a.size then a[i] else x", "start": [135, 1], "end": [141, 84], "kind": "commanddeclaration"}, {"full_name": "Array.mapM_eq_foldlM", "code": "theorem mapM_eq_foldlM [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 m \u03b2) (arr : Array \u03b1) :\n    arr.mapM f = arr.foldlM (fun bs a => bs.push <$> f a) #[]", "start": [143, 1], "end": [153, 35], "kind": "commanddeclaration"}, {"full_name": "Array.SatisfiesM_mapM", "code": "theorem SatisfiesM_mapM [Monad m] [LawfulMonad m] (as : Array \u03b1) (f : \u03b1 \u2192 m \u03b2)\n    (motive : Nat \u2192 Prop) (h0 : motive 0)\n    (p : Fin as.size \u2192 \u03b2 \u2192 Prop)\n    (hs : \u2200 i, motive i.1 \u2192 SatisfiesM (p i \u00b7 \u2227 motive (i + 1)) (f as[i])) :\n    SatisfiesM\n      (fun arr => motive as.size \u2227 \u2203 eq : arr.size = as.size, \u2200 i h, p \u27e8i, h\u27e9 (arr[i]'(eq \u25b8 h)))\n      (Array.mapM f as)", "start": [155, 1], "end": [171, 85], "kind": "commanddeclaration"}, {"full_name": "Array.SatisfiesM_mapM'", "code": "theorem SatisfiesM_mapM' [Monad m] [LawfulMonad m] (as : Array \u03b1) (f : \u03b1 \u2192 m \u03b2)\n    (p : Fin as.size \u2192 \u03b2 \u2192 Prop)\n    (hs : \u2200 i, SatisfiesM (p i) (f as[i])) :\n    SatisfiesM\n      (fun arr => \u2203 eq : arr.size = as.size, \u2200 i h, p \u27e8i, h\u27e9 (arr[i]'(eq \u25b8 h)))\n      (Array.mapM f as)", "start": [173, 1], "end": [179, 93], "kind": "commanddeclaration"}, {"full_name": "Array.size_mapM", "code": "theorem size_mapM [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 m \u03b2) (as : Array \u03b1) :\n    SatisfiesM (fun arr => arr.size = as.size) (Array.mapM f as)", "start": [181, 1], "end": [183, 73], "kind": "commanddeclaration"}, {"full_name": "Array.map_data", "code": "@[simp] theorem map_data (f : \u03b1 \u2192 \u03b2) (arr : Array \u03b1) : (arr.map f).data = arr.data.map f", "start": [185, 1], "end": [190, 11], "kind": "commanddeclaration"}, {"full_name": "Array.size_map", "code": "@[simp] theorem size_map (f : \u03b1 \u2192 \u03b2) (arr : Array \u03b1) : (arr.map f).size = arr.size", "start": [192, 1], "end": [193, 14], "kind": "commanddeclaration"}, {"full_name": "Array.getElem_map", "code": "@[simp] theorem getElem_map (f : \u03b1 \u2192 \u03b2) (arr : Array \u03b1) (i : Nat) (h) :\n    ((arr.map f)[i]'h) = f (arr[i]'(size_map .. \u25b8 h))", "start": [195, 1], "end": [199, 35], "kind": "commanddeclaration"}, {"full_name": "Array.pop_data", "code": "@[simp] theorem pop_data (arr : Array \u03b1) : arr.pop.data = arr.data.dropLast", "start": [201, 1], "end": [201, 83], "kind": "commanddeclaration"}, {"full_name": "Array.append_eq_append", "code": "@[simp] theorem append_eq_append (arr arr' : Array \u03b1) : arr.append arr' = arr ++ arr'", "start": [203, 1], "end": [203, 93], "kind": "commanddeclaration"}, {"full_name": "Array.append_data", "code": "@[simp] theorem append_data (arr arr' : Array \u03b1) :\n    (arr ++ arr').data = arr.data ++ arr'.data", "start": [205, 1], "end": [209, 52], "kind": "commanddeclaration"}, {"full_name": "Array.appendList_eq_append", "code": "@[simp] theorem appendList_eq_append\n    (arr : Array \u03b1) (l : List \u03b1) : arr.appendList l = arr ++ l", "start": [211, 1], "end": [212, 70], "kind": "commanddeclaration"}, {"full_name": "Array.appendList_data", "code": "@[simp] theorem appendList_data (arr : Array \u03b1) (l : List \u03b1) :\n    (arr ++ l).data = arr.data ++ l", "start": [214, 1], "end": [217, 44], "kind": "commanddeclaration"}, {"full_name": "Array.foldl_data_eq_bind", "code": "theorem foldl_data_eq_bind (l : List \u03b1) (acc : Array \u03b2)\n    (F : Array \u03b2 \u2192 \u03b1 \u2192 Array \u03b2) (G : \u03b1 \u2192 List \u03b2)\n    (H : \u2200 acc a, (F acc a).data = acc.data ++ G a) :\n    (l.foldl F acc).data = acc.data ++ l.bind G", "start": [219, 1], "end": [223, 55], "kind": "commanddeclaration"}, {"full_name": "Array.foldl_data_eq_map", "code": "theorem foldl_data_eq_map (l : List \u03b1) (acc : Array \u03b2) (G : \u03b1 \u2192 \u03b2) :\n    (l.foldl (fun acc a => acc.push (G a)) acc).data = acc.data ++ l.map G", "start": [225, 1], "end": [227, 44], "kind": "commanddeclaration"}, {"full_name": "Array.size_uset", "code": "theorem size_uset (a : Array \u03b1) (v i h) : (uset a i v h).size = a.size", "start": [229, 1], "end": [229, 82], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Option/Basic.lean", "imports": ["lake-packages/std/Std/Classes/SetNotation.lean", "lake-packages/std/Std/Tactic/NoMatch.lean", "lake-packages/std/Std/Classes/LawfulMonad.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Option.elim", "code": "@[simp, inline] protected def elim : Option \u03b1 \u2192 \u03b2 \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b2\n  | some x, _, f => f x\n  | none, y, _ => y", "start": [12, 1], "end": [15, 20], "kind": "commanddeclaration"}, {"full_name": "Option.mem_def", "code": "@[simp] theorem mem_def {a : \u03b1} {b : Option \u03b1} : a \u2208 b \u2194 b = some a", "start": [19, 1], "end": [19, 76], "kind": "commanddeclaration"}, {"full_name": "Option.isNone_iff_eq_none", "code": "theorem isNone_iff_eq_none {o : Option \u03b1} : o.isNone \u2194 o = none", "start": [24, 1], "end": [25, 52], "kind": "commanddeclaration"}, {"full_name": "Option.some_inj", "code": "theorem some_inj {a b : \u03b1} : some a = some b \u2194 a = b", "start": [27, 1], "end": [27, 64], "kind": "commanddeclaration"}, {"full_name": "Option.decidable_eq_none", "code": "@[inline] def decidable_eq_none {o : Option \u03b1} : Decidable (o = none) :=\n  decidable_of_decidable_of_iff isNone_iff_eq_none", "start": [29, 1], "end": [35, 51], "kind": "commanddeclaration"}, {"full_name": "Option.get", "code": "@[inline] def get {\u03b1 : Type u} : (o : Option \u03b1) \u2192 isSome o \u2192 \u03b1\n  | some x, _ => x", "start": [47, 1], "end": [49, 19], "kind": "commanddeclaration"}, {"full_name": "Option.guard", "code": "@[inline] def guard (p : \u03b1 \u2192 Prop) [DecidablePred p] (a : \u03b1) : Option \u03b1 :=\n  if p a then some a else none", "start": [51, 1], "end": [53, 31], "kind": "commanddeclaration"}, {"full_name": "Option.toList", "code": "@[inline] def toList : Option \u03b1 \u2192 List \u03b1\n  | none => []\n  | some a => [a]", "start": [55, 1], "end": [60, 18], "kind": "commanddeclaration"}, {"full_name": "Option.toArray", "code": "@[inline] def toArray : Option \u03b1 \u2192 Array \u03b1\n  | none => #[]\n  | some a => #[a]", "start": [62, 1], "end": [67, 19], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet", "code": "def liftOrGet (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Option \u03b1 \u2192 Option \u03b1 \u2192 Option \u03b1\n  | none, none => none\n  | some a, none => some a\n  | none, some b => some b\n  | some a, some b => some (f a b)", "start": [69, 1], "end": [77, 35], "kind": "commanddeclaration"}, {"full_name": "Option.Rel", "code": "inductive Rel (r : \u03b1 \u2192 \u03b2 \u2192 Prop) : Option \u03b1 \u2192 Option \u03b2 \u2192 Prop\n  \n  | some {a b} : r a b \u2192 Rel r (some a) (some b)\n  \n  | none : Rel r none none", "start": [79, 1], "end": [85, 27], "kind": "commanddeclaration"}, {"full_name": "Option.pbind", "code": "@[simp, inline]\ndef pbind : \u2200 x : Option \u03b1, (\u2200 a : \u03b1, a \u2208 x \u2192 Option \u03b2) \u2192 Option \u03b2\n  | none, _ => none\n  | some a, f => f a rfl", "start": [87, 1], "end": [96, 25], "kind": "commanddeclaration"}, {"full_name": "Option.pmap", "code": "@[simp, inline] def pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) :\n    \u2200 x : Option \u03b1, (\u2200 a \u2208 x, p a) \u2192 Option \u03b2\n  | none, _ => none\n  | some a, H => f a (H a rfl)", "start": [98, 1], "end": [106, 31], "kind": "commanddeclaration"}, {"full_name": "Option.join", "code": "@[simp, inline] def join (x : Option (Option \u03b1)) : Option \u03b1 := x.bind id", "start": [108, 1], "end": [109, 73], "kind": "commanddeclaration"}, {"full_name": "Option.forM", "code": "@[inline] protected def forM [Pure m] : Option \u03b1 \u2192 (\u03b1 \u2192 m PUnit) \u2192 m PUnit\n  | none  , _ => pure ()\n  | some a, f => f a", "start": [111, 1], "end": [114, 21], "kind": "commanddeclaration"}, {"full_name": "Option.mapA", "code": "@[inline] protected def mapA [Applicative m] {\u03b1 \u03b2} (f : \u03b1 \u2192 m \u03b2) : Option \u03b1 \u2192 m (Option \u03b2)\n  | none => pure none\n  | some x => some <$> f x", "start": [127, 1], "end": [130, 27], "kind": "commanddeclaration"}, {"full_name": "Option.sequence", "code": "@[inline] def sequence [Monad m] {\u03b1 : Type u} : Option (m \u03b1) \u2192 m (Option \u03b1)\n  | none => pure none\n  | some fn => some <$> fn", "start": [132, 1], "end": [139, 27], "kind": "commanddeclaration"}, {"full_name": "Option.elimM", "code": "@[inline] def elimM [Monad m] (x : m (Option \u03b1)) (y : m \u03b2) (z : \u03b1 \u2192 m \u03b2) : m \u03b2 :=\n  do (\u2190 x).elim y z", "start": [141, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "Option.getDM", "code": "@[inline] def getDM [Monad m] (x : Option \u03b1) (y : m \u03b1) : m \u03b1 :=\n  match x with\n  | some a => pure a\n  | none => y", "start": [145, 1], "end": [149, 14], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Meta/LCtx.lean", "imports": ["lake-packages/lean4/src/lean/Lean/LocalContext.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LocalContext.getRoundtrippingUserName?", "code": "def getRoundtrippingUserName? (lctx : LocalContext) (fvarId : FVarId) : Option Name := do\n  let ldecl\u2081 \u2190 lctx.find? fvarId\n  let ldecl\u2082 \u2190 lctx.findFromUserName? ldecl\u2081.userName\n  guard <| ldecl\u2081.fvarId == ldecl\u2082.fvarId\n  some ldecl\u2081.userName", "start": [10, 1], "end": [18, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Control/ForInStep/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ForInStep.bind", "code": "@[inline] protected def ForInStep.bind [Monad m]\n    (a : ForInStep \u03b1) (f : \u03b1 \u2192 m (ForInStep \u03b1)) : m (ForInStep \u03b1) :=\n  match a with\n  | .done a => return .done a\n  | .yield a => f a", "start": [9, 1], "end": [17, 20], "kind": "commanddeclaration"}, {"full_name": "ForInStep.bindM", "code": "@[inherit_doc ForInStep.bind] protected abbrev ForInStep.bindM [Monad m]\n    (a : m (ForInStep \u03b1)) (f : \u03b1 \u2192 m (ForInStep \u03b1)) : m (ForInStep \u03b1) := a >>= (\u00b7.bind f)", "start": [19, 1], "end": [20, 90], "kind": "commanddeclaration"}, {"full_name": "ForInStep.run", "code": "@[inline] def ForInStep.run : ForInStep \u03b1 \u2192 \u03b1\n  | .done a\n  | .yield a => a", "start": [22, 1], "end": [28, 18], "kind": "commanddeclaration"}, {"full_name": "ForInStep.bindList", "code": "def ForInStep.bindList [Monad m]\n      (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : List \u03b1 \u2192 ForInStep \u03b2 \u2192 m (ForInStep \u03b2)\n  | [], s => pure s\n  | a::l, s => s.bind fun b => f a b >>= (\u00b7.bindList f l)", "start": [30, 1], "end": [34, 58], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/DefaultAlt.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.getMaxOccs", "code": "private def getMaxOccs (alts : Array Alt) : Alt \u00d7 Nat := Id.run do\n  let mut maxAlt := alts[0]!\n  let mut max    := getNumOccsOf alts 0\n  for i in [1:alts.size] do\n    let curr := getNumOccsOf alts i\n    if curr > max then\n       maxAlt := alts[i]!\n       max    := curr\n  return (maxAlt, max)\nwhere\n  \n  getNumOccsOf (alts : Array Alt) (i : Nat) : Nat := Id.run do\n    let code := alts[i]!.getCode\n    let mut n := 1\n    for j in [i+1:alts.size] do\n      if Code.alphaEqv alts[j]!.getCode code then\n        n := n+1\n    return n", "start": [11, 1], "end": [39, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.addDefaultAlt", "code": "def addDefaultAlt (alts : Array Alt) : SimpM (Array Alt) := do\n  if alts.size <= 1 || alts.any (\u00b7 matches .default ..) then\n    return alts\n  else\n    let (max, noccs) := getMaxOccs alts\n    if noccs == 1 then\n      return alts\n    else\n      let mut altsNew := #[]\n      let mut first := true\n      markSimplified\n      for alt in alts do\n        if Code.alphaEqv alt.getCode max.getCode then\n          let .alt _ ps k := alt | unreachable!\n          eraseParams ps\n          unless first do\n            eraseCode k\n          first := false\n        else\n          altsNew := altsNew.push alt\n      return altsNew.push (.default max.getCode)", "start": [41, 1], "end": [65, 49], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Used.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.markUsedFVar", "code": "def markUsedFVar (fvarId : FVarId) : SimpM Unit :=\n  modify fun s => { s with used := s.used.insert fvarId }", "start": [11, 1], "end": [16, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.markUsedType", "code": "def markUsedType (type : Expr) : SimpM Unit :=\n  modify fun s => { s with used := collectLocalDeclsType s.used type }", "start": [18, 1], "end": [23, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.markUsedArg", "code": "def markUsedArg (arg : Arg) : SimpM Unit :=\n  match arg with\n  | .fvar fvarId => markUsedFVar fvarId\n  | .type type => markUsedType type\n  | .erased => return ()", "start": [25, 1], "end": [32, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.markUsedLetValue", "code": "def markUsedLetValue (e : LetValue) : SimpM Unit := do\n  match e with\n  | .value .. | .erased => return ()\n  | .proj _ _ fvarId => markUsedFVar fvarId\n  | .const _ _ args => args.forM markUsedArg\n  | .fvar fvarId args => markUsedFVar fvarId; args.forM markUsedArg", "start": [34, 1], "end": [42, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.markUsedLetDecl", "code": "def markUsedLetDecl (letDecl : LetDecl) : SimpM Unit :=\n  markUsedLetValue letDecl.value", "start": [44, 1], "end": [49, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.markUsedCode", "code": "partial def markUsedCode (code : Code) : SimpM Unit := do\n  match code with\n  | .let decl k => markUsedLetDecl decl; markUsedCode k\n  | .jp decl k | .fun decl k => markUsedFunDecl decl; markUsedCode k\n  | .return fvarId => markUsedFVar fvarId\n  | .unreach .. => return ()\n  | .jmp fvarId args => markUsedFVar fvarId; args.forM markUsedArg\n  | .cases c => markUsedFVar c.discr; c.alts.forM fun alt => markUsedCode alt.getCode", "start": [52, 1], "end": [62, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.markUsedFunDecl", "code": "partial def markUsedFunDecl (funDecl : FunDecl) : SimpM Unit :=\n  markUsedCode funDecl.value", "start": [64, 1], "end": [68, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.isUsed", "code": "def isUsed (fvarId : FVarId) : SimpM Bool :=\n  return (\u2190 get).used.contains fvarId", "start": [71, 1], "end": [75, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.attachCodeDecls", "code": "def attachCodeDecls (decls : Array CodeDecl) (code : Code) : SimpM Code := do\n  go decls.size code\nwhere\n  go (i : Nat) (code : Code) : SimpM Code := do\n    if i > 0 then\n      let decl := decls[i-1]!\n      if (\u2190 isUsed decl.fvarId) then\n        match decl with\n        | .let decl => markUsedLetDecl decl; go (i-1) (.let decl code)\n        | .fun decl => markUsedFunDecl decl; go (i-1) (.fun decl code)\n        | .jp decl => markUsedFunDecl decl; go (i-1) (.jp decl code)\n      else\n        eraseCodeDecl decl\n        go (i-1) code\n    else\n      return code", "start": [77, 1], "end": [101, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/ConstantFold.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.FolderM", "code": "abbrev FolderM := StateRefT (Array CodeDecl) CompilerM", "start": [13, 1], "end": [17, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder", "code": "abbrev Folder := Array Arg \u2192 FolderM (Option LetValue)", "start": [19, 1], "end": [24, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Literal", "code": "class Literal (\u03b1 : Type) where\n  \n  getLit : FVarId \u2192 CompilerM (Option \u03b1)\n  \n  mkLit : \u03b1 \u2192 FolderM LetValue", "start": [26, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLetDecl", "code": "def mkAuxLetDecl (e : LetValue) (prefixName := `_x) : FolderM FVarId := do\n  let decl \u2190 LCNF.mkAuxLetDecl e prefixName\n  modify fun s => s.push <| .let decl\n  return decl.fvarId", "start": [46, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLit", "code": "def mkAuxLit [Literal \u03b1] (x : \u03b1) (prefixName := `_x) : FolderM FVarId := do\n  let lit \u2190 mkLit x\n  mkAuxLetDecl lit prefixName", "start": [57, 1], "end": [62, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.getNatLit", "code": "partial def getNatLit (fvarId : FVarId) : CompilerM (Option Nat) := do\n  let some (.value (.natVal n)) \u2190 findLetValue? fvarId | return none\n  return n", "start": [64, 1], "end": [66, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.mkNatLit", "code": "def mkNatLit (n : Nat) : FolderM LetValue :=\n  return .value (.natVal n)", "start": [68, 1], "end": [69, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.getStringLit", "code": "def getStringLit (fvarId : FVarId) : CompilerM (Option String) := do\n  let some (.value (.strVal s)) \u2190 findLetValue? fvarId | return none\n  return s", "start": [75, 1], "end": [77, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.mkStringLit", "code": "def mkStringLit (n : String) : FolderM LetValue :=\n  return .value (.strVal n)", "start": [79, 1], "end": [80, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.getBoolLit", "code": "def getBoolLit (fvarId : FVarId) : CompilerM (Option Bool) := do\n  let some (.const ctor [] #[]) \u2190 findLetValue? fvarId | return none\n  return ctor == ``Bool.true", "start": [86, 1], "end": [88, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.mkBoolLit", "code": "def mkBoolLit (b : Bool) : FolderM LetValue :=\n  let ctor := if b then ``Bool.true else ``Bool.false\n  return .const ctor [] #[]", "start": [90, 1], "end": [92, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.getLitAux", "code": "private partial def getLitAux [Inhabited \u03b1] (fvarId : FVarId) (ofNat : Nat \u2192 \u03b1) (ofNatName : Name) : CompilerM (Option \u03b1) := do\n  let some (.const declName _ #[.fvar fvarId]) \u2190 findLetValue? fvarId | return none\n  unless declName == ofNatName do return none\n  let some natLit \u2190 getLit fvarId | return none\n  return ofNat natLit", "start": [98, 1], "end": [102, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.mkNatWrapperInstance", "code": "def mkNatWrapperInstance [Inhabited \u03b1] (ofNat : Nat \u2192 \u03b1) (ofNatName : Name) (toNat : \u03b1 \u2192 Nat) : Literal \u03b1 where\n  getLit := (getLitAux \u00b7 ofNat ofNatName)\n  mkLit x := do\n    let helperId \u2190 mkAuxLit <| toNat x\n    return .const ofNatName [] #[.fvar helperId]", "start": [104, 1], "end": [108, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.getPseudoListLiteral", "code": "partial def getPseudoListLiteral (fvarId : FVarId) : CompilerM (Option (List FVarId \u00d7 Expr \u00d7 Level)) := do\n  go fvarId []\nwhere\n  go (fvarId : FVarId) (fvarIds : List FVarId) : CompilerM (Option (List FVarId \u00d7 Expr \u00d7 Level)) := do\n    let some e \u2190 findLetValue? fvarId | return none\n    match e with\n    | .const ``List.nil [u] #[.type \u03b1] =>\n      return some (fvarIds.reverse, \u03b1, u)\n    | .const ``List.cons _ #[_, .fvar h, .fvar t] =>\n      go t (h :: fvarIds)\n    | _ => return none", "start": [118, 1], "end": [140, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.mkPseudoArrayLiteral", "code": "def mkPseudoArrayLiteral (elements : Array FVarId) (typ : Expr) (typLevel : Level) : FolderM LetValue := do\n  let sizeLit \u2190 mkAuxLit elements.size\n  let mut literal \u2190 mkAuxLetDecl <| .const ``Array.mkEmpty [typLevel] #[.type typ, .fvar sizeLit]\n  for element in elements do\n    literal \u2190 mkAuxLetDecl <| .const ``Array.push [typLevel] #[.type typ, .fvar literal, .fvar element]\n  return .fvar literal #[]", "start": [142, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.foldArrayLiteral", "code": "def foldArrayLiteral : Folder := fun args => do\n  let #[_, .fvar fvarId] := args | return none\n  let some (list, typ, level) \u2190 getPseudoListLiteral fvarId | return none\n  let arr := Array.mk list\n  let lit \u2190 mkPseudoArrayLiteral arr typ level\n  return some lit", "start": [160, 1], "end": [183, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkUnary", "code": "def Folder.mkUnary [Literal \u03b1] [Literal \u03b2] (folder : \u03b1 \u2192 \u03b2) : Folder := fun args => do\n  let #[.fvar fvarId] := args | return none\n  let some arg1 \u2190 getLit fvarId | return none\n  let res := folder arg1\n  mkLit res", "start": [185, 1], "end": [192, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkBinary", "code": "def Folder.mkBinary [Literal \u03b1] [Literal \u03b2] [Literal \u03b3] (folder : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Folder := fun args => do\n  let #[.fvar fvarId\u2081, .fvar fvarId\u2082] := args | return none\n  let some arg\u2081 \u2190 getLit fvarId\u2081 | return none\n  let some arg\u2082 \u2190 getLit fvarId\u2082 | return none\n  mkLit <| folder arg\u2081 arg\u2082", "start": [194, 1], "end": [201, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkBinaryDecisionProcedure", "code": "def Folder.mkBinaryDecisionProcedure [Literal \u03b1] [Literal \u03b2] {r : \u03b1 \u2192 \u03b2 \u2192 Prop} (folder : (a : \u03b1) \u2192 (b : \u03b2) \u2192 Decidable (r a b)) : Folder := fun args => do\n  if (\u2190 getPhase) < .mono then\n    return none\n  let #[.fvar fvarId\u2081, .fvar fvarId\u2082] := args | return none\n  let some arg\u2081 \u2190 getLit fvarId\u2081 | return none\n  let some arg\u2082 \u2190 getLit fvarId\u2082 | return none\n  let boolLit := folder arg\u2081 arg\u2082 |>.decide\n  mkLit boolLit", "start": [203, 1], "end": [210, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftNeutral", "code": "def Folder.leftNeutral [Literal \u03b1] [BEq \u03b1] (neutral : \u03b1) : Folder := fun args => do\n  let #[.fvar fvarId\u2081, .fvar fvarId\u2082] := args | return none\n  let some arg\u2081 \u2190 getLit fvarId\u2081 | return none\n  unless arg\u2081 == neutral do return none\n  return some <| .fvar fvarId\u2082 #[]", "start": [212, 1], "end": [219, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightNeutral", "code": "def Folder.rightNeutral [Literal \u03b1] [BEq \u03b1] (neutral : \u03b1) : Folder := fun args => do\n  let #[.fvar fvarId\u2081, .fvar fvarId\u2082] := args | return none\n  let some arg\u2082 \u2190 getLit fvarId\u2082 | return none\n  unless arg\u2082 == neutral do return none\n  return some <| .fvar fvarId\u2081 #[]", "start": [221, 1], "end": [228, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftAnnihilator", "code": "def Folder.leftAnnihilator [Literal \u03b1] [BEq \u03b1] (annihilator : \u03b1) (zero : \u03b1) : Folder := fun args => do\n  let #[.fvar fvarId, _] := args | return none\n  let some arg \u2190 getLit fvarId | return none\n  unless arg == annihilator do return none\n  mkLit zero", "start": [230, 1], "end": [237, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightAnnihilator", "code": "def Folder.rightAnnihilator [Literal \u03b1] [BEq \u03b1] (annihilator : \u03b1) (zero : \u03b1) : Folder := fun args => do\n  let #[_, .fvar fvarId] := args | return none\n  let some arg \u2190 getLit fvarId | return none\n  unless arg == annihilator do return none\n  mkLit zero", "start": [239, 1], "end": [246, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.divShift", "code": "def Folder.divShift [Literal \u03b1] [BEq \u03b1] (shiftRight : Name) (pow2 : \u03b1 \u2192 \u03b1) (log2 : \u03b1 \u2192 \u03b1) : Folder := fun args => do\n  unless (\u2190 getEnv).contains shiftRight do return none\n  let #[lhs, .fvar fvarId] := args | return none\n  let some rhs \u2190 getLit fvarId | return none\n  let exponent := log2 rhs\n  unless pow2 exponent == rhs do return none\n  let shiftLit \u2190 mkAuxLit exponent\n  return some <| .const shiftRight [] #[lhs, .fvar shiftLit]", "start": [248, 1], "end": [255, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mulRhsShift", "code": "def Folder.mulRhsShift [Literal \u03b1] [BEq \u03b1] (shiftLeft : Name) (pow2 : \u03b1 \u2192 \u03b1) (log2 : \u03b1 \u2192 \u03b1) : Folder := fun args => do\n  unless (\u2190 getEnv).contains shiftLeft do return none\n  let #[lhs, .fvar fvarId] := args | return none\n  let some rhs \u2190 getLit fvarId | return none\n  let exponent := log2 rhs\n  unless pow2 exponent == rhs do return none\n  let shiftLit \u2190 mkAuxLit exponent\n  return some <| .const shiftLeft [] #[lhs, .fvar shiftLit]", "start": [257, 1], "end": [264, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mulLhsShift", "code": "def Folder.mulLhsShift [Literal \u03b1] [BEq \u03b1] (shiftLeft : Name) (pow2 : \u03b1 \u2192 \u03b1) (log2 : \u03b1 \u2192 \u03b1) : Folder := fun args => do\n  unless (\u2190 getEnv).contains shiftLeft do return none\n  let #[.fvar fvarId, rhs] := args | return none\n  let some lhs \u2190 getLit fvarId | return none\n  let exponent := log2 lhs\n  unless pow2 exponent == lhs do return none\n  let shiftLit \u2190 mkAuxLit exponent\n  return some <| .const shiftLeft [] #[rhs, .fvar shiftLit]", "start": [266, 1], "end": [273, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.first", "code": "def Folder.first (folders : Array Folder) : Folder := fun exprs => do\n  let backup \u2190 get\n  for folder in folders do\n    if let some res \u2190 folder exprs then\n      return res\n    else\n      set backup\n  return none", "start": [275, 1], "end": [285, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightNeutral", "code": "def Folder.leftRightNeutral [Literal \u03b1] [BEq \u03b1] (neutral : \u03b1) : Folder :=\n  Folder.first #[Folder.leftNeutral neutral, Folder.rightNeutral neutral]", "start": [287, 1], "end": [291, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightAnnihilator", "code": "def Folder.leftRightAnnihilator [Literal \u03b1] [BEq \u03b1] (annihilator : \u03b1) (zero : \u03b1) : Folder :=\n  Folder.first #[Folder.leftAnnihilator annihilator zero, Folder.rightAnnihilator annihilator zero]", "start": [293, 1], "end": [297, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.higherOrderLiteralFolders", "code": "def higherOrderLiteralFolders : List (Name \u00d7 Folder) := [\n  (``List.toArray, foldArrayLiteral)\n]", "start": [299, 1], "end": [304, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mulShift", "code": "def Folder.mulShift [Literal \u03b1] [BEq \u03b1] (shiftLeft : Name) (pow2 : \u03b1 \u2192 \u03b1) (log2 : \u03b1 \u2192 \u03b1) : Folder :=\n  Folder.first #[Folder.mulLhsShift shiftLeft pow2 log2, Folder.mulRhsShift shiftLeft pow2 log2]", "start": [306, 1], "end": [307, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.arithmeticFolders", "code": "def arithmeticFolders : List (Name \u00d7 Folder) := [\n  (``Nat.succ, Folder.mkUnary Nat.succ),\n  (``Nat.add,    Folder.first #[Folder.mkBinary Nat.add, Folder.leftRightNeutral 0]),\n  (``UInt8.add,  Folder.first #[Folder.mkBinary UInt8.add, Folder.leftRightNeutral (0 : UInt8)]),\n  (``UInt16.add,  Folder.first #[Folder.mkBinary UInt16.add, Folder.leftRightNeutral (0 : UInt16)]),\n  (``UInt32.add,  Folder.first #[Folder.mkBinary UInt32.add, Folder.leftRightNeutral (0 : UInt32)]),\n  (``UInt64.add,  Folder.first #[Folder.mkBinary UInt64.add, Folder.leftRightNeutral (0 : UInt64)]),\n  (``Nat.sub,    Folder.first #[Folder.mkBinary Nat.sub, Folder.leftRightNeutral 0]),\n  (``UInt8.sub,  Folder.first #[Folder.mkBinary UInt8.sub, Folder.leftRightNeutral (0 : UInt8)]),\n  (``UInt16.sub,  Folder.first #[Folder.mkBinary UInt16.sub, Folder.leftRightNeutral (0 : UInt16)]),\n  (``UInt32.sub,  Folder.first #[Folder.mkBinary UInt32.sub, Folder.leftRightNeutral (0 : UInt32)]),\n  (``UInt64.sub,  Folder.first #[Folder.mkBinary UInt64.sub, Folder.leftRightNeutral (0 : UInt64)]),\n  (``Nat.mul,    Folder.first #[Folder.mkBinary Nat.mul, Folder.leftRightNeutral 1, Folder.leftRightAnnihilator 0 0, Folder.mulShift ``Nat.shiftLeft (Nat.pow 2) Nat.log2]),\n  (``UInt8.mul,  Folder.first #[Folder.mkBinary UInt8.mul, Folder.leftRightNeutral (1 : UInt8), Folder.leftRightAnnihilator (0 : UInt8) 0, Folder.mulShift ``UInt8.shiftLeft (UInt8.shiftLeft 1 \u00b7) UInt8.log2]),\n  (``UInt16.mul,  Folder.first #[Folder.mkBinary UInt16.mul, Folder.leftRightNeutral (1 : UInt16), Folder.leftRightAnnihilator (0 : UInt16) 0, Folder.mulShift ``UInt16.shiftLeft (UInt16.shiftLeft 1 \u00b7) UInt16.log2]),\n  (``UInt32.mul,  Folder.first #[Folder.mkBinary UInt32.mul, Folder.leftRightNeutral (1 : UInt32), Folder.leftRightAnnihilator (0 : UInt32) 0, Folder.mulShift ``UInt32.shiftLeft (UInt32.shiftLeft 1 \u00b7) UInt32.log2]),\n  (``UInt64.mul,  Folder.first #[Folder.mkBinary UInt64.mul, Folder.leftRightNeutral (1 : UInt64), Folder.leftRightAnnihilator (0 : UInt64) 0, Folder.mulShift ``UInt64.shiftLeft (UInt64.shiftLeft 1 \u00b7) UInt64.log2]),\n  (``Nat.div,    Folder.first #[Folder.mkBinary Nat.div, Folder.rightNeutral 1, Folder.divShift ``Nat.shiftRight (Nat.pow 2) Nat.log2]),\n  (``UInt8.div,  Folder.first #[Folder.mkBinary UInt8.div, Folder.rightNeutral (1 : UInt8), Folder.divShift ``UInt8.shiftRight (UInt8.shiftLeft 1 \u00b7) UInt8.log2]),\n  (``UInt16.div,  Folder.first #[Folder.mkBinary UInt16.div, Folder.rightNeutral (1 : UInt16), Folder.divShift ``UInt16.shiftRight (UInt16.shiftLeft 1 \u00b7) UInt16.log2]),\n  (``UInt32.div,  Folder.first #[Folder.mkBinary UInt32.div, Folder.rightNeutral (1 : UInt32), Folder.divShift ``UInt32.shiftRight (UInt32.shiftLeft 1 \u00b7) UInt32.log2]),\n  (``UInt64.div,  Folder.first #[Folder.mkBinary UInt64.div, Folder.rightNeutral (1 : UInt64), Folder.divShift ``UInt64.shiftRight (UInt64.shiftLeft 1 \u00b7) UInt64.log2])\n]", "start": [309, 1], "end": [334, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.relationFolders", "code": "def relationFolders : List (Name \u00d7 Folder) := [\n  (``Nat.decEq, Folder.mkBinaryDecisionProcedure Nat.decEq),\n  (``Nat.decLt, Folder.mkBinaryDecisionProcedure Nat.decLt),\n  (``Nat.decLe, Folder.mkBinaryDecisionProcedure Nat.decLe),\n  (``UInt8.decEq, Folder.mkBinaryDecisionProcedure UInt8.decEq),\n  (``UInt8.decLt, Folder.mkBinaryDecisionProcedure UInt8.decLt),\n  (``UInt8.decLe, Folder.mkBinaryDecisionProcedure UInt8.decLe),\n  (``UInt16.decEq, Folder.mkBinaryDecisionProcedure UInt16.decEq),\n  (``UInt16.decLt, Folder.mkBinaryDecisionProcedure UInt16.decLt),\n  (``UInt16.decLe, Folder.mkBinaryDecisionProcedure UInt16.decLe),\n  (``UInt32.decEq, Folder.mkBinaryDecisionProcedure UInt32.decEq),\n  (``UInt32.decLt, Folder.mkBinaryDecisionProcedure UInt32.decLt),\n  (``UInt32.decLe, Folder.mkBinaryDecisionProcedure UInt32.decLe),\n  (``UInt64.decEq, Folder.mkBinaryDecisionProcedure UInt64.decEq),\n  (``UInt64.decLt, Folder.mkBinaryDecisionProcedure UInt64.decLt),\n  (``UInt64.decLe, Folder.mkBinaryDecisionProcedure UInt64.decLe),\n  (``Bool.decEq, Folder.mkBinaryDecisionProcedure Bool.decEq),\n  (``Bool.decEq, Folder.mkBinaryDecisionProcedure String.decEq)\n]", "start": [336, 1], "end": [354, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.stringFolders", "code": "def stringFolders : List (Name \u00d7 Folder) := [\n  (``String.append, Folder.first #[Folder.mkBinary String.append, Folder.leftRightNeutral \"\"]),\n  (``String.length, Folder.mkUnary String.length),\n  (``String.push, Folder.mkBinary String.push)\n]", "start": [356, 1], "end": [363, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.applyFolders", "code": "def applyFolders (decl : LetDecl) (folders : SMap Name Folder) : CompilerM (Option (Array CodeDecl)) := do\n  match decl.value with\n  | .const name _ args =>\n    if let some folder := folders.find? name then\n      if let (some res, aux) \u2190 folder args |>.run #[] then\n        let decl \u2190 decl.updateValue res\n        return some <| aux.push (.let decl)\n    return none\n  | _ => return none", "start": [365, 1], "end": [376, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.getFolderCoreUnsafe", "code": "private unsafe def getFolderCoreUnsafe (env : Environment) (opts : Options) (declName : Name) : ExceptT String Id Folder :=\n  env.evalConstCheck Folder opts ``Folder declName", "start": [378, 1], "end": [379, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.getFolderCore", "code": "@[implemented_by getFolderCoreUnsafe]\nprivate opaque getFolderCore (env : Environment) (opts : Options) (declName : Name) : ExceptT String Id Folder", "start": [381, 1], "end": [382, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.getFolder", "code": "private def getFolder (declName : Name) : CoreM Folder := do\n  ofExcept <| getFolderCore (\u2190 getEnv) (\u2190 getOptions) declName", "start": [384, 1], "end": [385, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.builtinFolders", "code": "def builtinFolders : SMap Name Folder :=\n  (arithmeticFolders ++ relationFolders ++ higherOrderLiteralFolders ++ stringFolders).foldl (init := {}) fun s (declName, folder) =>\n    s.insert declName folder", "start": [387, 1], "end": [389, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry", "code": "structure FolderOleanEntry where\n  declName : Name\n  folderDeclName : Name", "start": [391, 1], "end": [393, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.FolderEntry", "code": "structure FolderEntry extends FolderOleanEntry where\n  folder : Folder", "start": [395, 1], "end": [396, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.registerFolder", "code": "def registerFolder (declName : Name) (folderDeclName : Name) : CoreM Unit := do\n  let folder \u2190 getFolder folderDeclName\n  modifyEnv fun env => folderExt.addEntry env { declName, folderDeclName, folder }", "start": [413, 1], "end": [415, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.getFolders", "code": "def getFolders : CoreM (SMap Name Folder) :=\n  return folderExt.getState (\u2190 getEnv) |>.2", "start": [417, 1], "end": [418, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.ConstantFold.foldConstants", "code": "def foldConstants (decl : LetDecl) : CompilerM (Option (Array CodeDecl)) := do\n  applyFolders decl (\u2190 getFolders)", "start": [420, 1], "end": [424, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/InlineCandidate.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.InlineCandidateInfo", "code": "structure InlineCandidateInfo where\n  isLocal  : Bool\n  params   : Array Param\n  \n  value    : Code\n  fType    : Expr\n  args     : Array Arg\n  \n  ifReduce : Bool\n  \n  recursive : Bool := false", "start": [11, 1], "end": [25, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.InlineCandidateInfo.arity", "code": "def InlineCandidateInfo.arity : InlineCandidateInfo \u2192 Nat\n  | { params, .. } => params.size", "start": [27, 1], "end": [29, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.inlineCandidate?", "code": "def inlineCandidate? (e : LetValue) : SimpM (Option InlineCandidateInfo) := do\n  let mut e := e\n  let mut mustInline := false\n  if let .const ``inline _ #[_, .fvar argFVarId] := e then\n    let some decl \u2190 findLetDecl? argFVarId | return none\n    e := decl.value\n    mustInline := true\n  if let .const declName us args := e then\n    unless (\u2190 read).config.inlineDefs do\n      return none\n    let some decl \u2190 getDecl? declName | return none\n    let shouldInline : SimpM Bool := do\n      if !decl.inlineIfReduceAttr && decl.recursive then return false\n      if mustInline then return true\n      \n      if (\u2190 inBasePhase <&&> Meta.isInstance decl.name) then\n        unless decl.name == ``instDecidableEqBool do\n          \n          return false\n      if decl.alwaysInlineAttr then return true\n      if decl.inlineAttr || decl.inlineIfReduceAttr then return true\n      unless decl.noinlineAttr do\n        if (\u2190 isSmall decl.value) then return true\n      return false\n    unless (\u2190 shouldInline) do return none\n    \n    let arity := decl.getArity\n    let inlinePartial := (\u2190 read).config.inlinePartial\n    if !mustInline && !inlinePartial && args.size < arity then return none\n    if decl.inlineIfReduceAttr then\n      let some paramIdx := decl.isCasesOnParam? | return none\n      unless paramIdx < args.size do return none\n      let arg := args[paramIdx]!\n      unless (\u2190 arg.isConstructorApp) do return none\n    let params := decl.instantiateParamsLevelParams us\n    let value := decl.instantiateValueLevelParams us\n    let type := decl.instantiateTypeLevelParams us\n    incInline\n    return some {\n      isLocal   := false\n      fType     := type\n      args      := args\n      ifReduce  := decl.inlineIfReduceAttr\n      recursive := decl.recursive\n      params, value\n    }\n  else if let .fvar f args := e then\n    let some decl \u2190 findFunDecl'? f | return none\n    unless args.size > 0 do return none unless mustInline || (\u2190 shouldInlineLocal decl) do return none\n    incInlineLocal\n    modify fun s => { s with inlineLocal := s.inlineLocal + 1 }\n    return some {\n      isLocal  := true\n      fType    := (\u2190 getType f)\n      args     := args\n      params   := decl.params\n      value    := decl.value\n      ifReduce := false\n    }\n  else\n    return none", "start": [31, 1], "end": [106, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpValue.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.simpProj?", "code": "def simpProj? (e : LetValue) : OptionT SimpM LetValue := do\n  let .proj _ i s := e | failure\n  let some ctorInfo \u2190 findCtor? s | failure\n  match ctorInfo with\n  | .ctor ctorVal args => return args[ctorVal.numParams + i]!.toLetValue\n  | .natVal .. => failure", "start": [11, 1], "end": [19, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.simpAppApp?", "code": "def simpAppApp? (e : LetValue) : OptionT SimpM LetValue := do\n  let .fvar g args := e | failure\n  let some decl \u2190 findLetDecl? g | failure\n  match decl.value with\n  | .fvar f args' =>\n    \n    guard (!args'.isEmpty)\n    return .fvar f (args' ++ args)\n  | .const declName us args' => return .const declName us (args' ++ args)\n  | .erased => return .erased\n  | .proj .. | .value .. => failure", "start": [21, 1], "end": [39, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.simpCtorDiscr?", "code": "def simpCtorDiscr? (e : LetValue) : OptionT SimpM LetValue := do\n  let .const declName _ _ := e | failure\n  let some (.ctorInfo _) := (\u2190 getEnv).find? declName | failure\n  let some fvarId \u2190 simpCtorDiscrCore? e.toExpr | failure\n  return .fvar fvarId #[]", "start": [41, 1], "end": [45, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.applyImplementedBy?", "code": "def applyImplementedBy? (e : LetValue) : OptionT SimpM LetValue := do\n  guard <| (\u2190 read).config.implementedBy\n  let .const declName us args := e | failure\n  let some declNameNew := getImplementedBy? (\u2190 getEnv) declName | failure\n  return .const declNameNew us args", "start": [47, 1], "end": [51, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.simpValue?", "code": "def simpValue? (e : LetValue) : SimpM (Option LetValue) :=\n  simpProj? e <|> simpAppApp? e <|> simpCtorDiscr? e <|> applyImplementedBy? e", "start": [53, 1], "end": [56, 79], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/InlineProj.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.inlineProjInst?", "code": "partial def inlineProjInst? (e : LetValue) : SimpM (Option (Array CodeDecl \u00d7 FVarId)) := do\n  let .proj _ i s := e | return none\n  let sType \u2190 getType s\n  unless (\u2190 isClass? sType).isSome do return none\n  let eType \u2190 e.inferType\n  unless  (\u2190 isClass? eType).isNone do return none\n  let (fvarId?, decls) \u2190 visit s [i] |>.run |>.run #[]\n  if let some fvarId := fvarId? then\n    return some (decls, fvarId)\n  else\n    eraseCodeDecls decls\n    return none\nwhere\n  visit (fvarId : FVarId) (projs : List Nat) : OptionT (StateRefT (Array CodeDecl) SimpM) FVarId := do\n    let some letDecl \u2190 findLetDecl? fvarId | failure\n    match letDecl.value with\n    | .proj _ i s => visit s (i :: projs)\n    | .fvar .. | .value .. | .erased => failure\n    | .const declName us args =>\n      if let some (.ctorInfo ctorVal) := (\u2190 getEnv).find? declName then\n        let i :: projs := projs | unreachable!\n        let arg := args[ctorVal.numParams + i]!\n        let fvarId \u2190 match arg with\n          | .fvar fvarId => pure fvarId\n          | .erased | .type .. =>\n            let auxDecl \u2190 mkLetDeclErased\n            modify (\u00b7.push (.let auxDecl))\n            pure auxDecl.fvarId\n        if projs.isEmpty then\n          return fvarId\n        else\n          visit fvarId projs\n      else\n        let some decl \u2190 getDecl? declName | failure\n        guard (decl.getArity == args.size)\n        let params := decl.instantiateParamsLevelParams us\n        let code := decl.instantiateValueLevelParams us\n        let code \u2190 betaReduce params code args (mustInline := true)\n        visitCode code projs\n\n  visitCode (code : Code) (projs : List Nat) : OptionT (StateRefT (Array CodeDecl) SimpM) FVarId := do\n    match code with\n    | .let decl k => modify (\u00b7.push (.let decl)); visitCode k projs\n    | .fun decl k => modify (\u00b7.push (.fun decl)); visitCode k projs\n    | .return fvarId => visit fvarId projs\n    | _ => eraseCode code; failure", "start": [11, 1], "end": [82, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/NoncomputableAttr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.addNoncomputable", "code": "def addNoncomputable (env : Environment) (declName : Name) : Environment :=\n  noncomputableExt.tag env declName", "start": [12, 1], "end": [14, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.isNoncomputable", "code": "def isNoncomputable (env : Environment) (declName : Name) : Bool :=\n  noncomputableExt.isTagged env declName", "start": [16, 1], "end": [21, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/DefView.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/DeclUtil.lean", "lake-packages/lean4/src/lean/Lean/Meta/ForEachExpr.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.DefKind", "code": "inductive DefKind where\n  | def | theorem | example | opaque | abbrev\n  deriving Inhabited, BEq", "start": [12, 1], "end": [14, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.DefKind.isTheorem", "code": "def DefKind.isTheorem : DefKind \u2192 Bool\n  | .theorem => true\n  | _        => false", "start": [16, 1], "end": [18, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.DefKind.isDefOrAbbrevOrOpaque", "code": "def DefKind.isDefOrAbbrevOrOpaque : DefKind \u2192 Bool\n  | .def    => true\n  | .opaque => true\n  | .abbrev => true\n  | _       => false", "start": [20, 1], "end": [24, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.DefKind.isExample", "code": "def DefKind.isExample : DefKind \u2192 Bool\n  | .example => true\n  | _        => false", "start": [26, 1], "end": [28, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.DefView", "code": "structure DefView where\n  kind          : DefKind\n  ref           : Syntax\n  modifiers     : Modifiers\n  declId        : Syntax\n  binders       : Syntax\n  type?         : Option Syntax\n  value         : Syntax\n  deriving?     : Option (Array Syntax) := none\n  deriving Inhabited", "start": [30, 1], "end": [39, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.DefView.isInstance", "code": "def DefView.isInstance (view : DefView) : Bool :=\n  view.modifiers.attrs.any fun attr => attr.name == `instance", "start": [41, 1], "end": [42, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkDefViewOfAbbrev", "code": "def mkDefViewOfAbbrev (modifiers : Modifiers) (stx : Syntax) : DefView :=\n  let (binders, type) := expandOptDeclSig stx[2]\n  let modifiers       := modifiers.addAttribute { name := `inline }\n  let modifiers       := modifiers.addAttribute { name := `reducible }\n  { ref := stx, kind := DefKind.abbrev, modifiers,\n    declId := stx[1], binders, type? := type, value := stx[3] }", "start": [47, 1], "end": [53, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkDefViewOfDef", "code": "def mkDefViewOfDef (modifiers : Modifiers) (stx : Syntax) : DefView :=\n  let (binders, type) := expandOptDeclSig stx[2]\n  let deriving? := if stx[4].isNone then none else some stx[4][1].getSepArgs\n  { ref := stx, kind := DefKind.def, modifiers,\n    declId := stx[1], binders, type? := type, value := stx[3], deriving? }", "start": [55, 1], "end": [60, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkDefViewOfTheorem", "code": "def mkDefViewOfTheorem (modifiers : Modifiers) (stx : Syntax) : DefView :=\n  let (binders, type) := expandDeclSig stx[2]\n  { ref := stx, kind := DefKind.theorem, modifiers,\n    declId := stx[1], binders, type? := some type, value := stx[3] }", "start": [62, 1], "end": [66, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkFreshInstanceName", "code": "def mkFreshInstanceName : CommandElabM Name := do\n  let s \u2190 get\n  let idx := s.nextInstIdx\n  modify fun s => { s with nextInstIdx := s.nextInstIdx + 1 }\n  return Lean.Elab.mkFreshInstanceName s.env idx", "start": [68, 1], "end": [72, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkInstanceName", "code": "def mkInstanceName (binders : Array Syntax) (type : Syntax) : CommandElabM Name := do\n  let savedState \u2190 get\n  try\n    let result \u2190 runTermElabM fun _ => Term.withAutoBoundImplicit <| Term.elabBinders binders fun _ => Term.withoutErrToSorry do\n      let type \u2190 instantiateMVars (\u2190 Term.elabType type)\n      let ref \u2190 IO.mkRef \"\"\n      Meta.forEachExpr type fun e => do\n        if e.isForall then ref.modify (\u00b7 ++ \"ForAll\")\n        else if e.isProp then ref.modify (\u00b7 ++ \"Prop\")\n        else if e.isType then ref.modify (\u00b7 ++ \"Type\")\n        else if e.isSort then ref.modify (\u00b7 ++ \"Sort\")\n        else if e.isConst then\n          match e.constName!.eraseMacroScopes with\n          | .str _ str =>\n              if str.front.isLower then\n                ref.modify (\u00b7 ++ str.capitalize)\n              else\n                ref.modify (\u00b7 ++ str)\n          | _ => pure ()\n      ref.get\n    set savedState\n    liftMacroM <| mkUnusedBaseName <| Name.mkSimple (\"inst\" ++ result)\n  catch _ =>\n    set savedState\n    mkFreshInstanceName", "start": [74, 1], "end": [101, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkDefViewOfInstance", "code": "def mkDefViewOfInstance (modifiers : Modifiers) (stx : Syntax) : CommandElabM DefView := do\n  let attrKind        \u2190 liftMacroM <| toAttributeKind stx[0]\n  let prio            \u2190 liftMacroM <| expandOptNamedPrio stx[2]\n  let attrStx         \u2190 `(attr| instance $(quote prio):num)\n  let (binders, type) := expandDeclSig stx[4]\n  let modifiers       := modifiers.addAttribute { kind := attrKind, name := `instance, stx := attrStx }\n  let declId \u2190 match stx[3].getOptional? with\n    | some declId => pure declId\n    | none        =>\n      let id \u2190 mkInstanceName binders.getArgs type\n      pure <| mkNode ``Parser.Command.declId #[mkIdentFrom stx id, mkNullNode]\n  return {\n    ref := stx, kind := DefKind.def, modifiers := modifiers,\n    declId := declId, binders := binders, type? := type, value := stx[5]\n  }", "start": [103, 1], "end": [118, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkDefViewOfOpaque", "code": "def mkDefViewOfOpaque (modifiers : Modifiers) (stx : Syntax) : CommandElabM DefView := do\n  let (binders, type) := expandDeclSig stx[2]\n  let val \u2190 match stx[3].getOptional? with\n    | some val => pure val\n    | none     =>\n      let val \u2190 if modifiers.isUnsafe then `(default_or_ofNonempty% unsafe) else `(default_or_ofNonempty%)\n      pure <| mkNode ``Parser.Command.declValSimple #[ mkAtomFrom stx \":=\", val ]\n  return {\n    ref := stx, kind := DefKind.opaque, modifiers := modifiers,\n    declId := stx[1], binders := binders, type? := some type, value := val\n  }", "start": [120, 1], "end": [131, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkDefViewOfExample", "code": "def mkDefViewOfExample (modifiers : Modifiers) (stx : Syntax) : DefView :=\n  let (binders, type) := expandOptDeclSig stx[1]\n  let id              := mkIdentFrom stx `_example\n  let declId          := mkNode ``Parser.Command.declId #[id, mkNullNode]\n  { ref := stx, kind := DefKind.example, modifiers := modifiers,\n    declId := declId, binders := binders, type? := type, value := stx[2] }", "start": [133, 1], "end": [139, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.isDefLike", "code": "def isDefLike (stx : Syntax) : Bool :=\n  let declKind := stx.getKind\n  declKind == ``Parser.Command.abbrev ||\n  declKind == ``Parser.Command.def ||\n  declKind == ``Parser.Command.theorem ||\n  declKind == ``Parser.Command.opaque ||\n  declKind == ``Parser.Command.instance ||\n  declKind == ``Parser.Command.example", "start": [141, 1], "end": [148, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkDefView", "code": "def mkDefView (modifiers : Modifiers) (stx : Syntax) : CommandElabM DefView :=\n  let declKind := stx.getKind\n  if declKind == ``Parser.Command.\u00ababbrev\u00bb then\n    return mkDefViewOfAbbrev modifiers stx\n  else if declKind == ``Parser.Command.def then\n    return mkDefViewOfDef modifiers stx\n  else if declKind == ``Parser.Command.theorem then\n    return mkDefViewOfTheorem modifiers stx\n  else if declKind == ``Parser.Command.opaque then\n    mkDefViewOfOpaque modifiers stx\n  else if declKind == ``Parser.Command.instance then\n    mkDefViewOfInstance modifiers stx\n  else if declKind == ``Parser.Command.example then\n    return mkDefViewOfExample modifiers stx\n  else\n    throwError \"unexpected kind of definition\"", "start": [150, 1], "end": [165, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Classes/BEq.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PartialEquivBEq", "code": "class PartialEquivBEq (\u03b1) [BEq \u03b1] : Prop where\n  \n  symm : (a : \u03b1) == b \u2192 b == a\n  \n  trans : (a : \u03b1) == b \u2192 b == c \u2192 a == c", "start": [9, 1], "end": [18, 41], "kind": "commanddeclaration"}, {"full_name": "beq_eq_false_iff_ne", "code": "@[simp] theorem beq_eq_false_iff_ne [BEq \u03b1] [LawfulBEq \u03b1]\n    (a b : \u03b1) : (a == b) = false \u2194 a \u2260 b", "start": [20, 1], "end": [23, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Ext.lean", "imports": ["lake-packages/std/Std/Tactic/Ext/Attr.lean", "lake-packages/std/Std/Tactic/RCases.lean", "lake-packages/std/Std/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.Ext.withExtHyps", "code": "def withExtHyps (struct : Name) (flat : Term)\n    (k : Array Expr \u2192 (x y : Expr) \u2192 Array (Name \u00d7 Expr) \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  let flat \u2190 match flat with\n  | `(true) => pure true\n  | `(false) => pure false\n  | _ => throwErrorAt flat \"expected 'true' or 'false'\"\n  unless isStructure (\u2190 getEnv) struct do throwError \"not a structure: {struct}\"\n  let structC \u2190 mkConstWithLevelParams struct\n  forallTelescope (\u2190 inferType structC) fun params _ => do\n  withNewBinderInfos (params.map (\u00b7.fvarId!, BinderInfo.implicit)) do\n  withLocalDeclD `x (mkAppN structC params) fun x => do\n  withLocalDeclD `y (mkAppN structC params) fun y => do\n    let mut hyps := #[]\n    let fields := if flat then\n      getStructureFieldsFlattened (\u2190 getEnv) struct (includeSubobjectFields := false)\n    else\n      getStructureFields (\u2190 getEnv) struct\n    for field in fields do\n      let x_f \u2190 mkProjection x field\n      let y_f \u2190 mkProjection y field\n      if \u2190 isProof x_f then\n        pure ()\n      else if \u2190 isDefEq (\u2190 inferType x_f) (\u2190 inferType y_f) then\n        hyps := hyps.push (field, \u2190 mkEq x_f y_f)\n      else\n        hyps := hyps.push (field, \u2190 mkHEq x_f y_f)\n    k params x y hyps", "start": [13, 1], "end": [45, 22], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.mkIff", "code": "def mkIff (p q : Expr) : Expr := mkApp2 (mkConst ``Iff) p q", "start": [57, 1], "end": [58, 60], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.mkAndN", "code": "def mkAndN : List Expr \u2192 Expr\n  | [] => mkConst ``True\n  | [p] => p\n  | p :: ps => mkAnd p (mkAndN ps)", "start": [60, 1], "end": [64, 35], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.$extName", "code": "@[ext $(prio)?] protected theorem $extName:ident : ext_type% $flat $struct:ident", "start": [84, 5], "end": [85, 49], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.$extIffName", "code": "protected theorem $extIffName:ident : ext_iff_type% $flat $struct:ident", "start": [86, 5], "end": [89, 61], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.applyExtLemma", "code": "def applyExtLemma (goal : MVarId) : MetaM (List MVarId) := goal.withContext do\n  let tgt \u2190 goal.getType'\n  unless tgt.isAppOfArity ``Eq 3 do\n    throwError \"applyExtLemma only applies to equations, not{indentExpr tgt}\"\n  let ty := tgt.getArg! 0\n  let s \u2190 saveState\n  for lem in \u2190 getExtLemmas ty do\n    try\n      withNewMCtxDepth do\n        let c \u2190 mkConstWithFreshMVarLevels lem.declName\n        let (_, _, declTy) \u2190 withDefault <| forallMetaTelescopeReducing (\u2190 inferType c)\n        guard (\u2190 isDefEq tgt declTy)\n      return \u2190 goal.apply (cfg := { newGoals := .all }) (\u2190 mkConstWithFreshMVarLevels lem.declName)\n    catch _ => s.restore\n  throwError \"no applicable extensionality lemma found for{indentExpr ty}\"", "start": [91, 1], "end": [113, 75], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.tryIntros", "code": "def tryIntros [Monad m] [MonadLiftT TermElabM m] (g : MVarId) (pats : List (TSyntax `rcasesPat))\n    (k : MVarId \u2192 List (TSyntax `rcasesPat) \u2192 m Nat) : m Nat := do\n  match pats with\n  | [] => k (\u2190 (g.intros : TermElabM _)).2 []\n  | p::ps =>\n    if (\u2190 (g.withContext g.getType' : TermElabM _)).isForall then\n      let mut n := 0\n      for g in \u2190 RCases.rintro #[p] none g do\n        n := n.max (\u2190 tryIntros g ps k)\n      pure (n + 1)\n    else k g pats", "start": [118, 1], "end": [132, 18], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.withExt1", "code": "def withExt1 [Monad m] [MonadLiftT TermElabM m] (g : MVarId) (pats : List (TSyntax `rcasesPat))\n    (k : MVarId \u2192 List (TSyntax `rcasesPat) \u2192 m Nat) : m Nat := do\n  let mut n := 0\n  for g in \u2190 (applyExtLemma g : TermElabM _) do\n    n := n.max (\u2190 tryIntros g pats k)\n  pure n", "start": [134, 1], "end": [143, 9], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.withExtN", "code": "def withExtN [Monad m] [MonadLiftT TermElabM m] [MonadExcept Exception m]\n    (g : MVarId) (pats : List (TSyntax `rcasesPat)) (k : MVarId \u2192 List (TSyntax `rcasesPat) \u2192 m Nat)\n    (depth := 1000000) (failIfUnchanged := true) : m Nat :=\n  match depth with\n  | 0 => k g pats\n  | depth+1 => do\n    if failIfUnchanged then\n      withExt1 g pats fun g pats => withExtN g pats k depth (failIfUnchanged := false)\n    else try\n      withExt1 g pats fun g pats => withExtN g pats k depth (failIfUnchanged := false)\n    catch _ => k g pats", "start": [145, 1], "end": [159, 24], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Ext.extCore", "code": "def extCore (g : MVarId) (pats : List (TSyntax `rcasesPat))\n    (depth := 1000000) (failIfUnchanged := true) :\n    TermElabM (Nat \u00d7 Array (MVarId \u00d7 List (TSyntax `rcasesPat))) := do\n  StateT.run (m := TermElabM) (s := #[])\n    (withExtN g pats (fun g qs => modify (\u00b7.push (g, qs)) *> pure 0) depth failIfUnchanged)", "start": [161, 1], "end": [169, 92], "kind": "commanddeclaration"}, {"full_name": "PUnit.ext", "code": "@[ext] protected theorem PUnit.ext (x y : PUnit) : x = y", "start": [207, 1], "end": [207, 64], "kind": "commanddeclaration"}, {"full_name": "Unit.ext", "code": "protected theorem Unit.ext (x y : Unit) : x = y", "start": [208, 1], "end": [208, 55], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/List/Basic.lean", "imports": ["lake-packages/std/Std/Data/Array/Init/Lemmas.lean", "lake-packages/std/Std/Tactic/NoMatch.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/Option/Init/Lemmas.lean", "lake-packages/std/Std/Classes/SetNotation.lean"], "premises": [{"full_name": "List.setTR", "code": "@[inline] def setTR (l : List \u03b1) (n : Nat) (a : \u03b1) : List \u03b1 := go l n #[] where\n  \n  go : List \u03b1 \u2192 Nat \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _, _ => l\n  | _::xs, 0, acc => acc.toListAppend (a::xs)\n  | x::xs, n+1, acc => go xs n (acc.push x)", "start": [15, 1], "end": [22, 44], "kind": "commanddeclaration"}, {"full_name": "List.set_eq_setTR", "code": "@[csimp] theorem set_eq_setTR : @set = @setTR", "start": [24, 1], "end": [31, 30], "kind": "commanddeclaration"}, {"full_name": "List.eraseTR", "code": "@[inline] def eraseTR [BEq \u03b1] (l : List \u03b1) (a : \u03b1) : List \u03b1 := go l #[] where\n  \n  go : List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _ => l\n  | x::xs, acc => bif x == a then acc.toListAppend xs else go xs (acc.push x)", "start": [33, 1], "end": [39, 78], "kind": "commanddeclaration"}, {"full_name": "List.erase_eq_eraseTR", "code": "@[csimp] theorem erase_eq_eraseTR : @List.erase = @eraseTR", "start": [41, 1], "end": [50, 35], "kind": "commanddeclaration"}, {"full_name": "List.eraseIdxTR", "code": "@[inline] def eraseIdxTR (l : List \u03b1) (n : Nat) : List \u03b1 := go l n #[] where\n  \n  go : List \u03b1 \u2192 Nat \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _, _ => l\n  | _::as, 0, acc => acc.toListAppend as\n  | a::as, n+1, acc => go as n (acc.push a)", "start": [52, 1], "end": [59, 44], "kind": "commanddeclaration"}, {"full_name": "List.eraseIdx_eq_eraseIdxTR", "code": "@[csimp] theorem eraseIdx_eq_eraseIdxTR : @eraseIdx = @eraseIdxTR", "start": [61, 1], "end": [72, 35], "kind": "commanddeclaration"}, {"full_name": "List.bindTR", "code": "@[inline] def bindTR (as : List \u03b1) (f : \u03b1 \u2192 List \u03b2) : List \u03b2 := go as #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b2 \u2192 List \u03b2\n  | [], acc => acc.toList\n  | x::xs, acc => go xs (acc ++ f x)", "start": [74, 1], "end": [79, 37], "kind": "commanddeclaration"}, {"full_name": "List.bind_eq_bindTR", "code": "@[csimp] theorem bind_eq_bindTR : @List.bind = @bindTR", "start": [81, 1], "end": [86, 25], "kind": "commanddeclaration"}, {"full_name": "List.joinTR", "code": "@[inline] def joinTR (l : List (List \u03b1)) : List \u03b1 := bindTR l id", "start": [88, 1], "end": [89, 65], "kind": "commanddeclaration"}, {"full_name": "List.join_eq_joinTR", "code": "@[csimp] theorem join_eq_joinTR : @join = @joinTR", "start": [91, 1], "end": [92, 60], "kind": "commanddeclaration"}, {"full_name": "List.filterMapTR", "code": "@[inline] def filterMapTR (f : \u03b1 \u2192 Option \u03b2) (l : List \u03b1) : List \u03b2 := go l #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b2 \u2192 List \u03b2\n  | [], acc => acc.toList\n  | a::as, acc => match f a with\n    | none => go as acc\n    | some b => go as (acc.push b)", "start": [94, 1], "end": [101, 35], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_eq_filterMapTR", "code": "@[csimp] theorem filterMap_eq_filterMapTR : @List.filterMap = @filterMapTR", "start": [103, 1], "end": [108, 24], "kind": "commanddeclaration"}, {"full_name": "List.replaceTR", "code": "@[inline] def replaceTR [BEq \u03b1] (l : List \u03b1) (b c : \u03b1) : List \u03b1 := go l #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _ => l\n  | a::as, acc => bif a == b then acc.toListAppend (c::as) else go as (acc.push a)", "start": [110, 1], "end": [116, 83], "kind": "commanddeclaration"}, {"full_name": "List.replace_eq_replaceTR", "code": "@[csimp] theorem replace_eq_replaceTR : @List.replace = @replaceTR", "start": [118, 1], "end": [127, 44], "kind": "commanddeclaration"}, {"full_name": "List.takeTR", "code": "@[inline] def takeTR (n : Nat) (l : List \u03b1) : List \u03b1 := go l n #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Nat \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _, _ => l\n  | _::_, 0, acc => acc.toList\n  | a::as, n+1, acc => go as n (acc.push a)", "start": [129, 1], "end": [136, 44], "kind": "commanddeclaration"}, {"full_name": "List.take_eq_takeTR", "code": "@[csimp] theorem take_eq_takeTR : @take = @takeTR", "start": [138, 1], "end": [146, 54], "kind": "commanddeclaration"}, {"full_name": "List.takeWhileTR", "code": "@[inline] def takeWhileTR (p : \u03b1 \u2192 Bool) (l : List \u03b1) : List \u03b1 := go l #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _ => l\n  | a::as, acc => bif p a then go as (acc.push a) else acc.toList", "start": [148, 1], "end": [154, 66], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_eq_takeWhileTR", "code": "@[csimp] theorem takeWhile_eq_takeWhileTR : @takeWhile = @takeWhileTR", "start": [156, 1], "end": [165, 44], "kind": "commanddeclaration"}, {"full_name": "List.foldrTR", "code": "@[specialize] def foldrTR (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) (l : List \u03b1) : \u03b2 := l.toArray.foldr f init", "start": [167, 1], "end": [168, 96], "kind": "commanddeclaration"}, {"full_name": "List.foldr_eq_foldrTR", "code": "@[csimp] theorem foldr_eq_foldrTR : @foldr = @foldrTR", "start": [170, 1], "end": [171, 86], "kind": "commanddeclaration"}, {"full_name": "List.zipWithTR", "code": "@[inline] def zipWithTR (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (as : List \u03b1) (bs : List \u03b2) : List \u03b3 := go as bs #[] where\n  \n  go : List \u03b1 \u2192 List \u03b2 \u2192 Array \u03b3 \u2192 List \u03b3\n  | a::as, b::bs, acc => go as bs (acc.push (f a b))\n  | _, _, acc => acc.toList", "start": [173, 1], "end": [178, 28], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_eq_zipWithTR", "code": "@[csimp] theorem zipWith_eq_zipWithTR : @zipWith = @zipWithTR", "start": [180, 1], "end": [185, 28], "kind": "commanddeclaration"}, {"full_name": "List.unzipTR", "code": "def unzipTR (l : List (\u03b1 \u00d7 \u03b2)) : List \u03b1 \u00d7 List \u03b2 :=\n  l.foldr (fun (a, b) (al, bl) => (a::al, b::bl)) ([], [])", "start": [187, 1], "end": [189, 59], "kind": "commanddeclaration"}, {"full_name": "List.unzip_eq_unzipTR", "code": "@[csimp] theorem unzip_eq_unzipTR : @unzip = @unzipTR", "start": [191, 1], "end": [192, 57], "kind": "commanddeclaration"}, {"full_name": "List.enumFromTR", "code": "def enumFromTR (n : Nat) (l : List \u03b1) : List (Nat \u00d7 \u03b1) :=\n  let arr := l.toArray\n  (arr.foldr (fun a (n, acc) => (n-1, (n-1, a) :: acc)) (n + arr.size, [])).2", "start": [194, 1], "end": [197, 78], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_eq_enumFromTR", "code": "@[csimp] theorem enumFrom_eq_enumFromTR : @enumFrom = @enumFromTR", "start": [199, 1], "end": [208, 44], "kind": "commanddeclaration"}, {"full_name": "List.replicateTR_loop_eq", "code": "theorem replicateTR_loop_eq : \u2200 n, replicateTR.loop a n acc = replicate n a ++ acc", "start": [210, 1], "end": [213, 87], "kind": "commanddeclaration"}, {"full_name": "List.dropLastTR", "code": "@[inline] def dropLastTR (l : List \u03b1) : List \u03b1 := l.toArray.pop.toList", "start": [215, 1], "end": [216, 71], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_eq_dropLastTR", "code": "@[csimp] theorem dropLast_eq_dropLastTR : @dropLast = @dropLastTR", "start": [218, 1], "end": [219, 32], "kind": "commanddeclaration"}, {"full_name": "List.intersperseTR", "code": "def intersperseTR (sep : \u03b1) : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | [x] => [x]\n  | x::y::xs => x :: sep :: y :: xs.foldr (fun a r => sep :: a :: r) []", "start": [221, 1], "end": [225, 72], "kind": "commanddeclaration"}, {"full_name": "List.intersperse_eq_intersperseTR", "code": "@[csimp] theorem intersperse_eq_intersperseTR : @intersperse = @intersperseTR", "start": [227, 1], "end": [231, 77], "kind": "commanddeclaration"}, {"full_name": "List.intercalateTR", "code": "def intercalateTR (sep : List \u03b1) : List (List \u03b1) \u2192 List \u03b1\n  | [] => []\n  | [x] => x\n  | x::xs => go sep.toArray x xs #[]\nwhere\n  \n  go (sep : Array \u03b1) : List \u03b1 \u2192 List (List \u03b1) \u2192 Array \u03b1 \u2192 List \u03b1\n  | x, [], acc => acc.toListAppend x\n  | x, y::xs, acc => go sep y xs (acc ++ x ++ sep)", "start": [233, 1], "end": [243, 51], "kind": "commanddeclaration"}, {"full_name": "List.intercalate_eq_intercalateTR", "code": "@[csimp] theorem intercalate_eq_intercalateTR : @intercalate = @intercalateTR", "start": [245, 1], "end": [255, 27], "kind": "commanddeclaration"}, {"full_name": "List.Subset", "code": "protected def Subset (l\u2081 l\u2082 : List \u03b1) := \u2200 \u2983a : \u03b1\u2984, a \u2208 l\u2081 \u2192 a \u2208 l\u2082", "start": [259, 1], "end": [262, 68], "kind": "commanddeclaration"}, {"full_name": "List.decidableBEx", "code": "instance decidableBEx (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    \u2200 l : List \u03b1, Decidable (\u2203 x \u2208 l, p x)\n  | [] => isFalse fun.\n  | x :: xs =>\n    if h\u2081 : p x then isTrue \u27e8x, .head .., h\u2081\u27e9 else\n      match decidableBEx p xs with\n      | isTrue h\u2082 => isTrue <| let \u27e8y, hm, hp\u27e9 := h\u2082; \u27e8y, .tail _ hm, hp\u27e9\n      | isFalse h\u2082 => isFalse fun\n        | \u27e8y, .tail _ h, hp\u27e9 => h\u2082 \u27e8y, h, hp\u27e9\n        | \u27e8_, .head .., hp\u27e9 => h\u2081 hp", "start": [266, 1], "end": [275, 37], "kind": "commanddeclaration"}, {"full_name": "List.decidableBAll", "code": "instance decidableBAll (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    \u2200 l : List \u03b1, Decidable (\u2200 x \u2208 l, p x)\n  | [] => isTrue fun.\n  | x :: xs =>\n    if h\u2081 : p x then\n      match decidableBAll p xs with\n      | isTrue h\u2082 => isTrue fun\n        | y, .tail _ h => h\u2082 y h\n        | _, .head .. => h\u2081\n      | isFalse h\u2082 => isFalse fun H => h\u2082 fun y hm => H y (.tail _ hm)\n    else isFalse fun H => h\u2081 <| H x (.head ..)", "start": [277, 1], "end": [287, 47], "kind": "commanddeclaration"}, {"full_name": "List.bagInter", "code": "protected def bagInter {\u03b1} [BEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | [], _ => []\n  | _, [] => []\n  | a :: l\u2081, l\u2082 => if l\u2082.elem a then a :: List.bagInter l\u2081 (l\u2082.erase a) else List.bagInter l\u2081 l\u2082", "start": [292, 1], "end": [300, 97], "kind": "commanddeclaration"}, {"full_name": "List.diff", "code": "protected def diff {\u03b1} [BEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | l, [] => l\n  | l\u2081, a :: l\u2082 => if l\u2081.elem a then List.diff (l\u2081.erase a) l\u2082 else List.diff l\u2081 l\u2082", "start": [302, 1], "end": [305, 84], "kind": "commanddeclaration"}, {"full_name": "List.tail", "code": "def tail : List \u03b1 \u2192 List \u03b1\n  | []    => []\n  | _::as => as", "start": [309, 1], "end": [312, 16], "kind": "commanddeclaration"}, {"full_name": "List.tail_nil", "code": "@[simp] theorem tail_nil : @tail \u03b1 [] = []", "start": [315, 1], "end": [315, 50], "kind": "commanddeclaration"}, {"full_name": "List.tail_cons", "code": "@[simp] theorem tail_cons : @tail \u03b1 (a::as) = as", "start": [316, 1], "end": [316, 56], "kind": "commanddeclaration"}, {"full_name": "List.next?", "code": "@[inline] def next? : List \u03b1 \u2192 Option (\u03b1 \u00d7 List \u03b1)\n  | [] => none\n  | a :: l => some (a, l)", "start": [318, 1], "end": [321, 26], "kind": "commanddeclaration"}, {"full_name": "List.mapIdx", "code": "@[inline] def mapIdx (f : Nat \u2192 \u03b1 \u2192 \u03b2) (as : List \u03b1) : List \u03b2 := go as #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b2 \u2192 List \u03b2\n  | [], acc => acc.toList\n  | a :: as, acc => go as (acc.push (f acc.size a))", "start": [323, 1], "end": [332, 52], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxM", "code": "@[inline] def mapIdxM {m : Type v \u2192 Type w} [Monad m]\n    (as : List \u03b1) (f : Nat \u2192 \u03b1 \u2192 m \u03b2) : m (List \u03b2) := go as #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b2 \u2192 m (List \u03b2)\n  | [], acc => pure acc.toList\n  | a :: as, acc => do go as (acc.push (\u2190 f acc.size a))", "start": [334, 1], "end": [341, 57], "kind": "commanddeclaration"}, {"full_name": "List.after", "code": "@[specialize] def after (p : \u03b1 \u2192 Bool) : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | x :: xs => bif p x then xs else after p xs", "start": [343, 1], "end": [353, 47], "kind": "commanddeclaration"}, {"full_name": "List.findIdx", "code": "@[inline] def findIdx (p : \u03b1 \u2192 Bool) (l : List \u03b1) : Nat := go l 0 where\n  \n  @[specialize] go : List \u03b1 \u2192 Nat \u2192 Nat\n  | [], n => n\n  | a :: l, n => bif p a then n else go l (n + 1)", "start": [355, 1], "end": [360, 50], "kind": "commanddeclaration"}, {"full_name": "List.indexOf", "code": "def indexOf [BEq \u03b1] (a : \u03b1) : List \u03b1 \u2192 Nat := findIdx (a == \u00b7)", "start": [362, 1], "end": [363, 63], "kind": "commanddeclaration"}, {"full_name": "List.removeNth", "code": "@[simp] def removeNth : List \u03b1 \u2192 Nat \u2192 List \u03b1\n  | [], _ => []\n  | _ :: xs, 0 => xs\n  | x :: xs, i+1 => x :: removeNth xs i", "start": [365, 1], "end": [369, 40], "kind": "commanddeclaration"}, {"full_name": "List.removeNthTR", "code": "@[inline] def removeNthTR (l : List \u03b1) (n : Nat) : List \u03b1 := go l n #[] where\n  \n  go : List \u03b1 \u2192 Nat \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _, _ => l\n  | _ :: xs, 0, acc => acc.toListAppend xs\n  | x :: xs, i+1, acc => go xs i (acc.push x)", "start": [371, 1], "end": [378, 46], "kind": "commanddeclaration"}, {"full_name": "List.removeNth_eq_removeNthTR", "code": "@[csimp] theorem removeNth_eq_removeNthTR : @removeNth = @removeNthTR", "start": [380, 1], "end": [389, 44], "kind": "commanddeclaration"}, {"full_name": "List.replaceF", "code": "@[simp] def replaceF (f : \u03b1 \u2192 Option \u03b1) : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | x :: xs => match f x with\n    | none => x :: replaceF f xs\n    | some a => a :: xs", "start": [391, 1], "end": [396, 24], "kind": "commanddeclaration"}, {"full_name": "List.replaceFTR", "code": "@[inline] def replaceFTR (f : \u03b1 \u2192 Option \u03b1) (l : List \u03b1) : List \u03b1 := go l #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], acc => acc.toList\n  | x :: xs, acc => match f x with\n    | none => go xs (acc.push x)\n    | some a' => acc.toListAppend (a' :: xs)", "start": [398, 1], "end": [405, 45], "kind": "commanddeclaration"}, {"full_name": "List.replaceF_eq_replaceFTR", "code": "@[csimp] theorem replaceF_eq_replaceFTR : @replaceF = @replaceFTR", "start": [407, 1], "end": [414, 24], "kind": "commanddeclaration"}, {"full_name": "List.insert", "code": "@[inline] protected def insert [DecidableEq \u03b1] (a : \u03b1) (l : List \u03b1) : List \u03b1 :=\n  if a \u2208 l then l else a :: l", "start": [416, 1], "end": [418, 30], "kind": "commanddeclaration"}, {"full_name": "List.union", "code": "@[inline] protected def union [DecidableEq \u03b1] (l\u2081 l\u2082 : List \u03b1) : List \u03b1 := foldr .insert l\u2082 l\u2081", "start": [420, 1], "end": [425, 95], "kind": "commanddeclaration"}, {"full_name": "List.inter", "code": "@[inline] protected def inter [DecidableEq \u03b1] (l\u2081 l\u2082 : List \u03b1) : List \u03b1 := filter (\u00b7 \u2208 l\u2082) l\u2081", "start": [429, 1], "end": [433, 94], "kind": "commanddeclaration"}, {"full_name": "List.Sublist", "code": "inductive Sublist {\u03b1} : List \u03b1 \u2192 List \u03b1 \u2192 Prop\n  \n  | slnil : Sublist [] []\n  \n  | cons a : Sublist l\u2081 l\u2082 \u2192 Sublist l\u2081 (a :: l\u2082)\n  \n  | cons\u2082 a : Sublist l\u2081 l\u2082 \u2192 Sublist (a :: l\u2081) (a :: l\u2082)", "start": [437, 1], "end": [444, 58], "kind": "commanddeclaration"}, {"full_name": "List.isSublist", "code": "def isSublist [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n  | [], _ => true\n  | _, [] => false\n  | l\u2081@(hd\u2081::tl\u2081), hd\u2082::tl\u2082 =>\n    if hd\u2081 = hd\u2082\n    then tl\u2081.isSublist tl\u2082\n    else l\u2081.isSublist tl\u2082", "start": [448, 1], "end": [455, 26], "kind": "commanddeclaration"}, {"full_name": "List.splitAt", "code": "def splitAt (n : Nat) (l : List \u03b1) : List \u03b1 \u00d7 List \u03b1 := go l n #[] where\n  \n  go : List \u03b1 \u2192 Nat \u2192 Array \u03b1 \u2192 List \u03b1 \u00d7 List \u03b1\n  | [], _, _ => (l, [])\n  | x :: xs, n+1, acc => go xs n (acc.push x)\n  | xs, _, acc => (acc.toList, xs)", "start": [457, 1], "end": [469, 35], "kind": "commanddeclaration"}, {"full_name": "List.splitAtD", "code": "def splitAtD (n : Nat) (l : List \u03b1) (dflt : \u03b1) : List \u03b1 \u00d7 List \u03b1 := go n l #[] where\n  \n  go : Nat \u2192 List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1 \u00d7 List \u03b1\n  | n+1, x :: xs, acc => go n xs (acc.push x)\n  | 0, xs, acc => (acc.toList, xs)\n  | n, [], acc => (acc.toListAppend (replicate n dflt), [])", "start": [471, 1], "end": [485, 60], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP", "code": "def splitOnP (P : \u03b1 \u2192 Bool) (l : List \u03b1) : List (List \u03b1) := go l [] where\n  \n  go : List \u03b1 \u2192 List \u03b1 \u2192 List (List \u03b1)\n  | [], acc => [acc.reverse]\n  | a :: t, acc => if P a then acc.reverse :: go t [] else go t (a::acc)", "start": [487, 1], "end": [498, 73], "kind": "commanddeclaration"}, {"full_name": "List.splitOnPTR", "code": "@[inline] def splitOnPTR (P : \u03b1 \u2192 Bool) (l : List \u03b1) : List (List \u03b1) := go l #[] #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b1 \u2192 Array (List \u03b1) \u2192 List (List \u03b1)\n  | [], acc, r => r.toListAppend [acc.toList]\n  | a :: t, acc, r => bif P a then go t #[] (r.push acc.toList) else go t (acc.push a) r", "start": [500, 1], "end": [506, 89], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP_eq_splitOnPTR", "code": "@[csimp] theorem splitOnP_eq_splitOnPTR : @splitOnP = @splitOnPTR", "start": [508, 1], "end": [513, 43], "kind": "commanddeclaration"}, {"full_name": "List.splitOn", "code": "@[inline] def splitOn [BEq \u03b1] (a : \u03b1) (as : List \u03b1) : List (List \u03b1) := as.splitOnP (\u00b7 == a)", "start": [515, 1], "end": [521, 92], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTail", "code": "@[simp] def modifyNthTail (f : List \u03b1 \u2192 List \u03b1) : Nat \u2192 List \u03b1 \u2192 List \u03b1\n  | 0, l => f l\n  | _+1, [] => []\n  | n+1, a :: l => a :: modifyNthTail f n l", "start": [523, 1], "end": [533, 44], "kind": "commanddeclaration"}, {"full_name": "List.modifyHead", "code": "@[simp, inline] def modifyHead (f : \u03b1 \u2192 \u03b1) : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | a :: l => f a :: l", "start": [535, 1], "end": [538, 23], "kind": "commanddeclaration"}, {"full_name": "List.modifyNth", "code": "def modifyNth (f : \u03b1 \u2192 \u03b1) : Nat \u2192 List \u03b1 \u2192 List \u03b1 :=\n  modifyNthTail (modifyHead f)", "start": [540, 1], "end": [542, 31], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTR", "code": "def modifyNthTR (f : \u03b1 \u2192 \u03b1) (n : Nat) (l : List \u03b1) : List \u03b1 := go l n #[] where\n  \n  go : List \u03b1 \u2192 Nat \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _, acc => acc.toList\n  | a :: l, 0, acc => acc.toListAppend (f a :: l)\n  | a :: l, n+1, acc => go l n (acc.push a)", "start": [544, 1], "end": [550, 44], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTR_go_eq", "code": "theorem modifyNthTR_go_eq : \u2200 l n, modifyNthTR.go f l n acc = acc.data ++ modifyNth f n l", "start": [552, 1], "end": [555, 76], "kind": "commanddeclaration"}, {"full_name": "List.modifyNth_eq_modifyNthTR", "code": "@[csimp] theorem modifyNth_eq_modifyNthTR : @modifyNth = @modifyNthTR", "start": [557, 1], "end": [558, 56], "kind": "commanddeclaration"}, {"full_name": "List.modifyLast", "code": "@[inline] def modifyLast (f : \u03b1 \u2192 \u03b1) (l : List \u03b1) : List \u03b1 := go l #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _ => []\n  | [x], acc => acc.toListAppend [f x]\n  | x :: xs, acc => go xs (acc.push x)", "start": [560, 1], "end": [566, 39], "kind": "commanddeclaration"}, {"full_name": "List.insertNth", "code": "def insertNth (n : Nat) (a : \u03b1) : List \u03b1 \u2192 List \u03b1 :=\n  modifyNthTail (cons a) n", "start": [568, 1], "end": [575, 27], "kind": "commanddeclaration"}, {"full_name": "List.insertNthTR", "code": "@[inline] def insertNthTR (n : Nat) (a : \u03b1) (l : List \u03b1) : List \u03b1 := go n l #[] where\n  \n  go : Nat \u2192 List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | 0, l, acc => acc.toListAppend (a :: l)\n  | _, [], acc => acc.toList\n  | n+1, a :: l, acc => go n l (acc.push a)", "start": [577, 1], "end": [583, 44], "kind": "commanddeclaration"}, {"full_name": "List.insertNthTR_go_eq", "code": "theorem insertNthTR_go_eq : \u2200 n l, insertNthTR.go a n l acc = acc.data ++ insertNth n a l", "start": [585, 1], "end": [587, 78], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_eq_insertNthTR", "code": "@[csimp] theorem insertNth_eq_insertNthTR : @insertNth = @insertNthTR", "start": [589, 1], "end": [590, 56], "kind": "commanddeclaration"}, {"full_name": "List.headD_eq_head?", "code": "@[simp] theorem headD_eq_head? (l) (a : \u03b1) : headD l a = (head? l).getD a", "start": [592, 1], "end": [592, 96], "kind": "commanddeclaration"}, {"full_name": "List.takeD", "code": "def takeD : Nat \u2192 List \u03b1 \u2192 \u03b1 \u2192 List \u03b1\n  | 0, _, _ => []\n  | n+1, l, x => l.headD x :: takeD n l.tail x", "start": [594, 1], "end": [600, 47], "kind": "commanddeclaration"}, {"full_name": "List.takeD_zero", "code": "@[simp] theorem takeD_zero (l) (a : \u03b1) : takeD 0 l a = []", "start": [602, 1], "end": [602, 65], "kind": "commanddeclaration"}, {"full_name": "List.takeD_succ", "code": "@[simp] theorem takeD_succ (l) (a : \u03b1) :\n    takeD (n+1) l a = l.head?.getD a :: takeD n l.tail a", "start": [603, 1], "end": [604, 76], "kind": "commanddeclaration"}, {"full_name": "List.takeD_nil", "code": "@[simp] theorem takeD_nil (n) (a : \u03b1) : takeD n [] a = replicate n a", "start": [606, 1], "end": [606, 100], "kind": "commanddeclaration"}, {"full_name": "List.takeDTR", "code": "def takeDTR (n : Nat) (l : List \u03b1) (dflt : \u03b1) : List \u03b1 := go n l #[] where\n  \n  go : Nat \u2192 List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | n+1, x :: xs, acc => go n xs (acc.push x)\n  | 0, _, acc => acc.toList\n  | n, [], acc => acc.toListAppend (replicate n dflt)", "start": [608, 1], "end": [614, 54], "kind": "commanddeclaration"}, {"full_name": "List.takeDTR_go_eq", "code": "theorem takeDTR_go_eq : \u2200 n l, takeDTR.go dflt n l acc = acc.data ++ takeD n l dflt", "start": [616, 1], "end": [619, 57], "kind": "commanddeclaration"}, {"full_name": "List.takeD_eq_takeDTR", "code": "@[csimp] theorem takeD_eq_takeDTR : @takeD = @takeDTR", "start": [621, 1], "end": [622, 48], "kind": "commanddeclaration"}, {"full_name": "List.leftpad", "code": "def leftpad (n : Nat) (a : \u03b1) (l : List \u03b1) : List \u03b1 := replicate (n - length l) a ++ l", "start": [624, 1], "end": [628, 87], "kind": "commanddeclaration"}, {"full_name": "List.leftpadTR", "code": "@[inline] def leftpadTR (n : Nat) (a : \u03b1) (l : List \u03b1) : List \u03b1 :=\n  replicateTR.loop a (n - length l) l", "start": [630, 1], "end": [632, 38], "kind": "commanddeclaration"}, {"full_name": "List.leftpad_eq_leftpadTR", "code": "@[csimp] theorem leftpad_eq_leftpadTR : @leftpad = @leftpadTR", "start": [634, 1], "end": [635, 65], "kind": "commanddeclaration"}, {"full_name": "List.scanl", "code": "@[simp] def scanl (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a : \u03b1) : List \u03b2 \u2192 List \u03b1\n  | [] => [a]\n  | b :: l => a :: scanl f (f a b) l", "start": [637, 1], "end": [645, 37], "kind": "commanddeclaration"}, {"full_name": "List.scanlTR", "code": "@[inline] def scanlTR (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a : \u03b1) (l : List \u03b2) : List \u03b1 := go l a #[] where\n  \n  @[specialize] go : List \u03b2 \u2192 \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], a, acc => acc.toListAppend [a]\n  | b :: l, a, acc => go l (f a b) (acc.push a)", "start": [647, 1], "end": [652, 48], "kind": "commanddeclaration"}, {"full_name": "List.scanlTR_go_eq", "code": "theorem scanlTR_go_eq : \u2200 l, scanlTR.go f l a acc = acc.data ++ scanl f a l", "start": [654, 1], "end": [656, 59], "kind": "commanddeclaration"}, {"full_name": "List.scanl_eq_scanlTR", "code": "@[csimp] theorem scanl_eq_scanlTR : @scanl = @scanlTR", "start": [658, 1], "end": [659, 48], "kind": "commanddeclaration"}, {"full_name": "List.scanr", "code": "def scanr (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) (l : List \u03b1) : List \u03b2 :=\n  let (b', l') := l.foldr (fun a (b', l') => (f a b', b' :: l')) (b, [])\n  b' :: l'", "start": [661, 1], "end": [669, 11], "kind": "commanddeclaration"}, {"full_name": "List.partitionMap", "code": "@[inline] def partitionMap (f : \u03b1 \u2192 \u03b2 \u2295 \u03b3) (l : List \u03b1) : List \u03b2 \u00d7 List \u03b3 := go l #[] #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b2 \u2192 Array \u03b3 \u2192 List \u03b2 \u00d7 List \u03b3\n  | [], acc\u2081, acc\u2082 => (acc\u2081.toList, acc\u2082.toList)\n  | x :: xs, acc\u2081, acc\u2082 =>\n    match f x with\n    | .inl a => go xs (acc\u2081.push a) acc\u2082\n    | .inr b => go xs acc\u2081 (acc\u2082.push b)", "start": [671, 1], "end": [688, 41], "kind": "commanddeclaration"}, {"full_name": "List.partitionM", "code": "@[inline] def partitionM [Monad m] (p : \u03b1 \u2192 m Bool) (l : List \u03b1) : m (List \u03b1 \u00d7 List \u03b1) :=\n  go l #[] #[]\nwhere\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b1 \u2192 Array \u03b1 \u2192 m (List \u03b1 \u00d7 List \u03b1)\n  | [], acc\u2081, acc\u2082 => pure (acc\u2081.toList, acc\u2082.toList)\n  | x :: xs, acc\u2081, acc\u2082 => do\n    if \u2190 p x then\n      go xs (acc\u2081.push x) acc\u2082\n    else\n      go xs acc\u2081 (acc\u2082.push x)", "start": [690, 1], "end": [703, 31], "kind": "commanddeclaration"}, {"full_name": "List.foldlIdx", "code": "@[simp, specialize] def foldlIdx (f : Nat \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b1) (init : \u03b1) : List \u03b2 \u2192 (start : _ := 0) \u2192 \u03b1\n  | [], _ => init\n  | b :: l, i => foldlIdx f (f i init b) l (i+1)", "start": [705, 1], "end": [711, 49], "kind": "commanddeclaration"}, {"full_name": "List.foldrIdx", "code": "@[simp, specialize] def foldrIdx (f : Nat \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) :\n    (l : List \u03b1) \u2192 (start : _ := 0) \u2192 \u03b2\n  | [], _ => init\n  | a :: l, i => f i a (foldrIdx f init l (i+1))", "start": [713, 1], "end": [721, 49], "kind": "commanddeclaration"}, {"full_name": "List.findIdxs", "code": "@[inline] def findIdxs (p : \u03b1 \u2192 Bool) (l : List \u03b1) : List Nat :=\n  foldrIdx (fun i a is => if p a then i :: is else is) [] l", "start": [723, 1], "end": [725, 60], "kind": "commanddeclaration"}, {"full_name": "List.indexesValues", "code": "@[inline] def indexesValues (p : \u03b1 \u2192 Bool) (l : List \u03b1) : List (Nat \u00d7 \u03b1) :=\n  foldrIdx (fun i a l => if p a then (i, a) :: l else l) [] l", "start": [727, 1], "end": [732, 62], "kind": "commanddeclaration"}, {"full_name": "List.indexesOf", "code": "@[inline] def indexesOf [BEq \u03b1] (a : \u03b1) : List \u03b1 \u2192 List Nat := findIdxs (\u00b7 == a)", "start": [734, 1], "end": [740, 81], "kind": "commanddeclaration"}, {"full_name": "List.findIdx?", "code": "def findIdx? (p : \u03b1 \u2192 Bool) : List \u03b1 \u2192 (start : Nat := 0) \u2192 Option Nat\n| [], _ => none\n| a :: l, i => if p a then some i else findIdx? p l (i + 1)", "start": [742, 1], "end": [745, 60], "kind": "commanddeclaration"}, {"full_name": "List.indexOf?", "code": "@[inline] def indexOf? [BEq \u03b1] (a : \u03b1) : List \u03b1 \u2192 Option Nat := findIdx? (a == \u00b7)", "start": [747, 1], "end": [748, 82], "kind": "commanddeclaration"}, {"full_name": "List.pmap", "code": "@[simp] def pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) : \u2200 l : List \u03b1, (\u2200 a \u2208 l, p a) \u2192 List \u03b2\n  | [], _ => []\n  | a :: l, H => f a (forall_mem_cons.1 H).1 :: pmap f l (forall_mem_cons.1 H).2", "start": [750, 1], "end": [756, 81], "kind": "commanddeclaration"}, {"full_name": "List.attachImpl", "code": "@[inline] private unsafe def attachImpl (l : List \u03b1) : List {x // x \u2208 l} := unsafeCast l", "start": [758, 1], "end": [763, 89], "kind": "commanddeclaration"}, {"full_name": "List.attach", "code": "@[implemented_by attachImpl] def attach (l : List \u03b1) : List {x // x \u2208 l} :=\n  pmap Subtype.mk l fun _ => id", "start": [765, 1], "end": [768, 32], "kind": "commanddeclaration"}, {"full_name": "List.pmapImpl", "code": "@[inline] private def pmapImpl {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (l : List \u03b1) (h : \u2200 a \u2208 l, p a) :\n    List \u03b2 := l.attach.map fun \u27e8x, h'\u27e9 => f x (h _ h')", "start": [770, 1], "end": [772, 55], "kind": "commanddeclaration"}, {"full_name": "List.pmap_eq_pmapImpl", "code": "@[csimp] private theorem pmap_eq_pmapImpl : @pmap = @pmapImpl", "start": [774, 1], "end": [781, 28], "kind": "commanddeclaration"}, {"full_name": "List.lookmap", "code": "@[inline] def lookmap (f : \u03b1 \u2192 Option \u03b1) (l : List \u03b1) : List \u03b1 := go l #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], acc => acc.toList\n  | a :: l, acc => match f a with\n    | some b => acc.toListAppend (b :: l)\n    | none => go l (acc.push a)", "start": [783, 1], "end": [794, 32], "kind": "commanddeclaration"}, {"full_name": "List.countP", "code": "@[inline] def countP (p : \u03b1 \u2192 Bool) (l : List \u03b1) : Nat := go l 0 where\n  \n  @[specialize] go : List \u03b1 \u2192 Nat \u2192 Nat\n  | [], acc => acc\n  | x :: xs, acc => bif p x then go xs (acc + 1) else go xs acc", "start": [796, 1], "end": [801, 64], "kind": "commanddeclaration"}, {"full_name": "List.count", "code": "@[inline] def count [BEq \u03b1] (a : \u03b1) : List \u03b1 \u2192 Nat := countP (\u00b7 == a)", "start": [803, 1], "end": [804, 70], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix", "code": "def IsPrefix (l\u2081 : List \u03b1) (l\u2082 : List \u03b1) : Prop := \u2203 t, l\u2081 ++ t = l\u2082", "start": [806, 1], "end": [810, 69], "kind": "commanddeclaration"}, {"full_name": "List.IsSuffix", "code": "def IsSuffix (l\u2081 : List \u03b1) (l\u2082 : List \u03b1) : Prop := \u2203 t, t ++ l\u2081 = l\u2082", "start": [812, 1], "end": [816, 69], "kind": "commanddeclaration"}, {"full_name": "List.IsInfix", "code": "def IsInfix (l\u2081 : List \u03b1) (l\u2082 : List \u03b1) : Prop := \u2203 s t, s ++ l\u2081 ++ t = l\u2082", "start": [818, 1], "end": [822, 75], "kind": "commanddeclaration"}, {"full_name": "List.inits", "code": "@[simp] def inits : List \u03b1 \u2192 List (List \u03b1)\n  | [] => [[]]\n  | a :: l => [] :: map (fun t => a :: t) (inits l)", "start": [830, 1], "end": [838, 52], "kind": "commanddeclaration"}, {"full_name": "List.initsTR", "code": "def initsTR (l : List \u03b1) : List (List \u03b1) :=\n  l.foldr (fun a arrs => (arrs.map fun t => a :: t).push []) #[[]] |>.toListRev", "start": [840, 1], "end": [842, 80], "kind": "commanddeclaration"}, {"full_name": "List.inits_eq_initsTR", "code": "@[csimp] theorem inits_eq_initsTR : @inits = @initsTR", "start": [844, 1], "end": [845, 68], "kind": "commanddeclaration"}, {"full_name": "List.tails", "code": "@[simp] def tails : List \u03b1 \u2192 List (List \u03b1)\n  | [] => [[]]\n  | a :: l => (a :: l) :: tails l", "start": [847, 1], "end": [855, 34], "kind": "commanddeclaration"}, {"full_name": "List.tailsTR", "code": "def tailsTR (l : List \u03b1) : List (List \u03b1) := go l #[] where\n  \n  go (l : List \u03b1) (acc : Array (List \u03b1)) : List (List \u03b1) :=\n    match l with\n    | [] => acc.toListAppend [[]]\n    | _::xs => go xs (acc.push l)", "start": [857, 1], "end": [863, 34], "kind": "commanddeclaration"}, {"full_name": "List.tails_eq_tailsTR", "code": "@[csimp] theorem tails_eq_tailsTR : @tails = @tailsTR", "start": [865, 1], "end": [869, 20], "kind": "commanddeclaration"}, {"full_name": "List.sublists'", "code": "def sublists' (l : List \u03b1) : List (List \u03b1) :=\n  let f a arr := arr.foldl (init := arr) fun r l => r.push (a :: l)\n  (l.foldr f #[[]]).toList", "start": [871, 1], "end": [882, 27], "kind": "commanddeclaration"}, {"full_name": "List.sublists", "code": "def sublists (l : List \u03b1) : List (List \u03b1) :=\n  let f a arr := arr.foldl (init := Array.mkEmpty (arr.size * 2))\n    fun r l => (r.push l).push (a :: l)\n  (l.foldr f #[[]]).toList", "start": [884, 1], "end": [894, 27], "kind": "commanddeclaration"}, {"full_name": "List.Forall\u2082", "code": "inductive Forall\u2082 (R : \u03b1 \u2192 \u03b2 \u2192 Prop) : List \u03b1 \u2192 List \u03b2 \u2192 Prop\n  \n  | nil : Forall\u2082 R [] []\n  \n  | cons {a b l\u2081 l\u2082} : R a b \u2192 Forall\u2082 R l\u2081 l\u2082 \u2192 Forall\u2082 R (a :: l\u2081) (b :: l\u2082)", "start": [900, 1], "end": [910, 79], "kind": "commanddeclaration"}, {"full_name": "List.transpose", "code": "def transpose (l : List (List \u03b1)) : List (List \u03b1) := (l.foldr go #[]).toList where\n  \n  pop (old : List \u03b1) : StateM (List \u03b1) (List \u03b1)\n    | [] => (old, [])\n    | a :: l => (a :: old, l)\n\n  \n  go (l : List \u03b1) (acc : Array (List \u03b1)) : Array (List \u03b1) :=\n    let (acc, l) := acc.mapM pop l\n    l.foldl (init := acc) fun arr a => arr.push [a]", "start": [916, 1], "end": [942, 52], "kind": "commanddeclaration"}, {"full_name": "List.sections", "code": "@[simp] def sections : List (List \u03b1) \u2192 List (List \u03b1)\n  | [] => [[]]\n  | l :: L => (sections L).bind fun s => l.map fun a => a :: s", "start": [944, 1], "end": [951, 63], "kind": "commanddeclaration"}, {"full_name": "List.sectionsTR", "code": "def sectionsTR (L : List (List \u03b1)) : List (List \u03b1) :=\n  bif L.any isEmpty then [] else (L.foldr go #[[]]).toList\nwhere\n  \n  go (l : List \u03b1) (acc : Array (List \u03b1)) : Array (List \u03b1) :=\n    acc.foldl (init := #[]) fun acc' l' =>\n      l.foldl (init := acc') fun acc' a =>\n        acc'.push (a :: l')", "start": [953, 1], "end": [962, 28], "kind": "commanddeclaration"}, {"full_name": "List.sections_eq_nil_of_isEmpty", "code": "theorem sections_eq_nil_of_isEmpty : \u2200 {L}, L.any isEmpty \u2192 @sections \u03b1 L = []", "start": [964, 1], "end": [969, 65], "kind": "commanddeclaration"}, {"full_name": "List.sections_eq_sectionsTR", "code": "@[csimp] theorem sections_eq_sectionsTR : @sections = @sectionsTR", "start": [971, 1], "end": [977, 40], "kind": "commanddeclaration"}, {"full_name": "List.eraseP", "code": "def eraseP (p : \u03b1 \u2192 Bool) : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | a :: l => bif p a then l else a :: eraseP p l", "start": [979, 1], "end": [982, 50], "kind": "commanddeclaration"}, {"full_name": "List.erasePTR", "code": "@[inline] def erasePTR (p : \u03b1 \u2192 Bool) (l : List \u03b1) : List \u03b1 := go l #[] where\n  \n  @[specialize] go : List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _ => l\n  | a :: l, acc => bif p a then acc.toListAppend l else go l (acc.push a)", "start": [984, 1], "end": [990, 74], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_eq_erasePTR", "code": "@[csimp] theorem eraseP_eq_erasePTR : @eraseP = @erasePTR", "start": [992, 1], "end": [1000, 28], "kind": "commanddeclaration"}, {"full_name": "List.extractP", "code": "def extractP (p : \u03b1 \u2192 Bool) (l : List \u03b1) : Option \u03b1 \u00d7 List \u03b1 := go l #[] where\n  \n  go : List \u03b1 \u2192 Array \u03b1 \u2192 Option \u03b1 \u00d7 List \u03b1\n  | [], _ => (none, l)\n  | a :: l, acc => bif p a then (some a, acc.toListAppend l) else go l (acc.push a)", "start": [1002, 1], "end": [1012, 84], "kind": "commanddeclaration"}, {"full_name": "List.revzip", "code": "def revzip (l : List \u03b1) : List (\u03b1 \u00d7 \u03b1) := zip l l.reverse", "start": [1014, 1], "end": [1021, 58], "kind": "commanddeclaration"}, {"full_name": "List.product", "code": "def product (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) : List (\u03b1 \u00d7 \u03b2) := l\u2081.bind fun a => l\u2082.map (Prod.mk a)", "start": [1023, 1], "end": [1029, 94], "kind": "commanddeclaration"}, {"full_name": "List.productTR", "code": "def productTR (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) : List (\u03b1 \u00d7 \u03b2) :=\n  l\u2081.foldl (fun acc a => l\u2082.foldl (fun acc b => acc.push (a, b)) acc) #[] |>.toList", "start": [1031, 1], "end": [1033, 84], "kind": "commanddeclaration"}, {"full_name": "List.product_eq_productTR", "code": "@[csimp] theorem product_eq_productTR : @product = @productTR", "start": [1035, 1], "end": [1038, 40], "kind": "commanddeclaration"}, {"full_name": "List.sigma", "code": "protected def sigma {\u03c3 : \u03b1 \u2192 Type _} (l\u2081 : List \u03b1) (l\u2082 : \u2200 a, List (\u03c3 a)) : List (\u03a3 a, \u03c3 a) :=\n  l\u2081.bind fun a => (l\u2082 a).map (Sigma.mk a)", "start": [1040, 1], "end": [1045, 43], "kind": "commanddeclaration"}, {"full_name": "List.sigmaTR", "code": "def sigmaTR {\u03c3 : \u03b1 \u2192 Type _} (l\u2081 : List \u03b1) (l\u2082 : \u2200 a, List (\u03c3 a)) : List (\u03a3 a, \u03c3 a) :=\n  l\u2081.foldl (fun acc a => (l\u2082 a).foldl (fun acc b => acc.push \u27e8a, b\u27e9) acc) #[] |>.toList", "start": [1047, 1], "end": [1049, 88], "kind": "commanddeclaration"}, {"full_name": "List.sigma_eq_sigmaTR", "code": "@[csimp] theorem sigma_eq_sigmaTR : @List.sigma = @sigmaTR", "start": [1051, 1], "end": [1054, 40], "kind": "commanddeclaration"}, {"full_name": "List.ofFn", "code": "def ofFn {n} (f : Fin n \u2192 \u03b1) : List \u03b1 := (Array.ofFn f).toList", "start": [1056, 1], "end": [1062, 63], "kind": "commanddeclaration"}, {"full_name": "List.ofFnNthVal", "code": "def ofFnNthVal {n} (f : Fin n \u2192 \u03b1) (i : Nat) : Option \u03b1 :=\n  if h : i < n then some (f \u27e8i, h\u27e9) else none", "start": [1064, 1], "end": [1066, 46], "kind": "commanddeclaration"}, {"full_name": "List.Disjoint", "code": "def Disjoint (l\u2081 l\u2082 : List \u03b1) : Prop :=\n  \u2200 \u2983a\u2984, a \u2208 l\u2081 \u2192 a \u2208 l\u2082 \u2192 False", "start": [1068, 1], "end": [1070, 33], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile\u2082", "code": "def takeWhile\u2082 (R : \u03b1 \u2192 \u03b2 \u2192 Bool) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b1 \u00d7 List \u03b2\n  | a::as, b::bs => if R a b then\n      let (as', bs') := takeWhile\u2082 R as bs\n      (a::as', b::bs')\n    else ([], [])\n  | _, _ => ([], [])", "start": [1072, 1], "end": [1083, 21], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile\u2082TR", "code": "@[inline] def takeWhile\u2082TR (R : \u03b1 \u2192 \u03b2 \u2192 Bool) (as : List \u03b1) (bs : List \u03b2) : List \u03b1 \u00d7 List \u03b2 :=\n  go as bs [] []\nwhere\n  \n  @[specialize] go : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b1 \u2192 List \u03b2 \u2192 List \u03b1 \u00d7 List \u03b2\n  | a::as, b::bs, acca, accb =>\n    bif R a b then go as bs (a::acca) (b::accb) else (acca.reverse, accb.reverse)\n  | _, _, acca, accb => (acca.reverse, accb.reverse)", "start": [1085, 1], "end": [1095, 53], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile\u2082_eq_takeWhile\u2082TR", "code": "@[csimp] theorem takeWhile\u2082_eq_takeWhile\u2082TR : @takeWhile\u2082 = @takeWhile\u2082TR", "start": [1097, 1], "end": [1103, 30], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise", "code": "inductive Pairwise : List \u03b1 \u2192 Prop\n  \n  | nil : Pairwise []\n  \n  | cons : \u2200 {a : \u03b1} {l : List \u03b1}, (\u2200 a' \u2208 l, R a a') \u2192 Pairwise l \u2192 Pairwise (a :: l)", "start": [1109, 1], "end": [1123, 87], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_cons", "code": "@[simp] theorem pairwise_cons : Pairwise R (a::l) \u2194 (\u2200 a' \u2208 l, R a a') \u2227 Pairwise R l", "start": [1129, 1], "end": [1130, 62], "kind": "commanddeclaration"}, {"full_name": "List.instDecidablePairwise", "code": "instance instDecidablePairwise [DecidableRel R] :\n    (l : List \u03b1) \u2192 Decidable (Pairwise R l)\n  | [] => isTrue .nil\n  | hd :: tl =>\n    match instDecidablePairwise tl with\n    | isTrue ht =>\n      match decidableBAll (R hd) tl with\n      | isFalse hf => isFalse fun hf' => hf (pairwise_cons.1 hf').1\n      | isTrue ht' => isTrue <| pairwise_cons.mpr (And.intro ht' ht)\n    | isFalse hf => isFalse fun | .cons _ ih => hf ih", "start": [1132, 1], "end": [1141, 54], "kind": "commanddeclaration"}, {"full_name": "List.pwFilter", "code": "def pwFilter (R : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel R] (l : List \u03b1) : List \u03b1 :=\n  l.foldr (fun x IH => if \u2200 y \u2208 IH, R x y then x :: IH else IH) []", "start": [1145, 1], "end": [1154, 67], "kind": "commanddeclaration"}, {"full_name": "List.Chain", "code": "inductive Chain : \u03b1 \u2192 List \u03b1 \u2192 Prop\n  \n  | nil {a : \u03b1} : Chain a []\n  \n  | cons : \u2200 {a b : \u03b1} {l : List \u03b1}, R a b \u2192 Chain b l \u2192 Chain a (b :: l)", "start": [1160, 1], "end": [1168, 74], "kind": "commanddeclaration"}, {"full_name": "List.Chain'", "code": "def Chain' : List \u03b1 \u2192 Prop\n  | [] => True\n  | a :: l => Chain R a l", "start": [1170, 1], "end": [1176, 26], "kind": "commanddeclaration"}, {"full_name": "List.Nodup", "code": "def Nodup : List \u03b1 \u2192 Prop := Pairwise (\u00b7 \u2260 \u00b7)", "start": [1180, 1], "end": [1182, 46], "kind": "commanddeclaration"}, {"full_name": "List.nodupDecidable", "code": "instance nodupDecidable [DecidableEq \u03b1] : \u2200 l : List \u03b1, Decidable (Nodup l) :=\n  instDecidablePairwise", "start": [1184, 1], "end": [1185, 24], "kind": "commanddeclaration"}, {"full_name": "List.eraseDup", "code": "@[inline] def eraseDup [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 := pwFilter (\u00b7 \u2260 \u00b7)", "start": [1187, 1], "end": [1191, 77], "kind": "commanddeclaration"}, {"full_name": "List.range'", "code": "def range' : (start len : Nat) \u2192 (step : Nat := 1) \u2192 List Nat\n  | _, 0, _ => []\n  | s, n+1, step => s :: range' (s+step) n step", "start": [1193, 1], "end": [1197, 48], "kind": "commanddeclaration"}, {"full_name": "List.range'TR", "code": "@[inline] def range'TR (s n : Nat) (step : Nat := 1) : List Nat := go n (s + step * n) [] where\n  \n  go : Nat \u2192 Nat \u2192 List Nat \u2192 List Nat\n  | 0, _, acc => acc\n  | n+1, e, acc => go n (e-step) ((e-step) :: acc)", "start": [1199, 1], "end": [1204, 51], "kind": "commanddeclaration"}, {"full_name": "List.range'_eq_range'TR", "code": "@[csimp] theorem range'_eq_range'TR : @range' = @range'TR", "start": [1206, 1], "end": [1215, 24], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption", "code": "@[inline] def reduceOption {\u03b1} : List (Option \u03b1) \u2192 List \u03b1 :=\n  List.filterMap id", "start": [1217, 1], "end": [1219, 20], "kind": "commanddeclaration"}, {"full_name": "List.ilast'", "code": "@[simp] def ilast' {\u03b1} : \u03b1 \u2192 List \u03b1 \u2192 \u03b1\n  | a, [] => a\n  | _, b :: l => ilast' b l", "start": [1221, 1], "end": [1226, 28], "kind": "commanddeclaration"}, {"full_name": "List.last'", "code": "@[simp] def last' {\u03b1} : List \u03b1 \u2192 Option \u03b1\n  | [] => none\n  | [a] => some a\n  | _ :: l => last' l", "start": [1228, 1], "end": [1234, 22], "kind": "commanddeclaration"}, {"full_name": "List.rotate", "code": "@[inline] def rotate (l : List \u03b1) (n : Nat) : List \u03b1 :=\n  let (l\u2081, l\u2082) := List.splitAt (n % l.length) l\n  l\u2082 ++ l\u2081", "start": [1236, 1], "end": [1244, 11], "kind": "commanddeclaration"}, {"full_name": "List.rotate'", "code": "@[simp] def rotate' : List \u03b1 \u2192 Nat \u2192 List \u03b1\n  | [], _ => []\n  | l, 0 => l\n  | a :: l, n+1 => rotate' (l ++ [a]) n", "start": [1246, 1], "end": [1250, 40], "kind": "commanddeclaration"}, {"full_name": "List.mapDiagM", "code": "def mapDiagM [Monad m] (f : \u03b1 \u2192 \u03b1 \u2192 m \u03b2) (l : List \u03b1) : m (List \u03b2) := go l #[] where\n  \n  go : List \u03b1 \u2192 Array \u03b2 \u2192 m (List \u03b2)\n  | [], acc => pure acc.toList\n  | x::xs, acc => do\n    let b \u2190 f x x\n    let acc \u2190 xs.foldlM (\u00b7.push <$> f x \u00b7) (acc.push b)\n    go xs acc", "start": [1252, 1], "end": [1268, 14], "kind": "commanddeclaration"}, {"full_name": "List.forDiagM", "code": "@[simp] def forDiagM [Monad m] (f : \u03b1 \u2192 \u03b1 \u2192 m PUnit) : List \u03b1 \u2192 m PUnit\n  | [] => pure \u27e8\u27e9\n  | x :: xs => do f x x; xs.forM (f x); xs.forDiagM f", "start": [1270, 1], "end": [1280, 54], "kind": "commanddeclaration"}, {"full_name": "List.getRest", "code": "def getRest [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Option (List \u03b1)\n  | l, [] => some l\n  | [], _ => none\n  | x :: l, y :: l\u2081 => if x = y then getRest l l\u2081 else none", "start": [1282, 1], "end": [1287, 60], "kind": "commanddeclaration"}, {"full_name": "List.dropSlice", "code": "@[simp] def dropSlice : Nat \u2192 Nat \u2192 List \u03b1 \u2192 List \u03b1\n  | _, _, [] => []\n  | 0, m, xs => xs.drop m\n  | n+1, m, x :: xs => x :: dropSlice n m xs", "start": [1289, 1], "end": [1293, 45], "kind": "commanddeclaration"}, {"full_name": "List.dropSliceTR", "code": "@[inline] def dropSliceTR (n m : Nat) (l : List \u03b1) : List \u03b1 :=\n  match m with\n  | 0 => l\n  | m+1 => go m l n #[]\nwhere\n  \n  go (m : Nat) : List \u03b1 \u2192 Nat \u2192 Array \u03b1 \u2192 List \u03b1\n  | [],    _,   _   => l\n  | _::xs, 0,   acc => acc.toListAppend (xs.drop m)\n  | x::xs, n+1, acc => go m xs n (acc.push x)", "start": [1295, 1], "end": [1306, 46], "kind": "commanddeclaration"}, {"full_name": "List.dropSlice_zero\u2082", "code": "theorem dropSlice_zero\u2082 : \u2200 n l, @dropSlice \u03b1 n 0 l = l", "start": [1308, 1], "end": [1310, 55], "kind": "commanddeclaration"}, {"full_name": "List.dropSlice_eq_dropSliceTR", "code": "@[csimp] theorem dropSlice_eq_dropSliceTR : @dropSlice = @dropSliceTR", "start": [1312, 1], "end": [1321, 30], "kind": "commanddeclaration"}, {"full_name": "List.zipWithLeft'", "code": "@[simp] def zipWithLeft' (f : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3 \u00d7 List \u03b2\n  | [], bs => ([], bs)\n  | a :: as, [] => ((a :: as).map fun a => f a none, [])\n  | a :: as, b :: bs => let r := zipWithLeft' f as bs; (f a (some b) :: r.1, r.2)", "start": [1323, 1], "end": [1336, 82], "kind": "commanddeclaration"}, {"full_name": "List.zipWithLeft'TR", "code": "@[inline] def zipWithLeft'TR (f : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3)\n    (as : List \u03b1) (bs : List \u03b2) : List \u03b3 \u00d7 List \u03b2 := go as bs #[] where\n  \n  go : List \u03b1 \u2192 List \u03b2 \u2192 Array \u03b3 \u2192 List \u03b3 \u00d7 List \u03b2\n  | [], bs, acc => (acc.toList, bs)\n  | as, [], acc => (as.foldl (fun acc a => acc.push (f a none)) acc |>.toList, [])\n  | a :: as, b :: bs, acc => go as bs (acc.push (f a (some b)))", "start": [1338, 1], "end": [1345, 64], "kind": "commanddeclaration"}, {"full_name": "List.zipWithLeft'_eq_zipWithLeft'TR", "code": "@[csimp] theorem zipWithLeft'_eq_zipWithLeft'TR : @zipWithLeft' = @zipWithLeft'TR", "start": [1347, 1], "end": [1354, 28], "kind": "commanddeclaration"}, {"full_name": "List.zipWithRight'", "code": "@[inline] def zipWithRight' (f : Option \u03b1 \u2192 \u03b2 \u2192 \u03b3) (as : List \u03b1) (bs : List \u03b2) : List \u03b3 \u00d7 List \u03b1 :=\n  zipWithLeft' (flip f) bs as", "start": [1356, 1], "end": [1367, 30], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft'", "code": "@[inline] def zipLeft' : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 Option \u03b2) \u00d7 List \u03b2 := zipWithLeft' Prod.mk", "start": [1369, 1], "end": [1379, 96], "kind": "commanddeclaration"}, {"full_name": "List.zipRight'", "code": "@[inline] def zipRight' : List \u03b1 \u2192 List \u03b2 \u2192 List (Option \u03b1 \u00d7 \u03b2) \u00d7 List \u03b1 := zipWithRight' Prod.mk", "start": [1381, 1], "end": [1391, 98], "kind": "commanddeclaration"}, {"full_name": "List.zipWithLeft", "code": "@[simp] def zipWithLeft (f : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3\n  | [], _ => []\n  | a :: as, [] => (a :: as).map fun a => f a none\n  | a :: as, b :: bs => f a (some b) :: zipWithLeft f as bs", "start": [1393, 1], "end": [1406, 60], "kind": "commanddeclaration"}, {"full_name": "List.zipWithLeftTR", "code": "@[inline] def zipWithLeftTR (f : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3)\n    (as : List \u03b1) (bs : List \u03b2) : List \u03b3 := go as bs #[] where\n  \n  go : List \u03b1 \u2192 List \u03b2 \u2192 Array \u03b3 \u2192 List \u03b3\n  | [], _, acc => acc.toList\n  | as, [], acc => as.foldl (fun acc a => acc.push (f a none)) acc |>.toList\n  | a :: as, b :: bs, acc => go as bs (acc.push (f a (some b)))", "start": [1408, 1], "end": [1415, 64], "kind": "commanddeclaration"}, {"full_name": "List.zipWithLeft_eq_zipWithLeftTR", "code": "@[csimp] theorem zipWithLeft_eq_zipWithLeftTR : @zipWithLeft = @zipWithLeftTR", "start": [1417, 1], "end": [1423, 27], "kind": "commanddeclaration"}, {"full_name": "List.zipWithRight", "code": "@[inline] def zipWithRight (f : Option \u03b1 \u2192 \u03b2 \u2192 \u03b3) (as : List \u03b1) (bs : List \u03b2) : List \u03b3 :=\n  zipWithLeft (flip f) bs as", "start": [1425, 1], "end": [1436, 29], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft", "code": "@[inline] def zipLeft : List \u03b1 \u2192 List \u03b2 \u2192 List (\u03b1 \u00d7 Option \u03b2) := zipWithLeft Prod.mk", "start": [1438, 1], "end": [1448, 85], "kind": "commanddeclaration"}, {"full_name": "List.zipRight", "code": "@[inline] def zipRight : List \u03b1 \u2192 List \u03b2 \u2192 List (Option \u03b1 \u00d7 \u03b2) := zipWithRight Prod.mk", "start": [1450, 1], "end": [1460, 87], "kind": "commanddeclaration"}, {"full_name": "List.zipWithAll", "code": "def zipWithAll (f : Option \u03b1 \u2192 Option \u03b2 \u2192 \u03b3) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3\n  | [], bs => bs.map fun b => f none (some b)\n  | a :: as, [] => (a :: as).map fun a => f (some a) none\n  | a :: as, b :: bs => f a b :: zipWithAll f as bs", "start": [1462, 1], "end": [1470, 52], "kind": "commanddeclaration"}, {"full_name": "List.zipWithAll_nil_right", "code": "@[simp] theorem zipWithAll_nil_right :\n    zipWithAll f as [] = as.map fun a => f (some a) none", "start": [1472, 1], "end": [1474, 19], "kind": "commanddeclaration"}, {"full_name": "List.zipWithAll_nil_left", "code": "@[simp] theorem zipWithAll_nil_left :\n    zipWithAll f [] bs = bs.map fun b => f none (some b)", "start": [1476, 1], "end": [1478, 18], "kind": "commanddeclaration"}, {"full_name": "List.zipWithAll_cons_cons", "code": "@[simp] theorem zipWithAll_cons_cons :\n    zipWithAll f (a :: as) (b :: bs) = f (some a) (some b) :: zipWithAll f as bs", "start": [1480, 1], "end": [1481, 88], "kind": "commanddeclaration"}, {"full_name": "List.allSome", "code": "@[inline] def allSome (l : List (Option \u03b1)) : Option (List \u03b1) := l.mapM id", "start": [1483, 1], "end": [1491, 75], "kind": "commanddeclaration"}, {"full_name": "List.fillNones", "code": "@[simp] def fillNones {\u03b1} : List (Option \u03b1) \u2192 List \u03b1 \u2192 List \u03b1\n  | [], _ => []\n  | some a :: as, as' => a :: fillNones as as'\n  | none :: as, [] => as.reduceOption\n  | none :: as, a :: as' => a :: fillNones as as'", "start": [1493, 1], "end": [1505, 50], "kind": "commanddeclaration"}, {"full_name": "List.fillNonesTR", "code": "@[inline] def fillNonesTR (as : List (Option \u03b1)) (as' : List \u03b1) : List \u03b1 := go as as' #[] where\n  \n  go : List (Option \u03b1) \u2192 List \u03b1 \u2192 Array \u03b1 \u2192 List \u03b1\n  | [], _, acc => acc.toList\n  | some a :: as, as', acc => go as as' (acc.push a)\n  | none :: as, [], acc => filterMapTR.go id as acc\n  | none :: as, a :: as', acc => go as as' (acc.push a)", "start": [1507, 1], "end": [1514, 56], "kind": "commanddeclaration"}, {"full_name": "List.fillNones_eq_fillNonesTR", "code": "@[csimp] theorem fillNones_eq_fillNonesTR : @fillNones = @fillNonesTR", "start": [1516, 1], "end": [1523, 25], "kind": "commanddeclaration"}, {"full_name": "List.takeList", "code": "def takeList {\u03b1} : List \u03b1 \u2192 List Nat \u2192 List (List \u03b1) \u00d7 List \u03b1\n  | xs, [] => ([], xs)\n  | xs, n :: ns =>\n    let (xs\u2081, xs\u2082) := xs.splitAt n\n    let (xss, rest) := takeList xs\u2082 ns\n    (xs\u2081 :: xss, rest)", "start": [1525, 1], "end": [1541, 23], "kind": "commanddeclaration"}, {"full_name": "List.takeListTR", "code": "@[inline] def takeListTR\n    (xs : List \u03b1) (ns : List Nat) : List (List \u03b1) \u00d7 List \u03b1 := go ns xs #[] where\n  \n  go : List Nat \u2192 List \u03b1 \u2192 Array (List \u03b1) \u2192 List (List \u03b1) \u00d7 List \u03b1\n  | [], xs, acc => (acc.toList, xs)\n  | n :: ns, xs, acc =>\n    let (xs\u2081, xs\u2082) := xs.splitAt n\n    go ns xs\u2082 (acc.push xs\u2081)", "start": [1543, 1], "end": [1551, 29], "kind": "commanddeclaration"}, {"full_name": "List.takeList_eq_takeListTR", "code": "@[csimp] theorem takeList_eq_takeListTR : @takeList = @takeListTR", "start": [1553, 1], "end": [1559, 24], "kind": "commanddeclaration"}, {"full_name": "List.toChunksAux", "code": "def toChunksAux {\u03b1} (n : Nat) : List \u03b1 \u2192 Nat \u2192 List \u03b1 \u00d7 List (List \u03b1)\n  | [], _ => ([], [])\n  | x :: xs, 0 =>\n    let (l, L) := toChunksAux n xs n\n    ([], (x :: l) :: L)\n  | x :: xs, i+1 =>\n    let (l, L) := toChunksAux n xs i\n    (x :: l, L)", "start": [1561, 1], "end": [1572, 16], "kind": "commanddeclaration"}, {"full_name": "List.toChunks", "code": "def toChunks {\u03b1} : Nat \u2192 List \u03b1 \u2192 List (List \u03b1)\n  | _, [] => []\n  | 0, xs => [xs]\n  | n, x :: xs =>\n    let rec\n    \n    go : List \u03b1 \u2192 Array \u03b1 \u2192 Array (List \u03b1) \u2192 List (List \u03b1)\n    | [], acc\u2081, acc\u2082 => acc\u2082.push acc\u2081.toList |>.toList\n    | x :: xs, acc\u2081, acc\u2082 =>\n      if acc\u2081.size == n then\n        go xs ((Array.mkEmpty n).push x) (acc\u2082.push acc\u2081.toList)\n      else\n        go xs (acc\u2081.push x) acc\u2082\n    go xs #[x] #[]", "start": [1574, 1], "end": [1599, 19], "kind": "commanddeclaration"}, {"full_name": "List.zipWith\u2083", "code": "def zipWith\u2083 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3 \u2192 List \u03b4\n  | x :: xs, y :: ys, z :: zs => f x y z :: zipWith\u2083 f xs ys zs\n  | _, _, _ => []", "start": [1611, 1], "end": [1614, 18], "kind": "commanddeclaration"}, {"full_name": "List.zipWith\u2084", "code": "def zipWith\u2084 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4 \u2192 \u03b5) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3 \u2192 List \u03b4 \u2192 List \u03b5\n  | x :: xs, y :: ys, z :: zs, u :: us => f x y z u :: zipWith\u2084 f xs ys zs us\n  | _, _, _, _ => []", "start": [1616, 1], "end": [1619, 21], "kind": "commanddeclaration"}, {"full_name": "List.zipWith\u2085", "code": "def zipWith\u2085 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4 \u2192 \u03b5 \u2192 \u03b6) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3 \u2192 List \u03b4 \u2192 List \u03b5 \u2192 List \u03b6\n  | x :: xs, y :: ys, z :: zs, u :: us, v :: vs => f x y z u v :: zipWith\u2085 f xs ys zs us vs\n  | _, _, _, _, _ => []", "start": [1621, 1], "end": [1624, 24], "kind": "commanddeclaration"}, {"full_name": "List.mapWithPrefixSuffixAux", "code": "def mapWithPrefixSuffixAux {\u03b1 \u03b2} (f : List \u03b1 \u2192 \u03b1 \u2192 List \u03b1 \u2192 \u03b2) : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b2\n  | _, [] => []\n  | prev, h :: t => f prev h t :: mapWithPrefixSuffixAux f (prev.concat h) t", "start": [1626, 1], "end": [1630, 77], "kind": "commanddeclaration"}, {"full_name": "List.mapWithPrefixSuffix", "code": "def mapWithPrefixSuffix {\u03b1 \u03b2} (f : List \u03b1 \u2192 \u03b1 \u2192 List \u03b1 \u2192 \u03b2) (l : List \u03b1) : List \u03b2 :=\n  mapWithPrefixSuffixAux f [] l", "start": [1632, 1], "end": [1640, 32], "kind": "commanddeclaration"}, {"full_name": "List.mapWithComplement", "code": "def mapWithComplement {\u03b1 \u03b2} (f : \u03b1 \u2192 List \u03b1 \u2192 \u03b2) : List \u03b1 \u2192 List \u03b2 :=\n  mapWithPrefixSuffix fun pref a suff => f a (pref ++ suff)", "start": [1642, 1], "end": [1651, 60], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Option/Lemmas.lean", "imports": ["lake-packages/std/Std/Tactic/Ext/Attr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Logic.lean", "lake-packages/std/Std/Data/Option/Init/Lemmas.lean", "lake-packages/std/Std/Data/Option/Basic.lean"], "premises": [{"full_name": "Option.mem_iff", "code": "theorem mem_iff {a : \u03b1} {b : Option \u03b1} : a \u2208 b \u2194 b = a", "start": [13, 1], "end": [13, 63], "kind": "commanddeclaration"}, {"full_name": "Option.some_ne_none", "code": "theorem some_ne_none (x : \u03b1) : some x \u2260 none", "start": [15, 1], "end": [15, 53], "kind": "commanddeclaration"}, {"full_name": "Option.forall", "code": "protected theorem \u00abforall\u00bb {p : Option \u03b1 \u2192 Prop} : (\u2200 x, p x) \u2194 p none \u2227 \u2200 x, p (some x)", "start": [17, 1], "end": [18, 70], "kind": "commanddeclaration"}, {"full_name": "Option.exists", "code": "protected theorem \u00abexists\u00bb {p : Option \u03b1 \u2192 Prop} : (\u2203 x, p x) \u2194 p none \u2228 \u2203 x, p (some x)", "start": [20, 1], "end": [22, 53], "kind": "commanddeclaration"}, {"full_name": "Option.get_mem", "code": "theorem get_mem : \u2200 {o : Option \u03b1} (h : isSome o), o.get h \u2208 o", "start": [24, 1], "end": [25, 21], "kind": "commanddeclaration"}, {"full_name": "Option.get_of_mem", "code": "theorem get_of_mem : \u2200 {o : Option \u03b1} (h : isSome o), a \u2208 o \u2192 o.get h = a", "start": [27, 1], "end": [28, 21], "kind": "commanddeclaration"}, {"full_name": "Option.not_mem_none", "code": "theorem not_mem_none (a : \u03b1) : a \u2209 (none : Option \u03b1)", "start": [30, 1], "end": [30, 61], "kind": "commanddeclaration"}, {"full_name": "Option.some_get", "code": "@[simp] theorem some_get : \u2200 {x : Option \u03b1} (h : isSome x), some (x.get h) = x", "start": [32, 1], "end": [33, 19], "kind": "commanddeclaration"}, {"full_name": "Option.get_some", "code": "@[simp] theorem get_some (x : \u03b1) (h : isSome (some x)) : (some x).get h = x", "start": [35, 1], "end": [35, 83], "kind": "commanddeclaration"}, {"full_name": "Option.getD_of_ne_none", "code": "theorem getD_of_ne_none {x : Option \u03b1} (hx : x \u2260 none) (y : \u03b1) : some (x.getD y) = x", "start": [37, 1], "end": [38, 43], "kind": "commanddeclaration"}, {"full_name": "Option.mem_unique", "code": "theorem mem_unique {o : Option \u03b1} {a b : \u03b1} (ha : a \u2208 o) (hb : b \u2208 o) : a = b", "start": [40, 1], "end": [41, 22], "kind": "commanddeclaration"}, {"full_name": "Option.ext", "code": "@[ext] theorem ext : \u2200 {o\u2081 o\u2082 : Option \u03b1}, (\u2200 a, a \u2208 o\u2081 \u2194 a \u2208 o\u2082) \u2192 o\u2081 = o\u2082", "start": [43, 1], "end": [46, 32], "kind": "commanddeclaration"}, {"full_name": "Option.eq_none_iff_forall_not_mem", "code": "theorem eq_none_iff_forall_not_mem : o = none \u2194 \u2200 a, a \u2209 o", "start": [48, 1], "end": [49, 77], "kind": "commanddeclaration"}, {"full_name": "Option.isSome_none", "code": "@[simp] theorem isSome_none : @isSome \u03b1 none = false", "start": [51, 1], "end": [51, 60], "kind": "commanddeclaration"}, {"full_name": "Option.isSome_some", "code": "@[simp] theorem isSome_some : isSome (some a) = true", "start": [53, 1], "end": [53, 60], "kind": "commanddeclaration"}, {"full_name": "Option.isSome_iff_exists", "code": "theorem isSome_iff_exists : isSome x \u2194 \u2203 a, x = some a", "start": [55, 1], "end": [55, 87], "kind": "commanddeclaration"}, {"full_name": "Option.isNone_none", "code": "@[simp] theorem isNone_none : @isNone \u03b1 none = true", "start": [57, 1], "end": [57, 59], "kind": "commanddeclaration"}, {"full_name": "Option.isNone_some", "code": "@[simp] theorem isNone_some : isNone (some a) = false", "start": [59, 1], "end": [59, 61], "kind": "commanddeclaration"}, {"full_name": "Option.not_isSome", "code": "@[simp] theorem not_isSome : isSome a = false \u2194 a.isNone = true", "start": [61, 1], "end": [62, 19], "kind": "commanddeclaration"}, {"full_name": "Option.eq_some_iff_get_eq", "code": "theorem eq_some_iff_get_eq : o = some a \u2194 \u2203 h : o.isSome, o.get h = a", "start": [64, 1], "end": [65, 27], "kind": "commanddeclaration"}, {"full_name": "Option.eq_some_of_isSome", "code": "theorem eq_some_of_isSome : \u2200 {o : Option \u03b1} (h : o.isSome), o = some (o.get h)", "start": [67, 1], "end": [68, 21], "kind": "commanddeclaration"}, {"full_name": "Option.not_isSome_iff_eq_none", "code": "theorem not_isSome_iff_eq_none : \u00aco.isSome \u2194 o = none", "start": [70, 1], "end": [71, 19], "kind": "commanddeclaration"}, {"full_name": "Option.ne_none_iff_isSome", "code": "theorem ne_none_iff_isSome : o \u2260 none \u2194 o.isSome", "start": [73, 1], "end": [73, 72], "kind": "commanddeclaration"}, {"full_name": "Option.ne_none_iff_exists", "code": "theorem ne_none_iff_exists : o \u2260 none \u2194 \u2203 x, some x = o", "start": [75, 1], "end": [75, 79], "kind": "commanddeclaration"}, {"full_name": "Option.ne_none_iff_exists'", "code": "theorem ne_none_iff_exists' : o \u2260 none \u2194 \u2203 x, o = some x", "start": [77, 1], "end": [78, 60], "kind": "commanddeclaration"}, {"full_name": "Option.bex_ne_none", "code": "theorem bex_ne_none {p : Option \u03b1 \u2192 Prop} : (\u2203 x, \u2203 (_ : x \u2260 none), p x) \u2194 \u2203 x, p (some x)", "start": [80, 1], "end": [82, 49], "kind": "commanddeclaration"}, {"full_name": "Option.ball_ne_none", "code": "theorem ball_ne_none {p : Option \u03b1 \u2192 Prop} : (\u2200 x (_ : x \u2260 none), p x) \u2194 \u2200 x, p (some x)", "start": [84, 1], "end": [89, 18], "kind": "commanddeclaration"}, {"full_name": "Option.bind_some", "code": "@[simp] theorem bind_some (x : Option \u03b1) : x.bind some = x", "start": [91, 1], "end": [91, 81], "kind": "commanddeclaration"}, {"full_name": "Option.bind_eq_some", "code": "@[simp] theorem bind_eq_some : x.bind f = some b \u2194 \u2203 a, x = some a \u2227 f a = some b", "start": [93, 1], "end": [94, 19], "kind": "commanddeclaration"}, {"full_name": "Option.bind_eq_none", "code": "@[simp] theorem bind_eq_none {o : Option \u03b1} {f : \u03b1 \u2192 Option \u03b2} :\n    o.bind f = none \u2194 \u2200 b a, a \u2208 o \u2192 b \u2209 f a", "start": [96, 1], "end": [98, 85], "kind": "commanddeclaration"}, {"full_name": "Option.bind_comm", "code": "theorem bind_comm {f : \u03b1 \u2192 \u03b2 \u2192 Option \u03b3} (a : Option \u03b1) (b : Option \u03b2) :\n    (a.bind fun x => b.bind (f x)) = b.bind fun y => a.bind fun x => f x y", "start": [100, 1], "end": [102, 30], "kind": "commanddeclaration"}, {"full_name": "Option.bind_assoc", "code": "theorem bind_assoc (x : Option \u03b1) (f : \u03b1 \u2192 Option \u03b2) (g : \u03b2 \u2192 Option \u03b3) :\n    (x.bind f).bind g = x.bind fun y => (f y).bind g", "start": [104, 1], "end": [105, 75], "kind": "commanddeclaration"}, {"full_name": "Option.join_eq_some", "code": "theorem join_eq_some : x.join = some a \u2194 x = some (some a)", "start": [107, 1], "end": [108, 7], "kind": "commanddeclaration"}, {"full_name": "Option.join_ne_none", "code": "theorem join_ne_none : x.join \u2260 none \u2194 \u2203 z, x = some (some z)", "start": [110, 1], "end": [111, 58], "kind": "commanddeclaration"}, {"full_name": "Option.join_ne_none'", "code": "theorem join_ne_none' : \u00acx.join = none \u2194 \u2203 z, x = some (some z)", "start": [113, 1], "end": [114, 15], "kind": "commanddeclaration"}, {"full_name": "Option.join_eq_none", "code": "theorem join_eq_none : o.join = none \u2194 o = none \u2228 o = some none", "start": [116, 1], "end": [117, 61], "kind": "commanddeclaration"}, {"full_name": "Option.bind_id_eq_join", "code": "theorem bind_id_eq_join {x : Option (Option \u03b1)} : x.bind id = x.join", "start": [119, 1], "end": [119, 76], "kind": "commanddeclaration"}, {"full_name": "Option.map_eq_map", "code": "@[simp] theorem map_eq_map : Functor.map f = Option.map f", "start": [121, 1], "end": [121, 65], "kind": "commanddeclaration"}, {"full_name": "Option.map_none", "code": "theorem map_none : f <$> none = none", "start": [123, 1], "end": [123, 44], "kind": "commanddeclaration"}, {"full_name": "Option.map_some", "code": "theorem map_some : f <$> some a = some (f a)", "start": [125, 1], "end": [125, 52], "kind": "commanddeclaration"}, {"full_name": "Option.map_eq_some'", "code": "@[simp] theorem map_eq_some' : x.map f = some b \u2194 \u2203 a, x = some a \u2227 f a = b", "start": [127, 1], "end": [127, 99], "kind": "commanddeclaration"}, {"full_name": "Option.map_eq_some", "code": "theorem map_eq_some : f <$> x = some b \u2194 \u2203 a, x = some a \u2227 f a = b", "start": [129, 1], "end": [129, 83], "kind": "commanddeclaration"}, {"full_name": "Option.map_eq_none'", "code": "@[simp] theorem map_eq_none' : x.map f = none \u2194 x = none", "start": [131, 1], "end": [132, 65], "kind": "commanddeclaration"}, {"full_name": "Option.map_eq_none", "code": "theorem map_eq_none : f <$> x = none \u2194 x = none", "start": [134, 1], "end": [134, 64], "kind": "commanddeclaration"}, {"full_name": "Option.map_eq_bind", "code": "theorem map_eq_bind {x : Option \u03b1} : x.map f = x.bind (some \u2218 f)", "start": [136, 1], "end": [137, 33], "kind": "commanddeclaration"}, {"full_name": "Option.map_congr", "code": "theorem map_congr {x : Option \u03b1} (h : \u2200 a \u2208 x, f a = g a) : x.map f = x.map g", "start": [139, 1], "end": [140, 59], "kind": "commanddeclaration"}, {"full_name": "Option.map_id'", "code": "@[simp] theorem map_id' : Option.map (@id \u03b1) = id", "start": [142, 1], "end": [142, 60], "kind": "commanddeclaration"}, {"full_name": "Option.map_id''", "code": "@[simp] theorem map_id'' {x : Option \u03b1} : (x.map fun a => a) = x", "start": [143, 1], "end": [143, 86], "kind": "commanddeclaration"}, {"full_name": "Option.map_map", "code": "@[simp] theorem map_map (h : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) (x : Option \u03b1) :\n    (x.map g).map h = x.map (h \u2218 g)", "start": [145, 1], "end": [147, 52], "kind": "commanddeclaration"}, {"full_name": "Option.comp_map", "code": "theorem comp_map (h : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) (x : Option \u03b1) : x.map (h \u2218 g) = (x.map g).map h", "start": [149, 1], "end": [150, 20], "kind": "commanddeclaration"}, {"full_name": "Option.map_comp_map", "code": "@[simp] theorem map_comp_map (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) :\n    Option.map g \u2218 Option.map f = Option.map (g \u2218 f)", "start": [152, 1], "end": [153, 74], "kind": "commanddeclaration"}, {"full_name": "Option.mem_map_of_mem", "code": "theorem mem_map_of_mem (g : \u03b1 \u2192 \u03b2) (h : a \u2208 x) : g a \u2208 Option.map g x", "start": [155, 1], "end": [155, 95], "kind": "commanddeclaration"}, {"full_name": "Option.bind_map_comm", "code": "theorem bind_map_comm {\u03b1 \u03b2} {x : Option (Option \u03b1)} {f : \u03b1 \u2192 \u03b2} :\n    x.bind (Option.map f) = (x.map (Option.map f)).bind id", "start": [157, 1], "end": [158, 82], "kind": "commanddeclaration"}, {"full_name": "Option.join_map_eq_map_join", "code": "theorem join_map_eq_map_join {f : \u03b1 \u2192 \u03b2} {x : Option (Option \u03b1)} :\n    (x.map (Option.map f)).join = x.join.map f", "start": [160, 1], "end": [161, 70], "kind": "commanddeclaration"}, {"full_name": "Option.join_join", "code": "theorem join_join {x : Option (Option (Option \u03b1))} : x.join.join = (x.map join).join", "start": [163, 1], "end": [164, 19], "kind": "commanddeclaration"}, {"full_name": "Option.mem_of_mem_join", "code": "theorem mem_of_mem_join {a : \u03b1} {x : Option (Option \u03b1)} (h : a \u2208 x.join) : some a \u2208 x", "start": [166, 1], "end": [167, 28], "kind": "commanddeclaration"}, {"full_name": "Option.some_orElse", "code": "@[simp] theorem some_orElse (a : \u03b1) (x : Option \u03b1) : (some a <|> x) = some a", "start": [169, 1], "end": [169, 84], "kind": "commanddeclaration"}, {"full_name": "Option.none_orElse", "code": "@[simp] theorem none_orElse (x : Option \u03b1) : (none <|> x) = x", "start": [171, 1], "end": [171, 69], "kind": "commanddeclaration"}, {"full_name": "Option.orElse_none", "code": "@[simp] theorem orElse_none (x : Option \u03b1) : (x <|> none) = x", "start": [173, 1], "end": [173, 84], "kind": "commanddeclaration"}, {"full_name": "Option.map_orElse", "code": "theorem map_orElse {x y : Option \u03b1} : (x <|> y).map f = (x.map f <|> y.map f)", "start": [175, 1], "end": [176, 19], "kind": "commanddeclaration"}, {"full_name": "Option.guard_eq_some", "code": "@[simp] theorem guard_eq_some [DecidablePred p] : guard p a = some b \u2194 a = b \u2227 p a", "start": [178, 1], "end": [179, 46], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_eq_or_eq", "code": "theorem liftOrGet_eq_or_eq {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} (h : \u2200 a b, f a b = a \u2228 f a b = b) :\n    \u2200 o\u2081 o\u2082, liftOrGet f o\u2081 o\u2082 = o\u2081 \u2228 liftOrGet f o\u2081 o\u2082 = o\u2082", "start": [181, 1], "end": [186, 79], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_none_left", "code": "@[simp] theorem liftOrGet_none_left {f} {b : Option \u03b1} : liftOrGet f none b = b", "start": [188, 1], "end": [189, 18], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_none_right", "code": "@[simp] theorem liftOrGet_none_right {f} {a : Option \u03b1} : liftOrGet f a none = a", "start": [191, 1], "end": [192, 18], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_some_some", "code": "@[simp] theorem liftOrGet_some_some {f} {a b : \u03b1} :\n  liftOrGet f (some a) (some b) = f a b", "start": [194, 1], "end": [195, 47], "kind": "commanddeclaration"}, {"full_name": "Option.elim_none", "code": "theorem elim_none (x : \u03b2) (f : \u03b1 \u2192 \u03b2) : none.elim x f = x", "start": [197, 1], "end": [197, 65], "kind": "commanddeclaration"}, {"full_name": "Option.elim_some", "code": "theorem elim_some (x : \u03b2) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : (some a).elim x f = f a", "start": [199, 1], "end": [199, 79], "kind": "commanddeclaration"}, {"full_name": "Option.getD_map", "code": "@[simp] theorem getD_map (f : \u03b1 \u2192 \u03b2) (x : \u03b1) (o : Option \u03b1) :\n  (o.map f).getD (f x) = f (getD o x)", "start": [201, 1], "end": [202, 60], "kind": "commanddeclaration"}, {"full_name": "Option.choice", "code": "noncomputable def choice (\u03b1 : Type _) : Option \u03b1 :=\n  if h : Nonempty \u03b1 then some (Classical.choice h) else none", "start": [208, 1], "end": [210, 61], "kind": "commanddeclaration"}, {"full_name": "Option.choice_eq", "code": "theorem choice_eq {\u03b1 : Type _} [Subsingleton \u03b1] (a : \u03b1) : choice \u03b1 = some a", "start": [212, 1], "end": [215, 32], "kind": "commanddeclaration"}, {"full_name": "Option.choice_isSome_iff_nonempty", "code": "theorem choice_isSome_iff_nonempty {\u03b1 : Type _} : (choice \u03b1).isSome \u2194 Nonempty \u03b1", "start": [217, 1], "end": [218, 88], "kind": "commanddeclaration"}, {"full_name": "Option.to_list_some", "code": "@[simp] theorem to_list_some (a : \u03b1) : (a : Option \u03b1).toList = [a]", "start": [222, 1], "end": [222, 74], "kind": "commanddeclaration"}, {"full_name": "Option.to_list_none", "code": "@[simp] theorem to_list_none (\u03b1 : Type _) : (none : Option \u03b1).toList = []", "start": [224, 1], "end": [224, 81], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Simpa.lean", "imports": ["lake-packages/std/Std/Lean/Meta/LCtx.lean", "lake-packages/std/Std/Lean/Parser.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Linter/Util.lean", "lake-packages/std/Std/Tactic/OpenPrivate.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Simp.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean"], "premises": [{"full_name": "Std.Tactic.Simpa.mkSimpOnly", "code": "private def mkSimpOnly (stx : Syntax) (usedSimps : UsedSimps) : MetaM Syntax.Tactic := do\n  let isSimpAll := stx[0].getAtomVal == \"simp_all\"\n  let mut stx := stx\n  if stx[3].isNone then\n    stx := stx.setArg 3 (mkNullNode #[mkAtom \"only\"])\n  let mut args := #[]\n  let mut localsOrStar := some #[]\n  let lctx \u2190 getLCtx\n  let env \u2190 getEnv\n  for (thm, _) in usedSimps.toArray.qsort (\u00b7.2 < \u00b7.2) do\n    match thm with\n    | .decl declName inv => if env.contains declName && !simpOnlyBuiltins.contains declName then\n        args := args.push (\u2190 if inv then\n          `(Parser.Tactic.simpLemma| \u2190 $(mkIdent (\u2190 unresolveNameGlobal declName)):ident)\n        else\n          `(Parser.Tactic.simpLemma| $(mkIdent (\u2190 unresolveNameGlobal declName)):ident))\n    | .fvar fvarId => if isSimpAll then\n        continue\n        if let some ldecl := lctx.find? fvarId then\n        localsOrStar := localsOrStar.bind fun locals =>\n          if !ldecl.userName.isInaccessibleUserName &&\n              (lctx.findFromUserName? ldecl.userName).get!.fvarId == ldecl.fvarId then\n            some (locals.push ldecl.userName)\n          else\n            none\n      | .stx _ thmStx => args := args.push thmStx\n    | .other _ => pure ()     if let some locals := localsOrStar then\n    args := args ++ (\u2190 locals.mapM fun id => `(Parser.Tactic.simpLemma| $(mkIdent id):ident))\n  else\n    args := args.push (\u2190 `(Parser.Tactic.simpStar| *))\n  let argsStx := if args.isEmpty then #[] else #[mkAtom \"[\", (mkAtom \",\").mkSep args, mkAtom \"]\"]\n  return stx.setArg 4 (mkNullNode argsStx)", "start": [57, 1], "end": [107, 43], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Simpa.getLinterUnnecessarySimpa", "code": "def getLinterUnnecessarySimpa (o : Options) : Bool :=\n  getLinterValue linter.unnecessarySimpa o", "start": [109, 1], "end": [111, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Control/ForInStep/Lemmas.lean", "imports": ["lake-packages/std/Std/Control/ForInStep/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ForInStep.bind_done", "code": "@[simp] theorem ForInStep.bind_done [Monad m] (a : \u03b1) (f : \u03b1 \u2192 m (ForInStep \u03b1)) :\n    (ForInStep.done a).bind (m := m) f = pure (.done a)", "start": [10, 1], "end": [11, 63], "kind": "commanddeclaration"}, {"full_name": "ForInStep.bind_yield", "code": "@[simp] theorem ForInStep.bind_yield [Monad m] (a : \u03b1) (f : \u03b1 \u2192 m (ForInStep \u03b1)) :\n    (ForInStep.yield a).bind (m := m) f = f a", "start": [12, 1], "end": [13, 53], "kind": "commanddeclaration"}, {"full_name": "ForInStep.run_done", "code": "@[simp] theorem ForInStep.run_done : (ForInStep.done a).run = a", "start": [17, 1], "end": [17, 71], "kind": "commanddeclaration"}, {"full_name": "ForInStep.run_yield", "code": "@[simp] theorem ForInStep.run_yield : (ForInStep.yield a).run = a", "start": [18, 1], "end": [18, 73], "kind": "commanddeclaration"}, {"full_name": "ForInStep.bindList_nil", "code": "@[simp] theorem ForInStep.bindList_nil [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2))\n    (s : ForInStep \u03b2) : s.bindList f [] = pure s", "start": [20, 1], "end": [21, 56], "kind": "commanddeclaration"}, {"full_name": "ForInStep.bindList_cons", "code": "@[simp] theorem ForInStep.bindList_cons [Monad m]\n    (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (s : ForInStep \u03b2) (a l) :\n    s.bindList f (a::l) = s.bind fun b => f a b >>= (\u00b7.bindList f l)", "start": [23, 1], "end": [25, 76], "kind": "commanddeclaration"}, {"full_name": "ForInStep.done_bindList", "code": "@[simp] theorem ForInStep.done_bindList [Monad m]\n    (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (a l) :\n    (ForInStep.done a).bindList f l = pure (.done a)", "start": [27, 1], "end": [29, 76], "kind": "commanddeclaration"}, {"full_name": "ForInStep.bind_yield_bindList", "code": "@[simp] theorem ForInStep.bind_yield_bindList [Monad m]\n    (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (s : ForInStep \u03b2) (l) :\n    (s.bind fun a => (yield a).bindList f l) = s.bindList f l", "start": [31, 1], "end": [33, 85], "kind": "commanddeclaration"}, {"full_name": "ForInStep.bind_bindList_assoc", "code": "@[simp] theorem ForInStep.bind_bindList_assoc [Monad m] [LawfulMonad m]\n    (f : \u03b2 \u2192 m (ForInStep \u03b2)) (g : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (s : ForInStep \u03b2) (l) :\n    s.bind f >>= (\u00b7.bindList g l) = s.bind fun b => f b >>= (\u00b7.bindList g l)", "start": [35, 1], "end": [38, 19], "kind": "commanddeclaration"}, {"full_name": "ForInStep.bindList_cons'", "code": "theorem ForInStep.bindList_cons' [Monad m] [LawfulMonad m]\n    (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (s : ForInStep \u03b2) (a l) :\n    s.bindList f (a::l) = s.bind (f a) >>= (\u00b7.bindList f l)", "start": [40, 1], "end": [42, 71], "kind": "commanddeclaration"}, {"full_name": "ForInStep.bindList_append", "code": "@[simp] theorem ForInStep.bindList_append [Monad m] [LawfulMonad m]\n    (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (s : ForInStep \u03b2) (l\u2081 l\u2082) :\n    s.bindList f (l\u2081 ++ l\u2082) = s.bindList f l\u2081 >>= (\u00b7.bindList f l\u2082)", "start": [44, 1], "end": [47, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/DeclHash.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.hashParams", "code": "def hashParams (ps : Array Param) : UInt64 :=\n  hash ps", "start": [13, 1], "end": [14, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.hashAlt", "code": "partial def hashAlt (alt : Alt) : UInt64 :=\n  match alt with\n  | .alt ctorName ps k => mixHash (mixHash (hash ctorName) (hash ps)) (hashCode k)\n  | .default k => hashCode k", "start": [17, 1], "end": [20, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.hashAlts", "code": "partial def hashAlts (alts : Array Alt) : UInt64 :=\n  alts.foldl (fun r a => mixHash r (hashAlt a)) 7", "start": [22, 1], "end": [23, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.hashCode", "code": "partial def hashCode (code : Code) : UInt64 :=\n  match code with\n  | .let decl k => mixHash (mixHash (hash decl.fvarId) (hash decl.type)) (mixHash (hash decl.value) (hashCode k))\n  | .fun decl k | .jp decl k =>\n    mixHash (mixHash (mixHash (hash decl.fvarId) (hash decl.type)) (mixHash (hashCode decl.value) (hashCode k))) (hash decl.params)\n  | .return fvarId => hash fvarId\n  | .unreach type => hash type\n  | .jmp fvarId args => mixHash (hash fvarId) (hash args)\n  | .cases c => mixHash (mixHash (hash c.discr) (hash c.resultType)) (hashAlts c.alts)", "start": [25, 1], "end": [33, 87], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Main.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/InlineProj.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Bind.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpValue.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ImplementedByAttr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/FunDeclInfo.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/InlineCandidate.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/ConstantFold.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/AlphaEqv.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Used.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/DefaultAlt.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ElimDead.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Simp.oneExitPointQuick", "code": "private partial def oneExitPointQuick (c : Code) : Bool :=\n  go c\nwhere\n  go (c : Code) : Bool :=\n    match c with\n    | .let _ k | .fun _ k => go k\n    | .cases c => c.alts.size == 1 && go c.alts[0]!.getCode\n    | .jp .. | .jmp .. | .unreach .. => false\n    | .return .. => true", "start": [22, 1], "end": [39, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.specializePartialApp", "code": "def specializePartialApp (info : InlineCandidateInfo) : SimpM FunDecl := do\n  let mut subst := {}\n  for param in info.params, arg in info.args do\n    subst := subst.insert param.fvarId arg.toExpr\n  let mut paramsNew := #[]\n  for param in info.params[info.args.size:] do\n    let type \u2190 replaceExprFVars param.type subst (translator := true)\n    let paramNew \u2190 mkAuxParam type\n    paramsNew := paramsNew.push paramNew\n    subst := subst.insert param.fvarId (.fvar paramNew.fvarId)\n  let code \u2190 info.value.internalize subst\n  updateFunDeclInfo code\n  mkAuxFunDecl paramsNew code", "start": [41, 1], "end": [57, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.inlineJp?", "code": "partial def inlineJp? (fvarId : FVarId) (args : Array Arg) : SimpM (Option Code) := do\n  \n  let some decl \u2190 findFunDecl? fvarId | return none\n  unless (\u2190 shouldInlineLocal decl) do return none\n  markSimplified\n  betaReduce decl.params decl.value args", "start": [59, 1], "end": [67, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.etaPolyApp?", "code": "def etaPolyApp? (letDecl : LetDecl) : OptionT SimpM FunDecl := do\n  guard <| (\u2190 read).config.etaPoly\n  let .const declName us args := letDecl.value | failure\n  let some info := (\u2190 getEnv).find? declName | failure\n  guard <| hasLocalInst info.type\n  guard <| !(\u2190 Meta.isInstance declName)\n  let some decl \u2190 getDecl? declName | failure\n  guard <| decl.getArity > args.size\n  let params \u2190 mkNewParams letDecl.type\n  let auxDecl \u2190 mkAuxLetDecl (.const declName us (args ++ params.map (.fvar \u00b7.fvarId)))\n  let funDecl \u2190 mkAuxFunDecl params (.let auxDecl (.return auxDecl.fvarId))\n  addFVarSubst letDecl.fvarId funDecl.fvarId\n  eraseLetDecl letDecl\n  return funDecl", "start": [69, 1], "end": [88, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.isReturnOf", "code": "def isReturnOf (c : Code) (fvarId : FVarId) : SimpM Bool := do\n  match c with\n  | .return fvarId' => match (\u2190 normFVar fvarId') with\n    | .fvar fvarId'' => return fvarId'' == fvarId\n    | .erased => return false\n  | _ => return false", "start": [90, 1], "end": [98, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.elimVar?", "code": "def elimVar? (value : LetValue) : SimpM (Option FVarId) := do\n  let .fvar fvarId #[] := value | return none\n  return fvarId", "start": [100, 1], "end": [102, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.inlineApp?", "code": "partial def inlineApp? (letDecl : LetDecl) (k : Code) : SimpM (Option Code) := do\n  let some info \u2190 inlineCandidate? letDecl.value | return none\n  let numArgs := info.args.size\n  withInlining letDecl.value info.recursive do\n  let fvarId := letDecl.fvarId\n  if numArgs < info.arity then\n    let funDecl \u2190 specializePartialApp info\n    addFVarSubst fvarId funDecl.fvarId\n    markSimplified\n    simp (.fun funDecl k)\n  else\n    let code \u2190 betaReduce info.params info.value info.args[:info.arity]\n    if k.isReturnOf fvarId && numArgs == info.arity then\n      \n      markSimplified\n      simp code\n    else\n      let code \u2190 simp code\n      let simpK (result : FVarId) : SimpM Code := do\n        \n        if numArgs > info.arity then\n          let decl \u2190 mkAuxLetDecl (.fvar result info.args[info.arity:])\n          addFVarSubst fvarId decl.fvarId\n          simp (.let decl k)\n        else\n          addFVarSubst fvarId result\n          simp k\n      if oneExitPointQuick code then\n        markSimplified\n        code.bind fun fvarId' => do\n          markUsedFVar fvarId'\n          simpK fvarId'\n      else\n        markSimplified\n        let expectedType \u2190 inferAppType info.fType info.args[:info.arity]\n        if expectedType.headBeta.isForall then\n          \n          let auxFunDecl \u2190 mkAuxFunDecl #[] code\n          let auxFunDecl \u2190 auxFunDecl.etaExpand\n          let k \u2190 simpK auxFunDecl.fvarId\n          attachCodeDecls #[.fun auxFunDecl] k\n        else\n          let jpParam \u2190 mkAuxParam expectedType\n          let jpValue \u2190 simpK jpParam.fvarId\n          let jpDecl \u2190 mkAuxJpDecl #[jpParam] jpValue\n          let code \u2190 code.bind fun fvarId => return .jmp jpDecl.fvarId #[.fvar fvarId]\n          return Code.jp jpDecl code", "start": [105, 1], "end": [174, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.simpFunDecl", "code": "partial def simpFunDecl (decl : FunDecl) : SimpM FunDecl := do\n  let type \u2190 normExpr decl.type\n  let params \u2190 normParams decl.params\n  let value \u2190 simp decl.value\n  decl.update type params value", "start": [176, 1], "end": [183, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.simpCasesOnCtor?", "code": "partial def simpCasesOnCtor? (cases : Cases) : SimpM (Option Code) := do\n  match (\u2190 normFVar cases.discr) with\n  | .erased => mkReturnErased\n  | .fvar discr =>\n    let some ctorInfo \u2190 findCtor? discr | return none\n    let (alt, cases) := cases.extractAlt! ctorInfo.getName\n    eraseCode (.cases cases)\n    markSimplified\n    match alt with\n    | .default k => simp k\n    | .alt _ params k =>\n      match ctorInfo with\n      | .ctor ctorVal ctorArgs =>\n        let fields := ctorArgs[ctorVal.numParams:]\n        for param in params, field in fields do\n          addSubst param.fvarId field.toExpr\n        let k \u2190 simp k\n        eraseParams params\n        return k\n      | .natVal 0 => simp k\n      | .natVal (n+1) =>\n        let auxDecl \u2190 mkAuxLetDecl (.value (.natVal n))\n        addFVarSubst params[0]!.fvarId auxDecl.fvarId\n        let k \u2190 simp k\n        eraseParams params\n        return some <| .let auxDecl k", "start": [185, 1], "end": [213, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Simp.simp", "code": "partial def simp (code : Code) : SimpM Code := withIncRecDepth do\n  incVisited\n  match code with\n  | .let decl k =>\n    let baseDecl := decl\n    let mut decl \u2190 normLetDecl baseDecl\n    if baseDecl != decl then\n      markSimplified\n    if let some value \u2190 simpValue? decl.value then\n      markSimplified\n      decl \u2190 decl.updateValue value\n    if let some decls \u2190 ConstantFold.foldConstants decl then\n      markSimplified\n      let k \u2190 simp k\n      attachCodeDecls decls k\n    else if let some funDecl \u2190 etaPolyApp? decl then\n      simp (.fun funDecl k)\n    else if let some fvarId \u2190 elimVar? decl.value then\n      \n      addFVarSubst decl.fvarId fvarId\n      eraseLetDecl decl\n      simp k\n    else if let some code \u2190 inlineApp? decl k then\n      eraseLetDecl decl\n      return code\n    else if let some (decls, fvarId) \u2190 inlineProjInst? decl.value then\n      addFVarSubst decl.fvarId fvarId\n      eraseLetDecl decl\n      let k \u2190 simp k\n      attachCodeDecls decls k\n    else\n      let k \u2190 simp k\n      if (\u2190 isUsed decl.fvarId) then\n        markUsedLetDecl decl\n        return code.updateLet! decl k\n      else\n        \n        eraseLetDecl decl\n        return k\n  | .fun decl k | .jp decl k =>\n    let mut decl := decl\n    let toBeInlined \u2190 isOnceOrMustInline decl.fvarId\n    if toBeInlined then\n      \n      decl \u2190 normFunDecl decl\n    else\n      \n      if code.isFun then\n        if decl.isEtaExpandCandidate then\n          \n          decl \u2190 normFunDecl decl\n          \n          decl \u2190 decl.etaExpand\n          markSimplified\n      decl \u2190 simpFunDecl decl\n    let k \u2190 simp k\n    if (\u2190 isUsed decl.fvarId) then\n      if toBeInlined then\n        \n        markUsedFunDecl decl\n      return code.updateFun! decl k\n    else\n      \n      eraseFunDecl decl\n      return k\n  | .return fvarId =>\n    withNormFVarResult (\u2190 normFVar fvarId) fun fvarId => do\n      markUsedFVar fvarId\n      return code.updateReturn! fvarId\n  | .unreach type =>\n    return code.updateUnreach! (\u2190 normExpr type)\n  | .jmp fvarId args =>\n    withNormFVarResult (\u2190 normFVar fvarId) fun fvarId => do\n      let args \u2190 normArgs args\n      if let some code \u2190 inlineJp? fvarId args then\n        simp code\n      else\n        markUsedFVar fvarId\n        args.forM markUsedArg\n        return code.updateJmp! fvarId args\n  | .cases c =>\n    if let some k \u2190 simpCasesOnCtor? c then\n      return k\n    else\n      withNormFVarResult (\u2190 normFVar c.discr) fun discr => do\n        let resultType \u2190 normExpr c.resultType\n        markUsedFVar discr\n        let alts \u2190 c.alts.mapMonoM fun alt => do\n          match alt with\n          | .alt ctorName ps k =>\n            if !(k matches .unreach ..) && (\u2190 ps.anyM fun p => isInductiveWithNoCtors p.type) then\n              let type \u2190 k.inferType\n              eraseCode k\n              markSimplified\n              return alt.updateCode (.unreach type)\n            else\n              withDiscrCtor discr ctorName ps do\n                return alt.updateCode (\u2190 simp k)\n          | .default k => return alt.updateCode (\u2190 simp k)\n        let alts \u2190 addDefaultAlt alts\n        if alts.size == 1 && alts[0]! matches .default .. then\n          return alts[0]!.getCode\n        else\n          return code.updateCases! resultType discr alts", "start": [215, 1], "end": [333, 57], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ReduceJpArity.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.ReduceJpArity.ReduceM", "code": "abbrev ReduceM := ReaderT (FVarIdMap (Array Bool)) CompilerM", "start": [16, 1], "end": [16, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ReduceJpArity.reduce", "code": "partial def reduce (code : Code) : ReduceM Code := do\n  match code with\n  | .let decl k => return code.updateLet! decl (\u2190 reduce k)\n  | .fun decl k =>\n    let value \u2190 reduce decl.value\n    let decl \u2190 decl.update' decl.type value\n    return code.updateFun! decl (\u2190 reduce k)\n  | .jp decl k =>\n    let value \u2190 reduce decl.value\n    let mut used := value.collectUsed\n    let mut mask := #[]\n    let mut paramsNew := #[]\n    for param in decl.params.reverse do\n      if used.contains param.fvarId then\n        used := collectUsedAtExpr used param.type\n        mask := mask.push true\n        paramsNew := paramsNew.push param\n      else\n        eraseParam param\n        mask := mask.push false\n    mask := mask.reverse\n    paramsNew := paramsNew.reverse\n    if paramsNew.size != decl.params.size then\n      let type \u2190 mkForallParams paramsNew (\u2190 value.inferType)\n      let decl \u2190 decl.update type paramsNew value\n      let k \u2190 withReader (\u00b7.insert decl.fvarId mask) (reduce k)\n      return .jp decl k\n    else\n      let decl \u2190 decl.update' decl.type value\n      return code.updateFun! decl (\u2190 reduce k)\n  | .cases c =>\n    let alts \u2190 c.alts.mapMonoM fun alt => return alt.updateCode (\u2190 reduce alt.getCode)\n    return code.updateAlts! alts\n  | .return .. | .unreach .. => return code\n  | .jmp fvarId args =>\n    if let some mask := (\u2190 read).find? fvarId then\n      let mut argsNew := #[]\n      for keep in mask, arg in args do\n        if keep then\n          argsNew := argsNew.push arg\n      return .jmp fvarId argsNew\n    else\n      return code", "start": [18, 1], "end": [60, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.reduceJpArity", "code": "def Decl.reduceJpArity (decl : Decl) : CompilerM Decl := do\n  let value \u2190 reduce decl.value |>.run {}\n  return { decl with value }", "start": [66, 1], "end": [71, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.reduceJpArity", "code": "def reduceJpArity (phase := Phase.base) : Pass :=\n  .mkPerDeclaration `reduceJpArity Decl.reduceJpArity phase", "start": [73, 1], "end": [74, 60], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/FixedParams.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.FixedParams.AbsValue", "code": "inductive AbsValue where\n  | top\n  | erased\n  | val (i : Nat)\n  deriving Inhabited, BEq, Hashable", "start": [36, 1], "end": [41, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.Context", "code": "structure Context where\n  \n  decls : Array Decl\n  \n  main : Decl\n  \n  assignment : FVarIdMap AbsValue", "start": [43, 1], "end": [55, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.State", "code": "structure State where\n  \n  visited : HashSet (Name \u00d7 Array AbsValue) := {}\n  \n  fixed : Array Bool", "start": [57, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.FixParamM", "code": "abbrev FixParamM := ReaderT Context <| EStateM Unit State", "start": [71, 1], "end": [72, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.abort", "code": "abbrev abort : FixParamM \u03b1 := do\n  modify fun s => { s with fixed := s.fixed.map fun _ => false }\n  throw ()", "start": [74, 1], "end": [77, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.evalFVar", "code": "def evalFVar (fvarId : FVarId) : FixParamM AbsValue := do\n  let some val := (\u2190 read).assignment.find? fvarId | return .top\n  return val", "start": [79, 1], "end": [81, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.evalArg", "code": "def evalArg (arg : Arg) : FixParamM AbsValue := do\n  match arg with\n  | .erased => return .erased\n  | .type (.fvar fvarId) => evalFVar fvarId\n  | .type _ => return .top\n  | .fvar fvarId => evalFVar fvarId", "start": [83, 1], "end": [88, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.inMutualBlock", "code": "def inMutualBlock (declName : Name) : FixParamM Bool :=\n  return (\u2190 read).decls.any (\u00b7.name == declName)", "start": [90, 1], "end": [91, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.mkAssignment", "code": "def mkAssignment (decl : Decl) (values : Array AbsValue) : FVarIdMap AbsValue := Id.run do\n  let mut assignment := {}\n  for param in decl.params, value in values do\n    assignment := assignment.insert param.fvarId value\n  return assignment", "start": [93, 1], "end": [97, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.evalLetValue", "code": "partial def evalLetValue (e : LetValue) : FixParamM Unit := do\n  match e with\n  | .const declName _ args => evalApp declName args\n  | _ => return ()", "start": [101, 1], "end": [104, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.evalCode", "code": "partial def evalCode (code : Code) : FixParamM Unit := do\n  match code with\n  | .let decl k => evalLetValue decl.value; evalCode k\n  | .fun decl k | .jp decl k => evalCode decl.value; evalCode k\n  | .cases c => c.alts.forM fun alt => evalCode alt.getCode\n  | .unreach .. | .jmp .. | .return .. => return ()", "start": [106, 1], "end": [111, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.evalApp", "code": "partial def evalApp (declName : Name) (args : Array Arg) : FixParamM Unit := do\n  let main := (\u2190 read).main\n  if declName == main.name then\n    for h : i in [:main.params.size] do\n      if _h : i < args.size then\n        have : i < main.params.size := h.upper\n        let param := main.params[i]\n        let val \u2190 evalArg args[i]\n        unless val == .val i || (val == .erased && param.type.isErased) do\n          modify fun s => { s with fixed := s.fixed.set! i false }\n      else\n        modify fun s => { s with fixed := s.fixed.set! i false }\n    unless (\u2190 get).fixed.contains true do\n      throw () for decl in (\u2190 read).decls do\n    if declName == decl.name then\n      let mut values := #[]\n      for i in [:decl.params.size] do\n        if h : i < args.size then\n          values := values.push (\u2190 evalArg args[i])\n        else\n          values := values.push .top\n      let key := (declName, values)\n      unless (\u2190 get).visited.contains key do\n        modify fun s => { s with visited := s.visited.insert key }\n        let assignment := mkAssignment decl values\n        withReader (fun ctx => { ctx with assignment }) <| evalCode decl.value", "start": [113, 1], "end": [144, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FixedParams.mkInitialValues", "code": "def mkInitialValues (numParams : Nat) : Array AbsValue := Id.run do\n  let mut values := #[]\n  for i in [:numParams] do\n    values := values.push <| .val i\n  return values", "start": [148, 1], "end": [152, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkFixedParamsMap", "code": "def mkFixedParamsMap (decls : Array Decl) : NameMap (Array Bool) := Id.run do\n  let mut result := {}\n  for decl in decls do\n    let values := mkInitialValues decl.params.size\n    let assignment := mkAssignment decl values\n    let fixed := Array.mkArray decl.params.size true\n    match evalCode decl.value |>.run { main := decl, decls, assignment } |>.run { fixed } with\n    | .ok _ s | .error _ s => result := result.insert decl.name s.fixed\n  return result", "start": [157, 1], "end": [173, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/HasConstCache.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.HasConstCache", "code": "structure HasConstCache (declName : Name) where\n  cache : HashMapImp Expr Bool := mkHashMapImp", "start": [10, 1], "end": [11, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.HasConstCache.containsUnsafe", "code": "unsafe def HasConstCache.containsUnsafe (e : Expr) : StateM (HasConstCache declName) Bool := do\n  if let some r := (\u2190 get).cache.find? (beq := \u27e8ptrEq\u27e9) e then\n    return r\n  else\n    match e with\n    | .const n ..        => return n == declName\n    | .app f a           => cache e (\u2190 containsUnsafe f <||> containsUnsafe a)\n    | .lam _ d b _       => cache e (\u2190 containsUnsafe d <||> containsUnsafe b)\n    | .forallE _ d b _   => cache e (\u2190 containsUnsafe d <||> containsUnsafe b)\n    | .letE _ t v b _    => cache e (\u2190 containsUnsafe t <||> containsUnsafe v <||> containsUnsafe b)\n    | .mdata _ b         => cache e (\u2190 containsUnsafe b)\n    | .proj _ _ b        => cache e (\u2190 containsUnsafe b)\n    | _                  => return false\nwhere\n  cache (e : Expr) (r : Bool) : StateM (HasConstCache declName) Bool := do\n    modify fun \u27e8cache\u27e9 => \u27e8cache.insert (beq := \u27e8ptrEq\u27e9) e r |>.1\u27e9\n    return r", "start": [13, 1], "end": [29, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.HasConstCache.contains", "code": "@[implemented_by HasConstCache.containsUnsafe]\nopaque HasConstCache.contains (e : Expr) : StateM (HasConstCache declName) Bool", "start": [31, 1], "end": [35, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/AbstractNestedProofs.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectLevelParams.lean", "lake-packages/lean4/src/lean/Lean/Elab/RecAppSyntax.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/DefView.lean", "lake-packages/lean4/src/lean/Lean/Compiler/NoncomputableAttr.lean"], "premises": [{"full_name": "Lean.Elab.PreDefinition", "code": "structure PreDefinition where\n  ref         : Syntax\n  kind        : DefKind\n  levelParams : List Name\n  modifiers   : Modifiers\n  declName    : Name\n  type        : Expr\n  value       : Expr\n  deriving Inhabited", "start": [16, 1], "end": [28, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.instantiateMVarsAtPreDecls", "code": "def instantiateMVarsAtPreDecls (preDefs : Array PreDefinition) : TermElabM (Array PreDefinition) :=\n  preDefs.mapM fun preDef => do\n    pure { preDef with type := (\u2190 instantiateMVars preDef.type), value := (\u2190 instantiateMVars preDef.value) }", "start": [30, 1], "end": [32, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.levelMVarToParamPreDecls", "code": "def levelMVarToParamPreDecls (preDefs : Array PreDefinition) : TermElabM (Array PreDefinition) :=\n  preDefs.mapM fun preDef => do\n    pure { preDef with type := (\u2190 levelMVarToParam preDef.type), value := (\u2190 levelMVarToParam preDef.value) }", "start": [34, 1], "end": [36, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.getLevelParamsPreDecls", "code": "private def getLevelParamsPreDecls (preDefs : Array PreDefinition) (scopeLevelNames allUserLevelNames : List Name) : TermElabM (List Name) := do\n  let mut s : CollectLevelParams.State := {}\n  for preDef in preDefs do\n    s := collectLevelParams s preDef.type\n    s := collectLevelParams s preDef.value\n  match sortDeclLevelParams scopeLevelNames allUserLevelNames s.params with\n  | Except.error msg      => throwError msg\n  | Except.ok levelParams => pure levelParams", "start": [38, 1], "end": [45, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.fixLevelParams", "code": "def fixLevelParams (preDefs : Array PreDefinition) (scopeLevelNames allUserLevelNames : List Name) : TermElabM (Array PreDefinition) := do\n  let levelParams \u2190 getLevelParamsPreDecls preDefs scopeLevelNames allUserLevelNames\n  let us := levelParams.map mkLevelParam\n  let fixExpr (e : Expr) : Expr :=\n    e.replace fun c => match c with\n      | Expr.const declName _ => if preDefs.any fun preDef => preDef.declName == declName then some $ Lean.mkConst declName us else none\n      | _ => none\n  return preDefs.map fun preDef =>\n    { preDef with\n      type        := fixExpr preDef.type,\n      value       := fixExpr preDef.value,\n      levelParams := levelParams }", "start": [47, 1], "end": [59, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.applyAttributesOf", "code": "def applyAttributesOf (preDefs : Array PreDefinition) (applicationTime : AttributeApplicationTime) : TermElabM Unit := do\n  for preDef in preDefs do\n    applyAttributesAt preDef.declName preDef.modifiers.attrs applicationTime", "start": [61, 1], "end": [63, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.abstractNestedProofs", "code": "def abstractNestedProofs (preDef : PreDefinition) : MetaM PreDefinition :=\n  if preDef.kind.isTheorem || preDef.kind.isExample then\n    pure preDef\n  else do\n    let value \u2190 Meta.abstractNestedProofs preDef.declName preDef.value\n    pure { preDef with value := value }", "start": [65, 1], "end": [70, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addAsAxiom", "code": "def addAsAxiom (preDef : PreDefinition) : MetaM Unit := do\n  withRef preDef.ref do\n    addDecl <| Declaration.axiomDecl { name := preDef.declName, levelParams := preDef.levelParams, type := preDef.type, isUnsafe := preDef.modifiers.isUnsafe }", "start": [72, 1], "end": [75, 160], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.shouldGenCodeFor", "code": "private def shouldGenCodeFor (preDef : PreDefinition) : Bool :=\n  !preDef.kind.isTheorem && !preDef.modifiers.isNoncomputable", "start": [77, 1], "end": [78, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.compileDecl", "code": "private def compileDecl (decl : Declaration) : TermElabM Bool := do\n  try\n    Lean.compileDecl decl\n  catch ex =>\n    if (\u2190 read).isNoncomputableSection then\n      return false\n    else\n      throw ex\n  return true", "start": [80, 1], "end": [88, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addNonRecAux", "code": "private def addNonRecAux (preDef : PreDefinition) (compile : Bool) (all : List Name) (applyAttrAfterCompilation := true) : TermElabM Unit :=\n  withRef preDef.ref do\n    let preDef \u2190 abstractNestedProofs preDef\n    let decl \u2190\n      match preDef.kind with\n      | DefKind.\u00abtheorem\u00bb =>\n        pure <| Declaration.thmDecl {\n          name := preDef.declName, levelParams := preDef.levelParams, type := preDef.type, value := preDef.value, all\n        }\n      | DefKind.\u00abopaque\u00bb  =>\n        pure <| Declaration.opaqueDecl {\n          name := preDef.declName, levelParams := preDef.levelParams, type := preDef.type, value := preDef.value\n          isUnsafe := preDef.modifiers.isUnsafe, all\n        }\n      | DefKind.\u00ababbrev\u00bb  =>\n        pure <| Declaration.defnDecl {\n          name := preDef.declName, levelParams := preDef.levelParams, type := preDef.type, value := preDef.value\n          hints := ReducibilityHints.\u00ababbrev\u00bb\n          safety := if preDef.modifiers.isUnsafe then DefinitionSafety.unsafe else DefinitionSafety.safe,\n          all }\n      | _ => pure <| Declaration.defnDecl {\n          name := preDef.declName, levelParams := preDef.levelParams, type := preDef.type, value := preDef.value\n          hints := ReducibilityHints.regular (getMaxHeight (\u2190 getEnv) preDef.value + 1)\n          safety := if preDef.modifiers.isUnsafe then DefinitionSafety.unsafe else DefinitionSafety.safe,\n          all }\n    addDecl decl\n    withSaveInfoContext do  addTermInfo' preDef.ref (\u2190 mkConstWithLevelParams preDef.declName) (isBinder := true)\n    applyAttributesOf #[preDef] AttributeApplicationTime.afterTypeChecking\n    if preDef.modifiers.isNoncomputable then\n      modifyEnv fun env => addNoncomputable env preDef.declName\n    if compile && shouldGenCodeFor preDef then\n      discard <| compileDecl decl\n    if applyAttrAfterCompilation then\n      applyAttributesOf #[preDef] AttributeApplicationTime.afterCompilation", "start": [90, 1], "end": [125, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addAndCompileNonRec", "code": "def addAndCompileNonRec (preDef : PreDefinition) (all : List Name := [preDef.declName]) : TermElabM Unit := do\n  addNonRecAux preDef (compile := true) (all := all)", "start": [127, 1], "end": [128, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addNonRec", "code": "def addNonRec (preDef : PreDefinition) (applyAttrAfterCompilation := true) (all : List Name := [preDef.declName]) : TermElabM Unit := do\n  addNonRecAux preDef (compile := false) (applyAttrAfterCompilation := applyAttrAfterCompilation) (all := all)", "start": [130, 1], "end": [131, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.eraseRecAppSyntaxExpr", "code": "def eraseRecAppSyntaxExpr (e : Expr) : CoreM Expr :=\n  Core.transform e (post := fun e => pure <| TransformStep.done <| if (getRecAppSyntax? e).isSome then e.mdataExpr! else e)", "start": [133, 1], "end": [137, 124], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.eraseRecAppSyntax", "code": "def eraseRecAppSyntax (preDef : PreDefinition) : CoreM PreDefinition :=\n  return { preDef with value := (\u2190 eraseRecAppSyntaxExpr preDef.value) }", "start": [139, 1], "end": [140, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addAndCompileUnsafe", "code": "def addAndCompileUnsafe (preDefs : Array PreDefinition) (safety := DefinitionSafety.unsafe) : TermElabM Unit := do\n  let preDefs \u2190 preDefs.mapM fun d => eraseRecAppSyntax d\n  withRef preDefs[0]!.ref do\n    let all  := preDefs.toList.map (\u00b7.declName)\n    let decl := Declaration.mutualDefnDecl <| \u2190 preDefs.toList.mapM fun preDef => return {\n        name        := preDef.declName\n        levelParams := preDef.levelParams\n        type        := preDef.type\n        value       := preDef.value\n        hints       := ReducibilityHints.opaque\n        safety, all\n      }\n    addDecl decl\n    withSaveInfoContext do  for preDef in preDefs do\n        addTermInfo' preDef.ref (\u2190 mkConstWithLevelParams preDef.declName) (isBinder := true)\n    applyAttributesOf preDefs AttributeApplicationTime.afterTypeChecking\n    discard <| compileDecl decl\n    applyAttributesOf preDefs AttributeApplicationTime.afterCompilation\n    return ()", "start": [142, 1], "end": [161, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addAndCompilePartialRec", "code": "def addAndCompilePartialRec (preDefs : Array PreDefinition) : TermElabM Unit := do\n  if preDefs.all shouldGenCodeFor then\n    withEnableInfoTree false do\n      addAndCompileUnsafe (safety := DefinitionSafety.partial) <| preDefs.map fun preDef =>\n        { preDef with\n          declName  := Compiler.mkUnsafeRecName preDef.declName\n          value     := preDef.value.replace fun e => match e with\n            | Expr.const declName us =>\n              if preDefs.any fun preDef => preDef.declName == declName then\n                some <| mkConst (Compiler.mkUnsafeRecName declName) us\n              else\n                none\n            | _ => none\n          modifiers := {} }", "start": [163, 1], "end": [176, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.containsRecFn", "code": "private def containsRecFn (recFnName : Name) (e : Expr) : Bool :=\n  (e.find? fun e => e.isConstOf recFnName).isSome", "start": [178, 1], "end": [179, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ensureNoRecFn", "code": "def ensureNoRecFn (recFnName : Name) (e : Expr) : MetaM Expr := do\n  if containsRecFn recFnName e then\n    Meta.forEachExpr e fun e => do\n      if e.isAppOf recFnName then\n        throwError \"unexpected occurrence of recursive application{indentExpr e}\"\n    pure e\n  else\n    pure e", "start": [181, 1], "end": [188, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/ForEachExpr.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Structural.RecArgInfo", "code": "structure RecArgInfo where\n  \n  fixedParams : Array Expr\n  \n  ys          : Array Expr\n  \n  pos         : Nat\n  \n  indicesPos  : Array Nat\n  \n  indName     : Name\n  \n  indLevels   : List Level\n  \n  indParams   : Array Expr\n  \n  indIndices  : Array Expr\n  \n  reflexive   : Bool\n  \n  indPred     : Bool", "start": [11, 1], "end": [31, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.RecArgInfo.recArgPos", "code": "def RecArgInfo.recArgPos (info : RecArgInfo) : Nat :=\n  info.fixedParams.size + info.pos", "start": [33, 1], "end": [34, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.State", "code": "structure State where\n  \n  addMatchers : Array (MetaM Unit) := #[]", "start": [36, 1], "end": [42, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.M", "code": "abbrev M := StateRefT State MetaM", "start": [44, 1], "end": [44, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.run", "code": "def run (x : M \u03b1) (s : State := {}) : MetaM (\u03b1 \u00d7 State) :=\n  StateRefT'.run x s", "start": [49, 1], "end": [50, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.recArgHasLooseBVarsAt", "code": "def recArgHasLooseBVarsAt (recFnName : Name) (recArgPos : Nat) (e : Expr) : Bool :=\n  let app?   := e.find? fun e =>\n     e.isAppOf recFnName && e.getAppNumArgs > recArgPos && (e.getArg! recArgPos).hasLooseBVars\n  app?.isSome", "start": [52, 1], "end": [64, 14], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Eqns.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Split.lean", "lake-packages/lean4/src/lean/Lean/Util/ForEachExprWhere.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Refl.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectFVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatchEqs.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eqns.lean"], "premises": [{"full_name": "Lean.Elab.Eqns.EqnInfoCore", "code": "structure EqnInfoCore where\n  declName    : Name\n  levelParams : List Name\n  type        : Expr\n  value       : Expr\n  deriving Inhabited", "start": [17, 1], "end": [22, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.expand", "code": "partial def expand : Expr \u2192 Expr\n  | Expr.letE _ _ v b _ => expand (b.instantiate1 v)\n  | Expr.mdata _ b      => expand b\n  | e => e", "start": [24, 1], "end": [27, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.expandRHS?", "code": "def expandRHS? (mvarId : MVarId) : MetaM (Option MVarId) := do\n  let target \u2190 mvarId.getType'\n  let some (_, lhs, rhs) := target.eq? | return none\n  unless rhs.isLet || rhs.isMData do return none\n  return some (\u2190 mvarId.replaceTargetDefEq (\u2190 mkEq lhs (expand rhs)))", "start": [29, 1], "end": [33, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.funext?", "code": "def funext? (mvarId : MVarId) : MetaM (Option MVarId) := do\n  let target \u2190 mvarId.getType'\n  let some (_, _, rhs) := target.eq? | return none\n  unless rhs.isLambda do return none\n  commitWhenSome? do\n    let [mvarId] \u2190 mvarId.apply (\u2190 mkConstWithFreshMVarLevels ``funext) | return none\n    let (_, mvarId) \u2190 mvarId.intro1\n    return some mvarId", "start": [35, 1], "end": [42, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.simpMatch?", "code": "def simpMatch? (mvarId : MVarId) : MetaM (Option MVarId) := do\n  let mvarId' \u2190 Split.simpMatchTarget mvarId\n  if mvarId != mvarId' then return some mvarId' else return none", "start": [44, 1], "end": [46, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.simpIf?", "code": "def simpIf? (mvarId : MVarId) : MetaM (Option MVarId) := do\n  let mvarId' \u2190 simpIfTarget mvarId (useDecide := true)\n  if mvarId != mvarId' then return some mvarId' else return none", "start": [48, 1], "end": [50, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.findMatchToSplit?", "code": "private def findMatchToSplit? (env : Environment) (e : Expr) (declNames : Array Name) (exceptionSet : ExprSet) : Option Expr :=\n  e.findExt? fun e => Id.run do\n    if e.hasLooseBVars || exceptionSet.contains e then\n      return Expr.FindStep.visit\n    else if let some info := isMatcherAppCore? env e then\n      let args := e.getAppArgs\n      let mut hasFVarDiscr := false\n      for i in [info.getFirstDiscrPos : info.getFirstDiscrPos + info.numDiscrs] do\n        let discr := args[i]!\n        if discr.isFVar then\n          hasFVarDiscr := true\n          break\n      unless hasFVarDiscr do\n        return Expr.FindStep.visit\n      for i in [info.getFirstAltPos : info.getFirstAltPos + info.numAlts] do\n        let alt := args[i]!\n        if Option.isSome <| alt.find? fun e => declNames.any e.isAppOf && e.hasLooseBVars then\n          return Expr.FindStep.found\n      return Expr.FindStep.visit\n    else\n      let Expr.const declName .. := e.getAppFn | return Expr.FindStep.visit\n      if declName == ``WellFounded.fix || isBRecOnRecursor env declName then\n        return Expr.FindStep.done\n      else\n        return Expr.FindStep.visit", "start": [52, 1], "end": [79, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.splitMatch?", "code": "partial def splitMatch? (mvarId : MVarId) (declNames : Array Name) : MetaM (Option (List MVarId)) := commitWhenSome? do\n  let target \u2190 mvarId.getType'\n  let rec go (badCases : ExprSet) : MetaM (Option (List MVarId)) := do\n    if let some e := findMatchToSplit? (\u2190 getEnv) target declNames badCases then\n      try\n        Meta.Split.splitMatch mvarId e\n      catch _ =>\n        go (badCases.insert e)\n    else\n      trace[Meta.Tactic.split] \"did not find term to split\\n{MessageData.ofGoal mvarId}\"\n      return none\n  go {}", "start": [81, 1], "end": [92, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.Context", "code": "structure Context where\n  declNames : Array Name", "start": [94, 1], "end": [95, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.lhsDependsOn", "code": "private def lhsDependsOn (type : Expr) (fvarId : FVarId) : MetaM Bool :=\n  forallTelescope type fun _ type => do\n    if let some (_, lhs, _) \u2190 matchEq? type then\n      dependsOn lhs fvarId\n    else\n      dependsOn type fvarId", "start": [97, 1], "end": [102, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.tryURefl", "code": "def tryURefl (mvarId : MVarId) : MetaM Bool :=\n  withOptions (smartUnfolding.set \u00b7 false) do\n    try mvarId.refl; return true catch _ => return false", "start": [104, 1], "end": [107, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.simpEqnType", "code": "def simpEqnType (eqnType : Expr) : MetaM Expr := do\n  forallTelescopeReducing (\u2190 instantiateMVars eqnType) fun ys type => do\n    let proofVars := collect type\n    trace[Elab.definition] \"simpEqnType type: {type}\"\n    let mut type \u2190 Match.unfoldNamedPattern type\n    let mut eliminated : FVarIdSet := {}\n    for y in ys.reverse do\n      trace[Elab.definition] \">> simpEqnType: {\u2190 inferType y}, {type}\"\n      if proofVars.contains y.fvarId! then\n        let some (_, Expr.fvar fvarId, rhs) \u2190 matchEq? (\u2190 inferType y) | throwError \"unexpected hypothesis in altenative{indentExpr eqnType}\"\n        eliminated := eliminated.insert fvarId\n        type := type.replaceFVarId fvarId rhs\n      else if eliminated.contains y.fvarId! then\n        if (\u2190 dependsOn type y.fvarId!) then\n          type \u2190 mkForallFVars #[y] type\n      else\n        if let some (_, lhs, rhs) \u2190 matchEq? (\u2190 inferType y) then\n          if (\u2190 isDefEq lhs rhs) then\n            if !(\u2190 dependsOn type y.fvarId!) then\n              continue\n            else if !(\u2190 lhsDependsOn type y.fvarId!) then\n              type := type.replaceFVar y (\u2190 mkEqRefl lhs)\n              continue\n        type \u2190 mkForallFVars #[y] type\n    return type\nwhere\n  collect (e : Expr) : FVarIdSet :=\n    let go (e : Expr) (\u03c9) : ST \u03c9 FVarIdSet := do\n      let ref \u2190 ST.mkRef {}\n      e.forEachWhere Match.isNamedPattern fun e => do\n        let some e := Match.isNamedPattern? e | unreachable!\n        let arg := e.appArg!.consumeMData\n        if arg.isFVar then\n          ST.Prim.Ref.modify ref (\u00b7.insert arg.fvarId!)\n      ST.Prim.Ref.get ref\n    runST (go e)", "start": [109, 1], "end": [149, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.saveEqn", "code": "private partial def saveEqn (mvarId : MVarId) : StateRefT (Array Expr) MetaM Unit := mvarId.withContext do\n  let target \u2190 mvarId.getType'\n  let fvarState := collectFVars {} target\n  let fvarState \u2190 (\u2190 getLCtx).foldrM (init := fvarState) fun decl fvarState => do\n    if fvarState.fvarSet.contains decl.fvarId then\n      return collectFVars fvarState (\u2190 instantiateMVars decl.type)\n    else\n      return fvarState\n  let mut fvarIdSet := fvarState.fvarSet\n  let mut fvarIds \u2190 sortFVarIds <| fvarState.fvarSet.toArray\n  let mut modified := false\n  repeat\n    modified := false\n    for decl in (\u2190 getLCtx) do\n      unless fvarIdSet.contains decl.fvarId do\n        if (\u2190 isProp decl.type) then\n          let type \u2190 instantiateMVars decl.type\n          unless (\u2190 isIrrelevant fvarIdSet type) do\n            modified := true\n            (fvarIdSet, fvarIds) \u2190 pushDecl fvarIdSet fvarIds decl\n  until !modified\n  let type \u2190 mkForallFVars (fvarIds.map mkFVar) target\n  let type \u2190 simpEqnType type\n  modify (\u00b7.push type)\nwhere\n  \n  isIrrelevant (fvarIdSet : FVarIdSet) (type : Expr) : MetaM Bool := do\n    if Option.isNone <| type.find? fun e => e.isFVar && fvarIdSet.contains e.fvarId! then\n      return true\n    else if let some (_, lhs, rhs) := type.eq? then\n      return (lhs.isFVar && !fvarIdSet.contains lhs.fvarId!)\n             || (rhs.isFVar && !fvarIdSet.contains rhs.fvarId!)\n    else\n      return false\n\n  pushDecl (fvarIdSet : FVarIdSet) (fvarIds : Array FVarId) (localDecl : LocalDecl) : MetaM (FVarIdSet \u00d7 Array FVarId) := do\n    let (fvarIdSet, fvarIds) \u2190 collectDeps fvarIdSet fvarIds (\u2190 instantiateMVars localDecl.type)\n    return (fvarIdSet.insert localDecl.fvarId, fvarIds.push localDecl.fvarId)\n\n  collectDeps (fvarIdSet : FVarIdSet) (fvarIds : Array FVarId) (type : Expr) : MetaM (FVarIdSet \u00d7 Array FVarId) := do\n    let s := collectFVars {} type\n    let usedFVarIds \u2190 sortFVarIds <| s.fvarSet.toArray\n    let mut fvarIdSet := fvarIdSet\n    let mut fvarIds := fvarIds\n    for fvarId in usedFVarIds do\n      unless fvarIdSet.contains fvarId do\n        (fvarIdSet, fvarIds) \u2190 pushDecl fvarIdSet fvarIds (\u2190 fvarId.getDecl)\n    return (fvarIdSet, fvarIds)", "start": [151, 1], "end": [203, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.shouldUseSimpMatch", "code": "private def shouldUseSimpMatch (e : Expr) : MetaM Bool := do\n  let env \u2190 getEnv\n  return Option.isSome <| e.find? fun e => Id.run do\n    if let some info := isMatcherAppCore? env e then\n      let args := e.getAppArgs\n      for discr in args[info.getFirstDiscrPos : info.getFirstDiscrPos + info.numDiscrs] do\n        if discr.isConstructorApp env then\n          return true\n    return false", "start": [205, 1], "end": [217, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.mkEqnTypes", "code": "partial def mkEqnTypes (declNames : Array Name) (mvarId : MVarId) : MetaM (Array Expr) := do\n  let (_, eqnTypes) \u2190 go mvarId |>.run { declNames } |>.run #[]\n  return eqnTypes\nwhere\n  go (mvarId : MVarId) : ReaderT Context (StateRefT (Array Expr) MetaM) Unit := do\n    trace[Elab.definition.eqns] \"mkEqnTypes step\\n{MessageData.ofGoal mvarId}\"\n    if (\u2190 tryURefl mvarId) then\n      saveEqn mvarId\n      return ()\n\n    if let some mvarId \u2190 expandRHS? mvarId then\n      return (\u2190 go mvarId)\nif (\u2190 shouldUseSimpMatch (\u2190 mvarId.getType')) then\n      if let some mvarId \u2190 simpMatch? mvarId then\n        return (\u2190 go mvarId)\n\n    if let some mvarIds \u2190 splitMatch? mvarId declNames then\n      return (\u2190 mvarIds.forM go)\n\n    saveEqn mvarId", "start": [219, 1], "end": [242, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.removeUnusedEqnHypotheses", "code": "def removeUnusedEqnHypotheses (declType declValue : Expr) : CoreM (Expr \u00d7 Expr) := do\n  go declType declValue #[] {}\nwhere\n  go (type value : Expr) (xs : Array Expr) (lctx : LocalContext) : CoreM (Expr \u00d7 Expr) := do\n    match value with\n    | .lam n d b bi =>\n      let d := d.instantiateRev xs\n      let fvarId \u2190 mkFreshFVarId\n      go (type.bindingBody!) b (xs.push (mkFVar fvarId)) (lctx.mkLocalDecl fvarId n d bi)\n    | _ =>\n      let type  := type.instantiateRev xs\n      let value := value.instantiateRev xs\n      let mut s := collectFVars (collectFVars {} type) value\n      let mut xsNew := #[]\n      for x in xs.reverse do\n        if s.fvarSet.contains x.fvarId! then\n          s := collectFVars s (lctx.getFVar! x).type\n          xsNew := xsNew.push x\n      if xsNew.size == xs.size then\n        return (declType, declValue)\n      else\n        xsNew := xsNew.reverse\n        return (lctx.mkForall xsNew type, lctx.mkLambda xsNew value)", "start": [244, 1], "end": [273, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.deltaLHS", "code": "def deltaLHS (mvarId : MVarId) : MetaM MVarId := mvarId.withContext do\n  let target \u2190 mvarId.getType'\n  let some (_, lhs, rhs) := target.eq? | throwTacticEx `deltaLHS mvarId \"equality expected\"\n  let some lhs \u2190 delta? lhs | throwTacticEx `deltaLHS mvarId \"failed to delta reduce lhs\"\n  mvarId.replaceTargetDefEq (\u2190 mkEq lhs rhs)", "start": [275, 1], "end": [280, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.deltaRHS?", "code": "def deltaRHS? (mvarId : MVarId) (declName : Name) : MetaM (Option MVarId) := mvarId.withContext do\n  let target \u2190 mvarId.getType'\n  let some (_, lhs, rhs) := target.eq? | return none\n  let some rhs \u2190 delta? rhs.consumeMData (\u00b7 == declName) | return none\n  mvarId.replaceTargetDefEq (\u2190 mkEq lhs rhs)", "start": [282, 1], "end": [286, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.whnfAux", "code": "private partial def whnfAux (e : Expr) : MetaM Expr := do\n  let e \u2190 whnfI e let f := e.getAppFn\n  match f with\n  | .proj _ _ s => return mkAppN (f.updateProj! (\u2190 whnfAux s)) e.getAppArgs\n  | _ => return e", "start": [288, 1], "end": [293, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.whnfReducibleLHS?", "code": "def whnfReducibleLHS? (mvarId : MVarId) : MetaM (Option MVarId) := mvarId.withContext do\n  let target \u2190 mvarId.getType'\n  let some (_, lhs, rhs) := target.eq? | return none\n  let lhs' \u2190 whnfAux lhs\n  if lhs' != lhs then\n    return some (\u2190 mvarId.replaceTargetDefEq (\u2190 mkEq lhs' rhs))\n  else\n    return none", "start": [295, 1], "end": [303, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.tryContradiction", "code": "def tryContradiction (mvarId : MVarId) : MetaM Bool := do\n  mvarId.contradictionCore { genDiseq := true }", "start": [305, 1], "end": [306, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.UnfoldEqnExtState", "code": "structure UnfoldEqnExtState where\n  map : PHashMap Name Name := {}\n  deriving Inhabited", "start": [308, 1], "end": [310, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.mkUnfoldProof", "code": "partial def mkUnfoldProof (declName : Name) (mvarId : MVarId) : MetaM Unit := do\n  let some eqs \u2190 getEqnsFor? declName | throwError \"failed to generate equations for '{declName}'\"\n  let tryEqns (mvarId : MVarId) : MetaM Bool :=\n    eqs.anyM fun eq => commitWhen do\n      try\n        let subgoals \u2190 mvarId.apply (\u2190 mkConstWithFreshMVarLevels eq)\n        subgoals.allM fun subgoal => do\n          if (\u2190 subgoal.isAssigned) then\n            return true else\n            subgoal.assumptionCore\n      catch _ =>\n        return false\n  let rec go (mvarId : MVarId) : MetaM Unit := do\n    if (\u2190 tryEqns mvarId) then\n      return ()\n    if (\u2190 shouldUseSimpMatch (\u2190 mvarId.getType')) then\n      if let some mvarId \u2190 simpMatch? mvarId then\n        return (\u2190 go mvarId)\n\n    if let some mvarIds \u2190 splitTarget? mvarId (splitIte := false) then\n      return (\u2190 mvarIds.forM go)\n\n    if (\u2190 tryContradiction mvarId) then\n      return ()\n\n    throwError \"failed to generate unfold theorem for '{declName}'\\n{MessageData.ofGoal mvarId}\"\n  go mvarId", "start": [316, 1], "end": [357, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.mkUnfoldEq", "code": "def mkUnfoldEq (declName : Name) (info : EqnInfoCore) : MetaM Name := withLCtx {} {} do\n  let env \u2190 getEnv\n  withOptions (tactic.hygienic.set \u00b7 false) do\n    let baseName := mkPrivateName env declName\n    lambdaTelescope info.value fun xs body => do\n      let us := info.levelParams.map mkLevelParam\n      let type \u2190 mkEq (mkAppN (Lean.mkConst declName us) xs) body\n      let goal \u2190 mkFreshExprSyntheticOpaqueMVar type\n      mkUnfoldProof declName goal.mvarId!\n      let type \u2190 mkForallFVars xs type\n      let value \u2190 mkLambdaFVars xs (\u2190 instantiateMVars goal)\n      let name := baseName ++ `_unfold\n      addDecl <| Declaration.thmDecl {\n        name, type, value\n        levelParams := info.levelParams\n      }\n      return name", "start": [359, 1], "end": [376, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Eqns.getUnfoldFor?", "code": "def getUnfoldFor? (declName : Name) (getInfo? : Unit \u2192 Option EqnInfoCore) : MetaM (Option Name) := do\n  let env \u2190 getEnv\n  if let some eq := unfoldEqnExt.getState env |>.map.find? declName then\n    return some eq\n  else if let some info := getInfo? () then\n    let eq \u2190 mkUnfoldEq declName info\n    modifyEnv fun env => unfoldEqnExt.modifyState env fun s => { s with map := s.map.insert declName eq }\n    return some eq\n  else\n    return none", "start": [378, 1], "end": [387, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/List/Lemmas.lean", "imports": ["lake-packages/std/Std/Control/ForInStep/Lemmas.lean", "lake-packages/std/Std/Tactic/Simpa.lean", "lake-packages/std/Std/Data/Option/Lemmas.lean", "lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/std/Std/Tactic/Ext.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Classes/BEq.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean"], "premises": [{"full_name": "List.cons_ne_nil", "code": "theorem cons_ne_nil (a : \u03b1) (l : List \u03b1) : a :: l \u2260 []", "start": [20, 1], "end": [20, 63], "kind": "commanddeclaration"}, {"full_name": "List.cons_ne_self", "code": "theorem cons_ne_self (a : \u03b1) (l : List \u03b1) : a :: l \u2260 l", "start": [22, 1], "end": [22, 100], "kind": "commanddeclaration"}, {"full_name": "List.head_eq_of_cons_eq", "code": "theorem head_eq_of_cons_eq (H : h\u2081 :: t\u2081 = h\u2082 :: t\u2082) : h\u2081 = h\u2082", "start": [24, 1], "end": [24, 81], "kind": "commanddeclaration"}, {"full_name": "List.tail_eq_of_cons_eq", "code": "theorem tail_eq_of_cons_eq (H : h\u2081 :: t\u2081 = h\u2082 :: t\u2082) : t\u2081 = t\u2082", "start": [26, 1], "end": [26, 81], "kind": "commanddeclaration"}, {"full_name": "List.cons_inj", "code": "theorem cons_inj (a : \u03b1) {l l' : List \u03b1} : a :: l = a :: l' \u2194 l = l'", "start": [28, 1], "end": [29, 35], "kind": "commanddeclaration"}, {"full_name": "List.exists_cons_of_ne_nil", "code": "theorem exists_cons_of_ne_nil : \u2200 {l : List \u03b1}, l \u2260 [] \u2192 \u2203 b L, l = b :: L", "start": [31, 1], "end": [32, 31], "kind": "commanddeclaration"}, {"full_name": "List.length_singleton", "code": "@[simp 1100] theorem length_singleton (a : \u03b1) : length [a] = 1", "start": [36, 1], "end": [36, 70], "kind": "commanddeclaration"}, {"full_name": "List.length_pos_of_mem", "code": "theorem length_pos_of_mem {a : \u03b1} : \u2200 {l : List \u03b1}, a \u2208 l \u2192 0 < length l", "start": [38, 1], "end": [39, 34], "kind": "commanddeclaration"}, {"full_name": "List.exists_mem_of_length_pos", "code": "theorem exists_mem_of_length_pos : \u2200 {l : List \u03b1}, 0 < length l \u2192 \u2203 a, a \u2208 l", "start": [41, 1], "end": [42, 29], "kind": "commanddeclaration"}, {"full_name": "List.length_pos_iff_exists_mem", "code": "theorem length_pos_iff_exists_mem {l : List \u03b1} : 0 < length l \u2194 \u2203 a, a \u2208 l", "start": [44, 1], "end": [45, 64], "kind": "commanddeclaration"}, {"full_name": "List.length_pos", "code": "theorem length_pos {l : List \u03b1} : 0 < length l \u2194 l \u2260 []", "start": [47, 1], "end": [48, 55], "kind": "commanddeclaration"}, {"full_name": "List.exists_mem_of_ne_nil", "code": "theorem exists_mem_of_ne_nil (l : List \u03b1) (h : l \u2260 []) : \u2203 x, x \u2208 l", "start": [50, 1], "end": [51, 44], "kind": "commanddeclaration"}, {"full_name": "List.length_eq_one", "code": "theorem length_eq_one {l : List \u03b1} : length l = 1 \u2194 \u2203 a, l = [a]", "start": [53, 1], "end": [54, 77], "kind": "commanddeclaration"}, {"full_name": "List.not_mem_nil", "code": "@[simp] theorem not_mem_nil (a : \u03b1) : \u00ac a \u2208 []", "start": [58, 1], "end": [58, 55], "kind": "commanddeclaration"}, {"full_name": "List.mem_nil_iff", "code": "theorem mem_nil_iff (a : \u03b1) : a \u2208 ([] : List \u03b1) \u2194 False", "start": [60, 1], "end": [60, 67], "kind": "commanddeclaration"}, {"full_name": "List.mem_cons", "code": "@[simp] theorem mem_cons : a \u2208 (b :: l) \u2194 a = b \u2228 a \u2208 l", "start": [62, 1], "end": [64, 80], "kind": "commanddeclaration"}, {"full_name": "List.mem_cons_self", "code": "theorem mem_cons_self (a : \u03b1) (l : List \u03b1) : a \u2208 a :: l", "start": [66, 1], "end": [66, 68], "kind": "commanddeclaration"}, {"full_name": "List.mem_cons_of_mem", "code": "theorem mem_cons_of_mem (y : \u03b1) {a : \u03b1} {l : List \u03b1} : a \u2208 l \u2192 a \u2208 y :: l", "start": [68, 1], "end": [68, 85], "kind": "commanddeclaration"}, {"full_name": "List.mem_singleton_self", "code": "theorem mem_singleton_self (a : \u03b1) : a \u2208 [a]", "start": [70, 1], "end": [70, 66], "kind": "commanddeclaration"}, {"full_name": "List.eq_of_mem_singleton", "code": "theorem eq_of_mem_singleton : a \u2208 [b] \u2192 a = b", "start": [72, 1], "end": [73, 20], "kind": "commanddeclaration"}, {"full_name": "List.mem_singleton", "code": "@[simp 1100] theorem mem_singleton {a b : \u03b1} : a \u2208 [b] \u2194 a = b", "start": [75, 1], "end": [76, 39], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_cons_of_mem", "code": "theorem mem_of_mem_cons_of_mem : \u2200 {a b : \u03b1} {l : List \u03b1}, a \u2208 b :: l \u2192 b \u2208 l \u2192 a \u2208 l", "start": [78, 1], "end": [79, 54], "kind": "commanddeclaration"}, {"full_name": "List.eq_or_ne_mem_of_mem", "code": "theorem eq_or_ne_mem_of_mem {a b : \u03b1} {l : List \u03b1} (h' : a \u2208 b :: l) : a = b \u2228 (a \u2260 b \u2227 a \u2208 l)", "start": [81, 1], "end": [82, 74], "kind": "commanddeclaration"}, {"full_name": "List.ne_nil_of_mem", "code": "theorem ne_nil_of_mem {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) : l \u2260 []", "start": [84, 1], "end": [84, 89], "kind": "commanddeclaration"}, {"full_name": "List.append_of_mem", "code": "theorem append_of_mem {a : \u03b1} {l : List \u03b1} : a \u2208 l \u2192 \u2203 s t : List \u03b1, l = s ++ a :: t", "start": [86, 1], "end": [88, 87], "kind": "commanddeclaration"}, {"full_name": "List.elem_iff", "code": "@[simp] theorem elem_iff [DecidableEq \u03b1] {a : \u03b1} {as : List \u03b1} :\n    elem a as \u2194 a \u2208 as", "start": [90, 1], "end": [91, 69], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_ne_of_mem", "code": "theorem mem_of_ne_of_mem {a y : \u03b1} {l : List \u03b1} (h\u2081 : a \u2260 y) (h\u2082 : a \u2208 y :: l) : a \u2208 l", "start": [93, 1], "end": [94, 45], "kind": "commanddeclaration"}, {"full_name": "List.ne_of_not_mem_cons", "code": "theorem ne_of_not_mem_cons {a b : \u03b1} {l : List \u03b1} : a \u2209 b::l \u2192 a \u2260 b", "start": [96, 1], "end": [96, 89], "kind": "commanddeclaration"}, {"full_name": "List.not_mem_of_not_mem_cons", "code": "theorem not_mem_of_not_mem_cons {a b : \u03b1} {l : List \u03b1} : a \u2209 b::l \u2192 a \u2209 l", "start": [98, 1], "end": [98, 90], "kind": "commanddeclaration"}, {"full_name": "List.not_mem_cons_of_ne_of_not_mem", "code": "theorem not_mem_cons_of_ne_of_not_mem {a y : \u03b1} {l : List \u03b1} : a \u2260 y \u2192 a \u2209 l \u2192 a \u2209 y::l", "start": [100, 1], "end": [101, 24], "kind": "commanddeclaration"}, {"full_name": "List.ne_and_not_mem_of_not_mem_cons", "code": "theorem ne_and_not_mem_of_not_mem_cons {a y : \u03b1} {l : List \u03b1} : a \u2209 y::l \u2192 a \u2260 y \u2227 a \u2209 l", "start": [103, 1], "end": [104, 61], "kind": "commanddeclaration"}, {"full_name": "List.append_eq_append", "code": "theorem append_eq_append : List.append l\u2081 l\u2082 = l\u2081 ++ l\u2082", "start": [108, 1], "end": [108, 63], "kind": "commanddeclaration"}, {"full_name": "List.append_eq_nil", "code": "@[simp] theorem append_eq_nil : p ++ q = [] \u2194 p = [] \u2227 q = []", "start": [110, 1], "end": [111, 19], "kind": "commanddeclaration"}, {"full_name": "List.append_ne_nil_of_ne_nil_left", "code": "theorem append_ne_nil_of_ne_nil_left (s t : List \u03b1) : s \u2260 [] \u2192 s ++ t \u2260 []", "start": [113, 1], "end": [113, 90], "kind": "commanddeclaration"}, {"full_name": "List.append_ne_nil_of_ne_nil_right", "code": "theorem append_ne_nil_of_ne_nil_right (s t : List \u03b1) : t \u2260 [] \u2192 s ++ t \u2260 []", "start": [115, 1], "end": [115, 91], "kind": "commanddeclaration"}, {"full_name": "List.nil_eq_append", "code": "@[simp] theorem nil_eq_append : [] = a ++ b \u2194 a = [] \u2227 b = []", "start": [117, 1], "end": [118, 30], "kind": "commanddeclaration"}, {"full_name": "List.append_ne_nil_of_left_ne_nil", "code": "theorem append_ne_nil_of_left_ne_nil (a b : List \u03b1) (h0 : a \u2260 []) : a ++ b \u2260 []", "start": [120, 1], "end": [120, 95], "kind": "commanddeclaration"}, {"full_name": "List.append_eq_cons", "code": "theorem append_eq_cons :\n    a ++ b = x :: c \u2194 (a = [] \u2227 b = x :: c) \u2228 (\u2203 a', a = x :: a' \u2227 c = a' ++ b)", "start": [122, 1], "end": [125, 89], "kind": "commanddeclaration"}, {"full_name": "List.cons_eq_append", "code": "theorem cons_eq_append :\n    x :: c = a ++ b \u2194 (a = [] \u2227 b = x :: c) \u2228 (\u2203 a', a = x :: a' \u2227 c = a' ++ b)", "start": [127, 1], "end": [129, 31], "kind": "commanddeclaration"}, {"full_name": "List.append_eq_append_iff", "code": "theorem append_eq_append_iff {a b c d : List \u03b1} :\n  a ++ b = c ++ d \u2194 (\u2203 a', c = a ++ a' \u2227 b = a' ++ d) \u2228 \u2203 c', a = c ++ c' \u2227 d = c' ++ b", "start": [131, 1], "end": [135, 75], "kind": "commanddeclaration"}, {"full_name": "List.mem_append", "code": "@[simp] theorem mem_append {a : \u03b1} {s t : List \u03b1} : a \u2208 s ++ t \u2194 a \u2208 s \u2228 a \u2208 t", "start": [137, 1], "end": [138, 38], "kind": "commanddeclaration"}, {"full_name": "List.not_mem_append", "code": "theorem not_mem_append {a : \u03b1} {s t : List \u03b1} (h\u2081 : a \u2209 s) (h\u2082 : a \u2209 t) : a \u2209 s ++ t", "start": [140, 1], "end": [141, 40], "kind": "commanddeclaration"}, {"full_name": "List.mem_append_eq", "code": "theorem mem_append_eq (a : \u03b1) (s t : List \u03b1) : (a \u2208 s ++ t) = (a \u2208 s \u2228 a \u2208 t)", "start": [143, 1], "end": [144, 21], "kind": "commanddeclaration"}, {"full_name": "List.mem_append_left", "code": "theorem mem_append_left {a : \u03b1} {l\u2081 : List \u03b1} (l\u2082 : List \u03b1) (h : a \u2208 l\u2081) : a \u2208 l\u2081 ++ l\u2082", "start": [146, 1], "end": [147, 26], "kind": "commanddeclaration"}, {"full_name": "List.mem_append_right", "code": "theorem mem_append_right {a : \u03b1} (l\u2081 : List \u03b1) {l\u2082 : List \u03b1} (h : a \u2208 l\u2082) : a \u2208 l\u2081 ++ l\u2082", "start": [149, 1], "end": [150, 26], "kind": "commanddeclaration"}, {"full_name": "List.mem_iff_append", "code": "theorem mem_iff_append {a : \u03b1} {l : List \u03b1} : a \u2208 l \u2194 \u2203 s t : List \u03b1, l = s ++ a :: t", "start": [152, 1], "end": [153, 48], "kind": "commanddeclaration"}, {"full_name": "List.map_singleton", "code": "theorem map_singleton (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : map f [a] = [f a]", "start": [157, 1], "end": [157, 69], "kind": "commanddeclaration"}, {"full_name": "List.mem_map", "code": "@[simp] theorem mem_map {f : \u03b1 \u2192 \u03b2} : \u2200 {l : List \u03b1}, b \u2208 l.map f \u2194 \u2203 a, a \u2208 l \u2227 f a = b", "start": [159, 1], "end": [161, 59], "kind": "commanddeclaration"}, {"full_name": "List.mem_map_of_mem", "code": "theorem mem_map_of_mem (f : \u03b1 \u2192 \u03b2) (h : a \u2208 l) : f a \u2208 map f l", "start": [163, 1], "end": [163, 88], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_mem_map", "code": "theorem exists_of_mem_map (h : b \u2208 map f l) : \u2203 a, a \u2208 l \u2227 f a = b", "start": [165, 1], "end": [165, 82], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_map_iff", "code": "theorem forall_mem_map_iff {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {P : \u03b2 \u2192 Prop} :\n    (\u2200 i \u2208 l.map f, P i) \u2194 \u2200 j \u2208 l, P (f j)", "start": [167, 1], "end": [169, 7], "kind": "commanddeclaration"}, {"full_name": "List.map_eq_nil", "code": "@[simp] theorem map_eq_nil {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} : map f l = [] \u2194 l = []", "start": [171, 1], "end": [172, 58], "kind": "commanddeclaration"}, {"full_name": "List.length_zipWith", "code": "@[simp] theorem length_zipWith (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l\u2081 l\u2082) :\n    length (zipWith f l\u2081 l\u2082) = min (length l\u2081) (length l\u2082)", "start": [176, 1], "end": [179, 66], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_map", "code": "@[simp]\ntheorem zipWith_map {\u03bc} (f : \u03b3 \u2192 \u03b4 \u2192 \u03bc) (g : \u03b1 \u2192 \u03b3) (h : \u03b2 \u2192 \u03b4) (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) :\n    zipWith f (l\u2081.map g) (l\u2082.map h) = zipWith (fun a b => f (g a) (h b)) l\u2081 l\u2082", "start": [181, 1], "end": [184, 57], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_map_left", "code": "theorem zipWith_map_left (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) (f : \u03b1 \u2192 \u03b1') (g : \u03b1' \u2192 \u03b2 \u2192 \u03b3) :\n    zipWith g (l\u2081.map f) l\u2082 = zipWith (fun a b => g (f a) b) l\u2081 l\u2082", "start": [186, 1], "end": [188, 57], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_map_right", "code": "theorem zipWith_map_right (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) (f : \u03b2 \u2192 \u03b2') (g : \u03b1 \u2192 \u03b2' \u2192 \u03b3) :\n    zipWith g l\u2081 (l\u2082.map f) = zipWith (fun a b => g a (f b)) l\u2081 l\u2082", "start": [190, 1], "end": [192, 57], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_foldr_eq_zip_foldr", "code": "theorem zipWith_foldr_eq_zip_foldr {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (i : \u03b4):\n    (zipWith f l\u2081 l\u2082).foldr g i = (zip l\u2081 l\u2082).foldr (fun p r => g (f p.1 p.2) r) i", "start": [194, 1], "end": [196, 57], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_foldl_eq_zip_foldl", "code": "theorem zipWith_foldl_eq_zip_foldl {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (i : \u03b4):\n    (zipWith f l\u2081 l\u2082).foldl g i = (zip l\u2081 l\u2082).foldl (fun r p => g r (f p.1 p.2)) i", "start": [198, 1], "end": [200, 59], "kind": "commanddeclaration"}, {"full_name": "List.length_zip", "code": "@[simp] theorem length_zip (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) :\n    length (zip l\u2081 l\u2082) = min (length l\u2081) (length l\u2082)", "start": [204, 1], "end": [206, 13], "kind": "commanddeclaration"}, {"full_name": "List.zip_map", "code": "theorem zip_map (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) :\n    \u2200 (l\u2081 : List \u03b1) (l\u2082 : List \u03b2), zip (l\u2081.map f) (l\u2082.map g) = (zip l\u2081 l\u2082).map (Prod.map f g)", "start": [208, 1], "end": [213, 67], "kind": "commanddeclaration"}, {"full_name": "List.zip_map_left", "code": "theorem zip_map_left (f : \u03b1 \u2192 \u03b3) (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) :\n    zip (l\u2081.map f) l\u2082 = (zip l\u2081 l\u2082).map (Prod.map f id)", "start": [215, 1], "end": [216, 85], "kind": "commanddeclaration"}, {"full_name": "List.zip_map_right", "code": "theorem zip_map_right (f : \u03b2 \u2192 \u03b3) (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) :\n    zip l\u2081 (l\u2082.map f) = (zip l\u2081 l\u2082).map (Prod.map id f)", "start": [218, 1], "end": [219, 85], "kind": "commanddeclaration"}, {"full_name": "List.mem_join", "code": "theorem mem_join : \u2200 {L : List (List \u03b1)}, a \u2208 L.join \u2194 \u2203 l, l \u2208 L \u2227 a \u2208 l", "start": [223, 1], "end": [225, 58], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_mem_join", "code": "theorem exists_of_mem_join : a \u2208 join L \u2192 \u2203 l, l \u2208 L \u2227 a \u2208 l", "start": [227, 1], "end": [227, 75], "kind": "commanddeclaration"}, {"full_name": "List.mem_join_of_mem", "code": "theorem mem_join_of_mem (lL : l \u2208 L) (al : a \u2208 l) : a \u2208 join L", "start": [229, 1], "end": [229, 89], "kind": "commanddeclaration"}, {"full_name": "List.mem_bind", "code": "theorem mem_bind {f : \u03b1 \u2192 List \u03b2} {b} {l : List \u03b1} : b \u2208 l.bind f \u2194 \u2203 a, a \u2208 l \u2227 b \u2208 f a", "start": [233, 1], "end": [235, 93], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_mem_bind", "code": "theorem exists_of_mem_bind {b : \u03b2} {l : List \u03b1} {f : \u03b1 \u2192 List \u03b2} :\n    b \u2208 List.bind l f \u2192 \u2203 a, a \u2208 l \u2227 b \u2208 f a", "start": [237, 1], "end": [238, 59], "kind": "commanddeclaration"}, {"full_name": "List.mem_bind_of_mem", "code": "theorem mem_bind_of_mem {b : \u03b2} {l : List \u03b1} {f : \u03b1 \u2192 List \u03b2} {a} (al : a \u2208 l) (h : b \u2208 f a) :\n    b \u2208 List.bind l f", "start": [240, 1], "end": [241, 47], "kind": "commanddeclaration"}, {"full_name": "List.bind_map", "code": "theorem bind_map (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 List \u03b2) :\n    \u2200 l : List \u03b1, map f (l.bind g) = l.bind fun a => (g a).map f", "start": [243, 1], "end": [246, 65], "kind": "commanddeclaration"}, {"full_name": "List.empty_eq", "code": "@[simp] theorem empty_eq : (\u2205 : List \u03b1) = []", "start": [250, 1], "end": [250, 52], "kind": "commanddeclaration"}, {"full_name": "List.exists_mem_nil", "code": "theorem exists_mem_nil (p : \u03b1 \u2192 Prop) : \u00ac\u2203 x \u2208 @nil \u03b1, p x", "start": [254, 1], "end": [254, 67], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_nil", "code": "theorem forall_mem_nil (p : \u03b1 \u2192 Prop) : \u2200 x \u2208 @nil \u03b1, p x", "start": [256, 1], "end": [256, 66], "kind": "commanddeclaration"}, {"full_name": "List.exists_mem_cons", "code": "theorem exists_mem_cons {p : \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1} :\n    (\u2203 x \u2208 a :: l, p x) \u2194 p a \u2228 \u2203 x \u2208 l, p x", "start": [258, 1], "end": [259, 56], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_singleton", "code": "theorem forall_mem_singleton {p : \u03b1 \u2192 Prop} {a : \u03b1} : (\u2200 x \u2208 [a], p x) \u2194 p a", "start": [261, 1], "end": [262, 39], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_append", "code": "theorem forall_mem_append {p : \u03b1 \u2192 Prop} {l\u2081 l\u2082 : List \u03b1} :\n    (\u2200 x \u2208 l\u2081 ++ l\u2082, p x) \u2194 (\u2200 x \u2208 l\u2081, p x) \u2227 (\u2200 x \u2208 l\u2082, p x)", "start": [264, 1], "end": [266, 45], "kind": "commanddeclaration"}, {"full_name": "List.subset_def", "code": "theorem subset_def {l\u2081 l\u2082 : List \u03b1} : l\u2081 \u2286 l\u2082 \u2194 \u2200 {a : \u03b1}, a \u2208 l\u2081 \u2192 a \u2208 l\u2082", "start": [270, 1], "end": [270, 83], "kind": "commanddeclaration"}, {"full_name": "List.nil_subset", "code": "@[simp] theorem nil_subset (l : List \u03b1) : [] \u2286 l", "start": [272, 1], "end": [272, 57], "kind": "commanddeclaration"}, {"full_name": "List.Subset.refl", "code": "@[simp] theorem Subset.refl (l : List \u03b1) : l \u2286 l", "start": [274, 1], "end": [274, 65], "kind": "commanddeclaration"}, {"full_name": "List.Subset.trans", "code": "theorem Subset.trans {l\u2081 l\u2082 l\u2083 : List \u03b1} (h\u2081 : l\u2081 \u2286 l\u2082) (h\u2082 : l\u2082 \u2286 l\u2083) : l\u2081 \u2286 l\u2083", "start": [276, 1], "end": [277, 23], "kind": "commanddeclaration"}, {"full_name": "List.subset_cons", "code": "@[simp] theorem subset_cons (a : \u03b1) (l : List \u03b1) : l \u2286 a :: l", "start": [285, 1], "end": [285, 85], "kind": "commanddeclaration"}, {"full_name": "List.subset_of_cons_subset", "code": "theorem subset_of_cons_subset {a : \u03b1} {l\u2081 l\u2082 : List \u03b1} : a :: l\u2081 \u2286 l\u2082 \u2192 l\u2081 \u2286 l\u2082", "start": [287, 1], "end": [288, 39], "kind": "commanddeclaration"}, {"full_name": "List.subset_cons_of_subset", "code": "theorem subset_cons_of_subset (a : \u03b1) {l\u2081 l\u2082 : List \u03b1} : l\u2081 \u2286 l\u2082 \u2192 l\u2081 \u2286 a :: l\u2082", "start": [290, 1], "end": [291, 29], "kind": "commanddeclaration"}, {"full_name": "List.cons_subset_cons", "code": "theorem cons_subset_cons {l\u2081 l\u2082 : List \u03b1} (a : \u03b1) (s : l\u2081 \u2286 l\u2082) : a :: l\u2081 \u2286 a :: l\u2082", "start": [293, 1], "end": [294, 62], "kind": "commanddeclaration"}, {"full_name": "List.subset_append_left", "code": "@[simp] theorem subset_append_left (l\u2081 l\u2082 : List \u03b1) : l\u2081 \u2286 l\u2081 ++ l\u2082", "start": [296, 1], "end": [296, 98], "kind": "commanddeclaration"}, {"full_name": "List.subset_append_right", "code": "@[simp] theorem subset_append_right (l\u2081 l\u2082 : List \u03b1) : l\u2082 \u2286 l\u2081 ++ l\u2082", "start": [298, 1], "end": [298, 100], "kind": "commanddeclaration"}, {"full_name": "List.subset_append_of_subset_left", "code": "theorem subset_append_of_subset_left (l\u2082 : List \u03b1) : l \u2286 l\u2081 \u2192 l \u2286 l\u2081 ++ l\u2082", "start": [300, 1], "end": [301, 50], "kind": "commanddeclaration"}, {"full_name": "List.subset_append_of_subset_right", "code": "theorem subset_append_of_subset_right (l\u2081 : List \u03b1) : l \u2286 l\u2082 \u2192 l \u2286 l\u2081 ++ l\u2082", "start": [303, 1], "end": [304, 51], "kind": "commanddeclaration"}, {"full_name": "List.cons_subset", "code": "@[simp] theorem cons_subset : a :: l \u2286 m \u2194 a \u2208 m \u2227 l \u2286 m", "start": [306, 1], "end": [307, 66], "kind": "commanddeclaration"}, {"full_name": "List.append_subset", "code": "@[simp] theorem append_subset {l\u2081 l\u2082 l : List \u03b1} :\n    l\u2081 ++ l\u2082 \u2286 l \u2194 l\u2081 \u2286 l \u2227 l\u2082 \u2286 l", "start": [309, 1], "end": [310, 79], "kind": "commanddeclaration"}, {"full_name": "List.subset_nil", "code": "theorem subset_nil {l : List \u03b1} : l \u2286 [] \u2194 l = []", "start": [312, 1], "end": [313, 97], "kind": "commanddeclaration"}, {"full_name": "List.eq_nil_iff_forall_not_mem", "code": "theorem eq_nil_iff_forall_not_mem {l : List \u03b1} : l = [] \u2194 \u2200 a, a \u2209 l", "start": [315, 1], "end": [316, 48], "kind": "commanddeclaration"}, {"full_name": "List.map_subset", "code": "theorem map_subset {l\u2081 l\u2082 : List \u03b1} (f : \u03b1 \u2192 \u03b2) (H : l\u2081 \u2286 l\u2082) : map f l\u2081 \u2286 map f l\u2082", "start": [318, 1], "end": [319, 72], "kind": "commanddeclaration"}, {"full_name": "List.replicate_succ", "code": "theorem replicate_succ (a : \u03b1) (n) : replicate (n+1) a = a :: replicate n a", "start": [323, 1], "end": [323, 83], "kind": "commanddeclaration"}, {"full_name": "List.mem_replicate", "code": "theorem mem_replicate {a b : \u03b1} : \u2200 {n}, b \u2208 replicate n a \u2194 n \u2260 0 \u2227 b = a", "start": [325, 1], "end": [327, 53], "kind": "commanddeclaration"}, {"full_name": "List.eq_of_mem_replicate", "code": "theorem eq_of_mem_replicate {a b : \u03b1} {n} (h : b \u2208 replicate n a) : b = a", "start": [329, 1], "end": [329, 99], "kind": "commanddeclaration"}, {"full_name": "List.eq_replicate_of_mem", "code": "theorem eq_replicate_of_mem {a : \u03b1} :\n    \u2200 {l : List \u03b1}, (\u2200 b \u2208 l, b = a) \u2192 l = replicate l.length a", "start": [331, 1], "end": [336, 58], "kind": "commanddeclaration"}, {"full_name": "List.eq_replicate", "code": "theorem eq_replicate {a : \u03b1} {n} {l : List \u03b1} :\n    l = replicate n a \u2194 length l = n \u2227 \u2200 b \u2208 l, b = a", "start": [338, 1], "end": [341, 46], "kind": "commanddeclaration"}, {"full_name": "List.getLast_cons'", "code": "theorem getLast_cons' {a : \u03b1} {l : List \u03b1} : \u2200 (h\u2081 : a :: l \u2260 nil) (h\u2082 : l \u2260 nil),\n  getLast (a :: l) h\u2081 = getLast l h\u2082", "start": [345, 1], "end": [347, 47], "kind": "commanddeclaration"}, {"full_name": "List.getLast_append", "code": "@[simp] theorem getLast_append {a : \u03b1} : \u2200 (l : List \u03b1) h, getLast (l ++ [a]) h = a", "start": [349, 1], "end": [352, 92], "kind": "commanddeclaration"}, {"full_name": "List.getLast_concat", "code": "theorem getLast_concat : (h : concat l a \u2260 []) \u2192 getLast (concat l a) h = a", "start": [354, 1], "end": [355, 41], "kind": "commanddeclaration"}, {"full_name": "List.eq_nil_or_concat", "code": "theorem eq_nil_or_concat : \u2200 l : List \u03b1, l = [] \u2228 \u2203 L b, l = L ++ [b]", "start": [357, 1], "end": [361, 49], "kind": "commanddeclaration"}, {"full_name": "List.nil_sublist", "code": "@[simp] theorem nil_sublist : \u2200 l : List \u03b1, [] <+ l", "start": [365, 1], "end": [367, 37], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.refl", "code": "@[simp] theorem Sublist.refl : \u2200 l : List \u03b1, l <+ l", "start": [369, 1], "end": [371, 39], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.trans", "code": "theorem Sublist.trans {l\u2081 l\u2082 l\u2083 : List \u03b1} (h\u2081 : l\u2081 <+ l\u2082) (h\u2082 : l\u2082 <+ l\u2083) : l\u2081 <+ l\u2083", "start": [373, 1], "end": [382, 53], "kind": "commanddeclaration"}, {"full_name": "List.sublist_cons", "code": "@[simp] theorem sublist_cons (a : \u03b1) (l : List \u03b1) : l <+ a :: l", "start": [386, 1], "end": [386, 91], "kind": "commanddeclaration"}, {"full_name": "List.sublist_of_cons_sublist", "code": "theorem sublist_of_cons_sublist : a :: l\u2081 <+ l\u2082 \u2192 l\u2081 <+ l\u2082", "start": [388, 1], "end": [389, 28], "kind": "commanddeclaration"}, {"full_name": "List.sublist_append_left", "code": "@[simp] theorem sublist_append_left : \u2200 l\u2081 l\u2082 : List \u03b1, l\u2081 <+ l\u2081 ++ l\u2082", "start": [391, 1], "end": [393, 55], "kind": "commanddeclaration"}, {"full_name": "List.sublist_append_right", "code": "@[simp] theorem sublist_append_right : \u2200 l\u2081 l\u2082 : List \u03b1, l\u2082 <+ l\u2081 ++ l\u2082", "start": [395, 1], "end": [397, 55], "kind": "commanddeclaration"}, {"full_name": "List.sublist_append_of_sublist_left", "code": "theorem sublist_append_of_sublist_left (s : l <+ l\u2081) : l <+ l\u2081 ++ l\u2082", "start": [399, 1], "end": [400, 36], "kind": "commanddeclaration"}, {"full_name": "List.sublist_append_of_sublist_right", "code": "theorem sublist_append_of_sublist_right (s : l <+ l\u2082) : l <+ l\u2081 ++ l\u2082", "start": [402, 1], "end": [403, 37], "kind": "commanddeclaration"}, {"full_name": "List.cons_sublist_cons", "code": "theorem cons_sublist_cons : a :: l\u2081 <+ a :: l\u2082 \u2194 l\u2081 <+ l\u2082", "start": [405, 1], "end": [406, 77], "kind": "commanddeclaration"}, {"full_name": "List.append_sublist_append_left", "code": "@[simp] theorem append_sublist_append_left : \u2200 l, l ++ l\u2081 <+ l ++ l\u2082 \u2194 l\u2081 <+ l\u2082", "start": [408, 1], "end": [410, 69], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.append_left", "code": "theorem Sublist.append_left : l\u2081 <+ l\u2082 \u2192 \u2200 l, l ++ l\u2081 <+ l ++ l\u2082", "start": [412, 1], "end": [413, 50], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.append_right", "code": "theorem Sublist.append_right : l\u2081 <+ l\u2082 \u2192 \u2200 l, l\u2081 ++ l <+ l\u2082 ++ l", "start": [415, 1], "end": [418, 48], "kind": "commanddeclaration"}, {"full_name": "List.sublist_or_mem_of_sublist", "code": "theorem sublist_or_mem_of_sublist (h : l <+ l\u2081 ++ a :: l\u2082) : l <+ l\u2081 ++ l\u2082 \u2228 a \u2208 l", "start": [420, 1], "end": [428, 65], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.reverse", "code": "theorem Sublist.reverse : l\u2081 <+ l\u2082 \u2192 l\u2081.reverse <+ l\u2082.reverse", "start": [430, 1], "end": [433, 85], "kind": "commanddeclaration"}, {"full_name": "List.reverse_sublist", "code": "@[simp] theorem reverse_sublist : l\u2081.reverse <+ l\u2082.reverse \u2194 l\u2081 <+ l\u2082", "start": [435, 1], "end": [436, 82], "kind": "commanddeclaration"}, {"full_name": "List.append_sublist_append_right", "code": "@[simp] theorem append_sublist_append_right (l) : l\u2081 ++ l <+ l\u2082 ++ l \u2194 l\u2081 <+ l\u2082", "start": [438, 1], "end": [443, 30], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.append", "code": "theorem Sublist.append (hl : l\u2081 <+ l\u2082) (hr : r\u2081 <+ r\u2082) : l\u2081 ++ r\u2081 <+ l\u2082 ++ r\u2082", "start": [445, 1], "end": [446, 66], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.subset", "code": "theorem Sublist.subset : l\u2081 <+ l\u2082 \u2192 l\u2081 \u2286 l\u2082", "start": [448, 1], "end": [452, 53], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.length_le", "code": "theorem Sublist.length_le : l\u2081 <+ l\u2082 \u2192 length l\u2081 \u2264 length l\u2082", "start": [463, 1], "end": [466, 45], "kind": "commanddeclaration"}, {"full_name": "List.sublist_nil", "code": "@[simp] theorem sublist_nil {l : List \u03b1} : l <+ [] \u2194 l = []", "start": [468, 1], "end": [469, 64], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.eq_of_length", "code": "theorem Sublist.eq_of_length : l\u2081 <+ l\u2082 \u2192 length l\u2081 = length l\u2082 \u2192 l\u2081 = l\u2082", "start": [471, 1], "end": [474, 57], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.eq_of_length_le", "code": "theorem Sublist.eq_of_length_le (s : l\u2081 <+ l\u2082) (h : length l\u2082 \u2264 length l\u2081) : l\u2081 = l\u2082", "start": [476, 1], "end": [477, 50], "kind": "commanddeclaration"}, {"full_name": "List.singleton_sublist", "code": "@[simp] theorem singleton_sublist {a : \u03b1} {l} : [a] <+ l \u2194 a \u2208 l", "start": [479, 1], "end": [482, 66], "kind": "commanddeclaration"}, {"full_name": "List.replicate_sublist_replicate", "code": "@[simp] theorem replicate_sublist_replicate {m n} (a : \u03b1) :\n    replicate m a <+ replicate n a \u2194 m \u2264 n", "start": [484, 1], "end": [490, 48], "kind": "commanddeclaration"}, {"full_name": "List.isSublist_iff_sublist", "code": "theorem isSublist_iff_sublist [DecidableEq \u03b1] {l\u2081 l\u2082 : List \u03b1} : l\u2081.isSublist l\u2082 \u2194 l\u2081 <+ l\u2082", "start": [492, 1], "end": [508, 24], "kind": "commanddeclaration"}, {"full_name": "List.head!_of_head?", "code": "theorem head!_of_head? [Inhabited \u03b1] : \u2200 {l : List \u03b1}, head? l = some a \u2192 head! l = a", "start": [515, 1], "end": [516, 23], "kind": "commanddeclaration"}, {"full_name": "List.head?_eq_head", "code": "theorem head?_eq_head : \u2200 l h, @head? \u03b1 l = some (head l h)", "start": [518, 1], "end": [520, 19], "kind": "commanddeclaration"}, {"full_name": "List.tailD_eq_tail?", "code": "@[simp] theorem tailD_eq_tail? (l l' : List \u03b1) : tailD l l' = (tail? l).getD l'", "start": [524, 1], "end": [525, 18], "kind": "commanddeclaration"}, {"full_name": "List.tail_eq_tailD", "code": "theorem tail_eq_tailD (l) : @tail \u03b1 l = tailD l []", "start": [527, 1], "end": [527, 73], "kind": "commanddeclaration"}, {"full_name": "List.tail_eq_tail?", "code": "theorem tail_eq_tail? (l) : @tail \u03b1 l = (tail? l).getD []", "start": [529, 1], "end": [529, 85], "kind": "commanddeclaration"}, {"full_name": "List.next?_nil", "code": "@[simp] theorem next?_nil : @next? \u03b1 [] = none", "start": [533, 1], "end": [533, 54], "kind": "commanddeclaration"}, {"full_name": "List.next?_cons", "code": "@[simp] theorem next?_cons (a l) : @next? \u03b1 (a :: l) = some (a, l)", "start": [534, 1], "end": [534, 74], "kind": "commanddeclaration"}, {"full_name": "List.getLastD_nil", "code": "@[simp] theorem getLastD_nil (a) : @getLastD \u03b1 [] a = a", "start": [538, 1], "end": [538, 63], "kind": "commanddeclaration"}, {"full_name": "List.getLastD_cons", "code": "@[simp] theorem getLastD_cons (a b l) : @getLastD \u03b1 (b::l) a = getLastD l b", "start": [539, 1], "end": [539, 98], "kind": "commanddeclaration"}, {"full_name": "List.getLast_eq_getLastD", "code": "theorem getLast_eq_getLastD (a l h) : @getLast \u03b1 (a::l) h = getLastD l a", "start": [541, 1], "end": [542, 18], "kind": "commanddeclaration"}, {"full_name": "List.getLastD_eq_getLast?", "code": "theorem getLastD_eq_getLast? (a l) : @getLastD \u03b1 l a = (getLast? l).getD a", "start": [544, 1], "end": [545, 18], "kind": "commanddeclaration"}, {"full_name": "List.getLast_singleton", "code": "theorem getLast_singleton (a h) : @getLast \u03b1 [a] h = a", "start": [547, 1], "end": [547, 62], "kind": "commanddeclaration"}, {"full_name": "List.getLast!_cons", "code": "theorem getLast!_cons [Inhabited \u03b1] : @getLast! \u03b1 _ (a::l) = getLastD l a", "start": [549, 1], "end": [550, 39], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_nil", "code": "@[simp] theorem getLast?_nil : @getLast? \u03b1 [] = none", "start": [552, 1], "end": [552, 60], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_cons", "code": "theorem getLast?_cons : @getLast? \u03b1 (a::l) = getLastD l a", "start": [553, 1], "end": [554, 39], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_eq_getLast", "code": "theorem getLast?_eq_getLast : \u2200 l h, @getLast? \u03b1 l = some (getLast l h)", "start": [556, 1], "end": [558, 19], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_append_cons", "code": "@[simp] theorem dropLast_append_cons : dropLast (l\u2081 ++ b::l\u2082) = l\u2081 ++ dropLast (b::l\u2082)", "start": [562, 1], "end": [563, 38], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_concat", "code": "@[simp 1100] theorem dropLast_concat : dropLast (l\u2081 ++ [b]) = l\u2081", "start": [565, 1], "end": [565, 76], "kind": "commanddeclaration"}, {"full_name": "List.get_cons_succ", "code": "@[simp] theorem get_cons_succ {as : List \u03b1} {h : i + 1 < (a :: as).length} :\n  (a :: as).get \u27e8i+1, h\u27e9 = as.get \u27e8i, Nat.lt_of_succ_lt_succ h\u27e9", "start": [569, 1], "end": [570, 71], "kind": "commanddeclaration"}, {"full_name": "List.get_cons_succ'", "code": "@[simp] theorem get_cons_succ' {as : List \u03b1} {i : Fin as.length} :\n  (a :: as).get i.succ = as.get i", "start": [572, 1], "end": [573, 41], "kind": "commanddeclaration"}, {"full_name": "List.get_cons_cons_one", "code": "@[simp] theorem get_cons_cons_one : (a\u2081 :: a\u2082 :: as).get (1 : Fin (as.length + 2)) = a\u2082", "start": [575, 1], "end": [575, 95], "kind": "commanddeclaration"}, {"full_name": "List.get_of_mem", "code": "theorem get_of_mem : \u2200 {a} {l : List \u03b1}, a \u2208 l \u2192 \u2203 n, get l n = a", "start": [577, 1], "end": [579, 92], "kind": "commanddeclaration"}, {"full_name": "List.get?_eq_get", "code": "theorem get?_eq_get : \u2200 {l : List \u03b1} {n} (h : n < l.length), l.get? n = some (get l \u27e8n, h\u27e9)", "start": [581, 1], "end": [583, 45], "kind": "commanddeclaration"}, {"full_name": "List.get!_cons_succ", "code": "theorem get!_cons_succ [Inhabited \u03b1] (l : List \u03b1) (a : \u03b1) (n : Nat) :\n    (a::l).get! (n+1) = get! l n", "start": [585, 1], "end": [586, 40], "kind": "commanddeclaration"}, {"full_name": "List.get!_cons_zero", "code": "theorem get!_cons_zero [Inhabited \u03b1] (l : List \u03b1) (a : \u03b1) : (a::l).get! 0 = a", "start": [588, 1], "end": [588, 85], "kind": "commanddeclaration"}, {"full_name": "List.get!_nil", "code": "theorem get!_nil [Inhabited \u03b1] (n : Nat) : [].get! n = (default : \u03b1)", "start": [590, 1], "end": [590, 76], "kind": "commanddeclaration"}, {"full_name": "List.get?_len_le", "code": "theorem get?_len_le : \u2200 {l : List \u03b1} {n}, length l \u2264 n \u2192 l.get? n = none", "start": [592, 1], "end": [594, 71], "kind": "commanddeclaration"}, {"full_name": "List.get!_len_le", "code": "theorem get!_len_le [Inhabited \u03b1] : \u2200 {l : List \u03b1} {n}, length l \u2264 n \u2192 l.get! n = (default : \u03b1)", "start": [596, 1], "end": [598, 71], "kind": "commanddeclaration"}, {"full_name": "List.get?_eq_some", "code": "theorem get?_eq_some : l.get? n = some a \u2194 \u2203 h, get l \u27e8n, h\u27e9 = a", "start": [600, 1], "end": [604, 35], "kind": "commanddeclaration"}, {"full_name": "List.get?_eq_none", "code": "@[simp] theorem get?_eq_none : l.get? n = none \u2194 length l \u2264 n", "start": [606, 1], "end": [607, 93], "kind": "commanddeclaration"}, {"full_name": "List.get?_of_mem", "code": "theorem get?_of_mem {a} {l : List \u03b1} (h : a \u2208 l) : \u2203 n, l.get? n = some a", "start": [609, 1], "end": [610, 58], "kind": "commanddeclaration"}, {"full_name": "List.get_mem", "code": "theorem get_mem : \u2200 (l : List \u03b1) n h, get l \u27e8n, h\u27e9 \u2208 l", "start": [612, 1], "end": [614, 45], "kind": "commanddeclaration"}, {"full_name": "List.get?_mem", "code": "theorem get?_mem {l : List \u03b1} {n a} (e : l.get? n = some a) : a \u2208 l", "start": [616, 1], "end": [617, 49], "kind": "commanddeclaration"}, {"full_name": "List.mem_iff_get", "code": "theorem mem_iff_get {a} {l : List \u03b1} : a \u2208 l \u2194 \u2203 n, get l n = a", "start": [619, 1], "end": [620, 45], "kind": "commanddeclaration"}, {"full_name": "List.Fin.exists_iff", "code": "theorem Fin.exists_iff (p : Fin n \u2192 Prop) : (\u2203 i, p i) \u2194 \u2203 i h, p \u27e8i, h\u27e9", "start": [623, 1], "end": [624, 64], "kind": "commanddeclaration"}, {"full_name": "List.mem_iff_get?", "code": "theorem mem_iff_get? {a} {l : List \u03b1} : a \u2208 l \u2194 \u2203 n, l.get? n = some a", "start": [626, 1], "end": [627, 51], "kind": "commanddeclaration"}, {"full_name": "List.get?_zero", "code": "theorem get?_zero (l : List \u03b1) : l.get? 0 = l.head?", "start": [629, 1], "end": [629, 74], "kind": "commanddeclaration"}, {"full_name": "List.getElem_eq_get", "code": "@[simp] theorem getElem_eq_get (l : List \u03b1) (i : Nat) (h) : l[i]'h = l.get \u27e8i, h\u27e9", "start": [631, 1], "end": [631, 89], "kind": "commanddeclaration"}, {"full_name": "List.getElem?_eq_get?", "code": "@[simp] theorem getElem?_eq_get? (l : List \u03b1) (i : Nat) : l[i]? = l.get? i", "start": [633, 1], "end": [636, 52], "kind": "commanddeclaration"}, {"full_name": "List.get?_inj", "code": "theorem get?_inj\n    (h\u2080 : i < xs.length) (h\u2081 : Nodup xs) (h\u2082 : xs.get? i = xs.get? j) : i = j", "start": [638, 1], "end": [653, 39], "kind": "commanddeclaration"}, {"full_name": "List.get?_map", "code": "@[simp] theorem get?_map (f : \u03b1 \u2192 \u03b2) : \u2200 l n, (map f l).get? n = (l.get? n).map f", "start": [655, 1], "end": [658, 34], "kind": "commanddeclaration"}, {"full_name": "List.get_map", "code": "@[simp] theorem get_map (f : \u03b1 \u2192 \u03b2) {l n} : get (map f l) n = f (get l \u27e8n, length_map l f \u25b8 n.2\u27e9)", "start": [660, 1], "end": [661, 71], "kind": "commanddeclaration"}, {"full_name": "List.get_of_eq", "code": "theorem get_of_eq {l l' : List \u03b1} (h : l = l') (i : Fin l.length) :\n    get l i = get l' \u27e8i, h \u25b8 i.2\u27e9", "start": [663, 1], "end": [669, 53], "kind": "commanddeclaration"}, {"full_name": "List.get_singleton", "code": "@[simp] theorem get_singleton (a : \u03b1) : (n : Fin 1) \u2192 get [a] n = a", "start": [671, 1], "end": [672, 18], "kind": "commanddeclaration"}, {"full_name": "List.get_zero", "code": "theorem get_zero : \u2200 {l : List \u03b1} (h : 0 < l.length), l.get \u27e80, h\u27e9 = l.head?", "start": [674, 1], "end": [675, 19], "kind": "commanddeclaration"}, {"full_name": "List.get_append", "code": "theorem get_append : \u2200 {l\u2081 l\u2082 : List \u03b1} (n : Nat) (h : n < l\u2081.length),\n    (l\u2081 ++ l\u2082).get \u27e8n, length_append .. \u25b8 Nat.lt_add_right _ _ _ h\u27e9 = l\u2081.get \u27e8n, h\u27e9", "start": [677, 1], "end": [680, 73], "kind": "commanddeclaration"}, {"full_name": "List.get?_append_right", "code": "theorem get?_append_right : \u2200 {l\u2081 l\u2082 : List \u03b1} {n : Nat}, l\u2081.length \u2264 n \u2192\n  (l\u2081 ++ l\u2082).get? n = l\u2082.get? (n - l\u2081.length)", "start": [682, 1], "end": [685, 89], "kind": "commanddeclaration"}, {"full_name": "List.get_append_right_aux", "code": "theorem get_append_right_aux {l\u2081 l\u2082 : List \u03b1} {n : Nat}\n  (h\u2081 : l\u2081.length \u2264 n) (h\u2082 : n < (l\u2081 ++ l\u2082).length) : n - l\u2081.length < l\u2082.length", "start": [687, 1], "end": [690, 40], "kind": "commanddeclaration"}, {"full_name": "List.get_append_right'", "code": "theorem get_append_right' {l\u2081 l\u2082 : List \u03b1} {n : Nat} (h\u2081 : l\u2081.length \u2264 n) (h\u2082) :\n    (l\u2081 ++ l\u2082).get \u27e8n, h\u2082\u27e9 = l\u2082.get \u27e8n - l\u2081.length, get_append_right_aux h\u2081 h\u2082\u27e9", "start": [692, 1], "end": [694, 78], "kind": "commanddeclaration"}, {"full_name": "List.get_of_append_proof", "code": "theorem get_of_append_proof {l : List \u03b1}\n    (eq : l = l\u2081 ++ a :: l\u2082) (h : l\u2081.length = n) : n < length l", "start": [696, 1], "end": [697, 90], "kind": "commanddeclaration"}, {"full_name": "List.get_of_append", "code": "theorem get_of_append {l : List \u03b1} (eq : l = l\u2081 ++ a :: l\u2082) (h : l\u2081.length = n) :\n    l.get \u27e8n, get_of_append_proof eq h\u27e9 = a", "start": [699, 1], "end": [701, 86], "kind": "commanddeclaration"}, {"full_name": "List.get_replicate", "code": "@[simp] theorem get_replicate (a : \u03b1) {n : Nat} (m : Fin _) : (replicate n a).get m = a", "start": [703, 1], "end": [704, 38], "kind": "commanddeclaration"}, {"full_name": "List.get?_append", "code": "theorem get?_append {l\u2081 l\u2082 : List \u03b1} {n : Nat} (hn : n < l\u2081.length) :\n  (l\u2081 ++ l\u2082).get? n = l\u2081.get? n", "start": [706, 1], "end": [710, 51], "kind": "commanddeclaration"}, {"full_name": "List.getLast_eq_get", "code": "theorem getLast_eq_get : \u2200 (l : List \u03b1) (h : l \u2260 []),\n    getLast l h = l.get \u27e8l.length - 1, Nat.sub_lt (length_pos.2 h) Nat.one_pos\u27e9", "start": [712, 1], "end": [716, 99], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_eq_get?", "code": "theorem getLast?_eq_get? : \u2200 (l : List \u03b1), getLast? l = l.get? (l.length - 1)", "start": [718, 1], "end": [720, 81], "kind": "commanddeclaration"}, {"full_name": "List.get?_concat_length", "code": "@[simp] theorem get?_concat_length : \u2200 (l : List \u03b1) (a : \u03b1), (l ++ [a]).get? l.length = some a", "start": [722, 1], "end": [724, 88], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_concat", "code": "@[simp] theorem getLast?_concat (l : List \u03b1) : getLast? (l ++ [a]) = some a", "start": [726, 1], "end": [727, 26], "kind": "commanddeclaration"}, {"full_name": "List.getLastD_concat", "code": "@[simp] theorem getLastD_concat (a b l) : @getLastD \u03b1 (l ++ [b]) a = b", "start": [729, 1], "end": [730, 50], "kind": "commanddeclaration"}, {"full_name": "List.get_cons_length", "code": "theorem get_cons_length (x : \u03b1) (xs : List \u03b1) (n : Nat) (h : n = xs.length) :\n    (x :: xs).get \u27e8n, by simp [h]\u27e9 = (x :: xs).getLast (cons_ne_nil x xs)", "start": [732, 1], "end": [734, 36], "kind": "commanddeclaration"}, {"full_name": "List.ext", "code": "@[ext] theorem ext : \u2200 {l\u2081 l\u2082 : List \u03b1}, (\u2200 n, l\u2081.get? n = l\u2082.get? n) \u2192 l\u2081 = l\u2082", "start": [736, 1], "end": [742, 63], "kind": "commanddeclaration"}, {"full_name": "List.ext_get", "code": "theorem ext_get {l\u2081 l\u2082 : List \u03b1} (hl : length l\u2081 = length l\u2082)\n    (h : \u2200 n h\u2081 h\u2082, get l\u2081 \u27e8n, h\u2081\u27e9 = get l\u2082 \u27e8n, h\u2082\u27e9) : l\u2081 = l\u2082", "start": [744, 1], "end": [751, 51], "kind": "commanddeclaration"}, {"full_name": "List.get?_reverse'", "code": "theorem get?_reverse' : \u2200 {l : List \u03b1} (i j), i + j + 1 = length l \u2192\n    get? l.reverse i = get? l j", "start": [753, 1], "end": [760, 80], "kind": "commanddeclaration"}, {"full_name": "List.get?_reverse", "code": "theorem get?_reverse {l : List \u03b1} (i) (h : i < length l) :\n    get? l.reverse i = get? l (l.length - 1 - i)", "start": [762, 1], "end": [766, 65], "kind": "commanddeclaration"}, {"full_name": "List.get!_of_get?", "code": "theorem get!_of_get? [Inhabited \u03b1] : \u2200 {l : List \u03b1} {n}, get? l n = some a \u2192 get! l n = a", "start": [768, 1], "end": [770, 44], "kind": "commanddeclaration"}, {"full_name": "List.getD_eq_get?", "code": "theorem getD_eq_get? : \u2200 l n (a : \u03b1), getD l n a = (get? l n).getD a", "start": [772, 1], "end": [775, 45], "kind": "commanddeclaration"}, {"full_name": "List.get!_eq_getD", "code": "@[simp] theorem get!_eq_getD [Inhabited \u03b1] : \u2200 (l : List \u03b1) n, l.get! n = l.getD n default", "start": [777, 1], "end": [780, 35], "kind": "commanddeclaration"}, {"full_name": "List.take_succ_cons", "code": "@[simp] theorem take_succ_cons : (a :: as).take (i + 1) = a :: as.take i", "start": [784, 1], "end": [784, 80], "kind": "commanddeclaration"}, {"full_name": "List.length_take", "code": "@[simp] theorem length_take : \u2200 (i : Nat) (l : List \u03b1), length (take i l) = min i (length l)", "start": [786, 1], "end": [789, 72], "kind": "commanddeclaration"}, {"full_name": "List.length_take_le", "code": "theorem length_take_le (n) (l : List \u03b1) : length (take n l) \u2264 n", "start": [791, 1], "end": [791, 93], "kind": "commanddeclaration"}, {"full_name": "List.length_take_of_le", "code": "theorem length_take_of_le (h : n \u2264 length l) : length (take n l) = n", "start": [793, 1], "end": [793, 100], "kind": "commanddeclaration"}, {"full_name": "List.get_cons_drop", "code": "theorem get_cons_drop : \u2200 (l : List \u03b1) i, get l i :: drop (i + 1) l = drop i l", "start": [795, 1], "end": [797, 45], "kind": "commanddeclaration"}, {"full_name": "List.drop_eq_nil_of_eq_nil", "code": "theorem drop_eq_nil_of_eq_nil : \u2200 {as : List \u03b1} {i}, as = [] \u2192 as.drop i = []", "start": [799, 1], "end": [800, 26], "kind": "commanddeclaration"}, {"full_name": "List.take_eq_nil_of_eq_nil", "code": "theorem take_eq_nil_of_eq_nil : \u2200 {as : List \u03b1} {i}, as = [] \u2192 as.take i = []", "start": [802, 1], "end": [803, 26], "kind": "commanddeclaration"}, {"full_name": "List.ne_nil_of_drop_ne_nil", "code": "theorem ne_nil_of_drop_ne_nil {as : List \u03b1} {i : Nat} (h: as.drop i \u2260 []) : as \u2260 []", "start": [805, 1], "end": [806, 29], "kind": "commanddeclaration"}, {"full_name": "List.ne_nil_of_take_ne_nil", "code": "theorem ne_nil_of_take_ne_nil {as : List \u03b1} {i : Nat} (h: as.take i \u2260 []) : as \u2260 []", "start": [808, 1], "end": [809, 29], "kind": "commanddeclaration"}, {"full_name": "List.map_eq_append_split", "code": "theorem map_eq_append_split {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} {s\u2081 s\u2082 : List \u03b2}\n    (h : map f l = s\u2081 ++ s\u2082) : \u2203 l\u2081 l\u2082, l = l\u2081 ++ l\u2082 \u2227 map f l\u2081 = s\u2081 \u2227 map f l\u2082 = s\u2082", "start": [811, 1], "end": [819, 25], "kind": "commanddeclaration"}, {"full_name": "List.drop_append_eq_append_drop", "code": "theorem drop_append_eq_append_drop {l\u2081 l\u2082 : List \u03b1} :\n    drop n (l\u2081 ++ l\u2082) = drop n l\u2081 ++ drop (n - l\u2081.length) l\u2082", "start": [821, 1], "end": [826, 23], "kind": "commanddeclaration"}, {"full_name": "List.drop_append_of_le_length", "code": "theorem drop_append_of_le_length {l\u2081 l\u2082 : List \u03b1} (h : n \u2264 l\u2081.length) :\n    (l\u2081 ++ l\u2082).drop n = l\u2081.drop n ++ l\u2082", "start": [828, 1], "end": [830, 61], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTail_id", "code": "theorem modifyNthTail_id : \u2200 n (l : List \u03b1), l.modifyNthTail id n = l", "start": [834, 1], "end": [837, 60], "kind": "commanddeclaration"}, {"full_name": "List.removeNth_eq_nth_tail", "code": "theorem removeNth_eq_nth_tail : \u2200 n (l : List \u03b1), removeNth l n = modifyNthTail tail n l", "start": [839, 1], "end": [842, 65], "kind": "commanddeclaration"}, {"full_name": "List.get?_modifyNth", "code": "theorem get?_modifyNth (f : \u03b1 \u2192 \u03b1) :\n    \u2200 n (l : List \u03b1) m, (modifyNth f n l).get? m = (fun a => if n = m then f a else a) <$> l.get? m", "start": [844, 1], "end": [852, 93], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTail_length", "code": "theorem modifyNthTail_length (f : List \u03b1 \u2192 List \u03b1) (H : \u2200 l, length (f l) = length l) :\n    \u2200 n l, length (modifyNthTail f n l) = length l", "start": [854, 1], "end": [858, 65], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTail_add", "code": "theorem modifyNthTail_add (f : List \u03b1 \u2192 List \u03b1) (n) (l\u2081 l\u2082 : List \u03b1) :\n    modifyNthTail f (l\u2081.length + n) (l\u2081 ++ l\u2082) = l\u2081 ++ modifyNthTail f n l\u2082", "start": [860, 1], "end": [862, 42], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_modifyNthTail", "code": "theorem exists_of_modifyNthTail (f : List \u03b1 \u2192 List \u03b1) {n} {l : List \u03b1} (h : n \u2264 l.length) :\n    \u2203 l\u2081 l\u2082, l = l\u2081 ++ l\u2082 \u2227 l\u2081.length = n \u2227 modifyNthTail f n l = l\u2081 ++ f l\u2082", "start": [864, 1], "end": [868, 58], "kind": "commanddeclaration"}, {"full_name": "List.modify_get?_length", "code": "@[simp] theorem modify_get?_length (f : \u03b1 \u2192 \u03b1) : \u2200 n l, length (modifyNth f n l) = length l", "start": [870, 1], "end": [871, 53], "kind": "commanddeclaration"}, {"full_name": "List.get?_modifyNth_eq", "code": "@[simp] theorem get?_modifyNth_eq (f : \u03b1 \u2192 \u03b1) (n) (l : List \u03b1) :\n  (modifyNth f n l).get? n = f <$> l.get? n", "start": [873, 1], "end": [875, 37], "kind": "commanddeclaration"}, {"full_name": "List.get?_modifyNth_ne", "code": "@[simp] theorem get?_modifyNth_ne (f : \u03b1 \u2192 \u03b1) {m n} (l : List \u03b1) (h : m \u2260 n) :\n    (modifyNth f m l).get? n = l.get? n", "start": [877, 1], "end": [879, 48], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_modifyNth", "code": "theorem exists_of_modifyNth (f : \u03b1 \u2192 \u03b1) {n} {l : List \u03b1} (h : n < l.length) :\n    \u2203 l\u2081 a l\u2082, l = l\u2081 ++ a :: l\u2082 \u2227 l\u2081.length = n \u2227 modifyNth f n l = l\u2081 ++ f a :: l\u2082", "start": [881, 1], "end": [885, 74], "kind": "commanddeclaration"}, {"full_name": "List.set_eq_modifyNth", "code": "theorem set_eq_modifyNth (a : \u03b1) : \u2200 n (l : List \u03b1), set l n a = modifyNth (fun _ => a) n l", "start": [889, 1], "end": [892, 62], "kind": "commanddeclaration"}, {"full_name": "List.modifyNth_eq_set_get?", "code": "theorem modifyNth_eq_set_get? (f : \u03b1 \u2192 \u03b1) :\n    \u2200 n (l : List \u03b1), l.modifyNth f n = ((fun a => l.set n (f a)) <$> l.get? n).getD l", "start": [894, 1], "end": [899, 86], "kind": "commanddeclaration"}, {"full_name": "List.modifyNth_eq_set_get", "code": "theorem modifyNth_eq_set_get (f : \u03b1 \u2192 \u03b1) {n} {l : List \u03b1} (h) :\n    l.modifyNth f n = l.set n (f (l.get \u27e8n, h\u27e9))", "start": [901, 1], "end": [903, 49], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_set", "code": "theorem exists_of_set {l : List \u03b1} (h : n < l.length) :\n    \u2203 l\u2081 a l\u2082, l = l\u2081 ++ a :: l\u2082 \u2227 l\u2081.length = n \u2227 l.set n a' = l\u2081 ++ a' :: l\u2082", "start": [905, 1], "end": [907, 55], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_set'", "code": "theorem exists_of_set' {l : List \u03b1} (h : n < l.length) :\n    \u2203 l\u2081 l\u2082, l = l\u2081 ++ l.get \u27e8n, h\u27e9 :: l\u2082 \u2227 l\u2081.length = n \u2227 l.set n a' = l\u2081 ++ a' :: l\u2082", "start": [909, 1], "end": [911, 90], "kind": "commanddeclaration"}, {"full_name": "List.get?_set_eq", "code": "theorem get?_set_eq (a : \u03b1) (n) (l : List \u03b1) : (set l n a).get? n = (fun _ => a) <$> l.get? n", "start": [913, 1], "end": [914, 50], "kind": "commanddeclaration"}, {"full_name": "List.get?_set_eq_of_lt", "code": "theorem get?_set_eq_of_lt (a : \u03b1) {n} {l : List \u03b1} (h : n < length l) :\n  (set l n a).get? n = some a", "start": [916, 1], "end": [917, 73], "kind": "commanddeclaration"}, {"full_name": "List.get?_set_ne", "code": "theorem get?_set_ne (a : \u03b1) {m n} (l : List \u03b1) (h : m \u2260 n) : (set l m a).get? n = l.get? n", "start": [919, 1], "end": [920, 56], "kind": "commanddeclaration"}, {"full_name": "List.get?_set", "code": "theorem get?_set (a : \u03b1) {m n} (l : List \u03b1) :\n    (set l m a).get? n = if m = n then (fun _ => a) <$> l.get? n else l.get? n", "start": [922, 1], "end": [924, 56], "kind": "commanddeclaration"}, {"full_name": "List.get?_set_of_lt", "code": "theorem get?_set_of_lt (a : \u03b1) {m n} (l : List \u03b1) (h : n < length l) :\n    (set l m a).get? n = if m = n then some a else l.get? n", "start": [926, 1], "end": [928, 33], "kind": "commanddeclaration"}, {"full_name": "List.get?_set_of_lt'", "code": "theorem get?_set_of_lt' (a : \u03b1) {m n} (l : List \u03b1) (h : m < length l) :\n    (set l m a).get? n = if m = n then some a else l.get? n", "start": [930, 1], "end": [932, 68], "kind": "commanddeclaration"}, {"full_name": "List.set_nil", "code": "@[simp] theorem set_nil (n : Nat) (a : \u03b1) : [].set n a = []", "start": [934, 1], "end": [934, 67], "kind": "commanddeclaration"}, {"full_name": "List.set_succ", "code": "@[simp] theorem set_succ (x : \u03b1) (xs : List \u03b1) (n : Nat) (a : \u03b1) :\n  (x :: xs).set n.succ a = x :: xs.set n a", "start": [936, 1], "end": [937, 50], "kind": "commanddeclaration"}, {"full_name": "List.set_comm", "code": "theorem set_comm (a b : \u03b1) : \u2200 {n m : Nat} (l : List \u03b1), n \u2260 m \u2192\n    (l.set n a).set m b = (l.set m b).set n a", "start": [939, 1], "end": [945, 69], "kind": "commanddeclaration"}, {"full_name": "List.set_set", "code": "theorem set_set (a b : \u03b1) : \u2200 (l : List \u03b1) (n : Nat), (l.set n a).set n b = l.set n b", "start": [947, 1], "end": [950, 42], "kind": "commanddeclaration"}, {"full_name": "List.get_set_eq", "code": "@[simp] theorem get_set_eq (l : List \u03b1) (i : Nat) (a : \u03b1) (h : i < (l.set i a).length) :\n    (l.set i a).get \u27e8i, h\u27e9 = a", "start": [952, 1], "end": [954, 79], "kind": "commanddeclaration"}, {"full_name": "List.get_set_ne", "code": "@[simp] theorem get_set_ne {l : List \u03b1} {i j : Nat} (h : i \u2260 j) (a : \u03b1)\n    (hj : j < (l.set i a).length) :\n    (l.set i a).get \u27e8j, hj\u27e9 = l.get \u27e8j, by simp at hj; exact hj\u27e9", "start": [956, 1], "end": [959, 72], "kind": "commanddeclaration"}, {"full_name": "List.get_set", "code": "theorem get_set (a : \u03b1) {m n} (l : List \u03b1) (h) :\n    (set l m a).get \u27e8n, h\u27e9 = if m = n then a else l.get \u27e8n, length_set .. \u25b8 h\u27e9", "start": [961, 1], "end": [963, 48], "kind": "commanddeclaration"}, {"full_name": "List.mem_or_eq_of_mem_set", "code": "theorem mem_or_eq_of_mem_set : \u2200 {l : List \u03b1} {n : Nat} {a b : \u03b1}, a \u2208 l.set n b \u2192 a \u2208 l \u2228 a = b", "start": [965, 1], "end": [968, 80], "kind": "commanddeclaration"}, {"full_name": "List.length_removeNth", "code": "theorem length_removeNth : \u2200 {l i}, i < length l \u2192 length (@removeNth \u03b1 l i) = length l - 1", "start": [972, 1], "end": [978, 93], "kind": "commanddeclaration"}, {"full_name": "List.length_tail", "code": "@[simp] theorem length_tail (l : List \u03b1) : length (tail l) = length l - 1", "start": [982, 1], "end": [982, 96], "kind": "commanddeclaration"}, {"full_name": "List.all_eq_true", "code": "@[simp] theorem all_eq_true {l : List \u03b1} : l.all p \u2194 \u2200 x \u2208 l, p x", "start": [986, 1], "end": [986, 97], "kind": "commanddeclaration"}, {"full_name": "List.any_eq_true", "code": "@[simp] theorem any_eq_true {l : List \u03b1} : l.any p \u2194 \u2203 x \u2208 l, p x", "start": [988, 1], "end": [988, 97], "kind": "commanddeclaration"}, {"full_name": "List.all_eq_not_any_not", "code": "theorem all_eq_not_any_not (l : List \u03b1) (p : \u03b1 \u2192 Bool) : l.all p = !l.any (fun c => !p c)", "start": [990, 1], "end": [991, 78], "kind": "commanddeclaration"}, {"full_name": "List.contains_nil", "code": "@[simp] theorem contains_nil [BEq \u03b1] : ([] : List \u03b1).contains a = false", "start": [993, 1], "end": [993, 79], "kind": "commanddeclaration"}, {"full_name": "List.contains_cons", "code": "@[simp] theorem contains_cons [BEq \u03b1] :\n    (a :: as : List \u03b1).contains x = (x == a || as.contains x)", "start": [995, 1], "end": [998, 21], "kind": "commanddeclaration"}, {"full_name": "List.contains_eq_any_beq", "code": "theorem contains_eq_any_beq [BEq \u03b1] (l : List \u03b1) (a : \u03b1) : l.contains a = l.any (a == \u00b7)", "start": [1000, 1], "end": [1001, 64], "kind": "commanddeclaration"}, {"full_name": "List.mem_reverseAux", "code": "@[simp] theorem mem_reverseAux {x : \u03b1} : \u2200 {as bs}, x \u2208 reverseAux as bs \u2194 x \u2208 as \u2228 x \u2208 bs", "start": [1005, 1], "end": [1007, 96], "kind": "commanddeclaration"}, {"full_name": "List.mem_reverse", "code": "@[simp] theorem mem_reverse {x : \u03b1} {as : List \u03b1} : x \u2208 reverse as \u2194 x \u2208 as", "start": [1009, 1], "end": [1009, 97], "kind": "commanddeclaration"}, {"full_name": "List.insert_of_mem", "code": "@[simp] theorem insert_of_mem {l : List \u03b1} (h : a \u2208 l) : l.insert a = l", "start": [1016, 1], "end": [1017, 36], "kind": "commanddeclaration"}, {"full_name": "List.insert_of_not_mem", "code": "@[simp] theorem insert_of_not_mem {l : List \u03b1} (h : a \u2209 l) : l.insert a = a :: l", "start": [1019, 1], "end": [1020, 36], "kind": "commanddeclaration"}, {"full_name": "List.mem_insert_iff", "code": "@[simp] theorem mem_insert_iff {l : List \u03b1} : a \u2208 l.insert b \u2194 a = b \u2228 a \u2208 l", "start": [1022, 1], "end": [1029, 42], "kind": "commanddeclaration"}, {"full_name": "List.mem_insert_self", "code": "@[simp 1100] theorem mem_insert_self (a : \u03b1) (l : List \u03b1) : a \u2208 l.insert a", "start": [1031, 1], "end": [1032, 32], "kind": "commanddeclaration"}, {"full_name": "List.mem_insert_of_mem", "code": "theorem mem_insert_of_mem {l : List \u03b1} (h : a \u2208 l) : a \u2208 l.insert b", "start": [1034, 1], "end": [1035, 30], "kind": "commanddeclaration"}, {"full_name": "List.eq_or_mem_of_mem_insert", "code": "theorem eq_or_mem_of_mem_insert {l : List \u03b1} (h : a \u2208 l.insert b) : a = b \u2228 a \u2208 l", "start": [1037, 1], "end": [1038, 21], "kind": "commanddeclaration"}, {"full_name": "List.length_insert_of_mem", "code": "@[simp] theorem length_insert_of_mem {l : List \u03b1} (h : a \u2208 l) :\n    length (l.insert a) = length l", "start": [1040, 1], "end": [1041, 62], "kind": "commanddeclaration"}, {"full_name": "List.length_insert_of_not_mem", "code": "@[simp] theorem length_insert_of_not_mem {l : List \u03b1} (h : a \u2209 l) :\n    length (l.insert a) = length l + 1", "start": [1043, 1], "end": [1044, 75], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_nil", "code": "@[simp] theorem eraseP_nil : [].eraseP p = []", "start": [1050, 1], "end": [1050, 53], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_cons", "code": "theorem eraseP_cons (a : \u03b1) (l : List \u03b1) :\n    (a :: l).eraseP p = bif p a then l else a :: l.eraseP p", "start": [1052, 1], "end": [1053, 67], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_cons_of_pos", "code": "@[simp] theorem eraseP_cons_of_pos {l : List \u03b1} (p) (h : p a) : (a :: l).eraseP p = l", "start": [1055, 1], "end": [1056, 24], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_cons_of_neg", "code": "@[simp] theorem eraseP_cons_of_neg {l : List \u03b1} (p) (h : \u00acp a) :\n    (a :: l).eraseP p = a :: l.eraseP p", "start": [1058, 1], "end": [1059, 68], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_of_forall_not", "code": "theorem eraseP_of_forall_not {l : List \u03b1} (h : \u2200 a, a \u2208 l \u2192 \u00acp a) : l.eraseP p = l", "start": [1061, 1], "end": [1064, 69], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_eraseP", "code": "theorem exists_of_eraseP : \u2200 {l : List \u03b1} {a} (al : a \u2208 l) (pa : p a),\n    \u2203 a l\u2081 l\u2082, (\u2200 b \u2208 l\u2081, \u00acp b) \u2227 p a \u2227 l = l\u2081 ++ a :: l\u2082 \u2227 l.eraseP p = l\u2081 ++ l\u2082", "start": [1066, 1], "end": [1077, 57], "kind": "commanddeclaration"}, {"full_name": "List.exists_or_eq_self_of_eraseP", "code": "theorem exists_or_eq_self_of_eraseP (p) (l : List \u03b1) :\n    l.eraseP p = l \u2228\n    \u2203 a l\u2081 l\u2082, (\u2200 b \u2208 l\u2081, \u00acp b) \u2227 p a \u2227 l = l\u2081 ++ a :: l\u2082 \u2227 l.eraseP p = l\u2081 ++ l\u2082", "start": [1079, 1], "end": [1086, 46], "kind": "commanddeclaration"}, {"full_name": "List.length_eraseP_of_mem", "code": "@[simp] theorem length_eraseP_of_mem (al : a \u2208 l) (pa : p a) :\n    length (l.eraseP p) = Nat.pred (length l)", "start": [1088, 1], "end": [1091, 41], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_append_left", "code": "theorem eraseP_append_left {a : \u03b1} (pa : p a) :\n    \u2200 {l\u2081 : List \u03b1} l\u2082, a \u2208 l\u2081 \u2192 (l\u2081++l\u2082).eraseP p = l\u2081.eraseP p ++ l\u2082", "start": [1093, 1], "end": [1098, 28], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_append_right", "code": "theorem eraseP_append_right :\n    \u2200 {l\u2081 : List \u03b1} l\u2082, (\u2200 b \u2208 l\u2081, \u00acp b) \u2192 eraseP p (l\u2081++l\u2082) = l\u2081 ++ l\u2082.eraseP p", "start": [1100, 1], "end": [1104, 82], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_sublist", "code": "theorem eraseP_sublist (l : List \u03b1) : l.eraseP p <+ l", "start": [1106, 1], "end": [1109, 56], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_subset", "code": "theorem eraseP_subset (l : List \u03b1) : l.eraseP p \u2286 l", "start": [1111, 1], "end": [1111, 81], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.eraseP", "code": "theorem Sublist.eraseP : l\u2081 <+ l\u2082 \u2192 l\u2081.eraseP p <+ l\u2082.eraseP p", "start": [1113, 1], "end": [1120, 33], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_eraseP", "code": "theorem mem_of_mem_eraseP {l : List \u03b1} : a \u2208 l.eraseP p \u2192 a \u2208 l", "start": [1122, 1], "end": [1122, 87], "kind": "commanddeclaration"}, {"full_name": "List.mem_eraseP_of_neg", "code": "@[simp] theorem mem_eraseP_of_neg {l : List \u03b1} (pa : \u00acp a) : a \u2208 l.eraseP p \u2194 a \u2208 l", "start": [1124, 1], "end": [1131, 33], "kind": "commanddeclaration"}, {"full_name": "List.eraseP_map", "code": "theorem eraseP_map (f : \u03b2 \u2192 \u03b1) : \u2200 (l : List \u03b2), (map f l).eraseP p = map f (l.eraseP (p \u2218 f))", "start": [1133, 1], "end": [1135, 85], "kind": "commanddeclaration"}, {"full_name": "List.extractP_eq_find?_eraseP", "code": "@[simp] theorem extractP_eq_find?_eraseP\n    (l : List \u03b1) : extractP p l = (find? p l, eraseP p l)", "start": [1137, 1], "end": [1145, 21], "kind": "commanddeclaration"}, {"full_name": "List.erase_nil", "code": "@[simp] theorem erase_nil (a : \u03b1) : [].erase a = []", "start": [1153, 1], "end": [1153, 59], "kind": "commanddeclaration"}, {"full_name": "List.erase_cons", "code": "theorem erase_cons (a b : \u03b1) (l : List \u03b1) :\n    (b :: l).erase a = if b = a then l else b :: l.erase a", "start": [1155, 1], "end": [1158, 62], "kind": "commanddeclaration"}, {"full_name": "List.erase_cons_head", "code": "@[simp] theorem erase_cons_head (a : \u03b1) (l : List \u03b1) : (a :: l).erase a = l", "start": [1160, 1], "end": [1161, 20], "kind": "commanddeclaration"}, {"full_name": "List.erase_cons_tail", "code": "@[simp] theorem erase_cons_tail {a b : \u03b1} (l : List \u03b1) (h : b \u2260 a) :\n    (b :: l).erase a = b :: l.erase a", "start": [1163, 1], "end": [1164, 77], "kind": "commanddeclaration"}, {"full_name": "List.erase_eq_eraseP", "code": "theorem erase_eq_eraseP (a : \u03b1) : \u2200 l : List \u03b1, l.erase a = l.eraseP (Eq a)", "start": [1166, 1], "end": [1169, 77], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.erase", "code": "theorem Sublist.erase (a : \u03b1) {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 <+ l\u2082) : l\u2081.erase a <+ l\u2082.erase a", "start": [1171, 1], "end": [1172, 49], "kind": "commanddeclaration"}, {"full_name": "List.erase_of_not_mem", "code": "theorem erase_of_not_mem {a : \u03b1} : \u2200 {l : List \u03b1}, a \u2209 l \u2192 l.erase a = l", "start": [1174, 1], "end": [1178, 64], "kind": "commanddeclaration"}, {"full_name": "List.exists_erase_eq", "code": "theorem exists_erase_eq {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) :\n    \u2203 l\u2081 l\u2082, a \u2209 l\u2081 \u2227 l = l\u2081 ++ a :: l\u2082 \u2227 l.erase a = l\u2081 ++ l\u2082", "start": [1180, 1], "end": [1183, 99], "kind": "commanddeclaration"}, {"full_name": "List.length_erase_of_mem", "code": "@[simp] theorem length_erase_of_mem {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) :\n    length (l.erase a) = Nat.pred (length l)", "start": [1185, 1], "end": [1187, 74], "kind": "commanddeclaration"}, {"full_name": "List.erase_append_left", "code": "theorem erase_append_left {l\u2081 : List \u03b1} (l\u2082) (h : a \u2208 l\u2081) :\n    (l\u2081 ++ l\u2082).erase a = l\u2081.erase a ++ l\u2082", "start": [1189, 1], "end": [1191, 86], "kind": "commanddeclaration"}, {"full_name": "List.erase_append_right", "code": "theorem erase_append_right {a : \u03b1} {l\u2081 : List \u03b1} (l\u2082 : List \u03b1) (h : a \u2209 l\u2081) :\n    (l\u2081 ++ l\u2082).erase a = (l\u2081 ++ l\u2082.erase a)", "start": [1193, 1], "end": [1196, 63], "kind": "commanddeclaration"}, {"full_name": "List.erase_sublist", "code": "theorem erase_sublist (a : \u03b1) (l : List \u03b1) : l.erase a <+ l", "start": [1198, 1], "end": [1199, 41], "kind": "commanddeclaration"}, {"full_name": "List.erase_subset", "code": "theorem erase_subset (a : \u03b1) (l : List \u03b1) : l.erase a \u2286 l", "start": [1201, 1], "end": [1201, 88], "kind": "commanddeclaration"}, {"full_name": "List.sublist.erase", "code": "theorem sublist.erase (a : \u03b1) {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 <+ l\u2082) : l\u2081.erase a <+ l\u2082.erase a", "start": [1203, 1], "end": [1204, 46], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_erase", "code": "theorem mem_of_mem_erase {a b : \u03b1} {l : List \u03b1} (h : a \u2208 l.erase b) : a \u2208 l", "start": [1206, 1], "end": [1206, 98], "kind": "commanddeclaration"}, {"full_name": "List.mem_erase_of_ne", "code": "@[simp] theorem mem_erase_of_ne {a b : \u03b1} {l : List \u03b1} (ab : a \u2260 b) : a \u2208 l.erase b \u2194 a \u2208 l", "start": [1208, 1], "end": [1209, 73], "kind": "commanddeclaration"}, {"full_name": "List.erase_comm", "code": "theorem erase_comm (a b : \u03b1) (l : List \u03b1) : (l.erase a).erase b = (l.erase b).erase a", "start": [1211, 1], "end": [1224, 49], "kind": "commanddeclaration"}, {"full_name": "List.filter_nil", "code": "@[simp] theorem filter_nil (p : \u03b1 \u2192 Bool) : filter p [] = []", "start": [1230, 1], "end": [1230, 68], "kind": "commanddeclaration"}, {"full_name": "List.filter_cons_of_pos", "code": "@[simp] theorem filter_cons_of_pos {p : \u03b1 \u2192 Bool} {a : \u03b1} (l) (pa : p a) :\n    filter p (a :: l) = a :: filter p l", "start": [1232, 1], "end": [1233, 62], "kind": "commanddeclaration"}, {"full_name": "List.filter_cons_of_neg", "code": "@[simp] theorem filter_cons_of_neg {p : \u03b1 \u2192 Bool} {a : \u03b1} (l) (pa : \u00ac p a) :\n    filter p (a :: l) = filter p l", "start": [1235, 1], "end": [1236, 77], "kind": "commanddeclaration"}, {"full_name": "List.filter_append", "code": "@[simp] theorem filter_append {p : \u03b1 \u2192 Bool} :\n    \u2200 (l\u2081 l\u2082 : List \u03b1), filter p (l\u2081 ++ l\u2082) = filter p l\u2081 ++ filter p l\u2082", "start": [1238, 1], "end": [1241, 71], "kind": "commanddeclaration"}, {"full_name": "List.filter_sublist", "code": "@[simp] theorem filter_sublist {p : \u03b1 \u2192 Bool} : \u2200 (l : List \u03b1), filter p l <+ l", "start": [1243, 1], "end": [1245, 93], "kind": "commanddeclaration"}, {"full_name": "List.mem_filter", "code": "theorem mem_filter : x \u2208 filter p as \u2194 x \u2208 as \u2227 p x", "start": [1247, 1], "end": [1253, 54], "kind": "commanddeclaration"}, {"full_name": "List.partition_eq_filter_filter", "code": "@[simp] theorem partition_eq_filter_filter (p : \u03b1 \u2192 Bool) (l : List \u03b1) :\n    partition p l = (filter p l, filter (not \u2218 p) l)", "start": [1255, 1], "end": [1260, 89], "kind": "commanddeclaration"}, {"full_name": "List.filter_congr'", "code": "theorem filter_congr' {p q : \u03b1 \u2192 Bool} :\n    \u2200 {l : List \u03b1}, (\u2200 x \u2208 l, p x \u2194 q x) \u2192 filter p l = filter q l", "start": [1262, 1], "end": [1268, 48], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_nil", "code": "@[simp] theorem filterMap_nil (f : \u03b1 \u2192 Option \u03b2) : filterMap f [] = []", "start": [1272, 1], "end": [1272, 78], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_cons", "code": "@[simp] theorem filterMap_cons (f : \u03b1 \u2192 Option \u03b2) (a : \u03b1) (l : List \u03b1) :\n    filterMap f (a :: l) =\n      match f a with\n      | none => filterMap f l\n      | some b => b :: filterMap f l", "start": [1274, 1], "end": [1278, 44], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_cons_none", "code": "theorem filterMap_cons_none {f : \u03b1 \u2192 Option \u03b2} (a : \u03b1) (l : List \u03b1) (h : f a = none) :\n    filterMap f (a :: l) = filterMap f l", "start": [1280, 1], "end": [1281, 72], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_cons_some", "code": "theorem filterMap_cons_some (f : \u03b1 \u2192 Option \u03b2) (a : \u03b1) (l : List \u03b1) {b : \u03b2} (h : f a = some b) :\n    filterMap f (a :: l) = b :: filterMap f l", "start": [1283, 1], "end": [1284, 77], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_append", "code": "theorem filterMap_append {\u03b1 \u03b2 : Type _} (l l' : List \u03b1) (f : \u03b1 \u2192 Option \u03b2) :\n    filterMap f (l ++ l') = filterMap f l ++ filterMap f l'", "start": [1286, 1], "end": [1288, 43], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_eq_map", "code": "theorem filterMap_eq_map (f : \u03b1 \u2192 \u03b2) : filterMap (some \u2218 f) = map f", "start": [1290, 1], "end": [1291, 37], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_eq_filter", "code": "theorem filterMap_eq_filter (p : \u03b1 \u2192 Bool) :\n    filterMap (Option.guard (p \u00b7)) = filter p", "start": [1293, 1], "end": [1298, 71], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_filterMap", "code": "theorem filterMap_filterMap (f : \u03b1 \u2192 Option \u03b2) (g : \u03b2 \u2192 Option \u03b3) (l : List \u03b1) :\n    filterMap g (filterMap f l) = filterMap (fun x => (f x).bind g) l", "start": [1300, 1], "end": [1304, 46], "kind": "commanddeclaration"}, {"full_name": "List.map_filterMap", "code": "theorem map_filterMap (f : \u03b1 \u2192 Option \u03b2) (g : \u03b2 \u2192 \u03b3) (l : List \u03b1) :\n    map g (filterMap f l) = filterMap (fun x => (f x).map g) l", "start": [1306, 1], "end": [1308, 74], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_map", "code": "theorem filterMap_map (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 Option \u03b3) (l : List \u03b1) :\n    filterMap g (map f l) = filterMap (g \u2218 f) l", "start": [1310, 1], "end": [1312, 52], "kind": "commanddeclaration"}, {"full_name": "List.filter_filterMap", "code": "theorem filter_filterMap (f : \u03b1 \u2192 Option \u03b2) (p : \u03b2 \u2192 Bool) (l : List \u03b1) :\n    filter p (filterMap f l) = filterMap (fun x => (f x).filter p) l", "start": [1314, 1], "end": [1317, 68], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_filter", "code": "theorem filterMap_filter (p : \u03b1 \u2192 Bool) (f : \u03b1 \u2192 Option \u03b2) (l : List \u03b1) :\n    filterMap f (filter p l) = filterMap (fun x => if p x then f x else none) l", "start": [1319, 1], "end": [1322, 63], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_some", "code": "@[simp] theorem filterMap_some (l : List \u03b1) : filterMap some l = l", "start": [1324, 1], "end": [1325, 33], "kind": "commanddeclaration"}, {"full_name": "List.map_filterMap_some_eq_filter_map_is_some", "code": "theorem map_filterMap_some_eq_filter_map_is_some (f : \u03b1 \u2192 Option \u03b2) (l : List \u03b1) :\n    (l.filterMap f).map some = (l.map f).filter fun b => b.isSome", "start": [1327, 1], "end": [1329, 43], "kind": "commanddeclaration"}, {"full_name": "List.mem_filterMap", "code": "@[simp] theorem mem_filterMap (f : \u03b1 \u2192 Option \u03b2) (l : List \u03b1) {b : \u03b2} :\n    b \u2208 filterMap f l \u2194 \u2203 a, a \u2208 l \u2227 f a = some b", "start": [1331, 1], "end": [1333, 52], "kind": "commanddeclaration"}, {"full_name": "List.filterMap_join", "code": "@[simp] theorem filterMap_join (f : \u03b1 \u2192 Option \u03b2) (L : List (List \u03b1)) :\n    filterMap f (join L) = join (map (filterMap f) L)", "start": [1335, 1], "end": [1337, 45], "kind": "commanddeclaration"}, {"full_name": "List.map_filterMap_of_inv", "code": "theorem map_filterMap_of_inv (f : \u03b1 \u2192 Option \u03b2) (g : \u03b2 \u2192 \u03b1) (H : \u2200 x : \u03b1, (f x).map g = some x)\n    (l : List \u03b1) : map g (filterMap f l) = l", "start": [1339, 1], "end": [1340, 96], "kind": "commanddeclaration"}, {"full_name": "List.length_filter_le", "code": "theorem length_filter_le (p : \u03b1 \u2192 Bool) (l : List \u03b1) :\n    (l.filter p).length \u2264 l.length", "start": [1342, 1], "end": [1343, 67], "kind": "commanddeclaration"}, {"full_name": "List.length_filterMap_le", "code": "theorem length_filterMap_le (f : \u03b1 \u2192 Option \u03b2) (l : List \u03b1) :\n    (filterMap f l).length \u2264 l.length", "start": [1345, 1], "end": [1348, 25], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.filterMap", "code": "theorem Sublist.filterMap (f : \u03b1 \u2192 Option \u03b2) (s : l\u2081 <+ l\u2082) : filterMap f l\u2081 <+ filterMap f l\u2082", "start": [1350, 1], "end": [1351, 59], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.filter", "code": "theorem Sublist.filter (p : \u03b1 \u2192 Bool) {l\u2081 l\u2082} (s : l\u2081 <+ l\u2082) : filter p l\u2081 <+ filter p l\u2082", "start": [1353, 1], "end": [1354, 48], "kind": "commanddeclaration"}, {"full_name": "List.map_filter", "code": "theorem map_filter (f : \u03b2 \u2192 \u03b1) (l : List \u03b2) : filter p (map f l) = map f (filter (p \u2218 f) l)", "start": [1356, 1], "end": [1357, 67], "kind": "commanddeclaration"}, {"full_name": "List.filter_filter", "code": "@[simp] theorem filter_filter (q) : \u2200 l, filter p (filter q l) = filter (fun a => p a \u2227 q a) l", "start": [1359, 1], "end": [1361, 94], "kind": "commanddeclaration"}, {"full_name": "List.filter_eq_nil", "code": "theorem filter_eq_nil {l} : filter p l = [] \u2194 \u2200 a \u2208 l, \u00acp a", "start": [1363, 1], "end": [1364, 61], "kind": "commanddeclaration"}, {"full_name": "List.filter_eq_self", "code": "theorem filter_eq_self {l} : filter p l = l \u2194 \u2200 a \u2208 l, p a", "start": [1366, 1], "end": [1370, 62], "kind": "commanddeclaration"}, {"full_name": "List.filter_length_eq_length", "code": "theorem filter_length_eq_length {l} : (filter p l).length = l.length \u2194 \u2200 a \u2208 l, p a", "start": [1372, 1], "end": [1373, 76], "kind": "commanddeclaration"}, {"full_name": "List.find?_cons_of_pos", "code": "theorem find?_cons_of_pos (l) (h : p a) : find? p (a :: l) = some a", "start": [1377, 1], "end": [1378, 21], "kind": "commanddeclaration"}, {"full_name": "List.find?_cons_of_neg", "code": "theorem find?_cons_of_neg (l) (h : \u00acp a) : find? p (a :: l) = find? p l", "start": [1380, 1], "end": [1381, 21], "kind": "commanddeclaration"}, {"full_name": "List.find?_eq_none", "code": "theorem find?_eq_none : find? p l = none \u2194 \u2200 x \u2208 l, \u00ac p x", "start": [1383, 1], "end": [1384, 56], "kind": "commanddeclaration"}, {"full_name": "List.find?_some", "code": "theorem find?_some : \u2200 {l}, find? p l = some a \u2192 p a", "start": [1386, 1], "end": [1390, 25], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_find?_eq_some", "code": "@[simp] theorem mem_of_find?_eq_some : \u2200 {l}, find? p l = some a \u2192 a \u2208 l", "start": [1392, 1], "end": [1396, 45], "kind": "commanddeclaration"}, {"full_name": "List.findIdx_nil", "code": "@[simp] theorem findIdx_nil {\u03b1 : Type _} (p : \u03b1 \u2192 Bool) : [].findIdx p = 0", "start": [1400, 1], "end": [1400, 82], "kind": "commanddeclaration"}, {"full_name": "List.findIdx_cons", "code": "theorem findIdx_cons (p : \u03b1 \u2192 Bool) (b : \u03b1) (l : List \u03b1) :\n    (b :: l).findIdx p = bif p b then 0 else (l.findIdx p) + 1", "start": [1402, 1], "end": [1415, 43], "kind": "commanddeclaration"}, {"full_name": "List.findIdx_of_get?_eq_some", "code": "theorem findIdx_of_get?_eq_some {xs : List \u03b1} (w : xs.get? (xs.findIdx p) = some y) : p y", "start": [1417, 1], "end": [1420, 65], "kind": "commanddeclaration"}, {"full_name": "List.findIdx_get", "code": "theorem findIdx_get {xs : List \u03b1} {w : xs.findIdx p < xs.length} :\n    p (xs.get \u27e8xs.findIdx p, w\u27e9)", "start": [1422, 1], "end": [1424, 45], "kind": "commanddeclaration"}, {"full_name": "List.findIdx_lt_length_of_exists", "code": "theorem findIdx_lt_length_of_exists {xs : List \u03b1} (h : \u2203 x \u2208 xs, p x) :\n    xs.findIdx p < xs.length", "start": [1426, 1], "end": [1438, 24], "kind": "commanddeclaration"}, {"full_name": "List.findIdx_get?_eq_get_of_exists", "code": "theorem findIdx_get?_eq_get_of_exists {xs : List \u03b1} (h : \u2203 x \u2208 xs, p x) :\n    xs.get? (xs.findIdx p) = some (xs.get \u27e8xs.findIdx p, xs.findIdx_lt_length_of_exists h\u27e9)", "start": [1440, 1], "end": [1442, 46], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.sublist", "code": "theorem Pairwise.sublist : l\u2081 <+ l\u2082 \u2192 l\u2082.Pairwise R \u2192 l\u2081.Pairwise R", "start": [1446, 1], "end": [1449, 80], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_map", "code": "theorem pairwise_map {l : List \u03b1} :\n    (l.map f).Pairwise R \u2194 l.Pairwise fun a b => R (f a) (f b)", "start": [1451, 1], "end": [1455, 58], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_append", "code": "theorem pairwise_append {l\u2081 l\u2082 : List \u03b1} :\n    (l\u2081 ++ l\u2082).Pairwise R \u2194 l\u2081.Pairwise R \u2227 l\u2082.Pairwise R \u2227 \u2200 a \u2208 l\u2081, \u2200 b \u2208 l\u2082, R a b", "start": [1457, 1], "end": [1459, 74], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_reverse", "code": "theorem pairwise_reverse {l : List \u03b1} :\n    l.reverse.Pairwise R \u2194 l.Pairwise (fun a b => R b a)", "start": [1461, 1], "end": [1463, 54], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.imp", "code": "theorem Pairwise.imp {\u03b1 R S} (H : \u2200 {a b}, R a b \u2192 S a b) :\n    \u2200 {l : List \u03b1}, l.Pairwise R \u2192 l.Pairwise S", "start": [1465, 1], "end": [1468, 50], "kind": "commanddeclaration"}, {"full_name": "List.replaceF_nil", "code": "theorem replaceF_nil : [].replaceF p = []", "start": [1472, 1], "end": [1472, 49], "kind": "commanddeclaration"}, {"full_name": "List.replaceF_cons", "code": "theorem replaceF_cons (a : \u03b1) (l : List \u03b1) :\n    (a :: l).replaceF p = match p a with\n      | none => a :: replaceF p l\n      | some a' => a' :: l", "start": [1474, 1], "end": [1477, 34], "kind": "commanddeclaration"}, {"full_name": "List.replaceF_cons_of_some", "code": "theorem replaceF_cons_of_some {l : List \u03b1} (p) (h : p a = some a') :\n    (a :: l).replaceF p = a' :: l", "start": [1479, 1], "end": [1481, 26], "kind": "commanddeclaration"}, {"full_name": "List.replaceF_cons_of_none", "code": "theorem replaceF_cons_of_none {l : List \u03b1} (p) (h : p a = none) :\n    (a :: l).replaceF p = a :: l.replaceF p", "start": [1483, 1], "end": [1484, 74], "kind": "commanddeclaration"}, {"full_name": "List.replaceF_of_forall_none", "code": "theorem replaceF_of_forall_none {l : List \u03b1} (h : \u2200 a, a \u2208 l \u2192 p a = none) : l.replaceF p = l", "start": [1486, 1], "end": [1489, 69], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_replaceF", "code": "theorem exists_of_replaceF : \u2200 {l : List \u03b1} {a a'} (al : a \u2208 l) (pa : p a = some a'),\n    \u2203 a a' l\u2081 l\u2082,\n      (\u2200 b \u2208 l\u2081, p b = none) \u2227 p a = some a' \u2227 l = l\u2081 ++ a :: l\u2082 \u2227 l.replaceF p = l\u2081 ++ a' :: l\u2082", "start": [1491, 1], "end": [1503, 57], "kind": "commanddeclaration"}, {"full_name": "List.exists_or_eq_self_of_replaceF", "code": "theorem exists_or_eq_self_of_replaceF (p) (l : List \u03b1) :\n    l.replaceF p = l \u2228 \u2203 a a' l\u2081 l\u2082,\n      (\u2200 b \u2208 l\u2081, p b = none) \u2227 p a = some a' \u2227 l = l\u2081 ++ a :: l\u2082 \u2227 l.replaceF p = l\u2081 ++ a' :: l\u2082", "start": [1505, 1], "end": [1513, 62], "kind": "commanddeclaration"}, {"full_name": "List.length_replaceF", "code": "@[simp] theorem length_replaceF : length (replaceF f l) = length l", "start": [1515, 1], "end": [1516, 54], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_symm", "code": "theorem disjoint_symm (d : Disjoint l\u2081 l\u2082) : Disjoint l\u2082 l\u2081", "start": [1520, 1], "end": [1520, 86], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_comm", "code": "theorem disjoint_comm : Disjoint l\u2081 l\u2082 \u2194 Disjoint l\u2082 l\u2081", "start": [1522, 1], "end": [1522, 90], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_left", "code": "theorem disjoint_left : Disjoint l\u2081 l\u2082 \u2194 \u2200 \u2983a\u2984, a \u2208 l\u2081 \u2192 a \u2209 l\u2082", "start": [1524, 1], "end": [1524, 86], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_right", "code": "theorem disjoint_right : Disjoint l\u2081 l\u2082 \u2194 \u2200 \u2983a\u2984, a \u2208 l\u2082 \u2192 a \u2209 l\u2081", "start": [1526, 1], "end": [1526, 82], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_iff_ne", "code": "theorem disjoint_iff_ne : Disjoint l\u2081 l\u2082 \u2194 \u2200 a \u2208 l\u2081, \u2200 b \u2208 l\u2082, a \u2260 b", "start": [1528, 1], "end": [1529, 83], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_of_subset_left", "code": "theorem disjoint_of_subset_left (ss : l\u2081 \u2286 l) (d : Disjoint l l\u2082) : Disjoint l\u2081 l\u2082", "start": [1531, 1], "end": [1532, 22], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_of_subset_right", "code": "theorem disjoint_of_subset_right (ss : l\u2082 \u2286 l) (d : Disjoint l\u2081 l) : Disjoint l\u2081 l\u2082", "start": [1534, 1], "end": [1535, 28], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_of_disjoint_cons_left", "code": "theorem disjoint_of_disjoint_cons_left {l\u2081 l\u2082} : Disjoint (a :: l\u2081) l\u2082 \u2192 Disjoint l\u2081 l\u2082", "start": [1537, 1], "end": [1538, 42], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_of_disjoint_cons_right", "code": "theorem disjoint_of_disjoint_cons_right {l\u2081 l\u2082} : Disjoint l\u2081 (a :: l\u2082) \u2192 Disjoint l\u2081 l\u2082", "start": [1540, 1], "end": [1541, 43], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_nil_left", "code": "@[simp] theorem disjoint_nil_left (l : List \u03b1) : Disjoint [] l", "start": [1543, 1], "end": [1543, 96], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_nil_right", "code": "@[simp] theorem disjoint_nil_right (l : List \u03b1) : Disjoint l []", "start": [1545, 1], "end": [1546, 48], "kind": "commanddeclaration"}, {"full_name": "List.singleton_disjoint", "code": "@[simp 1100] theorem singleton_disjoint : Disjoint [a] l \u2194 a \u2209 l", "start": [1548, 1], "end": [1548, 87], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_singleton", "code": "@[simp 1100] theorem disjoint_singleton : Disjoint l [a] \u2194 a \u2209 l", "start": [1550, 1], "end": [1551, 41], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_append_left", "code": "@[simp] theorem disjoint_append_left : Disjoint (l\u2081 ++ l\u2082) l \u2194 Disjoint l\u2081 l \u2227 Disjoint l\u2082 l", "start": [1553, 1], "end": [1554, 38], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_append_right", "code": "@[simp] theorem disjoint_append_right : Disjoint l (l\u2081 ++ l\u2082) \u2194 Disjoint l l\u2081 \u2227 Disjoint l l\u2082", "start": [1556, 1], "end": [1557, 76], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_cons_left", "code": "@[simp] theorem disjoint_cons_left : Disjoint (a::l\u2081) l\u2082 \u2194 (a \u2209 l\u2082) \u2227 Disjoint l\u2081 l\u2082", "start": [1559, 1], "end": [1560, 75], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_cons_right", "code": "@[simp] theorem disjoint_cons_right : Disjoint l\u2081 (a :: l\u2082) \u2194 (a \u2209 l\u2081) \u2227 Disjoint l\u2081 l\u2082", "start": [1562, 1], "end": [1563, 74], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_of_disjoint_append_left_left", "code": "theorem disjoint_of_disjoint_append_left_left (d : Disjoint (l\u2081 ++ l\u2082) l) : Disjoint l\u2081 l", "start": [1565, 1], "end": [1566, 31], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_of_disjoint_append_left_right", "code": "theorem disjoint_of_disjoint_append_left_right (d : Disjoint (l\u2081 ++ l\u2082) l) : Disjoint l\u2082 l", "start": [1568, 1], "end": [1569, 31], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_of_disjoint_append_right_left", "code": "theorem disjoint_of_disjoint_append_right_left (d : Disjoint l (l\u2081 ++ l\u2082)) : Disjoint l l\u2081", "start": [1571, 1], "end": [1572, 32], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_of_disjoint_append_right_right", "code": "theorem disjoint_of_disjoint_append_right_right (d : Disjoint l (l\u2081 ++ l\u2082)) : Disjoint l l\u2082", "start": [1574, 1], "end": [1575, 32], "kind": "commanddeclaration"}, {"full_name": "List.foldl_map", "code": "theorem foldl_map (f : \u03b2\u2081 \u2192 \u03b2\u2082) (g : \u03b1 \u2192 \u03b2\u2082 \u2192 \u03b1) (l : List \u03b2\u2081) (init : \u03b1) :\n    (l.map f).foldl g init = l.foldl (fun x y => g x (f y)) init", "start": [1579, 1], "end": [1581, 45], "kind": "commanddeclaration"}, {"full_name": "List.foldr_map", "code": "theorem foldr_map (f : \u03b1\u2081 \u2192 \u03b1\u2082) (g : \u03b1\u2082 \u2192 \u03b2 \u2192 \u03b2) (l : List \u03b1\u2081) (init : \u03b2) :\n    (l.map f).foldr g init = l.foldr (fun x y => g (f x) y) init", "start": [1583, 1], "end": [1585, 45], "kind": "commanddeclaration"}, {"full_name": "List.foldl_hom", "code": "theorem foldl_hom (f : \u03b1\u2081 \u2192 \u03b1\u2082) (g\u2081 : \u03b1\u2081 \u2192 \u03b2 \u2192 \u03b1\u2081) (g\u2082 : \u03b1\u2082 \u2192 \u03b2 \u2192 \u03b1\u2082) (l : List \u03b2) (init : \u03b1\u2081)\n    (H : \u2200 x y, g\u2082 (f x) y = f (g\u2081 x y)) : l.foldl g\u2082 (f init) = f (l.foldl g\u2081 init)", "start": [1587, 1], "end": [1589, 48], "kind": "commanddeclaration"}, {"full_name": "List.foldr_hom", "code": "theorem foldr_hom (f : \u03b2\u2081 \u2192 \u03b2\u2082) (g\u2081 : \u03b1 \u2192 \u03b2\u2081 \u2192 \u03b2\u2081) (g\u2082 : \u03b1 \u2192 \u03b2\u2082 \u2192 \u03b2\u2082) (l : List \u03b1) (init : \u03b2\u2081)\n    (H : \u2200 x y, g\u2082 x (f y) = f (g\u2081 x y)) : l.foldr g\u2082 (f init) = f (l.foldr g\u2081 init)", "start": [1591, 1], "end": [1593, 30], "kind": "commanddeclaration"}, {"full_name": "List.union_def", "code": "theorem union_def [DecidableEq \u03b1] (l\u2081 l\u2082 : List \u03b1)  : l\u2081 \u222a l\u2082 = foldr .insert l\u2082 l\u2081", "start": [1601, 1], "end": [1601, 91], "kind": "commanddeclaration"}, {"full_name": "List.nil_union", "code": "@[simp] theorem nil_union (l : List \u03b1) : nil \u222a l = l", "start": [1603, 1], "end": [1603, 88], "kind": "commanddeclaration"}, {"full_name": "List.cons_union", "code": "@[simp] theorem cons_union (a : \u03b1) (l\u2081 l\u2082 : List \u03b1) :\n    (a :: l\u2081) \u222a l\u2082 = (l\u2081 \u222a l\u2082).insert a", "start": [1605, 1], "end": [1606, 75], "kind": "commanddeclaration"}, {"full_name": "List.mem_union_iff", "code": "@[simp] theorem mem_union_iff [DecidableEq \u03b1] {x : \u03b1} {l\u2081 l\u2082 : List \u03b1} :\n    x \u2208 l\u2081 \u222a l\u2082 \u2194 x \u2208 l\u2081 \u2228 x \u2208 l\u2082", "start": [1608, 1], "end": [1609, 76], "kind": "commanddeclaration"}, {"full_name": "List.inter_def", "code": "theorem inter_def [DecidableEq \u03b1] (l\u2081 l\u2082 : List \u03b1)  : l\u2081 \u2229 l\u2082 = filter (\u00b7 \u2208 l\u2082) l\u2081", "start": [1615, 1], "end": [1615, 90], "kind": "commanddeclaration"}, {"full_name": "List.mem_inter_iff", "code": "@[simp] theorem mem_inter_iff [DecidableEq \u03b1] {x : \u03b1} {l\u2081 l\u2082 : List \u03b1} :\n    x \u2208 l\u2081 \u2229 l\u2082 \u2194 x \u2208 l\u2081 \u2227 x \u2208 l\u2082", "start": [1617, 1], "end": [1619, 49], "kind": "commanddeclaration"}, {"full_name": "List.pair_mem_product", "code": "theorem pair_mem_product {xs : List \u03b1} {ys : List \u03b2} {x : \u03b1} {y : \u03b2} :\n    (x, y) \u2208 product xs ys \u2194 x \u2208 xs \u2227 y \u2208 ys", "start": [1623, 1], "end": [1627, 47], "kind": "commanddeclaration"}, {"full_name": "List.leftpad_length", "code": "theorem leftpad_length (n : Nat) (a : \u03b1) (l : List \u03b1) :\n    (leftpad n a l).length = max n l.length", "start": [1631, 1], "end": [1635, 75], "kind": "commanddeclaration"}, {"full_name": "List.leftpad_prefix", "code": "theorem leftpad_prefix (n : Nat) (a : \u03b1) (l : List \u03b1) :\n    IsPrefix (replicate (n - length l) a) (leftpad n a l)", "start": [1637, 1], "end": [1640, 27], "kind": "commanddeclaration"}, {"full_name": "List.leftpad_suffix", "code": "theorem leftpad_suffix (n : Nat) (a : \u03b1) (l : List \u03b1) : IsSuffix l (leftpad n a l)", "start": [1642, 1], "end": [1644, 54], "kind": "commanddeclaration"}, {"full_name": "List.forIn_eq_forIn", "code": "@[simp] theorem forIn_eq_forIn [Monad m] : @List.forIn \u03b1 \u03b2 m _ = forIn", "start": [1649, 1], "end": [1649, 78], "kind": "commanddeclaration"}, {"full_name": "List.forIn_eq_bindList", "code": "theorem forIn_eq_bindList [Monad m] [LawfulMonad m]\n    (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (l : List \u03b1) (init : \u03b2) :\n    forIn l init f = ForInStep.run <$> (ForInStep.yield init).bindList f l", "start": [1651, 1], "end": [1655, 30], "kind": "commanddeclaration"}, {"full_name": "List.forM_append", "code": "@[simp] theorem forM_append [Monad m] [LawfulMonad m] (l\u2081 l\u2082 : List \u03b1) (f : \u03b1 \u2192 m PUnit) :\n    (l\u2081 ++ l\u2082).forM f = (do l\u2081.forM f; l\u2082.forM f)", "start": [1657, 1], "end": [1658, 82], "kind": "commanddeclaration"}, {"full_name": "List.diff_nil", "code": "@[simp] theorem diff_nil (l : List \u03b1) : l.diff [] = l", "start": [1666, 1], "end": [1666, 61], "kind": "commanddeclaration"}, {"full_name": "List.diff_cons", "code": "@[simp] theorem diff_cons (l\u2081 l\u2082 : List \u03b1) (a : \u03b1) : l\u2081.diff (a :: l\u2082) = (l\u2081.erase a).diff l\u2082", "start": [1668, 1], "end": [1669, 57], "kind": "commanddeclaration"}, {"full_name": "List.diff_cons_right", "code": "theorem diff_cons_right (l\u2081 l\u2082 : List \u03b1) (a : \u03b1) : l\u2081.diff (a :: l\u2082) = (l\u2081.diff l\u2082).erase a", "start": [1671, 1], "end": [1672, 71], "kind": "commanddeclaration"}, {"full_name": "List.diff_erase", "code": "theorem diff_erase (l\u2081 l\u2082 : List \u03b1) (a : \u03b1) : (l\u2081.diff l\u2082).erase a = (l\u2081.erase a).diff l\u2082", "start": [1674, 1], "end": [1675, 36], "kind": "commanddeclaration"}, {"full_name": "List.nil_diff", "code": "@[simp] theorem nil_diff (l : List \u03b1) : [].diff l = []", "start": [1677, 1], "end": [1678, 45], "kind": "commanddeclaration"}, {"full_name": "List.cons_diff", "code": "theorem cons_diff (a : \u03b1) (l\u2081 l\u2082 : List \u03b1) :\n    (a :: l\u2081).diff l\u2082 = if a \u2208 l\u2082 then l\u2081.diff (l\u2082.erase a) else a :: l\u2081.diff l\u2082", "start": [1680, 1], "end": [1684, 61], "kind": "commanddeclaration"}, {"full_name": "List.cons_diff_of_mem", "code": "theorem cons_diff_of_mem {a : \u03b1} {l\u2082 : List \u03b1} (h : a \u2208 l\u2082) (l\u2081 : List \u03b1) :\n    (a :: l\u2081).diff l\u2082 = l\u2081.diff (l\u2082.erase a)", "start": [1686, 1], "end": [1687, 76], "kind": "commanddeclaration"}, {"full_name": "List.cons_diff_of_not_mem", "code": "theorem cons_diff_of_not_mem {a : \u03b1} {l\u2082 : List \u03b1} (h : a \u2209 l\u2082) (l\u2081 : List \u03b1) :\n    (a :: l\u2081).diff l\u2082 = a :: l\u2081.diff l\u2082", "start": [1689, 1], "end": [1690, 71], "kind": "commanddeclaration"}, {"full_name": "List.diff_eq_foldl", "code": "theorem diff_eq_foldl : \u2200 l\u2081 l\u2082 : List \u03b1, l\u2081.diff l\u2082 = foldl List.erase l\u2081 l\u2082", "start": [1692, 1], "end": [1694, 65], "kind": "commanddeclaration"}, {"full_name": "List.diff_append", "code": "@[simp] theorem diff_append (l\u2081 l\u2082 l\u2083 : List \u03b1) : l\u2081.diff (l\u2082 ++ l\u2083) = (l\u2081.diff l\u2082).diff l\u2083", "start": [1696, 1], "end": [1697, 42], "kind": "commanddeclaration"}, {"full_name": "List.diff_sublist", "code": "theorem diff_sublist : \u2200 l\u2081 l\u2082 : List \u03b1, l\u2081.diff l\u2082 <+ l\u2081", "start": [1699, 1], "end": [1705, 34], "kind": "commanddeclaration"}, {"full_name": "List.diff_subset", "code": "theorem diff_subset (l\u2081 l\u2082 : List \u03b1) : l\u2081.diff l\u2082 \u2286 l\u2081", "start": [1707, 1], "end": [1707, 83], "kind": "commanddeclaration"}, {"full_name": "List.mem_diff_of_mem", "code": "theorem mem_diff_of_mem {a : \u03b1} : \u2200 {l\u2081 l\u2082 : List \u03b1}, a \u2208 l\u2081 \u2192 a \u2209 l\u2082 \u2192 a \u2208 l\u2081.diff l\u2082", "start": [1709, 1], "end": [1713, 94], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.diff_right", "code": "theorem Sublist.diff_right : \u2200 {l\u2081 l\u2082 l\u2083 : List \u03b1}, l\u2081 <+ l\u2082 \u2192 l\u2081.diff l\u2083 <+ l\u2082.diff l\u2083", "start": [1715, 1], "end": [1717, 75], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.erase_diff_erase_sublist", "code": "theorem Sublist.erase_diff_erase_sublist {a : \u03b1} :\n    \u2200 {l\u2081 l\u2082 : List \u03b1}, l\u2081 <+ l\u2082 \u2192 (l\u2082.erase a).diff (l\u2081.erase a) <+ l\u2082.diff l\u2081", "start": [1719, 1], "end": [1727, 71], "kind": "commanddeclaration"}, {"full_name": "List.prefix_append", "code": "@[simp] theorem prefix_append (l\u2081 l\u2082 : List \u03b1) : l\u2081 <+: l\u2081 ++ l\u2082", "start": [1733, 1], "end": [1733, 78], "kind": "commanddeclaration"}, {"full_name": "List.suffix_append", "code": "@[simp] theorem suffix_append (l\u2081 l\u2082 : List \u03b1) : l\u2082 <:+ l\u2081 ++ l\u2082", "start": [1735, 1], "end": [1735, 78], "kind": "commanddeclaration"}, {"full_name": "List.infix_append", "code": "theorem infix_append (l\u2081 l\u2082 l\u2083 : List \u03b1) : l\u2082 <:+: l\u2081 ++ l\u2082 ++ l\u2083", "start": [1737, 1], "end": [1737, 83], "kind": "commanddeclaration"}, {"full_name": "List.infix_append'", "code": "@[simp] theorem infix_append' (l\u2081 l\u2082 l\u2083 : List \u03b1) : l\u2082 <:+: l\u2081 ++ (l\u2082 ++ l\u2083)", "start": [1739, 1], "end": [1740, 47], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.isInfix", "code": "theorem IsPrefix.isInfix : l\u2081 <+: l\u2082 \u2192 l\u2081 <:+: l\u2082", "start": [1742, 1], "end": [1742, 78], "kind": "commanddeclaration"}, {"full_name": "List.IsSuffix.isInfix", "code": "theorem IsSuffix.isInfix : l\u2081 <:+ l\u2082 \u2192 l\u2081 <:+: l\u2082", "start": [1744, 1], "end": [1744, 98], "kind": "commanddeclaration"}, {"full_name": "List.nil_prefix", "code": "theorem nil_prefix (l : List \u03b1) : [] <+: l", "start": [1746, 1], "end": [1746, 55], "kind": "commanddeclaration"}, {"full_name": "List.nil_suffix", "code": "theorem nil_suffix (l : List \u03b1) : [] <:+ l", "start": [1748, 1], "end": [1748, 64], "kind": "commanddeclaration"}, {"full_name": "List.nil_infix", "code": "theorem nil_infix (l : List \u03b1) : [] <:+: l", "start": [1750, 1], "end": [1750, 69], "kind": "commanddeclaration"}, {"full_name": "List.prefix_refl", "code": "theorem prefix_refl (l : List \u03b1) : l <+: l", "start": [1752, 1], "end": [1752, 65], "kind": "commanddeclaration"}, {"full_name": "List.suffix_refl", "code": "theorem suffix_refl (l : List \u03b1) : l <:+ l", "start": [1754, 1], "end": [1754, 56], "kind": "commanddeclaration"}, {"full_name": "List.infix_refl", "code": "theorem infix_refl (l : List \u03b1) : l <:+: l", "start": [1756, 1], "end": [1756, 70], "kind": "commanddeclaration"}, {"full_name": "List.suffix_cons", "code": "@[simp] theorem suffix_cons (a : \u03b1) : \u2200 l, l <:+ a :: l", "start": [1758, 1], "end": [1758, 77], "kind": "commanddeclaration"}, {"full_name": "List.infix_cons", "code": "theorem infix_cons : l\u2081 <:+: l\u2082 \u2192 l\u2081 <:+: a :: l\u2082", "start": [1760, 1], "end": [1760, 95], "kind": "commanddeclaration"}, {"full_name": "List.infix_concat", "code": "theorem infix_concat : l\u2081 <:+: l\u2082 \u2192 l\u2081 <:+: concat l\u2082 a", "start": [1762, 1], "end": [1763, 67], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.trans", "code": "theorem IsPrefix.trans : \u2200 {l\u2081 l\u2082 l\u2083 : List \u03b1}, l\u2081 <+: l\u2082 \u2192 l\u2082 <+: l\u2083 \u2192 l\u2081 <+: l\u2083", "start": [1765, 1], "end": [1766, 75], "kind": "commanddeclaration"}, {"full_name": "List.IsSuffix.trans", "code": "theorem IsSuffix.trans : \u2200 {l\u2081 l\u2082 l\u2083 : List \u03b1}, l\u2081 <:+ l\u2082 \u2192 l\u2082 <:+ l\u2083 \u2192 l\u2081 <:+ l\u2083", "start": [1768, 1], "end": [1769, 68], "kind": "commanddeclaration"}, {"full_name": "List.IsInfix.trans", "code": "theorem IsInfix.trans : \u2200 {l\u2081 l\u2082 l\u2083 : List \u03b1}, l\u2081 <:+: l\u2082 \u2192 l\u2082 <:+: l\u2083 \u2192 l\u2081 <:+: l\u2083", "start": [1771, 1], "end": [1772, 95], "kind": "commanddeclaration"}, {"full_name": "List.IsInfix.sublist", "code": "protected theorem IsInfix.sublist : l\u2081 <:+: l\u2082 \u2192 l\u2081 <+ l\u2082", "start": [1774, 1], "end": [1775, 78], "kind": "commanddeclaration"}, {"full_name": "List.IsInfix.subset", "code": "protected theorem IsInfix.subset (hl : l\u2081 <:+: l\u2082) : l\u2081 \u2286 l\u2082", "start": [1777, 1], "end": [1778, 20], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.sublist", "code": "protected theorem IsPrefix.sublist (h : l\u2081 <+: l\u2082) : l\u2081 <+ l\u2082", "start": [1780, 1], "end": [1781, 20], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.subset", "code": "protected theorem IsPrefix.subset (hl : l\u2081 <+: l\u2082) : l\u2081 \u2286 l\u2082", "start": [1783, 1], "end": [1784, 20], "kind": "commanddeclaration"}, {"full_name": "List.IsSuffix.sublist", "code": "protected theorem IsSuffix.sublist (h : l\u2081 <:+ l\u2082) : l\u2081 <+ l\u2082", "start": [1786, 1], "end": [1787, 20], "kind": "commanddeclaration"}, {"full_name": "List.IsSuffix.subset", "code": "protected theorem IsSuffix.subset (hl : l\u2081 <:+ l\u2082) : l\u2081 \u2286 l\u2082", "start": [1789, 1], "end": [1790, 20], "kind": "commanddeclaration"}, {"full_name": "List.reverse_suffix", "code": "@[simp] theorem reverse_suffix : reverse l\u2081 <:+ reverse l\u2082 \u2194 l\u2081 <+: l\u2082", "start": [1792, 1], "end": [1794, 59], "kind": "commanddeclaration"}, {"full_name": "List.reverse_prefix", "code": "@[simp] theorem reverse_prefix : reverse l\u2081 <+: reverse l\u2082 \u2194 l\u2081 <:+ l\u2082", "start": [1796, 1], "end": [1797, 53], "kind": "commanddeclaration"}, {"full_name": "List.reverse_infix", "code": "@[simp] theorem reverse_infix : reverse l\u2081 <:+: reverse l\u2082 \u2194 l\u2081 <:+: l\u2082", "start": [1799, 1], "end": [1803, 61], "kind": "commanddeclaration"}, {"full_name": "List.IsInfix.length_le", "code": "theorem IsInfix.length_le (h : l\u2081 <:+: l\u2082) : l\u2081.length \u2264 l\u2082.length", "start": [1805, 1], "end": [1806, 22], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.length_le", "code": "theorem IsPrefix.length_le (h : l\u2081 <+: l\u2082) : l\u2081.length \u2264 l\u2082.length", "start": [1808, 1], "end": [1809, 22], "kind": "commanddeclaration"}, {"full_name": "List.IsSuffix.length_le", "code": "theorem IsSuffix.length_le (h : l\u2081 <:+ l\u2082) : l\u2081.length \u2264 l\u2082.length", "start": [1811, 1], "end": [1812, 22], "kind": "commanddeclaration"}, {"full_name": "List.infix_nil", "code": "@[simp] theorem infix_nil : l <:+: [] \u2194 l = []", "start": [1814, 1], "end": [1814, 98], "kind": "commanddeclaration"}, {"full_name": "List.prefix_nil", "code": "@[simp] theorem prefix_nil : l <+: [] \u2194 l = []", "start": [1816, 1], "end": [1816, 99], "kind": "commanddeclaration"}, {"full_name": "List.suffix_nil", "code": "@[simp] theorem suffix_nil : l <:+ [] \u2194 l = []", "start": [1818, 1], "end": [1818, 99], "kind": "commanddeclaration"}, {"full_name": "List.infix_iff_prefix_suffix", "code": "theorem infix_iff_prefix_suffix (l\u2081 l\u2082 : List \u03b1) : l\u2081 <:+: l\u2082 \u2194 \u2203 t, l\u2081 <+: t \u2227 t <:+ l\u2082", "start": [1820, 1], "end": [1822, 60], "kind": "commanddeclaration"}, {"full_name": "List.IsInfix.eq_of_length", "code": "theorem IsInfix.eq_of_length (h : l\u2081 <:+: l\u2082) : l\u2081.length = l\u2082.length \u2192 l\u2081 = l\u2082", "start": [1824, 1], "end": [1825, 25], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.eq_of_length", "code": "theorem IsPrefix.eq_of_length (h : l\u2081 <+: l\u2082) : l\u2081.length = l\u2082.length \u2192 l\u2081 = l\u2082", "start": [1827, 1], "end": [1828, 25], "kind": "commanddeclaration"}, {"full_name": "List.IsSuffix.eq_of_length", "code": "theorem IsSuffix.eq_of_length (h : l\u2081 <:+ l\u2082) : l\u2081.length = l\u2082.length \u2192 l\u2081 = l\u2082", "start": [1830, 1], "end": [1831, 25], "kind": "commanddeclaration"}, {"full_name": "List.prefix_of_prefix_length_le", "code": "theorem prefix_of_prefix_length_le :\n    \u2200 {l\u2081 l\u2082 l\u2083 : List \u03b1}, l\u2081 <+: l\u2083 \u2192 l\u2082 <+: l\u2083 \u2192 length l\u2081 \u2264 length l\u2082 \u2192 l\u2081 <+: l\u2082", "start": [1833, 1], "end": [1839, 20], "kind": "commanddeclaration"}, {"full_name": "List.prefix_or_prefix_of_prefix", "code": "theorem prefix_or_prefix_of_prefix (h\u2081 : l\u2081 <+: l\u2083) (h\u2082 : l\u2082 <+: l\u2083) : l\u2081 <+: l\u2082 \u2228 l\u2082 <+: l\u2081", "start": [1841, 1], "end": [1843, 39], "kind": "commanddeclaration"}, {"full_name": "List.suffix_of_suffix_length_le", "code": "theorem suffix_of_suffix_length_le\n    (h\u2081 : l\u2081 <:+ l\u2083) (h\u2082 : l\u2082 <:+ l\u2083) (ll : length l\u2081 \u2264 length l\u2082) : l\u2081 <:+ l\u2082", "start": [1845, 1], "end": [1848, 90], "kind": "commanddeclaration"}, {"full_name": "List.suffix_or_suffix_of_suffix", "code": "theorem suffix_or_suffix_of_suffix (h\u2081 : l\u2081 <:+ l\u2083) (h\u2082 : l\u2082 <:+ l\u2083) : l\u2081 <:+ l\u2082 \u2228 l\u2082 <:+ l\u2081", "start": [1850, 1], "end": [1852, 21], "kind": "commanddeclaration"}, {"full_name": "List.suffix_cons_iff", "code": "theorem suffix_cons_iff : l\u2081 <:+ a :: l\u2082 \u2194 l\u2081 = a :: l\u2082 \u2228 l\u2081 <:+ l\u2082", "start": [1854, 1], "end": [1863, 41], "kind": "commanddeclaration"}, {"full_name": "List.infix_cons_iff", "code": "theorem infix_cons_iff : l\u2081 <:+: a :: l\u2082 \u2194 l\u2081 <+: a :: l\u2082 \u2228 l\u2081 <:+: l\u2082", "start": [1865, 1], "end": [1874, 27], "kind": "commanddeclaration"}, {"full_name": "List.infix_of_mem_join", "code": "theorem infix_of_mem_join : \u2200 {L : List (List \u03b1)}, l \u2208 L \u2192 l <:+: join L", "start": [1876, 1], "end": [1881, 78], "kind": "commanddeclaration"}, {"full_name": "List.prefix_append_right_inj", "code": "theorem prefix_append_right_inj (l) : l ++ l\u2081 <+: l ++ l\u2082 \u2194 l\u2081 <+: l\u2082", "start": [1883, 1], "end": [1884, 63], "kind": "commanddeclaration"}, {"full_name": "List.prefix_cons_inj", "code": "theorem prefix_cons_inj (a) : a :: l\u2081 <+: a :: l\u2082 \u2194 l\u2081 <+: l\u2082", "start": [1886, 1], "end": [1887, 30], "kind": "commanddeclaration"}, {"full_name": "List.take_prefix", "code": "theorem take_prefix (n) (l : List \u03b1) : take n l <+: l", "start": [1889, 1], "end": [1890, 28], "kind": "commanddeclaration"}, {"full_name": "List.drop_suffix", "code": "theorem drop_suffix (n) (l : List \u03b1) : drop n l <:+ l", "start": [1892, 1], "end": [1893, 28], "kind": "commanddeclaration"}, {"full_name": "List.take_sublist", "code": "theorem take_sublist (n) (l : List \u03b1) : take n l <+ l", "start": [1895, 1], "end": [1896, 28], "kind": "commanddeclaration"}, {"full_name": "List.drop_sublist", "code": "theorem drop_sublist (n) (l : List \u03b1) : drop n l <+ l", "start": [1898, 1], "end": [1899, 28], "kind": "commanddeclaration"}, {"full_name": "List.take_subset", "code": "theorem take_subset (n) (l : List \u03b1) : take n l \u2286 l", "start": [1901, 1], "end": [1902, 28], "kind": "commanddeclaration"}, {"full_name": "List.drop_subset", "code": "theorem drop_subset (n) (l : List \u03b1) : drop n l \u2286 l", "start": [1904, 1], "end": [1905, 28], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_take", "code": "theorem mem_of_mem_take {l : List \u03b1} (h : a \u2208 l.take n) : a \u2208 l", "start": [1907, 1], "end": [1908, 20], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.filter", "code": "theorem IsPrefix.filter (p : \u03b1 \u2192 Bool) \u2983l\u2081 l\u2082 : List \u03b1\u2984 (h : l\u2081 <+: l\u2082) :\n    l\u2081.filter p <+: l\u2082.filter p", "start": [1910, 1], "end": [1913, 42], "kind": "commanddeclaration"}, {"full_name": "List.IsSuffix.filter", "code": "theorem IsSuffix.filter (p : \u03b1 \u2192 Bool) \u2983l\u2081 l\u2082 : List \u03b1\u2984 (h : l\u2081 <:+ l\u2082) :\n    l\u2081.filter p <:+ l\u2082.filter p", "start": [1915, 1], "end": [1918, 42], "kind": "commanddeclaration"}, {"full_name": "List.IsInfix.filter", "code": "theorem IsInfix.filter (p : \u03b1 \u2192 Bool) \u2983l\u2081 l\u2082 : List \u03b1\u2984 (h : l\u2081 <:+: l\u2082) :\n    l\u2081.filter p <:+: l\u2082.filter p", "start": [1920, 1], "end": [1923, 58], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_drop", "code": "theorem mem_of_mem_drop {n} {l : List \u03b1} (h : a \u2208 l.drop n) : a \u2208 l", "start": [1925, 1], "end": [1925, 89], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_take_drop", "code": "theorem disjoint_take_drop : \u2200 {l : List \u03b1}, l.Nodup \u2192 m \u2264 n \u2192 Disjoint (l.take m) (l.drop n)", "start": [1927, 1], "end": [1935, 61], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_append_dropWhile", "code": "@[simp] theorem takeWhile_append_dropWhile (p : \u03b1 \u2192 Bool) :\n    \u2200 (l : List \u03b1), takeWhile p l ++ dropWhile p l = l", "start": [1939, 1], "end": [1942, 100], "kind": "commanddeclaration"}, {"full_name": "List.chain_cons", "code": "@[simp]\ntheorem chain_cons {a b : \u03b1} {l : List \u03b1} : Chain R a (b :: l) \u2194 R a b \u2227 Chain R b l", "start": [1949, 1], "end": [1952, 27], "kind": "commanddeclaration"}, {"full_name": "List.rel_of_chain_cons", "code": "theorem rel_of_chain_cons {a b : \u03b1} {l : List \u03b1} (p : Chain R a (b :: l)) : R a b", "start": [1954, 1], "end": [1955, 21], "kind": "commanddeclaration"}, {"full_name": "List.chain_of_chain_cons", "code": "theorem chain_of_chain_cons {a b : \u03b1} {l : List \u03b1} (p : Chain R a (b :: l)) : Chain R b l", "start": [1957, 1], "end": [1958, 21], "kind": "commanddeclaration"}, {"full_name": "List.Chain.imp'", "code": "theorem Chain.imp' {R S : \u03b1 \u2192 \u03b1 \u2192 Prop} (HRS : \u2200 \u2983a b\u2984, R a b \u2192 S a b) {a b : \u03b1}\n    (Hab : \u2200 \u2983c\u2984, R a c \u2192 S b c) {l : List \u03b1} (p : Chain R a l) : Chain S b l", "start": [1960, 1], "end": [1967, 24], "kind": "commanddeclaration"}, {"full_name": "List.Chain.imp", "code": "theorem Chain.imp {R S : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : \u2200 a b, R a b \u2192 S a b) {a : \u03b1} {l : List \u03b1}\n    (p : Chain R a l) : Chain S a l", "start": [1969, 1], "end": [1971, 17], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.chain", "code": "protected theorem Pairwise.chain (p : Pairwise R (a :: l)) : Chain R a l", "start": [1973, 1], "end": [1979, 36], "kind": "commanddeclaration"}, {"full_name": "List.length_range'", "code": "@[simp] theorem length_range' (s step) : \u2200 n : Nat, length (range' s n step) = n", "start": [1983, 1], "end": [1985, 49], "kind": "commanddeclaration"}, {"full_name": "List.range'_eq_nil", "code": "@[simp] theorem range'_eq_nil : range' s n step = [] \u2194 n = 0", "start": [1987, 1], "end": [1988, 39], "kind": "commanddeclaration"}, {"full_name": "List.mem_range'", "code": "theorem mem_range' : \u2200{n}, m \u2208 range' s n step \u2194 \u2203 i < n, m = s + step * i", "start": [1990, 1], "end": [1995, 71], "kind": "commanddeclaration"}, {"full_name": "List.mem_range'_1", "code": "@[simp] theorem mem_range'_1 : m \u2208 range' s n \u2194 s \u2264 m \u2227 m < s + n", "start": [1997, 1], "end": [2000, 93], "kind": "commanddeclaration"}, {"full_name": "List.map_add_range'", "code": "theorem map_add_range' (a) : \u2200 s n step, map (a + \u00b7) (range' s n step) = range' (a + s) n step", "start": [2002, 1], "end": [2004, 90], "kind": "commanddeclaration"}, {"full_name": "List.map_sub_range'", "code": "theorem map_sub_range' (a s n : Nat) (h : a \u2264 s) :\n    map (\u00b7 - a) (range' s n step) = range' (s - a) n step", "start": [2006, 1], "end": [2010, 42], "kind": "commanddeclaration"}, {"full_name": "List.chain_succ_range'", "code": "theorem chain_succ_range' : \u2200 s n step : Nat,\n    Chain (fun a b => b = a + step) s (range' (s + step) n step)", "start": [2012, 1], "end": [2015, 69], "kind": "commanddeclaration"}, {"full_name": "List.chain_lt_range'", "code": "theorem chain_lt_range' (s n : Nat) {step} (h : 0 < step) :\n    Chain (\u00b7 < \u00b7) s (range' (s + step) n step)", "start": [2017, 1], "end": [2019, 83], "kind": "commanddeclaration"}, {"full_name": "List.range'_append", "code": "theorem range'_append : \u2200 s m n step : Nat,\n    range' s m step ++ range' (s + step * m) n step = range' s (n + m) step", "start": [2021, 1], "end": [2026, 46], "kind": "commanddeclaration"}, {"full_name": "List.range'_append_1", "code": "@[simp] theorem range'_append_1 (s m n : Nat) :\n    range' s m ++ range' (s + m) n = range' s (n + m)", "start": [2028, 1], "end": [2029, 94], "kind": "commanddeclaration"}, {"full_name": "List.range'_sublist_right", "code": "theorem range'_sublist_right {s m n : Nat} : range' s m step <+ range' s n step \u2194 m \u2264 n", "start": [2031, 1], "end": [2033, 88], "kind": "commanddeclaration"}, {"full_name": "List.range'_subset_right", "code": "theorem range'_subset_right {s m n : Nat} (step0 : 0 < step) :\n    range' s m step \u2286 range' s n step \u2194 m \u2264 n", "start": [2035, 1], "end": [2039, 82], "kind": "commanddeclaration"}, {"full_name": "List.range'_subset_right_1", "code": "theorem range'_subset_right_1 {s m n : Nat} : range' s m \u2286 range' s n \u2194 m \u2264 n", "start": [2041, 1], "end": [2042, 34], "kind": "commanddeclaration"}, {"full_name": "List.get?_range'", "code": "theorem get?_range' (s step) : \u2200 {m n : Nat}, m < n \u2192 get? (range' s n step) m = some (s + step * m)", "start": [2044, 1], "end": [2048, 55], "kind": "commanddeclaration"}, {"full_name": "List.get_range'", "code": "@[simp] theorem get_range' {n m step} (i) (H : i < (range' n m step).length) :\n    get (range' n m step) \u27e8i, H\u27e9 = n + step * i", "start": [2050, 1], "end": [2052, 62], "kind": "commanddeclaration"}, {"full_name": "List.range'_concat", "code": "theorem range'_concat (s n : Nat) : range' s (n + 1) step = range' s n step ++ [s + step * n]", "start": [2054, 1], "end": [2055, 63], "kind": "commanddeclaration"}, {"full_name": "List.range'_1_concat", "code": "theorem range'_1_concat (s n : Nat) : range' s (n + 1) = range' s n ++ [s + n]", "start": [2057, 1], "end": [2058, 23], "kind": "commanddeclaration"}, {"full_name": "List.range_loop_range'", "code": "theorem range_loop_range' : \u2200 s n : Nat, range.loop s (range' s n) = range' 0 (n + s)", "start": [2060, 1], "end": [2062, 101], "kind": "commanddeclaration"}, {"full_name": "List.range_eq_range'", "code": "theorem range_eq_range' (n : Nat) : range n = range' 0 n", "start": [2064, 1], "end": [2065, 56], "kind": "commanddeclaration"}, {"full_name": "List.range_succ_eq_map", "code": "theorem range_succ_eq_map (n : Nat) : range (n + 1) = 0 :: map succ (range n)", "start": [2067, 1], "end": [2069, 30], "kind": "commanddeclaration"}, {"full_name": "List.range'_eq_map_range", "code": "theorem range'_eq_map_range (s n : Nat) : range' s n = map (s + \u00b7) (range n)", "start": [2071, 1], "end": [2072, 44], "kind": "commanddeclaration"}, {"full_name": "List.length_range", "code": "@[simp] theorem length_range (n : Nat) : length (range n) = n", "start": [2074, 1], "end": [2075, 45], "kind": "commanddeclaration"}, {"full_name": "List.range_eq_nil", "code": "@[simp] theorem range_eq_nil {n : Nat} : range n = [] \u2194 n = 0", "start": [2077, 1], "end": [2078, 38], "kind": "commanddeclaration"}, {"full_name": "List.range_sublist", "code": "theorem range_sublist {m n : Nat} : range m <+ range n \u2194 m \u2264 n", "start": [2080, 1], "end": [2081, 52], "kind": "commanddeclaration"}, {"full_name": "List.range_subset", "code": "theorem range_subset {m n : Nat} : range m \u2286 range n \u2194 m \u2264 n", "start": [2083, 1], "end": [2084, 51], "kind": "commanddeclaration"}, {"full_name": "List.mem_range", "code": "@[simp]\ntheorem mem_range {m n : Nat} : m \u2208 range n \u2194 m < n", "start": [2086, 1], "end": [2088, 81], "kind": "commanddeclaration"}, {"full_name": "List.not_mem_range_self", "code": "theorem not_mem_range_self {n : Nat} : n \u2209 range n", "start": [2090, 1], "end": [2090, 62], "kind": "commanddeclaration"}, {"full_name": "List.self_mem_range_succ", "code": "theorem self_mem_range_succ (n : Nat) : n \u2208 range (n + 1)", "start": [2092, 1], "end": [2092, 69], "kind": "commanddeclaration"}, {"full_name": "List.get?_range", "code": "theorem get?_range {m n : Nat} (h : m < n) : get? (range n) m = some m", "start": [2094, 1], "end": [2095, 44], "kind": "commanddeclaration"}, {"full_name": "List.range_succ", "code": "theorem range_succ (n : Nat) : range (succ n) = range n ++ [n]", "start": [2097, 1], "end": [2098, 61], "kind": "commanddeclaration"}, {"full_name": "List.range_zero", "code": "@[simp] theorem range_zero : range 0 = []", "start": [2100, 1], "end": [2100, 49], "kind": "commanddeclaration"}, {"full_name": "List.range_add", "code": "theorem range_add (a b : Nat) : range (a + b) = range a ++ (range b).map (a + \u00b7)", "start": [2102, 1], "end": [2104, 75], "kind": "commanddeclaration"}, {"full_name": "List.iota_eq_reverse_range'", "code": "theorem iota_eq_reverse_range' : \u2200 n : Nat, iota n = reverse (range' 1 n)", "start": [2106, 1], "end": [2108, 99], "kind": "commanddeclaration"}, {"full_name": "List.length_iota", "code": "@[simp] theorem length_iota (n : Nat) : length (iota n) = n", "start": [2110, 1], "end": [2110, 96], "kind": "commanddeclaration"}, {"full_name": "List.mem_iota", "code": "theorem mem_iota {m n : Nat} : m \u2208 iota n \u2194 1 \u2264 m \u2227 m \u2264 n", "start": [2112, 1], "end": [2113, 59], "kind": "commanddeclaration"}, {"full_name": "List.reverse_range'", "code": "theorem reverse_range' : \u2200 s n : Nat, reverse (range' s n) = map (s + n - 1 - \u00b7) (range n)", "start": [2115, 1], "end": [2120, 51], "kind": "commanddeclaration"}, {"full_name": "List.get_range", "code": "@[simp] theorem get_range {n} (i) (H : i < (range n).length) : get (range n) \u27e8i, H\u27e9 = i", "start": [2122, 1], "end": [2123, 76], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_map_fst", "code": "@[simp] theorem enumFrom_map_fst (n) :\n    \u2200 (l : List \u03b1), map Prod.fst (enumFrom n l) = range' n l.length", "start": [2127, 1], "end": [2130, 55], "kind": "commanddeclaration"}, {"full_name": "List.enum_map_fst", "code": "@[simp] theorem enum_map_fst (l : List \u03b1) : map Prod.fst (enum l) = range l.length", "start": [2132, 1], "end": [2133, 54], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/AssocList.lean", "imports": ["lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.AssocList", "code": "inductive AssocList (\u03b1 : Type u) (\u03b2 : Type v) where\n  \n  | nil\n  \n  | cons (key : \u03b1) (value : \u03b2) (tail : AssocList \u03b1 \u03b2)\n  deriving Inhabited", "start": [10, 1], "end": [21, 21], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.toList", "code": "@[simp] def toList : AssocList \u03b1 \u03b2 \u2192 List (\u03b1 \u00d7 \u03b2)\n  | nil => []\n  | cons a b es => (a, b) :: es.toList", "start": [25, 1], "end": [32, 39], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.empty_eq", "code": "@[simp] theorem empty_eq : (\u2205 : AssocList \u03b1 \u03b2) = nil", "start": [36, 1], "end": [36, 60], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.isEmpty", "code": "def isEmpty : AssocList \u03b1 \u03b2 \u2192 Bool\n  | nil => true\n  | _   => false", "start": [38, 1], "end": [41, 17], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.isEmpty_eq", "code": "@[simp] theorem isEmpty_eq (l : AssocList \u03b1 \u03b2) : isEmpty l = l.toList.isEmpty", "start": [43, 1], "end": [44, 46], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.foldlM", "code": "@[specialize] def foldlM [Monad m] (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b4) : (init : \u03b4) \u2192 AssocList \u03b1 \u03b2 \u2192 m \u03b4\n  | d, nil         => pure d\n  | d, cons a b es => do foldlM f (\u2190 f d a b) es", "start": [46, 1], "end": [49, 49], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.foldlM_eq", "code": "@[simp] theorem foldlM_eq [Monad m] (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b4) (init l) :\n    foldlM f init l = l.toList.foldlM (fun d (a, b) => f d a b) init", "start": [51, 1], "end": [53, 53], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.foldl", "code": "@[inline] def foldl (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b4) (init : \u03b4) (as : AssocList \u03b1 \u03b2) : \u03b4 :=\n  Id.run (foldlM f init as)", "start": [55, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.foldl_eq", "code": "@[simp] theorem foldl_eq (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b4) (init l) :\n    foldl f init l = l.toList.foldl (fun d (a, b) => f d a b) init", "start": [59, 1], "end": [61, 45], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.toListTR", "code": "def toListTR (as : AssocList \u03b1 \u03b2) : List (\u03b1 \u00d7 \u03b2) :=\n  as.foldl (init := #[]) (fun r a b => r.push (a, b)) |>.toList", "start": [63, 1], "end": [65, 64], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.toList_eq_toListTR", "code": "@[csimp] theorem toList_eq_toListTR : @toList = @toListTR", "start": [67, 1], "end": [69, 82], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.forM", "code": "@[specialize] def forM [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) : AssocList \u03b1 \u03b2 \u2192 m PUnit\n  | nil         => pure \u27e8\u27e9\n  | cons a b es => do f a b; forM f es", "start": [71, 1], "end": [74, 39], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.forM_eq", "code": "@[simp] theorem forM_eq [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) (l) :\n    forM f l = l.toList.forM (fun (a, b) => f a b)", "start": [76, 1], "end": [78, 33], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.mapKey", "code": "@[simp] def mapKey (f : \u03b1 \u2192 \u03b4) : AssocList \u03b1 \u03b2 \u2192 AssocList \u03b4 \u03b2\n  | nil        => nil\n  | cons k v t => cons (f k) v (mapKey f t)", "start": [80, 1], "end": [83, 44], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.mapKey_toList", "code": "@[simp] theorem mapKey_toList (f : \u03b1 \u2192 \u03b4) (l : AssocList \u03b1 \u03b2) :\n    (mapKey f l).toList = l.toList.map (fun (a, b) => (f a, b))", "start": [85, 1], "end": [87, 27], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.mapVal", "code": "@[simp] def mapVal (f : \u03b1 \u2192 \u03b2 \u2192 \u03b4) : AssocList \u03b1 \u03b2 \u2192 AssocList \u03b1 \u03b4\n  | nil        => nil\n  | cons k v t => cons k (f k v) (mapVal f t)", "start": [89, 1], "end": [92, 46], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.mapVal_toList", "code": "@[simp] theorem mapVal_toList (f : \u03b1 \u2192 \u03b2 \u2192 \u03b4) (l : AssocList \u03b1 \u03b2) :\n    (mapVal f l).toList = l.toList.map (fun (a, b) => (a, f a b))", "start": [94, 1], "end": [96, 27], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.findEntryP?", "code": "@[specialize] def findEntryP? (p : \u03b1 \u2192 \u03b2 \u2192 Bool) : AssocList \u03b1 \u03b2 \u2192 Option (\u03b1 \u00d7 \u03b2)\n  | nil         => none\n  | cons k v es => bif p k v then some (k, v) else findEntryP? p es", "start": [98, 1], "end": [101, 68], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.findEntryP?_eq", "code": "@[simp] theorem findEntryP?_eq (p : \u03b1 \u2192 \u03b2 \u2192 Bool) (l : AssocList \u03b1 \u03b2) :\n    findEntryP? p l = l.toList.find? fun (a, b) => p a b", "start": [103, 1], "end": [105, 74], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.findEntry?", "code": "@[inline] def findEntry? [BEq \u03b1] (a : \u03b1) (l : AssocList \u03b1 \u03b2) : Option (\u03b1 \u00d7 \u03b2) :=\n  findEntryP? (fun k _ => k == a) l", "start": [107, 1], "end": [109, 36], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.findEntry?_eq", "code": "@[simp] theorem findEntry?_eq [BEq \u03b1] (a : \u03b1) (l : AssocList \u03b1 \u03b2) :\n    findEntry? a l = l.toList.find? (\u00b7.1 == a)", "start": [111, 1], "end": [112, 68], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.find?", "code": "def find? [BEq \u03b1] (a : \u03b1) : AssocList \u03b1 \u03b2 \u2192 Option \u03b2\n  | nil         => none\n  | cons k v es => match k == a with\n    | true  => some v\n    | false => find? a es", "start": [114, 1], "end": [119, 26], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.find?_eq_findEntry?", "code": "theorem find?_eq_findEntry? [BEq \u03b1] (a : \u03b1) (l : AssocList \u03b1 \u03b2) :\n    find? a l = (l.findEntry? a).map (\u00b7.2)", "start": [121, 1], "end": [123, 68], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.find?_eq", "code": "@[simp] theorem find?_eq [BEq \u03b1] (a : \u03b1) (l : AssocList \u03b1 \u03b2) :\n    find? a l = (l.toList.find? (\u00b7.1 == a)).map (\u00b7.2)", "start": [125, 1], "end": [126, 87], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.any", "code": "@[specialize] def any (p : \u03b1 \u2192 \u03b2 \u2192 Bool) : AssocList \u03b1 \u03b2 \u2192 Bool\n  | nil         => false\n  | cons k v es => p k v || any p es", "start": [128, 1], "end": [131, 37], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.any_eq", "code": "@[simp] theorem any_eq (p : \u03b1 \u2192 \u03b2 \u2192 Bool) (l : AssocList \u03b1 \u03b2) :\n    any p l = l.toList.any fun (a, b) => p a b", "start": [133, 1], "end": [134, 83], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.all", "code": "@[specialize] def all (p : \u03b1 \u2192 \u03b2 \u2192 Bool) : AssocList \u03b1 \u03b2 \u2192 Bool\n  | nil         => true\n  | cons k v es => p k v && all p es", "start": [136, 1], "end": [139, 37], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.all_eq", "code": "@[simp] theorem all_eq (p : \u03b1 \u2192 \u03b2 \u2192 Bool) (l : AssocList \u03b1 \u03b2) :\n    all p l = l.toList.all fun (a, b) => p a b", "start": [141, 1], "end": [142, 83], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.All", "code": "def All (p : \u03b1 \u2192 \u03b2 \u2192 Prop) (l : AssocList \u03b1 \u03b2) : Prop := \u2200 a \u2208 l.toList, p a.1 a.2", "start": [144, 1], "end": [145, 83], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.contains", "code": "@[inline] def contains [BEq \u03b1] (a : \u03b1) (l : AssocList \u03b1 \u03b2) : Bool := any (fun k _ => k == a) l", "start": [147, 1], "end": [148, 95], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.contains_eq", "code": "@[simp] theorem contains_eq [BEq \u03b1] (a : \u03b1) (l : AssocList \u03b1 \u03b2) :\n    contains a l = l.toList.any (\u00b7.1 == a)", "start": [150, 1], "end": [152, 37], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.replace", "code": "@[simp] def replace [BEq \u03b1] (a : \u03b1) (b : \u03b2) : AssocList \u03b1 \u03b2 \u2192 AssocList \u03b1 \u03b2\n  | nil         => nil\n  | cons k v es => match k == a with\n    | true  => cons a b es\n    | false => cons k v (replace a b es)", "start": [154, 1], "end": [162, 41], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.replace_toList", "code": "@[simp] theorem replace_toList [BEq \u03b1] (a : \u03b1) (b : \u03b2) (l : AssocList \u03b1 \u03b2) :\n    (replace a b l).toList =\n    l.toList.replaceF (bif \u00b7.1 == a then some (a, b) else none)", "start": [164, 1], "end": [167, 53], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.eraseP", "code": "@[specialize, simp] def eraseP (p : \u03b1 \u2192 \u03b2 \u2192 Bool) : AssocList \u03b1 \u03b2 \u2192 AssocList \u03b1 \u03b2\n  | nil         => nil\n  | cons k v es => bif p k v then es else cons k v (eraseP p es)", "start": [169, 1], "end": [172, 65], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.eraseP_toList", "code": "@[simp] theorem eraseP_toList (p) (l : AssocList \u03b1 \u03b2) :\n    (eraseP p l).toList = l.toList.eraseP fun (a, b) => p a b", "start": [174, 1], "end": [176, 63], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.erase", "code": "@[inline] def erase [BEq \u03b1] (a : \u03b1) (l : AssocList \u03b1 \u03b2) : AssocList \u03b1 \u03b2 :=\n  eraseP (fun k _ => k == a) l", "start": [178, 1], "end": [180, 31], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.erase_toList", "code": "@[simp] theorem erase_toList [BEq \u03b1] (a : \u03b1) (l : AssocList \u03b1 \u03b2) :\n    (erase a l).toList = l.toList.eraseP (\u00b7.1 == a)", "start": [182, 1], "end": [183, 72], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.modify", "code": "@[simp] def modify [BEq \u03b1] (a : \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) : AssocList \u03b1 \u03b2 \u2192 AssocList \u03b1 \u03b2\n  | nil         => nil\n  | cons k v es => match k == a with\n    | true  => cons a (f k v) es\n    | false => cons k v (modify a f es)", "start": [185, 1], "end": [193, 40], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.modify_toList", "code": "@[simp] theorem modify_toList [BEq \u03b1] (a : \u03b1) (l : AssocList \u03b1 \u03b2) :\n    (modify a f l).toList =\n    l.toList.replaceF fun (k, v) => bif k == a then some (a, f k v) else none", "start": [195, 1], "end": [200, 49], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.forIn", "code": "@[specialize] protected def forIn [Monad m]\n    (as : AssocList \u03b1 \u03b2) (init : \u03b4) (f : (\u03b1 \u00d7 \u03b2) \u2192 \u03b4 \u2192 m (ForInStep \u03b4)) : m \u03b4 :=\n  match as with\n  | nil => pure init\n  | cons k v es => do\n    match (\u2190 f (k, v) init) with\n    | ForInStep.done d  => pure d\n    | ForInStep.yield d => es.forIn d f", "start": [202, 1], "end": [210, 40], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.forIn_eq", "code": "@[simp] theorem forIn_eq [Monad m] (l : AssocList \u03b1 \u03b2) (init : \u03b4)\n    (f : (\u03b1 \u00d7 \u03b2) \u2192 \u03b4 \u2192 m (ForInStep \u03b4)) : forIn l init f = forIn l.toList init f", "start": [215, 1], "end": [219, 38], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.pop?", "code": "def pop? : AssocList \u03b1 \u03b2 \u2192 Option ((\u03b1 \u00d7 \u03b2) \u00d7 AssocList \u03b1 \u03b2)\n  | nil => none\n  | cons a b l => some ((a, b), l)", "start": [221, 1], "end": [224, 35], "kind": "commanddeclaration"}, {"full_name": "List.toAssocList", "code": "@[simp] def _root_.List.toAssocList : List (\u03b1 \u00d7 \u03b2) \u2192 AssocList \u03b1 \u03b2\n  | []          => nil\n  | (a,b) :: es => cons a b (toAssocList es)", "start": [229, 1], "end": [232, 45], "kind": "commanddeclaration"}, {"full_name": "List.toAssocList_toList", "code": "@[simp] theorem _root_.List.toAssocList_toList (l : List (\u03b1 \u00d7 \u03b2)) : l.toAssocList.toList = l", "start": [234, 1], "end": [235, 27], "kind": "commanddeclaration"}, {"full_name": "Std.AssocList.toList_toAssocList", "code": "@[simp] theorem toList_toAssocList (l : AssocList \u03b1 \u03b2) : l.toList.toAssocList = l", "start": [237, 1], "end": [238, 27], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/MonadScope.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Scope", "code": "abbrev Scope := FVarIdSet", "start": [10, 1], "end": [10, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.MonadScope", "code": "class MonadScope (m : Type \u2192 Type) where\n  getScope : m Scope\n  withScope : (Scope \u2192 Scope) \u2192 m \u03b1 \u2192 m \u03b1", "start": [12, 1], "end": [14, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ScopeT", "code": "abbrev ScopeT (m : Type \u2192 Type) := ReaderT Scope m", "start": [18, 1], "end": [18, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.inScope", "code": "def inScope [MonadScope m] [Monad m] (fvarId : FVarId) : m Bool :=\n  return (\u2190 getScope).contains fvarId", "start": [28, 1], "end": [29, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.withParams", "code": "@[inline] def withParams [MonadScope m] [Monad m] (ps : Array Param) (x : m \u03b1) : m \u03b1 :=\n  withScope (fun s => ps.foldl (init := s) fun s p => s.insert p.fvarId) x", "start": [31, 1], "end": [32, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.withFVar", "code": "@[inline] def withFVar [MonadScope m] [Monad m] (fvarId : FVarId) (x : m \u03b1) : m \u03b1 :=\n  withScope (fun s => s.insert fvarId) x", "start": [34, 1], "end": [35, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.withNewScope", "code": "@[inline] def withNewScope [MonadScope m] [Monad m] (x : m \u03b1) : m \u03b1 := do\n  withScope (fun _ => {}) x", "start": [37, 1], "end": [38, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Closure.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Util/ForEachExprWhere.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Closure.Context", "code": "structure Context where\n  \n  inScope : FVarId \u2192 Bool\n  \n  abstract : FVarId \u2192 Bool", "start": [20, 1], "end": [30, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.State", "code": "structure State where\n  \n  visited : FVarIdSet := {}\n  \n  params  : Array Param := #[]\n  \n  decls   : Array CodeDecl := #[]", "start": [32, 1], "end": [54, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.ClosureM", "code": "abbrev ClosureM := ReaderT Context $ StateRefT State CompilerM", "start": [56, 1], "end": [59, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.markVisited", "code": "def markVisited (fvarId : FVarId) : ClosureM Unit :=\n  modify fun s => { s with visited := s.visited.insert fvarId }", "start": [61, 1], "end": [66, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.collectParams", "code": "partial def collectParams (params : Array Param) : ClosureM Unit :=\n    params.forM (collectType \u00b7.type)", "start": [69, 2], "end": [74, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.collectArg", "code": "partial def collectArg (arg : Arg) : ClosureM Unit :=\n    match arg with\n    | .erased => return ()\n    | .type e => collectType e\n    | .fvar fvarId => collectFVar fvarId", "start": [76, 3], "end": [80, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.collectLetValue", "code": "partial def collectLetValue (e : LetValue) : ClosureM Unit := do\n    match e with\n    | .erased | .value .. => return ()\n    | .proj _ _ fvarId => collectFVar fvarId\n    | .const _ _ args => args.forM collectArg\n    | .fvar fvarId args => collectFVar fvarId; args.forM collectArg", "start": [82, 3], "end": [87, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.collectCode", "code": "partial def collectCode (c : Code) : ClosureM Unit := do\n    match c with\n    | .let decl k => collectType decl.type; collectLetValue decl.value; collectCode k\n    | .fun decl k | .jp decl k => collectFunDecl decl; collectCode k\n    | .cases c =>\n      collectType c.resultType\n      collectFVar c.discr\n      c.alts.forM fun alt => do\n        match alt with\n        | .default k => collectCode k\n        | .alt _ ps k => collectParams ps; collectCode k\n    | .jmp _ args => args.forM collectArg\n    | .unreach type => collectType type\n    | .return fvarId => collectFVar fvarId", "start": [89, 3], "end": [106, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.collectFunDecl", "code": "partial def collectFunDecl (decl : FunDecl) : ClosureM Unit := do\n    collectType decl.type\n    collectParams decl.params\n    collectCode decl.value", "start": [108, 3], "end": [112, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.collectFVar", "code": "partial def collectFVar (fvarId : FVarId) : ClosureM Unit := do\n    unless (\u2190 get).visited.contains fvarId do\n      markVisited fvarId\n      if (\u2190 read).inScope fvarId then\n        \n        if let some funDecl \u2190 findFunDecl? fvarId then\n          if (\u2190 read).abstract funDecl.fvarId then\n            modify fun s => { s with params := s.params.push <| { funDecl with borrow := false } }\n          else\n            collectFunDecl funDecl\n            modify fun s => { s with decls := s.decls.push <| .fun funDecl }\n        else if let some param \u2190 findParam? fvarId then\n          collectType param.type\n          modify fun s => { s with params := s.params.push param }\n        else if let some letDecl \u2190 findLetDecl? fvarId then\n          collectType letDecl.type\n          if (\u2190 read).abstract letDecl.fvarId then\n            modify fun s => { s with params := s.params.push <| { letDecl with borrow := false } }\n          else\n            collectLetValue letDecl.value\n            modify fun s => { s with decls := s.decls.push <| .let letDecl }\n        else\n          unreachable!", "start": [114, 3], "end": [140, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.collectType", "code": "partial def collectType (type : Expr) : ClosureM Unit := do\n    type.forEachWhere Expr.isFVar fun e => collectFVar e.fvarId!", "start": [142, 3], "end": [144, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Closure.run", "code": "def run (x : ClosureM \u03b1) (inScope : FVarId \u2192 Bool) (abstract : FVarId \u2192 Bool := fun _ => true) : CompilerM (\u03b1 \u00d7 Array Param \u00d7 Array CodeDecl) := do\n  let (a, s) \u2190 x { inScope, abstract } |>.run {}\n  return (a, s.params, s.decls)", "start": [148, 1], "end": [150, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Level.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/CollectLevelParams.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.NormLevelParam.State", "code": "structure State where\n  \n  nextIdx    : Nat := 1\n  \n  map        : HashMap Name Level := {}\n  \n  paramNames : Array Name := #[]", "start": [27, 1], "end": [34, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.NormLevelParam.M", "code": "abbrev M := StateM State", "start": [36, 1], "end": [37, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.NormLevelParam.normLevel", "code": "partial def normLevel (u : Level) : M Level := do\n  if !u.hasParam then\n    return u\n  else match u with\n    | .zero     => return u\n    | .succ v   => return u.updateSucc! (\u2190 normLevel v)\n    | .max v w  => return u.updateMax! (\u2190 normLevel v) (\u2190 normLevel w)\n    | .imax v w => return u.updateIMax! (\u2190 normLevel v) (\u2190 normLevel w)\n    | .mvar _   => unreachable!\n    | .param n  => match (\u2190 get).map.find? n with\n      | some u => return u\n      | none   =>\n        let u := Level.param <| (`u).appendIndexAfter (\u2190 get).nextIdx\n        modify fun { nextIdx, map, paramNames } =>\n          { nextIdx := nextIdx + 1, map := map.insert n u, paramNames := paramNames.push n }\n        return u", "start": [39, 1], "end": [57, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.NormLevelParam.normExpr", "code": "partial def normExpr (e : Expr) : M Expr := do\n  if !e.hasLevelParam then\n    return e\n  else match e with\n    | .const _ us      => return e.updateConst! (\u2190 us.mapM normLevel)\n    | .sort u          => return e.updateSort! (\u2190 normLevel u)\n    | .app f a         => return e.updateApp! (\u2190 normExpr f) (\u2190 normExpr a)\n    | .letE _ t v b _  => return e.updateLet! (\u2190 normExpr t) (\u2190 normExpr v) (\u2190 normExpr b)\n    | .forallE _ d b _ => return e.updateForallE! (\u2190 normExpr d) (\u2190 normExpr b)\n    | .lam _ d b _     => return e.updateLambdaE! (\u2190 normExpr d) (\u2190 normExpr b)\n    | .mdata _ b       => return e.updateMData! (\u2190 normExpr b)\n    | .proj _ _ b      => return e.updateProj! (\u2190 normExpr b)\n    | .mvar _          => unreachable!\n    | _                => return e", "start": [59, 1], "end": [75, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normLevelParams", "code": "def normLevelParams (e : Expr) : Expr \u00d7 List Name :=\n  let (e, s) := NormLevelParam.normExpr e |>.run {}\n  (e, s.paramNames.toList)", "start": [79, 1], "end": [85, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CollectLevelParams.visitType", "code": "abbrev visitType (type : Expr) : Visitor :=\n  visitExpr type", "start": [100, 1], "end": [101, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CollectLevelParams.visitArg", "code": "def visitArg (arg : Arg) : Visitor :=\n  match arg with\n  | .erased | .fvar .. => id\n  | .type e => visitType e", "start": [103, 1], "end": [106, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CollectLevelParams.visitArgs", "code": "def visitArgs (args : Array Arg) : Visitor :=\n  fun s => args.foldl (init := s) fun s arg => visitArg arg s", "start": [108, 1], "end": [109, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CollectLevelParams.visitLetValue", "code": "def visitLetValue (e : LetValue) : Visitor :=\n  match e with\n  | .erased | .value .. | .proj .. => id\n  | .const _ us args => visitLevels us \u2218 visitArgs args\n  | .fvar _ args => visitArgs args", "start": [111, 1], "end": [115, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CollectLevelParams.visitParam", "code": "def visitParam (p : Param) : Visitor :=\n  visitType p.type", "start": [117, 1], "end": [118, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CollectLevelParams.visitParams", "code": "def visitParams (ps : Array Param) : Visitor :=\n  fun s => ps.foldl (init := s) fun s p => visitParam p s", "start": [120, 1], "end": [121, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CollectLevelParams.visitAlt", "code": "partial def visitAlt (alt : Alt) : Visitor :=\n    match alt with\n    | .default k => visitCode k\n    | .alt _ ps k => visitCode k \u2218 visitParams ps", "start": [124, 3], "end": [127, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CollectLevelParams.visitAlts", "code": "partial def visitAlts (alts : Array Alt) : Visitor :=\n    fun s => alts.foldl (init := s) fun s alt => visitAlt alt s", "start": [129, 3], "end": [130, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CollectLevelParams.visitCode", "code": "partial def visitCode : Code \u2192 Visitor\n    | .let decl k => visitCode k \u2218 visitLetValue decl.value \u2218 visitType decl.type\n    | .fun decl k | .jp decl k => visitCode k \u2218 visitCode decl.value \u2218 visitParams decl.params \u2218 visitType decl.type\n    | .cases c => visitAlts c.alts \u2218 visitType c.resultType\n    | .unreach type => visitType type\n    | .return _ => id\n    | .jmp _ args => visitArgs args", "start": [132, 3], "end": [138, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.setLevelParams", "code": "def Decl.setLevelParams (decl : Decl) : Decl :=\n  let levelParams := (visitCode decl.value \u2218 visitParams decl.params \u2218 visitType decl.type) {} |>.params.toList\n  { decl with levelParams }", "start": [146, 1], "end": [152, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/AuxDeclCache.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/DeclHash.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Internalize.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.AuxDeclCache", "code": "abbrev AuxDeclCache := PHashMap Decl Name", "start": [12, 1], "end": [12, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CacheAuxDeclResult", "code": "inductive CacheAuxDeclResult where\n  | new\n  | alreadyCached (declName : Name)", "start": [16, 1], "end": [18, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.cacheAuxDecl", "code": "def cacheAuxDecl (decl : Decl) : CompilerM CacheAuxDeclResult := do\n  let key := { decl with name := .anonymous }\n  let key \u2190 normalizeFVarIds key\n  match auxDeclCacheExt.getState (\u2190 getEnv) |>.find? key with\n  | some declName =>\n    return .alreadyCached declName\n  | none =>\n    modifyEnv fun env => auxDeclCacheExt.modifyState env fun s => s.insert key decl.name\n    return .new", "start": [20, 1], "end": [28, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/InlineProj.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/SimpValue.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/FunDeclInfo.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Renaming.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ReduceJpArity.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/InlineCandidate.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/JpCases.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Main.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Config.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/Used.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp/DefaultAlt.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Decl.simp?", "code": "def Decl.simp? (decl : Decl) : SimpM (Option Decl) := do\n  updateFunDeclInfo decl.value\n  traceM `Compiler.simp.inline.info do return m!\"{decl.name}:{Format.nest 2 (\u2190 (\u2190 get).funDeclInfoMap.format)}\"\n  traceM `Compiler.simp.step do ppDecl decl\n  let value \u2190 simp decl.value\n  let s \u2190 get\n  let value \u2190 value.applyRenaming s.binderRenaming\n  traceM `Compiler.simp.step.new do return m!\"{decl.name} :=\\n{\u2190 ppCode value}\"\n  trace[Compiler.simp.stat] \"{decl.name}, size: {value.size}, # visited: {s.visited}, # inline: {s.inline}, # inline local: {s.inlineLocal}\"\n  if let some value \u2190 simpJpCases? value then\n    let decl := { decl with value }\n    decl.reduceJpArity\n  else if (\u2190 get).simplified then\n    return some { decl with value }\n  else\n    return none", "start": [23, 1], "end": [38, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.simp", "code": "partial def Decl.simp (decl : Decl) (config : Config) : CompilerM Decl := do\n  let mut config := config\n  if (\u2190 isTemplateLike decl) then\n    let mut inlineDefs := config.inlineDefs\n    \n    if (\u2190 inBasePhase <&&> Meta.isInstance decl.name) then\n      unless decl.inlineable do\n        inlineDefs := false\n    \n    config := { config with etaPoly := false, inlinePartial := false, inlineDefs }\n  go decl config\nwhere\n  go (decl : Decl) (config : Config) : CompilerM Decl := do\n    if let some decl \u2190 decl.simp? |>.run { config, declName := decl.name } |>.run' {} |>.run {} then\n      go decl config\n    else\n      return decl", "start": [40, 1], "end": [74, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.simp", "code": "def simp (config : Config := {}) (occurrence : Nat := 0) (phase := Phase.base) : Pass :=\n  .mkPerDeclaration `simp (Decl.simp \u00b7 config) phase (occurrence := occurrence)", "start": [76, 1], "end": [77, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/SpecInfo.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/Specialize.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/FixedParams.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.SpecParamInfo", "code": "inductive SpecParamInfo where\n  \n  | fixedInst\n  \n  | fixedHO\n  \n  | fixedNeutral\n  \n  | user\n  \n  | other\n  deriving Inhabited, Repr", "start": [12, 1], "end": [42, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.SpecState", "code": "structure SpecState where\n  specInfo : PHashMap Name (Array SpecParamInfo) := {}\n  deriving Inhabited", "start": [52, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.SpecEntry", "code": "structure SpecEntry where\n  declName   : Name\n  paramsInfo : Array SpecParamInfo\n  deriving Inhabited", "start": [56, 1], "end": [59, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.SpecState.addEntry", "code": "def addEntry (s : SpecState) (e : SpecEntry) : SpecState :=\n  match s with\n  | { specInfo } => { specInfo := specInfo.insert e.declName e.paramsInfo }", "start": [63, 1], "end": [65, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.declLt", "code": "private abbrev declLt (a b : SpecEntry) :=\n  Name.quickLt a.declName b.declName", "start": [69, 1], "end": [70, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.sortEntries", "code": "private abbrev sortEntries (entries : Array SpecEntry) : Array SpecEntry :=\n  entries.qsort declLt", "start": [72, 1], "end": [73, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.findAtSorted?", "code": "private abbrev findAtSorted? (entries : Array SpecEntry) (declName : Name) : Option SpecEntry :=\n  entries.binSearch { declName, paramsInfo := #[] } declLt", "start": [75, 1], "end": [76, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isNoSpecType", "code": "private def isNoSpecType (env : Environment) (type : Expr) : Bool :=\n  match type with\n  | .forallE _ _ b _ => isNoSpecType env b\n  | _ =>\n    if let .const declName _ := type.getAppFn then\n      hasNospecializeAttribute env declName\n    else\n      false", "start": [89, 1], "end": [100, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.hasFwdDeps", "code": "private def hasFwdDeps (decl : Decl) (paramsInfo : Array SpecParamInfo) (j : Nat) : Bool := Id.run do\n  let param := decl.params[j]!\n  for k in [j+1 : decl.params.size] do\n    if paramsInfo[k]! matches .user | .fixedHO | .fixedInst then\n      let param' := decl.params[k]!\n      if param'.type.containsFVar param.fvarId then\n        return true\n  return false", "start": [123, 1], "end": [136, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.saveSpecParamInfo", "code": "def saveSpecParamInfo (decls : Array Decl) : CompilerM Unit := do\n  let mut declsInfo := #[]\n  for decl in decls do\n    if hasNospecializeAttribute (\u2190 getEnv) decl.name then\n      declsInfo := declsInfo.push (mkArray decl.params.size .other)\n    else\n      let specArgs? := getSpecializationArgs? (\u2190 getEnv) decl.name\n      let contains (i : Nat) : Bool := specArgs?.getD #[] |>.contains i\n      let mut paramsInfo : Array SpecParamInfo := #[]\n      for i in [:decl.params.size] do\n        let param := decl.params[i]!\n        let info \u2190\n          if contains i then\n            pure .user\n          \n          else if isNoSpecType (\u2190 getEnv) param.type then\n            pure .other\n          else if isTypeFormerType param.type then\n            pure .fixedNeutral\n          else if (\u2190 isArrowClass? param.type).isSome then\n            pure .fixedInst\n          \n          else if specArgs? == some #[] && param.type matches .forallE .. then\n            pure .fixedHO\n          else\n            pure .other\n        paramsInfo := paramsInfo.push info\n        pure ()\n      declsInfo := declsInfo.push paramsInfo\n  if declsInfo.any fun paramsInfo => paramsInfo.any (\u00b7 matches .user | .fixedInst | .fixedHO) then\n    let m := mkFixedParamsMap decls\n    for i in [:decls.size] do\n      let decl := decls[i]!\n      let mut paramsInfo := declsInfo[i]!\n      let some mask := m.find? decl.name | unreachable!\n      trace[Compiler.specialize.info] \"{decl.name} {mask}\"\n      paramsInfo := paramsInfo.zipWith mask fun info fixed => if fixed || info matches .user then info else .other\n      for j in [:paramsInfo.size] do\n        let mut info  := paramsInfo[j]!\n        if info matches .fixedNeutral && !hasFwdDeps decl paramsInfo j then\n          paramsInfo := paramsInfo.set! j .other\n      if paramsInfo.any fun info => info matches .fixedInst | .fixedHO | .user then\n        trace[Compiler.specialize.info] \"{decl.name} {paramsInfo}\"\n        modifyEnv fun env => specExtension.addEntry env { declName := decl.name, paramsInfo }", "start": [138, 1], "end": [195, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getSpecParamInfoCore?", "code": "def getSpecParamInfoCore? (env : Environment) (declName : Name) : Option (Array SpecParamInfo) :=\n  match env.getModuleIdxFor? declName with\n  | some modIdx =>\n    if let some entry := findAtSorted? (specExtension.getModuleEntries env modIdx) declName then\n      some entry.paramsInfo\n    else\n      none\n  | none => (specExtension.getState env).specInfo.find? declName", "start": [197, 1], "end": [204, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getSpecParamInfo?", "code": "def getSpecParamInfo? [Monad m] [MonadEnv m] (declName : Name) : m (Option (Array SpecParamInfo)) :=\n  return getSpecParamInfoCore? (\u2190 getEnv) declName", "start": [206, 1], "end": [207, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isSpecCandidate", "code": "def isSpecCandidate [Monad m] [MonadEnv m] (declName : Name) : m Bool := do\n  return getSpecParamInfoCore? (\u2190 getEnv) declName |>.isSome", "start": [209, 1], "end": [210, 61], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/FVarUtil.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.TraverseFVar", "code": "class TraverseFVar (\u03b1 : Type) where\n  mapFVarM {m : Type \u2192 Type} [MonadLiftT CompilerM m] [Monad m] (f : FVarId \u2192 m FVarId) (val : \u03b1) : m \u03b1\n  forFVarM {m : Type \u2192 Type} [Monad m] (f : FVarId \u2192 m Unit) (val : \u03b1) : m Unit", "start": [12, 1], "end": [14, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Expr.mapFVarM", "code": "partial def Expr.mapFVarM [MonadLiftT CompilerM m] [Monad m] (f : FVarId \u2192 m FVarId) (e : Expr) : m Expr := do\n  match e with\n  | .app fn arg => return e.updateApp! (\u2190 mapFVarM f fn) (\u2190 mapFVarM f arg)\n  | .fvar fvarId => return e.updateFVar! (\u2190 f fvarId)\n  | .lam _ ty body _ => return e.updateLambdaE! (\u2190 mapFVarM f ty) (\u2190 mapFVarM f body)\n  | .forallE _ ty body _ => return e.updateForallE! (\u2190 mapFVarM f ty) (\u2190 mapFVarM f body)\n  | .bvar .. | .sort .. => return e\n  | .mdata .. | .const .. | .lit .. => return e\n  | .letE ..  | .proj .. | .mvar .. => unreachable!", "start": [18, 1], "end": [26, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Expr.forFVarM", "code": "partial def Expr.forFVarM [Monad m] (f : FVarId \u2192 m Unit) (e : Expr) : m Unit := do\n  match e with\n  | .app fn arg =>\n    forFVarM f fn\n    forFVarM f arg\n  | .fvar fvarId => f fvarId\n  | .lam _ ty body .. =>\n    forFVarM f ty\n    forFVarM f body\n  | .forallE _ ty body .. =>\n    forFVarM f ty\n    forFVarM f body\n  | .bvar .. | .sort .. => return\n  | .mdata .. | .const .. | .lit .. => return\n  | .mvar .. | .letE .. | .proj .. => unreachable!", "start": [28, 1], "end": [42, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.mapFVarM", "code": "def Arg.mapFVarM [MonadLiftT CompilerM m] [Monad m] (f : FVarId \u2192 m FVarId) (arg : Arg) : m Arg := do\n  match arg with\n  | .erased => return .erased\n  | .type e => return arg.updateType! (\u2190 TraverseFVar.mapFVarM f e)\n  | .fvar fvarId => return arg.updateFVar! (\u2190 f fvarId)", "start": [48, 1], "end": [52, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.forFVarM", "code": "def Arg.forFVarM [Monad m] (f : FVarId \u2192 m Unit) (arg : Arg) : m Unit := do\n  match arg with\n  | .erased => return ()\n  | .type e => TraverseFVar.forFVarM f e\n  | .fvar fvarId => f fvarId", "start": [54, 1], "end": [58, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.mapFVarM", "code": "def LetValue.mapFVarM [MonadLiftT CompilerM m] [Monad m] (f : FVarId \u2192 m FVarId) (e : LetValue) : m LetValue := do\n  match e with\n  | .value .. | .erased => return e\n  | .proj _ _ fvarId => return e.updateProj! (\u2190 f fvarId)\n  | .const _ _ args => return e.updateArgs! (\u2190 args.mapM (TraverseFVar.mapFVarM f))\n  | .fvar fvarId args => return e.updateFVar! (\u2190 f fvarId) (\u2190 args.mapM (TraverseFVar.mapFVarM f))", "start": [64, 1], "end": [69, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.forFVarM", "code": "def LetValue.forFVarM [Monad m] (f : FVarId \u2192 m Unit) (e : LetValue) : m Unit := do\n  match e with\n  | .value .. | .erased => return ()\n  | .proj _ _ fvarId => f fvarId\n  | .const _ _ args => args.forM (TraverseFVar.forFVarM f)\n  | .fvar fvarId args => f fvarId; args.forM (TraverseFVar.forFVarM f)", "start": [71, 1], "end": [76, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl.mapFVarM", "code": "partial def LetDecl.mapFVarM [MonadLiftT CompilerM m] [Monad m] (f : FVarId \u2192 m FVarId) (decl : LetDecl) : m LetDecl := do\n  decl.update (\u2190 Expr.mapFVarM f decl.type) (\u2190 LetValue.mapFVarM f decl.value)", "start": [82, 1], "end": [83, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl.forFVarM", "code": "partial def LetDecl.forFVarM [Monad m] (f : FVarId \u2192 m Unit) (decl : LetDecl) : m Unit := do\n  Expr.forFVarM f decl.type\n  LetValue.forFVarM f decl.value", "start": [85, 1], "end": [87, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Param.mapFVarM", "code": "partial def Param.mapFVarM [MonadLiftT CompilerM m] [Monad m] (f : FVarId \u2192 m FVarId) (param : Param) : m Param := do\n  param.update (\u2190 Expr.mapFVarM f param.type)", "start": [93, 1], "end": [94, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Param.forFVarM", "code": "partial def Param.forFVarM [Monad m] (f : FVarId \u2192 m Unit) (param : Param) : m Unit := do\n  Expr.forFVarM f param.type", "start": [96, 1], "end": [97, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.mapFVarM", "code": "partial def Code.mapFVarM [MonadLiftT CompilerM m] [Monad m] (f : FVarId \u2192 m FVarId) (c : Code) : m Code := do\n  match c with\n  | .let decl k =>\n    let decl \u2190 LetDecl.mapFVarM f decl\n    return Code.updateLet! c decl (\u2190 mapFVarM f k)\n  | .fun decl k =>\n    let params \u2190 decl.params.mapM (Param.mapFVarM f)\n    let decl \u2190 decl.update (\u2190 Expr.mapFVarM f decl.type) params (\u2190 mapFVarM f decl.value)\n    return Code.updateFun! c decl (\u2190 mapFVarM f k)\n  | .jp decl k =>\n    let params \u2190 decl.params.mapM (Param.mapFVarM f)\n    let decl \u2190 decl.update (\u2190 Expr.mapFVarM f decl.type) params (\u2190 mapFVarM f decl.value)\n    return Code.updateFun! c decl (\u2190 mapFVarM f k)\n  | .cases cs =>\n    return Code.updateCases! c (\u2190 Expr.mapFVarM f cs.resultType) (\u2190 f cs.discr) (\u2190 cs.alts.mapM (\u00b7.mapCodeM (mapFVarM f)))\n  | .jmp fn args =>\n    return Code.updateJmp! c (\u2190 f fn) (\u2190 args.mapM (Arg.mapFVarM f))\n  | .return var =>\n    return Code.updateReturn! c (\u2190 f var)\n  | .unreach typ =>\n    return Code.updateUnreach! c (\u2190 Expr.mapFVarM f typ)", "start": [103, 1], "end": [123, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.forFVarM", "code": "partial def Code.forFVarM [Monad m] (f : FVarId \u2192 m Unit) (c : Code) : m Unit := do\n  match c with\n  | .let decl k =>\n    LetDecl.forFVarM f decl\n    forFVarM f k\n  | .fun decl k =>\n    decl.params.forM (Param.forFVarM f)\n    Expr.forFVarM f decl.type\n    forFVarM f decl.value\n    forFVarM f k\n  | .jp decl k =>\n    decl.params.forM (Param.forFVarM f)\n    Expr.forFVarM f decl.type\n    forFVarM f decl.value\n    forFVarM f k\n  | .cases cs =>\n    Expr.forFVarM f cs.resultType\n    f cs.discr\n    cs.alts.forM (\u00b7.forCodeM (forFVarM f))\n  | .jmp fn args =>\n    f fn\n    args.forM (Arg.forFVarM f)\n  | .return var => f var\n  | .unreach typ =>\n    Expr.forFVarM f typ", "start": [125, 1], "end": [149, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDecl.mapFVarM", "code": "def FunDecl.mapFVarM [MonadLiftT CompilerM m] [Monad m] (f : FVarId \u2192 m FVarId) (decl : FunDecl) : m FunDecl := do\n  let params \u2190 decl.params.mapM (Param.mapFVarM f)\n  decl.update (\u2190 Expr.mapFVarM f decl.type) params (\u2190 Code.mapFVarM f decl.value)", "start": [155, 1], "end": [157, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDecl.forFVarM", "code": "def FunDecl.forFVarM [Monad m] (f : FVarId \u2192 m Unit) (decl : FunDecl) : m Unit := do\n  decl.params.forM (Param.forFVarM f)\n  Expr.forFVarM f decl.type\n  Code.forFVarM f decl.value", "start": [159, 1], "end": [162, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.anyFVarM", "code": "def anyFVarM [Monad m] [TraverseFVar \u03b1] (f : FVarId \u2192 m Bool) (x : \u03b1) : m Bool := do\n  return (\u2190 TraverseFVar.forFVarM go x |>.run) matches none\nwhere\n  go (fvar : FVarId) : OptionT m Unit := do\n    if (\u2190 f fvar) then failure", "start": [194, 1], "end": [198, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.allFVarM", "code": "def allFVarM [Monad m] [TraverseFVar \u03b1] (f : FVarId \u2192 m Bool) (x : \u03b1) : m Bool := do\n  return (\u2190 TraverseFVar.forFVarM go x |>.run) matches .some ..\nwhere\n  go (fvar : FVarId) : OptionT m Unit := do\n    if !(\u2190 f fvar) then failure", "start": [200, 1], "end": [204, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.anyFVar", "code": "def anyFVar [TraverseFVar \u03b1] (f : FVarId \u2192 Bool) (x : \u03b1) : Bool :=\n  Id.run <| anyFVarM f x", "start": [206, 1], "end": [207, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.allFVar", "code": "def allFVar [TraverseFVar \u03b1] (f : FVarId \u2192 Bool) (x : \u03b1) : Bool :=\n  Id.run <| allFVarM f x", "start": [209, 1], "end": [210, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.ToExpr.LevelMap", "code": "private abbrev LevelMap := FVarIdMap Nat", "start": [12, 1], "end": [12, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.toExpr", "code": "private def _root_.Lean.FVarId.toExpr (offset : Nat) (m : LevelMap) (fvarId : FVarId) : Expr :=\n  match m.find? fvarId with\n  | some level => .bvar (offset - level - 1)\n  | none => .fvar fvarId", "start": [14, 1], "end": [17, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.abstract'", "code": "private def _root_.Lean.Expr.abstract' (offset : Nat) (m : LevelMap) (e : Expr) : Expr :=\n  go offset e\nwhere\n  go (o : Nat) (e : Expr) : Expr :=\n    match e with\n    | .fvar fvarId => fvarId.toExpr o m\n    | .lit .. | .const .. | .sort .. | .mvar .. | .bvar .. => e\n    | .app f a => .app (go o f) (go o a)\n    | .mdata k b => .mdata k (go o b)\n    | .proj s i b => .proj s i (go o b)\n    | .forallE n d b bi => .forallE n (go o d) (go (o+1) b) bi\n    | .lam n d b bi => .lam n (go o d) (go (o+1) b) bi\n    | .letE n t v b nd => .letE n (go o t) (go o v) (go (o+1) b) nd", "start": [19, 1], "end": [31, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToExpr.ToExprM", "code": "abbrev ToExprM := ReaderT Nat $ StateM LevelMap", "start": [33, 1], "end": [33, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToExpr.mkLambdaM", "code": "abbrev mkLambdaM (params : Array Param) (e : Expr) : ToExprM Expr :=\n  return go (\u2190 read) (\u2190 get) params.size e\nwhere\n  go (offset : Nat) (m : LevelMap) (i : Nat) (e : Expr) : Expr :=\n   if i > 0 then\n     let param  := params[i-1]!\n     let domain := param.type.abstract' (offset - 1) m\n     go (offset - 1) m (i - 1) (.lam param.binderName domain e .default)\n   else\n     e", "start": [35, 1], "end": [44, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.toExprM", "code": "private abbrev _root_.Lean.FVarId.toExprM (fvarId : FVarId) : ToExprM Expr :=\n  return fvarId.toExpr (\u2190 read) (\u2190 get)", "start": [46, 1], "end": [47, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToExpr.abstractM", "code": "abbrev abstractM (e : Expr) : ToExprM Expr :=\n  return e.abstract' (\u2190 read) (\u2190 get)", "start": [49, 1], "end": [50, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToExpr.withFVar", "code": "@[inline] def withFVar (fvarId : FVarId) (k : ToExprM \u03b1) : ToExprM \u03b1 := do\n  let offset \u2190 read\n  modify fun s => s.insert fvarId offset\n  withReader (\u00b7+1) k", "start": [52, 1], "end": [55, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToExpr.withParams", "code": "@[inline] partial def withParams (params : Array Param) (k : ToExprM \u03b1) : ToExprM \u03b1 :=\n  go 0\nwhere\n  @[specialize] go (i : Nat) : ToExprM \u03b1 := do\n    if h : i < params.size then\n      withFVar params[i].fvarId (go (i+1))\n    else\n      k", "start": [57, 1], "end": [64, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToExpr.run", "code": "@[inline] def run (x : ToExprM \u03b1) (offset : Nat := 0) (levelMap : LevelMap := {}) : \u03b1 :=\n  x |>.run offset |>.run' levelMap", "start": [66, 1], "end": [67, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToExpr.run'", "code": "@[inline] def run' (x : ToExprM \u03b1) (xs : Array FVarId) : \u03b1 :=\n  let map := xs.foldl (init := {}) fun map x => map.insert x map.size\n  run x xs.size map", "start": [69, 1], "end": [71, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.toExprM", "code": "private def Arg.toExprM (arg : Arg) : ToExprM Expr :=\n  return arg.toExpr.abstract' (\u2190 read) (\u2190 get)", "start": [77, 1], "end": [78, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.toExprM", "code": "partial def FunDeclCore.toExprM (decl : FunDecl) : ToExprM Expr :=\n  withParams decl.params do mkLambdaM decl.params (\u2190 decl.value.toExprM)", "start": [81, 1], "end": [82, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.toExprM", "code": "partial def Code.toExprM (code : Code) : ToExprM Expr := do\n  match code with\n  | .let decl k =>\n    let type \u2190 abstractM decl.type\n    let value \u2190 abstractM decl.value.toExpr\n    let body \u2190 withFVar decl.fvarId k.toExprM\n    return .letE decl.binderName type value body true\n  | .fun decl k | .jp decl k =>\n    let type \u2190 abstractM decl.type\n    let value \u2190 decl.toExprM\n    let body \u2190 withFVar decl.fvarId k.toExprM\n    return .letE decl.binderName type value body true\n  | .return fvarId => fvarId.toExprM\n  | .jmp fvarId args => return mkAppN (\u2190 fvarId.toExprM) (\u2190 args.mapM Arg.toExprM)\n  | .unreach type => return mkApp (mkConst ``lcUnreachable) (\u2190 abstractM type)\n  | .cases c =>\n    let alts \u2190 c.alts.mapM fun\n      | .alt _ params k => withParams params do mkLambdaM params (\u2190 k.toExprM)\n      | .default k => k.toExprM\n    return mkAppN (mkConst `cases) (#[\u2190 c.discr.toExprM] ++ alts)", "start": [84, 1], "end": [103, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.toExpr", "code": "def Code.toExpr (code : Code) (xs : Array FVarId := #[]) : Expr :=\n  run' code.toExprM xs", "start": [106, 1], "end": [107, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.toExpr", "code": "def FunDeclCore.toExpr (decl : FunDecl) (xs : Array FVarId := #[]) : Expr :=\n  run' decl.toExprM xs", "start": [109, 1], "end": [110, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.toExpr", "code": "def Decl.toExpr (decl : Decl) : Expr :=\n  run do withParams decl.params do mkLambdaM decl.params (\u2190 decl.value.toExprM)", "start": [112, 1], "end": [113, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PullFunDecls.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/DependsOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.PullFunDecls.ToPull", "code": "structure ToPull where\n  isFun : Bool\n  decl  : FunDecl\n  used  : FVarIdSet\n  deriving Inhabited", "start": [13, 1], "end": [20, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.PullM", "code": "abbrev PullM := StateRefT (List ToPull) CompilerM", "start": [22, 1], "end": [25, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.findFVarDirectDeps", "code": "def findFVarDirectDeps (fvarId : FVarId) : PullM (List ToPull) := do\n  let s \u2190 get\n  unless s.any fun info => info.used.contains fvarId do\n    return []\n  let (s\u2081, s\u2082) \u2190  go s [] []\n  set s\u2081\n  return s\u2082\nwhere\n  go (as keep dep : List ToPull) : CoreM (List ToPull \u00d7 List ToPull) := do\n    match as with\n    | [] => return (keep, dep)\n    | a :: as =>\n      if a.used.contains fvarId then\n        go as keep (a :: dep)\n      else\n        go as (a :: keep) dep", "start": [27, 1], "end": [47, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.findFVarDepsFixpoint", "code": "partial def findFVarDepsFixpoint (todo : List ToPull) (acc : Array ToPull := #[]) : PullM (Array ToPull) := do\n  match todo with\n  | [] => return acc\n  | p :: ps =>\n    let psNew \u2190 findFVarDirectDeps p.decl.fvarId\n    findFVarDepsFixpoint (psNew ++ ps) (acc.push p)", "start": [49, 1], "end": [54, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.findFVarDeps", "code": "partial def findFVarDeps (fvarId : FVarId) : PullM (Array ToPull) := do\n  let ps \u2190 findFVarDirectDeps fvarId\n  findFVarDepsFixpoint ps", "start": [56, 1], "end": [58, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.findParamsDeps", "code": "def findParamsDeps (params : Array Param) : PullM (Array ToPull) := do\n  let mut acc := #[]\n  for param in params do\n    acc := acc ++ (\u2190 findFVarDeps param.fvarId)\n  return acc", "start": [60, 1], "end": [68, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.ToPull.attach", "code": "def ToPull.attach (p : ToPull) (k : Code) : Code :=\n  if p.isFun then\n    .fun p.decl k\n  else\n    .jp p.decl k", "start": [70, 1], "end": [77, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.attach", "code": "partial def attach (ps : Array ToPull) (k : Code) : Code := Id.run do\n  let visited := ps.map fun _ => false\n  let (_, (k, _)) := go |>.run (k, visited)\n  return k\nwhere\n  go : StateM (Code \u00d7 Array Bool) Unit := do\n    for i in [:ps.size] do\n      visit i\n\n  visited (i : Nat) : StateM (Code \u00d7 Array Bool) Bool :=\n    return (\u2190 get).2[i]!\n\n  visit (i : Nat) : StateM (Code \u00d7 Array Bool) Unit := do\n    unless (\u2190 visited i) do\n      modify fun (k, visited) => (k, visited.set! i true)\n      let pi := ps[i]!\n      for j in [:ps.size] do\n        unless (\u2190 visited j) do\n          let pj := ps[j]!\n          if pj.used.contains pi.decl.fvarId then\n            visit j\n      modify fun (k, visited) => (pi.attach k, visited)", "start": [79, 1], "end": [103, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.attachFVarDeps", "code": "partial def attachFVarDeps (fvarId : FVarId) (k : Code) : PullM Code := do\n  let ps \u2190 findFVarDeps fvarId\n  return attach ps k", "start": [105, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.attachParamsDeps", "code": "def attachParamsDeps (params : Array Param) (k : Code) : PullM Code := do\n  let ps \u2190 findParamsDeps params\n  return attach ps k", "start": [113, 1], "end": [119, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.attachJps", "code": "def attachJps (k : Code) : PullM Code := do\n  let jps := (\u2190 get).filter fun info => !info.isFun\n  modify fun s => s.filter fun info => info.isFun\n  let jps \u2190 findFVarDepsFixpoint jps\n  return attach jps k", "start": [121, 1], "end": [125, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.addToPull", "code": "partial def addToPull (isFun : Bool) (decl : FunDecl) : PullM Unit := do\n  let saved \u2190 get\n  modify fun _ => []\n  let mut value \u2190 pull decl.value\n  value \u2190 attachParamsDeps decl.params value\n  if isFun then\n    \n    value \u2190 attachJps value\n  let decl \u2190 decl.update' decl.type value\n  modify fun s => { isFun, decl, used := decl.collectUsed } :: s ++ saved", "start": [128, 1], "end": [140, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullFunDecls.pull", "code": "partial def pull (code : Code) : PullM Code := do\n  match code with\n  | .let decl k =>\n    let k \u2190 pull k\n    let k \u2190 attachFVarDeps decl.fvarId k\n    return code.updateLet! decl k\n  | .fun decl k => addToPull true decl; pull k\n  | .jp decl k => addToPull false decl; pull k\n  | .cases c =>\n    let alts \u2190 c.alts.mapMonoM fun alt => do\n      match alt with\n      | .default k => return alt.updateCode (\u2190 pull k)\n      | .alt _ ps k =>\n        let k \u2190 pull k\n        let k \u2190 attachParamsDeps ps k\n        return alt.updateCode k\n    return code.updateAlts! alts\n  | .return .. | .unreach .. | .jmp .. => return code", "start": [142, 1], "end": [163, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.pullFunDecls", "code": "def Decl.pullFunDecls (decl : Decl) : CompilerM Decl := do\n  let (value, ps) \u2190 pull decl.value |>.run []\n  let value := attach ps.toArray value\n  return { decl with value }", "start": [170, 1], "end": [176, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.pullFunDecls", "code": "def pullFunDecls : Pass :=\n  .mkPerDeclaration `pullFunDecls Decl.pullFunDecls .base", "start": [178, 1], "end": [179, 58], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ScopeM.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.ScopeM", "code": "abbrev ScopeM := StateRefT FVarIdSet CompilerM", "start": [10, 1], "end": [13, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ScopeM.getScope", "code": "def getScope : ScopeM FVarIdSet := get", "start": [17, 1], "end": [17, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ScopeM.setScope", "code": "def setScope (newScope : FVarIdSet) : ScopeM Unit := set newScope", "start": [18, 1], "end": [18, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ScopeM.clearScope", "code": "def clearScope : ScopeM Unit := setScope {}", "start": [19, 1], "end": [19, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ScopeM.withBackTrackingScope", "code": "def withBackTrackingScope [MonadLiftT ScopeM m] [Monad m] [MonadFinally m] (x : m \u03b1) : m \u03b1 := do\n  let scope \u2190 getScope\n  try x finally setScope scope", "start": [21, 1], "end": [26, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ScopeM.withNewScope", "code": "def withNewScope [MonadLiftT ScopeM m] [Monad m] [MonadFinally m] (x : m \u03b1) : m \u03b1 := do\n  withBackTrackingScope do\n    clearScope\n    x", "start": [28, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ScopeM.isInScope", "code": "def isInScope (fvarId : FVarId) : ScopeM Bool := do\n  let scope \u2190 getScope\n  return scope.contains fvarId", "start": [37, 1], "end": [43, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ScopeM.addToScope", "code": "def addToScope (fvarId : FVarId) : ScopeM Unit :=\n  modify fun scope => scope.insert fvarId", "start": [45, 1], "end": [49, 42], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/TerminationHint.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.WF.TerminationHintValue", "code": "structure TerminationHintValue where\n  ref   : Syntax\n  value : Syntax\n  deriving Inhabited", "start": [12, 1], "end": [15, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationHint", "code": "inductive TerminationHint where\n  | none\n  | one (val : TerminationHintValue)\n  | many (map : NameMap TerminationHintValue)\n  deriving Inhabited", "start": [17, 1], "end": [21, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.expandTerminationHint", "code": "def expandTerminationHint (terminationHint? : Option Syntax) (cliques : Array (Array Name)) : MacroM TerminationHint := do\n  if let some terminationHint := terminationHint? then\n    let ref := terminationHint\n    let terminationHint := terminationHint[1]\n    if terminationHint.getKind == ``Parser.Command.terminationHint1 then\n      return TerminationHint.one { ref, value := terminationHint[0] }\n    else if terminationHint.getKind == ``Parser.Command.terminationHintMany then\n      let m \u2190 terminationHint[0].getArgs.foldlM (init := {}) fun m arg =>\n        let declName? := cliques.findSome? fun clique => clique.findSome? fun declName =>\n          if arg[0].getId.isSuffixOf declName then some declName else none\n        match declName? with\n        | none => Macro.throwErrorAt arg[0] s!\"function '{arg[0].getId}' not found in current declaration\"\n        | some declName => return m.insert declName { ref := arg, value := arg[2] }\n      for clique in cliques do\n        let mut found? := Option.none\n        for declName in clique do\n          if let some { ref, .. } := m.find? declName then\n            if let some found := found? then\n              Macro.throwErrorAt ref s!\"invalid termination hint element, '{declName}' and '{found}' are in the same clique\"\n            found? := some declName\n      return TerminationHint.many m\n    else\n      Macro.throwUnsupported\n  else\n    return TerminationHint.none", "start": [23, 1], "end": [47, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationHint.markAsUsed", "code": "def TerminationHint.markAsUsed (t : TerminationHint) (clique : Array Name) : TerminationHint :=\n  match t with\n  | TerminationHint.none   => TerminationHint.none\n  | TerminationHint.one .. => TerminationHint.none\n  | TerminationHint.many m => Id.run do\n    for declName in clique do\n      if m.contains declName then\n        let m := m.erase declName\n        let m := m.erase declName\n        if m.isEmpty then\n          return TerminationHint.none\n        else\n          return TerminationHint.many m\n    return t", "start": [49, 1], "end": [62, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationHint.find?", "code": "def TerminationHint.find? (t : TerminationHint) (clique : Array Name) : Option TerminationHintValue :=\n  match t with\n  | TerminationHint.none   => Option.none\n  | TerminationHint.one v  => some v\n  | TerminationHint.many m => clique.findSome? m.find?", "start": [64, 1], "end": [68, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationHint.ensureAllUsed", "code": "def TerminationHint.ensureAllUsed (t : TerminationHint) : MacroM Unit := do\n  match t with\n  | TerminationHint.one v   => Macro.throwErrorAt v.ref \"unused termination hint element\"\n  | TerminationHint.many m  => m.forM fun _ v => Macro.throwErrorAt v.ref \"unused termination hint element\"\n  | _ => pure ()", "start": [70, 1], "end": [74, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationByElement", "code": "structure TerminationByElement where\n  ref       : Syntax\n  declName  : Name\n  vars      : Array Syntax\n  body      : Syntax\n  implicit  : Bool\n  deriving Inhabited", "start": [78, 1], "end": [84, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationByClique", "code": "structure TerminationByClique where\n  elements : Array TerminationByElement\n  used     : Bool := false", "start": [86, 1], "end": [88, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationBy", "code": "inductive TerminationBy where\n  | core (hint : TerminationHint)\n  | ext  (cliques : Array TerminationByClique)\n  deriving Inhabited", "start": [90, 1], "end": [93, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationWF", "code": "inductive TerminationWF where\n  | core (stx : Syntax)\n  | ext  (clique : Array TerminationByElement)", "start": [95, 1], "end": [97, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.expandTerminationByNonCore", "code": "private def expandTerminationByNonCore (hint : Syntax) (cliques : Array (Array Name)) : MacroM TerminationBy := do\n  let elementStxs := hint[1].getArgs\n  let mut alreadyFound : NameSet := {}\n  let mut elseElemStx? := none\n  for elementStx in elementStxs do\n    let declStx := elementStx[0]\n    if declStx.isIdent then\n      let declSuffix := declStx.getId\n      if alreadyFound.contains declSuffix then\n        withRef elementStx <| Macro.throwError s!\"invalid `termination_by` syntax, `{declSuffix}` case has already been provided\"\n      alreadyFound := alreadyFound.insert declSuffix\n      if cliques.all fun clique => clique.all fun declName => !declSuffix.isSuffixOf declName then\n        withRef elementStx <| Macro.throwError s!\"function '{declSuffix}' not found in current declaration\"\n    else if elseElemStx?.isSome then\n      withRef elementStx <| Macro.throwError \"invalid `termination_by` syntax, the else-case (i.e., `_ ... => ...`) has already been specified\"\n    else\n      elseElemStx? := some elementStx\n  let toElement (declName : Name) (elementStx : Syntax) : TerminationByElement :=\n    let vars     := elementStx[1].getArgs\n    let implicit := !elementStx[0].isIdent\n    let body     := elementStx[3]\n    { ref := elementStx, declName, vars, implicit, body }\n  let mut result := #[]\n  let mut usedElse := false\n  for clique in cliques do\n    let mut elements := #[]\n    for declName in clique do\n      if let some elementStx := elementStxs.find? fun elementStx => elementStx[0].isIdent && elementStx[0].getId.isSuffixOf declName then\n        elements := elements.push (toElement declName elementStx)\n      else if let some elseElemStx := elseElemStx? then\n        elements := elements.push (toElement declName elseElemStx)\n        usedElse := true\n    unless elements.isEmpty do\n      if let some missing := clique.find? fun declName => elements.find? (\u00b7.declName == declName) |>.isNone then\n        withRef elements[0]!.ref <| Macro.throwError s!\"invalid `termination_by` syntax, missing case for function '{missing}'\"\n      result := result.push { elements }\n  if !usedElse && elseElemStx?.isSome then\n    withRef elseElemStx?.get! <| Macro.throwError s!\"invalid `termination_by` syntax, unnecessary else-case\"\n  return TerminationBy.ext result", "start": [105, 1], "end": [143, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.expandTerminationBy", "code": "def expandTerminationBy (hint? : Option Syntax) (cliques : Array (Array Name)) : MacroM TerminationBy :=\n  if let some hint := hint? then\n    if hint.isOfKind ``Parser.Command.terminationByCore then\n      return TerminationBy.core (\u2190 expandTerminationHint hint? cliques)\n    else if hint.isOfKind ``Parser.Command.terminationBy then\n      expandTerminationByNonCore hint cliques\n    else\n      Macro.throwUnsupported\n  else\n      return TerminationBy.core TerminationHint.none", "start": [145, 1], "end": [154, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationBy.markAsUsed", "code": "def TerminationBy.markAsUsed (t : TerminationBy) (cliqueNames : Array Name) : TerminationBy :=\n  match t with\n  | core hint   => core (hint.markAsUsed cliqueNames)\n  | ext cliques => ext <| cliques.map fun clique =>\n    if cliqueNames.any fun name => clique.elements.any fun elem => elem.declName == name then\n      { clique with used := true }\n    else\n      clique", "start": [156, 1], "end": [163, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationBy.find?", "code": "def TerminationBy.find? (t : TerminationBy) (cliqueNames : Array Name) : Option TerminationWF :=\n  match t with\n  | core hint => hint.find? cliqueNames |>.map fun v => TerminationWF.core v.value\n  | ext cliques =>\n    cliques.findSome? fun clique =>\n      if cliqueNames.any fun name => clique.elements.any fun elem => elem.declName == name then\n        some <| TerminationWF.ext clique.elements\n      else\n        none", "start": [165, 1], "end": [173, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationByClique.allImplicit", "code": "def TerminationByClique.allImplicit (c : TerminationByClique) : Bool :=\n  c.elements.all fun elem => elem.implicit", "start": [175, 1], "end": [176, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationByClique.getExplicitElement?", "code": "def TerminationByClique.getExplicitElement? (c : TerminationByClique) : Option TerminationByElement :=\n  c.elements.find? (!\u00b7.implicit)", "start": [178, 1], "end": [179, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.TerminationBy.ensureAllUsed", "code": "def TerminationBy.ensureAllUsed (t : TerminationBy) : MacroM Unit :=\n  match t with\n  | core hint => hint.ensureAllUsed\n  | ext cliques => do\n    let hasUsedAllImplicit := cliques.any fun c => c.allImplicit && c.used\n    let mut reportedAllImplicit := true\n    for clique in cliques do\n      unless clique.used do\n        if let some explicitElem := clique.getExplicitElement? then\n          Macro.throwErrorAt explicitElem.ref \"unused termination hint element\"\n        else if !hasUsedAllImplicit then\n          unless reportedAllImplicit do\n            reportedAllImplicit := true\n            Macro.throwErrorAt clique.elements[0]!.ref \"unused termination hint element\"", "start": [181, 1], "end": [194, 89], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/BRecOn.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/Match.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/CasesOn.lean", "lake-packages/lean4/src/lean/Lean/Elab/RecAppSyntax.lean", "lake-packages/lean4/src/lean/Lean/Util/HasConstCache.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Structural.throwToBelowFailed", "code": "private def throwToBelowFailed : MetaM \u03b1 :=\n  throwError \"toBelow failed\"", "start": [16, 1], "end": [17, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.toBelowAux", "code": "private partial def toBelowAux (C : Expr) (belowDict : Expr) (arg : Expr) (F : Expr) : MetaM Expr := do\n  let belowDict \u2190 whnf belowDict\n  trace[Elab.definition.structural] \"belowDict: {belowDict}, arg: {arg}\"\n  match belowDict with\n  | .app (.app (.const `PProd _) d1) d2 =>\n    (do toBelowAux C d1 arg (\u2190 mkAppM `PProd.fst #[F]))\n    <|>\n    (do toBelowAux C d2 arg (\u2190 mkAppM `PProd.snd #[F]))\n  | .app (.app (.const `And _) d1) d2 =>\n    (do toBelowAux C d1 arg (\u2190 mkAppM `And.left #[F]))\n    <|>\n    (do toBelowAux C d2 arg (\u2190 mkAppM `And.right #[F]))\n  | _ => forallTelescopeReducing belowDict fun xs belowDict => do\n    let arg \u2190 zetaReduce arg\n    let argArgs := arg.getAppArgs\n    unless argArgs.size >= xs.size do throwToBelowFailed\n    let n := argArgs.size\n    let argTailArgs := argArgs.extract (n - xs.size) n\n    let belowDict := belowDict.replaceFVars xs argTailArgs\n    match belowDict with\n    | .app belowDictFun belowDictArg =>\n      unless belowDictFun.getAppFn == C do throwToBelowFailed\n      unless \u2190 isDefEq belowDictArg arg do throwToBelowFailed\n      pure (mkAppN F argTailArgs)\n    | _ => throwToBelowFailed", "start": [19, 1], "end": [44, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.withBelowDict", "code": "private def withBelowDict (below : Expr) (numIndParams : Nat) (k : Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  let belowType \u2190 inferType below\n  trace[Elab.definition.structural] \"belowType: {belowType}\"\n  belowType.withApp fun f args => do\n    let motivePos := numIndParams + 1\n    unless motivePos < args.size do throwError \"unexpected 'below' type{indentExpr belowType}\"\n    let pre := mkAppN f (args.extract 0 numIndParams)\n    let preType \u2190 inferType pre\n    forallBoundedTelescope preType (some 1) fun x _ => do\n      let motiveType \u2190 inferType x[0]!\n      withLocalDeclD (\u2190 mkFreshUserName `C) motiveType fun C =>\n        let belowDict := mkApp pre C\n        let belowDict := mkAppN belowDict (args.extract (numIndParams + 1) args.size)\n        k C belowDict", "start": [46, 1], "end": [60, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.toBelow", "code": "private partial def toBelow (below : Expr) (numIndParams : Nat) (recArg : Expr) : MetaM Expr := do\n  withBelowDict below numIndParams fun C belowDict =>\n    toBelowAux C belowDict recArg below", "start": [62, 1], "end": [84, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.refinedArgType", "code": "def refinedArgType (matcherApp : MatcherApp) (arg : Expr) : MetaM Bool := do\n  let argType \u2190 inferType arg\n  (Array.zip matcherApp.alts matcherApp.altNumParams).anyM fun (alt, numParams) =>\n    lambdaTelescope alt fun xs _ => do\n      if xs.size >= numParams then\n        let refinedArg := xs[numParams - 1]!\n        return !(\u2190 isDefEq (\u2190 inferType refinedArg) argType)\n      else\n        return false", "start": [86, 1], "end": [98, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.replaceRecApps", "code": "private partial def replaceRecApps (recFnName : Name) (recArgInfo : RecArgInfo) (below : Expr) (e : Expr) : M Expr :=\n  let containsRecFn (e : Expr) : StateRefT (HasConstCache recFnName) M Bool :=\n    modifyGet (\u00b7.contains e)\n  let rec loop (below : Expr) (e : Expr) : StateRefT (HasConstCache recFnName) M Expr := do\n    if !(\u2190 containsRecFn e) then\n      return e\n    match e with\n    | Expr.lam n d b c =>\n      withLocalDecl n c (\u2190 loop below d) fun x => do\n        mkLambdaFVars #[x] (\u2190 loop below (b.instantiate1 x))\n    | Expr.forallE n d b c =>\n      withLocalDecl n c (\u2190 loop below d) fun x => do\n        mkForallFVars #[x] (\u2190 loop below (b.instantiate1 x))\n    | Expr.letE n type val body _ =>\n      withLetDecl n (\u2190 loop below type) (\u2190 loop below val) fun x => do\n        mkLetFVars #[x] (\u2190 loop below (body.instantiate1 x)) (usedLetOnly := false)\n    | Expr.mdata d b     =>\n      if let some _ := getRecAppSyntax? e then\n        loop below b\n      else\n        return mkMData d (\u2190 loop below b)\n    | Expr.proj n i e    => return mkProj n i (\u2190 loop below e)\n    | Expr.app _ _ =>\n      let processApp (e : Expr) : StateRefT (HasConstCache recFnName) M Expr :=\n        e.withApp fun f args => do\n          if f.isConstOf recFnName then\n            let numFixed  := recArgInfo.fixedParams.size\n            let recArgPos := recArgInfo.fixedParams.size + recArgInfo.pos\n            if recArgPos >= args.size then\n              throwError \"insufficient number of parameters at recursive application {indentExpr e}\"\n            let recArg := args[recArgPos]!\n            let recArg \u2190 loop below recArg\n            let f \u2190 try toBelow below recArgInfo.indParams.size recArg catch  _ => throwError \"failed to eliminate recursive application{indentExpr e}\"\n            let argsNonFixed := args.extract numFixed args.size\n            let mut fArgs := #[]\n            for i in [:argsNonFixed.size] do\n              if recArgInfo.pos != i && !recArgInfo.indicesPos.contains i then\n                let arg := argsNonFixed[i]!\n                let arg \u2190 replaceRecApps recFnName recArgInfo below arg\n                fArgs := fArgs.push arg\n            return mkAppN f fArgs\n          else\n            return mkAppN (\u2190 loop below f) (\u2190 args.mapM (loop below))\n      match (\u2190 matchMatcherApp? e) with\n      | some matcherApp =>\n        if !recArgHasLooseBVarsAt recFnName recArgInfo.recArgPos e then\n          processApp e\n        else\n          \n          trace[Elab.definition.structural] \"below before matcherApp.addArg: {below} : {\u2190 inferType below}\"\n          let matcherApp \u2190 mapError (matcherApp.addArg below) (fun msg => \"failed to add `below` argument to 'matcher' application\" ++ indentD msg)\n          if !(\u2190 refinedArgType matcherApp below) then\n            processApp e\n          else\n            let altsNew \u2190 (Array.zip matcherApp.alts matcherApp.altNumParams).mapM fun (alt, numParams) =>\n              lambdaTelescope alt fun xs altBody => do\n                trace[Elab.definition.structural] \"altNumParams: {numParams}, xs: {xs}\"\n                unless xs.size >= numParams do\n                  throwError \"unexpected matcher application alternative{indentExpr alt}\\nat application{indentExpr e}\"\n                let belowForAlt := xs[numParams - 1]!\n                mkLambdaFVars xs (\u2190 loop belowForAlt altBody)\n            pure { matcherApp with alts := altsNew }.toExpr\n      | none =>\n      match (\u2190 toCasesOnApp? e) with\n      | some casesOnApp =>\n        if !recArgHasLooseBVarsAt recFnName recArgInfo.recArgPos e then\n          processApp e\n        else if let some casesOnApp \u2190 casesOnApp.addArg? below (checkIfRefined := true) then\n          let altsNew \u2190 (Array.zip casesOnApp.alts casesOnApp.altNumParams).mapM fun (alt, numParams) =>\n            lambdaTelescope alt fun xs altBody => do\n              unless xs.size >= numParams do\n                throwError \"unexpected `casesOn` application alternative{indentExpr alt}\\nat application{indentExpr e}\"\n              let belowForAlt := xs[numParams]!\n              mkLambdaFVars xs (\u2190 loop belowForAlt altBody)\n          return { casesOnApp with alts := altsNew }.toExpr\n        else\n          processApp e\n      | none => processApp e\n    | e => ensureNoRecFn recFnName e\n  loop below e |>.run' {}", "start": [100, 1], "end": [197, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.mkBRecOn", "code": "def mkBRecOn (recFnName : Name) (recArgInfo : RecArgInfo) (value : Expr) : M Expr := do\n  trace[Elab.definition.structural] \"mkBRecOn: {value}\"\n  let type  := (\u2190 inferType value).headBeta\n  let major := recArgInfo.ys[recArgInfo.pos]!\n  let otherArgs := recArgInfo.ys.filter fun y => y != major && !recArgInfo.indIndices.contains y\n  trace[Elab.definition.structural] \"fixedParams: {recArgInfo.fixedParams}, otherArgs: {otherArgs}\"\n  let motive \u2190 mkForallFVars otherArgs type\n  let mut brecOnUniv \u2190 getLevel motive\n  trace[Elab.definition.structural] \"brecOn univ: {brecOnUniv}\"\n  let useBInductionOn := recArgInfo.reflexive && brecOnUniv == levelZero\n  if recArgInfo.reflexive && brecOnUniv != levelZero then\n    brecOnUniv \u2190 decLevel brecOnUniv\n  let motive \u2190 mkLambdaFVars (recArgInfo.indIndices.push major) motive\n  trace[Elab.definition.structural] \"brecOn motive: {motive}\"\n  let brecOn :=\n    if useBInductionOn then\n      Lean.mkConst (mkBInductionOnName recArgInfo.indName) recArgInfo.indLevels\n    else\n      Lean.mkConst (mkBRecOnName recArgInfo.indName) (brecOnUniv :: recArgInfo.indLevels)\n  let brecOn := mkAppN brecOn recArgInfo.indParams\n  let brecOn := mkApp brecOn motive\n  let brecOn := mkAppN brecOn recArgInfo.indIndices\n  let brecOn := mkApp brecOn major\n  check brecOn\n  let brecOnType \u2190 inferType brecOn\n  trace[Elab.definition.structural] \"brecOn     {brecOn}\"\n  trace[Elab.definition.structural] \"brecOnType {brecOnType}\"\n  forallBoundedTelescope brecOnType (some 1) fun F _ => do\n    let F := F[0]!\n    let FType \u2190 inferType F\n    trace[Elab.definition.structural] \"FType: {FType}\"\n    let FType \u2190 instantiateForall FType recArgInfo.indIndices\n    let FType \u2190 instantiateForall FType #[major]\n    forallBoundedTelescope FType (some 1) fun below _ => do\n      let below := below[0]!\n      let valueNew     \u2190 replaceRecApps recFnName recArgInfo below value\n      let Farg         \u2190 mkLambdaFVars (recArgInfo.indIndices ++ #[major, below] ++ otherArgs) valueNew\n      let brecOn       := mkApp brecOn Farg\n      return mkAppN brecOn otherArgs", "start": [199, 1], "end": [239, 37], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Eqns.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Split.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Eqns.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eqns.lean"], "premises": [{"full_name": "Lean.Elab.Structural.EqnInfo", "code": "structure EqnInfo extends EqnInfoCore where\n  recArgPos   : Nat\n  deriving Inhabited", "start": [20, 1], "end": [22, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.mkProof", "code": "private partial def mkProof (declName : Name) (type : Expr) : MetaM Expr := do\n  trace[Elab.definition.structural.eqns] \"proving: {type}\"\n  withNewMCtxDepth do\n    let main \u2190 mkFreshExprSyntheticOpaqueMVar type\n    let (_, mvarId) \u2190 main.mvarId!.intros\n    unless (\u2190 tryURefl mvarId) do go (\u2190 deltaLHS mvarId)\n    instantiateMVars main\nwhere\n  go (mvarId : MVarId) : MetaM Unit := do\n    trace[Elab.definition.structural.eqns] \"step\\n{MessageData.ofGoal mvarId}\"\n    if (\u2190 tryURefl mvarId) then\n      return ()\n    else if (\u2190 tryContradiction mvarId) then\n      return ()\n    else if let some mvarId \u2190 simpMatch? mvarId then\n      go mvarId\n    else if let some mvarId \u2190 simpIf? mvarId then\n      go mvarId\n    else if let some mvarId \u2190 whnfReducibleLHS? mvarId then\n      go mvarId\n    else match (\u2190 simpTargetStar mvarId {}).1 with\n      | TacticResultCNM.closed => return ()\n      | TacticResultCNM.modified mvarId => go mvarId\n      | TacticResultCNM.noChange =>\n        if let some mvarId \u2190 deltaRHS? mvarId declName then\n          go mvarId\n        else if let some mvarIds \u2190 casesOnStuckLHS? mvarId then\n          mvarIds.forM go\n        else if let some mvarIds \u2190 splitTarget? mvarId then\n          mvarIds.forM go\n        else\n          throwError \"failed to generate equational theorem for '{declName}'\\n{MessageData.ofGoal mvarId}\"", "start": [24, 1], "end": [56, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.mkEqns", "code": "def mkEqns (info : EqnInfo) : MetaM (Array Name) :=\n  withOptions (tactic.hygienic.set \u00b7 false) do\n  let eqnTypes \u2190 withNewMCtxDepth <| lambdaTelescope info.value fun xs body => do\n    let us := info.levelParams.map mkLevelParam\n    let target \u2190 mkEq (mkAppN (Lean.mkConst info.declName us) xs) body\n    let goal \u2190 mkFreshExprSyntheticOpaqueMVar target\n    mkEqnTypes #[info.declName] goal.mvarId!\n  let baseName := mkPrivateName (\u2190 getEnv) info.declName\n  let mut thmNames := #[]\n  for i in [: eqnTypes.size] do\n    let type := eqnTypes[i]!\n    trace[Elab.definition.structural.eqns] \"{eqnTypes[i]!}\"\n    let name := baseName ++ (`_eq).appendIndexAfter (i+1)\n    thmNames := thmNames.push name\n    let value \u2190 mkProof info.declName type\n    let (type, value) \u2190 removeUnusedEqnHypotheses type value\n    addDecl <| Declaration.thmDecl {\n      name, type, value\n      levelParams := info.levelParams\n    }\n  return thmNames", "start": [58, 1], "end": [78, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.registerEqnsInfo", "code": "def registerEqnsInfo (preDef : PreDefinition) (recArgPos : Nat) : CoreM Unit := do\n  modifyEnv fun env => eqnInfoExt.insert env preDef.declName { preDef with recArgPos }", "start": [82, 1], "end": [83, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.getEqnsFor?", "code": "def getEqnsFor? (declName : Name) : MetaM (Option (Array Name)) := do\n  if let some info := eqnInfoExt.find? (\u2190 getEnv) declName then\n    mkEqns info\n  else\n    return none", "start": [85, 1], "end": [89, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.getUnfoldFor?", "code": "def getUnfoldFor? (declName : Name) : MetaM (Option Name) := do\n  let env \u2190 getEnv\n  Eqns.getUnfoldFor? declName fun _ => eqnInfoExt.find? env declName |>.map (\u00b7.toEqnInfoCore)", "start": [91, 1], "end": [93, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.getStructuralRecArgPosImp?", "code": "@[export lean_get_structural_rec_arg_pos]\ndef getStructuralRecArgPosImp? (declName : Name) : CoreM (Option Nat) := do\n  let some info := eqnInfoExt.find? (\u2190 getEnv) declName | return none\n  return some info.recArgPos", "start": [95, 1], "end": [98, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/IndPred.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/IndPredBelow.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Structural.replaceIndPredRecApps", "code": "private partial def replaceIndPredRecApps (recFnName : Name) (recArgInfo : RecArgInfo) (motive : Expr) (e : Expr) : M Expr := do\n  let maxDepth := IndPredBelow.maxBackwardChainingDepth.get (\u2190 getOptions)\n  let rec loop (e : Expr) : M Expr := do\n    match e with\n    | Expr.lam n d b c =>\n      withLocalDecl n c (\u2190 loop d) fun x => do\n        mkLambdaFVars #[x] (\u2190 loop (b.instantiate1 x))\n    | Expr.forallE n d b c =>\n      withLocalDecl n c (\u2190 loop d) fun x => do\n        mkForallFVars #[x] (\u2190 loop (b.instantiate1 x))\n    | Expr.letE n type val body _ =>\n      withLetDecl n (\u2190 loop type) (\u2190 loop val) fun x => do\n        mkLetFVars #[x] (\u2190 loop (body.instantiate1 x))\n    | Expr.mdata d e     => return mkMData d (\u2190 loop e)\n    | Expr.proj n i e    => return mkProj n i (\u2190 loop e)\n    | Expr.app _ _ =>\n      let processApp (e : Expr) : M Expr := do\n        e.withApp fun f args => do\n          if f.isConstOf recFnName then\n            let ty \u2190 inferType e\n            let main \u2190 mkFreshExprSyntheticOpaqueMVar ty\n            if (\u2190 IndPredBelow.backwardsChaining main.mvarId! maxDepth) then\n              pure main\n            else\n              throwError \"could not solve using backwards chaining {MessageData.ofGoal main.mvarId!}\"\n          else\n            return mkAppN (\u2190 loop f) (\u2190 args.mapM loop)\n      match (\u2190 matchMatcherApp? e) with\n      | some matcherApp =>\n        if !recArgHasLooseBVarsAt recFnName recArgInfo.recArgPos e then\n          processApp e\n        else\n          trace[Elab.definition.structural] \"matcherApp before adding below transformation:\\n{matcherApp.toExpr}\"\n          let rec addBelow (matcherApp : MatcherApp) : M Expr := do\n            if let some (t, idx) \u2190 IndPredBelow.findBelowIdx matcherApp.discrs motive then\n              let (newApp, addMatcher) \u2190 IndPredBelow.mkBelowMatcher matcherApp motive t idx\n              modify fun s => { s with addMatchers := s.addMatchers.push addMatcher }\n              let some newApp \u2190 matchMatcherApp? newApp | throwError \"not a matcherApp: {newApp}\"\n              addBelow newApp\n            else pure matcherApp.toExpr\n\n          let newApp \u2190 addBelow matcherApp\n          if newApp == matcherApp.toExpr then\n            throwError \"could not add below discriminant\"\n          else\n            trace[Elab.definition.structural] \"modified matcher:\\n{newApp}\"\n            processApp newApp\n      | none => processApp e\n    | e => ensureNoRecFn recFnName e\n  loop e", "start": [13, 1], "end": [62, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.mkIndPredBRecOn", "code": "def mkIndPredBRecOn (recFnName : Name) (recArgInfo : RecArgInfo) (value : Expr) : M Expr := do\n  let type  := (\u2190 inferType value).headBeta\n  let major := recArgInfo.ys[recArgInfo.pos]!\n  let otherArgs := recArgInfo.ys.filter fun y => y != major && !recArgInfo.indIndices.contains y\n  trace[Elab.definition.structural] \"fixedParams: {recArgInfo.fixedParams}, otherArgs: {otherArgs}\"\n  let motive \u2190 mkForallFVars otherArgs type\n  let motive \u2190 mkLambdaFVars (recArgInfo.indIndices.push major) motive\n  trace[Elab.definition.structural] \"brecOn motive: {motive}\"\n  let brecOn := Lean.mkConst (mkBRecOnName recArgInfo.indName) recArgInfo.indLevels\n  let brecOn := mkAppN brecOn recArgInfo.indParams\n  let brecOn := mkApp brecOn motive\n  let brecOn := mkAppN brecOn recArgInfo.indIndices\n  let brecOn := mkApp brecOn major\n  check brecOn\n  let brecOnType \u2190 inferType brecOn\n  trace[Elab.definition.structural] \"brecOn     {brecOn}\"\n  trace[Elab.definition.structural] \"brecOnType {brecOnType}\"\n  let FType \u2190 forallBoundedTelescope brecOnType (some 1) fun F _ => do\n    let F := F[0]!\n    let FType \u2190 inferType F\n    trace[Elab.definition.structural] \"FType: {FType}\"\n    let FType \u2190 instantiateForall FType recArgInfo.indIndices\n    instantiateForall FType #[major]\n  forallBoundedTelescope FType (some 1) fun below _ => do\n    let below := below[0]!\n    let valueNew     \u2190 replaceIndPredRecApps recFnName recArgInfo motive value\n    let Farg         \u2190 mkLambdaFVars (recArgInfo.indIndices ++ #[major, below] ++ otherArgs) valueNew\n    let brecOn       := mkApp brecOn Farg\n    return mkAppN brecOn otherArgs", "start": [64, 1], "end": [97, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/SmartUnfolding.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Structural.addSmartUnfoldingDefAux", "code": "partial def addSmartUnfoldingDefAux (preDef : PreDefinition) (recArgPos : Nat) : MetaM PreDefinition := do\n  return { preDef with\n    declName  := mkSmartUnfoldingNameFor preDef.declName\n    value     := (\u2190 visit preDef.value)\n    modifiers := {}\n  }\nwhere\n  \n  visit (e : Expr) : MetaM Expr := do\n    match e with\n    | Expr.lam ..     => lambdaTelescope e fun xs b => do mkLambdaFVars xs (\u2190 visit b)\n    | Expr.forallE .. => forallTelescope e fun xs b => do mkForallFVars xs (\u2190 visit b)\n    | Expr.letE n type val body _ =>\n      withLetDecl n type (\u2190 visit val) fun x => do mkLetFVars #[x] (\u2190 visit (body.instantiate1 x))\n    | Expr.mdata d b     => return mkMData d (\u2190 visit b)\n    | Expr.proj n i s    => return mkProj n i (\u2190 visit s)\n    | Expr.app .. =>\n      let processApp (e : Expr) : MetaM Expr :=\n        e.withApp fun f args =>\n          return mkAppN (\u2190 visit f) (\u2190 args.mapM visit)\n      match (\u2190 matchMatcherApp? e) with\n      | some matcherApp =>\n        if !recArgHasLooseBVarsAt preDef.declName recArgPos e then\n          processApp e\n        else\n          let mut altsNew := #[]\n          for alt in matcherApp.alts, numParams in matcherApp.altNumParams do\n            let altNew \u2190 lambdaTelescope alt fun xs altBody => do\n              unless xs.size >= numParams do\n                throwError \"unexpected matcher application alternative{indentExpr alt}\\nat application{indentExpr e}\"\n              let altBody \u2190 visit altBody\n              let containsSUnfoldMatch := Option.isSome <| altBody.find? fun e => smartUnfoldingMatch? e |>.isSome\n              if !containsSUnfoldMatch then\n                let altBody \u2190 mkLambdaFVars xs[numParams:xs.size] altBody\n                let altBody := markSmartUnfoldingMatchAlt altBody\n                mkLambdaFVars xs[0:numParams] altBody\n              else\n                mkLambdaFVars xs altBody\n            altsNew := altsNew.push altNew\n          return markSmartUnfoldingMatch { matcherApp with alts := altsNew }.toExpr\n      | _ => processApp e\n    | _ => return e", "start": [12, 1], "end": [62, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.addSmartUnfoldingDef", "code": "partial def addSmartUnfoldingDef (preDef : PreDefinition) (recArgPos : Nat) : TermElabM Unit := do\n  if (\u2190 isProp preDef.type) then\n    return ()\n  else\n    withEnableInfoTree false do\n      let preDefSUnfold \u2190 addSmartUnfoldingDefAux preDef recArgPos\n      addNonRec preDefSUnfold", "start": [64, 1], "end": [70, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Preprocess.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Structural.shouldBetaReduce", "code": "private def shouldBetaReduce (e : Expr) (recFnName : Name) : Bool :=\n  if e.isHeadBetaTarget then\n    e.getAppFn.find? (\u00b7.isConstOf recFnName) |>.isSome\n  else\n    false", "start": [11, 1], "end": [15, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.preprocess", "code": "def preprocess (e : Expr) (recFnName : Name) : CoreM Expr :=\n  Core.transform e\n   fun e =>\n     if shouldBetaReduce e recFnName then\n       return .visit e.headBeta\n     else\n       return .continue", "start": [17, 1], "end": [33, 24], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/FindRecArg.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Structural.getIndexMinPos", "code": "private def getIndexMinPos (xs : Array Expr) (indices : Array Expr) : Nat := Id.run do\n  let mut minPos := xs.size\n  for index in indices do\n    match xs.indexOf? index with\n    | some pos => if pos.val < minPos then minPos := pos.val\n    | _        => pure ()\n  return minPos", "start": [11, 1], "end": [17, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.hasBadIndexDep?", "code": "private def hasBadIndexDep? (ys : Array Expr) (indices : Array Expr) : MetaM (Option (Expr \u00d7 Expr)) := do\n  for index in indices do\n    let indexType \u2190 inferType index\n    for y in ys do\n      if !indices.contains y && (\u2190 dependsOn indexType y.fvarId!) then\n        return some (index, y)\n  return none", "start": [20, 1], "end": [26, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.hasBadParamDep?", "code": "private def hasBadParamDep? (ys : Array Expr) (indParams : Array Expr) : MetaM (Option (Expr \u00d7 Expr)) := do\n  for p in indParams do\n    let pType \u2190 inferType p\n    for y in ys do\n      if \u2190 dependsOn pType y.fvarId! then\n        return some (p, y)\n  return none", "start": [29, 1], "end": [35, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.throwStructuralFailed", "code": "private def throwStructuralFailed : MetaM \u03b1 :=\n  throwError \"structural recursion cannot be used\"", "start": [37, 1], "end": [38, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.orelse'", "code": "private def orelse' (x y : M \u03b1) : M \u03b1 := do\n  let saveState \u2190 get\n  orelseMergeErrors x (do set saveState; y)", "start": [40, 1], "end": [42, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.findRecArg", "code": "partial def findRecArg (numFixed : Nat) (xs : Array Expr) (k : RecArgInfo \u2192 M \u03b1) : M \u03b1 := do\n  \n  let indicesRef : IO.Ref FVarIdSet \u2190 IO.mkRef {}\n  for x in xs do\n    let xType \u2190 inferType x\n    \n    forEachExpr xType fun e =>\n      \n      matchConstInduct e.getAppFn (fun _ => pure ()) fun info _ => do\n        if info.numIndices > 0 && info.numParams + info.numIndices == e.getAppNumArgs then\n          for arg in e.getAppArgs[info.numParams:] do\n            forEachExpr arg fun e => do\n              if e.isFVar && xs.any (\u00b7 == e) then\n                indicesRef.modify fun indices => indices.insert e.fvarId!\n  let indices \u2190 indicesRef.get\n  \n  let rec go (i : Nat) (firstPass : Bool) : M \u03b1 := do\n    if h : i < xs.size then\n      let x := xs.get \u27e8i, h\u27e9\n      trace[Elab.definition.structural] \"findRecArg x: {x}, firstPass: {firstPass}\"\n      let localDecl \u2190 getFVarLocalDecl x\n      if localDecl.isLet then\n        throwStructuralFailed\n      else if firstPass == indices.contains localDecl.fvarId then\n        go (i+1) firstPass\n      else\n        let xType \u2190 whnfD localDecl.type\n        matchConstInduct xType.getAppFn (fun _ => go (i+1) firstPass) fun indInfo us => do\n        if !(\u2190 hasConst (mkBRecOnName indInfo.name)) then\n          go (i+1) firstPass\n        else if indInfo.isReflexive && !(\u2190 hasConst (mkBInductionOnName indInfo.name)) && !(\u2190 isInductivePredicate indInfo.name) then\n          go (i+1) firstPass\n        else\n          let indArgs    := xType.getAppArgs\n          let indParams  := indArgs.extract 0 indInfo.numParams\n          let indIndices := indArgs.extract indInfo.numParams indArgs.size\n          if !indIndices.all Expr.isFVar then\n            orelse'\n              (throwError \"argument #{i+1} was not used because its type is an inductive family and indices are not variables{indentExpr xType}\")\n              (go (i+1) firstPass)\n          else if !indIndices.allDiff then\n            orelse'\n              (throwError \"argument #{i+1} was not used because its type is an inductive family and indices are not pairwise distinct{indentExpr xType}\")\n              (go (i+1) firstPass)\n          else\n            let indexMinPos := getIndexMinPos xs indIndices\n            let numFixed    := if indexMinPos < numFixed then indexMinPos else numFixed\n            let fixedParams := xs.extract 0 numFixed\n            let ys          := xs.extract numFixed xs.size\n            match (\u2190 hasBadIndexDep? ys indIndices) with\n            | some (index, y) =>\n              orelse'\n                (throwError \"argument #{i+1} was not used because its type is an inductive family{indentExpr xType}\\nand index{indentExpr index}\\ndepends on the non index{indentExpr y}\")\n                (go (i+1) firstPass)\n            | none =>\n              match (\u2190 hasBadParamDep? ys indParams) with\n              | some (indParam, y) =>\n                orelse'\n                  (throwError \"argument #{i+1} was not used because its type is an inductive datatype{indentExpr xType}\\nand parameter{indentExpr indParam}\\ndepends on{indentExpr y}\")\n                  (go (i+1) firstPass)\n              | none =>\n                let indicesPos := indIndices.map fun index => match ys.indexOf? index with | some i => i.val | none => unreachable!\n                orelse'\n                  (mapError\n                    (k { fixedParams := fixedParams\n                         ys          := ys\n                         pos         := i - fixedParams.size\n                         indicesPos  := indicesPos\n                         indName     := indInfo.name\n                         indLevels   := us\n                         indParams   := indParams\n                         indIndices  := indIndices\n                         reflexive := indInfo.isReflexive\n                         indPred := \u2190isInductivePredicate indInfo.name })\n                    (fun msg => m!\"argument #{i+1} was not used for structural recursion{indentD msg}\"))\n                  (go (i+1) firstPass)\n    else if firstPass then\n      go (i := numFixed) (firstPass := false)\n    else\n      throwStructuralFailed\n\n  go (i := numFixed) (firstPass := true)", "start": [44, 1], "end": [139, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Array/Lemmas.lean", "imports": ["lake-packages/std/Std/Tactic/Simpa.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/List/Lemmas.lean", "lake-packages/std/Std/Tactic/HaveI.lean"], "premises": [{"full_name": "getElem_fin", "code": "@[simp] theorem getElem_fin [GetElem Cont Nat Elem Dom] (a : Cont) (i : Fin n) (h : Dom a i) :\n    a[i] = a[i.1]", "start": [14, 1], "end": [15, 25], "kind": "commanddeclaration"}, {"full_name": "getElem?_fin", "code": "@[simp] theorem getElem?_fin [GetElem Cont Nat Elem Dom] (a : Cont) (i : Fin n)\n    [Decidable (Dom a i)] : a[i]? = a[i.1]?", "start": [17, 1], "end": [18, 51], "kind": "commanddeclaration"}, {"full_name": "getElem!_fin", "code": "@[simp] theorem getElem!_fin [GetElem Cont Nat Elem Dom] (a : Cont) (i : Fin n)\n    [Decidable (Dom a i)] [Inhabited Elem] : a[i]! = a[i.1]!", "start": [20, 1], "end": [21, 68], "kind": "commanddeclaration"}, {"full_name": "getElem?_pos", "code": "theorem getElem?_pos [GetElem Cont Idx Elem Dom]\n    (a : Cont) (i : Idx) (h : Dom a i) [Decidable (Dom a i)] : a[i]? = a[i]", "start": [23, 1], "end": [24, 89], "kind": "commanddeclaration"}, {"full_name": "getElem?_neg", "code": "theorem getElem?_neg [GetElem Cont Idx Elem Dom]\n    (a : Cont) (i : Idx) (h : \u00acDom a i) [Decidable (Dom a i)] : a[i]? = none", "start": [26, 1], "end": [27, 90], "kind": "commanddeclaration"}, {"full_name": "mkArray_data", "code": "@[simp] theorem mkArray_data (n : Nat) (v : \u03b1) : (mkArray n v).data = List.replicate n v", "start": [29, 1], "end": [29, 96], "kind": "commanddeclaration"}, {"full_name": "Array.singleton_def", "code": "@[simp] theorem singleton_def (v : \u03b1) : singleton v = #[v]", "start": [35, 1], "end": [35, 66], "kind": "commanddeclaration"}, {"full_name": "Array.toArray_data", "code": "@[simp] theorem toArray_data : (a : Array \u03b1) \u2192 a.data.toArray = a", "start": [37, 1], "end": [38, 33], "kind": "commanddeclaration"}, {"full_name": "Array.get_eq_getElem", "code": "@[simp] theorem get_eq_getElem (a : Array \u03b1) (i : Fin _) : a.get i = a[i.1]", "start": [40, 1], "end": [40, 83], "kind": "commanddeclaration"}, {"full_name": "Array.get?_eq_getElem?", "code": "@[simp] theorem get?_eq_getElem? (a : Array \u03b1) (i : Nat) : a.get? i = a[i]?", "start": [41, 1], "end": [41, 83], "kind": "commanddeclaration"}, {"full_name": "Array.getElem_fin_eq_data_get", "code": "theorem getElem_fin_eq_data_get (a : Array \u03b1) (i : Fin _) : a[i] = a.data.get i", "start": [42, 1], "end": [42, 87], "kind": "commanddeclaration"}, {"full_name": "Array.ugetElem_eq_getElem", "code": "@[simp] theorem ugetElem_eq_getElem (a : Array \u03b1) {i : USize} (h : i.toNat < a.size) :\n  a[i] = a[i.toNat]", "start": [44, 1], "end": [45, 27], "kind": "commanddeclaration"}, {"full_name": "Array.getElem?_eq_getElem", "code": "theorem getElem?_eq_getElem (a : Array \u03b1) (i : Nat) (h : i < a.size) : a[i]? = a[i]", "start": [47, 1], "end": [48, 18], "kind": "commanddeclaration"}, {"full_name": "Array.get?_len_le", "code": "theorem get?_len_le (a : Array \u03b1) (i : Nat) (h : a.size \u2264 i) : a[i]? = none", "start": [50, 1], "end": [51, 25], "kind": "commanddeclaration"}, {"full_name": "Array.getElem_mem_data", "code": "theorem getElem_mem_data (a : Array \u03b1) (h : i < a.size) : a[i] \u2208 a.data", "start": [53, 1], "end": [54, 43], "kind": "commanddeclaration"}, {"full_name": "Array.getElem?_eq_data_get?", "code": "theorem getElem?_eq_data_get? (a : Array \u03b1) (i : Nat) : a[i]? = a.data.get? i", "start": [56, 1], "end": [57, 96], "kind": "commanddeclaration"}, {"full_name": "Array.get?_eq_data_get?", "code": "theorem get?_eq_data_get? (a : Array \u03b1) (i : Nat) : a.get? i = a.data.get? i", "start": [59, 1], "end": [60, 27], "kind": "commanddeclaration"}, {"full_name": "Array.getD_eq_get?", "code": "@[simp] theorem getD_eq_get? (a : Array \u03b1) (n d) : a.getD n d = (a.get? n).getD d", "start": [62, 1], "end": [63, 36], "kind": "commanddeclaration"}, {"full_name": "Array.get!_eq_getD", "code": "theorem get!_eq_getD [Inhabited \u03b1] (a : Array \u03b1) : a.get! n = a.getD n default", "start": [65, 1], "end": [65, 86], "kind": "commanddeclaration"}, {"full_name": "Array.get!_eq_get?", "code": "@[simp] theorem get!_eq_get? [Inhabited \u03b1] (a : Array \u03b1) : a.get! n = (a.get? n).getD default", "start": [67, 1], "end": [68, 22], "kind": "commanddeclaration"}, {"full_name": "Array.back_eq_back?", "code": "@[simp] theorem back_eq_back? [Inhabited \u03b1] (a : Array \u03b1) : a.back = a.back?.getD default", "start": [70, 1], "end": [71, 21], "kind": "commanddeclaration"}, {"full_name": "Array.back?_push", "code": "@[simp] theorem back?_push (a : Array \u03b1) : (a.push x).back? = some x", "start": [73, 1], "end": [74, 38], "kind": "commanddeclaration"}, {"full_name": "Array.back_push", "code": "theorem back_push [Inhabited \u03b1] (a : Array \u03b1) : (a.push x).back = x", "start": [76, 1], "end": [76, 79], "kind": "commanddeclaration"}, {"full_name": "Array.get?_push_lt", "code": "theorem get?_push_lt (a : Array \u03b1) (x : \u03b1) (i : Nat) (h : i < a.size) :\n    (a.push x)[i]? = some a[i]", "start": [78, 1], "end": [80, 33], "kind": "commanddeclaration"}, {"full_name": "Array.get?_push_eq", "code": "theorem get?_push_eq (a : Array \u03b1) (x : \u03b1) : (a.push x)[a.size]? = some x", "start": [82, 1], "end": [83, 33], "kind": "commanddeclaration"}, {"full_name": "Array.data_set", "code": "@[simp] theorem data_set (a : Array \u03b1) (i v) : (a.set i v).data = a.data.set i.1 v", "start": [85, 1], "end": [85, 90], "kind": "commanddeclaration"}, {"full_name": "Array.get_set_eq", "code": "@[simp] theorem get_set_eq (a : Array \u03b1) (i : Fin a.size) (v : \u03b1) :\n    (a.set i v)[i.1]'(by simp [i.2]) = v", "start": [87, 1], "end": [89, 56], "kind": "commanddeclaration"}, {"full_name": "Array.get_set_ne", "code": "@[simp] theorem get_set_ne (a : Array \u03b1) (i : Fin a.size) {j : Nat} (v : \u03b1) (hj : j < a.size)\n    (h : i.1 \u2260 j) : (a.set i v)[j]'(by simp [*]) = a[j]", "start": [91, 1], "end": [93, 58], "kind": "commanddeclaration"}, {"full_name": "Array.get?_set_eq", "code": "@[simp] theorem get?_set_eq (a : Array \u03b1) (i : Fin a.size) (v : \u03b1) :\n    (a.set i v)[i.1]? = v", "start": [95, 1], "end": [96, 57], "kind": "commanddeclaration"}, {"full_name": "Array.get?_set_ne", "code": "@[simp] theorem get?_set_ne (a : Array \u03b1) (i : Fin a.size) {j : Nat} (v : \u03b1)\n    (h : i.1 \u2260 j) : (a.set i v)[j]? = a[j]?", "start": [98, 1], "end": [100, 63], "kind": "commanddeclaration"}, {"full_name": "Array.get?_set", "code": "theorem get?_set (a : Array \u03b1) (i : Fin a.size) (j : Nat) (v : \u03b1) :\n    (a.set i v)[j]? = if i.1 = j then some v else a[j]?", "start": [102, 1], "end": [104, 54], "kind": "commanddeclaration"}, {"full_name": "Array.get_set", "code": "theorem get_set (a : Array \u03b1) (i : Fin a.size) (j : Nat) (hj : j < a.size) (v : \u03b1) :\n    (a.set i v)[j]'(by simp [*]) = if i = j then v else a[j]", "start": [106, 1], "end": [108, 54], "kind": "commanddeclaration"}, {"full_name": "Array.set_set", "code": "theorem set_set (a : Array \u03b1) (i : Fin a.size) (v v' : \u03b1) :\n    (a.set i v).set \u27e8i, by simp [i.2]\u27e9 v' = a.set i v'", "start": [110, 1], "end": [111, 86], "kind": "commanddeclaration"}, {"full_name": "Array.fin_cast_val", "code": "private theorem fin_cast_val (e : n = n') (i : Fin n) : e \u25b8 i = \u27e8i.1, e \u25b8 i.2\u27e9", "start": [113, 1], "end": [113, 98], "kind": "commanddeclaration"}, {"full_name": "Array.swap_def", "code": "theorem swap_def (a : Array \u03b1) (i j : Fin a.size) :\n    a.swap i j = (a.set i (a.get j)).set \u27e8j.1, by simp [j.2]\u27e9 (a.get i)", "start": [115, 1], "end": [117, 28], "kind": "commanddeclaration"}, {"full_name": "Array.data_swap", "code": "theorem data_swap (a : Array \u03b1) (i j : Fin a.size) :\n    (a.swap i j).data = (a.data.set i (a.get j)).set j (a.get i)", "start": [119, 1], "end": [120, 87], "kind": "commanddeclaration"}, {"full_name": "Array.get?_swap", "code": "theorem get?_swap (a : Array \u03b1) (i j : Fin a.size) (k : Nat) : (a.swap i j)[k]? =\n    if j = k then some a[i.1] else if i = k then some a[j.1] else a[k]?", "start": [122, 1], "end": [124, 55], "kind": "commanddeclaration"}, {"full_name": "Array.swapAt_def", "code": "@[simp] theorem swapAt_def (a : Array \u03b1) (i : Fin a.size) (v : \u03b1) :\n    a.swapAt i v = (a[i.1], a.set i v)", "start": [126, 1], "end": [127, 46], "kind": "commanddeclaration"}, {"full_name": "Array.swapAt!_def", "code": "theorem swapAt!_def (a : Array \u03b1) (i : Nat) (v : \u03b1) (h : i < a.size) :\n    a.swapAt! i v = (a[i], a.set \u27e8i, h\u27e9 v)", "start": [130, 1], "end": [131, 67], "kind": "commanddeclaration"}, {"full_name": "Array.data_pop", "code": "@[simp] theorem data_pop (a : Array \u03b1) : a.pop.data = a.data.dropLast", "start": [133, 1], "end": [133, 87], "kind": "commanddeclaration"}, {"full_name": "Array.pop_empty", "code": "@[simp] theorem pop_empty : (#[] : Array \u03b1).pop = #[]", "start": [135, 1], "end": [135, 61], "kind": "commanddeclaration"}, {"full_name": "Array.pop_push", "code": "@[simp] theorem pop_push (a : Array \u03b1) : (a.push x).pop = a", "start": [137, 1], "end": [137, 77], "kind": "commanddeclaration"}, {"full_name": "Array.SatisfiesM_foldrM", "code": "theorem SatisfiesM_foldrM [Monad m] [LawfulMonad m]\n    {as : Array \u03b1} (motive : Nat \u2192 \u03b2 \u2192 Prop)\n    {init : \u03b2} (h0 : motive as.size init) {f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2}\n    (hf : \u2200 i : Fin as.size, \u2200 b, motive (i.1 + 1) b \u2192 SatisfiesM (motive i.1) (f as[i] b)) :\n    SatisfiesM (motive 0) (as.foldrM f init)", "start": [139, 1], "end": [153, 59], "kind": "commanddeclaration"}, {"full_name": "Array.foldr_induction", "code": "theorem foldr_induction\n    {as : Array \u03b1} (motive : Nat \u2192 \u03b2 \u2192 Prop) {init : \u03b2} (h0 : motive as.size init) {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2}\n    (hf : \u2200 i : Fin as.size, \u2200 b, motive (i.1 + 1) b \u2192 motive i.1 (f as[i] b)) :\n    motive 0 (as.foldr f init)", "start": [155, 1], "end": [161, 16], "kind": "commanddeclaration"}, {"full_name": "Array.mapM_eq_mapM_data", "code": "theorem mapM_eq_mapM_data [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 m \u03b2) (arr : Array \u03b1) :\n    arr.mapM f = return mk (\u2190 arr.data.mapM f)", "start": [163, 1], "end": [169, 60], "kind": "commanddeclaration"}, {"full_name": "Array.SatisfiesM_mapIdxM", "code": "theorem SatisfiesM_mapIdxM [Monad m] [LawfulMonad m] (as : Array \u03b1) (f : Fin as.size \u2192 \u03b1 \u2192 m \u03b2)\n    (motive : Nat \u2192 Prop) (h0 : motive 0)\n    (p : Fin as.size \u2192 \u03b2 \u2192 Prop)\n    (hs : \u2200 i, motive i.1 \u2192 SatisfiesM (p i \u00b7 \u2227 motive (i + 1)) (f i as[i])) :\n    SatisfiesM\n      (fun arr => motive as.size \u2227 \u2203 eq : arr.size = as.size, \u2200 i h, p \u27e8i, h\u27e9 (arr[i]'(eq \u25b8 h)))\n      (Array.mapIdxM as f)", "start": [171, 1], "end": [191, 41], "kind": "commanddeclaration"}, {"full_name": "Array.mapIdx_induction", "code": "theorem mapIdx_induction (as : Array \u03b1) (f : Fin as.size \u2192 \u03b1 \u2192 \u03b2)\n    (motive : Nat \u2192 Prop) (h0 : motive 0)\n    (p : Fin as.size \u2192 \u03b2 \u2192 Prop)\n    (hs : \u2200 i, motive i.1 \u2192 p i (f i as[i]) \u2227 motive (i + 1)) :\n    motive as.size \u2227 \u2203 eq : (Array.mapIdx as f).size = as.size,\n      \u2200 i h, p \u27e8i, h\u27e9 ((Array.mapIdx as f)[i]'(eq \u25b8 h))", "start": [193, 1], "end": [201, 18], "kind": "commanddeclaration"}, {"full_name": "Array.mapIdx_induction'", "code": "theorem mapIdx_induction' (as : Array \u03b1) (f : Fin as.size \u2192 \u03b1 \u2192 \u03b2)\n    (p : Fin as.size \u2192 \u03b2 \u2192 Prop) (hs : \u2200 i, p i (f i as[i])) :\n    \u2203 eq : (Array.mapIdx as f).size = as.size,\n      \u2200 i h, p \u27e8i, h\u27e9 ((Array.mapIdx as f)[i]'(eq \u25b8 h))", "start": [203, 1], "end": [207, 81], "kind": "commanddeclaration"}, {"full_name": "Array.size_mapIdx", "code": "@[simp] theorem size_mapIdx (a : Array \u03b1) (f : Fin a.size \u2192 \u03b1 \u2192 \u03b2) : (a.mapIdx f).size = a.size", "start": [209, 1], "end": [210, 72], "kind": "commanddeclaration"}, {"full_name": "Array.getElem_mapIdx", "code": "@[simp] theorem getElem_mapIdx (a : Array \u03b1) (f : Fin a.size \u2192 \u03b1 \u2192 \u03b2) (i : Nat) (h) :\n    haveI : i < a.size := by simp_all\n    (a.mapIdx f)[i]'h = f \u27e8i, this\u27e9 a[i]", "start": [212, 1], "end": [215, 71], "kind": "commanddeclaration"}, {"full_name": "Array.size_swap!", "code": "@[simp] theorem size_swap! (a : Array \u03b1) (i j) (hi : i < a.size) (hj : j < a.size) :\n    (a.swap! i j).size = a.size", "start": [217, 1], "end": [218, 59], "kind": "commanddeclaration"}, {"full_name": "Array.size_reverse", "code": "@[simp] theorem size_reverse (a : Array \u03b1) : a.reverse.size = a.size", "start": [220, 1], "end": [228, 26], "kind": "commanddeclaration"}, {"full_name": "Array.reverse_data", "code": "@[simp] theorem reverse_data (a : Array \u03b1) : a.reverse.data = a.data.reverse", "start": [230, 1], "end": [265, 26], "kind": "commanddeclaration"}, {"full_name": "Array.size_ofFn_go", "code": "@[simp] theorem size_ofFn_go {n} (f : Fin n \u2192 \u03b1) (i acc) :\n    (ofFn.go f i acc).size = acc.size + (n - i)", "start": [267, 1], "end": [278, 26], "kind": "commanddeclaration"}, {"full_name": "Array.size_ofFn", "code": "@[simp] theorem size_ofFn (f : Fin n \u2192 \u03b1) : (ofFn f).size = n", "start": [280, 1], "end": [280, 80], "kind": "commanddeclaration"}, {"full_name": "Array.getElem_ofFn_go", "code": "theorem getElem_ofFn_go (f : Fin n \u2192 \u03b1) (i) {acc k}\n    (hki : k < n) (hin : i \u2264 n) (hi : i = acc.size)\n    (hacc : \u2200 j, \u2200 hj : j < acc.size, acc[j] = f \u27e8j, Nat.lt_of_lt_of_le hj (hi \u25b8 hin)\u27e9) :\n    haveI : acc.size + (n - acc.size) = n := Nat.add_sub_cancel' (hi \u25b8 hin)\n    (ofFn.go f i acc)[k]'(by simp [*]) = f \u27e8k, hki\u27e9", "start": [282, 1], "end": [298, 26], "kind": "commanddeclaration"}, {"full_name": "Array.getElem_ofFn", "code": "@[simp] theorem getElem_ofFn (f : Fin n \u2192 \u03b1) (i : Nat) (h) :\n    (ofFn f)[i] = f \u27e8i, size_ofFn f \u25b8 h\u27e9", "start": [300, 1], "end": [302, 49], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/HashMap/Basic.lean", "imports": ["lake-packages/std/Std/Data/AssocList.lean", "lake-packages/std/Std/Classes/BEq.lean", "lake-packages/std/Std/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.HashMap.LawfulHashable", "code": "class LawfulHashable (\u03b1 : Type _) [BEq \u03b1] [Hashable \u03b1] : Prop where\n  \n  hash_eq {a b : \u03b1} : a == b \u2192 hash a = hash b", "start": [12, 1], "end": [15, 47], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets", "code": "def Buckets (\u03b1 : Type u) (\u03b2 : Type v) := {b : Array (AssocList \u03b1 \u03b2) // 0 < b.size}", "start": [19, 1], "end": [23, 83], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.mk", "code": "def mk (buckets := 8) (h : 0 < buckets := by decide) : Buckets \u03b1 \u03b2 :=\n  \u27e8mkArray buckets .nil, by simp [h]\u27e9", "start": [27, 1], "end": [29, 38], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.update", "code": "def update (data : Buckets \u03b1 \u03b2) (i : USize)\n    (d : AssocList \u03b1 \u03b2) (h : i.toNat < data.1.size) : Buckets \u03b1 \u03b2 :=\n  \u27e8data.1.uset i d h, (Array.size_uset ..).symm \u25b8 data.2\u27e9", "start": [31, 1], "end": [34, 58], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.size", "code": "noncomputable def size (data : Buckets \u03b1 \u03b2) : Nat := .sum (data.1.data.map (\u00b7.toList.length))", "start": [36, 1], "end": [40, 94], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.update_size", "code": "@[simp] theorem update_size (self : Buckets \u03b1 \u03b2) (i d h) :\n    (self.update i d h).1.size = self.1.size", "start": [42, 1], "end": [43, 67], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.mapVal", "code": "@[specialize] def mapVal (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (self : Buckets \u03b1 \u03b2) : Buckets \u03b1 \u03b3 :=\n  \u27e8self.1.map (.mapVal f), by simp [self.2]\u27e9", "start": [45, 1], "end": [47, 45], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.WF", "code": "structure WF [BEq \u03b1] [Hashable \u03b1] (buckets : Buckets \u03b1 \u03b2) : Prop where\n  \n  distinct [LawfulHashable \u03b1] [PartialEquivBEq \u03b1] : \u2200 bucket \u2208 buckets.1.data,\n    bucket.toList.Pairwise fun a b => \u00ac(a.1 == b.1)\n  \n  hash_self (i : Nat) (h : i < buckets.1.size) :\n    buckets.1[i].All fun k _ => ((hash k).toUSize % buckets.1.size).toNat = i", "start": [49, 1], "end": [59, 78], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp", "code": "structure Imp (\u03b1 : Type u) (\u03b2 : Type v) where\n  \n  size    : Nat\n  \n  buckets : Imp.Buckets \u03b1 \u03b2", "start": [64, 1], "end": [71, 28], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.numBucketsForCapacity", "code": "@[inline] def numBucketsForCapacity (capacity : Nat) : Nat :=\n  capacity * 4 / 3", "start": [75, 1], "end": [80, 19], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.empty'", "code": "@[inline] def empty' (buckets := 8) (h : 0 < buckets := by decide) : Imp \u03b1 \u03b2 :=\n  \u27e80, .mk buckets h\u27e9", "start": [82, 1], "end": [84, 21], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.empty", "code": "def empty (capacity := 0) : Imp \u03b1 \u03b2 :=\n  let nbuckets := numBucketsForCapacity capacity\n  let n : {n : Nat // 0 < n} :=\n    if h : nbuckets = 0 then \u27e88, by decide\u27e9\n    else \u27e8nbuckets, Nat.zero_lt_of_ne_zero h\u27e9\n  empty' n n.2", "start": [86, 1], "end": [92, 15], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.mkIdx", "code": "def mkIdx {n : Nat} (h : 0 < n) (u : USize) : {u : USize // u.toNat < n} :=\n  \u27e8u % n, USize.modn_lt _ h\u27e9", "start": [94, 1], "end": [96, 29], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.reinsertAux", "code": "@[inline] def reinsertAux [Hashable \u03b1]\n    (data : Buckets \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) : Buckets \u03b1 \u03b2 :=\n  let \u27e8i, h\u27e9 := mkIdx data.2 (hash a |>.toUSize)\n  data.update i (.cons a b data.1[i]) h", "start": [98, 1], "end": [105, 40], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.foldM", "code": "@[inline] def foldM [Monad m] (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b4) (d : \u03b4) (map : Imp \u03b1 \u03b2) : m \u03b4 :=\n  map.buckets.1.foldlM (init := d) fun d b => b.foldlM f d", "start": [107, 1], "end": [109, 59], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.fold", "code": "@[inline] def fold (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b4) (d : \u03b4) (m : Imp \u03b1 \u03b2) : \u03b4 :=\n  Id.run $ foldM f d m", "start": [111, 1], "end": [113, 23], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.forM", "code": "@[inline] def forM [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) (h : Imp \u03b1 \u03b2) : m PUnit :=\n  h.buckets.1.forM fun b => b.forM f", "start": [115, 1], "end": [117, 37], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.findEntry?", "code": "def findEntry? [BEq \u03b1] [Hashable \u03b1] (m : Imp \u03b1 \u03b2) (a : \u03b1) : Option (\u03b1 \u00d7 \u03b2) :=\n  let \u27e8_, buckets\u27e9 := m\n  let \u27e8i, h\u27e9 := mkIdx buckets.2 (hash a |>.toUSize)\n  buckets.1[i].findEntry? a", "start": [119, 1], "end": [123, 28], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.find?", "code": "def find? [BEq \u03b1] [Hashable \u03b1] (m : Imp \u03b1 \u03b2) (a : \u03b1) : Option \u03b2 :=\n  let \u27e8_, buckets\u27e9 := m\n  let \u27e8i, h\u27e9 := mkIdx buckets.2 (hash a |>.toUSize)\n  buckets.1[i].find? a", "start": [125, 1], "end": [129, 23], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.contains", "code": "def contains [BEq \u03b1] [Hashable \u03b1] (m : Imp \u03b1 \u03b2) (a : \u03b1) : Bool :=\n  let \u27e8_, buckets\u27e9 := m\n  let \u27e8i, h\u27e9 := mkIdx buckets.2 (hash a |>.toUSize)\n  buckets.1[i].contains a", "start": [131, 1], "end": [135, 26], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.expand", "code": "def expand [Hashable \u03b1] (size : Nat) (buckets : Buckets \u03b1 \u03b2) : Imp \u03b1 \u03b2 :=\n  let nbuckets := buckets.1.size * 2\n  { size, buckets := go 0 buckets.1 (.mk nbuckets (Nat.mul_pos buckets.2 (by decide))) }\nwhere\n  \n  go (i : Nat) (source : Array (AssocList \u03b1 \u03b2)) (target : Buckets \u03b1 \u03b2) : Buckets \u03b1 \u03b2 :=\n    if h : i < source.size then\n      let idx : Fin source.size := \u27e8i, h\u27e9\n      let es := source.get idx\n      let source := source.set idx .nil\n      let target := es.foldl reinsertAux target\n      go (i+1) source target\n    else target\ntermination_by _ i source _ => source.size - i", "start": [137, 1], "end": [154, 47], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.insert", "code": "@[inline] def insert [BEq \u03b1] [Hashable \u03b1] (m : Imp \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) : Imp \u03b1 \u03b2 :=\n  let \u27e8size, buckets\u27e9 := m\n  let \u27e8i, h\u27e9 := mkIdx buckets.2 (hash a |>.toUSize)\n  let bkt := buckets.1[i]\n  bif bkt.contains a then\n    \u27e8size, buckets.update i (bkt.replace a b) h\u27e9\n  else\n    let size' := size + 1\n    let buckets' := buckets.update i (.cons a b bkt) h\n    if numBucketsForCapacity size' \u2264 buckets.1.size then\n      { size := size', buckets := buckets' }\n    else\n      expand size' buckets'", "start": [156, 1], "end": [172, 28], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.erase", "code": "def erase [BEq \u03b1] [Hashable \u03b1] (m : Imp \u03b1 \u03b2) (a : \u03b1) : Imp \u03b1 \u03b2 :=\n  let \u27e8size, buckets\u27e9 := m\n  let \u27e8i, h\u27e9 := mkIdx buckets.2 (hash a |>.toUSize)\n  let bkt := buckets.1[i]\n  bif bkt.contains a then \u27e8size - 1, buckets.update i (bkt.erase a) h\u27e9 else m", "start": [174, 1], "end": [181, 78], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.mapVal", "code": "@[inline] def mapVal (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (self : Imp \u03b1 \u03b2) : Imp \u03b1 \u03b3 :=\n  { size := self.size, buckets := self.buckets.mapVal f }", "start": [183, 1], "end": [185, 58], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.modify", "code": "def modify [BEq \u03b1] [Hashable \u03b1] (m : Imp \u03b1 \u03b2) (a : \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) : Imp \u03b1 \u03b2 :=\n  let \u27e8size, buckets\u27e9 := m\n  let \u27e8i, h\u27e9 := mkIdx buckets.2 (hash a |>.toUSize)\n  let bkt := buckets.1[i]\n  let buckets := buckets.update i .nil h \u27e8size, buckets.update i (bkt.modify a f) ((Buckets.update_size ..).symm \u25b8 h)\u27e9", "start": [187, 1], "end": [193, 80], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.filterMap", "code": "@[specialize] def filterMap {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}\n    (f : \u03b1 \u2192 \u03b2 \u2192 Option \u03b3) (m : Imp \u03b1 \u03b2) : Imp \u03b1 \u03b3 :=\n  let m' := m.buckets.1.mapM (m := StateT (ULift Nat) Id) (go .nil) |>.run \u27e80\u27e9 |>.run\n  have : m'.1.size > 0 := by\n    have := Array.size_mapM (m := StateT (ULift Nat) Id) (go .nil) m.buckets.1\n    simp [SatisfiesM_StateT_eq, SatisfiesM_Id_eq] at this\n    simp [this, Id.run, StateT.run, m.2.2]\n  \u27e8m'.2.1, m'.1, this\u27e9\nwhere\n  \n  @[specialize] go (acc : AssocList \u03b1 \u03b3) : AssocList \u03b1 \u03b2 \u2192 ULift Nat \u2192 AssocList \u03b1 \u03b3 \u00d7 ULift Nat\n  | .nil, n => (acc, n)\n  | .cons a b l, n => match f a b with\n    | none => go acc l n\n    | some c => go (.cons a c acc) l \u27e8n.1 + 1\u27e9", "start": [195, 1], "end": [214, 47], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.filter", "code": "@[inline] def filter (f : \u03b1 \u2192 \u03b2 \u2192 Bool) (m : Imp \u03b1 \u03b2) : Imp \u03b1 \u03b2 :=\n  m.filterMap fun a b => bif f a b then some b else none", "start": [216, 1], "end": [218, 57], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.WF", "code": "inductive WF [BEq \u03b1] [Hashable \u03b1] : Imp \u03b1 \u03b2 \u2192 Prop where\n  \n  | mk : m.size = m.buckets.size \u2192 m.buckets.WF \u2192 WF m\n  \n  | empty' : WF (empty' n h)\n  \n  | insert : WF m \u2192 WF (insert m a b)\n  \n  | erase : WF m \u2192 WF (erase m a)\n  \n  | modify : WF m \u2192 WF (modify m a f)", "start": [220, 1], "end": [238, 38], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.WF.empty", "code": "theorem WF.empty [BEq \u03b1] [Hashable \u03b1] : WF (empty n : Imp \u03b1 \u03b2)", "start": [240, 1], "end": [240, 96], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap", "code": "def _root_.Std.HashMap (\u03b1 : Type u) (\u03b2 : Type v) [BEq \u03b1] [Hashable \u03b1] := {m : Imp \u03b1 \u03b2 // m.WF}", "start": [244, 1], "end": [251, 95], "kind": "commanddeclaration"}, {"full_name": "Std.mkHashMap", "code": "@[inline] def _root_.Std.mkHashMap [BEq \u03b1] [Hashable \u03b1] (capacity := 0) : HashMap \u03b1 \u03b2 :=\n  \u27e8.empty capacity, .empty\u27e9", "start": [255, 1], "end": [257, 28], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.empty", "code": "@[inline] def empty [BEq \u03b1] [Hashable \u03b1] : HashMap \u03b1 \u03b2 := mkHashMap", "start": [264, 1], "end": [265, 68], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.size", "code": "@[inline] def size (self : HashMap \u03b1 \u03b2) : Nat := self.1.size", "start": [269, 1], "end": [270, 61], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.isEmpty", "code": "@[inline] def isEmpty (self : HashMap \u03b1 \u03b2) : Bool := self.size = 0", "start": [272, 1], "end": [273, 67], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.insert", "code": "def insert (self : HashMap \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) : HashMap \u03b1 \u03b2 := \u27e8self.1.insert a b, self.2.insert\u27e9", "start": [275, 1], "end": [279, 100], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.insert'", "code": "@[inline] def insert' (m : HashMap \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) : HashMap \u03b1 \u03b2 \u00d7 Bool :=\n  let old := m.size\n  let m' := m.insert a b\n  let replaced := old == m'.size\n  (m', replaced)", "start": [281, 1], "end": [289, 17], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.erase", "code": "@[inline] def erase (self : HashMap \u03b1 \u03b2) (a : \u03b1) : HashMap \u03b1 \u03b2 := \u27e8self.1.erase a, self.2.erase\u27e9", "start": [291, 1], "end": [294, 97], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.modify", "code": "def modify (self : HashMap \u03b1 \u03b2) (a : \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) : HashMap \u03b1 \u03b2 :=\n  \u27e8self.1.modify a f, self.2.modify\u27e9", "start": [296, 1], "end": [301, 37], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.findEntry?", "code": "@[inline] def findEntry? (self : HashMap \u03b1 \u03b2) (a : \u03b1) : Option (\u03b1 \u00d7 \u03b2) := self.1.findEntry? a", "start": [303, 1], "end": [304, 94], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.find?", "code": "@[inline] def find? (self : HashMap \u03b1 \u03b2) (a : \u03b1) : Option \u03b2 := self.1.find? a", "start": [306, 1], "end": [307, 78], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.findD", "code": "@[inline] def findD (self : HashMap \u03b1 \u03b2) (a : \u03b1) (b\u2080 : \u03b2) : \u03b2 := (self.find? a).getD b\u2080", "start": [309, 1], "end": [310, 88], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.find!", "code": "@[inline] def find! [Inhabited \u03b2] (self : HashMap \u03b1 \u03b2) (a : \u03b1) : \u03b2 :=\n  (self.find? a).getD (panic! \"key is not in the map\")", "start": [312, 1], "end": [314, 55], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.contains", "code": "@[inline] def contains (self : HashMap \u03b1 \u03b2) (a : \u03b1) : Bool := self.1.contains a", "start": [319, 1], "end": [320, 80], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.foldM", "code": "@[inline] def foldM [Monad m] (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b4) (init : \u03b4) (self : HashMap \u03b1 \u03b2) : m \u03b4 :=\n  self.1.foldM f init", "start": [322, 1], "end": [324, 22], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.fold", "code": "@[inline] def fold (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b4) (init : \u03b4) (self : HashMap \u03b1 \u03b2) : \u03b4 := self.1.fold f init", "start": [326, 1], "end": [327, 97], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.mergeWithM", "code": "@[specialize] def mergeWithM [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 m \u03b2)\n    (self other : HashMap \u03b1 \u03b2) : m (HashMap \u03b1 \u03b2) :=\n  other.foldM (init := self) fun m k v\u2082 =>\n    match m.find? k with\n    | none => return m.insert k v\u2082\n    | some v\u2081 => return m.insert k (\u2190 f k v\u2081 v\u2082)", "start": [329, 1], "end": [335, 49], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.mergeWith", "code": "@[inline] def mergeWith (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2) (self other : HashMap \u03b1 \u03b2) : HashMap \u03b1 \u03b2 :=\n  other.fold (init := self) \u03bb map k v\u2082 =>\n    match map.find? k with\n    | none => map.insert k v\u2082\n    | some v\u2081 => map.insert k $ f k v\u2081 v\u2082", "start": [337, 1], "end": [344, 42], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.forM", "code": "@[inline] def forM [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) (self : HashMap \u03b1 \u03b2) : m PUnit := self.1.forM f", "start": [346, 1], "end": [347, 99], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.toList", "code": "def toList (self : HashMap \u03b1 \u03b2) : List (\u03b1 \u00d7 \u03b2) := self.fold (init := []) fun r k v => (k, v)::r", "start": [349, 1], "end": [350, 96], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.toArray", "code": "def toArray (self : HashMap \u03b1 \u03b2) : Array (\u03b1 \u00d7 \u03b2) :=\n  self.fold (init := #[]) fun r k v => r.push (k, v)", "start": [352, 1], "end": [354, 53], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.numBuckets", "code": "def numBuckets (self : HashMap \u03b1 \u03b2) : Nat := self.1.buckets.1.size", "start": [356, 1], "end": [357, 67], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.ofList", "code": "def ofList [BEq \u03b1] [Hashable \u03b1] (l : List (\u03b1 \u00d7 \u03b2)) : HashMap \u03b1 \u03b2 :=\n  l.foldl (init := HashMap.empty) fun m (k, v) => m.insert k v", "start": [359, 1], "end": [364, 63], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.ofListWith", "code": "def ofListWith [BEq \u03b1] [Hashable \u03b1] (l : List (\u03b1 \u00d7 \u03b2)) (f : \u03b2 \u2192 \u03b2 \u2192 \u03b2) : HashMap \u03b1 \u03b2 :=\n  l.foldl (init := HashMap.empty) fun m p =>\n    match m.find? p.1 with\n    | none   => m.insert p.1 p.2\n    | some v => m.insert p.1 <| f v p.2", "start": [366, 1], "end": [371, 40], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompatibleTypes.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.compatibleTypesQuick", "code": "partial def compatibleTypesQuick (a b : Expr) : Bool :=\n  if a.isErased || b.isErased then\n    true\n  else\n    let a' := a.headBeta\n    let b' := b.headBeta\n    if a != a' || b != b' then\n      compatibleTypesQuick a' b'\n    else if a == b then\n      true\n    else\n      match a, b with\n      | .app f a, .app g b => compatibleTypesQuick f g && compatibleTypesQuick a b\n      | .forallE _ d\u2081 b\u2081 _, .forallE _ d\u2082 b\u2082 _ => compatibleTypesQuick d\u2081 d\u2082 && compatibleTypesQuick b\u2081 b\u2082\n      | .lam _ d\u2081 b\u2081 _, .lam _ d\u2082 b\u2082 _ => compatibleTypesQuick d\u2081 d\u2082 && compatibleTypesQuick b\u2081 b\u2082\n      | .sort u, .sort v => Level.isEquiv u v\n      | .const n us, .const m vs => n == m && List.isEqv us vs Level.isEquiv\n      | _, _ => false", "start": [43, 1], "end": [68, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.compatibleTypesFull", "code": "partial def InferType.compatibleTypesFull (a b : Expr) : InferTypeM Bool := do\n  if a.isErased || b.isErased then\n    return true\n  else\n    let a' := a.headBeta\n    let b' := b.headBeta\n    if a != a' || b != b' then\n      compatibleTypesFull a' b'\n    else if a == b then\n      return true\n    else\n      match a, b with\n      | .app f a, .app g b => compatibleTypesFull f g <&&> compatibleTypesFull a b\n      | .forallE n d\u2081 b\u2081 bi, .forallE _ d\u2082 b\u2082 _ =>\n        unless (\u2190 compatibleTypesFull d\u2081 d\u2082) do return false\n        withLocalDecl n d\u2081 bi fun x =>\n          compatibleTypesFull (b\u2081.instantiate1 x) (b\u2082.instantiate1 x)\n      | .lam n d\u2081 b\u2081 bi, .lam _ d\u2082 b\u2082 _ =>\n        unless (\u2190 compatibleTypesFull d\u2081 d\u2082) do return false\n        withLocalDecl n d\u2081 bi fun x =>\n          compatibleTypesFull (b\u2081.instantiate1 x) (b\u2082.instantiate1 x)\n      | .sort u, .sort v => return Level.isEquiv u v\n      | .const n us, .const m vs => return n == m && List.isEqv us vs Level.isEquiv\n      | _, _ =>\n        if a.isLambda then\n          let some b \u2190 etaExpand? b | return false\n          compatibleTypesFull a b\n        else if b.isLambda then\n          let some a \u2190 etaExpand? a | return false\n          compatibleTypesFull a b\n        else\n          return false\nwhere\n  etaExpand? (e : Expr) : InferTypeM (Option Expr) := do\n    match (\u2190 inferType e).headBeta with\n    | .forallE n d _ bi =>\n      \n      return some (.lam n d (.app e (.bvar 0)) bi)\n    | _ => return none", "start": [70, 1], "end": [117, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.InferType.compatibleTypes", "code": "def InferType.compatibleTypes (a b : Expr) : InferTypeM Bool := do\n  if compatibleTypesQuick a b then\n    return true\n  else\n    compatibleTypesFull a b", "start": [119, 1], "end": [141, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToLCNF.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Util.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Bind.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/ProjFns.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/BorrowedAnnotation.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.ToLCNF.isLCProof", "code": "def isLCProof (e : Expr) : Bool :=\n  e.isAppOfArity ``lcProof 1", "start": [16, 1], "end": [21, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.mkLcProof", "code": "def mkLcProof (p : Expr) :=\n  mkApp (mkConst ``lcProof []) p", "start": [23, 1], "end": [25, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.Element", "code": "inductive Element where\n  | jp  (decl : FunDecl)\n  | fun (decl : FunDecl)\n  | let (decl : LetDecl)\n  | cases (p : Param) (cases : Cases)\n  | unreach (p : Param)\n  deriving Inhabited", "start": [27, 1], "end": [38, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.BindCasesM.State", "code": "abbrev BindCasesM.State := FVarIdMap FunDecl", "start": [40, 1], "end": [44, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.BindCasesM", "code": "abbrev BindCasesM := StateRefT BindCasesM.State CompilerM", "start": [46, 1], "end": [47, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.bindCases", "code": "partial def bindCases (jpDecl : FunDecl) (cases : Cases) : CompilerM Code := do\n  let (alts, s) \u2190 visitAlts cases.alts |>.run {}\n  let resultType \u2190 mkCasesResultType alts\n  let result := .cases { cases with alts, resultType }\n  let result := s.fold (init := result) fun result _ altJp => .jp altJp result\n  return .jp jpDecl result\nwhere\n  visitAlts (alts : Array Alt) : BindCasesM (Array Alt) :=\n    alts.mapM fun alt => return alt.updateCode (\u2190 go alt.getCode)\n\n  findFun? (f : FVarId) : CompilerM (Option FunDecl) := do\n    if let some funDecl \u2190 findFunDecl? f then\n      return funDecl\n    else if let some (.fvar f' #[]) \u2190 findLetValue? f then\n      findFun? f'\n    else\n      return none\n\n  go (code : Code) : BindCasesM Code := do\n    match code with\n    | .let decl k =>\n      if let .return fvarId := k then\n        \n        if decl.fvarId == fvarId then\n          match decl.value with\n          | .fvar f args =>\n            let binderName \u2190 getBinderName f\n            if binderName.getPrefix == `_alt then\n              if let some funDecl \u2190 findFun? f then\n                eraseLetDecl decl\n                if let some altJp := (\u2190 get).find? f then\n                  \n                  return .jmp altJp.fvarId args\n                else\n                  \n                  let mut jpParams := #[]\n                  let mut subst := {}\n                  let mut jpArgs := #[]\n                  \n                  for param in funDecl.params[:args.size] do\n                    let type \u2190 replaceExprFVars param.type subst (translator := true)\n                    let paramNew \u2190 mkAuxParam type\n                    jpParams := jpParams.push paramNew\n                    subst := subst.insert param.fvarId (Expr.fvar paramNew.fvarId)\n                    jpArgs := jpArgs.push (Arg.fvar paramNew.fvarId)\n                  let letDecl \u2190 mkAuxLetDecl (.fvar f jpArgs)\n                  let jpValue := .let letDecl (.jmp jpDecl.fvarId #[.fvar letDecl.fvarId])\n                  let altJp \u2190 mkAuxJpDecl jpParams jpValue\n                  modify fun map => map.insert f altJp\n                  return .jmp altJp.fvarId args\n          | _ => pure ()\n      let k \u2190 go k\n      if let some altJp := (\u2190 get).find? decl.fvarId then\n        modify fun s => s.erase decl.fvarId\n        return .let decl (.jp altJp k)\n      else\n        return .let decl k\n    | .fun decl k => return .fun decl (\u2190 go k)\n    | .jp decl k =>\n      let value \u2190 go decl.value\n      let type \u2190 value.inferParamType decl.params\n      let decl \u2190 decl.update' type value\n      return .jp decl (\u2190 go k)\n    | .cases c =>\n      let alts \u2190 c.alts.mapM fun\n        | .alt ctorName params k => return .alt ctorName params (\u2190 go k)\n        | .default k => return .default (\u2190 go k)\n      if alts.isEmpty then\n        throwError \"`Code.bind` failed, empty `cases` found\"\n      let resultType \u2190 mkCasesResultType alts\n      return .cases { c with alts, resultType }\n    | .return fvarId => return .jmp jpDecl.fvarId #[.fvar fvarId]\n    | .jmp .. | .unreach .. => return code", "start": [49, 1], "end": [149, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.seqToCode", "code": "def seqToCode (seq : Array Element) (k : Code) : CompilerM Code := do\n  go seq seq.size k\nwhere\n  go (seq : Array Element) (i : Nat) (c : Code) : CompilerM Code := do\n    if i > 0 then\n      match seq[i-1]! with\n      | .jp decl => go seq (i - 1) (.jp decl c)\n      | .fun decl => go seq (i - 1) (.fun decl c)\n      | .let decl => go seq (i - 1) (.let decl c)\n      | .unreach _ =>\n        let type \u2190 c.inferType\n        eraseCode c\n        seq[:i].forM fun\n          | .let decl => eraseLetDecl decl\n          | .jp decl | .fun decl => eraseFunDecl decl\n          | .cases _ cs => eraseCode (.cases cs)\n          | .unreach auxParam => eraseParam auxParam\n        return .unreach type\n      | .cases auxParam cases =>\n        if let .return fvarId := c then\n          if auxParam.fvarId == fvarId then\n            eraseParam auxParam\n            go seq (i - 1) (.cases cases)\n          else\n            go seq (i - 1) c\n        else if auxParam.type.headBeta.isForall then\n          \n          eraseParam auxParam\n          let auxFunDecl := { auxParam with params := #[], value := .cases cases : FunDecl }\n          modifyLCtx fun lctx => lctx.addFunDecl auxFunDecl\n          let auxFunDecl \u2190 auxFunDecl.etaExpand\n          go seq (i - 1) (.fun auxFunDecl c)\n        else\n          \n          let jpDecl \u2190 mkAuxJpDecl' auxParam c\n          go seq (i - 1) (\u2190 bindCases jpDecl cases)\n    else\n      return c", "start": [151, 1], "end": [192, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.State", "code": "structure State where\n  \n  lctx : LocalContext := {}\n  \n  cache : PHashMap Expr Arg := {}\n  \n  typeCache : HashMap Expr Expr := {}\n  \n  isTypeFormerTypeCache : HashMap Expr Bool := {}\n  \n  seq : Array Element := #[]\n  \n  toAny : FVarIdSet := {}", "start": [194, 1], "end": [212, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.M", "code": "abbrev M := StateRefT State CompilerM", "start": [214, 1], "end": [214, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.liftMetaM", "code": "@[inline] def liftMetaM (x : MetaM \u03b1) : M \u03b1 := do\n  x.run' { lctx := (\u2190 get).lctx }", "start": [216, 1], "end": [217, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.pushElement", "code": "def pushElement (elem : Element) : M Unit := do\n  modify fun s => { s with seq := s.seq.push elem }", "start": [219, 1], "end": [221, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.mkUnreachable", "code": "def mkUnreachable (type : Expr) : M Arg := do\n  let p \u2190 mkAuxParam type\n  pushElement (.unreach p)\n  return .fvar p.fvarId", "start": [223, 1], "end": [226, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.mkAuxLetDecl", "code": "def mkAuxLetDecl (e : LetValue) (prefixName := `_x) : M FVarId := do\n  match e with\n  | .fvar fvarId #[] => return fvarId\n  | _ =>\n    let letDecl \u2190 mkLetDecl (\u2190 mkFreshBinderName prefixName) (\u2190 e.inferType) e\n    pushElement (.let letDecl)\n    return letDecl.fvarId", "start": [228, 1], "end": [234, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.letValueToArg", "code": "def letValueToArg (e : LetValue) (prefixName := `_x) : M Arg :=\n  return .fvar (\u2190 mkAuxLetDecl e prefixName)", "start": [236, 1], "end": [237, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.toCode", "code": "def toCode (result : Arg) : M Code := do\n  match result with\n  | .fvar fvarId => seqToCode (\u2190 get).seq (.return fvarId)\n  | .erased | .type .. =>\n    let fvarId \u2190 mkAuxLetDecl .erased\n    seqToCode (\u2190 get).seq (.return fvarId)", "start": [239, 1], "end": [245, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.run", "code": "def run (x : M \u03b1) : CompilerM \u03b1 :=\n  x |>.run' {}", "start": [247, 1], "end": [248, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.isTypeFormerType", "code": "private partial def isTypeFormerType (type : Expr) : M Bool := do\n  match quick (\u2190 getEnv) type with\n  | .true => return true\n  | .false => return false\n  | .undef =>\n    if let some result := (\u2190 get).isTypeFormerTypeCache.find? type then\n      return result\n    let result \u2190 liftMetaM <| Meta.isTypeFormerType type\n    modify fun s => { s with isTypeFormerTypeCache := s.isTypeFormerTypeCache.insert type result }\n    return result\nwhere\n  quick (env : Environment) : Expr \u2192 LBool\n  | .forallE _ _ b _ => quick env b\n  | .mdata _ b => quick env b\n  | .letE .. => .undef\n  | .sort _ => .true\n  | .bvar .. => .false\n  | type =>\n    match type.getAppFn with\n    | .bvar .. => .false\n    | .const declName _ =>\n      if let some (.inductInfo ..) := env.find? declName then\n        .false\n      else\n        .undef\n    | _ => .undef", "start": [250, 1], "end": [278, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.withNewScope", "code": "def withNewScope (x : M \u03b1) : M \u03b1 := do\n  let saved \u2190 get\n  let saved := { saved with typeCache := {}, isTypeFormerTypeCache := {} }\n  modify fun s => { s with seq := #[] }\n  try\n    x\n  finally\n    let saved := { saved with\n      typeCache := (\u2190 get).typeCache\n      isTypeFormerTypeCache := (\u2190 get).isTypeFormerTypeCache\n    }\n    set saved", "start": [280, 1], "end": [292, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.applyToAny", "code": "def applyToAny (type : Expr) : M Expr := do\n  let toAny := (\u2190 get).toAny\n  return type.replace fun\n    | .fvar fvarId => if toAny.contains fvarId then some erasedExpr else none\n    | _ => none", "start": [299, 1], "end": [303, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.toLCNFType", "code": "def toLCNFType (type : Expr) : M Expr := do\n  match (\u2190 get).typeCache.find? type with\n  | some type' => return type'\n  | none =>\n    let type' \u2190 liftMetaM <| LCNF.toLCNFType type\n    let type' \u2190 applyToAny type'\n    modify fun s => { s with typeCache := s.typeCache.insert type type' }\n    return type'", "start": [305, 1], "end": [312, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.cleanupBinderName", "code": "def cleanupBinderName (binderName : Name) : CompilerM Name :=\n  if binderName.hasMacroScopes then\n    let binderName := binderName.eraseMacroScopes\n    mkFreshBinderName binderName\n  else\n    return binderName", "start": [314, 1], "end": [319, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.mkParam", "code": "def mkParam (binderName : Name) (type : Expr) : M Param := do\n  let binderName \u2190 cleanupBinderName binderName\n  let borrow := isMarkedBorrowed type\n  let type' \u2190 toLCNFType type\n  let param \u2190 LCNF.mkParam binderName type' borrow\n  modify fun s => { s with lctx  := s.lctx.mkLocalDecl param.fvarId binderName type .default }\n  return param", "start": [321, 1], "end": [328, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.mkLetDecl", "code": "def mkLetDecl (binderName : Name) (type : Expr) (value : Expr) (type' : Expr) (arg : Arg) : M LetDecl := do\n  let binderName \u2190 cleanupBinderName binderName\n  let value' \u2190 match arg with\n    | .fvar fvarId => pure <| .fvar fvarId #[]\n    | .erased | .type .. => pure .erased\n  let letDecl \u2190 LCNF.mkLetDecl binderName type' value'\n  modify fun s => { s with\n    lctx := s.lctx.mkLetDecl letDecl.fvarId binderName type value false\n    seq := s.seq.push <| .let letDecl\n  }\n  return letDecl", "start": [330, 1], "end": [340, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.visitLambda", "code": "def visitLambda (e : Expr) : M (Array Param \u00d7 Expr) :=\n  go e #[] #[]\nwhere\n  go (e : Expr) (xs : Array Expr) (ps : Array Param) := do\n    if let .lam binderName type body _ := e then\n      let type := type.instantiateRev xs\n      let p \u2190 mkParam binderName type\n      go body (xs.push p.toExpr) (ps.push p)\n    else\n      return (ps, e.instantiateRev xs)", "start": [342, 1], "end": [351, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.visitBoundedLambda", "code": "def visitBoundedLambda (e : Expr) (n : Nat) : M (Array Param \u00d7 Expr) :=\n  go e n #[] #[]\nwhere\n  go (e : Expr) (n : Nat) (xs : Array Expr) (ps : Array Param) := do\n    if n == 0 then\n      return (ps, e.instantiateRev xs)\n    else if let .lam binderName type body _ := e then\n      let type := type.instantiateRev xs\n      let p \u2190 mkParam binderName type\n      go body (n-1) (xs.push p.toExpr) (ps.push p)\n    else\n      return (ps, e.instantiateRev xs)", "start": [353, 1], "end": [364, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.mustEtaExpand", "code": "def mustEtaExpand (env : Environment) (e : Expr) : Bool :=\n  if let .const declName _ := e.getAppFn then\n    match env.find? declName with\n    | some (.recInfo ..) | some (.ctorInfo ..) | some (.quotInfo ..) => true\n    | _ => isCasesOnRecursor env declName || isNoConfusion env declName || env.isProjectionFn declName || declName == ``Eq.ndrec\n  else\n    false", "start": [366, 1], "end": [372, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.etaExpandN", "code": "def etaExpandN (e : Expr) (n : Nat) : M Expr := do\n  if n == 0 then\n    return e\n  else liftMetaM do\n    Meta.forallBoundedTelescope (\u2190 Meta.inferType e) n fun xs _ =>\n      Meta.mkLambdaFVars xs (mkAppN e xs)", "start": [374, 1], "end": [382, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.etaReduceImplicit", "code": "partial def etaReduceImplicit (e : Expr) : Expr :=\n  match e with\n  | .lam _ d b bi =>\n    if bi.isImplicit then\n      let b' := etaReduceImplicit b\n      match b' with\n      | .app f (.bvar 0) =>\n        if !f.hasLooseBVar 0 then\n          f.lowerLooseBVars 1 1\n        else\n          e.updateLambdaE! d b'\n      | _ => e.updateLambdaE! d b'\n    else\n      e\n  | _ => e", "start": [384, 1], "end": [402, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.litToValue", "code": "def litToValue (lit : Literal) : LitValue :=\n  match lit with\n  | .natVal val => .natVal val\n  | .strVal val => .strVal val", "start": [404, 1], "end": [407, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToLCNF.toLCNF", "code": "partial def toLCNF (e : Expr) : CompilerM Code := do\n  run do toCode (\u2190 visit e)\nwhere\n  visitCore (e : Expr) : M Arg := withIncRecDepth do\n    if let some arg := (\u2190 get).cache.find? e then\n      return arg\n    let r : Arg \u2190 match e with\n      | .app ..      => visitApp e\n      | .const ..    => visitApp e\n      | .proj s i e  => visitProj s i e\n      | .mdata d e   => visitMData d e\n      | .lam ..      => visitLambda e\n      | .letE ..     => visitLet e #[]\n      | .lit lit     => visitLit lit\n      | .fvar fvarId => if (\u2190 get).toAny.contains fvarId then pure .erased else pure (.fvar fvarId)\n      | .forallE .. | .mvar .. | .bvar .. | .sort ..  => unreachable!\n    modify fun s => { s with cache := s.cache.insert e r }\n    return r\n\n  visit (e : Expr) : M Arg := withIncRecDepth do\n    if isLCProof e then\n      return .erased\n    let type \u2190 liftMetaM <| Meta.inferType e\n    if (\u2190 liftMetaM <| Meta.isProp type) then\n      \n      return .erased\n    if (\u2190 isTypeFormerType type) then\n      \n      return .erased\n    visitCore e\n\n  visitLit (lit : Literal) : M Arg :=\n    letValueToArg (.value (litToValue lit))\n\n  visitAppArg (e : Expr) : M Arg := do\n    if isLCProof e then\n      return .erased\n    let type \u2190 liftMetaM <| Meta.inferType e\n    if (\u2190 liftMetaM <| Meta.isProp type) then\n      \n      return .erased\n    if (\u2190 isTypeFormerType type) then\n      \n      if isPredicateType (\u2190 toLCNFType type) then\n        return .erased\n      else\n        \n        return .type (\u2190 toLCNFType e)\n    else\n      visitCore e\n\n  \n  visitAppDefaultConst (f : Expr) (args : Array Expr) : M Arg := do\n    let .const declName us := f | unreachable!\n    let args \u2190 args.mapM visitAppArg\n    letValueToArg <| .const declName us args\n\n  \n  etaIfUnderApplied (e : Expr) (arity : Nat) (k : M Arg) : M Arg := do\n    let numArgs := e.getAppNumArgs\n    if numArgs < arity then\n      visit (\u2190 etaExpandN e (arity - numArgs))\n    else\n      k\n\n  \n  mkOverApplication (app : Arg) (args : Array Expr) (arity : Nat) : M Arg := do\n    if args.size == arity then\n      return app\n    else\n      match app with\n      | .fvar f =>\n        let mut argsNew := #[]\n        for i in [arity : args.size] do\n          argsNew := argsNew.push (\u2190 visitAppArg args[i]!)\n        letValueToArg <| .fvar f argsNew\n      | .erased | .type .. => return .erased\n\n  \n  visitAlt (ctorName : Name) (numParams : Nat) (e : Expr) : M (Expr \u00d7 Alt) := do\n    withNewScope do\n      let mut (ps, e) \u2190 visitBoundedLambda e numParams\n      if ps.size < numParams then\n        e \u2190 etaExpandN e (numParams - ps.size)\n        let (ps', e') \u2190 ToLCNF.visitLambda e\n        ps := ps ++ ps'\n        e := e'\n      \n      ps \u2190 ps.mapM fun p => do\n        let type \u2190 inferType p.toExpr\n        if (\u2190 isTypeFormerType type) then\n          modify fun s => { s with toAny := s.toAny.insert p.fvarId }\n        \n        p.update (\u2190 applyToAny p.type)\n      let c \u2190 toCode (\u2190 visit e)\n      let altType \u2190 c.inferType\n      return (altType, .alt ctorName ps c)\n\n  visitCases (casesInfo : CasesInfo) (e : Expr) : M Arg :=\n    etaIfUnderApplied e casesInfo.arity do\n      let args := e.getAppArgs\n      let mut resultType \u2190 toLCNFType (\u2190 liftMetaM do Meta.inferType (mkAppN e.getAppFn args[:casesInfo.arity]))\n      if casesInfo.numAlts == 0 then\n        \n        mkUnreachable resultType\n      else\n        let mut alts := #[]\n        let typeName := casesInfo.declName.getPrefix\n        let discr \u2190 visitAppArg args[casesInfo.discrPos]!\n        let .inductInfo indVal \u2190 getConstInfo typeName | unreachable!\n        match discr with\n        | .erased | .type .. =>\n          \n          throwError \"unsupported `{casesInfo.declName}` application during code generation\"\n        | .fvar discrFVarId =>\n          for i in casesInfo.altsRange, numParams in casesInfo.altNumParams, ctorName in indVal.ctors do\n            let (altType, alt) \u2190 visitAlt ctorName numParams args[i]!\n            resultType := joinTypes altType resultType\n            alts := alts.push alt\n          let cases : Cases := { typeName, discr := discrFVarId, resultType, alts }\n          let auxDecl \u2190 mkAuxParam resultType\n          pushElement (.cases auxDecl cases)\n          let result := .fvar auxDecl.fvarId\n          mkOverApplication result args casesInfo.arity\n\n  visitCtor (arity : Nat) (e : Expr) : M Arg :=\n    etaIfUnderApplied e arity do\n      visitAppDefaultConst e.getAppFn e.getAppArgs\n\n  visitQuotLift (e : Expr) : M Arg := do\n    let arity := 6\n    etaIfUnderApplied e arity do\n      let mut args := e.getAppArgs\n      let \u03b1 := args[0]!\n      let r := args[1]!\n      let f \u2190 visitAppArg args[3]!\n      let q \u2190 visitAppArg args[5]!\n      let .const _ [u, _] := e.getAppFn | unreachable!\n      let invq \u2190 mkAuxLetDecl (.const ``Quot.lcInv [u] #[.type \u03b1, .type r, q])\n      match f with\n      | .erased => return .erased\n      | .type _ => unreachable!\n      | .fvar fvarId => mkOverApplication (\u2190 letValueToArg <| .fvar fvarId #[.fvar invq]) args arity\n\n  visitEqRec (e : Expr) : M Arg :=\n    let arity := 6\n    etaIfUnderApplied e arity do\n      let args := e.getAppArgs\n      let minor := if e.isAppOf ``Eq.rec || e.isAppOf ``Eq.ndrec then args[3]! else args[5]!\n      let minor \u2190 visit minor\n      mkOverApplication minor args arity\n\n  visitFalseRec (e : Expr) : M Arg :=\n    let arity := 2\n    etaIfUnderApplied e arity do\n      let type \u2190 toLCNFType (\u2190 liftMetaM do Meta.inferType e)\n      mkUnreachable type\n\n  visitAndIffRecCore (e : Expr) (minorPos : Nat) : M Arg :=\n    let arity := 5\n    etaIfUnderApplied e arity do\n      let args := e.getAppArgs\n      let ha := mkLcProof args[0]! let hb := mkLcProof args[1]!\n      let minor := args[minorPos]!\n      let minor := minor.beta #[ha, hb]\n      visit (mkAppN minor args[arity:])\n\n  visitNoConfusion (e : Expr) : M Arg := do\n    let .const declName _ := e.getAppFn | unreachable!\n    let typeName := declName.getPrefix\n    let .inductInfo inductVal \u2190 getConstInfo typeName | unreachable!\n    let arity := inductVal.numParams + inductVal.numIndices + 1  + 2  + 1 \n    etaIfUnderApplied e arity do\n      let args := e.getAppArgs\n      let lhs \u2190 liftMetaM do Meta.whnf args[inductVal.numParams + inductVal.numIndices + 1]!\n      let rhs \u2190 liftMetaM do Meta.whnf args[inductVal.numParams + inductVal.numIndices + 2]!\n      let lhs := lhs.toCtorIfLit\n      let rhs := rhs.toCtorIfLit\n      match lhs.isConstructorApp? (\u2190 getEnv), rhs.isConstructorApp? (\u2190 getEnv) with\n      | some lhsCtorVal, some rhsCtorVal =>\n        if lhsCtorVal.name == rhsCtorVal.name then\n          etaIfUnderApplied e (arity+1) do\n            let major := args[arity]!\n            let major \u2190 expandNoConfusionMajor major lhsCtorVal.numFields\n            let major := mkAppN major args[arity+1:]\n            visit major\n        else\n          let type \u2190 toLCNFType (\u2190 liftMetaM <| Meta.inferType e)\n          mkUnreachable type\n      | _, _ =>\n        throwError \"code generator failed, unsupported occurrence of `{declName}`\"\n\n  expandNoConfusionMajor (major : Expr) (numFields : Nat) : M Expr := do\n    match numFields with\n    | 0 => return major\n    | n+1 =>\n      if let .lam _ d b _ := major then\n        let proof := mkLcProof d\n        expandNoConfusionMajor (b.instantiate1 proof) n\n      else\n        expandNoConfusionMajor (\u2190 etaExpandN major (n+1)) (n+1)\n\n  visitProjFn (projInfo : ProjectionFunctionInfo) (e : Expr) : M Arg := do\n    let typeName := projInfo.ctorName.getPrefix\n    if isRuntimeBultinType typeName then\n      let numArgs := e.getAppNumArgs\n      let arity := projInfo.numParams + 1\n      if numArgs < arity then\n        visit (\u2190 etaExpandN e (arity - numArgs))\n      else\n        visitAppDefaultConst e.getAppFn e.getAppArgs\n    else\n      let .const declName us := e.getAppFn | unreachable!\n      let info \u2190 getConstInfo declName\n      let f \u2190 Core.instantiateValueLevelParams info us\n      visit (f.beta e.getAppArgs)\n\n  visitApp (e : Expr) : M Arg := do\n    if let .const declName _ := e.getAppFn then\n      if declName == ``Quot.lift then\n        visitQuotLift e\n      else if declName == ``Quot.mk then\n        visitCtor 3 e\n      else if declName == ``Eq.casesOn || declName == ``Eq.rec || declName == ``Eq.ndrec then\n        visitEqRec e\n      else if declName == ``And.rec || declName == ``Iff.rec then\n        visitAndIffRecCore e (minorPos := 3)\n      else if declName == ``And.casesOn || declName == ``Iff.casesOn then\n        visitAndIffRecCore e (minorPos := 4)\n      else if declName == ``False.rec || declName == ``Empty.rec || declName == ``False.casesOn || declName == ``Empty.casesOn then\n        visitFalseRec e\n      else if let some casesInfo \u2190 getCasesInfo? declName then\n        visitCases casesInfo e\n      else if let some arity \u2190 getCtorArity? declName then\n        visitCtor arity e\n      else if isNoConfusion (\u2190 getEnv) declName then\n        visitNoConfusion e\n      else if let some projInfo \u2190 getProjectionFnInfo? declName then\n        visitProjFn projInfo e\n      else\n        e.withApp visitAppDefaultConst\n    else\n      e.withApp fun f args => do\n        match (\u2190 visit f) with\n        | .erased | .type .. => return .erased\n        | .fvar fvarId =>\n          let args \u2190 args.mapM visitAppArg\n          letValueToArg <| .fvar fvarId args\n\n  visitLambda (e : Expr) : M Arg := do\n    let b := etaReduceImplicit e\n    \n    if !b.isLambda && !mustEtaExpand (\u2190 getEnv) b then\n      \n      visit b\n    else\n      let funDecl \u2190 withNewScope do\n        let (ps, e) \u2190 ToLCNF.visitLambda e\n        let e \u2190 visit e\n        let c \u2190 toCode e\n        mkAuxFunDecl ps c\n      pushElement (.fun funDecl)\n      return .fvar funDecl.fvarId\n\n  visitMData (mdata : MData) (e : Expr) : M Arg := do\n    if let some (.app (.lam n t b ..) v) := letFunAnnotation? (.mdata mdata e) then\n      visitLet (.letE n t v b (nonDep := true)) #[]\n    else\n      visit e\n\n  visitProj (s : Name) (i : Nat) (e : Expr) : M Arg := do\n    match (\u2190 visit e) with\n    | .erased | .type .. => return .erased\n    | .fvar fvarId => letValueToArg <| .proj s i fvarId\n\n  visitLet (e : Expr) (xs : Array Expr) : M Arg := do\n    match e with\n    | .letE binderName type value body _ =>\n      let type := type.instantiateRev xs\n      let value := value.instantiateRev xs\n      if (\u2190 (liftMetaM <| Meta.isProp type) <||> isTypeFormerType type) then\n        visitLet body (xs.push value)\n      else\n        let type' \u2190 toLCNFType type\n        let letDecl \u2190 mkLetDecl binderName type value type' (\u2190 visit value)\n        visitLet body (xs.push (.fvar letDecl.fvarId))\n    | _ =>\n      let e := e.instantiateRev xs\n      visit e", "start": [409, 1], "end": [752, 14], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ReduceArity.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Internalize.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.FindUsed.Context", "code": "structure Context where\n  decl : Decl\n  params : FVarIdSet", "start": [52, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FindUsed.State", "code": "structure State where\n  used : FVarIdSet := {}", "start": [56, 1], "end": [57, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FindUsed.FindUsedM", "code": "abbrev FindUsedM := ReaderT Context <| StateRefT State CompilerM", "start": [59, 1], "end": [59, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FindUsed.visitFVar", "code": "def visitFVar (fvarId : FVarId) : FindUsedM Unit := do\n  if (\u2190 read).params.contains fvarId then\n    modify fun s => { s with used := s.used.insert fvarId }", "start": [61, 1], "end": [63, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FindUsed.visitArg", "code": "def visitArg (arg : Arg) : FindUsedM Unit := do\n  match arg with\n  | .erased | .type .. => return ()\n  | .fvar fvarId => visitFVar fvarId", "start": [65, 1], "end": [68, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FindUsed.visitLetValue", "code": "def visitLetValue (e : LetValue) : FindUsedM Unit := do\n  match e with\n  | .erased | .value .. => return ()\n  | .proj _ _ fvarId => visitFVar fvarId\n  | .fvar fvarId args => visitFVar fvarId; args.forM visitArg\n  | .const declName _ args =>\n    let decl := (\u2190 read).decl\n    if declName == decl.name then\n      for param in decl.params, arg in args do\n        match arg with\n        | .fvar fvarId =>\n          unless fvarId == param.fvarId do\n            visitFVar fvarId\n        | .erased | .type .. => pure ()\n      for arg in args[decl.params.size:] do\n        visitArg arg\n      for param in decl.params[args.size:] do\n        visitFVar param.fvarId\n    else\n      args.forM visitArg", "start": [70, 1], "end": [92, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FindUsed.visit", "code": "partial def visit (code : Code) : FindUsedM Unit := do\n  match code with\n  | .let decl k =>\n    visitLetValue decl.value\n    visit k\n  | .jp decl k | .fun decl k =>\n    visit decl.value; visit k\n  | .cases c =>\n    visitFVar c.discr\n    c.alts.forM fun alt => visit alt.getCode\n  | .jmp _ args => args.forM visitArg\n  | .return fvarId => visitFVar fvarId\n  | .unreach _ => return ()", "start": [94, 1], "end": [106, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FindUsed.collectUsedParams", "code": "def collectUsedParams (decl : Decl) : CompilerM FVarIdSet := do\n  let params := decl.params.foldl (init := {}) fun s p => s.insert p.fvarId\n  let (_, { used, .. }) \u2190 visit decl.value |>.run { decl, params } |>.run {}\n  return used", "start": [108, 1], "end": [111, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ReduceArity.Context", "code": "structure Context where\n  declName : Name\n  auxDeclName : Name\n  paramMask : Array Bool", "start": [117, 1], "end": [120, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ReduceArity.ReduceM", "code": "abbrev ReduceM := ReaderT Context CompilerM", "start": [122, 1], "end": [122, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ReduceArity.reduce", "code": "partial def reduce (code : Code) : ReduceM Code := do\n  match code with\n  | .let decl k =>\n    let .const declName _ args := decl.value | do return code.updateLet! decl (\u2190 reduce k)\n    unless declName == (\u2190 read).declName do return code.updateLet! decl (\u2190 reduce k)\n    let mut argsNew := #[]\n    for used in (\u2190 read).paramMask, arg in args do\n      if used then\n        argsNew := argsNew.push arg\n    let decl \u2190 decl.updateValue (.const (\u2190 read).auxDeclName [] argsNew)\n    return code.updateLet! decl (\u2190 reduce k)\n  | .fun decl k | .jp decl k =>\n    let decl \u2190 decl.updateValue (\u2190 reduce decl.value)\n    return code.updateFun! decl (\u2190 reduce k)\n  | .cases c =>\n    let alts \u2190 c.alts.mapMonoM fun alt => return alt.updateCode (\u2190 reduce alt.getCode)\n    return code.updateAlts! alts\n  | .unreach .. | .jmp .. | .return .. => return code", "start": [124, 1], "end": [141, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.reduceArity", "code": "def Decl.reduceArity (decl : Decl) : CompilerM (Array Decl) := do\n  let used \u2190 collectUsedParams decl\n  if used.size == decl.params.size then\n    return #[decl] else\n    trace[Compiler.reduceArity] \"{decl.name}, used params: {used.toList.map mkFVar}\"\n    let mask   := decl.params.map fun param => used.contains param.fvarId\n    let auxName   := decl.name ++ `_redArg\n    let mkAuxDecl : CompilerM Decl := do\n      let params := decl.params.filter fun param => used.contains param.fvarId\n      let value  \u2190 reduce decl.value |>.run { declName := decl.name, auxDeclName := auxName, paramMask := mask }\n      let type \u2190 value.inferType\n      let type \u2190 mkForallParams params type\n      let auxDecl := { decl with name := auxName, levelParams := [], type, params, value }\n      auxDecl.saveMono\n      return auxDecl\n    let updateDecl : InternalizeM Decl := do\n      let params \u2190 decl.params.mapM internalizeParam\n      let mut args := #[]\n      for used in mask, param in params do\n        if used then\n          args := args.push param.toArg\n      let letDecl \u2190 mkAuxLetDecl (.const auxName [] args)\n      let value := .let letDecl (.return letDecl.fvarId)\n      let decl := { decl with params, value, inlineAttr? := some .inline, recursive := false }\n      decl.saveMono\n      return decl\n    let unusedParams := decl.params.filter fun param => !used.contains param.fvarId\n    let auxDecl \u2190 mkAuxDecl\n    let decl \u2190 updateDecl |>.run' {}\n    eraseParams unusedParams\n    return #[auxDecl, decl]", "start": [147, 1], "end": [178, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.reduceArity", "code": "def reduceArity : Pass where\n  phase := .mono\n  name  := `reduceArity\n  run   := fun decls => do\n    decls.foldlM (init := #[]) fun decls decl => return decls ++ (\u2190 decl.reduceArity)", "start": [180, 1], "end": [184, 86], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/LambdaLifting.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/InlineAttrs.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/AuxDeclCache.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Level.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Closure.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/MonadScope.lean", "lake-packages/lean4/src/lean/Lean/Meta/Instances.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Internalize.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.LambdaLifting.Context", "code": "structure Context where\n  \n  liftInstParamOnly : Bool := false\n  \n  suffix : Name\n  \n  mainDecl : Decl\n  \n  inheritInlineAttrs := false\n  \n  minSize : Nat := 0", "start": [18, 1], "end": [41, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LambdaLifting.State", "code": "structure State where\n  \n  decls  : Array Decl := #[]\n  \n  nextIdx := 0", "start": [44, 1], "end": [53, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LambdaLifting.LiftM", "code": "abbrev LiftM := ReaderT Context (StateRefT State (ScopeT CompilerM))", "start": [55, 1], "end": [56, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LambdaLifting.hasInstParam", "code": "def hasInstParam (decl : FunDecl) : CompilerM Bool :=\n  decl.params.anyM fun param => return (\u2190 isArrowClass? param.type).isSome", "start": [58, 1], "end": [63, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LambdaLifting.shouldLift", "code": "def shouldLift (decl : FunDecl) : LiftM Bool := do\n  let minSize := (\u2190 read).minSize\n  if decl.value.size < minSize then\n    return false\n  else if (\u2190 read).liftInstParamOnly then\n    hasInstParam decl\n  else\n    return true", "start": [65, 1], "end": [75, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LambdaLifting.mkAuxDeclName", "code": "partial def mkAuxDeclName : LiftM Name := do\n  let nextIdx \u2190 modifyGet fun s => (s.nextIdx, { s with nextIdx := s.nextIdx + 1})\n  let nameNew := (\u2190 read).mainDecl.name ++ (\u2190 read).suffix.appendIndexAfter nextIdx\n  if (\u2190 getDecl? nameNew).isNone then return nameNew\n  mkAuxDeclName", "start": [77, 1], "end": [81, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LambdaLifting.mkAuxDecl", "code": "def mkAuxDecl (closure : Array Param) (decl : FunDecl) : LiftM LetDecl := do\n  let nameNew \u2190 mkAuxDeclName\n  let inlineAttr? := if (\u2190 read).inheritInlineAttrs then (\u2190 read).mainDecl.inlineAttr? else none\n  let auxDecl \u2190 go nameNew (\u2190 read).mainDecl.safe inlineAttr? |>.run' {}\n  let us := auxDecl.levelParams.map mkLevelParam\n  let auxDeclName \u2190 match (\u2190 cacheAuxDecl auxDecl) with\n  | .new =>\n    auxDecl.save\n    modify fun { decls, .. } => { decls := decls.push auxDecl }\n    pure auxDecl.name\n  | .alreadyCached declName =>\n    auxDecl.erase\n    pure declName\n  let value := .const auxDeclName us (closure.map (.fvar \u00b7.fvarId))\n  \n  let declNew := { fvarId := decl.fvarId, binderName := decl.binderName, type := decl.type, value }\n  modifyLCtx fun lctx => lctx.addLetDecl declNew\n  eraseFunDecl decl\n  return declNew\nwhere\n  go (nameNew : Name) (safe : Bool) (inlineAttr? : Option InlineAttributeKind) : InternalizeM Decl := do\n    let params := (\u2190 closure.mapM internalizeParam) ++ (\u2190 decl.params.mapM internalizeParam)\n    let value \u2190 internalizeCode decl.value\n    let type \u2190 value.inferType\n    let type \u2190 mkForallParams params type\n    let decl := { name := nameNew, levelParams := [], params, type, value, safe, inlineAttr?, recursive := false : Decl }\n    return decl.setLevelParams", "start": [84, 1], "end": [114, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LambdaLifting.visitFunDecl", "code": "partial def visitFunDecl (funDecl : FunDecl) : LiftM FunDecl := do\n    let value \u2190 withParams funDecl.params <| visitCode funDecl.value\n    funDecl.update' funDecl.type value", "start": [117, 3], "end": [119, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LambdaLifting.visitCode", "code": "partial def visitCode (code : Code) : LiftM Code := do\n    match code with\n    | .let decl k =>\n      let k \u2190 withFVar decl.fvarId <| visitCode k\n      return code.updateLet! decl k\n    | .fun decl k =>\n      let decl \u2190 visitFunDecl decl\n      if (\u2190 shouldLift decl) then\n        let scope \u2190 getScope\n        let (_, params, _) \u2190 Closure.run (inScope := scope.contains) <| Closure.collectFunDecl decl\n        let declNew \u2190 mkAuxDecl params decl\n        let k \u2190 withFVar declNew.fvarId <| visitCode k\n        return .let declNew k\n      else\n        let k \u2190 withFVar decl.fvarId <| visitCode k\n        return code.updateFun! decl k\n    | .jp decl k =>\n      let decl \u2190 visitFunDecl decl\n      let k \u2190 withFVar decl.fvarId <| visitCode k\n      return code.updateFun! decl k\n    | .cases c =>\n      let alts \u2190 c.alts.mapMonoM fun alt =>\n        match alt with\n        | .default k => return alt.updateCode (\u2190 visitCode k)\n        | .alt _ ps k => withParams ps do return alt.updateCode (\u2190 visitCode k)\n      return code.updateAlts! alts\n    | .unreach .. | .jmp .. | .return .. => return code", "start": [121, 3], "end": [147, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LambdaLifting.main", "code": "def main (decl : Decl) : LiftM Decl := do\n  let value \u2190 withParams decl.params <| visitCode decl.value\n  return { decl with value }", "start": [150, 1], "end": [152, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.lambdaLifting", "code": "partial def Decl.lambdaLifting (decl : Decl) (liftInstParamOnly : Bool) (suffix : Name) (inheritInlineAttrs := false) (minSize := 0) : CompilerM (Array Decl) := do\n  let (decl, s) \u2190 LambdaLifting.main decl |>.run { mainDecl := decl, liftInstParamOnly, suffix, inheritInlineAttrs, minSize } |>.run {} |>.run {}\n  return s.decls.push decl", "start": [156, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.lambdaLifting", "code": "def lambdaLifting : Pass where\n  phase      := .mono\n  name       := `lambdaLifting\n  run        := fun decls => do\n    decls.foldlM (init := #[]) fun decls decl => return decls ++ (\u2190 decl.lambdaLifting false (suffix := `_lam))", "start": [160, 1], "end": [167, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eagerLambdaLifting", "code": "def eagerLambdaLifting : Pass where\n  phase      := .base\n  name       := `eagerLambdaLifting\n  run        := fun decls => do\n    decls.foldlM (init := #[]) fun decls decl => do\n      if (\u2190 Meta.isInstance decl.name) then\n        \n        return decls ++ (\u2190 decl.lambdaLifting (liftInstParamOnly := false) (suffix := `_elam) (inheritInlineAttrs := true) (minSize := 3))\n      else\n        return decls ++ (\u2190 decl.lambdaLifting (liftInstParamOnly := true) (suffix := `_elam))", "start": [169, 1], "end": [190, 94], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Specialize.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Level.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToExpr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/MonadScope.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Closure.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/FVarUtil.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/SpecInfo.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Lean/Compiler/Specialize.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Specialize.Cache", "code": "abbrev Cache := SMap Expr Name", "start": [20, 1], "end": [20, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.CacheEntry", "code": "structure CacheEntry where\n  key : Expr\n  declName : Name\n  deriving Inhabited", "start": [22, 1], "end": [25, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.addEntry", "code": "def addEntry (cache : Cache) (e : CacheEntry) : Cache :=\n  cache.insert e.key e.declName", "start": [27, 1], "end": [28, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.cacheSpec", "code": "def cacheSpec (key : Expr) (declName : Name) : CoreM Unit :=\n  modifyEnv fun env => specCacheExt.addEntry env { key, declName }", "start": [36, 1], "end": [37, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.findSpecCache?", "code": "def findSpecCache? (key : Expr) : CoreM (Option Name) :=\n  return specCacheExt.getState (\u2190 getEnv) |>.find? key", "start": [39, 1], "end": [40, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.Context", "code": "structure Context where\n  \n  scope  : FVarIdSet := {}\n  \n  ground : FVarIdSet := {}\n  \n  declName : Name", "start": [42, 1], "end": [55, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.State", "code": "structure State where\n  decls : Array Decl := #[]", "start": [57, 1], "end": [58, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.SpecializeM", "code": "abbrev SpecializeM := ReaderT Context $ StateRefT State CompilerM", "start": [60, 1], "end": [60, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.isGround", "code": "def isGround [TraverseFVar \u03b1] (e : \u03b1) : SpecializeM Bool := do\n  let s := (\u2190 read).ground\n  return allFVar (s.contains \u00b7) e", "start": [66, 1], "end": [72, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.withLetDecl", "code": "@[inline] def withLetDecl (decl : LetDecl) (x : SpecializeM \u03b1) : SpecializeM \u03b1 := do\n  let grd \u2190 isGround decl.value\n  let fvarId := decl.fvarId\n  withReader (fun { scope, ground, declName } => { declName, scope := scope.insert fvarId, ground := if grd then ground.insert fvarId else ground }) x", "start": [74, 1], "end": [77, 151], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.Collector.collect", "code": "def collect (paramsInfo : Array SpecParamInfo) (args : Array Arg) : SpecializeM (Array (Option Arg) \u00d7 Array Param \u00d7 Array CodeDecl) := do\n  let ctx \u2190 read\n  let lctx := (\u2190 getThe CompilerM.State).lctx\n  let abstract (fvarId : FVarId) : Bool :=\n    !lctx.funDecls.contains fvarId && !ctx.ground.contains fvarId\n  Closure.run (inScope := ctx.scope.contains) (abstract := abstract) do\n    let mut argMask := #[]\n    for paramInfo in paramsInfo, arg in args do\n      match paramInfo with\n      | .other =>\n        argMask := argMask.push none\n      | .fixedNeutral | .user | .fixedInst | .fixedHO =>\n        argMask := argMask.push (some arg)\n        Closure.collectArg arg\n    return argMask", "start": [128, 1], "end": [152, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.shouldSpecialize", "code": "def shouldSpecialize (paramsInfo : Array SpecParamInfo) (args : Array Arg) : SpecializeM Bool := do\n  for paramInfo in paramsInfo, arg in args do\n    match paramInfo with\n    | .other => pure ()\n    | .fixedNeutral => pure () | .fixedInst | .user => if (\u2190 isGround arg) then return true\n    | .fixedHO => return true return false", "start": [156, 1], "end": [166, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.expandCodeDecls", "code": "def expandCodeDecls (decls : Array CodeDecl) (body : LetValue) : CompilerM Expr := do\n  let xs := decls.map (mkFVar \u00b7.fvarId)\n  let values := decls.map fun\n    | .let decl => decl.value.toExpr\n    | .fun decl | .jp decl => decl.toExpr\n  let rec go (i : Nat) (subst : Array Expr) : Expr :=\n    if h : i < values.size then\n      let value := values[i].abstractRange i xs\n      let value := value.instantiateRev subst\n      go (i+1) (subst.push value)\n    else\n      (body.toExpr.abstract xs).instantiateRev subst\n  return go 0 #[]\ntermination_by go => values.size - i", "start": [168, 1], "end": [185, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.mkKey", "code": "def mkKey (params : Array Param) (decls : Array CodeDecl) (body : LetValue) : CompilerM (Expr \u00d7 List Name) := do\n  let body \u2190 expandCodeDecls decls body\n  let key := ToExpr.run do\n    ToExpr.withParams params do\n      ToExpr.mkLambdaM params (\u2190 ToExpr.abstractM body)\n  return normLevelParams key", "start": [187, 1], "end": [198, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.mkSpecDecl", "code": "def mkSpecDecl (decl : Decl) (us : List Level) (argMask : Array (Option Arg)) (params : Array Param) (decls : Array CodeDecl) (levelParamsNew : List Name) : SpecializeM Decl := do\n  let nameNew := decl.name ++ `_at_ ++ (\u2190 read).declName.eraseMacroScopes ++ (`spec).appendIndexAfter (\u2190 get).decls.size\n  \n  let decl \u2190 decl.internalize\n  try\n    go decl nameNew |>.run' {}\n  finally\n    eraseDecl decl\nwhere\n  go (decl : Decl) (nameNew : Name) : InternalizeM Decl := do\n    let mut params \u2190 params.mapM internalizeParam\n    let decls \u2190 decls.mapM internalizeCodeDecl\n    for param in decl.params, arg in argMask do\n      if let some arg := arg then\n        let arg \u2190 normArg arg\n        modify fun s => s.insert param.fvarId arg.toExpr\n      else\n        let param := { param with type := param.type.instantiateLevelParamsNoCache decl.levelParams us }\n        params := params.push (\u2190 internalizeParam param)\n    for param in decl.params[argMask.size:] do\n      let param := { param with type := param.type.instantiateLevelParamsNoCache decl.levelParams us }\n      params := params.push (\u2190 internalizeParam param)\n    let value := decl.instantiateValueLevelParams us\n    let value \u2190 internalizeCode value\n    let value := attachCodeDecls decls value\n    let type \u2190 value.inferType\n    let type \u2190 mkForallParams params type\n    let safe := decl.safe\n    let recursive := decl.recursive\n    let decl := { name := nameNew, levelParams := levelParamsNew, params, type, value, safe, recursive, inlineAttr? := none : Decl }\n    return decl.setLevelParams", "start": [201, 1], "end": [245, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.getRemainingArgs", "code": "def getRemainingArgs (paramsInfo : Array SpecParamInfo) (args : Array Arg) : Array Arg := Id.run do\n  let mut result := #[]\n  for info in paramsInfo, arg in args do\n    if info matches .other then\n      result := result.push arg\n  return result ++ args[paramsInfo.size:]", "start": [247, 1], "end": [256, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.specializeApp?", "code": "partial def specializeApp? (e : LetValue) : SpecializeM (Option LetValue) := do\n    let .const declName us args := e | return none\n    if args.isEmpty then return none\n    if (\u2190 Meta.isInstance declName) then return none\n    let some paramsInfo \u2190 getSpecParamInfo? declName | return none\n    unless (\u2190 shouldSpecialize paramsInfo args) do return none\n    let some decl \u2190 getDecl? declName | return none\n    trace[Compiler.specialize.candidate] \"{e.toExpr}, {paramsInfo}\"\n    let (argMask, params, decls) \u2190 Collector.collect paramsInfo args\n    let keyBody := .const declName us (argMask.filterMap id)\n    let (key, levelParamsNew) \u2190 mkKey params decls keyBody\n    trace[Compiler.specialize.candidate] \"key: {key}\"\n    assert! !key.hasLooseBVars\n    assert! !key.hasFVar\n    let usNew := levelParamsNew.map mkLevelParam\n    let argsNew := params.map (.fvar \u00b7.fvarId) ++ getRemainingArgs paramsInfo args\n    if let some declName \u2190 findSpecCache? key then\n      trace[Compiler.specialize.step] \"cached: {declName}\"\n      return some (.const declName usNew argsNew)\n    else\n      let specDecl \u2190 mkSpecDecl decl us argMask params decls levelParamsNew\n      trace[Compiler.specialize.step] \"new: {specDecl.name}\"\n      cacheSpec key specDecl.name\n      specDecl.saveBase\n      let specDecl \u2190 specDecl.etaExpand\n      specDecl.saveBase\n      let specDecl \u2190 specDecl.simp {}\n      let specDecl \u2190 specDecl.simp { etaPoly := true, inlinePartial := true, implementedBy := true }\n      let value \u2190 withReader (fun _ => { declName := specDecl.name }) do\n         withParams specDecl.params <| visitCode specDecl.value\n      let specDecl := { specDecl with value }\n      modify fun s => { s with decls := s.decls.push specDecl }\n      return some (.const specDecl.name usNew argsNew)", "start": [259, 3], "end": [295, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.visitFunDecl", "code": "partial def visitFunDecl (funDecl : FunDecl) : SpecializeM FunDecl := do\n    let value \u2190 withParams funDecl.params <| visitCode funDecl.value\n    funDecl.update' funDecl.type value", "start": [297, 3], "end": [299, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.visitCode", "code": "partial def visitCode (code : Code) : SpecializeM Code := do\n    match code with\n    | .let decl k =>\n      let mut decl := decl\n      if let some value \u2190 specializeApp? decl.value then\n        decl \u2190 decl.updateValue value\n      let k \u2190 withLetDecl decl <| visitCode k\n      return code.updateLet! decl k\n    | .fun decl k | .jp decl k =>\n      let decl \u2190 visitFunDecl decl\n      let k \u2190 withFVar decl.fvarId <| visitCode k\n      return code.updateFun! decl k\n    | .cases c =>\n      let alts \u2190 c.alts.mapMonoM fun alt =>\n        match alt with\n        | .default k => return alt.updateCode (\u2190 visitCode k)\n        | .alt _ ps k => withParams ps do return alt.updateCode (\u2190 visitCode k)\n      return code.updateAlts! alts\n    | .unreach .. | .jmp .. | .return .. => return code", "start": [301, 3], "end": [319, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Specialize.main", "code": "def main (decl : Decl) : SpecializeM Decl := do\n  if (\u2190 decl.isTemplateLike) then\n    return decl\n  else\n    let value \u2190 withParams decl.params <| visitCode decl.value\n    return { decl with value }", "start": [323, 1], "end": [328, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.specialize", "code": "partial def Decl.specialize (decl : Decl) : CompilerM (Array Decl) := do\n  let (decl, s) \u2190 Specialize.main decl |>.run { declName := decl.name } |>.run {}\n  return s.decls.push decl", "start": [332, 1], "end": [334, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.specialize", "code": "def specialize : Pass where\n  phase := .base\n  name  := `specialize\n  run   := fun decls => do\n    saveSpecParamInfo decls\n    decls.foldlM (init := #[]) fun decls decl => return decls ++ (\u2190 decl.specialize)", "start": [336, 1], "end": [341, 85], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PullLetDecls.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/DependsOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.PullLetDecls.Context", "code": "structure Context where\n  isCandidateFn : LetDecl \u2192 FVarIdSet \u2192 CompilerM Bool\n  included : FVarIdSet := {}", "start": [14, 1], "end": [16, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.State", "code": "structure State where\n  toPull : Array LetDecl := #[]", "start": [18, 1], "end": [19, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.PullM", "code": "abbrev PullM := ReaderT Context $ StateRefT State CompilerM", "start": [21, 1], "end": [21, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.withFVar", "code": "@[inline] def withFVar (fvarId : FVarId) (x : PullM \u03b1) : PullM \u03b1 :=\n  withReader (fun ctx => { ctx with included := ctx.included.insert fvarId }) x", "start": [23, 1], "end": [24, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.withParams", "code": "@[inline] def withParams (ps : Array Param) (x : PullM \u03b1) : PullM \u03b1 :=\n  withReader (fun ctx => { ctx with included := ps.foldl (init := ctx.included) fun s p => s.insert p.fvarId }) x", "start": [26, 1], "end": [27, 114], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.withNewScope", "code": "@[inline] def withNewScope (x : PullM \u03b1) : PullM \u03b1 :=\n  withReader (fun ctx => { ctx with included := {} }) x", "start": [29, 1], "end": [30, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.withCheckpoint", "code": "partial def withCheckpoint (x : PullM Code) : PullM Code := do\n  let toPullSizeSaved := (\u2190 get).toPull.size\n  let c \u2190 withNewScope x\n  let toPull := (\u2190 get).toPull\n  let rec go (i : Nat) (included : FVarIdSet) : StateM (Array LetDecl) Code := do\n    if h : i < toPull.size then\n      let letDecl := toPull[i]\n      if letDecl.dependsOn included then\n        let c \u2190 go (i+1) (included.insert letDecl.fvarId)\n        return .let letDecl c\n      else\n        modify (\u00b7.push letDecl)\n        go (i+1) included\n    else\n      return c\n  let (c, keep) := go toPullSizeSaved (\u2190 read).included |>.run #[]\n  modify fun s => { s with toPull := s.toPull.shrink toPullSizeSaved ++ keep }\n  return c", "start": [32, 1], "end": [49, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.attachToPull", "code": "def attachToPull (c : Code) : PullM Code := do\n  let toPull := (\u2190 get).toPull\n  return toPull.foldr (init := c) fun decl c => .let decl c", "start": [51, 1], "end": [53, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.shouldPull", "code": "def shouldPull (decl : LetDecl) : PullM Bool := do\n  unless decl.dependsOn (\u2190 read).included do\n    if (\u2190 (\u2190 read).isCandidateFn decl (\u2190 read).included) then\n      modify fun s => { s with toPull := s.toPull.push decl }\n      return true\n  return false", "start": [55, 1], "end": [60, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.pullAlt", "code": "partial def pullAlt (alt : Alt) : PullM Alt :=\n    match alt with\n    | .default k => return alt.updateCode (\u2190 withNewScope <| pullDecls k)\n    | .alt _ params k => return alt.updateCode (\u2190 withNewScope <| withParams params <| pullDecls k)", "start": [63, 3], "end": [66, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.pullDecls", "code": "partial def pullDecls (code : Code) : PullM Code := do\n    match code with\n    | .cases c =>\n      withCheckpoint do\n        let alts \u2190 c.alts.mapMonoM pullAlt\n        return code.updateAlts! alts\n    | .let decl k =>\n      if (\u2190 shouldPull decl) then\n        pullDecls k\n      else\n        withFVar decl.fvarId do return code.updateCont! (\u2190 pullDecls k)\n    | .fun decl k | .jp decl k =>\n      withCheckpoint do\n        let value \u2190 withParams decl.params <| pullDecls decl.value\n        let decl \u2190 decl.updateValue value\n        withFVar decl.fvarId do return code.updateFun! decl (\u2190 pullDecls k)\n    | _ => return code", "start": [68, 3], "end": [84, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PullLetDecls.PullM.run", "code": "def PullM.run (x : PullM \u03b1) (isCandidateFn : LetDecl \u2192 FVarIdSet \u2192 CompilerM Bool) : CompilerM \u03b1 :=\n  x { isCandidateFn } |>.run' {}", "start": [88, 1], "end": [89, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.pullLetDecls", "code": "def Decl.pullLetDecls (decl : Decl) (isCandidateFn : LetDecl \u2192 FVarIdSet \u2192 CompilerM Bool) : CompilerM Decl := do\n  PullM.run (isCandidateFn := isCandidateFn) do\n    withParams decl.params do\n      let value \u2190 pullDecls decl.value\n      let value \u2190 attachToPull value\n      return { decl with value }", "start": [95, 1], "end": [100, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.pullInstances", "code": "def Decl.pullInstances (decl : Decl) : CompilerM Decl :=\n  decl.pullLetDecls fun letDecl candidates => do\n    if (\u2190 isClass? letDecl.type).isSome then\n      return true\n    else if let .proj _ _ fvarId := letDecl.value then\n      return candidates.contains fvarId\n    else\n      return false", "start": [102, 1], "end": [109, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.pullInstances", "code": "def pullInstances : Pass :=\n  .mkPerDeclaration `pullInstances Decl.pullInstances .base", "start": [111, 1], "end": [112, 60], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CSE.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToExpr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.CSE.State", "code": "structure State where\n  map   : PHashMap Expr FVarId := {}\n  subst : FVarSubst := {}", "start": [16, 1], "end": [18, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CSE.M", "code": "abbrev M := StateRefT State CompilerM", "start": [20, 1], "end": [20, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CSE.getSubst", "code": "@[inline] def getSubst : M FVarSubst :=\n  return (\u2190 get).subst", "start": [28, 1], "end": [29, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CSE.addEntry", "code": "@[inline] def addEntry (value : Expr) (fvarId : FVarId) : M Unit :=\n  modify fun s => { s with map := s.map.insert value fvarId }", "start": [31, 1], "end": [32, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CSE.withNewScope", "code": "@[inline] def withNewScope (x : M \u03b1) : M \u03b1 := do\n  let map := (\u2190 get).map\n  try x finally modify fun s => { s with map }", "start": [34, 1], "end": [36, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CSE.replaceLet", "code": "def replaceLet (decl : LetDecl) (fvarId : FVarId) : M Unit := do\n  eraseLetDecl decl\n  addFVarSubst decl.fvarId fvarId", "start": [38, 1], "end": [40, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CSE.replaceFun", "code": "def replaceFun (decl : FunDecl) (fvarId : FVarId) : M Unit := do\n  eraseFunDecl decl\n  addFVarSubst decl.fvarId fvarId", "start": [42, 1], "end": [44, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.cse", "code": "partial def _root_.Lean.Compiler.LCNF.Code.cse (code : Code) : CompilerM Code :=\n  go code |>.run' {}\nwhere\n  goFunDecl (decl : FunDecl) : M FunDecl := do\n    let type \u2190 normExpr decl.type\n    let params \u2190 normParams decl.params\n    let value \u2190 withNewScope do go decl.value\n    decl.update type params value\n\n  go (code : Code) : M Code := do\n    match code with\n    | .let decl k =>\n      let decl \u2190 normLetDecl decl\n      let key := decl.value.toExpr\n      match (\u2190 get).map.find? key with\n      | some fvarId =>\n        replaceLet decl fvarId\n        go k\n      | none =>\n        addEntry key decl.fvarId\n        return code.updateLet! decl (\u2190 go k)\n    | .fun decl k =>\n      let decl \u2190 goFunDecl decl\n      let value := decl.toExpr\n      match (\u2190 get).map.find? value with\n      | some fvarId' =>\n        replaceFun decl fvarId'\n        go k\n      | none =>\n        addEntry value decl.fvarId\n        return code.updateFun! decl (\u2190 go k)\n    | .jp decl k =>\n      let decl \u2190 goFunDecl decl\n      \n      return code.updateFun! decl (\u2190 go k)\n    | .cases c =>\n      withNormFVarResult (\u2190 normFVar c.discr) fun discr => do\n        let resultType \u2190 normExpr c.resultType\n        let alts \u2190 c.alts.mapMonoM fun alt => do\n          match alt with\n          | .alt _ ps k => withNewScope do\n            return alt.updateAlt! (\u2190 normParams ps) (\u2190 go k)\n          | .default k => withNewScope do return alt.updateCode (\u2190 go k)\n        return code.updateCases! resultType discr alts\n    | .return fvarId => withNormFVarResult (\u2190 normFVar fvarId) fun fvarId => return code.updateReturn! fvarId\n    | .jmp fvarId args => withNormFVarResult (\u2190 normFVar fvarId) fun fvarId => return code.updateJmp! fvarId (\u2190 normArgs args)\n    | .unreach .. => return code", "start": [46, 1], "end": [96, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.cse", "code": "def Decl.cse (decl : Decl) : CompilerM Decl := do\n  let value \u2190 decl.value.cse\n  return { decl with value }", "start": [100, 1], "end": [105, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.cse", "code": "def cse (phase : Phase := .base) (occurrence := 0) : Pass :=\n  .mkPerDeclaration `cse Decl.cse phase occurrence", "start": [107, 1], "end": [108, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/FloatLetIn.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/FVarUtil.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.FloatLetIn.Decision", "code": "inductive Decision where\n|\n  \n  arm (name : Name)\n| \n  default\n|\n  \n  dont\n|\n  \n  unknown\nderiving Hashable, BEq, Inhabited, Repr", "start": [15, 1], "end": [38, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.Decision.ofAlt", "code": "def Decision.ofAlt : Alt \u2192 Decision\n| .alt name _ _ => .arm name\n| .default _ => .default", "start": [40, 1], "end": [42, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.BaseFloatContext", "code": "structure BaseFloatContext where\n  \n  decls : List CodeDecl := []", "start": [44, 1], "end": [52, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.FloatState", "code": "structure FloatState where\n  \n  decision : HashMap FVarId Decision\n  \n  newArms : HashMap Decision (List CodeDecl)", "start": [54, 1], "end": [69, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.BaseFloatM", "code": "abbrev BaseFloatM :=  ReaderT BaseFloatContext CompilerM", "start": [71, 1], "end": [74, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.FloatM", "code": "abbrev FloatM := StateRefT FloatState BaseFloatM", "start": [76, 1], "end": [79, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.withNewCandidate", "code": "def withNewCandidate (decl : CodeDecl) (x : BaseFloatM \u03b1) : BaseFloatM \u03b1 :=\n  withReader (fun r => { r with decls := decl :: r.decls }) do\n    x", "start": [81, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.withNewScope", "code": "def withNewScope (x : BaseFloatM \u03b1) : BaseFloatM \u03b1 := do\n  withReader (fun _ => {}) do\n    x", "start": [88, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.ignore?", "code": "def ignore? (decl : LetDecl) : BaseFloatM Bool :=  do\n   if (\u2190 isArrowClass? decl.type).isSome then\n     return true\n   else if let .proj _ _ fvarId := decl.value then\n     return (\u2190 isArrowClass? (\u2190 getType fvarId)).isSome\n   else\n     return false", "start": [95, 1], "end": [106, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.initialDecisions", "code": "def initialDecisions (cs : Cases) : BaseFloatM (HashMap FVarId Decision) := do\n  let mut map := mkHashMap (\u2190 read).decls.length\n  let folder val acc := do\n    if let .let decl := val then\n      if (\u2190 ignore? decl) then\n        return acc.insert decl.fvarId .dont\n    return acc.insert val.fvarId .unknown\n\n  map \u2190 (\u2190 read).decls.foldrM (init := map) folder\n  if map.contains cs.discr then\n    map := map.insert cs.discr .dont\n  (_, map) \u2190 goCases cs |>.run map\n  return map\nwhere\n  goFVar (plannedDecision : Decision) (var : FVarId) : StateRefT (HashMap FVarId Decision) BaseFloatM Unit := do\n    if let some decision := (\u2190 get).find? var then\n      if decision == .unknown then\n        modify fun s => s.insert var plannedDecision\n      else if decision != plannedDecision then\n          modify fun s => s.insert var .dont\n      goAlt (alt : Alt) : StateRefT (HashMap FVarId Decision) BaseFloatM Unit :=\n    forFVarM (goFVar (.ofAlt alt)) alt\n  goCases (cs : Cases) : StateRefT (HashMap FVarId Decision) BaseFloatM Unit :=\n    cs.alts.forM goAlt", "start": [108, 1], "end": [143, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.initialNewArms", "code": "def initialNewArms (cs : Cases) : HashMap Decision (List CodeDecl) := Id.run do\n  let mut map := mkHashMap (cs.alts.size + 1)\n  map := map.insert .dont []\n  cs.alts.foldr (init := map) fun val acc => acc.insert (.ofAlt val) []", "start": [145, 1], "end": [152, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.dontFloat", "code": "def dontFloat (decl : CodeDecl) : FloatM Unit := do\n  forFVarM goFVar decl\n  modify fun s => { s with newArms := s.newArms.insert .dont (decl :: s.newArms.find! .dont) }\nwhere\n  goFVar (fvar : FVarId) : FloatM Unit := do\n    if (\u2190 get).decision.contains fvar then\n      modify fun s => { s with decision := s.decision.insert fvar .dont }", "start": [154, 1], "end": [176, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.float", "code": "def float (decl : CodeDecl) : FloatM Unit := do\n  let arm := (\u2190 get).decision.find! decl.fvarId\n  forFVarM (goFVar \u00b7 arm) decl\n  modify fun s => { s with newArms := s.newArms.insert arm (decl :: s.newArms.find! arm) }\nwhere\n  goFVar (fvar : FVarId) (arm : Decision) : FloatM Unit := do\n    let some decision := (\u2190 get).decision.find? fvar | return ()\n    if decision != arm then\n      modify fun s => { s with decision := s.decision.insert fvar .dont }\n    else if decision == .unknown then\n      modify fun s => { s with decision := s.decision.insert fvar arm }", "start": [178, 1], "end": [234, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FloatLetIn.floatLetIn", "code": "partial def floatLetIn (decl : Decl) : CompilerM Decl := do\n  let newValue \u2190 go decl.value |>.run {}\n  return { decl with value := newValue }\nwhere\n  \n  goCases : FloatM Unit := do\n    for decl in (\u2190 read).decls do\n      let currentDecision := (\u2190 get).decision.find! decl.fvarId\n      if currentDecision == .unknown then\n        \n        eraseCodeDecl decl\n      else if currentDecision == .dont then\n        dontFloat decl\n      else\n        float decl\n\n  go (code : Code) : BaseFloatM Code := do\n    match code with\n    | .let decl k =>\n      withNewCandidate (.let decl) do\n        go k\n    | .jp decl k =>\n      let value \u2190 withNewScope do\n        go decl.value\n      let decl \u2190 decl.updateValue value\n      withNewCandidate (.jp decl) do\n        go k\n    | .fun decl k =>\n      let value \u2190 withNewScope do\n        go decl.value\n      let decl \u2190 decl.updateValue value\n      withNewCandidate (.fun decl) do\n        go k\n    | .cases cs =>\n      let base := {\n        decision := (\u2190 initialDecisions cs)\n        newArms := initialNewArms cs\n      }\n      let (_, res) \u2190 goCases |>.run base\n      let remainders := res.newArms.find! .dont\n      let altMapper alt := do\n        let decision := .ofAlt alt\n        let newCode := res.newArms.find! decision\n        trace[Compiler.floatLetIn] \"Size of code that was pushed into arm: {repr decision} {newCode.length}\"\n        let fused \u2190 withNewScope do\n          go (attachCodeDecls newCode.toArray alt.getCode)\n        return alt.updateCode fused\n      let newAlts \u2190 cs.alts.mapM altMapper\n      let mut newCases := Code.updateCases! code cs.resultType cs.discr newAlts\n      return attachCodeDecls remainders.toArray newCases\n    | .jmp .. | .return .. | .unreach .. =>\n    return attachCodeDecls (\u2190 read).decls.toArray.reverse code", "start": [236, 1], "end": [298, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.floatLetIn", "code": "def Decl.floatLetIn (decl : Decl) : CompilerM Decl := do\n  FloatLetIn.floatLetIn decl", "start": [302, 1], "end": [303, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.floatLetIn", "code": "def floatLetIn (phase := Phase.base) (occurrence := 0) : Pass :=\n  .mkPerDeclaration `floatLetIn Decl.floatLetIn phase occurrence", "start": [305, 1], "end": [306, 65], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/JoinPoints.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ScopeM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PullFunDecls.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/FVarUtil.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.JoinPointFinder.CandidateInfo", "code": "structure CandidateInfo where\n  \n  arity : Nat\n  \n  associated : HashSet FVarId\n  deriving Inhabited", "start": [19, 1], "end": [32, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.FindState", "code": "structure FindState where\n  \n  candidates : HashMap FVarId CandidateInfo := .empty\n  \n  scope : HashSet FVarId := .empty", "start": [34, 1], "end": [46, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.ReplaceCtx", "code": "abbrev ReplaceCtx := HashMap FVarId Name", "start": [48, 1], "end": [48, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.FindM", "code": "abbrev FindM := ReaderT (Option FVarId) StateRefT FindState ScopeM", "start": [50, 1], "end": [50, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.ReplaceM", "code": "abbrev ReplaceM := ReaderT ReplaceCtx CompilerM", "start": [51, 1], "end": [51, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.findCandidate?", "code": "private def findCandidate? (fvarId : FVarId) : FindM (Option CandidateInfo) := do\n  return (\u2190 get).candidates.find? fvarId", "start": [53, 1], "end": [57, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.eraseCandidate", "code": "private partial def eraseCandidate (fvarId : FVarId) : FindM Unit := do\n  if let some info \u2190 findCandidate? fvarId then\n    modify (fun state => { state with candidates := state.candidates.erase fvarId })\n    info.associated.forM eraseCandidate", "start": [59, 1], "end": [66, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.modifyCandidates", "code": "private def modifyCandidates (f : HashMap FVarId CandidateInfo \u2192 HashMap FVarId CandidateInfo) : FindM Unit :=\n  modify (fun state => {state with candidates := f state.candidates })", "start": [68, 1], "end": [72, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg", "code": "private partial def removeCandidatesInArg (a : Arg) : FindM Unit := do\n  forFVarM eraseCandidate a", "start": [74, 1], "end": [78, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInLetValue", "code": "private partial def removeCandidatesInLetValue (e : LetValue) : FindM Unit := do\n  forFVarM eraseCandidate e", "start": [80, 1], "end": [84, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.addCandidate", "code": "private def addCandidate (fvarId : FVarId) (arity : Nat) : FindM Unit := do\n  let cinfo := { arity, associated := .empty }\n  modifyCandidates (fun cs => cs.insert fvarId cinfo )", "start": [86, 1], "end": [91, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.addDependency", "code": "private def addDependency (src : FVarId) (target : FVarId) : FindM Unit := do\n  if let some targetInfo \u2190 findCandidate? target then\n    modifyCandidates (fun cs => cs.insert target { targetInfo with associated := targetInfo.associated.insert src })\n  else\n    eraseCandidate src", "start": [93, 1], "end": [100, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.find", "code": "partial def find (decl : Decl) : CompilerM FindState := do\n  let (_, candidates) \u2190 go decl.value |>.run none |>.run {} |>.run' {}\n  return candidates\nwhere\n  go : Code \u2192 FindM Unit\n  | .let decl k => do\n    match k, decl.value with\n    | .return valId, .fvar fvarId args =>\n      args.forM removeCandidatesInArg\n      if let some candidateInfo \u2190 findCandidate? fvarId then\n        if valId != decl.fvarId || args.size != candidateInfo.arity then\n          eraseCandidate fvarId\n        else if let some upperCandidate \u2190 read then\n          if !(\u2190 isInScope fvarId) then\n            addDependency fvarId upperCandidate\n      else\n        eraseCandidate fvarId\n    | _, _ =>\n      removeCandidatesInLetValue decl.value\n      go k\n  | .fun decl k => do\n    withReader (fun _ => some decl.fvarId) do\n      withNewScope do\n        go decl.value\n    addCandidate decl.fvarId decl.getArity\n    addToScope decl.fvarId\n    go k\n  | .jp decl k => do\n    go decl.value\n    go k\n  | .jmp _ args => args.forM removeCandidatesInArg\n  | .return val => eraseCandidate val\n  | .cases c => do\n    eraseCandidate c.discr\n    c.alts.forM (\u00b7.forCodeM go)\n  | .unreach .. => return ()", "start": [102, 1], "end": [171, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointFinder.replace", "code": "partial def replace (decl : Decl) (state : FindState) : CompilerM Decl := do\n  let mapper := fun acc cname _ => do return acc.insert cname (\u2190 mkFreshJpName)\n  let replaceCtx : ReplaceCtx \u2190 state.candidates.foldM (init := .empty) mapper\n  let newValue \u2190 go decl.value |>.run replaceCtx\n  return { decl with value := newValue }\nwhere\n  go (code : Code) : ReplaceM Code := do\n    match code with\n    | .let decl k =>\n      match k, decl.value with\n      | .return valId, .fvar fvarId args =>\n        if valId == decl.fvarId then\n          if (\u2190 read).contains fvarId then\n            eraseLetDecl decl\n            return .jmp fvarId args\n          else\n            return code\n        else\n          return code\n      | _, _ => return Code.updateLet! code decl (\u2190 go k)\n    | .fun decl k =>\n      if let some replacement := (\u2190 read).find? decl.fvarId then\n        let newDecl := { decl with\n          binderName := replacement,\n          value := (\u2190 go decl.value)\n        }\n        modifyLCtx fun lctx => lctx.addFunDecl newDecl\n        return .jp newDecl (\u2190 go k)\n      else\n        let newDecl \u2190 decl.updateValue (\u2190 go decl.value)\n        return Code.updateFun! code newDecl (\u2190 go k)\n    | .jp decl k =>\n       let newDecl \u2190 decl.updateValue (\u2190 go decl.value)\n       return Code.updateFun! code newDecl (\u2190 go k)\n    | .cases cs =>\n      return Code.updateCases! code cs.resultType cs.discr (\u2190 cs.alts.mapM (\u00b7.mapCodeM go))\n    | .jmp .. | .return .. | .unreach .. =>\n      return code", "start": [173, 1], "end": [214, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.ExtendContext", "code": "structure ExtendContext where\n  \n  currentJp? : Option FVarId := none\n  \n  candidates : FVarIdSet := {}", "start": [222, 1], "end": [235, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.ExtendState", "code": "structure ExtendState where\n  \n  fvarMap : HashMap FVarId (HashMap FVarId Param) := {}", "start": [237, 1], "end": [246, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.ExtendM", "code": "abbrev ExtendM := ReaderT ExtendContext StateRefT ExtendState ScopeM", "start": [248, 1], "end": [251, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.replaceFVar", "code": "def replaceFVar (fvar : FVarId) : ExtendM FVarId := do\n  if (\u2190 read).candidates.contains fvar then\n    if let some currentJp := (\u2190 read).currentJp? then\n      if let some replacement := (\u2190 get).fvarMap.find! currentJp |>.find? fvar then\n        return replacement.fvarId\n  return fvar", "start": [253, 1], "end": [266, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.withNewCandidate", "code": "def withNewCandidate (fvar : FVarId) (x : ExtendM \u03b1) : ExtendM \u03b1 := do\n  addToScope fvar\n  if (\u2190 read).currentJp?.isSome then\n    withReader (fun ctx => { ctx with candidates := ctx.candidates.insert fvar }) do\n      x\n  else\n    x", "start": [268, 1], "end": [278, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.withNewCandidates", "code": "def withNewCandidates (fvars : Array FVarId) (x : ExtendM \u03b1) : ExtendM \u03b1 := do\n  if (\u2190 read).currentJp?.isSome then\n    let candidates := (\u2190 read).candidates\n    let folder (acc : FVarIdSet) (val : FVarId) := do\n      addToScope val\n      return acc.insert val\n    let newCandidates \u2190 fvars.foldlM (init := candidates) folder\n    withReader (fun ctx => { ctx with candidates := newCandidates }) do\n      x\n  else\n    x", "start": [280, 1], "end": [293, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.extendByIfNecessary", "code": "def extendByIfNecessary (fvar : FVarId) : ExtendM Unit := do\n  if let some currentJp := (\u2190 read).currentJp? then\n    let mut translator := (\u2190 get).fvarMap.find! currentJp\n    let candidates := (\u2190 read).candidates\n    if !(\u2190 isInScope fvar) && !translator.contains fvar && candidates.contains fvar then\n      let typ \u2190 getType fvar\n      let newParam \u2190 mkAuxParam typ\n      translator := translator.insert fvar newParam\n      modify fun s => { s with fvarMap := s.fvarMap.insert currentJp translator }", "start": [295, 1], "end": [321, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.mergeJpContextIfNecessary", "code": "def mergeJpContextIfNecessary (jp : FVarId) : ExtendM Unit := do\n  if (\u2190 read).currentJp?.isSome then\n    let additionalArgs := (\u2190 get).fvarMap.find! jp |>.toArray\n    for (fvar, _) in additionalArgs do\n      extendByIfNecessary fvar", "start": [323, 1], "end": [341, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.withNewFunScope", "code": "def withNewFunScope (decl : FunDecl) (x : ExtendM \u03b1): ExtendM \u03b1 := do\n  withReader (fun ctx => { ctx with currentJp? := none, candidates := {} }) do\n    withNewScope do\n      x", "start": [343, 1], "end": [351, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.withNewJpScope", "code": "def withNewJpScope (decl : FunDecl) (x : ExtendM \u03b1): ExtendM \u03b1 := do\n  withReader (fun ctx => { ctx with currentJp? := some decl.fvarId }) do\n    modify fun s => { s with fvarMap := s.fvarMap.insert decl.fvarId {} }\n    withNewScope do\n      withNewCandidates (decl.params.map (\u00b7.fvarId)) do\n        x", "start": [353, 1], "end": [365, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.withNewAltScope", "code": "def withNewAltScope (alt : Alt) (x : ExtendM \u03b1) : ExtendM \u03b1 := do\n  withBackTrackingScope do\n    withNewCandidates (alt.getParams.map (\u00b7.fvarId)) do\n      x", "start": [367, 1], "end": [376, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointContextExtender.extend", "code": "partial def extend (decl : Decl) : CompilerM Decl := do\n  let newValue \u2190 go decl.value |>.run {} |>.run' {} |>.run' {}\n  let decl := { decl with value := newValue }\n  decl.pullFunDecls\nwhere\n  goFVar (fvar : FVarId) : ExtendM FVarId := do\n    extendByIfNecessary fvar\n    replaceFVar fvar\n  go (code : Code) : ExtendM Code := do\n    match code with\n    | .let decl k =>\n      let decl \u2190 decl.updateValue (\u2190 mapFVarM goFVar decl.value)\n      withNewCandidate decl.fvarId do\n        return Code.updateLet! code decl (\u2190 go k)\n    | .jp decl k =>\n      let decl \u2190 withNewJpScope decl do\n        let value \u2190 go decl.value\n        let additionalParams := (\u2190 get).fvarMap.find! decl.fvarId |>.toArray |>.map Prod.snd\n        let newType := additionalParams.foldr (init := decl.type) (fun val acc => .forallE val.binderName val.type acc .default)\n        decl.update newType (additionalParams ++ decl.params) value\n      mergeJpContextIfNecessary decl.fvarId\n      withNewCandidate decl.fvarId do\n        return Code.updateFun! code decl (\u2190 go k)\n    | .fun decl k =>\n      let decl \u2190 withNewFunScope decl do\n        decl.updateValue (\u2190 go decl.value)\n      withNewCandidate decl.fvarId do\n        return Code.updateFun! code decl (\u2190 go k)\n    | .cases cs =>\n      extendByIfNecessary cs.discr\n      let discr \u2190 replaceFVar cs.discr\n      let visitor := fun alt => do\n        withNewAltScope alt do\n          alt.mapCodeM go\n      let alts \u2190 cs.alts.mapM visitor\n      return Code.updateCases! code cs.resultType discr alts\n    | .jmp fn args =>\n      let mut newArgs \u2190 args.mapM (mapFVarM goFVar)\n      let additionalArgs := (\u2190 get).fvarMap.find! fn |>.toArray |>.map Prod.fst\n      if let some _currentJp := (\u2190 read).currentJp? then\n        let f := fun arg => do\n          return .fvar (\u2190 goFVar arg)\n        newArgs := (\u2190additionalArgs.mapM f) ++ newArgs\n      else\n        newArgs := (additionalArgs.map .fvar) ++ newArgs\n      return Code.updateJmp! code fn newArgs\n    | .return var =>\n      extendByIfNecessary var\n      return Code.updateReturn! code (\u2190 replaceFVar var)\n    | .unreach .. => return code", "start": [378, 1], "end": [439, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointCommonArgs.AnalysisCtx", "code": "structure AnalysisCtx where\n  \n  jpScopes : FVarIdMap FVarIdSet := {}", "start": [445, 1], "end": [453, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointCommonArgs.AnalysisState", "code": "structure AnalysisState where\n  \n  jpJmpArgs : FVarIdMap FVarSubst := {}", "start": [455, 1], "end": [463, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointCommonArgs.ReduceAnalysisM", "code": "abbrev ReduceAnalysisM := ReaderT AnalysisCtx StateRefT AnalysisState ScopeM", "start": [465, 1], "end": [465, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointCommonArgs.ReduceActionM", "code": "abbrev ReduceActionM := ReaderT AnalysisState CompilerM", "start": [466, 1], "end": [466, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointCommonArgs.isInJpScope", "code": "def isInJpScope (jp : FVarId) (var : FVarId) : ReduceAnalysisM Bool := do\n  return (\u2190 read).jpScopes.find! jp |>.contains var", "start": [468, 1], "end": [469, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.JoinPointCommonArgs.reduce", "code": "partial def reduce (decl : Decl) : CompilerM Decl := do\n  let (_, analysis) \u2190 goAnalyze decl.value |>.run {} |>.run {} |>.run' {}\n  let newValue \u2190 goReduce decl.value |>.run analysis\n  return { decl with value := newValue }\nwhere\n  goAnalyzeFunDecl (fn : FunDecl) : ReduceAnalysisM Unit := do\n    withNewScope do\n      fn.params.forM (addToScope \u00b7.fvarId)\n      goAnalyze fn.value\n\n  goAnalyze (code : Code) : ReduceAnalysisM Unit := do\n    match code with\n    | .let decl k =>\n      addToScope decl.fvarId\n      goAnalyze k\n    | .jp decl k =>\n      goAnalyzeFunDecl decl\n      let scope \u2190 getScope\n      withReader (fun ctx => { ctx with jpScopes := ctx.jpScopes.insert decl.fvarId scope }) do\n        addToScope decl.fvarId\n        goAnalyze k\n    | .fun decl k =>\n      goAnalyzeFunDecl decl\n      addToScope decl.fvarId\n      goAnalyze k\n    | .cases cs =>\n      let visitor alt := do\n        withNewScope do\n          alt.getParams.forM (addToScope \u00b7.fvarId)\n          goAnalyze alt.getCode\n      cs.alts.forM visitor\n    | .jmp fn args =>\n      let decl \u2190 getFunDecl fn\n      if let some knownArgs := (\u2190 get).jpJmpArgs.find? fn then\n        let mut newArgs := knownArgs\n        for (param, arg) in decl.params.zip args do\n          if let some knownVal := newArgs.find? param.fvarId then\n            if arg.toExpr != knownVal then\n              newArgs := newArgs.erase param.fvarId\n        modify fun s => { s with jpJmpArgs := s.jpJmpArgs.insert fn newArgs }\n      else\n        let folder := fun acc (param, arg) => do\n          if (\u2190 allFVarM (isInJpScope fn) arg) then\n            return acc.insert param.fvarId arg.toExpr\n          else\n            return acc\n        let interestingArgs \u2190 decl.params.zip args |>.foldlM (init := {}) folder\n        modify fun s => { s with jpJmpArgs := s.jpJmpArgs.insert fn interestingArgs }\n    | .return .. | .unreach .. => return ()\n\n  goReduce (code : Code) : ReduceActionM Code := do\n    match code with\n    | .jp decl k =>\n      if let some reducibleArgs := (\u2190 read).jpJmpArgs.find? decl.fvarId then\n        let filter param := do\n          let erasable := reducibleArgs.contains param.fvarId\n          if erasable then\n            eraseParam param\n          return !erasable\n        let newParams \u2190 decl.params.filterM filter\n        let mut newValue \u2190 goReduce decl.value\n        newValue \u2190 replaceFVars newValue reducibleArgs false\n        let newType \u2190\n          if newParams.size != decl.params.size then\n            mkForallParams newParams (\u2190 newValue.inferType)\n          else\n            pure decl.type\n        let k \u2190 goReduce k\n        let decl \u2190 decl.update newType newParams newValue\n        return Code.updateFun! code decl k\n      else\n        return Code.updateFun! code decl (\u2190 goReduce k)\n    | .jmp fn args =>\n      let reducibleArgs := (\u2190 read).jpJmpArgs.find! fn\n      let decl \u2190 getFunDecl fn\n      let newParams := decl.params.zip args\n        |>.filter (!reducibleArgs.contains \u00b7.fst.fvarId)\n        |>.map Prod.snd\n      return Code.updateJmp! code fn newParams\n    | .let decl k =>\n      return Code.updateLet! code decl (\u2190 goReduce k)\n    | .fun decl k =>\n      let decl \u2190 decl.updateValue (\u2190 goReduce decl.value)\n      return Code.updateFun! code decl (\u2190 goReduce k)\n    | .cases cs =>\n      let alts \u2190 cs.alts.mapM (\u00b7.mapCodeM goReduce)\n      return Code.updateCases! code cs.resultType cs.discr alts\n    | .return .. | .unreach .. => return code", "start": [473, 1], "end": [598, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.findJoinPoints", "code": "def Decl.findJoinPoints (decl : Decl) : CompilerM Decl := do\n  let findResult \u2190 JoinPointFinder.find decl\n  trace[Compiler.findJoinPoints] \"Found: {findResult.candidates.size} jp candidates\"\n  JoinPointFinder.replace decl findResult", "start": [602, 1], "end": [609, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.findJoinPoints", "code": "def findJoinPoints : Pass :=\n  .mkPerDeclaration `findJoinPoints Decl.findJoinPoints .base", "start": [611, 1], "end": [612, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.extendJoinPointContext", "code": "def Decl.extendJoinPointContext (decl : Decl) : CompilerM Decl := do\n  JoinPointContextExtender.extend decl", "start": [617, 1], "end": [618, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.extendJoinPointContext", "code": "def extendJoinPointContext (occurrence : Nat := 0) (phase := Phase.mono) (_h : phase \u2260 .base := by simp): Pass :=\n  .mkPerDeclaration `extendJoinPointContext Decl.extendJoinPointContext phase (occurrence := occurrence)", "start": [620, 1], "end": [621, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.commonJoinPointArgs", "code": "def Decl.commonJoinPointArgs (decl : Decl) : CompilerM Decl := do\n  JoinPointCommonArgs.reduce decl", "start": [626, 1], "end": [627, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.commonJoinPointArgs", "code": "def commonJoinPointArgs : Pass :=\n  .mkPerDeclaration `commonJoinPointArgs Decl.commonJoinPointArgs .mono", "start": [629, 1], "end": [630, 72], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToMono.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/MonoTypes.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.ToMonoM.State", "code": "structure ToMonoM.State where\n  typeParams : FVarIdSet := {}", "start": [11, 1], "end": [12, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ToMonoM", "code": "abbrev ToMonoM := StateRefT ToMonoM.State CompilerM", "start": [14, 1], "end": [14, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Param.toMono", "code": "def Param.toMono (param : Param) : ToMonoM Param := do\n  if isTypeFormerType param.type then\n    modify fun { typeParams, .. } => { typeParams := typeParams.insert param.fvarId }\n  param.update (\u2190 toMonoType param.type)", "start": [16, 1], "end": [19, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isTrivialConstructorApp?", "code": "def isTrivialConstructorApp? (declName : Name) (args : Array Arg) : ToMonoM (Option LetValue) := do\n  let some (.ctorInfo ctorInfo) := (\u2190 getEnv).find? declName | return none\n  let some info \u2190 hasTrivialStructure? ctorInfo.induct | return none\n  return args[ctorInfo.numParams + info.fieldIdx]!.toLetValue", "start": [21, 1], "end": [24, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.argToMono", "code": "def argToMono (arg : Arg) : ToMonoM Arg := do\n  match arg with\n  | .erased | .type .. => return .erased\n  | .fvar fvarId =>\n    if (\u2190 get).typeParams.contains fvarId then\n      return .erased\n    else\n      return arg", "start": [26, 1], "end": [33, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ctorAppToMono", "code": "def ctorAppToMono (ctorInfo : ConstructorVal) (args : Array Arg) : ToMonoM LetValue := do\n  let argsNew : Array Arg \u2190 args[:ctorInfo.numParams].toArray.mapM fun arg => do\n    match arg with\n    | .type type => return .type (\u2190 toMonoType type)\n    | .fvar .. | .erased => return .erased\n  let argsNew := argsNew ++ (\u2190 args[ctorInfo.numParams:].toArray.mapM argToMono)\n  return .const ctorInfo.name [] argsNew", "start": [35, 1], "end": [42, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.toMono", "code": "partial def LetValue.toMono (e : LetValue) : ToMonoM LetValue := do\n  match e with\n  | .erased | .value .. => return e\n  | .const declName _ args =>\n    if declName == ``Decidable.isTrue then\n      return .const ``Bool.true [] #[]\n    else if declName == ``Decidable.isFalse then\n      return .const ``Bool.false [] #[]\n    else if let some e' \u2190 isTrivialConstructorApp? declName args then\n      e'.toMono\n    else if let some (.ctorInfo ctorInfo) := (\u2190 getEnv).find? declName then\n      ctorAppToMono ctorInfo args\n    else\n      return .const declName [] (\u2190 args.mapM argToMono)\n  | .fvar fvarId args =>\n    if (\u2190 get).typeParams.contains fvarId then\n      return .erased\n    else\n      return .fvar fvarId (\u2190 args.mapM argToMono)\n  | .proj structName fieldIdx fvarId =>\n    if (\u2190 get).typeParams.contains fvarId then\n      return .erased\n    else if let some info \u2190 hasTrivialStructure? structName then\n      if info.fieldIdx == fieldIdx then\n        return .fvar fvarId #[]\n      else\n        return .erased\n    else\n      return e", "start": [44, 1], "end": [72, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl.toMono", "code": "def LetDecl.toMono (decl : LetDecl) : ToMonoM LetDecl := do\n  let type \u2190 toMonoType decl.type\n  let value \u2190 decl.value.toMono\n  decl.update type value", "start": [74, 1], "end": [77, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.toMono", "code": "partial def FunDeclCore.toMono (decl : FunDecl) : ToMonoM FunDecl := do\n  let type \u2190 toMonoType decl.type\n  let params \u2190 decl.params.mapM (\u00b7.toMono)\n  let value \u2190 decl.value.toMono\n  decl.update type params value", "start": [81, 1], "end": [85, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.decToMono", "code": "partial def decToMono (c : Cases) (_ : c.typeName == ``Decidable) : ToMonoM Code := do\n  let resultType \u2190 toMonoType c.resultType\n  let alts \u2190 c.alts.mapM fun alt => do\n    match alt with\n    | .default k => return alt.updateCode (\u2190 k.toMono)\n    | .alt ctorName ps k =>\n      eraseParams ps\n      let ctorName := if ctorName == ``Decidable.isTrue then ``Bool.true else ``Bool.false\n      return .alt ctorName #[] (\u2190 k.toMono)\n  return .cases { c with resultType, alts, typeName := ``Bool }", "start": [87, 1], "end": [97, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.trivialStructToMono", "code": "partial def trivialStructToMono (info : TrivialStructureInfo) (c : Cases) : ToMonoM Code := do\n  assert! c.alts.size == 1\n  let .alt ctorName ps k := c.alts[0]! | unreachable!\n  assert! ctorName == info.ctorName\n  assert! info.fieldIdx < ps.size\n  let p := ps[info.fieldIdx]!\n  eraseParams ps\n  \n  let decl := { fvarId := p.fvarId, binderName := p.binderName, type := (\u2190 toMonoType p.type), value := .fvar c.discr #[] }\n  modifyLCtx fun lctx => lctx.addLetDecl decl\n  let k \u2190 k.toMono\n  return .let decl k", "start": [99, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.toMono", "code": "partial def Code.toMono (code : Code) : ToMonoM Code := do\n  match code with\n  | .let decl k => return code.updateLet! (\u2190 decl.toMono) (\u2190 k.toMono)\n  | .fun decl k | .jp decl k => return code.updateFun! (\u2190 decl.toMono) (\u2190 k.toMono)\n  | .unreach type => return .unreach (\u2190 toMonoType type)\n  | .return .. | .jmp .. => return code\n  | .cases c =>\n    if h : c.typeName == ``Decidable then\n      decToMono c h\n    else if let some info \u2190 hasTrivialStructure? c.typeName then\n      trivialStructToMono info c\n    else\n      let type \u2190 toMonoType c.resultType\n      let alts \u2190 c.alts.mapM fun alt =>\n        match alt with\n        | .default k => return alt.updateCode (\u2190 k.toMono)\n        | .alt _ ps k => return alt.updateAlt! (\u2190 ps.mapM (\u00b7.toMono)) (\u2190 k.toMono)\n      return code.updateCases! type c.discr alts", "start": [113, 1], "end": [131, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.toMono", "code": "def Decl.toMono (decl : Decl) : CompilerM Decl := do\n  go |>.run' {}\nwhere\n  go : ToMonoM Decl := do\n    let type \u2190 toMonoType decl.type\n    let params \u2190 decl.params.mapM (\u00b7.toMono)\n    let value \u2190 decl.value.toMono\n    let decl := { decl with type, params, value, levelParams := [] }\n    decl.saveMono\n    return decl", "start": [135, 1], "end": [144, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.toMono", "code": "def toMono : Pass where\n  name     := `toMono\n  run      := fun decls => do\n    let decls \u2190 decls.filterM fun decl => do\n      if hasLocalInst decl.type then\n        \n        decl.erase\n        return false\n      else\n        return true\n    decls.mapM (\u00b7.toMono)\n  phase    := .base\n  phaseOut := .mono", "start": [146, 1], "end": [161, 20], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ElimDeadBranches.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value", "code": "inductive Value where\n  \n  | bot\n  \n  | top\n  \n  | ctor (i : Name) (vs : Array Value)\n  \n  | choice (vs : List Value)\n  deriving Inhabited, Repr", "start": [15, 1], "end": [36, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.maxValueDepth", "code": "def maxValueDepth := 8", "start": [41, 1], "end": [41, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.beq", "code": "protected partial def beq : Value \u2192 Value \u2192 Bool\n| bot, bot => true\n| top, top => true\n| ctor i1 vs1 , ctor i2 vs2 =>\n  i1 == i2 && Array.isEqv vs1 vs2 Value.beq\n| choice vs1 , choice vs2 =>\n  let isSubset as bs := as.all (fun a => bs.any fun b => Value.beq a b)\n  isSubset vs1 vs2 && isSubset vs2 vs1\n| _, _ => false", "start": [43, 1], "end": [51, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.addChoice", "code": "partial def addChoice (vs : List Value) (v : Value) : List Value :=\n  match vs, v with\n  | [], v => [v]\n  | v1@(ctor i1 _ ) :: cs, ctor i2 _ =>\n    if i1 == i2 then\n      (merge v1 v) :: cs\n    else\n      v1 :: addChoice cs v\n  | _, _ => panic! \"invalid addChoice\"", "start": [57, 1], "end": [71, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.merge", "code": "partial def merge (v1 v2 : Value) : Value :=\n  match v1, v2 with\n  | bot, v | v, bot => v\n  | top, _ | _, top => top\n  | ctor i1 vs1, ctor i2 vs2 =>\n    if i1 == i2 then\n      ctor i1 (vs1.zipWith vs2 merge)\n    else\n      choice [v1, v2]\n  | choice vs1, choice vs2 =>\n    choice (vs1.foldl addChoice vs2)\n  | choice vs, v | v, choice vs =>\n    choice (addChoice vs v)", "start": [73, 1], "end": [88, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.truncate", "code": "partial def truncate (env : Environment) (v : Value) : Value :=\n  go v {} maxValueDepth\nwhere\n  go (v : Value) (forbiddenTypes : NameSet) (remainingDepth : Nat) :=\n    match remainingDepth with\n    | 0 => top\n    | remainingDepth + 1 =>\n      match v with\n      | ctor i vs =>\n        let typeName := i.getPrefix\n        if forbiddenTypes.contains typeName then\n          top\n        else\n          let cont forbiddenTypes' :=\n            ctor i (vs.map (go \u00b7 forbiddenTypes' remainingDepth))\n          match env.find? typeName with\n          | some (.inductInfo type) =>\n            if type.isRec then\n              cont <| forbiddenTypes.insert typeName\n            else\n              cont forbiddenTypes\n          | _ => cont forbiddenTypes\n      | choice vs =>\n        let vs := vs.map (go \u00b7 forbiddenTypes remainingDepth)\n        if vs.elem top then\n          top\n        else\n          choice vs\n      | v => v", "start": [92, 1], "end": [126, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.widening", "code": "def widening (env : Environment) (v1 v2 : Value) : Value :=\n  truncate env (merge v1 v2)", "start": [128, 1], "end": [130, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.containsCtor", "code": "partial def containsCtor : Value \u2192 Name \u2192 Bool\n| .top .., _ => true\n| .bot .., _ => true | .ctor i ..,  j => i == j\n| .choice vs .., j => vs.any fun v => containsCtor v j", "start": [132, 1], "end": [142, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.getCtorArgs", "code": "partial def getCtorArgs : Value \u2192 Name \u2192 Option (Array Value)\n| .ctor i args ..,  j => if i == j then some args else none\n| .choice vs .., j => do\n  for variant in vs do\n    if let .ctor i args .. := variant then\n      if i == j then\n        return args\n  none\n| _, _ => none", "start": [144, 1], "end": [155, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.ofNat", "code": "partial def ofNat (n : Nat) : Value :=\n  if n > maxValueDepth then\n    goBig n n\n  else\n    goSmall n\nwhere\n  goBig (orig : Nat) (curr : Nat) : Value :=\n    if orig - curr == maxValueDepth then\n      .top\n    else\n      .ctor ``Nat.succ #[goBig orig (curr - 1)]\n  goSmall : Nat \u2192 Value\n  | 0 => .ctor ``Nat.zero #[]\n  | n + 1 => .ctor ``Nat.succ #[goSmall n]", "start": [157, 1], "end": [170, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.ofLCNFLit", "code": "def ofLCNFLit : LCNF.LitValue \u2192 Value\n| .natVal n => ofNat n\n| .strVal .. => .top", "start": [172, 1], "end": [175, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.proj", "code": "partial def proj : Value \u2192 Nat \u2192 Value\n| .ctor _ vs , i => vs.getD i bot\n| .choice vs, i => vs.foldl (fun r v => merge r (proj v i)) bot\n| v, _ => v", "start": [177, 1], "end": [180, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.isLiteral", "code": "partial def isLiteral : Value \u2192 Bool\n| .ctor _ vs => vs.all isLiteral\n| _ => false", "start": [182, 1], "end": [188, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Value.getLiteral", "code": "partial def getLiteral (v : Value) : CompilerM (Option ((Array CodeDecl) \u00d7 FVarId)) := do\n  if isLiteral v then\n    let literal \u2190 go v\n    return some literal\n  else\n    return none\nwhere\n  go : Value \u2192 CompilerM ((Array CodeDecl) \u00d7 FVarId)\n  | .ctor `Nat.zero #[] .. => do\n    let decl \u2190 mkAuxLetDecl <| .value <| .natVal <| 0\n    return (#[.let decl], decl.fvarId)\n  | .ctor `Nat.succ #[val] .. => do\n    let val := getNatConstant val + 1\n    let decl \u2190 mkAuxLetDecl <| .value <| .natVal <| val\n    return (#[.let decl], decl.fvarId)\n  | .ctor i vs => do\n    let args \u2190 vs.mapM go\n    let flatten acc := fun (decls, var) => (acc.fst ++ decls, acc.snd.push <| .fvar var)\n    let (decls, params) := args.foldl (init := (#[], Array.mkEmpty args.size)) flatten\n    let letVal : LetValue := .const i [] params\n    let letDecl \u2190 mkAuxLetDecl letVal\n    return (decls.push <| .let letDecl, letDecl.fvarId)\n  | _ => unreachable!\n\n  getNatConstant : Value \u2192 Nat\n  | .ctor `Nat.zero #[] .. => 0\n  | .ctor `Nat.succ #[val] .. => getNatConstant val + 1\n  | _ => panic! \"Not a well formed Nat constant Value\"", "start": [194, 1], "end": [226, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.FunctionSummaries", "code": "abbrev FunctionSummaries := PHashMap Name Value", "start": [230, 1], "end": [234, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.decLt", "code": "private abbrev decLt (a b : Name \u00d7 Value) : Bool :=\n  Name.quickLt a.fst b.fst", "start": [236, 1], "end": [237, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.findAtSorted?", "code": "private abbrev findAtSorted? (entries : Array (Name \u00d7 Value)) (fid : Name) : Option Value :=\n  entries.binSearch (fid, default) decLt |>.map Prod.snd", "start": [239, 1], "end": [240, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.addFunctionSummary", "code": "def addFunctionSummary (env : Environment) (fid : Name) (v : Value) : Environment :=\n  functionSummariesExt.addEntry (env.addExtraName fid) (fid, v)", "start": [252, 1], "end": [256, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.getFunctionSummary?", "code": "def getFunctionSummary? (env : Environment) (fid : Name) : Option Value :=\n  match env.getModuleIdxFor? fid with\n  | some modIdx => findAtSorted? (functionSummariesExt.getModuleEntries env modIdx) fid\n  | none        => functionSummariesExt.getState env |>.find? fid", "start": [258, 1], "end": [264, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.Assignment", "code": "abbrev Assignment := HashMap FVarId Value", "start": [266, 1], "end": [270, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.InterpContext", "code": "structure InterpContext where\n  \n  decls     : Array Decl\n  \n  currFnIdx : Nat := 0", "start": [272, 1], "end": [285, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.InterpState", "code": "structure InterpState where\n  \n  assignments : Array Assignment\n  \n  funVals     : PArray Value", "start": [287, 1], "end": [296, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.InterpM", "code": "abbrev InterpM := ReaderT InterpContext StateRefT InterpState CompilerM", "start": [298, 1], "end": [301, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.getAssignment", "code": "def getAssignment : InterpM Assignment := do\n  return (\u2190 get).assignments[(\u2190 read).currFnIdx]!", "start": [303, 1], "end": [307, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.getFunVal", "code": "def getFunVal (funIdx : Nat) : InterpM Value := do\n  return (\u2190 get).funVals[funIdx]!", "start": [309, 1], "end": [313, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.findFunVal?", "code": "def findFunVal? (declName : Name) : InterpM (Option Value) := do\n  match (\u2190 read).decls.findIdx? (\u00b7.name == declName) with\n  | some idx => return some (\u2190 getFunVal idx)\n  | none => return none", "start": [315, 1], "end": [318, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.modifyAssignment", "code": "def modifyAssignment (f : Assignment \u2192 Assignment) : InterpM Unit := do\n  let ctx \u2190 read\n  let currFnIdx := ctx.currFnIdx\n  modify fun s => { s with assignments := s.assignments.modify currFnIdx f }", "start": [320, 1], "end": [326, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.findVarValue", "code": "def findVarValue (var : FVarId) : InterpM Value := do\n  let assignment \u2190 getAssignment\n  return assignment.findD var .bot", "start": [328, 1], "end": [334, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.findArgValue", "code": "def findArgValue (arg : Arg) : InterpM Value := do\n  match arg with\n  | .fvar fvarId => findVarValue fvarId\n  | _ => return .top", "start": [336, 1], "end": [342, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.updateVarAssignment", "code": "def updateVarAssignment (var : FVarId) (newVal : Value) : InterpM Unit := do\n  let val \u2190 findVarValue var\n  let updatedVal := .merge val newVal\n  modifyAssignment (\u00b7.insert var updatedVal)", "start": [344, 1], "end": [350, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.resetVarAssignment", "code": "def resetVarAssignment (var : FVarId) : InterpM Unit := do\n  modifyAssignment (\u00b7.insert var .bot)", "start": [352, 1], "end": [356, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.updateCurrFnSummary", "code": "def updateCurrFnSummary (v : Value) : InterpM Unit := do\n  let ctx \u2190 read\n  let env \u2190 getEnv\n  let currFnIdx := ctx.currFnIdx\n  modify fun s => { s with funVals := s.funVals.modify currFnIdx (fun v' => .widening env v v') }", "start": [358, 1], "end": [365, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.updateFunDeclParamsAssignment", "code": "def updateFunDeclParamsAssignment (params : Array Param) (args : Array Arg) : InterpM Bool := do\n  let mut ret := false\n  for param in params, arg in args do\n    let paramVal \u2190 findVarValue param.fvarId\n    let argVal \u2190 findArgValue arg\n    let newVal := .merge paramVal argVal\n    if newVal != paramVal then\n      modifyAssignment (\u00b7.insert param.fvarId newVal)\n      ret := true\n  \n  if params.size != args.size then\n    for param in params[args.size:] do\n      ret := (\u2190 findVarValue param.fvarId) == .bot\n      updateVarAssignment param.fvarId .top\n  return ret", "start": [367, 1], "end": [392, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.resetNestedFunDeclParams", "code": "private partial def resetNestedFunDeclParams : Code \u2192 InterpM Unit\n| .let _ k => resetNestedFunDeclParams k\n| .jp decl k | .fun decl k => do\n  decl.params.forM (resetVarAssignment \u00b7.fvarId)\n  \n  resetNestedFunDeclParams k\n| .cases cs =>\n  cs.alts.forM (resetNestedFunDeclParams \u00b7.getCode)\n| .return .. | .unreach .. | .jmp .. => return ()", "start": [394, 1], "end": [403, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.interpCode", "code": "partial def interpCode : Code \u2192 InterpM Unit\n| .let decl k => do\n  let val \u2190 interpLetValue decl.value\n  updateVarAssignment decl.fvarId val\n  if let .fvar fvarId args := decl.value then\n    if let some funDecl \u2190 findFunDecl? fvarId then\n      interpFunCall funDecl args\n  interpCode k\n| .jp decl k | .fun decl k => do\n  interpCode decl.value\n  interpCode k\n| .jmp fn args => do\n  let jp \u2190 getFunDecl fn\n  args.forM handleFunArg\n  interpFunCall jp args\n| .cases cs => do\n  let discrVal \u2190 findVarValue cs.discr\n  for alt in cs.alts do\n    match alt with\n    | .alt ctor params body =>\n      if let some argValues := discrVal.getCtorArgs ctor then\n        params.zip argValues |>.forM (fun (param, val) => updateVarAssignment param.fvarId val)\n      else\n        params.forM (updateVarAssignment \u00b7.fvarId .top)\n      interpCode body\n    | .default body => interpCode body\n| .return var => do\n  handleFunVar var\n  let val \u2190 findVarValue var\n  updateCurrFnSummary val\n| .unreach .. => return ()\nwhere\n  \n  interpLetValue (letVal : LetValue) : InterpM Value := do\n    match letVal with\n    | .value val => return .ofLCNFLit val\n    | .proj _ idx struct => return (\u2190 findVarValue struct).proj idx\n    | .const declName _ args =>\n      let env \u2190 getEnv\n      args.forM handleFunArg\n      match (\u2190 getDecl? declName) with\n      | some decl =>\n        if decl.getArity == args.size then\n          match getFunctionSummary? env declName with\n          | some v => return v\n          | none => return (\u2190 findFunVal? declName).getD .top\n        else\n          return .top\n      | none =>\n        let some (.ctorInfo info) := env.find? declName | return .top\n        let args := args[info.numParams:].toArray\n        if info.numFields == args.size then\n          return .ctor declName (\u2190 args.mapM findArgValue)\n        else\n          return .top\n    | .fvar _ args =>\n      args.forM handleFunArg\n      \n      return .top\n    | .erased => return .top\n\n  handleFunArg (arg : Arg) : InterpM Unit := do\n    if let .fvar fvarId := arg then\n      handleFunVar fvarId\n\n  \n  handleFunVar (var : FVarId) : InterpM Unit := do\n    if let some funDecl \u2190 findFunDecl? var then\n      funDecl.params.forM (updateVarAssignment \u00b7.fvarId .top)\n      interpFunCall funDecl #[]\n\n  interpFunCall (funDecl : FunDecl) (args : Array Arg) : InterpM Unit := do\n    let updated \u2190 updateFunDeclParamsAssignment funDecl.params args\n    if updated then\n      \n      resetNestedFunDeclParams funDecl.value\n      interpCode funDecl.value", "start": [405, 1], "end": [498, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.inferStep", "code": "def inferStep : InterpM Bool := do\n  let ctx \u2190 read\n  for idx in [0:ctx.decls.size] do\n    let decl := ctx.decls[idx]!\n    if !decl.safe then\n      continue\n\n    let currentVal \u2190 getFunVal idx\n    withReader (fun ctx => { ctx with currFnIdx := idx }) do\n      decl.params.forM fun p => updateVarAssignment p.fvarId .top\n      interpCode decl.value\n    let newVal \u2190 getFunVal idx\n    if currentVal != newVal then\n      return true\n  return false", "start": [501, 1], "end": [519, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.inferMain", "code": "partial def inferMain : InterpM Unit := do\n  let ctx \u2190 read\n  modify fun s => { s with assignments := ctx.decls.map fun _ => {} }\n  let modified \u2190 inferStep\n  if modified then\n    inferMain\n  else\n    return ()", "start": [521, 1], "end": [531, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.UnreachableBranches.elimDead", "code": "partial def elimDead (assignment : Assignment) (decl : Decl) : CompilerM Decl := do\n  trace[Compiler.elimDeadBranches] s!\"Eliminating {decl.name} with {repr (\u2190 assignment.toArray |>.mapM (fun (name, val) => do return (toString (\u2190 getBinderName name), val)))}\"\n  return { decl with value := (\u2190 go decl.value) }\nwhere\n  go (code : Code) : CompilerM Code := do\n    match code with\n    | .let decl k =>\n      return code.updateLet! decl (\u2190 go k)\n    | .jp decl k | .fun decl k =>\n      return code.updateFun! (\u2190 decl.updateValue (\u2190 go decl.value)) (\u2190 go k)\n    | .cases cs =>\n      let discrVal := assignment.findD cs.discr .bot\n      let processAlt typ alt := do\n        match alt with\n        | .alt ctor args body =>\n          if discrVal.containsCtor ctor then\n            let filter param := do\n              if let some val := assignment.find? param.fvarId then\n                if let some literal \u2190 val.getLiteral then\n                  return some (param, literal)\n              return none\n            let constantInfos \u2190 args.filterMapM filter\n            if constantInfos.size != 0 then\n              let folder := fun (body, subst) (param, decls, var) => do\n                return (attachCodeDecls decls body, subst.insert param.fvarId (.fvar var))\n              let (body, subst) \u2190 constantInfos.foldlM (init := (\u2190 go body, {})) folder\n              let body \u2190 replaceFVars body subst false\n              return alt.updateCode body\n            else\n              return alt.updateCode (\u2190 go body)\n          else\n            trace[Compiler.elimDeadBranches] s!\"Threw away cases {\u2190 getBinderName cs.discr} branch {ctor}\"\n            eraseCode alt.getCode\n            return alt.updateCode <| .unreach typ\n        | .default body => return alt.updateCode (\u2190 go body)\n      return code.updateCases! cs.resultType cs.discr (\u2190 cs.alts.mapM <| processAlt cs.resultType)\n    | .jmp .. | .return .. | .unreach .. => return code", "start": [533, 1], "end": [574, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.elimDeadBranches", "code": "def Decl.elimDeadBranches (decls : Array Decl) : CompilerM (Array Decl) := do\n  let mut assignments := decls.map fun _ => {}\n  let initialVal i :=\n    \n    if decls[i]!.safe then .bot else .top\n  let mut funVals := decls.size.fold (init := .empty) fun i p => p.push (initialVal i)\n  let ctx := { decls }\n  let mut state := { assignments, funVals }\n  (_, state) \u2190 inferMain |>.run ctx |>.run state\n  funVals := state.funVals\n  assignments := state.assignments\n  modifyEnv fun e =>\n    decls.size.fold (init := e) fun i env =>\n      addFunctionSummary env decls[i]!.name funVals[i]!\n\n  decls.mapIdxM fun i decl => if decl.safe then elimDead assignments[i]! decl else return decl", "start": [579, 1], "end": [599, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.elimDeadBranches", "code": "def elimDeadBranches : Pass :=\n  { name := `elimDeadBranches, run := Decl.elimDeadBranches, phase := .mono }", "start": [601, 1], "end": [602, 78], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/FreeVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.MaxIndex.Collector", "code": "abbrev Collector := Index \u2192 Index", "start": [19, 1], "end": [19, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.skip", "code": "@[inline] private def skip : Collector := id", "start": [21, 1], "end": [21, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collect", "code": "@[inline] private def collect (x : Index) : Collector := fun y => if x > y then x else y", "start": [22, 1], "end": [22, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectVar", "code": "@[inline] private def collectVar (x : VarId) : Collector := collect x.idx", "start": [23, 1], "end": [23, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectJP", "code": "@[inline] private def collectJP (j : JoinPointId) : Collector := collect j.idx", "start": [24, 1], "end": [24, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.seq", "code": "@[inline] private def seq (k\u2081 k\u2082 : Collector) : Collector := k\u2082 \u2218 k\u2081", "start": [25, 1], "end": [25, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectArg", "code": "private def collectArg : Arg \u2192 Collector\n  | Arg.var x  => collectVar x\n  | _          => skip", "start": [29, 1], "end": [31, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectArray", "code": "private def collectArray {\u03b1 : Type} (as : Array \u03b1) (f : \u03b1 \u2192 Collector) : Collector :=\n  fun m => as.foldl (fun m a => f a m) m", "start": [33, 1], "end": [34, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectArgs", "code": "private def collectArgs (as : Array Arg) : Collector := collectArray as collectArg", "start": [36, 1], "end": [36, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectParam", "code": "private def collectParam (p : Param) : Collector := collectVar p.x", "start": [37, 1], "end": [37, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectParams", "code": "private def collectParams (ps : Array Param) : Collector := collectArray ps collectParam", "start": [38, 1], "end": [38, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectExpr", "code": "private def collectExpr : Expr \u2192 Collector\n  | Expr.ctor _ ys      => collectArgs ys\n  | Expr.reset _ x      => collectVar x\n  | Expr.reuse x _ _ ys => collectVar x >> collectArgs ys\n  | Expr.proj _ x       => collectVar x\n  | Expr.uproj _ x      => collectVar x\n  | Expr.sproj _ _ x    => collectVar x\n  | Expr.fap _ ys       => collectArgs ys\n  | Expr.pap _ ys       => collectArgs ys\n  | Expr.ap x ys        => collectVar x >> collectArgs ys\n  | Expr.box _ x        => collectVar x\n  | Expr.unbox x        => collectVar x\n  | Expr.lit _          => skip\n  | Expr.isShared x     => collectVar x", "start": [40, 1], "end": [53, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectAlts", "code": "private def collectAlts (f : FnBody \u2192 Collector) (alts : Array Alt) : Collector :=\n  collectArray alts fun alt => f alt.body", "start": [55, 1], "end": [56, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectFnBody", "code": "partial def collectFnBody : FnBody \u2192 Collector\n  | FnBody.vdecl x _ v b    => collectVar x >> collectExpr v >> collectFnBody b\n  | FnBody.jdecl j ys v b   => collectJP j >> collectFnBody v >> collectParams ys >> collectFnBody b\n  | FnBody.set x _ y b      => collectVar x >> collectArg y >> collectFnBody b\n  | FnBody.uset x _ y b     => collectVar x >> collectVar y >> collectFnBody b\n  | FnBody.sset x _ _ y _ b => collectVar x >> collectVar y >> collectFnBody b\n  | FnBody.setTag x _ b     => collectVar x >> collectFnBody b\n  | FnBody.inc x _ _ _ b    => collectVar x >> collectFnBody b\n  | FnBody.dec x _ _ _ b    => collectVar x >> collectFnBody b\n  | FnBody.del x b          => collectVar x >> collectFnBody b\n  | FnBody.mdata _ b        => collectFnBody b\n  | FnBody.case _ x _ alts  => collectVar x >> collectAlts collectFnBody alts\n  | FnBody.jmp j ys         => collectJP j >> collectArgs ys\n  | FnBody.ret x            => collectArg x\n  | FnBody.unreachable      => skip", "start": [58, 1], "end": [72, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MaxIndex.collectDecl", "code": "partial def collectDecl : Decl \u2192 Collector\n  | .fdecl (xs := xs) (body := b) .. => collectParams xs >> collectFnBody b\n  | .extern (xs := xs) ..            => collectParams xs", "start": [74, 1], "end": [76, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.maxIndex", "code": "def FnBody.maxIndex (b : FnBody) : Index :=\n  MaxIndex.collectFnBody b 0", "start": [80, 1], "end": [81, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.maxIndex", "code": "def Decl.maxIndex (d : Decl) : Index :=\n  MaxIndex.collectDecl d 0", "start": [83, 1], "end": [84, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.Collector", "code": "abbrev Collector := IndexSet \u2192 IndexSet \u2192 IndexSet", "start": [90, 1], "end": [90, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.skip", "code": "@[inline] private def skip : Collector :=\n  fun _ fv => fv", "start": [92, 1], "end": [93, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.collectIndex", "code": "@[inline] private def collectIndex (x : Index) : Collector :=\n  fun bv fv => if bv.contains x then fv else fv.insert x", "start": [95, 1], "end": [96, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.collectVar", "code": "@[inline] private def collectVar (x : VarId) : Collector :=\n  collectIndex x.idx", "start": [98, 1], "end": [99, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.collectJP", "code": "@[inline] private def collectJP (x : JoinPointId) : Collector :=\n  collectIndex x.idx", "start": [101, 1], "end": [102, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.withIndex", "code": "@[inline] private def withIndex (x : Index) : Collector \u2192 Collector :=\n  fun k bv fv => k (bv.insert x) fv", "start": [104, 1], "end": [105, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.withVar", "code": "@[inline] private def withVar (x : VarId) : Collector \u2192 Collector :=\n  withIndex x.idx", "start": [107, 1], "end": [108, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.withJP", "code": "@[inline] private def withJP (x : JoinPointId) : Collector \u2192 Collector :=\n  withIndex x.idx", "start": [110, 1], "end": [111, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.insertParams", "code": "def insertParams (s : IndexSet) (ys : Array Param) : IndexSet :=\n  ys.foldl (init := s) fun s p => s.insert p.x.idx", "start": [113, 1], "end": [114, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.withParams", "code": "@[inline] private def withParams (ys : Array Param) : Collector \u2192 Collector :=\n  fun k bv fv => k (insertParams bv ys) fv", "start": [116, 1], "end": [117, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.seq", "code": "@[inline] private def seq : Collector \u2192 Collector \u2192 Collector :=\n  fun k\u2081 k\u2082 bv fv => k\u2082 bv (k\u2081 bv fv)", "start": [119, 1], "end": [120, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.collectArg", "code": "private def collectArg : Arg \u2192 Collector\n  | Arg.var x  => collectVar x\n  | _          => skip", "start": [125, 1], "end": [127, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.collectArray", "code": "private def collectArray {\u03b1 : Type} (as : Array \u03b1) (f : \u03b1 \u2192 Collector) : Collector :=\n  fun bv fv => as.foldl (fun fv a => f a bv fv) fv", "start": [129, 1], "end": [130, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.collectArgs", "code": "private def collectArgs (as : Array Arg) : Collector :=\n  collectArray as collectArg", "start": [132, 1], "end": [133, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.collectExpr", "code": "private def collectExpr : Expr \u2192 Collector\n  | Expr.ctor _ ys      => collectArgs ys\n  | Expr.reset _ x      => collectVar x\n  | Expr.reuse x _ _ ys => collectVar x >> collectArgs ys\n  | Expr.proj _ x       => collectVar x\n  | Expr.uproj _ x      => collectVar x\n  | Expr.sproj _ _ x    => collectVar x\n  | Expr.fap _ ys       => collectArgs ys\n  | Expr.pap _ ys       => collectArgs ys\n  | Expr.ap x ys        => collectVar x >> collectArgs ys\n  | Expr.box _ x        => collectVar x\n  | Expr.unbox x        => collectVar x\n  | Expr.lit _          => skip\n  | Expr.isShared x     => collectVar x", "start": [135, 1], "end": [148, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.collectAlts", "code": "private def collectAlts (f : FnBody \u2192 Collector) (alts : Array Alt) : Collector :=\n  collectArray alts fun alt => f alt.body", "start": [150, 1], "end": [151, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FreeIndices.collectFnBody", "code": "partial def collectFnBody : FnBody \u2192 Collector\n  | FnBody.vdecl x _ v b    => collectExpr v >> withVar x (collectFnBody b)\n  | FnBody.jdecl j ys v b   => withParams ys (collectFnBody v) >> withJP j (collectFnBody b)\n  | FnBody.set x _ y b      => collectVar x >> collectArg y >> collectFnBody b\n  | FnBody.uset x _ y b     => collectVar x >> collectVar y >> collectFnBody b\n  | FnBody.sset x _ _ y _ b => collectVar x >> collectVar y >> collectFnBody b\n  | FnBody.setTag x _ b     => collectVar x >> collectFnBody b\n  | FnBody.inc x _ _ _ b    => collectVar x >> collectFnBody b\n  | FnBody.dec x _ _ _ b    => collectVar x >> collectFnBody b\n  | FnBody.del x b          => collectVar x >> collectFnBody b\n  | FnBody.mdata _ b        => collectFnBody b\n  | FnBody.case _ x _ alts  => collectVar x >> collectAlts collectFnBody alts\n  | FnBody.jmp j ys         => collectJP j >> collectArgs ys\n  | FnBody.ret x            => collectArg x\n  | FnBody.unreachable      => skip", "start": [153, 1], "end": [167, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.collectFreeIndices", "code": "def FnBody.collectFreeIndices (b : FnBody) (vs : IndexSet) : IndexSet :=\n  FreeIndices.collectFnBody b {} vs", "start": [171, 1], "end": [172, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.freeIndices", "code": "def FnBody.freeIndices (b : FnBody) : IndexSet :=\n  b.collectFreeIndices {}", "start": [174, 1], "end": [175, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.HasIndex.visitVar", "code": "def visitVar (w : Index) (x : VarId) : Bool := w == x.idx", "start": [182, 1], "end": [182, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.HasIndex.visitJP", "code": "def visitJP (w : Index) (x : JoinPointId) : Bool := w == x.idx", "start": [183, 1], "end": [183, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.HasIndex.visitArg", "code": "def visitArg (w : Index) : Arg \u2192 Bool\n  | Arg.var x => visitVar w x\n  | _         => false", "start": [185, 1], "end": [187, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.HasIndex.visitArgs", "code": "def visitArgs (w : Index) (xs : Array Arg) : Bool :=\n  xs.any (visitArg w)", "start": [189, 1], "end": [190, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.HasIndex.visitParams", "code": "def visitParams (w : Index) (ps : Array Param) : Bool :=\n  ps.any (fun p => w == p.x.idx)", "start": [192, 1], "end": [193, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.HasIndex.visitExpr", "code": "def visitExpr (w : Index) : Expr \u2192 Bool\n  | Expr.ctor _ ys      => visitArgs w ys\n  | Expr.reset _ x      => visitVar w x\n  | Expr.reuse x _ _ ys => visitVar w x || visitArgs w ys\n  | Expr.proj _ x       => visitVar w x\n  | Expr.uproj _ x      => visitVar w x\n  | Expr.sproj _ _ x    => visitVar w x\n  | Expr.fap _ ys       => visitArgs w ys\n  | Expr.pap _ ys       => visitArgs w ys\n  | Expr.ap x ys        => visitVar w x || visitArgs w ys\n  | Expr.box _ x        => visitVar w x\n  | Expr.unbox x        => visitVar w x\n  | Expr.lit _          => false\n  | Expr.isShared x     => visitVar w x", "start": [195, 1], "end": [208, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.HasIndex.visitFnBody", "code": "partial def visitFnBody (w : Index) : FnBody \u2192 Bool\n  | FnBody.vdecl _ _ v b    => visitExpr w v || visitFnBody w b\n  | FnBody.jdecl _ _  v b   => visitFnBody w v || visitFnBody w b\n  | FnBody.set x _ y b      => visitVar w x || visitArg w y || visitFnBody w b\n  | FnBody.uset x _ y b     => visitVar w x || visitVar w y || visitFnBody w b\n  | FnBody.sset x _ _ y _ b => visitVar w x || visitVar w y || visitFnBody w b\n  | FnBody.setTag x _ b     => visitVar w x || visitFnBody w b\n  | FnBody.inc x _ _ _ b    => visitVar w x || visitFnBody w b\n  | FnBody.dec x _ _ _ b    => visitVar w x || visitFnBody w b\n  | FnBody.del x b          => visitVar w x || visitFnBody w b\n  | FnBody.mdata _ b        => visitFnBody w b\n  | FnBody.jmp j ys         => visitJP w j || visitArgs w ys\n  | FnBody.ret x            => visitArg w x\n  | FnBody.case _ x _ alts  => visitVar w x || alts.any (fun alt => visitFnBody w alt.body)\n  | FnBody.unreachable      => false", "start": [210, 1], "end": [224, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Arg.hasFreeVar", "code": "def Arg.hasFreeVar (arg : Arg) (x : VarId) : Bool := HasIndex.visitArg x.idx arg", "start": [228, 1], "end": [228, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Expr.hasFreeVar", "code": "def Expr.hasFreeVar (e : Expr) (x : VarId) : Bool := HasIndex.visitExpr x.idx e", "start": [229, 1], "end": [229, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.hasFreeVar", "code": "def FnBody.hasFreeVar (b : FnBody) (x : VarId) : Bool := HasIndex.visitFnBody x.idx b", "start": [230, 1], "end": [230, 86], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Eqns.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Split.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Eqns.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Rewrite.lean"], "premises": [{"full_name": "Lean.Elab.WF.EqnInfo", "code": "structure EqnInfo extends EqnInfoCore where\n  declNames       : Array Name\n  declNameNonRec  : Name\n  fixedPrefixSize : Nat\n  deriving Inhabited", "start": [15, 1], "end": [19, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.deltaLHSUntilFix", "code": "private partial def deltaLHSUntilFix (mvarId : MVarId) : MetaM MVarId := mvarId.withContext do\n  let target \u2190 mvarId.getType'\n  let some (_, lhs, _) := target.eq? | throwTacticEx `deltaLHSUntilFix mvarId \"equality expected\"\n  if lhs.isAppOf ``WellFounded.fix then\n    return mvarId\n  else\n    deltaLHSUntilFix (\u2190 deltaLHS mvarId)", "start": [21, 1], "end": [27, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.rwFixEq", "code": "private def rwFixEq (mvarId : MVarId) : MetaM MVarId := mvarId.withContext do\n  let target \u2190 mvarId.getType'\n  let some (_, lhs, rhs) := target.eq? | unreachable!\n  let h := mkAppN (mkConst ``WellFounded.fix_eq lhs.getAppFn.constLevels!) lhs.getAppArgs\n  let some (_, _, lhsNew) := (\u2190 inferType h).eq? | unreachable!\n  let targetNew \u2190 mkEq lhsNew rhs\n  let mvarNew \u2190 mkFreshExprSyntheticOpaqueMVar targetNew\n  mvarId.assign (\u2190 mkEqTrans h mvarNew)\n  return mvarNew.mvarId!", "start": [29, 1], "end": [37, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.hasWellFoundedFix", "code": "private def hasWellFoundedFix (e : Expr) : Bool :=\n  Option.isSome <| e.find? (\u00b7.isConstOf ``WellFounded.fix)", "start": [39, 1], "end": [40, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.decodePackedArg?", "code": "private partial def decodePackedArg? (info : EqnInfo) (e : Expr) : Option (Name \u00d7 Array Expr) := do\n  if info.declNames.size == 1 then\n    let args := decodePSigma e #[]\n    return (info.declNames[0]!, args)\n  else\n    decodePSum? e 0\nwhere\n  decodePSum? (e : Expr) (i : Nat) : Option (Name \u00d7 Array Expr) := do\n    if e.isAppOfArity ``PSum.inl 3 then\n      decodePSum? e.appArg! i\n    else if e.isAppOfArity ``PSum.inr 3 then\n      decodePSum? e.appArg! (i+1)\n    else\n      guard (i < info.declNames.size)\n      return (info.declNames[i]!, decodePSigma e #[])\n\n  decodePSigma (e : Expr) (acc : Array Expr) : Array Expr :=\n    \n    if e.isAppOfArity ``PSigma.mk 4 then\n       decodePSigma e.appArg! (acc.push e.appFn!.appArg!)\n    else\n       acc.push e", "start": [42, 1], "end": [68, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.tryToFoldWellFoundedFix", "code": "private def tryToFoldWellFoundedFix (info : EqnInfo) (us : List Level) (fixedPrefix : Array Expr) (e : Expr) : MetaM Expr := do\n  if hasWellFoundedFix e then\n    transform e (pre := pre)\n  else\n    return e\nwhere\n  pre (e : Expr) : MetaM TransformStep := do\n    let e' := e.headBeta\n    if e'.isAppOf ``WellFounded.fix && e'.getAppNumArgs >= 6 then\n      let args := e'.getAppArgs\n      let packedArg := args[5]!\n      let extraArgs := args[6:]\n      if let some (declName, args) := decodePackedArg? info packedArg then\n        let candidate := mkAppN (mkAppN (mkAppN (mkConst declName us) fixedPrefix) args) extraArgs\n        trace[Elab.definition.wf] \"found nested WF at discr {candidate}\"\n        if (\u2190 withDefault <| isDefEq candidate e) then\n          return .visit candidate\n    return .continue", "start": [70, 1], "end": [98, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.simpMatchWF?", "code": "def simpMatchWF? (info : EqnInfo) (us : List Level) (fixedPrefix : Array Expr) (mvarId : MVarId) : MetaM (Option MVarId) :=\n  mvarId.withContext do\n    let target \u2190 instantiateMVars (\u2190 mvarId.getType)\n    let (targetNew, _) \u2190 Simp.main target (\u2190 Split.getSimpMatchContext) (methods := { pre })\n    let mvarIdNew \u2190 applySimpResultToTarget mvarId target targetNew\n    if mvarId != mvarIdNew then return some mvarIdNew else return none\nwhere\n  pre (e : Expr) : SimpM Simp.Step := do\n    let some app \u2190 matchMatcherApp? e | return Simp.Step.visit { expr := e }\n    if app.discrs.any hasWellFoundedFix then\n      let discrsNew \u2190 app.discrs.mapM (tryToFoldWellFoundedFix info us fixedPrefix \u00b7)\n      if discrsNew != app.discrs then\n        let app := { app with discrs := discrsNew }\n        let eNew := app.toExpr\n        trace[Elab.definition.wf] \"folded discriminants {indentExpr eNew}\"\n        return Simp.Step.visit { expr := app.toExpr }\n    match (\u2190 reduceRecMatcher? e) with\n    | some e' => return Simp.Step.done { expr := e' }\n    | none    =>\n      match (\u2190 Simp.simpMatchCore? app e SplitIf.discharge?) with\n      | some r => return r\n      | none => return Simp.Step.visit { expr := e }", "start": [100, 1], "end": [127, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.tryToFoldLHS?", "code": "private def tryToFoldLHS? (info : EqnInfo) (us : List Level) (fixedPrefix : Array Expr) (mvarId : MVarId) : MetaM (Option MVarId) :=\n  mvarId.withContext do\n    let target \u2190 mvarId.getType'\n    let some (_, lhs, rhs) := target.eq? | unreachable!\n    let lhsNew \u2190 tryToFoldWellFoundedFix info us fixedPrefix lhs\n    if lhs == lhsNew then return none\n    let targetNew \u2190 mkEq lhsNew rhs\n    let mvarNew \u2190 mkFreshExprSyntheticOpaqueMVar targetNew\n    mvarId.assign mvarNew\n    return mvarNew.mvarId!", "start": [129, 1], "end": [138, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.getFixedPrefix", "code": "private def getFixedPrefix (declName : Name) (info : EqnInfo) (mvarId : MVarId) : MetaM (List Level \u00d7 Array Expr) := mvarId.withContext do\n  let target \u2190 mvarId.getType'\n  let some (_, lhs, _) := target.eq? | unreachable!\n  let lhsArgs := lhs.getAppArgs\n  if lhsArgs.size < info.fixedPrefixSize || !lhs.getAppFn matches .const .. then\n    throwError \"failed to generate equational theorem for '{declName}', unexpected number of arguments in the equation left-hand-side\\n{mvarId}\"\n  let result := lhsArgs[:info.fixedPrefixSize]\n  trace[Elab.definition.wf.eqns] \"fixedPrefix: {result}\"\n  return (lhs.getAppFn.constLevels!, result)", "start": [140, 1], "end": [152, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.mkProof", "code": "private partial def mkProof (declName : Name) (info : EqnInfo) (type : Expr) : MetaM Expr := do\n  trace[Elab.definition.wf.eqns] \"proving: {type}\"\n  withNewMCtxDepth do\n    let main \u2190 mkFreshExprSyntheticOpaqueMVar type\n    let (_, mvarId) \u2190 main.mvarId!.intros\n    let (us, fixedPrefix) \u2190 getFixedPrefix declName info mvarId\n    let rec go (mvarId : MVarId) : MetaM Unit := do\n      trace[Elab.definition.wf.eqns] \"step\\n{MessageData.ofGoal mvarId}\"\n      if (\u2190 tryURefl mvarId) then\n        return ()\n      else if (\u2190 tryContradiction mvarId) then\n        return ()\n      else if let some mvarId \u2190 simpMatchWF? info us fixedPrefix mvarId then\n        go mvarId\n      else if let some mvarId \u2190 simpIf? mvarId then\n        go mvarId\n      else if let some mvarId \u2190 whnfReducibleLHS? mvarId then\n        go mvarId\n      else match (\u2190 simpTargetStar mvarId { config.dsimp := false }).1 with\n        | TacticResultCNM.closed => return ()\n        | TacticResultCNM.modified mvarId => go mvarId\n        | TacticResultCNM.noChange =>\n          if let some mvarIds \u2190 casesOnStuckLHS? mvarId then\n            mvarIds.forM go\n          else if let some mvarIds \u2190 splitTarget? mvarId then\n            mvarIds.forM go\n          else if let some mvarId \u2190 tryToFoldLHS? info us fixedPrefix mvarId then\n            go mvarId\n          else\n            throwError \"failed to generate equational theorem for '{declName}'\\n{MessageData.ofGoal mvarId}\"\n    go (\u2190 rwFixEq (\u2190 deltaLHSUntilFix mvarId))\n    instantiateMVars main", "start": [154, 1], "end": [185, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.mkEqns", "code": "def mkEqns (declName : Name) (info : EqnInfo) : MetaM (Array Name) :=\n  withOptions (tactic.hygienic.set \u00b7 false) do\n  let baseName := mkPrivateName (\u2190 getEnv) declName\n  let eqnTypes \u2190 withNewMCtxDepth <| lambdaTelescope info.value fun xs body => do\n    let us := info.levelParams.map mkLevelParam\n    let target \u2190 mkEq (mkAppN (Lean.mkConst declName us) xs) body\n    let goal \u2190 mkFreshExprSyntheticOpaqueMVar target\n    mkEqnTypes info.declNames goal.mvarId!\n  let mut thmNames := #[]\n  for i in [: eqnTypes.size] do\n    let type := eqnTypes[i]!\n    trace[Elab.definition.wf.eqns] \"{eqnTypes[i]!}\"\n    let name := baseName ++ (`_eq).appendIndexAfter (i+1)\n    thmNames := thmNames.push name\n    let value \u2190 mkProof declName info type\n    let (type, value) \u2190 removeUnusedEqnHypotheses type value\n    addDecl <| Declaration.thmDecl {\n      name, type, value\n      levelParams := info.levelParams\n    }\n  return thmNames", "start": [187, 1], "end": [207, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.registerEqnsInfo", "code": "def registerEqnsInfo (preDefs : Array PreDefinition) (declNameNonRec : Name) (fixedPrefixSize : Nat) : MetaM Unit := do\n  \n  unless preDefs.all fun p => p.kind.isTheorem do\n    unless (\u2190 preDefs.allM fun p => isProp p.type) do\n      let declNames := preDefs.map (\u00b7.declName)\n      modifyEnv fun env =>\n        preDefs.foldl (init := env) fun env preDef =>\n          eqnInfoExt.insert env preDef.declName { preDef with declNames, declNameNonRec, fixedPrefixSize }", "start": [211, 1], "end": [222, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.getEqnsFor?", "code": "def getEqnsFor? (declName : Name) : MetaM (Option (Array Name)) := do\n  if let some info := eqnInfoExt.find? (\u2190 getEnv) declName then\n    mkEqns declName info\n  else\n    return none", "start": [224, 1], "end": [228, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.getUnfoldFor?", "code": "def getUnfoldFor? (declName : Name) : MetaM (Option Name) := do\n  let env \u2190 getEnv\n  Eqns.getUnfoldFor? declName fun _ => eqnInfoExt.find? env declName |>.map (\u00b7.toEqnInfoCore)", "start": [230, 1], "end": [232, 94], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Rel.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Rename.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/TerminationHint.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean"], "premises": [{"full_name": "Lean.Elab.WF.getRefFromElems", "code": "private def getRefFromElems (elems : Array TerminationByElement) : Syntax := Id.run do\n  for elem in elems do\n    if !elem.implicit then\n      return elem.ref\n  return elems[0]!.ref", "start": [17, 1], "end": [21, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.unpackMutual", "code": "private partial def unpackMutual (preDefs : Array PreDefinition) (mvarId : MVarId) (fvarId : FVarId) : TermElabM (Array (FVarId \u00d7 MVarId)) := do\n  let rec go (i : Nat) (mvarId : MVarId) (fvarId : FVarId) (result : Array (FVarId \u00d7 MVarId)) : TermElabM (Array (FVarId \u00d7 MVarId)) := do\n    if i < preDefs.size - 1 then\n      let #[s\u2081, s\u2082] \u2190  mvarId.cases fvarId | unreachable!\n      go (i + 1) s\u2082.mvarId s\u2082.fields[0]!.fvarId! (result.push (s\u2081.fields[0]!.fvarId!, s\u2081.mvarId))\n    else\n      return result.push (fvarId, mvarId)\n  go 0 mvarId fvarId #[]", "start": [23, 1], "end": [30, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.unpackUnary", "code": "private partial def unpackUnary (preDef : PreDefinition) (prefixSize : Nat) (mvarId : MVarId) (fvarId : FVarId) (element : TerminationByElement) : TermElabM MVarId := do\n  let varNames \u2190 lambdaTelescope preDef.value fun xs _ => do\n    let mut varNames \u2190 xs.mapM fun x => x.fvarId!.getUserName\n    if element.vars.size > varNames.size then\n      throwErrorAt element.vars[varNames.size]! \"too many variable names\"\n    for i in [:element.vars.size] do\n      let varStx := element.vars[i]!\n      if varStx.isIdent then\n        varNames := varNames.set! (varNames.size - element.vars.size + i) varStx.getId\n    return varNames\n  let mut mvarId := mvarId\n  for localDecl in (\u2190 Term.getMVarDecl mvarId).lctx, varName in varNames[:prefixSize] do\n    unless localDecl.userName == varName do\n      mvarId \u2190 mvarId.rename localDecl.fvarId varName\n  let numPackedArgs := varNames.size - prefixSize\n  let rec go (i : Nat) (mvarId : MVarId) (fvarId : FVarId) : TermElabM MVarId := do\n    trace[Elab.definition.wf] \"i: {i}, varNames: {varNames}, goal: {mvarId}\"\n    if i < numPackedArgs - 1 then\n      let #[s] \u2190 mvarId.cases fvarId #[{ varNames := [varNames[prefixSize + i]!] }] | unreachable!\n      go (i+1) s.mvarId s.fields[1]!.fvarId!\n    else\n      mvarId.rename fvarId varNames.back\n  go 0 mvarId fvarId", "start": [32, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.getNumCandidateArgs", "code": "def getNumCandidateArgs (fixedPrefixSize : Nat) (preDefs : Array PreDefinition) : MetaM (Array Nat) := do\n  preDefs.mapM fun preDef =>\n    lambdaTelescope preDef.value fun xs _ =>\n      return xs.size - fixedPrefixSize", "start": [56, 1], "end": [59, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.getForbiddenByTrivialSizeOf", "code": "def getForbiddenByTrivialSizeOf (fixedPrefixSize : Nat) (preDef : PreDefinition) : MetaM (Array Nat) :=\n  lambdaTelescope preDef.value fun xs _ => do\n    let mut result := #[]\n    for x in xs[fixedPrefixSize:], i in [:xs.size] do\n      try\n        let sizeOf \u2190 whnfD (\u2190 mkAppM ``sizeOf #[x])\n        if sizeOf.isLit then\n         result := result.push i\n      catch _ =>\n        result := result.push i\n    return result", "start": [61, 1], "end": [78, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.generateCombinations?", "code": "def generateCombinations? (forbiddenArgs : Array (Array Nat)) (numArgs : Array Nat) (threshold : Nat := 32) : Option (Array (Array Nat)) :=\n  go 0 #[] |>.run #[] |>.2\nwhere\n  isForbidden (fidx : Nat) (argIdx : Nat) : Bool :=\n    if h : fidx < forbiddenArgs.size then\n       forbiddenArgs.get \u27e8fidx, h\u27e9 |>.contains argIdx\n    else\n      false\n\n  go (fidx : Nat) : OptionT (ReaderT (Array Nat) (StateM (Array (Array Nat)))) Unit := do\n    if h : fidx < numArgs.size then\n      let n := numArgs.get \u27e8fidx, h\u27e9\n      for argIdx in [:n] do\n        unless isForbidden fidx argIdx do\n          withReader (\u00b7.push argIdx) (go (fidx + 1))\n    else\n      modify (\u00b7.push (\u2190 read))\n      if (\u2190 get).size > threshold then\n        failure\ntermination_by _ fidx => numArgs.size - fidx", "start": [80, 1], "end": [99, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.elabWFRel", "code": "def elabWFRel (preDefs : Array PreDefinition) (unaryPreDefName : Name) (fixedPrefixSize : Nat) (argType : Expr) (wf? : Option TerminationWF) (k : Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  let \u03b1 := argType\n  let u \u2190 getLevel \u03b1\n  let expectedType := mkApp (mkConst ``WellFoundedRelation [u]) \u03b1\n  trace[Elab.definition.wf] \"elabWFRel start: {(\u2190 mkFreshTypeMVar).mvarId!}\"\n  match wf? with\n  | some (TerminationWF.core wfStx) => withDeclName unaryPreDefName do\n      let wfRel \u2190 instantiateMVars (\u2190 withSynthesize <| elabTermEnsuringType wfStx expectedType)\n      let pendingMVarIds \u2190 getMVars wfRel\n      discard <| logUnassignedUsingErrorInfos pendingMVarIds\n      k wfRel\n  | some (TerminationWF.ext elements) => go expectedType elements\n  | none => guess expectedType\nwhere\n  go (expectedType : Expr) (elements : Array TerminationByElement) : TermElabM \u03b1 :=\n    withDeclName unaryPreDefName <| withRef (getRefFromElems elements) do\n      let mainMVarId := (\u2190 mkFreshExprSyntheticOpaqueMVar expectedType).mvarId!\n      let [fMVarId, wfRelMVarId, _] \u2190 mainMVarId.apply (\u2190 mkConstWithFreshMVarLevels ``invImage) | throwError \"failed to apply 'invImage'\"\n      let (d, fMVarId) \u2190 fMVarId.intro1\n      let subgoals \u2190 unpackMutual preDefs fMVarId d\n      for (d, mvarId) in subgoals, element in elements, preDef in preDefs do\n        let mvarId \u2190 unpackUnary preDef fixedPrefixSize mvarId d element\n        mvarId.withContext do\n          let value \u2190 Term.withSynthesize <| elabTermEnsuringType element.body (\u2190 mvarId.getType)\n          mvarId.assign value\n      let wfRelVal \u2190 synthInstance (\u2190 inferType (mkMVar wfRelMVarId))\n      wfRelMVarId.assign wfRelVal\n      k (\u2190 instantiateMVars (mkMVar mainMVarId))\n\n  generateElements (numArgs : Array Nat) (argCombination : Array Nat) : TermElabM (Array TerminationByElement) := do\n    let mut result := #[]\n    let var \u2190 `(x)\n    let hole \u2190 `(_)\n    for preDef in preDefs, numArg in numArgs, argIdx in argCombination, i in [:preDefs.size] do\n      let mut vars := #[var]\n      for _ in [:numArg - argIdx - 1] do\n        vars := vars.push hole\n      let body \u2190 if preDefs.size > 1 then `((sizeOf x, $(quote i))) else `(sizeOf x)\n      result := result.push {\n        ref := preDef.ref\n        declName := preDef.declName\n        vars := vars\n        body := body\n        implicit := false\n      }\n    return result\n\n  guess (expectedType : Expr) : TermElabM \u03b1 := do\n    let numArgs \u2190 getNumCandidateArgs fixedPrefixSize preDefs\n    let forbiddenArgs \u2190 preDefs.mapM fun preDef => getForbiddenByTrivialSizeOf fixedPrefixSize preDef\n    if let some combs := generateCombinations? forbiddenArgs numArgs then\n      for comb in combs do\n        let elements \u2190 generateElements numArgs comb\n        if let some r \u2190 observing? (go expectedType elements) then\n          return r\n    throwError \"failed to prove termination, use `termination_by` to specify a well-founded relation\"", "start": [101, 1], "end": [162, 102], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Ite.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.iteToDIte", "code": "def iteToDIte (e : Expr) : MetaM Expr := do\n  let post (e : Expr) : MetaM TransformStep := do\n    if e.isAppOfArity ``ite 5 then\n      let f    := e.getAppFn\n      let args := e.getAppArgs\n      let c    := args[1]!\n      let h    \u2190 mkFreshUserName `h\n      let args := args.set! 3 (Lean.mkLambda h BinderInfo.default c args[3]!)\n      let args := args.set! 4 (Lean.mkLambda h BinderInfo.default (mkNot c) args[4]!)\n      return .done <| mkAppN (mkConst ``dite f.constLevels!) args\n    else\n      return .done e\n  transform e (post := post)", "start": [10, 1], "end": [27, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/PackMutual.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.WF.mkNewDomain", "code": "private def mkNewDomain (ds : Array Expr) : MetaM Expr := do\n  let mut r := ds.back\n  for d in ds.pop.reverse do\n    r \u2190 mkAppM ``PSum #[d, r]\n  return r", "start": [12, 1], "end": [17, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.getCodomainLevel", "code": "private def getCodomainLevel (preDefType : Expr) : MetaM Level :=\n  forallBoundedTelescope preDefType (some 1) fun _ body => getLevel body", "start": [19, 1], "end": [20, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.getCodomainsLevel", "code": "private def getCodomainsLevel (preDefsOriginal : Array PreDefinition) (preDefTypes : Array Expr) : MetaM Level := do\n  let r \u2190 getCodomainLevel preDefTypes[0]!\n  for i in [1:preDefTypes.size] do\n    let preDef := preDefTypes[i]!\n    unless (\u2190 isLevelDefEq r (\u2190 getCodomainLevel preDef)) do\n      let arity\u2080 \u2190 lambdaTelescope preDefsOriginal[0]!.value fun xs _ => return xs.size\n      let arity\u1d62 \u2190 lambdaTelescope preDefsOriginal[i]!.value fun xs _ => return xs.size\n      forallBoundedTelescope preDefsOriginal[0]!.type arity\u2080 fun _ type\u2080 =>\n      forallBoundedTelescope preDefsOriginal[i]!.type arity\u1d62 fun _ type\u1d62 =>\n        withOptions (fun o => pp.sanitizeNames.set o false) do\n          throwError \"invalid mutual definition, result types must be in the same universe level, resulting type for `{preDefsOriginal[0]!.declName}` is{indentExpr type\u2080} : {\u2190 inferType type\u2080}\\nand for `{preDefsOriginal[i]!.declName}` is{indentExpr type\u1d62} : {\u2190 inferType type\u1d62}\"\n  return r", "start": [22, 1], "end": [37, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.mkNewCoDomain", "code": "private partial def mkNewCoDomain (preDefsOriginal : Array PreDefinition) (preDefTypes : Array Expr) (x : Expr) : MetaM Expr := do\n  let u \u2190 getCodomainsLevel preDefsOriginal preDefTypes\n  let rec go (x : Expr) (i : Nat) : MetaM Expr := do\n    if i < preDefTypes.size - 1 then\n      let xType \u2190 whnfD (\u2190 inferType x)\n      assert! xType.isAppOfArity ``PSum 2\n      let xTypeArgs := xType.getAppArgs\n      let casesOn := mkConst (mkCasesOnName ``PSum) (mkLevelSucc u :: xType.getAppFn.constLevels!)\n      let casesOn := mkAppN casesOn xTypeArgs let casesOn := mkApp casesOn (\u2190 mkLambdaFVars #[x] (mkSort u)) let casesOn := mkApp casesOn x let minor1 \u2190 withLocalDeclD (\u2190 mkFreshUserName `_x) xTypeArgs[0]! fun x =>\n        mkLambdaFVars #[x] (preDefTypes[i]!.bindingBody!.instantiate1 x)\n      let minor2 \u2190 withLocalDeclD (\u2190 mkFreshUserName `_x) xTypeArgs[1]! fun x => do\n        mkLambdaFVars #[x] (\u2190 go x (i+1))\n      return mkApp2 casesOn minor1 minor2\n    else\n      return preDefTypes[i]!.bindingBody!.instantiate1 x\n  go x 0", "start": [39, 1], "end": [61, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.packValues", "code": "private partial def packValues (x : Expr) (codomain : Expr) (preDefValues : Array Expr) : MetaM Expr := do\n  let varNames := preDefValues.map fun val =>\n    assert! val.isLambda\n    val.bindingName!\n  let mvar \u2190 mkFreshExprSyntheticOpaqueMVar codomain\n  let rec go (mvarId : MVarId) (x : FVarId) (i : Nat) : MetaM Unit := do\n    if i < preDefValues.size - 1 then\n      \n      let givenNames : Array AltVarNames :=\n         if i == preDefValues.size - 2 then\n           #[{ varNames := [varNames[i]!] }, { varNames := [varNames[i+1]!] }]\n         else\n           #[{ varNames := [varNames[i]!] }]\n       let #[s\u2081, s\u2082] \u2190 mvarId.cases x (givenNames := givenNames) | unreachable!\n      s\u2081.mvarId.assign (mkApp preDefValues[i]! s\u2081.fields[0]!).headBeta\n      go s\u2082.mvarId s\u2082.fields[0]!.fvarId! (i+1)\n    else\n      mvarId.assign (mkApp preDefValues[i]! (mkFVar x)).headBeta\n  go mvar.mvarId! x.fvarId! 0\n  instantiateMVars mvar", "start": [63, 1], "end": [91, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.post", "code": "private partial def post (fixedPrefix : Nat) (preDefs : Array PreDefinition) (domain : Expr) (newFn : Name) (e : Expr) : MetaM TransformStep := do\n  if e.getAppNumArgs != fixedPrefix + 1 then\n    return TransformStep.done e\n  let f := e.getAppFn\n  if !f.isConst then\n    return TransformStep.done e\n  let declName := f.constName!\n  let us       := f.constLevels!\n  if let some fidx := preDefs.findIdx? (\u00b7.declName == declName) then\n    let args := e.getAppArgs\n    let fixedArgs := args[:fixedPrefix]\n    let arg  := args.back\n    let rec mkNewArg (i : Nat) (type : Expr) : MetaM Expr := do\n      if i == preDefs.size - 1 then\n        return arg\n      else\n        (\u2190 whnfD type).withApp fun f args => do\n          assert! args.size == 2\n          if i == fidx then\n            return mkApp3 (mkConst ``PSum.inl f.constLevels!) args[0]! args[1]! arg\n          else\n            let r \u2190 mkNewArg (i+1) args[1]!\n            return mkApp3 (mkConst ``PSum.inr f.constLevels!) args[0]! args[1]! r\n    return TransformStep.done <| mkApp (mkAppN (mkConst newFn us) fixedArgs) (\u2190 mkNewArg 0 domain)\n  return TransformStep.done e", "start": [93, 1], "end": [121, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.withFixedPrefix", "code": "partial def withFixedPrefix (fixedPrefix : Nat) (preDefs : Array PreDefinition) (k : Array Expr \u2192 Array Expr \u2192 Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  go fixedPrefix #[] (preDefs.map (\u00b7.value))\nwhere\n  go (i : Nat) (fvars : Array Expr) (vals : Array Expr) : MetaM \u03b1 := do\n    match i with\n    | 0 => k fvars (\u2190 preDefs.mapM fun preDef => instantiateForall preDef.type fvars) vals\n    | i+1 =>\n      withLocalDecl vals[0]!.bindingName! vals[0]!.binderInfo vals[0]!.bindingDomain! fun x =>\n        go i (fvars.push x) (vals.map fun val => val.bindingBody!.instantiate1 x)", "start": [123, 1], "end": [131, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.packMutual", "code": "def packMutual (fixedPrefix : Nat) (preDefsOriginal : Array PreDefinition) (preDefs : Array PreDefinition) : MetaM PreDefinition := do\n  if preDefs.size == 1 then return preDefs[0]!\n  withFixedPrefix fixedPrefix preDefs fun ys types vals => do\n    let domains := types.map fun type => type.bindingDomain!\n    let domain \u2190 mkNewDomain domains\n    withLocalDeclD (\u2190 mkFreshUserName `_x) domain fun x => do\n      let codomain \u2190 mkNewCoDomain preDefsOriginal types x\n      let type \u2190 mkForallFVars (ys.push x) codomain\n      let value \u2190 packValues x codomain vals\n      let newFn := preDefs[0]!.declName ++ `_mutual\n      let preDefNew := { preDefs[0]! with declName := newFn, type, value }\n      addAsAxiom preDefNew\n      let value \u2190 transform value (post := post fixedPrefix preDefs domain newFn)\n      let value \u2190 mkLambdaFVars (ys.push x) value\n      return { preDefNew with value }", "start": [133, 1], "end": [188, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Fix.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cleanup.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/Match.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/CasesOn.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/RecAppSyntax.lean", "lake-packages/lean4/src/lean/Lean/Util/HasConstCache.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/BRecOn.lean"], "premises": [{"full_name": "Lean.Elab.WF.applyDefaultDecrTactic", "code": "private def applyDefaultDecrTactic (mvarId : MVarId) : TermElabM Unit := do\n  let remainingGoals \u2190 Tactic.run mvarId do\n    Tactic.evalTactic (\u2190 `(tactic| decreasing_tactic))\n  remainingGoals.forM fun mvarId => Term.reportUnsolvedGoals [mvarId]", "start": [20, 1], "end": [23, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.mkDecreasingProof", "code": "private def mkDecreasingProof (decreasingProp : Expr) (decrTactic? : Option Syntax) : TermElabM Expr := do\n  let mvar \u2190 mkFreshExprSyntheticOpaqueMVar decreasingProp\n  let mvarId := mvar.mvarId!\n  let mvarId \u2190 mvarId.cleanup\n  match decrTactic? with\n  | none => applyDefaultDecrTactic mvarId\n  | some decrTactic =>\n    pushInfoTree (.hole mvarId)\n    Term.runTactic mvarId decrTactic\n  instantiateMVars mvar", "start": [25, 1], "end": [35, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.replaceRecApps", "code": "private partial def replaceRecApps (recFnName : Name) (fixedPrefixSize : Nat) (decrTactic? : Option Syntax) (F : Expr) (e : Expr) : TermElabM Expr := do\n  trace[Elab.definition.wf] \"replaceRecApps:{indentExpr e}\"\n  trace[Elab.definition.wf] \"{F} : {\u2190 inferType F}\"\n  loop F e |>.run' {}\nwhere\n  processRec (F : Expr) (e : Expr) : StateRefT (HasConstCache recFnName) TermElabM Expr := do\n    if e.getAppNumArgs < fixedPrefixSize + 1 then\n      loop F (\u2190 etaExpand e)\n    else\n      let args := e.getAppArgs\n      let r := mkApp F (\u2190 loop F args[fixedPrefixSize]!)\n      let decreasingProp := (\u2190 whnf (\u2190 inferType r)).bindingDomain!\n      let r := mkApp r (\u2190 mkDecreasingProof decreasingProp decrTactic?)\n      return mkAppN r (\u2190 args[fixedPrefixSize+1:].toArray.mapM (loop F))\n\n  processApp (F : Expr) (e : Expr) : StateRefT (HasConstCache recFnName) TermElabM Expr := do\n    if e.isAppOf recFnName then\n      processRec F e\n    else\n      e.withApp fun f args => return mkAppN (\u2190 loop F f) (\u2190 args.mapM (loop F))\n\n  containsRecFn (e : Expr) : StateRefT (HasConstCache recFnName) TermElabM Bool := do\n    modifyGet (\u00b7.contains e)\n\n  loop (F : Expr) (e : Expr) : StateRefT (HasConstCache recFnName) TermElabM Expr := do\n    if !(\u2190 containsRecFn e) then\n      return e\n    match e with\n    | Expr.lam n d b c =>\n      withLocalDecl n c (\u2190 loop F d) fun x => do\n        mkLambdaFVars #[x] (\u2190 loop F (b.instantiate1 x))\n    | Expr.forallE n d b c =>\n      withLocalDecl n c (\u2190 loop F d) fun x => do\n        mkForallFVars #[x] (\u2190 loop F (b.instantiate1 x))\n    | Expr.letE n type val body _ =>\n      withLetDecl n (\u2190 loop F type) (\u2190 loop F val) fun x => do\n        mkLetFVars #[x] (\u2190 loop F (body.instantiate1 x)) (usedLetOnly := false)\n    | Expr.mdata d b =>\n      if let some stx := getRecAppSyntax? e then\n        withRef stx <| loop F b\n      else\n        return mkMData d (\u2190 loop F b)\n    | Expr.proj n i e => return mkProj n i (\u2190 loop F e)\n    | Expr.const .. => if e.isConstOf recFnName then processRec F e else return e\n    | Expr.app .. =>\n      match (\u2190 matchMatcherApp? e) with\n      | some matcherApp =>\n        if !Structural.recArgHasLooseBVarsAt recFnName fixedPrefixSize e then\n          processApp F e\n        else if let some matcherApp \u2190 matcherApp.addArg? F then\n          if !(\u2190 Structural.refinedArgType matcherApp F) then\n            processApp F e\n          else\n            let altsNew \u2190 (Array.zip matcherApp.alts matcherApp.altNumParams).mapM fun (alt, numParams) =>\n              lambdaTelescope alt fun xs altBody => do\n                unless xs.size >= numParams do\n                  throwError \"unexpected matcher application alternative{indentExpr alt}\\nat application{indentExpr e}\"\n                let FAlt := xs[numParams - 1]!\n                mkLambdaFVars xs (\u2190 loop FAlt altBody)\n            return { matcherApp with alts := altsNew, discrs := (\u2190 matcherApp.discrs.mapM (loop F)) }.toExpr\n        else\n          processApp F e\n      | none =>\n      match (\u2190 toCasesOnApp? e) with\n      | some casesOnApp =>\n        if !Structural.recArgHasLooseBVarsAt recFnName fixedPrefixSize e then\n          processApp F e\n        else if let some casesOnApp \u2190 casesOnApp.addArg? F (checkIfRefined := true) then\n          let altsNew \u2190 (Array.zip casesOnApp.alts casesOnApp.altNumParams).mapM fun (alt, numParams) =>\n            lambdaTelescope alt fun xs altBody => do\n              unless xs.size >= numParams do\n                throwError \"unexpected `casesOn` application alternative{indentExpr alt}\\nat application{indentExpr e}\"\n              let FAlt := xs[numParams]!\n              mkLambdaFVars xs (\u2190 loop FAlt altBody)\n          return { casesOnApp with\n                   alts      := altsNew\n                   remaining := (\u2190 casesOnApp.remaining.mapM (loop F)) }.toExpr\n        else\n          processApp F e\n      | none => processApp F e\n    | e => ensureNoRecFn recFnName e", "start": [37, 1], "end": [117, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.processSumCasesOn", "code": "private partial def processSumCasesOn (x F val : Expr) (k : (x : Expr) \u2192 (F : Expr) \u2192 (val : Expr) \u2192 TermElabM Expr) : TermElabM Expr := do\n  if x.isFVar && val.isAppOfArity ``PSum.casesOn 6 && val.getArg! 3 == x && (val.getArg! 4).isLambda && (val.getArg! 5).isLambda then\n    let args := val.getAppArgs\n    let \u03b1 := args[0]!\n    let \u03b2 := args[1]!\n    let FDecl \u2190 F.fvarId!.getDecl\n    let (motiveNew, u) \u2190 lambdaTelescope args[2]! fun xs type => do\n      let type \u2190 mkArrow (FDecl.type.replaceFVar x xs[0]!) type\n      return (\u2190 mkLambdaFVars xs type, \u2190 getLevel type)\n    let mkMinorNew (ctorName : Name) (minor : Expr) : TermElabM Expr :=\n      lambdaTelescope minor fun xs body => do\n        let xNew := xs[0]!\n        let valNew \u2190 mkLambdaFVars xs[1:] body\n        let FTypeNew := FDecl.type.replaceFVar x (\u2190 mkAppOptM ctorName #[\u03b1, \u03b2, xNew])\n        withLocalDeclD FDecl.userName FTypeNew fun FNew => do\n          mkLambdaFVars #[xNew, FNew] (\u2190 processSumCasesOn xNew FNew valNew k)\n    let minorLeft \u2190 mkMinorNew ``PSum.inl args[4]!\n    let minorRight \u2190 mkMinorNew ``PSum.inr args[5]!\n    let result := mkAppN (mkConst ``PSum.casesOn [u, (\u2190 getLevel \u03b1), (\u2190 getLevel \u03b2)]) #[\u03b1, \u03b2, motiveNew, x, minorLeft, minorRight, F]\n    return result\n  else\n    k x F val", "start": [119, 1], "end": [141, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.processPSigmaCasesOn", "code": "private partial def processPSigmaCasesOn (x F val : Expr) (k : (F : Expr) \u2192 (val : Expr) \u2192 TermElabM Expr) : TermElabM Expr := do\n  if x.isFVar && val.isAppOfArity ``PSigma.casesOn 5 && val.getArg! 3 == x && (val.getArg! 4).isLambda && (val.getArg! 4).bindingBody!.isLambda then\n    let args := val.getAppArgs\n    let [_, u, v] := val.getAppFn.constLevels! | unreachable!\n    let \u03b1 := args[0]!\n    let \u03b2 := args[1]!\n    let FDecl \u2190 F.fvarId!.getDecl\n    let (motiveNew, w) \u2190 lambdaTelescope args[2]! fun xs type => do\n      let type \u2190 mkArrow (FDecl.type.replaceFVar x xs[0]!) type\n      return (\u2190 mkLambdaFVars xs type, \u2190 getLevel type)\n    let minor \u2190 lambdaTelescope args[4]! fun xs body => do\n        let a := xs[0]!\n        let xNew := xs[1]!\n        let valNew \u2190 mkLambdaFVars xs[2:] body\n        let FTypeNew := FDecl.type.replaceFVar x (\u2190 mkAppOptM `PSigma.mk #[\u03b1, \u03b2, a, xNew])\n        withLocalDeclD FDecl.userName FTypeNew fun FNew => do\n          mkLambdaFVars #[a, xNew, FNew] (\u2190 processPSigmaCasesOn xNew FNew valNew k)\n    let result := mkAppN (mkConst ``PSigma.casesOn [w, u, v]) #[\u03b1, \u03b2, motiveNew, x, minor, F]\n    return result\n  else\n    k F val", "start": [143, 1], "end": [164, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.mkFix", "code": "def mkFix (preDef : PreDefinition) (prefixArgs : Array Expr) (wfRel : Expr) (decrTactic? : Option Syntax) : TermElabM Expr := do\n  let type \u2190 instantiateForall preDef.type prefixArgs\n  let (wfFix, varName) \u2190 forallBoundedTelescope type (some 1) fun x type => do\n    let x := x[0]!\n    let \u03b1 \u2190 inferType x\n    let u \u2190 getLevel \u03b1\n    let v \u2190 getLevel type\n    let motive \u2190 mkLambdaFVars #[x] type\n    let rel := mkProj ``WellFoundedRelation 0 wfRel\n    let wf  := mkProj ``WellFoundedRelation 1 wfRel\n    let varName \u2190 x.fvarId!.getUserName return (mkApp4 (mkConst ``WellFounded.fix [u, v]) \u03b1 motive rel wf, varName)\n  forallBoundedTelescope (\u2190 whnf (\u2190 inferType wfFix)).bindingDomain! (some 2) fun xs _ => do\n    let x   := xs[0]!\n    let lctx := (\u2190 getLCtx).setUserName x.fvarId! varName\n    withTheReader Meta.Context (fun ctx => { ctx with lctx }) do\n      let F   := xs[1]!\n      let val := preDef.value.beta (prefixArgs.push x)\n      let val \u2190 processSumCasesOn x F val fun x F val => do\n        processPSigmaCasesOn x F val (replaceRecApps preDef.declName prefixArgs.size decrTactic?)\n      mkLambdaFVars prefixArgs (mkApp wfFix (\u2190 mkLambdaFVars #[x, F] val))", "start": [166, 1], "end": [189, 75], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/PackDomain.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.WF.mkTupleElems", "code": "private def mkTupleElems (t : Expr) (arity : Nat) : Array Expr := Id.run do\n  let mut result := #[]\n  let mut t := t\n  for _ in [:arity - 1] do\n    result := result.push (mkProj ``PSigma 0 t)\n    t := mkProj ``PSigma 1 t\n  result.push t", "start": [12, 1], "end": [23, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.mkUnaryArg", "code": "partial def mkUnaryArg (type : Expr) (args : Array Expr) : MetaM Expr := do\n  go 0 type\nwhere\n  go (i : Nat) (type : Expr) : MetaM Expr := do\n    if i < args.size - 1 then\n      let arg := args[i]!\n      assert! type.isAppOfArity ``PSigma 2\n      let us := type.getAppFn.constLevels!\n      let \u03b1 := type.appFn!.appArg!\n      let \u03b2 := type.appArg!\n      assert! \u03b2.isLambda\n      let type := \u03b2.bindingBody!.instantiate1 arg\n      let rest \u2190 go (i+1) type\n      return mkApp4 (mkConst ``PSigma.mk us) \u03b1 \u03b2 arg rest\n    else\n      return args[i]!", "start": [25, 1], "end": [41, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.mkPSigmaCasesOn", "code": "private partial def mkPSigmaCasesOn (y : Expr) (codomain : Expr) (xs : Array Expr) (value : Expr) : MetaM Expr := do\n  let mvar \u2190 mkFreshExprSyntheticOpaqueMVar codomain\n  let rec go (mvarId : MVarId) (y : FVarId) (ys : Array Expr) : MetaM Unit := do\n    if ys.size < xs.size - 1 then\n      let xDecl  \u2190 xs[ys.size]!.fvarId!.getDecl\n      let xDecl' \u2190 xs[ys.size + 1]!.fvarId!.getDecl\n      let #[s] \u2190 mvarId.cases y #[{ varNames := [xDecl.userName, xDecl'.userName] }] | unreachable!\n      go s.mvarId s.fields[1]!.fvarId! (ys.push s.fields[0]!)\n    else\n      let ys := ys.push (mkFVar y)\n      mvarId.assign (value.replaceFVars xs ys)\n  go mvar.mvarId! y.fvarId! #[]\n  instantiateMVars mvar", "start": [43, 1], "end": [55, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.WF.packDomain", "code": "partial def packDomain (fixedPrefix : Nat) (preDefs : Array PreDefinition) : MetaM (Array PreDefinition) := do\n  let mut preDefsNew := #[]\n  let mut arities := #[]\n  let mut modified := false\n  for preDef in preDefs do\n    let (preDefNew, arity, modifiedCurr) \u2190 lambdaTelescope preDef.value fun xs _ => do\n      if xs.size == fixedPrefix then\n        throwError \"well-founded recursion cannot be used, '{preDef.declName}' does not take any (non-fixed) arguments\"\n      let arity := xs.size\n      if arity > fixedPrefix + 1 then\n        let bodyType \u2190 instantiateForall preDef.type xs\n        let mut d \u2190 inferType xs.back\n        let ys : Array Expr := xs[:fixedPrefix]\n        let xs : Array Expr := xs[fixedPrefix:]\n        for x in xs.pop.reverse do\n          d \u2190 mkAppOptM ``PSigma #[some (\u2190 inferType x), some (\u2190 mkLambdaFVars #[x] d)]\n        withLocalDeclD (\u2190 mkFreshUserName `_x) d fun tuple => do\n          let elems := mkTupleElems tuple xs.size\n          let codomain := bodyType.replaceFVars xs elems\n          let preDefNew:= { preDef with\n            declName := preDef.declName ++ `_unary\n            type := (\u2190 mkForallFVars (ys.push tuple) codomain)\n          }\n          addAsAxiom preDefNew\n          return (preDefNew, arity, true)\n      else\n        return (preDef, arity, false)\n    modified := modified || modifiedCurr\n    arities := arities.push arity\n    preDefsNew := preDefsNew.push preDefNew\n  if !modified then\n    return preDefs\n  for i in [:preDefs.size] do\n    let preDef := preDefs[i]!\n    let preDefNew := preDefsNew[i]!\n    let valueNew \u2190 lambdaTelescope preDef.value fun xs body => do\n      let ys : Array Expr := xs[:fixedPrefix]\n      let xs : Array Expr := xs[fixedPrefix:]\n      let type \u2190 instantiateForall preDefNew.type ys\n      forallBoundedTelescope type (some 1) fun z codomain => do\n        let z := z[0]!\n        let newBody \u2190 mkPSigmaCasesOn z codomain xs body\n        mkLambdaFVars (ys.push z) (\u2190 packApplications newBody arities preDefsNew)\n    let isBad (e : Expr) : Bool :=\n      match isAppOfPreDef? e with\n      | none   => false\n      | some i => e.getAppNumArgs > fixedPrefix + 1 || preDefsNew[i]!.declName != preDefs[i]!.declName\n    if let some bad := valueNew.find? isBad then\n      if let some i := isAppOfPreDef? bad then\n        throwErrorAt preDef.ref \"well-founded recursion cannot be used, function '{preDef.declName}' contains application of function '{preDefs[i]!.declName}' with #{bad.getAppNumArgs} argument(s), but function has arity {arities[i]!}\"\n    preDefsNew := preDefsNew.set! i { preDefNew with value := valueNew }\n  return preDefsNew\nwhere\n  \n  isAppOfPreDef? (e : Expr) : Option Nat := do\n    let f := e.getAppFn\n    guard f.isConst\n    preDefs.findIdx? (\u00b7.declName == f.constName!)\n\n  packApplications (e : Expr) (arities : Array Nat) (preDefsNew : Array PreDefinition) : MetaM Expr := do\n    let pack (e : Expr) (funIdx : Nat) : MetaM Expr := do\n      let f := e.getAppFn\n      let args := e.getAppArgs\n      let fNew := mkConst preDefsNew[funIdx]!.declName f.constLevels!\n      let fNew := mkAppN fNew args[:fixedPrefix]\n      let Expr.forallE _ d .. \u2190 inferType fNew | unreachable!\n      let argNew \u2190 mkUnaryArg d args[fixedPrefix:]\n      return mkApp fNew argNew\n    let rec\n      visit (e : Expr) : MonadCacheT ExprStructEq Expr MetaM Expr := do\n        checkCache { val := e : ExprStructEq } fun _ => Meta.withIncRecDepth do\n          match e with\n          | Expr.lam n d b c =>\n            withLocalDecl n c (\u2190 visit d) fun x => do\n              mkLambdaFVars (usedLetOnly := false) #[x] (\u2190 visit (b.instantiate1 x))\n          | Expr.forallE n d b c =>\n            withLocalDecl n c (\u2190 visit d) fun x => do\n              mkForallFVars (usedLetOnly := false) #[x] (\u2190 visit (b.instantiate1 x))\n          | Expr.letE n t v b _  =>\n            withLetDecl n (\u2190 visit t) (\u2190 visit v) fun x => do\n              mkLambdaFVars (usedLetOnly := false) #[x] (\u2190 visit (b.instantiate1 x))\n          | Expr.proj n i s .. => return mkProj n i (\u2190 visit s)\n          | Expr.mdata d b     => return mkMData d (\u2190 visit b)\n          | Expr.app ..        => visitApp e\n          | Expr.const ..      => visitApp e\n          | e                  => return e,\n      visitApp (e : Expr) : MonadCacheT ExprStructEq Expr MetaM Expr := e.withApp fun f args => do\n        let args \u2190 args.mapM visit\n        if let some funIdx := isAppOfPreDef? f then\n          let numArgs := args.size\n          let arity   := arities[funIdx]!\n          if numArgs < arity then\n            let extra := arity - numArgs\n            withDefault do forallBoundedTelescope (\u2190 inferType e) extra fun xs _ => do\n              if xs.size != extra then\n                return (mkAppN f args) else\n                mkLambdaFVars xs (\u2190 pack (mkAppN (mkAppN f args) xs) funIdx)\n          else if numArgs > arity then\n            let r \u2190 pack (mkAppN f args[:arity]) funIdx\n            let rType \u2190 inferType r\n            withLetDecl (\u2190 mkFreshUserName `aux) rType r fun aux =>\n              mkLetFVars #[aux] (mkAppN aux args[arity:])\n          else\n            pack (mkAppN f args) funIdx\n        else if args.isEmpty then\n          return f\n        else\n          return mkAppN (\u2190 visit f) args\n    visit e |>.run", "start": [57, 1], "end": [174, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Main.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/FindRecArg.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Preprocess.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/SmartUnfolding.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/IndPred.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/BRecOn.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Eqns.lean"], "premises": [{"full_name": "Lean.Elab.Structural.getFixedPrefix", "code": "private def getFixedPrefix (declName : Name) (xs : Array Expr) (value : Expr) : MetaM Nat := do\n  let numFixedRef \u2190 IO.mkRef xs.size\n  forEachExpr' value fun e => do\n    if e.isAppOf declName then\n      let args := e.getAppArgs\n      numFixedRef.modify fun numFixed => if args.size < numFixed then args.size else numFixed\n      for arg in args, x in xs do\n        \n        if !(\u2190 withoutProofIrrelevance <| withReducible <| isDefEq arg x) then\n          return true\n      return false\n    else\n      return true\n  numFixedRef.get", "start": [18, 1], "end": [57, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.elimRecursion", "code": "private def elimRecursion (preDef : PreDefinition) : M (Nat \u00d7 PreDefinition) := do\n  trace[Elab.definition.structural] \"{preDef.declName} := {preDef.value}\"\n  withoutModifyingEnv do lambdaTelescope preDef.value fun xs value => do\n    addAsAxiom preDef\n    let value \u2190 preprocess value preDef.declName\n    trace[Elab.definition.structural] \"{preDef.declName} {xs} :=\\n{value}\"\n    let numFixed \u2190 getFixedPrefix preDef.declName xs value\n    trace[Elab.definition.structural] \"numFixed: {numFixed}\"\n    findRecArg numFixed xs fun recArgInfo => do\n      let valueNew \u2190 if recArgInfo.indPred then\n        mkIndPredBRecOn preDef.declName recArgInfo value\n      else\n        mkBRecOn preDef.declName recArgInfo value\n      let valueNew \u2190 mkLambdaFVars xs valueNew\n      trace[Elab.definition.structural] \"result: {valueNew}\"\n      let valueNew \u2190 ensureNoRecFn preDef.declName valueNew\n      let recArgPos := recArgInfo.fixedParams.size + recArgInfo.pos\n      return (recArgPos, { preDef with value := valueNew })", "start": [59, 1], "end": [78, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Structural.structuralRecursion", "code": "def structuralRecursion (preDefs : Array PreDefinition) : TermElabM Unit :=\n  if preDefs.size != 1 then\n    throwError \"structural recursion does not handle mutually recursive functions\"\n  else do\n    let ((recArgPos, preDefNonRec), state) \u2190 run <| elimRecursion preDefs[0]!\n    let preDefNonRec \u2190 eraseRecAppSyntax preDefNonRec\n    let preDef \u2190 eraseRecAppSyntax preDefs[0]!\n    state.addMatchers.forM liftM\n    unless preDef.kind.isTheorem do\n      unless (\u2190 isProp preDef.type) do\n        \n        registerEqnsInfo preDef recArgPos\n    mapError (addNonRec preDefNonRec (applyAttrAfterCompilation := false)) fun msg =>\n      m!\"structural recursion failed, produced type incorrect term{indentD msg}\"\n    addAndCompilePartialRec #[preDef]\n    addSmartUnfoldingDef preDef recArgPos\n    applyAttributesOf #[preDefNonRec] AttributeApplicationTime.afterCompilation", "start": [80, 1], "end": [100, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Split.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Split.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.evalSplit", "code": "@[builtin_tactic Lean.Parser.Tactic.split] def evalSplit : Tactic := fun stx => do\n  unless stx[1].isNone do\n    throwError \"'split' tactic, term to split is not supported yet\"\n  let loc := expandOptLocation stx[2]\n  match loc with\n  | Location.targets hyps simplifyTarget =>\n    if (hyps.size > 0 && simplifyTarget) || hyps.size > 1 then\n      throwErrorAt stx[2] \"'split' tactic failed, select a single target to split\"\n    if simplifyTarget then\n      liftMetaTactic fun mvarId => do\n       let some mvarIds \u2190 splitTarget? mvarId | Meta.throwTacticEx `split mvarId \"\"\n        return mvarIds\n    else\n      let fvarId \u2190 getFVarId hyps[0]!\n      liftMetaTactic fun mvarId => do\n        let some mvarIds \u2190 splitLocalDecl? mvarId fvarId | Meta.throwTacticEx `split mvarId \"\"\n        return mvarIds\n  | Location.wildcard =>\n    liftMetaTactic fun mvarId => do\n      let fvarIds \u2190 mvarId.getNondepPropHyps\n      for fvarId in fvarIds do\n        if let some mvarIds \u2190 splitLocalDecl? mvarId fvarId then\n          return mvarIds\n      let some mvarIds \u2190 splitTarget? mvarId | Meta.throwTacticEx `split mvarId \"\"\n      return mvarIds", "start": [13, 1], "end": [37, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/HashMap/WF.lean", "imports": ["lake-packages/std/Std/Data/HashMap/Basic.lean", "lake-packages/std/Std/Tactic/ShowTerm.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/Array/Lemmas.lean", "lake-packages/std/Std/Data/List/Lemmas.lean"], "premises": [{"full_name": "Std.HashMap.Imp.Buckets.ext", "code": "@[ext] protected theorem ext : \u2200 {b\u2081 b\u2082 : Buckets \u03b1 \u03b2}, b\u2081.1.data = b\u2082.1.data \u2192 b\u2081 = b\u2082", "start": [18, 1], "end": [19, 35], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.update_data", "code": "theorem update_data (self : Buckets \u03b1 \u03b2) (i d h) :\n    (self.update i d h).1.data = self.1.data.set i.toNat d", "start": [21, 1], "end": [22, 66], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.exists_of_update", "code": "theorem exists_of_update (self : Buckets \u03b1 \u03b2) (i d h) :\n    \u2203 l\u2081 l\u2082, self.1.data = l\u2081 ++ self.1[i] :: l\u2082 \u2227 List.length l\u2081 = i.toNat \u2227\n      (self.update i d h).1.data = l\u2081 ++ d :: l\u2082", "start": [24, 1], "end": [27, 64], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.update_update", "code": "theorem update_update (self : Buckets \u03b1 \u03b2) (i d d' h h') :\n    (self.update i d h).update i d' h' = self.update i d' h", "start": [29, 1], "end": [31, 45], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.size_eq", "code": "theorem size_eq (data : Buckets \u03b1 \u03b2) :\n  size data = .sum (data.1.data.map (\u00b7.toList.length))", "start": [33, 1], "end": [34, 62], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.mk_size", "code": "theorem mk_size (h) : (mk n h : Buckets \u03b1 \u03b2).size = 0", "start": [36, 1], "end": [38, 27], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.WF.mk'", "code": "theorem WF.mk' [BEq \u03b1] [Hashable \u03b1] (h) : (Buckets.mk n h : Buckets \u03b1 \u03b2).WF", "start": [40, 1], "end": [44, 81], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.Buckets.WF.update", "code": "theorem WF.update [BEq \u03b1] [Hashable \u03b1] {buckets : Buckets \u03b1 \u03b2} {i d h} (H : buckets.WF)\n    (h\u2081 : \u2200 [PartialEquivBEq \u03b1] [LawfulHashable \u03b1],\n      (buckets.1[i].toList.Pairwise fun a b => \u00ac(a.1 == b.1)) \u2192\n      d.toList.Pairwise fun a b => \u00ac(a.1 == b.1))\n    (h\u2082 : (buckets.1[i].All fun k _ => ((hash k).toUSize % buckets.1.size).toNat = i.toNat) \u2192\n      d.All fun k _ => ((hash k).toUSize % buckets.1.size).toNat = i.toNat) :\n    (buckets.update i d h).WF", "start": [46, 1], "end": [60, 38], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.reinsertAux_size", "code": "theorem reinsertAux_size [Hashable \u03b1] (data : Buckets \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) :\n    (reinsertAux data a b).size = data.size.succ", "start": [64, 1], "end": [68, 31], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.reinsertAux_WF", "code": "theorem reinsertAux_WF [BEq \u03b1] [Hashable \u03b1] {data : Buckets \u03b1 \u03b2} {a : \u03b1} {b : \u03b2} (H : data.WF)\n    (h\u2081 : \u2200 [PartialEquivBEq \u03b1] [LawfulHashable \u03b1],\n      haveI := mkIdx data.2 (hash a).toUSize\n      (data.val[this.1]'this.2).All fun x _ => \u00ac(a == x)) :\n    (reinsertAux data a b).WF", "start": [70, 1], "end": [77, 31], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.expand_size", "code": "theorem expand_size [Hashable \u03b1] {buckets : Buckets \u03b1 \u03b2} :\n    (expand sz buckets).buckets.size = buckets.size", "start": [79, 1], "end": [111, 50], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.expand_WF.foldl", "code": "theorem expand_WF.foldl [BEq \u03b1] [Hashable \u03b1] (rank : \u03b1 \u2192 Nat) {l : List (\u03b1 \u00d7 \u03b2)} {i : Nat}\n    (hl\u2081 : \u2200 [PartialEquivBEq \u03b1] [LawfulHashable \u03b1], l.Pairwise fun a b => \u00ac(a.1 == b.1))\n    (hl\u2082 : \u2200 x \u2208 l, rank x.1 = i)\n    {target : Buckets \u03b1 \u03b2} (ht\u2081 : target.WF)\n    (ht\u2082 : \u2200 bucket \u2208 target.1.data,\n      bucket.All fun k _ => rank k \u2264 i \u2227\n        \u2200 [PartialEquivBEq \u03b1] [LawfulHashable \u03b1], \u2200 x \u2208 l, \u00ac(x.1 == k)) :\n    (l.foldl (fun d x => reinsertAux d x.1 x.2) target).WF \u2227\n    \u2200 bucket \u2208 (l.foldl (fun d x => reinsertAux d x.1 x.2) target).1.data,\n      bucket.All fun k _ => rank k \u2264 i", "start": [113, 1], "end": [141, 25], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.expand_WF", "code": "theorem expand_WF [BEq \u03b1] [Hashable \u03b1] {buckets : Buckets \u03b1 \u03b2} (H : buckets.WF) :\n    (expand sz buckets).buckets.WF", "start": [143, 1], "end": [172, 54], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.insert_size", "code": "theorem insert_size [BEq \u03b1] [Hashable \u03b1] {m : Imp \u03b1 \u03b2} {k v}\n    (h : m.size = m.buckets.size) :\n    (insert m k v).size = (insert m k v).buckets.size", "start": [174, 1], "end": [187, 50], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.mem_replaceF", "code": "private theorem mem_replaceF {l : List (\u03b1 \u00d7 \u03b2)} {x : \u03b1 \u00d7 \u03b2} {p : \u03b1 \u00d7 \u03b2 \u2192 Bool} {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b2} :\n    x \u2208 (l.replaceF fun a => bif p a then some (k, f a) else none) \u2192 x.1 = k \u2228 x \u2208 l", "start": [189, 1], "end": [201, 46], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.pairwise_replaceF", "code": "private theorem pairwise_replaceF [BEq \u03b1] [PartialEquivBEq \u03b1]\n    {l : List (\u03b1 \u00d7 \u03b2)} {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b2}\n    (H : l.Pairwise fun a b => \u00ac(a.fst == b.fst)) :\n    (l.replaceF fun a => bif a.fst == k then some (k, f a) else none)\n      |>.Pairwise fun a b => \u00ac(a.fst == b.fst)", "start": [203, 1], "end": [219, 32], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.insert_WF", "code": "theorem insert_WF [BEq \u03b1] [Hashable \u03b1] {m : Imp \u03b1 \u03b2} {k v}\n    (h : m.buckets.WF) : (insert m k v).buckets.WF", "start": [221, 1], "end": [239, 32], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.erase_size", "code": "theorem erase_size [BEq \u03b1] [Hashable \u03b1] {m : Imp \u03b1 \u03b2} {k}\n    (h : m.size = m.buckets.size) :\n    (erase m k).size = (erase m k).buckets.size", "start": [241, 1], "end": [255, 12], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.erase_WF", "code": "theorem erase_WF [BEq \u03b1] [Hashable \u03b1] {m : Imp \u03b1 \u03b2} {k}\n    (h : m.buckets.WF) : (erase m k).buckets.WF", "start": [257, 1], "end": [263, 12], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.modify_size", "code": "theorem modify_size [BEq \u03b1] [Hashable \u03b1] {m : Imp \u03b1 \u03b2} {k}\n    (h : m.size = m.buckets.size) :\n    (modify m k f).size = (modify m k f).buckets.size", "start": [265, 1], "end": [271, 32], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.modify_WF", "code": "theorem modify_WF [BEq \u03b1] [Hashable \u03b1] {m : Imp \u03b1 \u03b2} {k}\n    (h : m.buckets.WF) : (modify m k f).buckets.WF", "start": [273, 1], "end": [281, 28], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.WF.out", "code": "theorem WF.out [BEq \u03b1] [Hashable \u03b1] {m : Imp \u03b1 \u03b2} (h : m.WF) :\n    m.size = m.buckets.size \u2227 m.buckets.WF", "start": [283, 1], "end": [290, 60], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.WF_iff", "code": "theorem WF_iff [BEq \u03b1] [Hashable \u03b1] {m : Imp \u03b1 \u03b2} :\n    m.WF \u2194 m.size = m.buckets.size \u2227 m.buckets.WF", "start": [292, 1], "end": [294, 39], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.WF.mapVal", "code": "theorem WF.mapVal {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} [BEq \u03b1] [Hashable \u03b1]\n    {m : Imp \u03b1 \u03b2} (H : WF m) : WF (mapVal f m)", "start": [296, 1], "end": [306, 23], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.Imp.WF.filterMap", "code": "theorem WF.filterMap {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 Option \u03b3} [BEq \u03b1] [Hashable \u03b1]\n    {m : Imp \u03b1 \u03b2} (H : WF m) : WF (filterMap f m)", "start": [308, 1], "end": [347, 43], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.mapVal", "code": "@[inline] def mapVal (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (self : HashMap \u03b1 \u03b2) : HashMap \u03b1 \u03b3 :=\n  \u27e8self.1.mapVal f, self.2.mapVal\u27e9", "start": [353, 1], "end": [355, 35], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.filterMap", "code": "@[inline] def filterMap (f : \u03b1 \u2192 \u03b2 \u2192 Option \u03b3) (self : HashMap \u03b1 \u03b2) : HashMap \u03b1 \u03b3 :=\n  \u27e8self.1.filterMap f, self.2.filterMap\u27e9", "start": [357, 1], "end": [362, 41], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.filter", "code": "@[inline] def filter (f : \u03b1 \u2192 \u03b2 \u2192 Bool) (self : HashMap \u03b1 \u03b2) : HashMap \u03b1 \u03b2 :=\n  self.filterMap fun a b => bif f a b then some b else none", "start": [364, 1], "end": [366, 60], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Delaborator.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PrettyPrinter.Delaborator.withOverApp", "code": "def Lean.PrettyPrinter.Delaborator.withOverApp (arity : Nat) (x : Delab) : Delab := do\n  let n := (\u2190 getExpr).getAppNumArgs\n  guard (n \u2265 arity)\n  let kinds \u2190 getParamKinds\n  let rec\n  \n  loop : Nat \u2192 DelabM (Term \u00d7 Array Term)\n  | 0 => return (\u2190 x, #[])\n  | n+1 => do\n    let mut (fnStx, args) \u2190 withAppFn (loop n)\n    if kinds.get? (n + arity) |>.all (\u00b7.bInfo.isExplicit) then\n      args := args.push (\u2190 withAppArg delab)\n    pure (fnStx, args)\n  let (fnStx, argStxs) \u2190 loop (n - arity)\n  return Syntax.mkApp fnStx argStxs", "start": [10, 1], "end": [38, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.ppConst", "code": "def Lean.ppConst (e : Expr) : MessageData :=\n  if e.isConst then\n    .ofPPFormat {\n      pp := fun\n        | some ctx => ctx.runMetaM <| withOptions (pp.tagAppFns.set \u00b7 true) <|\n          PrettyPrinter.ppExprWithInfos (delab := delabConst) e\n        | none => return f!\"{e}\"\n    }\n  else\n    panic! \"not a constant\"", "start": [40, 1], "end": [55, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Check.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompatibleTypes.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Check.Context", "code": "structure Context where\n  \n  jps : FVarIdSet := {}\n  \n  vars : FVarIdSet := {}", "start": [84, 1], "end": [88, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.State", "code": "structure State where\n  \n  all : FVarIdHashSet := {}", "start": [90, 1], "end": [92, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.CheckM", "code": "abbrev CheckM := ReaderT Context $ StateRefT State InferTypeM", "start": [94, 1], "end": [94, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkTypes", "code": "def checkTypes : CheckM Bool := do\n  return (\u2190 getConfig).checkTypes", "start": [96, 1], "end": [97, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkFVar", "code": "def checkFVar (fvarId : FVarId) : CheckM Unit :=\n  unless (\u2190 read).vars.contains fvarId do\n    throwError \"invalid out of scope free variable {\u2190 getBinderName fvarId}\"", "start": [99, 1], "end": [101, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.isCtorParam", "code": "def isCtorParam (f : Expr) (i : Nat) : CoreM Bool := do\n  let .const declName _ := f | return false\n  let .ctorInfo info \u2190 getConstInfo declName | return false\n  return i < info.numParams", "start": [103, 1], "end": [107, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkAppArgs", "code": "def checkAppArgs (f : Expr) (args : Array Arg) : CheckM Unit := do\n  let mut fType \u2190 inferType f\n  let mut j := 0\n  for i in [:args.size] do\n    let arg := args[i]!\n    if fType.isErased then\n      return ()\n    fType := fType.headBeta\n    let (d, b) \u2190\n      match fType with\n      | .forallE _ d b _ => pure (d, b)\n      | _ =>\n        fType := instantiateRevRangeArgs fType j i args |>.headBeta\n        match fType with\n        | .forallE _ d b _ => j := i; pure (d, b)\n        | _ => return ()\n    let expectedType := instantiateRevRangeArgs d j i args\n    if (\u2190 checkTypes) then\n      let argType \u2190 arg.inferType\n      unless (\u2190 InferType.compatibleTypes argType expectedType) do\n        throwError \"type mismatch at LCNF application{indentExpr (mkAppN f (args.map Arg.toExpr))}\\nargument {arg.toExpr} has type{indentExpr argType}\\nbut is expected to have type{indentExpr expectedType}\"\n    unless (\u2190 pure (maybeTypeFormerType expectedType) <||> isErasedCompatible expectedType) do\n      match arg with\n      | .fvar fvarId => checkFVar fvarId\n      | .erased => pure ()\n      | .type _ =>\n        unless (\u2190 getPhase) \u2265 .mono && (\u2190 isCtorParam f i) do\n          throwError \"invalid LCNF application{indentExpr (mkAppN f (args.map (\u00b7.toExpr)))}\\nargument{indentExpr arg.toExpr}\\nhas type{indentExpr expectedType}\\nmust be a free variable\"\n    fType := b", "start": [109, 1], "end": [138, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkLetValue", "code": "def checkLetValue (e : LetValue) : CheckM Unit := do\n  match e with\n  | .value .. | .erased => pure ()\n  | .const declName us args => checkAppArgs (mkConst declName us) args\n  | .fvar fvarId args => checkFVar fvarId; checkAppArgs (.fvar fvarId) args\n  | .proj _ _ fvarId => checkFVar fvarId", "start": [140, 1], "end": [145, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkJpInScope", "code": "def checkJpInScope (jp : FVarId) : CheckM Unit := do\n  unless (\u2190 read).jps.contains jp do\n    \n    throwError \"invalid jump to out of scope join point `{mkFVar jp}`\"", "start": [147, 1], "end": [159, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkParam", "code": "def checkParam (param : Param) : CheckM Unit := do\n  unless param == (\u2190 getParam param.fvarId) do\n    throwError \"LCNF parameter mismatch at `{param.binderName}`, does not value in local context\"", "start": [161, 1], "end": [163, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkParams", "code": "def checkParams (params : Array Param) : CheckM Unit :=\n  params.forM checkParam", "start": [165, 1], "end": [166, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkLetDecl", "code": "def checkLetDecl (letDecl : LetDecl) : CheckM Unit := do\n  checkLetValue letDecl.value\n  if (\u2190 checkTypes) then\n    let valueType \u2190 letDecl.value.inferType\n    unless (\u2190 InferType.compatibleTypes letDecl.type valueType) do\n      throwError \"type mismatch at `{letDecl.binderName}`, value has type{indentExpr valueType}\\nbut is expected to have type{indentExpr letDecl.type}\"\n  unless letDecl == (\u2190 getLetDecl letDecl.fvarId) do\n    throwError \"LCNF let declaration mismatch at `{letDecl.binderName}`, does not match value in local context\"", "start": [168, 1], "end": [175, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.addFVarId", "code": "def addFVarId (fvarId : FVarId) : CheckM Unit := do\n  if (\u2190 get).all.contains fvarId then\n    throwError \"invalid LCNF, free variables are not unique `{fvarId.name}`\"\n  modify fun s => { s with all := s.all.insert fvarId }", "start": [177, 1], "end": [180, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.withFVarId", "code": "@[inline] def withFVarId (fvarId : FVarId) (x : CheckM \u03b1) : CheckM \u03b1 := do\n  addFVarId fvarId\n  withReader (fun ctx => { ctx with vars := ctx.vars.insert fvarId }) x", "start": [182, 1], "end": [184, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.withJp", "code": "@[inline] def withJp (fvarId : FVarId) (x : CheckM \u03b1) : CheckM \u03b1 := do\n  addFVarId fvarId\n  withReader (fun ctx => { ctx with jps := ctx.jps.insert fvarId }) x", "start": [186, 1], "end": [188, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.withParams", "code": "@[inline] def withParams (params : Array Param) (x : CheckM \u03b1) : CheckM \u03b1 := do\n  params.forM (addFVarId \u00b7.fvarId)\n  withReader (fun ctx => { ctx with vars := params.foldl (init := ctx.vars) fun vars p => vars.insert p.fvarId })\n    x", "start": [190, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkFunDeclCore", "code": "partial def checkFunDeclCore (declName : Name) (params : Array Param) (type : Expr) (value : Code) : CheckM Unit := do\n  checkParams params\n  withParams params do\n    discard <| check value\n    if (\u2190 checkTypes) then\n      let valueType \u2190 mkForallParams params (\u2190 value.inferType)\n      unless (\u2190 InferType.compatibleTypes type valueType) do\n        throwError \"type mismatch at `{declName}`, value has type{indentExpr valueType}\\nbut is expected to have type{indentExpr type}\"", "start": [199, 1], "end": [206, 136], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkFunDecl", "code": "partial def checkFunDecl (funDecl : FunDecl) : CheckM Unit := do\n  checkFunDeclCore funDecl.binderName funDecl.params funDecl.type funDecl.value\n  let decl \u2190 getFunDecl funDecl.fvarId\n  unless decl.binderName == funDecl.binderName do\n    throwError \"LCNF local function declaration mismatch at `{funDecl.binderName}`, binder name in local context `{decl.binderName}`\"\n  unless decl.type == funDecl.type do\n    throwError \"LCNF local function declaration mismatch at `{funDecl.binderName}`, type in local context{indentExpr decl.type}\\nexpected{indentExpr funDecl.type}\"\n  unless (\u2190 getFunDecl funDecl.fvarId) == funDecl do\n    throwError \"LCNF local function declaration mismatch at `{funDecl.binderName}`, declaration in local context does match\"", "start": [208, 1], "end": [216, 125], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.checkCases", "code": "partial def checkCases (c : Cases) : CheckM Unit := do\n  let mut ctorNames : NameSet := {}\n  let mut hasDefault := false\n  checkFVar c.discr\n  for alt in c.alts do\n    match alt with\n    | .default k => hasDefault := true; check k\n    | .alt ctorName params k =>\n      checkParams params\n      if ctorNames.contains ctorName then\n        throwError \"invalid LCNF `cases`, alternative `{ctorName}` occurs more than once\"\n      ctorNames := ctorNames.insert ctorName\n      let .ctorInfo val \u2190 getConstInfo ctorName | throwError \"invalid LCNF `cases`, `{ctorName}` is not a constructor name\"\n      unless val.induct == c.typeName do\n        throwError \"invalid LCNF `cases`, `{ctorName}` is not a constructor of `{c.typeName}`\"\n      unless params.size == val.numFields do\n        throwError \"invalid LCNF `cases`, `{ctorName}` has # {val.numFields} fields, but alternative has # {params.size} alternatives\"\n      withParams params do check k", "start": [218, 1], "end": [235, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.check", "code": "partial def check (code : Code) : CheckM Unit := do\n  match code with\n  | .let decl k => checkLetDecl decl; withFVarId decl.fvarId do check k\n  | .fun decl k =>\n    withReader (fun ctx => { ctx with jps := {} }) do checkFunDecl decl\n    withFVarId decl.fvarId do check k\n  | .jp decl k => checkFunDecl decl; withJp decl.fvarId do check k\n  | .cases c => checkCases c\n  | .jmp fvarId args =>\n    checkJpInScope fvarId\n    let decl \u2190 getFunDecl fvarId\n    unless decl.getArity == args.size do\n      throwError \"invalid LCNF `goto`, join point {decl.binderName} has #{decl.getArity} parameters, but #{args.size} were provided\"\n    checkAppArgs (.fvar fvarId) args\n  | .return fvarId => checkFVar fvarId\n  | .unreach .. => pure ()", "start": [237, 1], "end": [253, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Check.run", "code": "def run (x : CheckM \u03b1) : CompilerM \u03b1 :=\n  x |>.run {} |>.run' {} |>.run {}", "start": [257, 1], "end": [258, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.check", "code": "def Decl.check (decl : Decl) : CompilerM Unit := do\n  Check.run do Check.checkFunDeclCore decl.name decl.params decl.type decl.value", "start": [262, 1], "end": [263, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.checkDeadLocalDecls", "code": "partial def checkDeadLocalDecls (decls : Array Decl) : CompilerM Unit := do\n  let (_, s) := visitDecls decls |>.run {}\n  let usesFVar (binderName : Name) (fvarId : FVarId) :=\n    unless s.contains fvarId do\n      throwError \"LCNF local context contains unused local variable declaration `{binderName}`\"\n  let lctx := (\u2190 get).lctx\n  lctx.params.forM fun fvarId decl => usesFVar decl.binderName fvarId\n  lctx.letDecls.forM fun fvarId decl => usesFVar decl.binderName fvarId\n  lctx.funDecls.forM fun fvarId decl => usesFVar decl.binderName fvarId\nwhere\n  visitFVar (fvarId : FVarId) : StateM FVarIdHashSet Unit :=\n    modify (\u00b7.insert fvarId)\n\n  visitParam (param : Param) : StateM FVarIdHashSet Unit := do\n    visitFVar param.fvarId\n\n  visitParams (params : Array Param) : StateM FVarIdHashSet Unit := do\n    params.forM visitParam\n\n  visitCode (code : Code) : StateM FVarIdHashSet Unit := do\n    match code with\n    | .jmp .. | .return .. | .unreach .. => return ()\n    | .let decl k => visitFVar decl.fvarId; visitCode k\n    | .fun decl k | .jp decl k =>\n      visitFVar decl.fvarId; visitParams decl.params; visitCode decl.value\n      visitCode k\n    | .cases c => c.alts.forM fun alt => do\n      match alt with\n      | .default k => visitCode k\n      | .alt _ ps k => visitParams ps; visitCode k\n\n  visitDecl (decl : Decl) : StateM FVarIdHashSet Unit := do\n    visitParams decl.params\n    visitCode decl.value\n\n  visitDecls (decls : Array Decl) : StateM FVarIdHashSet Unit :=\n    decls.forM visitDecl", "start": [265, 1], "end": [304, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToDecl.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatcherInfo.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ImplementedByAttr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToLCNF.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.macroInline", "code": "def macroInline (e : Expr) : CoreM Expr :=\n  Core.transform e fun e => do\n    let .const declName us := e.getAppFn | return .continue\n    unless hasMacroInlineAttribute (\u2190 getEnv) declName do return .continue\n    let val \u2190 Core.instantiateValueLevelParams (\u2190 getConstInfo declName) us\n    return .visit <| val.beta e.getAppArgs", "start": [12, 1], "end": [20, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normalizeAlt", "code": "private def normalizeAlt (e : Expr) (numParams : Nat) : MetaM Expr :=\n  Meta.lambdaTelescope e fun xs body => do\n    if xs.size == numParams then\n      return e\n    else if xs.size > numParams then\n      let body \u2190 Meta.mkLambdaFVars xs[numParams:] body\n      let body \u2190 Meta.withLetDecl (\u2190 mkFreshUserName `_k) (\u2190 Meta.inferType body) body fun x => Meta.mkLetFVars #[x] x\n      Meta.mkLambdaFVars xs[:numParams] body\n    else\n      Meta.forallBoundedTelescope (\u2190 Meta.inferType e) (numParams - xs.size) fun ys _ =>\n        Meta.mkLambdaFVars (xs ++ ys) (mkAppN e ys)", "start": [22, 1], "end": [32, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.inlineMatchers", "code": "partial def inlineMatchers (e : Expr) : CoreM Expr :=\n  Meta.MetaM.run' <| Meta.transform e fun e => do\n    let .const declName us := e.getAppFn | return .continue\n    let some info \u2190 Meta.getMatcherInfo? declName | return .continue\n    let numArgs := e.getAppNumArgs\n    if numArgs > info.arity then\n      return .continue\n    else if numArgs < info.arity then\n      Meta.forallBoundedTelescope (\u2190 Meta.inferType e) (info.arity - numArgs) fun xs _ =>\n        return .visit (\u2190 Meta.mkLambdaFVars xs (mkAppN e xs))\n    else\n      let mut args := e.getAppArgs\n      let numAlts := info.numAlts\n      let altNumParams := info.altNumParams\n      let rec inlineMatcher (i : Nat) (args : Array Expr) (letFVars : Array Expr) : MetaM Expr := do\n        if i < numAlts then\n          let altIdx := i + info.getFirstAltPos\n          let numParams := altNumParams[i]!\n          let alt \u2190 normalizeAlt args[altIdx]! numParams\n          Meta.withLetDecl (\u2190 mkFreshUserName `_alt) (\u2190 Meta.inferType alt) alt fun altFVar =>\n            inlineMatcher (i+1) (args.set! altIdx altFVar) (letFVars.push altFVar)\n        else\n          let info \u2190 getConstInfo declName\n          let value := (\u2190 Core.instantiateValueLevelParams info us).beta args\n          Meta.mkLetFVars letFVars value\n      return .visit (\u2190 inlineMatcher 0 args #[])", "start": [34, 1], "end": [62, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.replaceUnsafeRecNames", "code": "private def replaceUnsafeRecNames (value : Expr) : CoreM Expr :=\n  Core.transform value fun e =>\n    match e with\n    | .const declName us =>\n      if let some safeDeclName := isUnsafeRecName? declName then\n        return .done (.const safeDeclName us)\n      else\n        return .done e\n    | _ => return .continue", "start": [64, 1], "end": [75, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getDeclInfo?", "code": "def getDeclInfo? (declName : Name) : CoreM (Option ConstantInfo) := do\n  let env \u2190 getEnv\n  return env.find? (mkUnsafeRecName declName) <|> env.find? declName", "start": [77, 1], "end": [84, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.toDecl", "code": "def toDecl (declName : Name) : CompilerM Decl := do\n  let declName := if let some name := isUnsafeRecName? declName then name else declName\n  let some info \u2190 getDeclInfo? declName | throwError \"declaration `{declName}` not found\"\n  let some value := info.value? | throwError \"declaration `{declName}` does not have a value\"\n  let (type, value) \u2190 Meta.MetaM.run' do\n    let type  \u2190 toLCNFType info.type\n    let value \u2190 Meta.lambdaTelescope value fun xs body => do Meta.mkLambdaFVars xs (\u2190 Meta.etaExpand body)\n    let value \u2190 replaceUnsafeRecNames value\n    let value \u2190 macroInline value\n    \n    let value \u2190 inlineMatchers value\n    \n    let value \u2190 macroInline value\n    \n        return (type, value)\n  let value \u2190 toLCNF value\n  let safe := !info.isPartial && !info.isUnsafe\n  let inlineAttr? := getInlineAttribute? (\u2190 getEnv) declName\n  let decl \u2190 if let .fun decl (.return _) := value then\n    eraseFunDecl decl (recursive := false)\n    pure { name := declName, params := decl.params, type, value := decl.value, levelParams := info.levelParams, safe, inlineAttr? : Decl }\n  else\n    pure { name := declName, params := #[], type, value, levelParams := info.levelParams, safe, inlineAttr? }\n  \n  decl.etaExpand", "start": [86, 1], "end": [123, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Passes.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ElimDeadBranches.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToMono.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/JoinPoints.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/FloatLetIn.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CSE.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PullLetDecls.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PullFunDecls.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ReduceJpArity.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Specialize.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/LambdaLifting.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ReduceArity.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.init", "code": "def init : Pass where\n  name  := `init\n  run   := fun decls => do\n    decls.forM (\u00b7.saveBase)\n    return decls\n  phase := .base", "start": [25, 1], "end": [30, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.trace", "code": "def trace (phase := Phase.base) : Pass where\n  name  := `trace\n  run   := pure\n  phase := phase", "start": [33, 1], "end": [36, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.saveBase", "code": "def saveBase : Pass :=\n  .mkPerDeclaration `saveBase (fun decl => do (\u2190 normalizeFVarIds decl).saveBase; return decl) .base", "start": [38, 1], "end": [39, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.saveMono", "code": "def saveMono : Pass :=\n  .mkPerDeclaration `saveMono (fun decl => do (\u2190 normalizeFVarIds decl).saveMono; return decl) .mono", "start": [41, 1], "end": [42, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.builtinPassManager", "code": "def builtinPassManager : PassManager := {\n  passes := #[\n    init,\n    pullInstances,\n    cse,\n    simp,\n    floatLetIn,\n    findJoinPoints,\n    pullFunDecls,\n    reduceJpArity,\n    \n    simp { etaPoly := true, inlinePartial := true, implementedBy := true } (occurrence := 1),\n    eagerLambdaLifting,\n    specialize,\n    simp (occurrence := 2),\n    cse (occurrence := 1),\n    saveBase, toMono,\n    simp (occurrence := 3) (phase := .mono),\n    reduceJpArity (phase := .mono),\n    extendJoinPointContext (phase := .mono) (occurrence := 0),\n    floatLetIn (phase := .mono) (occurrence := 1),\n    reduceArity,\n    commonJoinPointArgs,\n    simp (occurrence := 4) (phase := .mono),\n    floatLetIn (phase := .mono) (occurrence := 2),\n    elimDeadBranches,\n    lambdaLifting,\n    extendJoinPointContext (phase := .mono) (occurrence := 1),\n    simp (occurrence := 5) (phase := .mono),\n    cse (occurrence := 2) (phase := .mono),\n    saveMono  ]\n}", "start": [44, 1], "end": [81, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.runImportedDecls", "code": "def runImportedDecls (importedDeclNames : Array (Array Name)) : CoreM PassManager := do\n  let mut m := builtinPassManager\n  for declNames in importedDeclNames do\n    for declName in declNames do\n      m \u2190 runFromDecl m declName\n  return m", "start": [83, 1], "end": [88, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getPassManager", "code": "def getPassManager : CoreM PassManager :=\n  return passManagerExt.getState (\u2190 getEnv) |>.2", "start": [98, 1], "end": [99, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.addPass", "code": "def addPass (declName : Name) : CoreM Unit := do\n  let info \u2190 getConstInfo declName\n  match info.type with\n  | .const `Lean.Compiler.LCNF.PassInstaller .. =>\n    let managerNew \u2190 runFromDecl (\u2190 getPassManager) declName\n    modifyEnv fun env => passManagerExt.addEntry env (declName, managerNew)\n  | _ =>\n    throwError \"invalid 'cpass' only 'PassInstaller's can be added via the 'cpass' attribute: {info.type}\"", "start": [101, 1], "end": [108, 107], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/Options.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Trace.lean", "lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/ElimDeadVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/FreeVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.reshapeWithoutDead", "code": "partial def reshapeWithoutDead (bs : Array FnBody) (term : FnBody) : FnBody :=\n  let rec reshape (bs : Array FnBody) (b : FnBody) (used : IndexSet) :=\n    if bs.isEmpty then b\n    else\n      let curr := bs.back\n      let bs   := bs.pop\n      let keep (_ : Unit) :=\n        let used := curr.collectFreeIndices used\n        let b    := curr.setBody b\n        reshape bs b used\n      let keepIfUsed (vidx : Index) :=\n        if used.contains vidx then keep ()\n        else reshape bs b used\n      match curr with\n      | FnBody.vdecl x _ _ _  => keepIfUsed x.idx\n      | FnBody.jdecl j _ _ _  => keepIfUsed j.idx\n      | _                     => keep ()\n  reshape bs term term.freeIndices", "start": [11, 1], "end": [29, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.elimDead", "code": "partial def FnBody.elimDead (b : FnBody) : FnBody :=\n  let (bs, term) := b.flatten\n  let bs         := modifyJPs bs elimDead\n  let term       := match term with\n    | FnBody.case tid x xType alts =>\n      let alts := alts.map fun alt => alt.modifyBody elimDead\n      FnBody.case tid x xType alts\n    | other => other\n  reshapeWithoutDead bs term", "start": [31, 1], "end": [39, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.elimDead", "code": "def Decl.elimDead (d : Decl) : Decl :=\n  match d with\n  | .fdecl (body := b) .. => d.updateBody! b.elimDead\n  | other => other", "start": [41, 1], "end": [45, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/ClosedTermCache.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ClosedTermCache", "code": "structure ClosedTermCache where\n  map        : PHashMap Expr Name := {}\n  constNames : NameSet := {}\n  deriving Inhabited", "start": [10, 1], "end": [13, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.cacheClosedTermName", "code": "@[export lean_cache_closed_term_name]\ndef cacheClosedTermName (env : Environment) (e : Expr) (n : Name) : Environment :=\n  closedTermCacheExt.modifyState env fun s => { s with map := s.map.insert e n, constNames := s.constNames.insert n }", "start": [17, 1], "end": [19, 118], "kind": "commanddeclaration"}, {"full_name": "Lean.getClosedTermName?", "code": "@[export lean_get_closed_term_name]\ndef getClosedTermName? (env : Environment) (e : Expr) : Option Name :=\n  (closedTermCacheExt.getState env).map.find? e", "start": [21, 1], "end": [23, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.isClosedTermName", "code": "def isClosedTermName (env : Environment) (n : Name) : Bool :=\n  (closedTermCacheExt.getState env).constNames.contains n", "start": [25, 1], "end": [26, 58], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Runtime.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.closureMaxArgsFn", "code": "@[extern \"lean_closure_max_args\"]\nopaque closureMaxArgsFn : Unit \u2192 Nat", "start": [9, 1], "end": [10, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.maxSmallNatFn", "code": "@[extern \"lean_max_small_nat\"]\nopaque maxSmallNatFn : Unit \u2192 Nat", "start": [12, 1], "end": [13, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.closureMaxArgs", "code": "def closureMaxArgs : Nat :=\n  closureMaxArgsFn ()", "start": [15, 1], "end": [16, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.maxSmallNat", "code": "def maxSmallNat : Nat :=\n  maxSmallNatFn ()", "start": [18, 1], "end": [19, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/ComputedFields.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Constructions.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ImplementedByAttr.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Eqns.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.ComputedFields.mkUnsafeCastTo", "code": "def mkUnsafeCastTo (expectedType : Expr) (e : Expr) : MetaM Expr :=\n  mkAppOptM ``unsafeCast #[none, expectedType, e]", "start": [40, 1], "end": [41, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.isScalarField", "code": "def isScalarField (ctor : Name) : CoreM Bool :=\n  return (\u2190 getConstInfoCtor ctor).numFields == 0", "start": [43, 1], "end": [44, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.Context", "code": "structure Context extends InductiveVal where\n  lparams : List Level\n  params : Array Expr\n  compFields : Array Name\n  compFieldVars : Array Expr\n  indices : Array Expr\n  val : Expr", "start": [46, 1], "end": [52, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.M", "code": "abbrev M := ReaderT Context MetaM", "start": [54, 1], "end": [54, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.getComputedFieldValue", "code": "def getComputedFieldValue (computedField : Name) (ctorTerm : Expr) : MetaM Expr := do\n  let ctorName := ctorTerm.getAppFn.constName!\n  let ind \u2190 getConstInfoInduct (\u2190 getConstInfoCtor ctorName).induct\n  let val \u2190 mkAppOptM computedField (mkArray (ind.numParams+ind.numIndices) none ++ #[some ctorTerm])\n  let val \u2190\n    if let some wfEqn := WF.eqnInfoExt.find? (\u2190 getEnv) computedField then\n      pure <| mkAppN (wfEqn.value.instantiateLevelParams wfEqn.levelParams val.getAppFn.constLevels!) val.getAppArgs\n    else\n      unfoldDefinition val\n  let val \u2190 whnfHeadPred val (return ctorTerm.occurs \u00b7)\n  if !ctorTerm.occurs val then return val\n  throwError \"computed field {computedField} does not reduce for constructor {ctorName}\"", "start": [57, 1], "end": [68, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.validateComputedFields", "code": "def validateComputedFields : M Unit := do\n  let {compFieldVars, indices, val ..} \u2190 read\n  for cf in compFieldVars do\n    let ty \u2190 inferType cf\n    if ty.containsFVar val.fvarId! then\n      throwError \"computed field {cf}'s type must not depend on value{indentExpr ty}\"\n    if indices.any (ty.containsFVar \u00b7.fvarId!) then\n      throwError \"computed field {cf}'s type must not depend on indices{indentExpr ty}\"", "start": [70, 1], "end": [77, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.mkImplType", "code": "def mkImplType : M Unit := do\n  let {name, isUnsafe, type, ctors, levelParams, numParams, lparams, params, compFieldVars, ..} \u2190 read\n  addDecl <| .inductDecl levelParams numParams\n    (isUnsafe := isUnsafe) [{ name := name ++ `_impl, type,\n       ctors := \u2190 ctors.mapM fun ctor => do\n         forallTelescope (\u2190 inferType (mkAppN (mkConst ctor lparams) params)) fun fields retTy => do\n           let retTy := mkAppN (mkConst (name ++ `_impl) lparams) retTy.getAppArgs\n           let type \u2190 mkForallFVars (params ++ (if \u2190 isScalarField ctor then #[] else compFieldVars) ++ fields) retTy\n           return { name := ctor ++ `_impl, type } }]", "start": [79, 1], "end": [88, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.overrideCasesOn", "code": "def overrideCasesOn : M Unit := do\n  let {name, numIndices, ctors, lparams, params, compFieldVars, ..} \u2190 read\n  let casesOn \u2190 getConstInfoDefn (mkCasesOnName name)\n  mkCasesOn (name ++ `_impl)\n  let value \u2190\n    forallTelescope (\u2190 instantiateForall casesOn.type params) fun xs constMotive => do\n      let (indices, major, minors) := (xs[1:numIndices+1].toArray,\n        xs[numIndices+1]!, xs[numIndices+2:].toArray)\n      let majorImplTy := mkAppN (mkConst (name ++ `_impl) lparams) (params ++ indices)\n      mkLambdaFVars (params ++ xs) <|\n        mkAppN (mkConst (mkCasesOnName (name ++ `_impl))\n            (casesOn.levelParams.map mkLevelParam)) <|\n        params ++\n        #[\u2190 withLocalDeclD `a majorImplTy fun majorImpl => do\n          withLetDecl `m (\u2190 inferType constMotive) constMotive fun m => do\n          mkLambdaFVars (#[m] ++ indices ++ #[majorImpl]) m] ++\n        indices ++ #[\u2190 mkUnsafeCastTo majorImplTy major] ++\n        (\u2190 (minors.zip ctors.toArray).mapM fun (minor, ctor) => do\n          forallTelescope (\u2190 inferType minor) fun args _ => do\n            mkLambdaFVars ((if \u2190 isScalarField ctor then #[] else compFieldVars) ++ args)\n              (\u2190 mkUnsafeCastTo constMotive (mkAppN minor args)))\n  let nameOverride := mkCasesOnName name ++ `_override\n  addDecl <| .defnDecl { casesOn with\n    name := nameOverride\n    all  := [nameOverride]\n    value\n    hints  := .opaque\n    safety := .unsafe\n  }\n  setInlineAttribute (mkCasesOnName name ++ `_override)\n  setImplementedBy (mkCasesOnName name) (mkCasesOnName name ++ `_override)", "start": [90, 1], "end": [120, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.overrideConstructors", "code": "def overrideConstructors : M Unit := do\n  let {ctors, levelParams, lparams, params, compFields, ..} \u2190 read\n  for ctor in ctors do\n    forallTelescope (\u2190 inferType (mkAppN (mkConst ctor lparams) params)) fun fields retTy => do\n    let ctorTerm := mkAppN (mkConst ctor lparams) (params ++ fields)\n    let computedFieldVals \u2190 if \u2190 isScalarField ctor then pure #[] else\n      compFields.mapM (getComputedFieldValue \u00b7 ctorTerm)\n    addDecl <| .defnDecl {\n      name := ctor ++ `_override\n      levelParams\n      type := \u2190 inferType (mkConst ctor lparams)\n      value := \u2190 mkLambdaFVars (params ++ fields) <| \u2190 mkUnsafeCastTo retTy <|\n        mkAppN (mkConst (ctor ++ `_impl) lparams) (params ++ computedFieldVals ++ fields)\n      hints := .opaque\n      safety := .unsafe\n    }\n    setImplementedBy ctor (ctor ++ `_override)\n    if \u2190 isScalarField ctor then setInlineAttribute (ctor ++ `_override)", "start": [122, 1], "end": [139, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.overrideComputedFields", "code": "def overrideComputedFields : M Unit := do\n  let {name, levelParams, ctors, compFields, compFieldVars, lparams, params, indices, val ..} \u2190 read\n  withLocalDeclD `x (mkAppN (mkConst (name ++ `_impl) lparams) (params ++ indices)) fun xImpl => do\n  for cfn in compFields, cf in compFieldVars do\n    if isExtern (\u2190 getEnv) cfn then\n      compileDecls [cfn]\n      continue\n    let cases \u2190 ctors.toArray.mapM fun ctor => do\n      forallTelescope (\u2190 inferType (mkAppN (mkConst ctor lparams) params)) fun fields _ => do\n      if \u2190 isScalarField ctor then\n        mkLambdaFVars fields <|\n          \u2190 getComputedFieldValue cfn (mkAppN (mkConst ctor lparams) (params ++ fields))\n      else\n        mkLambdaFVars (compFieldVars ++ fields) cf\n    addDecl <| .defnDecl {\n      name := cfn ++ `_override\n      levelParams\n      type := \u2190 mkForallFVars (params ++ indices ++ #[val]) (\u2190 inferType cf)\n      value := \u2190 mkLambdaFVars (params ++ indices ++ #[val]) <|\n        \u2190 mkAppOptM (mkCasesOnName (name ++ `_impl))\n          ((params ++ #[\u2190 mkLambdaFVars (indices.push xImpl) (\u2190 inferType cf)] ++ indices ++\n            #[\u2190 mkUnsafeCastTo (\u2190 inferType xImpl) val] ++ cases).map some)\n      safety := .unsafe\n      hints := .opaque\n    }\n    setImplementedBy cfn (cfn ++ `_override)", "start": [141, 1], "end": [166, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.mkComputedFieldOverrides", "code": "def mkComputedFieldOverrides (declName : Name) (compFields : Array Name) : MetaM Unit := do\n  let ind \u2190 getConstInfoInduct declName\n  if ind.ctors.length < 2 then\n    throwError \"computed fields require at least two constructors\"\n  let lparams := ind.levelParams.map mkLevelParam\n  forallTelescope ind.type fun paramsIndices _ => do\n  withLocalDeclD `x (mkAppN (mkConst ind.name lparams) paramsIndices) fun val => do\n    let params := paramsIndices[:ind.numParams].toArray\n    let indices := paramsIndices[ind.numParams:].toArray\n    let compFieldVars := compFields.map fun fieldDeclName =>\n      (fieldDeclName.updatePrefix .anonymous,\n        fun _ => do inferType (\u2190 mkAppM fieldDeclName (params ++ indices ++ #[val])))\n    withLocalDeclsD compFieldVars fun compFieldVars => do\n      let ctx := { ind with lparams, params, compFields, compFieldVars, indices, val }\n      ReaderT.run (r := ctx) do\n        validateComputedFields\n        mkImplType\n        overrideCasesOn\n        overrideConstructors\n        overrideComputedFields", "start": [168, 1], "end": [187, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ComputedFields.setComputedFields", "code": "def setComputedFields (computedFields : Array (Name \u00d7 Array Name)) : MetaM Unit := do\n  for (indName, computedFieldNames) in computedFields do\n    for computedFieldName in computedFieldNames do\n      unless computedFieldAttr.hasTag (\u2190 getEnv) computedFieldName do\n        logError m!\"'{computedFieldName}' must be tagged with @[computed_field]\"\n    mkComputedFieldOverrides indName computedFieldNames\n\n  compileDecls <| computedFields.toList.map fun (indName, _) =>\n    mkCasesOnName indName ++ `_override\n\n  let mut toCompile := #[]\n  for (declName, computedFields) in computedFields do\n    let ind \u2190 getConstInfoInduct declName\n    for ctor in ind.ctors do\n      toCompile := toCompile.push (ctor ++ `_override)\n    for fieldName in computedFields do\n      unless isExtern (\u2190 getEnv) fieldName do\n        toCompile := toCompile.push <| fieldName ++ `_override\n  compileDecls toCompile.toList", "start": [189, 1], "end": [217, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.MkInstResult", "code": "structure MkInstResult where\n  instVal   : Expr\n  instType  : Expr\n  outParams : Array Expr := #[]", "start": [14, 1], "end": [18, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkInst?", "code": "private partial def mkInst? (className : Name) (type : Expr) : MetaM (Option MkInstResult) := do\n  let rec go? (instType instTypeType : Expr) (outParams : Array Expr) : MetaM (Option MkInstResult) := do\n    let instTypeType \u2190 whnfD instTypeType\n    unless instTypeType.isForall do\n      return none\n    let d := instTypeType.bindingDomain!\n    if d.isOutParam then\n      let mvar \u2190 mkFreshExprMVar d\n      go? (mkApp instType mvar) (instTypeType.bindingBody!.instantiate1 mvar) (outParams.push mvar)\n    else\n      unless (\u2190 isDefEqGuarded (\u2190 inferType type) d) do\n        return none\n      let instType \u2190 instantiateMVars (mkApp instType type)\n      let instVal \u2190 synthInstance instType\n      return some { instVal, instType, outParams }\n  let instType \u2190 mkConstWithFreshMVarLevels className\n  go? instType (\u2190 inferType instType) #[]", "start": [20, 1], "end": [39, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.processDefDeriving", "code": "def processDefDeriving (className : Name) (declName : Name) : TermElabM Bool := do\n  try\n    let ConstantInfo.defnInfo info \u2190 getConstInfo declName | return false\n    let some result \u2190 mkInst? className info.value | return false\n    let instTypeNew := mkApp result.instType.appFn! (Lean.mkConst declName (info.levelParams.map mkLevelParam))\n    Meta.check instTypeNew\n    let instName \u2190 liftMacroM <| mkUnusedBaseName (declName.appendBefore \"inst\" |>.appendAfter className.getString!)\n    addAndCompile <| Declaration.defnDecl {\n      name        := instName\n      levelParams := info.levelParams\n      type        := (\u2190 instantiateMVars instTypeNew)\n      value       := (\u2190 instantiateMVars result.instVal)\n      hints       := info.hints\n      safety      := info.safety\n    }\n    addInstance instName AttributeKind.global (eval_prio default)\n    return true\n  catch _ =>\n    return false", "start": [41, 1], "end": [59, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.DerivingHandler", "code": "def DerivingHandler := (typeNames : Array Name) \u2192 (args? : Option (TSyntax ``Parser.Term.structInst)) \u2192 CommandElabM Bool", "start": [63, 1], "end": [63, 122], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.DerivingHandlerNoArgs", "code": "def DerivingHandlerNoArgs := (typeNames : Array Name) \u2192 CommandElabM Bool", "start": [64, 1], "end": [64, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.registerDerivingHandlerWithArgs", "code": "def registerDerivingHandlerWithArgs (className : Name) (handler : DerivingHandler) : IO Unit := do\n  unless (\u2190 initializing) do\n    throw (IO.userError \"failed to register deriving handler, it can only be registered during initialization\")\n  derivingHandlersRef.modify fun m => match m.find? className with\n    | some handlers => m.insert className (handler :: handlers)\n    | none => m.insert className [handler]", "start": [68, 1], "end": [78, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.registerDerivingHandler", "code": "def registerDerivingHandler (className : Name) (handler : DerivingHandlerNoArgs) : IO Unit := do\n  registerDerivingHandlerWithArgs className fun typeNames _ => handler typeNames", "start": [80, 1], "end": [82, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.defaultHandler", "code": "def defaultHandler (className : Name) (typeNames : Array Name) : CommandElabM Unit := do\n  throwError \"default handlers have not been implemented yet, class: '{className}' types: {typeNames}\"", "start": [84, 1], "end": [85, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.applyDerivingHandlers", "code": "def applyDerivingHandlers (className : Name) (typeNames : Array Name) (args? : Option (TSyntax ``Parser.Term.structInst)) : CommandElabM Unit := do\n  match (\u2190 derivingHandlersRef.get).find? className with\n  | some handlers =>\n    for handler in handlers do\n      if (\u2190 handler typeNames args?) then\n        return ()\n    defaultHandler className typeNames\n  | none => defaultHandler className typeNames", "start": [87, 1], "end": [94, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.tryApplyDefHandler", "code": "private def tryApplyDefHandler (className : Name) (declName : Name) : CommandElabM Bool :=\n  liftTermElabM do\n    Term.processDefDeriving className declName", "start": [96, 1], "end": [98, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.elabDeriving", "code": "@[builtin_command_elab \u00abderiving\u00bb] def elabDeriving : CommandElab\n  | `(deriving instance $[$classes $[with $argss?]?],* for $[$declNames],*) => do\n     let declNames \u2190 declNames.mapM resolveGlobalConstNoOverloadWithInfo\n     for cls in classes, args? in argss? do\n       try\n         let className \u2190 resolveGlobalConstNoOverloadWithInfo cls\n         withRef cls do\n           if declNames.size == 1 && args?.isNone then\n             if (\u2190 tryApplyDefHandler className declNames[0]!) then\n               return ()\n           applyDerivingHandlers className declNames args?\n       catch ex =>\n         logException ex\n  | _ => throwUnsupportedSyntax", "start": [100, 1], "end": [113, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.DerivingClassView", "code": "structure DerivingClassView where\n  ref : Syntax\n  className : Name\n  args? : Option (TSyntax ``Parser.Term.structInst)", "start": [115, 1], "end": [118, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.getOptDerivingClasses", "code": "def getOptDerivingClasses [Monad m] [MonadEnv m] [MonadResolveName m] [MonadError m] [MonadInfoTree m] (optDeriving : Syntax) : m (Array DerivingClassView) := do\n  match optDeriving with\n  | `(Parser.Command.optDeriving| deriving $[$classes $[with $argss?]?],*) =>\n    let mut ret := #[]\n    for cls in classes, args? in argss? do\n      let className \u2190 resolveGlobalConstNoOverloadWithInfo cls\n      ret := ret.push { ref := cls, className := className, args? }\n    return ret\n  | _ => return #[]", "start": [120, 1], "end": [128, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.DerivingClassView.applyHandlers", "code": "def DerivingClassView.applyHandlers (view : DerivingClassView) (declNames : Array Name) : CommandElabM Unit :=\n  withRef view.ref do applyDerivingHandlers view.className declNames view.args?", "start": [130, 1], "end": [131, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Main.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/PackDomain.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/TerminationHint.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Fix.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Eqns.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/PackMutual.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Ite.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Rel.lean"], "premises": [{"full_name": "Lean.Elab.addNonRecPreDefs", "code": "private partial def addNonRecPreDefs (preDefs : Array PreDefinition) (preDefNonRec : PreDefinition) (fixedPrefixSize : Nat) : TermElabM Unit := do\n  let us := preDefNonRec.levelParams.map mkLevelParam\n  let all := preDefs.toList.map (\u00b7.declName)\n  for fidx in [:preDefs.size] do\n    let preDef := preDefs[fidx]!\n    let value \u2190 lambdaTelescope preDef.value fun xs _ => do\n      let packedArgs : Array Expr := xs[fixedPrefixSize:]\n      let mkProd (type : Expr) : MetaM Expr := do\n        mkUnaryArg type packedArgs\n      let rec mkSum (i : Nat) (type : Expr) : MetaM Expr := do\n        if i == preDefs.size - 1 then\n          mkProd type\n        else\n          (\u2190 whnfD type).withApp fun f args => do\n            assert! args.size == 2\n            if i == fidx then\n              return mkApp3 (mkConst ``PSum.inl f.constLevels!) args[0]! args[1]! (\u2190 mkProd args[0]!)\n            else\n              let r \u2190 mkSum (i+1) args[1]!\n              return mkApp3 (mkConst ``PSum.inr f.constLevels!) args[0]! args[1]! r\n      let Expr.forallE _ domain _ _ := (\u2190 instantiateForall preDefNonRec.type xs[:fixedPrefixSize]) | unreachable!\n      let arg \u2190 mkSum 0 domain\n      mkLambdaFVars xs (mkApp (mkAppN (mkConst preDefNonRec.declName us) xs[:fixedPrefixSize]) arg)\n    trace[Elab.definition.wf] \"{preDef.declName} := {value}\"\n    addNonRec { preDef with value } (applyAttrAfterCompilation := false) (all := all)", "start": [19, 1], "end": [43, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.withCommonTelescope", "code": "partial def withCommonTelescope (preDefs : Array PreDefinition) (k : Array Expr \u2192 Array Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  go #[] (preDefs.map (\u00b7.value))\nwhere\n  go (fvars : Array Expr) (vals : Array Expr) : TermElabM \u03b1 := do\n    if !(vals.all fun val => val.isLambda) then\n      k fvars vals\n    else if !(\u2190 vals.allM fun val => return val.bindingName! == vals[0]!.bindingName! && val.binderInfo == vals[0]!.binderInfo && (\u2190 isDefEq val.bindingDomain! vals[0]!.bindingDomain!)) then\n      k fvars vals\n    else\n      withLocalDecl vals[0]!.bindingName! vals[0]!.binderInfo vals[0]!.bindingDomain! fun x =>\n        go (fvars.push x) (vals.map fun val => val.bindingBody!.instantiate1 x)", "start": [45, 1], "end": [55, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.getFixedPrefix", "code": "def getFixedPrefix (preDefs : Array PreDefinition) : TermElabM Nat :=\n  withCommonTelescope preDefs fun xs vals => do\n    let resultRef \u2190 IO.mkRef xs.size\n    for val in vals do\n      if (\u2190 resultRef.get) == 0 then return 0\n      forEachExpr' val fun e => do\n        if preDefs.any fun preDef => e.isAppOf preDef.declName then\n          let args := e.getAppArgs\n          resultRef.modify (min args.size \u00b7)\n          for arg in args, x in xs do\n            if !(\u2190 withoutProofIrrelevance <| withReducible <| isDefEq arg x) then\n              return true\n          return false\n        else\n          return true\n    resultRef.get", "start": [57, 1], "end": [73, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.isOnlyOneUnaryDef", "code": "private def isOnlyOneUnaryDef (preDefs : Array PreDefinition) (fixedPrefixSize : Nat) : MetaM Bool := do\n  if preDefs.size == 1 then\n    lambdaTelescope preDefs[0]!.value fun xs _ => return xs.size == fixedPrefixSize + 1\n  else\n    return false", "start": [75, 1], "end": [79, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.wfRecursion", "code": "def wfRecursion (preDefs : Array PreDefinition) (wf? : Option TerminationWF) (decrTactic? : Option Syntax) : TermElabM Unit := do\n  let (unaryPreDef, fixedPrefixSize) \u2190 withoutModifyingEnv do\n    for preDef in preDefs do\n      addAsAxiom preDef\n    let fixedPrefixSize \u2190 getFixedPrefix preDefs\n    trace[Elab.definition.wf] \"fixed prefix: {fixedPrefixSize}\"\n    let preDefsDIte \u2190 preDefs.mapM fun preDef => return { preDef with value := (\u2190 iteToDIte preDef.value) }\n    let unaryPreDefs \u2190 packDomain fixedPrefixSize preDefsDIte\n    return (\u2190 packMutual fixedPrefixSize preDefs unaryPreDefs, fixedPrefixSize)\n  let preDefNonRec \u2190 forallBoundedTelescope unaryPreDef.type fixedPrefixSize fun prefixArgs type => do\n    let type \u2190 whnfForall type\n    let packedArgType := type.bindingDomain!\n    elabWFRel preDefs unaryPreDef.declName fixedPrefixSize packedArgType wf? fun wfRel => do\n      trace[Elab.definition.wf] \"wfRel: {wfRel}\"\n      let (value, envNew) \u2190 withoutModifyingEnv' do\n        addAsAxiom unaryPreDef\n        let value \u2190 mkFix unaryPreDef prefixArgs wfRel decrTactic?\n        eraseRecAppSyntaxExpr value\n      \n      let value \u2190 unfoldDeclsFrom envNew value\n      return { unaryPreDef with value }\n  trace[Elab.definition.wf] \">> {preDefNonRec.declName} :=\\n{preDefNonRec.value}\"\n  let preDefs \u2190 preDefs.mapM fun d => eraseRecAppSyntax d\n  if (\u2190 isOnlyOneUnaryDef preDefs fixedPrefixSize) then\n    addNonRec preDefNonRec (applyAttrAfterCompilation := false)\n  else\n    withEnableInfoTree false do\n      addNonRec preDefNonRec (applyAttrAfterCompilation := false)\n    addNonRecPreDefs preDefs preDefNonRec fixedPrefixSize\n  registerEqnsInfo preDefs preDefNonRec.declName fixedPrefixSize\n  for preDef in preDefs do\n    applyAttributesOf #[preDef] AttributeApplicationTime.afterCompilation\n  addAndCompilePartialRec preDefs", "start": [81, 1], "end": [113, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/SCC.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.SCC.Data", "code": "structure Data where\n  index?   : Option Nat := none\n  lowlink? : Option Nat := none\n  onStack  : Bool       := false", "start": [18, 1], "end": [21, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.State", "code": "structure State where\n  stack     : List \u03b1 := []\n  nextIndex : Nat := 0\n  data      : HashMap \u03b1 Data := {}\n  sccs      : List (List \u03b1) := []", "start": [23, 1], "end": [27, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.M", "code": "abbrev M := StateM (State \u03b1)", "start": [29, 1], "end": [29, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.getDataOf", "code": "private def getDataOf (a : \u03b1) : M \u03b1 Data := do\n  let s \u2190 get\n  match s.data.find? a with\n  | some d => pure d\n  | none   => pure {}", "start": [34, 1], "end": [38, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.push", "code": "private def push (a : \u03b1) : M \u03b1 Unit :=\n  modify fun s => { s with\n    stack     := a :: s.stack,\n    nextIndex := s.nextIndex + 1,\n    data      := s.data.insert a {\n      index?   := s.nextIndex,\n      lowlink? := s.nextIndex,\n      onStack  := true\n    }\n  }", "start": [40, 1], "end": [49, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.modifyDataOf", "code": "private def modifyDataOf (a : \u03b1) (f : Data \u2192 Data) : M \u03b1 Unit :=\n  modify fun s => { s with\n    data := match s.data.find? a with\n      | none   => s.data\n      | some d => s.data.insert a (f d)\n  }", "start": [51, 1], "end": [56, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.resetOnStack", "code": "private def resetOnStack (a : \u03b1) : M \u03b1 Unit :=\n  modifyDataOf a fun d => { d with onStack := false }", "start": [58, 1], "end": [59, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.updateLowLinkOf", "code": "private def updateLowLinkOf (a : \u03b1) (v : Option Nat) : M \u03b1 Unit :=\n  modifyDataOf a fun d => { d with\n    lowlink? := match d.lowlink?, v with\n      | i, none => i\n      | none, i => i\n      | some i, some j => if i < j then i else j\n  }", "start": [61, 1], "end": [67, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.addSCC", "code": "private def addSCC (a : \u03b1) : M \u03b1 Unit := do\n  let rec add\n    | [],    newSCC => modify fun s => { s with stack := [], sccs := newSCC :: s.sccs }\n    | b::bs, newSCC => do\n      resetOnStack b;\n      let newSCC := b::newSCC;\n      if a != b then\n        add bs newSCC\n      else\n        modify fun s => { s with stack := bs, sccs := newSCC :: s.sccs }\n  add (\u2190 get).stack []", "start": [69, 1], "end": [79, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.sccAux", "code": "private partial def sccAux (successorsOf : \u03b1 \u2192 List \u03b1) (a : \u03b1) : M \u03b1 Unit := do\n  push a\n  (successorsOf a).forM fun b => do\n    let bData \u2190 getDataOf b;\n    if bData.index?.isNone then\n      sccAux successorsOf b;\n      let bData \u2190 getDataOf b;\n      updateLowLinkOf a bData.lowlink?\n    else if bData.onStack then do\n      updateLowLinkOf a bData.index?\n    else\n      pure ()\n  let aData \u2190 getDataOf a;\n  if aData.lowlink? == aData.index? then\n    addSCC a", "start": [81, 1], "end": [98, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.SCC.scc", "code": "def scc (vertices : List \u03b1) (successorsOf : \u03b1 \u2192 List \u03b1) : List (List \u03b1) :=\n  let main : M \u03b1 Unit := vertices.forM fun a => do\n    let aData \u2190 getDataOf a\n    if aData.index?.isNone then sccAux successorsOf a\n  let (_, s) := main.run {}\n  s.sccs.reverse", "start": [100, 1], "end": [105, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/MkInhabitant.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.mkInhabitant?", "code": "private def mkInhabitant? (type : Expr) (useOfNonempty : Bool) : MetaM (Option Expr) := do\n  try\n    if useOfNonempty then\n      return some (\u2190 mkOfNonempty type)\n    else\n      return some (\u2190 mkDefault type)\n  catch _ =>\n    return none", "start": [10, 1], "end": [17, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.findAssumption?", "code": "private def findAssumption? (xs : Array Expr) (type : Expr) : MetaM (Option Expr) := do\n  xs.findM? fun x => do isDefEq (\u2190 inferType x) type", "start": [19, 1], "end": [20, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkFnInhabitant?", "code": "private def mkFnInhabitant? (xs : Array Expr) (type : Expr) (useOfNonempty : Bool) : MetaM (Option Expr) :=\n  let rec loop\n    | 0,   type => mkInhabitant? type useOfNonempty\n    | i+1, type => do\n      let x := xs[i]!\n      let type \u2190 mkForallFVars #[x] type;\n      match (\u2190 mkInhabitant? type useOfNonempty) with\n      | none     => loop i type\n      | some val => return some (\u2190 mkLambdaFVars xs[0:i] val)\n  loop xs.size type", "start": [22, 1], "end": [31, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkInhabitantFor", "code": "def mkInhabitantFor (declName : Name) (xs : Array Expr) (type : Expr) : MetaM Expr := do\n  let go? (useOfNonempty : Bool) : MetaM (Option Expr) := do\n    match (\u2190 mkInhabitant? type useOfNonempty) with\n    | some val => mkLambdaFVars xs val\n    | none     =>\n    match (\u2190 findAssumption? xs type) with\n    | some x => mkLambdaFVars xs x\n    | none   =>\n    match (\u2190 mkFnInhabitant? xs type useOfNonempty) with\n    | some val => return val\n    | none     => return none\n  match (\u2190 go? false) with\n  | some val => return val\n  | none     => match (\u2190 go? true) with\n    | some val => return val\n    | none     => throwError \"failed to compile partial definition '{declName}', failed to show that type is inhabited and non empty\"", "start": [34, 1], "end": [49, 134], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Unfold.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Unfold.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.unfoldLocalDecl", "code": "def unfoldLocalDecl (declName : Name) (fvarId : FVarId) : TacticM Unit := do\n  replaceMainGoal [\u2190 Meta.unfoldLocalDecl (\u2190 getMainGoal) fvarId declName]", "start": [13, 1], "end": [14, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.unfoldTarget", "code": "def unfoldTarget (declName : Name) : TacticM Unit := do\n  replaceMainGoal [\u2190 Meta.unfoldTarget (\u2190 getMainGoal) declName]", "start": [16, 1], "end": [17, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalUnfold", "code": "@[builtin_tactic Lean.Parser.Tactic.unfold] def evalUnfold : Tactic := fun stx => do\n  let loc := expandOptLocation stx[2]\n  for declNameId in stx[1].getArgs do\n    go declNameId loc\nwhere\n  go (declNameId : Syntax) (loc : Location) : TacticM Unit := do\n    let declName \u2190 resolveGlobalConstNoOverloadWithInfo declNameId\n    withLocation loc (unfoldLocalDecl declName) (unfoldTarget declName) (throwTacticEx `unfold \u00b7 m!\"did not unfold '{declName}'\")", "start": [19, 1], "end": [27, 130], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Simp.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Split.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Simp.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Conv.applySimpResult", "code": "def applySimpResult (result : Simp.Result) : TacticM Unit := do\n  if result.proof?.isNone then\n    changeLhs result.expr\n  else\n    updateLhs result.expr (\u2190 result.getProof)", "start": [13, 1], "end": [17, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalSimp", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.simp] def evalSimp : Tactic := fun stx => withMainContext do\n  let { ctx, dischargeWrapper, .. } \u2190 mkSimpContext stx (eraseLocal := false)\n  let lhs \u2190 getLhs\n  let (result, _) \u2190 dischargeWrapper.with fun d? => simp lhs ctx (discharge? := d?)\n  applySimpResult result", "start": [19, 1], "end": [23, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalSimpMatch", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.simpMatch] def evalSimpMatch : Tactic := fun _ => withMainContext do\n  applySimpResult (\u2190 Split.simpMatch (\u2190 getLhs))", "start": [25, 1], "end": [26, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalDSimp", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.dsimp] def evalDSimp : Tactic := fun stx => withMainContext do\n  let { ctx, .. } \u2190 mkSimpContext stx (eraseLocal := false) (kind := .dsimp)\n  changeLhs (\u2190 Lean.Meta.dsimp (\u2190 getLhs) ctx).1", "start": [28, 1], "end": [30, 49], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Delta.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Delta.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.deltaLocalDecl", "code": "def deltaLocalDecl (declNames : Array Name) (fvarId : FVarId) : TacticM Unit := do\n  let mvarId \u2190 getMainGoal\n  let localDecl \u2190 fvarId.getDecl\n  let typeNew \u2190 deltaExpand localDecl.type declNames.contains\n  if typeNew == localDecl.type then\n    throwTacticEx `delta mvarId m!\"did not delta reduce {declNames} at {localDecl.userName}\"\n  replaceMainGoal [\u2190 mvarId.replaceLocalDeclDefEq fvarId typeNew]", "start": [13, 1], "end": [19, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.deltaTarget", "code": "def deltaTarget (declNames : Array Name) : TacticM Unit := do\n  let mvarId \u2190 getMainGoal\n  let target \u2190 getMainTarget\n  let targetNew \u2190 deltaExpand target declNames.contains\n  if targetNew == target then\n    throwTacticEx `delta mvarId m!\"did not delta reduce {declNames}\"\n  replaceMainGoal [\u2190 mvarId.replaceTargetDefEq targetNew]", "start": [21, 1], "end": [27, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalDelta", "code": "@[builtin_tactic Lean.Parser.Tactic.delta] def evalDelta : Tactic := fun stx => do\n  let declNames \u2190 stx[1].getArgs.mapM resolveGlobalConstNoOverloadWithInfo\n  let loc := expandOptLocation stx[2]\n  withLocation loc (deltaLocalDecl declNames) (deltaTarget declNames)\n    (throwTacticEx `delta \u00b7 m!\"did not delta reduce {declNames}\")", "start": [29, 1], "end": [34, 66], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/HashMap.lean", "imports": ["lake-packages/std/Std/Data/HashMap/WF.lean", "lake-packages/std/Std/Data/HashMap/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Tactic/CoeExt.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Builtins.lean", "lake-packages/std/Std/Lean/Delaborator.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.Coe.CoeFnType", "code": "inductive CoeFnType\n  \n  | coe\n  \n  | coeFun\n  \n  | coeSort\n  deriving Inhabited, Repr, DecidableEq", "start": [12, 1], "end": [20, 40], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Coe.CoeFnInfo", "code": "structure CoeFnInfo where\n  \n  numArgs : Nat\n  \n  coercee : Nat\n  \n  type : CoeFnType\n  deriving Inhabited, Repr", "start": [29, 1], "end": [37, 27], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Coe.getCoeFnInfo?", "code": "def getCoeFnInfo? (fn : Name) : CoreM (Option CoeFnInfo) :=\n  return (coeExt.getState (\u2190 getEnv)).find? fn", "start": [50, 1], "end": [52, 47], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Coe.coeDelaborator", "code": "def coeDelaborator (info : CoeFnInfo) : Delab := whenPPOption getPPCoercions do\n  withOverApp info.numArgs do\n    `(\u2191$(\u2190 withNaryArg info.coercee delab))", "start": [56, 1], "end": [63, 44], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Coe.addCoeDelaborator", "code": "def addCoeDelaborator (name : Name) (info : CoeFnInfo) : MetaM Unit := do\n  let delabName := name ++ `delaborator\n  addAndCompile <| Declaration.defnDecl {\n    name := delabName\n    levelParams := []\n    type := mkConst ``Delab\n    value := mkApp (mkConst ``coeDelaborator) (toExpr info)\n    hints := .opaque\n    safety := .safe\n  }\n  let kind := `app ++ name\n  Attribute.add delabName `delab (Unhygienic.run `(attr| delab $(mkIdent kind):ident))", "start": [65, 1], "end": [77, 87], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Coe.registerCoercion", "code": "def registerCoercion (name : Name) (info : Option CoeFnInfo := none) : MetaM Unit := do\n  let info \u2190 match info with | some info => pure info | none => do\n    let fnInfo \u2190 getFunInfo (\u2190 mkConstWithLevelParams name)\n    let some coercee := fnInfo.paramInfo.findIdx? (\u00b7.binderInfo.isExplicit)\n      | throwError \"{name} has no explicit arguments\"\n    pure { numArgs := coercee + 1, coercee, type := .coe }\n  modifyEnv (coeExt.addEntry \u00b7 (name, info))\n  addCoeDelaborator name info", "start": [79, 1], "end": [87, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Testing.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Code.containsConst", "code": "partial def Code.containsConst (constName : Name) (code : Code) : Bool :=\n  match code with\n  | .let decl k => goLetValue decl.value || containsConst constName k\n  | .fun decl k => containsConst constName decl.value || containsConst constName k\n  | .jp decl k => containsConst constName decl.value || containsConst constName k\n  | .cases cs => cs.alts.any fun alt => containsConst constName alt.getCode\n  | .return .. | .unreach .. | .jmp .. => false\nwhere\n  goExpr (e : Expr) : Bool :=\n    match e with\n    | .const name .. => name == constName\n    | .app fn arg .. => goExpr fn || goExpr arg\n    | .lam _ _ body .. => goExpr body\n    | .proj _ _ struct .. => goExpr struct\n    | .letE .. => unreachable! | _ => false\n  goLetValue (l : LetValue) : Bool :=\n    match l with\n    | .value .. | .erased | .proj .. | .fvar .. => false\n    | .const name .. => name == constName", "start": [11, 1], "end": [30, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.TestInstallerContext", "code": "structure TestInstallerContext where\n  passUnderTestName : Name\n  testName : Name", "start": [34, 1], "end": [36, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.TestContext", "code": "structure TestContext where\n  passUnderTest : Pass\n  testName : Name", "start": [38, 1], "end": [40, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.SimpleAssertionContext", "code": "structure SimpleAssertionContext where\n  decls : Array Decl", "start": [42, 1], "end": [43, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.InOutAssertionContext", "code": "structure InOutAssertionContext where\n  input : Array Decl\n  output : Array Decl", "start": [45, 1], "end": [47, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.TestInstallerM", "code": "abbrev TestInstallerM := ReaderM TestInstallerContext", "start": [49, 1], "end": [49, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.TestInstaller", "code": "abbrev TestInstaller := TestInstallerM PassInstaller", "start": [50, 1], "end": [50, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.TestM", "code": "abbrev TestM := ReaderT TestContext CompilerM", "start": [52, 1], "end": [52, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.SimpleAssertionM", "code": "abbrev SimpleAssertionM := ReaderT SimpleAssertionContext TestM", "start": [53, 1], "end": [53, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.InOutAssertionM", "code": "abbrev InOutAssertionM := ReaderT InOutAssertionContext TestM", "start": [54, 1], "end": [54, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.SimpleTest", "code": "abbrev SimpleTest := SimpleAssertionM Unit", "start": [55, 1], "end": [55, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.InOutTest", "code": "abbrev InOutTest := InOutAssertionM Unit", "start": [56, 1], "end": [56, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.TestInstaller.install", "code": "def TestInstaller.install (x : TestInstaller) (passUnderTestName testName : Name) : PassInstaller :=\n  x { passUnderTestName, testName }", "start": [58, 1], "end": [59, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.TestM.run", "code": "def TestM.run (x : TestM \u03b1) (passUnderTest : Pass) (testName : Name) : CompilerM \u03b1 :=\n  x { passUnderTest, testName }", "start": [61, 1], "end": [62, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.SimpleAssertionM.run", "code": "def SimpleAssertionM.run (x : SimpleAssertionM \u03b1) (decls : Array Decl) (passUnderTest : Pass) (testName : Name) : CompilerM \u03b1 :=\n  x { decls } { passUnderTest, testName }", "start": [64, 1], "end": [65, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.InOutAssertionM.run", "code": "def InOutAssertionM.run (x : InOutAssertionM \u03b1) (input output : Array Decl) (passUnderTest : Pass) (testName : Name) : CompilerM \u03b1 :=\n  x { input, output } { passUnderTest, testName }", "start": [67, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.getTestName", "code": "def getTestName : TestM Name := do\n  return (\u2190read).testName", "start": [70, 1], "end": [71, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.getPassUnderTest", "code": "def getPassUnderTest : TestM Pass := do\n  return (\u2190read).passUnderTest", "start": [73, 1], "end": [74, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.getDecls", "code": "def getDecls : SimpleAssertionM (Array Decl) := do\n  return (\u2190read).decls", "start": [76, 1], "end": [77, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.getInputDecls", "code": "def getInputDecls : InOutAssertionM (Array Decl) := do\n  return (\u2190read).input", "start": [79, 1], "end": [80, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.getOutputDecls", "code": "def getOutputDecls : InOutAssertionM (Array Decl) := do\n  return (\u2190read).output", "start": [82, 1], "end": [83, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assert", "code": "def assert (property : Bool) (msg : String) : TestM Unit := do\n  unless property do\n    throwError msg", "start": [85, 1], "end": [90, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertAfterTest", "code": "private def assertAfterTest (test : SimpleTest) : TestInstallerM (Pass \u2192 Pass) := do\n  let testName := (\u2190read).testName\n  return fun passUnderTest => {\n    phase := passUnderTest.phase\n    name := testName\n    run := fun decls => do\n      trace[Compiler.test] \"Starting post condition test {testName} for {passUnderTest.name} occurrence {passUnderTest.occurrence}\"\n      test.run decls passUnderTest testName\n      trace[Compiler.test] \"Post condition test {testName} for {passUnderTest.name} occurrence {passUnderTest.occurrence} successful\"\n      return decls\n  }", "start": [92, 1], "end": [102, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertAfter", "code": "def assertAfter (test : SimpleTest) (occurrence : Nat := 0): TestInstaller := do\n  let passUnderTestName := (\u2190read).passUnderTestName\n  let assertion \u2190 assertAfterTest test\n  return .installAfter passUnderTestName assertion occurrence", "start": [104, 1], "end": [111, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertAfterEachOccurrence", "code": "def assertAfterEachOccurrence (test : SimpleTest) : TestInstaller := do\n  let passUnderTestName := (\u2190read).passUnderTestName\n  let assertion \u2190 assertAfterTest test\n  return .installAfterEach passUnderTestName assertion", "start": [113, 1], "end": [119, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertForEachDeclAfter", "code": "def assertForEachDeclAfter (assertion : Pass \u2192 Decl \u2192 Bool) (msg : String) (occurrence : Nat := 0) : TestInstaller :=\n  let assertion := do\n    let pass \u2190 getPassUnderTest\n    (\u2190getDecls).forM (fun decl => assert (assertion pass decl) msg)\n  assertAfter assertion occurrence", "start": [121, 1], "end": [129, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertForEachDeclAfterEachOccurrence", "code": "def assertForEachDeclAfterEachOccurrence (assertion : Pass \u2192 Decl \u2192 Bool) (msg : String) : TestInstaller :=\n  assertAfterEachOccurrence <| do\n    let pass \u2190 getPassUnderTest\n    (\u2190getDecls).forM (fun decl => assert (assertion pass decl) msg)", "start": [131, 1], "end": [138, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertAroundTest", "code": "private def assertAroundTest (test : InOutTest) : TestInstallerM (Pass \u2192 Pass) := do\n  let testName := (\u2190read).testName\n  return fun passUnderTest => {\n    phase := passUnderTest.phase\n    name := passUnderTest.name\n    run := fun decls => do\n      trace[Compiler.test] \"Starting wrapper test {testName} for {passUnderTest.name} occurrence {passUnderTest.occurrence}\"\n      let newDecls \u2190 passUnderTest.run decls\n      test.run decls newDecls passUnderTest testName\n      trace[Compiler.test] \"Wrapper test {testName} for {passUnderTest.name} occurrence {passUnderTest.occurrence} successful\"\n      return newDecls\n  }", "start": [140, 1], "end": [151, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertAround", "code": "def assertAround (test : InOutTest) (occurrence : Nat := 0) : TestInstaller := do\n  let passUnderTestName := (\u2190read).passUnderTestName\n  let assertion \u2190 assertAroundTest test\n  return .replacePass passUnderTestName assertion occurrence", "start": [153, 1], "end": [161, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertAroundEachOccurrence", "code": "def assertAroundEachOccurrence (test : InOutTest) : TestInstaller := do\n  let passUnderTestName := (\u2190read).passUnderTestName\n  let assertion \u2190 assertAroundTest test\n  return .replaceEachOccurrence passUnderTestName assertion", "start": [163, 1], "end": [171, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.throwFixPointError", "code": "private def throwFixPointError (err : String) (firstResult secondResult : Array Decl) : CompilerM Unit := do\n  let mut err := err\n  err := err ++ \"Result after usual run:\"\n  let folder := fun err decl => do return err ++ s!\"\\n{\u2190ppDecl decl}\"\n  err \u2190 firstResult.foldlM (init := err) folder\n  err := err ++ \"Result after further run:\"\n  err \u2190 secondResult.foldlM (init := err) folder\n  throwError err", "start": [173, 1], "end": [180, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertIsAtFixPoint", "code": "def assertIsAtFixPoint : TestInstaller :=\n  let test := do\n    let passUnderTest \u2190 getPassUnderTest\n    let decls \u2190 getDecls\n    let secondResult \u2190 passUnderTest.run decls\n    if decls.size < secondResult.size then\n      let err := s!\"Pass {passUnderTest.name} did not reach a fixpoint, it added declarations on further runs:\\n\"\n      throwFixPointError err decls secondResult\n    else if decls.size > secondResult.size then\n      let err := s!\"Pass {passUnderTest.name} did not reach a fixpoint, it removed declarations on further runs:\\n\"\n      throwFixPointError err decls secondResult\n    else if decls != secondResult then\n      let err := s!\"Pass {passUnderTest.name} did not reach a fixpoint, it either changed declarations or their order:\\n\"\n      throwFixPointError err decls secondResult\n  assertAfterEachOccurrence test", "start": [182, 1], "end": [201, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertSize", "code": "def assertSize (assertion : Nat \u2192 Nat \u2192 Bool) (msg : String) : TestInstaller :=\n  let sumDeclSizes := fun decls => decls.map Decl.size |>.foldl (init := 0) (\u00b7 + \u00b7)\n  let assertion := (fun inputS outputS => Testing.assert (assertion inputS outputS) s!\"{msg}: input size {inputS} output size {outputS}\")\n  assertAroundEachOccurrence (do assertion (sumDeclSizes (\u2190getInputDecls)) (sumDeclSizes (\u2190getOutputDecls)))", "start": [203, 1], "end": [210, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertPreservesSize", "code": "def assertPreservesSize (msg : String) : TestInstaller :=\n  assertSize (\u00b7 == \u00b7) msg", "start": [212, 1], "end": [217, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertReducesSize", "code": "def assertReducesSize (msg : String) : TestInstaller :=\n  assertSize (\u00b7 > \u00b7) msg", "start": [219, 1], "end": [223, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertReducesOrPreservesSize", "code": "def assertReducesOrPreservesSize (msg : String) : TestInstaller :=\n  assertSize (\u00b7 \u2265 \u00b7) msg", "start": [225, 1], "end": [230, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertDoesNotContainConstAfter", "code": "def assertDoesNotContainConstAfter (constName : Name) (msg : String) : TestInstaller :=\n  assertForEachDeclAfterEachOccurrence (fun _ decl => !decl.value.containsConst constName) msg", "start": [232, 1], "end": [237, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Testing.assertNoFun", "code": "def assertNoFun : TestInstaller :=\n  assertAfter do\n    for decl in (\u2190 getDecls) do\n      decl.value.forM fun\n        | .fun .. => throwError \"declaration `{decl.name}` contains a local function declaration\"\n        | _ => return ()", "start": [239, 1], "end": [244, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ForEachExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ForEachExpr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Main.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/Options.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PullLetDecls.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Passes.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CSE.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToDecl.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Check.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.shouldGenerateCode", "code": "def shouldGenerateCode (declName : Name) : CoreM Bool := do\n  if (\u2190 isCompIrrelevant |>.run') then return false\n  let some info \u2190 getDeclInfo? declName | return false\n  unless info.hasValue do return false\n  let env \u2190 getEnv\n  if isExtern env declName then return false\n  if hasMacroInlineAttribute env declName then return false\n  if (\u2190 Meta.isMatcher declName) then return false\n  if isCasesOnRecursor env declName then return false\n  return true\nwhere\n  isCompIrrelevant : MetaM Bool := do\n    let info \u2190 getConstInfo declName\n    Meta.isProp info.type <||> Meta.isTypeFormerType info.type", "start": [17, 1], "end": [41, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.checkpoint", "code": "def checkpoint (stepName : Name) (decls : Array Decl) : CompilerM Unit := do\n  for decl in decls do\n    trace[Compiler.stat] \"{decl.name} : {decl.size}\"\n    withOptions (fun opts => opts.setBool `pp.motives.pi false) do\n      let clsName := `Compiler ++ stepName\n      if (\u2190 Lean.isTracingEnabledFor clsName) then\n        Lean.addTrace clsName m!\"size: {decl.size}\\n{\u2190 ppDecl' decl}\"\n      if compiler.check.get (\u2190 getOptions) then\n        decl.check\n  if compiler.check.get (\u2190 getOptions) then\n    checkDeadLocalDecls decls", "start": [43, 1], "end": [58, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.PassManager.run", "code": "def run (declNames : Array Name) : CompilerM (Array Decl) := withAtLeastMaxRecDepth 8192 do\n  \n  let declNames \u2190 declNames.filterM (shouldGenerateCode \u00b7)\n  if declNames.isEmpty then return #[]\n  let mut decls \u2190 declNames.mapM toDecl\n  decls := markRecDecls decls\n  let manager \u2190 getPassManager\n  for pass in manager.passes do\n    decls \u2190 withTraceNode `Compiler (fun _ => return m!\"new compiler phase: {pass.phase}, pass: {pass.name}\") do\n      withPhase pass.phase <| pass.run decls\n    withPhase pass.phaseOut <| checkpoint pass.name decls\n  if (\u2190 Lean.isTracingEnabledFor `Compiler.result) then\n    for decl in decls do\n      let some decl' \u2190 getDeclAt? decl.name .mono | unreachable!\n      Lean.addTrace `Compiler.result m!\"size: {decl.size}\\n{\u2190 ppDecl' decl'}\"\n  return decls", "start": [62, 1], "end": [83, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.compile", "code": "def compile (declNames : Array Name) : CoreM (Array Decl) :=\n  CompilerM.run <| PassManager.run declNames", "start": [87, 1], "end": [88, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.showDecl", "code": "def showDecl (phase : Phase) (declName : Name) : CoreM Format := do\n  let some decl \u2190 getDeclAt? declName phase | return \"<not-available>\"\n  ppDecl' decl", "start": [90, 1], "end": [92, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.main", "code": "@[export lean_lcnf_compile_decls]\ndef main (declNames : List Name) : CoreM Unit := do\n  profileitM Exception \"compilation new\" (\u2190 getOptions) do\n    withTraceNode `Compiler (fun _ => return m!\"compiling new: {declNames}\") do\n      CompilerM.run <| discard <| PassManager.run declNames.toArray", "start": [94, 1], "end": [98, 68], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/NormIds.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.UniqueIds.M", "code": "abbrev M := StateT IndexSet Id", "start": [10, 1], "end": [10, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UniqueIds.checkId", "code": "def checkId (id : Index) : M Bool :=\n  modifyGet fun s =>\n    if s.contains id then (false, s)\n    else (true, s.insert id)", "start": [12, 1], "end": [15, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UniqueIds.checkParams", "code": "def checkParams (ps : Array Param) : M Bool :=\n  ps.allM fun p => checkId p.x.idx", "start": [17, 1], "end": [18, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UniqueIds.checkFnBody", "code": "partial def checkFnBody : FnBody \u2192 M Bool\n  | .vdecl x _ _ b    => checkId x.idx <&&> checkFnBody b\n  | .jdecl j ys _ b   => checkId j.idx <&&> checkParams ys <&&> checkFnBody b\n  | .case _ _ _ alts  => alts.allM fun alt => checkFnBody alt.body\n  | b                 => if b.isTerminal then pure true else checkFnBody b.body", "start": [20, 1], "end": [24, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UniqueIds.checkDecl", "code": "partial def checkDecl : Decl \u2192 M Bool\n  | .fdecl (xs := xs) (body := b) .. => checkParams xs <&&> checkFnBody b\n  | .extern (xs := xs) .. => checkParams xs", "start": [26, 1], "end": [28, 44], "kind": "commanddeclaration"}, {"full_name": "Decl.uniqueIds", "code": "def Decl.uniqueIds (d : Decl) : Bool :=\n  (UniqueIds.checkDecl d).run' {}", "start": [32, 1], "end": [34, 34], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.M", "code": "abbrev M := ReaderT IndexRenaming Id", "start": [38, 1], "end": [38, 37], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.normIndex", "code": "def normIndex (x : Index) : M Index := fun m =>\n  match m.find? x with\n  | some y => y\n  | none   => x", "start": [40, 1], "end": [43, 16], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.normVar", "code": "def normVar (x : VarId) : M VarId :=\n  VarId.mk <$> normIndex x.idx", "start": [45, 1], "end": [46, 31], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.normJP", "code": "def normJP (x : JoinPointId) : M JoinPointId :=\n  JoinPointId.mk <$> normIndex x.idx", "start": [48, 1], "end": [49, 37], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.normArg", "code": "def normArg : Arg \u2192 M Arg\n  | Arg.var x => Arg.var <$> normVar x\n  | other     => pure other", "start": [51, 1], "end": [53, 28], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.normArgs", "code": "def normArgs (as : Array Arg) : M (Array Arg) := fun m =>\n  as.map fun a => normArg a m", "start": [55, 1], "end": [56, 30], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.normExpr", "code": "def normExpr : Expr \u2192 M Expr\n  | Expr.ctor c ys,      m => Expr.ctor c (normArgs ys m)\n  | Expr.reset n x,      m => Expr.reset n (normVar x m)\n  | Expr.reuse x c u ys, m => Expr.reuse (normVar x m) c u (normArgs ys m)\n  | Expr.proj i x,       m => Expr.proj i (normVar x m)\n  | Expr.uproj i x,      m => Expr.uproj i (normVar x m)\n  | Expr.sproj n o x,    m => Expr.sproj n o (normVar x m)\n  | Expr.fap c ys,       m => Expr.fap c (normArgs ys m)\n  | Expr.pap c ys,       m => Expr.pap c (normArgs ys m)\n  | Expr.ap x ys,        m => Expr.ap (normVar x m) (normArgs ys m)\n  | Expr.box t x,        m => Expr.box t (normVar x m)\n  | Expr.unbox x,        m => Expr.unbox (normVar x m)\n  | Expr.isShared x,     m => Expr.isShared (normVar x m)\n  | e@(Expr.lit _),      _ =>  e", "start": [58, 1], "end": [71, 33], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.N", "code": "abbrev N := ReaderT IndexRenaming (StateM Nat)", "start": [73, 1], "end": [73, 47], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.withVar", "code": "@[inline] def withVar {\u03b1 : Type} (x : VarId) (k : VarId \u2192 N \u03b1) : N \u03b1 := fun m => do\n  let n \u2190 getModify (fun n => n + 1)\n  k { idx := n } (m.insert x.idx n)", "start": [75, 1], "end": [77, 36], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.withJP", "code": "@[inline] def withJP {\u03b1 : Type} (x : JoinPointId) (k : JoinPointId \u2192 N \u03b1) : N \u03b1 := fun m => do\n  let n \u2190 getModify (fun n => n + 1)\n  k { idx := n } (m.insert x.idx n)", "start": [79, 1], "end": [81, 36], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.withParams", "code": "@[inline] def withParams {\u03b1 : Type} (ps : Array Param) (k : Array Param \u2192 N \u03b1) : N \u03b1 := fun m => do\n  let m \u2190 ps.foldlM (init := m) fun m p => do\n    let n \u2190 getModify fun n => n + 1\n    return m.insert p.x.idx n\n  let ps := ps.map fun p => { p with x := normVar p.x m }\n  k ps m", "start": [83, 1], "end": [88, 9], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.normFnBody", "code": "partial def normFnBody : FnBody \u2192 N FnBody\n  | FnBody.vdecl x t v b    => do let v \u2190 normExpr v; withVar x fun x => return FnBody.vdecl x t v (\u2190 normFnBody b)\n  | FnBody.jdecl j ys v b   => do\n    let (ys, v) \u2190 withParams ys fun ys => do let v \u2190 normFnBody v; pure (ys, v)\n    withJP j fun j => return FnBody.jdecl j ys v (\u2190 normFnBody b)\n  | FnBody.set x i y b      => return FnBody.set (\u2190 normVar x) i (\u2190 normArg y) (\u2190 normFnBody b)\n  | FnBody.uset x i y b     => return FnBody.uset (\u2190 normVar x) i (\u2190 normVar y) (\u2190 normFnBody b)\n  | FnBody.sset x i o y t b => return FnBody.sset (\u2190 normVar x) i o (\u2190 normVar y) t (\u2190 normFnBody b)\n  | FnBody.setTag x i b     => return FnBody.setTag (\u2190 normVar x) i (\u2190 normFnBody b)\n  | FnBody.inc x n c p b    => return FnBody.inc (\u2190 normVar x) n c p (\u2190 normFnBody b)\n  | FnBody.dec x n c p b    => return FnBody.dec (\u2190 normVar x) n c p (\u2190 normFnBody b)\n  | FnBody.del x b          => return FnBody.del (\u2190 normVar x) (\u2190 normFnBody b)\n  | FnBody.mdata d b        => return FnBody.mdata d (\u2190 normFnBody b)\n  | FnBody.case tid x xType alts => do\n    let x \u2190 normVar x\n    let alts \u2190 alts.mapM fun alt => alt.mmodifyBody normFnBody\n    return FnBody.case tid x xType alts\n  | FnBody.jmp j ys        => return FnBody.jmp (\u2190 normJP j) (\u2190 normArgs ys)\n  | FnBody.ret x           => return FnBody.ret (\u2190 normArg x)\n  | FnBody.unreachable     => pure FnBody.unreachable", "start": [93, 1], "end": [112, 54], "kind": "commanddeclaration"}, {"full_name": "NormalizeIds.normDecl", "code": "def normDecl (d : Decl) : N Decl :=\n  match d with\n  | Decl.fdecl (xs := xs) (body := b) .. => withParams xs fun _ => return d.updateBody! (\u2190 normFnBody b)\n  | other => pure other", "start": [114, 1], "end": [117, 24], "kind": "commanddeclaration"}, {"full_name": "Decl.normalizeIds", "code": "def Decl.normalizeIds (d : Decl) : Decl :=\n  (NormalizeIds.normDecl d {}).run' 1", "start": [121, 1], "end": [123, 38], "kind": "commanddeclaration"}, {"full_name": "MapVars.mapArg", "code": "@[inline] def mapArg (f : VarId \u2192 VarId) : Arg \u2192 Arg\n  | Arg.var x => Arg.var (f x)\n  | a         => a", "start": [129, 1], "end": [131, 19], "kind": "commanddeclaration"}, {"full_name": "MapVars.mapArgs", "code": "def mapArgs (f : VarId \u2192 VarId) (as : Array Arg) : Array Arg :=\n  as.map (mapArg f)", "start": [133, 1], "end": [134, 20], "kind": "commanddeclaration"}, {"full_name": "MapVars.mapExpr", "code": "def mapExpr (f : VarId \u2192 VarId) : Expr \u2192 Expr\n  | Expr.ctor c ys      => Expr.ctor c (mapArgs f ys)\n  | Expr.reset n x      => Expr.reset n (f x)\n  | Expr.reuse x c u ys => Expr.reuse (f x) c u (mapArgs f ys)\n  | Expr.proj i x       => Expr.proj i (f x)\n  | Expr.uproj i x      => Expr.uproj i (f x)\n  | Expr.sproj n o x    => Expr.sproj n o (f x)\n  | Expr.fap c ys       => Expr.fap c (mapArgs f ys)\n  | Expr.pap c ys       => Expr.pap c (mapArgs f ys)\n  | Expr.ap x ys        => Expr.ap (f x) (mapArgs f ys)\n  | Expr.box t x        => Expr.box t (f x)\n  | Expr.unbox x        => Expr.unbox (f x)\n  | Expr.isShared x     => Expr.isShared (f x)\n  | e@(Expr.lit _)      =>  e", "start": [136, 1], "end": [149, 30], "kind": "commanddeclaration"}, {"full_name": "MapVars.mapFnBody", "code": "partial def mapFnBody (f : VarId \u2192 VarId) : FnBody \u2192 FnBody\n  | FnBody.vdecl x t v b         => FnBody.vdecl x t (mapExpr f v) (mapFnBody f b)\n  | FnBody.jdecl j ys v b        => FnBody.jdecl j ys (mapFnBody f v) (mapFnBody f b)\n  | FnBody.set x i y b           => FnBody.set (f x) i (mapArg f y) (mapFnBody f b)\n  | FnBody.setTag x i b          => FnBody.setTag (f x) i (mapFnBody f b)\n  | FnBody.uset x i y b          => FnBody.uset (f x) i (f y) (mapFnBody f b)\n  | FnBody.sset x i o y t b      => FnBody.sset (f x) i o (f y) t (mapFnBody f b)\n  | FnBody.inc x n c p b         => FnBody.inc (f x) n c p (mapFnBody f b)\n  | FnBody.dec x n c p b         => FnBody.dec (f x) n c p (mapFnBody f b)\n  | FnBody.del x b               => FnBody.del (f x) (mapFnBody f b)\n  | FnBody.mdata d b             => FnBody.mdata d (mapFnBody f b)\n  | FnBody.case tid x xType alts => FnBody.case tid (f x) xType (alts.map fun alt => alt.modifyBody (mapFnBody f))\n  | FnBody.jmp j ys              => FnBody.jmp j (mapArgs f ys)\n  | FnBody.ret x                 => FnBody.ret (mapArg f x)\n  | FnBody.unreachable           => FnBody.unreachable", "start": [151, 1], "end": [165, 55], "kind": "commanddeclaration"}, {"full_name": "FnBody.mapVars", "code": "@[inline] def FnBody.mapVars (f : VarId \u2192 VarId) (b : FnBody) : FnBody :=\n  MapVars.mapFnBody f b", "start": [169, 1], "end": [170, 24], "kind": "commanddeclaration"}, {"full_name": "FnBody.replaceVar", "code": "def FnBody.replaceVar (x y : VarId) (b : FnBody) : FnBody :=\n  b.mapVars fun z => if x == z then y else z", "start": [172, 1], "end": [174, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/EmitUtil.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/InitAttr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.isTailCallTo", "code": "def isTailCallTo (g : Name) (b : FnBody) : Bool :=\n  match b with\n  | FnBody.vdecl x _ (Expr.fap f _) (FnBody.ret (Arg.var y)) => x == y && f == g\n  | _  => false", "start": [12, 1], "end": [16, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.usesModuleFrom", "code": "def usesModuleFrom (env : Environment) (modulePrefix : Name) : Bool :=\n  env.allImportedModuleNames.toList.any fun modName => modulePrefix.isPrefixOf modName", "start": [18, 1], "end": [19, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectUsedDecls.M", "code": "abbrev M := ReaderT Environment (StateM NameSet)", "start": [23, 1], "end": [23, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectUsedDecls.collect", "code": "@[inline] def collect (f : FunId) : M Unit :=\n  modify fun s => s.insert f", "start": [25, 1], "end": [26, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectUsedDecls.collectFnBody", "code": "partial def collectFnBody : FnBody \u2192 M Unit\n  | .vdecl _ _ v b   =>\n    match v with\n    | .fap f _ => collect f *> collectFnBody b\n    | .pap f _ => collect f *> collectFnBody b\n    | _        => collectFnBody b\n  | .jdecl _ _ v b   => collectFnBody v *> collectFnBody b\n  | .case _ _ _ alts => alts.forM fun alt => collectFnBody alt.body\n  | e => do unless e.isTerminal do collectFnBody e.body", "start": [28, 1], "end": [36, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectUsedDecls.collectInitDecl", "code": "def collectInitDecl (fn : Name) : M Unit := do\n  let env \u2190 read\n  match getInitFnNameFor? env fn with\n  | some initFn => collect initFn\n  | _           => pure ()", "start": [38, 1], "end": [42, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectUsedDecls.collectDecl", "code": "def collectDecl : Decl \u2192 M NameSet\n  | .fdecl (f := f) (body := b) .. => collectInitDecl f *> CollectUsedDecls.collectFnBody b *> get\n  | .extern (f := f) .. => collectInitDecl f *> get", "start": [44, 1], "end": [46, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.collectUsedDecls", "code": "def collectUsedDecls (env : Environment) (decl : Decl) (used : NameSet := {}) : NameSet :=\n  (CollectUsedDecls.collectDecl decl env).run' used", "start": [50, 1], "end": [51, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.VarTypeMap", "code": "abbrev VarTypeMap  := HashMap VarId IRType", "start": [53, 1], "end": [53, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.JPParamsMap", "code": "abbrev JPParamsMap := HashMap JoinPointId (Array Param)", "start": [54, 1], "end": [54, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectMaps.Collector", "code": "abbrev Collector := (VarTypeMap \u00d7 JPParamsMap) \u2192 (VarTypeMap \u00d7 JPParamsMap)", "start": [57, 1], "end": [57, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectMaps.collectVar", "code": "@[inline] def collectVar (x : VarId) (t : IRType) : Collector\n  | (vs, js) => (vs.insert x t, js)", "start": [58, 1], "end": [59, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectMaps.collectParams", "code": "def collectParams (ps : Array Param) : Collector :=\n  fun s => ps.foldl (fun s p => collectVar p.x p.ty s) s", "start": [60, 1], "end": [61, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectMaps.collectJP", "code": "@[inline] def collectJP (j : JoinPointId) (xs : Array Param) : Collector\n  | (vs, js) => (vs, js.insert j xs)", "start": [62, 1], "end": [63, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectMaps.collectFnBody", "code": "partial def collectFnBody : FnBody \u2192 Collector\n  | .vdecl x t _ b    => collectVar x t \u2218 collectFnBody b\n  | .jdecl j xs v b   => collectJP j xs \u2218 collectParams xs \u2218 collectFnBody v \u2218 collectFnBody b\n  | .case _ _ _ alts  => fun s => alts.foldl (fun s alt => collectFnBody alt.body s) s\n  | e                 => if e.isTerminal then id else collectFnBody e.body", "start": [65, 1], "end": [70, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CollectMaps.collectDecl", "code": "def collectDecl : Decl \u2192 Collector\n  | .fdecl (xs := xs) (body := b) .. => collectParams xs \u2218 collectFnBody b\n  | _ => id", "start": [72, 1], "end": [74, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkVarJPMaps", "code": "def mkVarJPMaps (d : Decl) : VarTypeMap \u00d7 JPParamsMap :=\n  CollectMaps.collectDecl d ({}, {})", "start": [78, 1], "end": [82, 37], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/Boxing.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ExternAttr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/FreeVars.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Lean/Runtime.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ClosedTermCache.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/ElimDeadVars.lean"], "premises": [{"full_name": "Lean.IR.ExplicitBoxing.mkBoxedName", "code": "def mkBoxedName (n : Name) : Name :=\n  Name.mkStr n \"_boxed\"", "start": [30, 1], "end": [31, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.isBoxedName", "code": "def isBoxedName (name : Name) : Bool :=\n  name matches .str _ \"_boxed\"", "start": [33, 1], "end": [34, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.N", "code": "abbrev N := StateM Nat", "start": [36, 1], "end": [36, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.N.mkFresh", "code": "private def N.mkFresh : N VarId :=\n  modifyGet fun n => ({ idx := n }, n + 1)", "start": [38, 1], "end": [39, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.requiresBoxedVersion", "code": "def requiresBoxedVersion (env : Environment) (decl : Decl) : Bool :=\n  let ps := decl.params\n  (ps.size > 0 && (decl.resultType.isScalar || ps.any (fun p => p.ty.isScalar || p.borrow) || isExtern env decl.name))\n  || ps.size > closureMaxArgs", "start": [41, 1], "end": [44, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.mkBoxedVersionAux", "code": "def mkBoxedVersionAux (decl : Decl) : N Decl := do\n  let ps := decl.params\n  let qs \u2190 ps.mapM fun _ => do let x \u2190 N.mkFresh; pure { x := x, ty := IRType.object, borrow := false : Param }\n  let (newVDecls, xs) \u2190 qs.size.foldM (init := (#[], #[])) fun i (newVDecls, xs) => do\n    let p := ps[i]!\n    let q := qs[i]!\n    if !p.ty.isScalar then\n      pure (newVDecls, xs.push (Arg.var q.x))\n    else\n      let x \u2190 N.mkFresh\n      pure (newVDecls.push (FnBody.vdecl x p.ty (Expr.unbox q.x) default), xs.push (Arg.var x))\n  let r \u2190 N.mkFresh\n  let newVDecls := newVDecls.push (FnBody.vdecl r decl.resultType (Expr.fap decl.name xs) default)\n  let body \u2190 if !decl.resultType.isScalar then\n    pure <| reshape newVDecls (FnBody.ret (Arg.var r))\n  else\n    let newR \u2190 N.mkFresh\n    let newVDecls := newVDecls.push (FnBody.vdecl newR IRType.object (Expr.box decl.resultType r) default)\n    pure <| reshape newVDecls (FnBody.ret (Arg.var newR))\n  return Decl.fdecl (mkBoxedName decl.name) qs IRType.object body decl.getInfo", "start": [46, 1], "end": [65, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.mkBoxedVersion", "code": "def mkBoxedVersion (decl : Decl) : Decl :=\n  (mkBoxedVersionAux decl).run' 1", "start": [67, 1], "end": [68, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.addBoxedVersions", "code": "def addBoxedVersions (env : Environment) (decls : Array Decl) : Array Decl :=\n  let boxedDecls := decls.foldl (init := #[]) fun newDecls decl =>\n    if requiresBoxedVersion env decl then newDecls.push (mkBoxedVersion decl) else newDecls\n  decls ++ boxedDecls", "start": [70, 1], "end": [73, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.getScrutineeType", "code": "def getScrutineeType (alts : Array Alt) : IRType :=\n  let isScalar :=\n     alts.size > 1 && alts.all fun\n      | Alt.ctor c _  => c.isScalar\n      | Alt.default _ => false\n  match isScalar with\n  | false => IRType.object\n  | true  =>\n    let n := alts.size\n    if n < 256 then IRType.uint8\n    else if n < 65536 then IRType.uint16\n    else if n < 4294967296 then IRType.uint32\n    else IRType.object", "start": [75, 1], "end": [90, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.eqvTypes", "code": "def eqvTypes (t\u2081 t\u2082 : IRType) : Bool :=\n  (t\u2081.isScalar == t\u2082.isScalar) && (!t\u2081.isScalar || t\u2081 == t\u2082)", "start": [92, 1], "end": [93, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.BoxingContext", "code": "structure BoxingContext where\n  f : FunId := default\n  localCtx : LocalContext := {}\n  resultType : IRType := IRType.irrelevant\n  decls : Array Decl\n  env : Environment", "start": [95, 1], "end": [100, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.BoxingState", "code": "structure BoxingState where\n  nextIdx : Index\n  \n  auxDecls : Array Decl := #[]\n  auxDeclCache : AssocList FnBody Expr := AssocList.empty\n  nextAuxId : Nat := 1", "start": [102, 1], "end": [117, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.M", "code": "abbrev M := ReaderT BoxingContext (StateT BoxingState Id)", "start": [119, 1], "end": [119, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.M.mkFresh", "code": "private def M.mkFresh : M VarId := do\n  let oldS \u2190 getModify fun s => { s with nextIdx := s.nextIdx + 1 }\n  pure { idx := oldS.nextIdx }", "start": [121, 1], "end": [123, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.getEnv", "code": "def getEnv : M Environment := BoxingContext.env <$> read", "start": [125, 1], "end": [125, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.getLocalContext", "code": "def getLocalContext : M LocalContext := BoxingContext.localCtx <$> read", "start": [126, 1], "end": [126, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.getResultType", "code": "def getResultType : M IRType := BoxingContext.resultType <$> read", "start": [127, 1], "end": [127, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.getVarType", "code": "def getVarType (x : VarId) : M IRType := do\n  let localCtx \u2190 getLocalContext\n  match localCtx.getType x with\n  | some t => pure t\n  | none   => pure IRType.object", "start": [129, 1], "end": [133, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.getJPParams", "code": "def getJPParams (j : JoinPointId) : M (Array Param) := do\n  let localCtx \u2190 getLocalContext\n  match localCtx.getJPParams j with\n  | some ys => pure ys\n  | none    => pure #[]", "start": [135, 1], "end": [139, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.getDecl", "code": "def getDecl (fid : FunId) : M Decl := do\n  let ctx \u2190 read\n  match findEnvDecl' ctx.env fid ctx.decls with\n  | some decl => pure decl\n  | none      => pure default", "start": [141, 1], "end": [145, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.withParams", "code": "@[inline] def withParams {\u03b1 : Type} (xs : Array Param) (k : M \u03b1) : M \u03b1 :=\n  withReader (fun ctx => { ctx with localCtx := ctx.localCtx.addParams xs }) k", "start": [147, 1], "end": [148, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.withVDecl", "code": "@[inline] def withVDecl {\u03b1 : Type} (x : VarId) (ty : IRType) (v : Expr) (k : M \u03b1) : M \u03b1 :=\n  withReader (fun ctx => { ctx with localCtx := ctx.localCtx.addLocal x ty v }) k", "start": [150, 1], "end": [151, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.withJDecl", "code": "@[inline] def withJDecl {\u03b1 : Type} (j : JoinPointId) (xs : Array Param) (v : FnBody) (k : M \u03b1) : M \u03b1 :=\n  withReader (fun ctx => { ctx with localCtx := ctx.localCtx.addJP j xs v }) k", "start": [153, 1], "end": [154, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.isExpensiveConstantValueBoxing", "code": "private def isExpensiveConstantValueBoxing (x : VarId) (xType : IRType) : M (Option Expr) :=\n  if !xType.isScalar then\n    return none else match xType with\n    | IRType.uint8  => return none\n    | IRType.uint16 => return none\n    | _ => do\n      let localCtx \u2190 getLocalContext\n      match localCtx.getValue x with\n      | some val =>\n        match val with\n        | Expr.lit _ => return some val\n        | Expr.fap _ args => return if args.size == 0 then some val else none\n        | _ => return none\n      | _ => return none", "start": [156, 1], "end": [172, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.mkCast", "code": "def mkCast (x : VarId) (xType : IRType) (expectedType : IRType) : M Expr := do\n  match (\u2190 isExpensiveConstantValueBoxing x xType) with\n  | some v => do\n    let ctx \u2190 read\n    let s \u2190 get\n    \n    let body : FnBody :=\n      FnBody.vdecl { idx := 1 } xType v $\n      FnBody.vdecl { idx := 2 } expectedType (Expr.box xType { idx := 1 }) $\n      FnBody.ret (mkVarArg { idx := 2 })\n    match s.auxDeclCache.find? body with\n    | some v => pure v\n    | none   => do\n      let auxName  := ctx.f ++ ((`_boxed_const).appendIndexAfter s.nextAuxId)\n      let auxConst := Expr.fap auxName #[]\n      let auxDecl  := Decl.fdecl auxName #[] expectedType body {}\n      modify fun s => { s with\n       auxDecls     := s.auxDecls.push auxDecl\n       auxDeclCache := s.auxDeclCache.cons body auxConst\n       nextAuxId    := s.nextAuxId + 1\n      }\n      pure auxConst\n  | none => pure $ if xType.isScalar then Expr.box xType x else Expr.unbox x", "start": [174, 1], "end": [205, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.castVarIfNeeded", "code": "@[inline] def castVarIfNeeded (x : VarId) (expected : IRType) (k : VarId \u2192 M FnBody) : M FnBody := do\n  let xType \u2190 getVarType x\n  if eqvTypes xType expected then\n    k x\n  else\n    let y \u2190 M.mkFresh\n    let v \u2190 mkCast x xType expected\n    FnBody.vdecl y expected v <$> k y", "start": [207, 1], "end": [214, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.castArgIfNeeded", "code": "@[inline] def castArgIfNeeded (x : Arg) (expected : IRType) (k : Arg \u2192 M FnBody) : M FnBody :=\n  match x with\n  | Arg.var x => castVarIfNeeded x expected (fun x => k (Arg.var x))\n  | _         => k x", "start": [216, 1], "end": [219, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.castArgsIfNeededAux", "code": "def castArgsIfNeededAux (xs : Array Arg) (typeFromIdx : Nat \u2192 IRType) : M (Array Arg \u00d7 Array FnBody) := do\n  let mut xs' := #[]\n  let mut bs  := #[]\n  let mut i   := 0\n  for x in xs do\n    let expected := typeFromIdx i\n    match x with\n    | Arg.irrelevant =>\n      xs' := xs'.push x\n    | Arg.var x =>\n      let xType \u2190 getVarType x\n      if eqvTypes xType expected then\n        xs' := xs'.push (Arg.var x)\n      else\n        let y \u2190 M.mkFresh\n        let v \u2190 mkCast x xType expected\n        let b := FnBody.vdecl y expected v FnBody.nil\n        xs' := xs'.push (Arg.var y)\n        bs := bs.push b\n    i := i + 1\n  return (xs', bs)", "start": [221, 1], "end": [241, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.castArgsIfNeeded", "code": "@[inline] def castArgsIfNeeded (xs : Array Arg) (ps : Array Param) (k : Array Arg \u2192 M FnBody) : M FnBody := do\n  let (ys, bs) \u2190 castArgsIfNeededAux xs fun i => ps[i]!.ty\n  let b \u2190 k ys\n  pure (reshape bs b)", "start": [243, 1], "end": [246, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.boxArgsIfNeeded", "code": "@[inline] def boxArgsIfNeeded (xs : Array Arg) (k : Array Arg \u2192 M FnBody) : M FnBody := do\n  let (ys, bs) \u2190 castArgsIfNeededAux xs (fun _ => IRType.object)\n  let b \u2190 k ys\n  pure (reshape bs b)", "start": [248, 1], "end": [251, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.unboxResultIfNeeded", "code": "def unboxResultIfNeeded (x : VarId) (ty : IRType) (e : Expr) (b : FnBody) : M FnBody := do\n  if ty.isScalar then\n    let y \u2190 M.mkFresh\n    return FnBody.vdecl y IRType.object e (FnBody.vdecl x ty (Expr.unbox y) b)\n  else\n    return FnBody.vdecl x ty e b", "start": [253, 1], "end": [258, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.castResultIfNeeded", "code": "def castResultIfNeeded (x : VarId) (ty : IRType) (e : Expr) (eType : IRType) (b : FnBody) : M FnBody := do\n  if eqvTypes ty eType then\n    return FnBody.vdecl x ty e b\n  else\n    let y \u2190 M.mkFresh\n    let v \u2190 mkCast y eType ty\n    return FnBody.vdecl y eType e (FnBody.vdecl x ty v b)", "start": [260, 1], "end": [266, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.visitVDeclExpr", "code": "def visitVDeclExpr (x : VarId) (ty : IRType) (e : Expr) (b : FnBody) : M FnBody :=\n  match e with\n  | Expr.ctor c ys =>\n    if c.isScalar && ty.isScalar then\n      return FnBody.vdecl x ty (Expr.lit (LitVal.num c.cidx)) b\n    else\n      boxArgsIfNeeded ys fun ys => return FnBody.vdecl x ty (Expr.ctor c ys) b\n  | Expr.reuse w c u ys =>\n    boxArgsIfNeeded ys fun ys => return FnBody.vdecl x ty (Expr.reuse w c u ys) b\n  | Expr.fap f ys => do\n    let decl \u2190 getDecl f\n    castArgsIfNeeded ys decl.params fun ys =>\n    castResultIfNeeded x ty (Expr.fap f ys) decl.resultType b\n  | Expr.pap f ys => do\n    let env \u2190 getEnv\n    let decl \u2190 getDecl f\n    let f := if requiresBoxedVersion env decl then mkBoxedName f else f\n    boxArgsIfNeeded ys fun ys => return FnBody.vdecl x ty (Expr.pap f ys) b\n  | Expr.ap f ys =>\n    boxArgsIfNeeded ys fun ys =>\n    unboxResultIfNeeded x ty (Expr.ap f ys) b\n  | _     =>\n    return FnBody.vdecl x ty e b", "start": [268, 1], "end": [290, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.visitFnBody", "code": "partial def visitFnBody : FnBody \u2192 M FnBody\n  | FnBody.vdecl x t v b     => do\n    let b \u2190 withVDecl x t v (visitFnBody b)\n    visitVDeclExpr x t v b\n  | FnBody.jdecl j xs v b    => do\n    let v \u2190 withParams xs (visitFnBody v)\n    let b \u2190 withJDecl j xs v (visitFnBody b)\n    return FnBody.jdecl j xs v b\n  | FnBody.uset x i y b      => do\n    let b \u2190 visitFnBody b\n    castVarIfNeeded y IRType.usize fun y =>\n      return FnBody.uset x i y b\n  | FnBody.sset x i o y ty b => do\n    let b \u2190 visitFnBody b\n    castVarIfNeeded y ty fun y =>\n      return FnBody.sset x i o y ty b\n  | FnBody.mdata d b         =>\n    FnBody.mdata d <$> visitFnBody b\n  | FnBody.case tid x _ alts   => do\n    let expected := getScrutineeType alts\n    let alts \u2190 alts.mapM fun alt => alt.mmodifyBody visitFnBody\n    castVarIfNeeded x expected fun x => do\n      return FnBody.case tid x expected alts\n  | FnBody.ret x             => do\n    let expected \u2190 getResultType\n    castArgIfNeeded x expected (fun x => return FnBody.ret x)\n  | FnBody.jmp j ys          => do\n    let ps \u2190 getJPParams j\n    castArgsIfNeeded ys ps fun ys => return FnBody.jmp j ys\n  | other                    =>\n    pure other", "start": [292, 1], "end": [322, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitBoxing.run", "code": "def run (env : Environment) (decls : Array Decl) : Array Decl :=\n  let ctx : BoxingContext := { decls := decls, env := env }\n  let decls := decls.foldl (init := #[]) fun newDecls decl =>\n    match decl with\n    | .fdecl (f := f) (xs := xs) (type := t) (body := b) .. =>\n      let nextIdx  := decl.maxIndex + 1\n      let (b, s)   := (withParams xs (visitFnBody b) { ctx with f := f, resultType := t }).run { nextIdx := nextIdx }\n      let newDecls := newDecls ++ s.auxDecls\n      let newDecl  := decl.updateBody! b\n      let newDecl  := newDecl.elimDead\n      newDecls.push newDecl\n    | d => newDecls.push d\n  addBoxedVersions env decls", "start": [324, 1], "end": [336, 29], "kind": "commanddeclaration"}, {"full_name": "explicitBoxing", "code": "def explicitBoxing (decls : Array Decl) : CompilerM (Array Decl) := do\n  let env \u2190 getEnv\n  return ExplicitBoxing.run env decls", "start": [340, 1], "end": [342, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/SimpCase.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Format.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.ensureHasDefault", "code": "def ensureHasDefault (alts : Array Alt) : Array Alt :=\n  if alts.any Alt.isDefault then alts\n  else if alts.size < 2 then alts\n  else\n    let last := alts.back;\n    let alts := alts.pop;\n    alts.push (Alt.default last.body)", "start": [11, 1], "end": [17, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getOccsOf", "code": "private def getOccsOf (alts : Array Alt) (i : Nat) : Nat := Id.run do\n  let aBody := (alts.get! i).body\n  let mut n := 1\n  for j in [i+1:alts.size] do\n    if alts[j]!.body == aBody then\n      n := n+1\n  return n", "start": [19, 1], "end": [25, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.maxOccs", "code": "private def maxOccs (alts : Array Alt) : Alt \u00d7 Nat := Id.run do\n  let mut maxAlt := alts[0]!\n  let mut max    := getOccsOf alts 0\n  for i in [1:alts.size] do\n    let curr := getOccsOf alts i\n    if curr > max then\n       maxAlt := alts[i]!\n       max    := curr\n  return (maxAlt, max)", "start": [27, 1], "end": [35, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.addDefault", "code": "private def addDefault (alts : Array Alt) : Array Alt :=\n  if alts.size <= 1 || alts.any Alt.isDefault then alts\n  else\n    let (max, noccs) := maxOccs alts\n    if noccs == 1 then alts\n    else\n      let alts := alts.filter fun alt => alt.body != max.body\n      alts.push (Alt.default max.body)", "start": [37, 1], "end": [44, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.filterUnreachable", "code": "private def filterUnreachable (alts : Array Alt) : Array Alt :=\n  alts.filter fun alt => alt.body != FnBody.unreachable", "start": [46, 1], "end": [47, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkSimpCase", "code": "private def mkSimpCase (tid : Name) (x : VarId) (xType : IRType) (alts : Array Alt) : FnBody :=\n  let alts := filterUnreachable alts\n  let alts := addDefault alts;\n  if alts.size == 0 then\n    FnBody.unreachable\n  else if alts.size == 1 then\n    (alts.get! 0).body\n  else\n    FnBody.case tid x xType alts", "start": [49, 1], "end": [57, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.simpCase", "code": "partial def FnBody.simpCase (b : FnBody) : FnBody :=\n  let (bs, term) := b.flatten;\n  let bs         := modifyJPs bs simpCase;\n  match term with\n  | FnBody.case tid x xType alts =>\n    let alts := alts.map fun alt => alt.modifyBody simpCase;\n    reshape bs (mkSimpCase tid x xType alts)\n  | _     => reshape bs term", "start": [59, 1], "end": [66, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.simpCase", "code": "def Decl.simpCase (d : Decl) : Decl :=\n  match d with\n  | .fdecl (body := b) .. => d.updateBody! b.simpCase\n  | other => other", "start": [68, 1], "end": [75, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/NameMangling.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Name.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "String.mangleAux", "code": "private def mangleAux : Nat \u2192 String.Iterator \u2192 String \u2192 String\n  | 0,   _,  r => r\n  | i+1, it, r =>\n    let c := it.curr\n    if c.isAlpha || c.isDigit then\n      mangleAux i it.next (r.push c)\n    else if c = '_' then\n      mangleAux i it.next (r ++ \"__\")\n    else if c.toNat < 0x100 then\n      let n := c.toNat\n      let r := r ++ \"_x\"\n      let r := r.push <| Nat.digitChar (n / 0x10)\n      let r := r.push <| Nat.digitChar (n % 0x10)\n      mangleAux i it.next r\n    else if c.toNat < 0x10000 then\n      let n := c.toNat\n      let r := r ++ \"_u\"\n      let r := r.push <| Nat.digitChar (n / 0x1000)\n      let n := n % 0x1000\n      let r := r.push <| Nat.digitChar (n / 0x100)\n      let n := n % 0x100\n      let r := r.push <| Nat.digitChar (n / 0x10)\n      let r := r.push <| Nat.digitChar (n % 0x10)\n      mangleAux i it.next r\n    else\n      let n := c.toNat\n      let r := r ++ \"_U\"\n      let ds := Nat.toDigits 16 n\n      let r := Nat.repeat (\u00b7.push '0') (8 - ds.length) r\n      let r := ds.foldl (fun r c => r.push c) r\n      mangleAux i it.next r", "start": [10, 1], "end": [40, 28], "kind": "commanddeclaration"}, {"full_name": "String.mangle", "code": "def mangle (s : String) : String :=\n  mangleAux s.length s.mkIterator \"\"", "start": [42, 1], "end": [43, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mangleAux", "code": "private def Name.mangleAux : Name \u2192 String\n  | Name.anonymous => \"\"\n  | Name.str p s =>\n    let m := String.mangle s\n    match p with\n    | Name.anonymous => m\n    | p              => mangleAux p ++ \"_\" ++ m\n  | Name.num p n => mangleAux p ++ \"_\" ++ toString n ++ \"_\"", "start": [49, 1], "end": [56, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mangle", "code": "@[export lean_name_mangle]\ndef Name.mangle (n : Name) (pre : String := \"l_\") : String :=\n  pre ++ Name.mangleAux n", "start": [58, 1], "end": [60, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.mkModuleInitializationFunctionName", "code": "@[export lean_mk_module_initialization_function_name]\ndef mkModuleInitializationFunctionName (moduleName : Name) : String :=\n  \"initialize_\" ++ moduleName.mangle \"\"", "start": [62, 1], "end": [64, 40], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/ExportAttr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.isValidCppId", "code": "private def isValidCppId (id : String) : Bool :=\n  let first := id.get 0;\n  first.isAlpha  && (id.toSubstring.drop 1).all (fun c => c.isAlpha || c.isDigit || c == '_')", "start": [10, 1], "end": [12, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.isValidCppName", "code": "private def isValidCppName : Name \u2192 Bool\n  | .str .anonymous s => isValidCppId s\n  | .str p s          => isValidCppId s && isValidCppName p\n  | _                 => false", "start": [14, 1], "end": [17, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.getExportNameFor?", "code": "@[export lean_get_export_name_for]\ndef getExportNameFor? (env : Environment) (n : Name) : Option Name :=\n  exportAttr.getParam? env n", "start": [30, 1], "end": [32, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.isExport", "code": "def isExport (env : Environment) (n : Name) : Bool :=\n  (getExportNameFor? env n).isSome || n == `main", "start": [34, 1], "end": [37, 49], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/LiveVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/FreeVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.IsLive.M", "code": "abbrev M := StateM LocalContext", "start": [29, 1], "end": [37, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IsLive.visitVar", "code": "abbrev visitVar (w : Index) (x : VarId) : M Bool := pure (HasIndex.visitVar w x)", "start": [39, 1], "end": [39, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IsLive.visitJP", "code": "abbrev visitJP (w : Index) (x : JoinPointId) : M Bool := pure (HasIndex.visitJP w x)", "start": [40, 1], "end": [40, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IsLive.visitArg", "code": "abbrev visitArg (w : Index) (a : Arg) : M Bool := pure (HasIndex.visitArg w a)", "start": [41, 1], "end": [41, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IsLive.visitArgs", "code": "abbrev visitArgs (w : Index) (as : Array Arg) : M Bool := pure (HasIndex.visitArgs w as)", "start": [42, 1], "end": [42, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IsLive.visitExpr", "code": "abbrev visitExpr (w : Index) (e : Expr) : M Bool := pure (HasIndex.visitExpr w e)", "start": [43, 1], "end": [43, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IsLive.visitFnBody", "code": "partial def visitFnBody (w : Index) : FnBody \u2192 M Bool\n  | FnBody.vdecl _ _ v b    => visitExpr w v <||> visitFnBody w b\n  | FnBody.jdecl _ _  v b   => visitFnBody w v <||> visitFnBody w b\n  | FnBody.set x _ y b      => visitVar w x <||> visitArg w y <||> visitFnBody w b\n  | FnBody.uset x _ y b     => visitVar w x <||> visitVar w y <||> visitFnBody w b\n  | FnBody.sset x _ _ y _ b => visitVar w x <||> visitVar w y <||> visitFnBody w b\n  | FnBody.setTag x _ b     => visitVar w x <||> visitFnBody w b\n  | FnBody.inc x _ _ _ b    => visitVar w x <||> visitFnBody w b\n  | FnBody.dec x _ _ _ b    => visitVar w x <||> visitFnBody w b\n  | FnBody.del x b          => visitVar w x <||> visitFnBody w b\n  | FnBody.mdata _ b        => visitFnBody w b\n  | FnBody.jmp j ys         => visitArgs w ys <||> do\n      let ctx \u2190 get\n      match ctx.getJPBody j with\n      | some b =>\n        set (ctx.eraseJoinPointDecl j) *> visitFnBody w b\n      | none   =>\n        pure false\n  | FnBody.ret x            => visitArg w x\n  | FnBody.case _ x _ alts  => visitVar w x <||> alts.anyM (fun alt => visitFnBody w alt.body)\n  | FnBody.unreachable      => pure false", "start": [45, 1], "end": [68, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.hasLiveVar", "code": "def FnBody.hasLiveVar (b : FnBody) (ctx : LocalContext) (x : VarId) : Bool :=\n  (IsLive.visitFnBody x.idx b).run' ctx", "start": [72, 1], "end": [79, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVarSet", "code": "abbrev LiveVarSet   := VarIdSet", "start": [81, 1], "end": [81, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.JPLiveVarMap", "code": "abbrev JPLiveVarMap := RBMap JoinPointId LiveVarSet (fun j\u2081 j\u2082 => compare j\u2081.idx j\u2082.idx)", "start": [82, 1], "end": [82, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkLiveVarSet", "code": "def mkLiveVarSet (x : VarId) : LiveVarSet :=\n  RBTree.empty.insert x", "start": [87, 1], "end": [88, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.Collector", "code": "abbrev Collector := LiveVarSet \u2192 LiveVarSet", "start": [92, 1], "end": [92, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.skip", "code": "@[inline] private def skip : Collector := fun s => s", "start": [94, 1], "end": [94, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.collectVar", "code": "@[inline] private def collectVar (x : VarId) : Collector := fun s => s.insert x", "start": [95, 1], "end": [95, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.collectArg", "code": "private def collectArg : Arg \u2192 Collector\n  | Arg.var x  => collectVar x\n  | _          => skip", "start": [97, 1], "end": [99, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.collectArray", "code": "private def collectArray {\u03b1 : Type} (as : Array \u03b1) (f : \u03b1 \u2192 Collector) : Collector := fun s =>\n  as.foldl (fun s a => f a s) s", "start": [101, 1], "end": [102, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.collectArgs", "code": "private def collectArgs (as : Array Arg) : Collector :=\n  collectArray as collectArg", "start": [104, 1], "end": [105, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.accumulate", "code": "private def accumulate (s' : LiveVarSet) : Collector :=\n  fun s => s'.fold (fun s x => s.insert x) s", "start": [107, 1], "end": [108, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.collectJP", "code": "private def collectJP (m : JPLiveVarMap) (j : JoinPointId) : Collector :=\n  match m.find? j with\n  | some xs => accumulate xs\n  | none    => skip", "start": [110, 1], "end": [113, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.bindVar", "code": "private def bindVar (x : VarId) : Collector := fun s =>\n  s.erase x", "start": [115, 1], "end": [116, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.bindParams", "code": "private def bindParams (ps : Array Param) : Collector := fun s =>\n  ps.foldl (fun s p => s.erase p.x) s", "start": [118, 1], "end": [119, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.collectExpr", "code": "def collectExpr : Expr \u2192 Collector\n  | Expr.ctor _ ys      => collectArgs ys\n  | Expr.reset _ x      => collectVar x\n  | Expr.reuse x _ _ ys => collectVar x \u2218 collectArgs ys\n  | Expr.proj _ x       => collectVar x\n  | Expr.uproj _ x      => collectVar x\n  | Expr.sproj _ _ x    => collectVar x\n  | Expr.fap _ ys       => collectArgs ys\n  | Expr.pap _ ys       => collectArgs ys\n  | Expr.ap x ys        => collectVar x \u2218 collectArgs ys\n  | Expr.box _ x        => collectVar x\n  | Expr.unbox x        => collectVar x\n  | Expr.lit _          => skip\n  | Expr.isShared x     => collectVar x", "start": [121, 1], "end": [134, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.collectFnBody", "code": "partial def collectFnBody : FnBody \u2192 JPLiveVarMap \u2192 Collector\n  | FnBody.vdecl x _ v b,    m => collectExpr v \u2218 bindVar x \u2218 collectFnBody b m\n  | FnBody.jdecl j ys v b,   m =>\n    let jLiveVars := (bindParams ys \u2218 collectFnBody v m) {};\n    let m         := m.insert j jLiveVars;\n    collectFnBody b m\n  | FnBody.set x _ y b,      m => collectVar x \u2218 collectArg y \u2218 collectFnBody b m\n  | FnBody.setTag x _ b,     m => collectVar x \u2218 collectFnBody b m\n  | FnBody.uset x _ y b,     m => collectVar x \u2218 collectVar y \u2218 collectFnBody b m\n  | FnBody.sset x _ _ y _ b, m => collectVar x \u2218 collectVar y \u2218 collectFnBody b m\n  | FnBody.inc x _ _ _ b,    m => collectVar x \u2218 collectFnBody b m\n  | FnBody.dec x _ _ _ b,    m => collectVar x \u2218 collectFnBody b m\n  | FnBody.del x b,          m => collectVar x \u2218 collectFnBody b m\n  | FnBody.mdata _ b,        m => collectFnBody b m\n  | FnBody.ret x,            _ => collectArg x\n  | FnBody.case _ x _ alts,  m => collectVar x \u2218 collectArray alts (fun alt => collectFnBody alt.body m)\n  | FnBody.unreachable,      _ => skip\n  | FnBody.jmp j xs,         m => collectJP m j \u2218 collectArgs xs", "start": [136, 1], "end": [153, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LiveVars.updateJPLiveVarMap", "code": "def updateJPLiveVarMap (j : JoinPointId) (ys : Array Param) (v : FnBody) (m : JPLiveVarMap) : JPLiveVarMap :=\n  let jLiveVars := (bindParams ys \u2218 collectFnBody v m) {};\n  m.insert j jLiveVars", "start": [155, 1], "end": [157, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.updateLiveVars", "code": "def updateLiveVars (e : Expr) (v : LiveVarSet) : LiveVarSet :=\n  LiveVars.collectExpr e v", "start": [161, 1], "end": [162, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.collectLiveVars", "code": "def collectLiveVars (b : FnBody) (m : JPLiveVarMap) (v : LiveVarSet := {}) : LiveVarSet :=\n  LiveVars.collectFnBody b m v", "start": [164, 1], "end": [165, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Deriving.implicitBinderF", "code": "def implicitBinderF := Parser.Term.implicitBinder", "start": [12, 1], "end": [12, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.instBinderF", "code": "def instBinderF     := Parser.Term.instBinder", "start": [13, 1], "end": [13, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.explicitBinderF", "code": "def explicitBinderF := Parser.Term.explicitBinder", "start": [14, 1], "end": [14, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkInductArgNames", "code": "def mkInductArgNames (indVal : InductiveVal) : TermElabM (Array Name) := do\n  forallTelescopeReducing indVal.type fun xs _ => do\n    let mut argNames := #[]\n    for x in xs do\n      let localDecl \u2190 x.fvarId!.getDecl\n      let paramName \u2190 mkFreshUserName localDecl.userName.eraseMacroScopes\n      argNames := argNames.push paramName\n    pure argNames", "start": [16, 1], "end": [26, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkInductiveApp", "code": "def mkInductiveApp (indVal : InductiveVal) (argNames : Array Name) : TermElabM Term :=\n  let f    := mkCIdent indVal.name\n  let args := argNames.map mkIdent\n  `(@$f $args*)", "start": [28, 1], "end": [32, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkImplicitBinders", "code": "def mkImplicitBinders (argNames : Array Name) : TermElabM (Array (TSyntax ``Parser.Term.implicitBinder)) :=\n  argNames.mapM fun argName =>\n    `(implicitBinderF| { $(mkIdent argName) })", "start": [35, 1], "end": [40, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkInstImplicitBinders", "code": "def mkInstImplicitBinders (className : Name) (indVal : InductiveVal) (argNames : Array Name) : TermElabM (Array Syntax) :=\n  forallBoundedTelescope indVal.type indVal.numParams fun xs _ => do\n    let mut binders := #[]\n    for i in [:xs.size] do\n      try\n        let x := xs[i]!\n        let c \u2190 mkAppM className #[x]\n        if (\u2190 isTypeCorrect c) then\n          let argName := argNames[i]!\n          let binder : Syntax \u2190 `(instBinderF| [ $(mkCIdent className):ident $(mkIdent argName):ident ])\n          binders := binders.push binder\n      catch _ =>\n        pure ()\n    return binders", "start": [42, 1], "end": [61, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Context", "code": "structure Context where\n  typeInfos   : Array InductiveVal\n  auxFunNames : Array Name\n  usePartial  : Bool", "start": [63, 1], "end": [66, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkContext", "code": "def mkContext (fnPrefix : String) (typeName : Name) : TermElabM Context := do\n  let indVal \u2190 getConstInfoInduct typeName\n  let mut typeInfos := #[]\n  for typeName in indVal.all do\n    typeInfos := typeInfos.push (\u2190 getConstInfoInduct typeName)\n  let mut auxFunNames := #[]\n  for typeName in indVal.all do\n    match typeName.eraseMacroScopes with\n    | .str _ t => auxFunNames := auxFunNames.push (\u2190 mkFreshUserName <| Name.mkSimple <| fnPrefix ++ t)\n    | _        => auxFunNames := auxFunNames.push (\u2190 mkFreshUserName `instFn)\n  trace[Elab.Deriving.beq] \"{auxFunNames}\"\n  let usePartial := indVal.isNested || typeInfos.size > 1\n  return {\n    typeInfos   := typeInfos\n    auxFunNames := auxFunNames\n    usePartial  := usePartial\n  }", "start": [68, 1], "end": [84, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkLocalInstanceLetDecls", "code": "def mkLocalInstanceLetDecls (ctx : Context) (className : Name) (argNames : Array Name) : TermElabM (Array (TSyntax ``Parser.Term.letDecl)) := do\n  let mut letDecls := #[]\n  for i in [:ctx.typeInfos.size] do\n    let indVal       := ctx.typeInfos[i]!\n    let auxFunName   := ctx.auxFunNames[i]!\n    let currArgNames \u2190 mkInductArgNames indVal\n    let numParams    := indVal.numParams\n    let currIndices  := currArgNames[numParams:]\n    let binders      \u2190 mkImplicitBinders currIndices\n    let argNamesNew  := argNames[:numParams] ++ currIndices\n    let indType      \u2190 mkInductiveApp indVal argNamesNew\n    let type         \u2190 `($(mkCIdent className) $indType)\n    let val          \u2190 `(\u27e8$(mkIdent auxFunName)\u27e9)\n    let instName     \u2190 mkFreshUserName `localinst\n    let letDecl      \u2190 `(Parser.Term.letDecl| $(mkIdent instName):ident $binders:implicitBinder* : $type := $val)\n    letDecls := letDecls.push letDecl\n  return letDecls", "start": [86, 1], "end": [102, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkLet", "code": "def mkLet (letDecls : Array (TSyntax ``Parser.Term.letDecl)) (body : Term) : TermElabM Term :=\n  letDecls.foldrM (init := body) fun letDecl body =>\n    `(let $letDecl:letDecl; $body)", "start": [104, 1], "end": [106, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkInstanceCmds", "code": "def mkInstanceCmds (ctx : Context) (className : Name) (typeNames : Array Name) (useAnonCtor := true) : TermElabM (Array Command) := do\n  let mut instances := #[]\n  for i in [:ctx.typeInfos.size] do\n    let indVal       := ctx.typeInfos[i]!\n    if typeNames.contains indVal.name then\n      let auxFunName   := ctx.auxFunNames[i]!\n      let argNames     \u2190 mkInductArgNames indVal\n      let binders      \u2190 mkImplicitBinders argNames\n      let binders      := binders ++ (\u2190 mkInstImplicitBinders className indVal argNames)\n      let indType      \u2190 mkInductiveApp indVal argNames\n      let type         \u2190 `($(mkCIdent className) $indType)\n      let mut val      := mkIdent auxFunName\n      if useAnonCtor then\n        val \u2190 `(\u27e8$val\u27e9)\n      let instCmd \u2190 `(instance $binders:implicitBinder* : $type := $val)\n      instances := instances.push instCmd\n  return instances", "start": [109, 1], "end": [125, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkDiscr", "code": "def mkDiscr (varName : Name) : TermElabM (TSyntax ``Parser.Term.matchDiscr) :=\n `(Parser.Term.matchDiscr| $(mkIdent varName):term)", "start": [127, 1], "end": [128, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Header", "code": "structure Header where\n  binders     : Array (TSyntax ``Parser.Term.bracketedBinder)\n  argNames    : Array Name\n  targetNames : Array Name\n  targetType  : Term", "start": [130, 1], "end": [134, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkHeader", "code": "def mkHeader (className : Name) (arity : Nat) (indVal : InductiveVal) : TermElabM Header := do\n  let argNames      \u2190 mkInductArgNames indVal\n  let binders       \u2190 mkImplicitBinders argNames\n  let targetType    \u2190 mkInductiveApp indVal argNames\n  let mut targetNames := #[]\n  for _ in [:arity] do\n    targetNames := targetNames.push (\u2190 mkFreshUserName `x)\n  let binders      := binders ++ (\u2190 mkInstImplicitBinders className indVal argNames)\n  let binders      := binders ++ (\u2190 targetNames.mapM fun targetName => `(explicitBinderF| ($(mkIdent targetName) : $targetType)))\n  return {\n    binders     := binders\n    argNames    := argNames\n    targetNames := targetNames\n    targetType  := targetType\n  }", "start": [137, 1], "end": [151, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.mkDiscrs", "code": "def mkDiscrs (header : Header) (indVal : InductiveVal) : TermElabM (Array (TSyntax ``Parser.Term.matchDiscr)) := do\n  let mut discrs := #[]\n  for argName in header.argNames[indVal.numParams:] do\n    discrs := discrs.push (\u2190 mkDiscr argName)\n  return discrs ++ (\u2190 header.targetNames.mapM mkDiscr)", "start": [153, 1], "end": [158, 55], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Xml/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Xml.Attributes", "code": "def Attributes := RBMap String String compare", "start": [12, 1], "end": [12, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Element", "code": "inductive Element\n| Element\n  (name : String)\n  (attributes : Attributes)\n  (content : Array Content)", "start": [16, 1], "end": [20, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Content", "code": "inductive Content\n| Element (element : Element)\n| Comment (comment : String)\n| Character (content : String)\nderiving Inhabited", "start": [22, 1], "end": [26, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.eToString", "code": "private partial def eToString : Element \u2192 String\n| Element.Element n a c => s!\"<{n}{a}>{c.map cToString |>.foldl (\u00b7 ++ \u00b7) \"\"}</{n}>\"", "start": [30, 1], "end": [31, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.cToString", "code": "private partial def cToString : Content \u2192 String\n| Content.Element e => eToString e\n| Content.Comment c => s!\"<!| Content.Character c => c", "start": [33, 1], "end": [36, 27], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean", "imports": ["lake-packages/lean4/src/lean/Lean/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Parser/Command.lean", "lake-packages/lean4/src/lean/Lean/Log.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Utf16.lean"], "premises": [{"full_name": "Lean.Elab.getDeclarationRange", "code": "def getDeclarationRange [Monad m] [MonadFileMap m] (stx : Syntax) : m DeclarationRange := do\n  let fileMap \u2190 getFileMap\n  let pos    := stx.getPos?.getD 0\n  let endPos := stx.getTailPos?.getD pos |> fileMap.toPosition\n  let pos    := pos |> fileMap.toPosition\n  return {\n    pos          := pos\n    charUtf16    := fileMap.leanPosToLspPos pos |>.character\n    endPos       := endPos\n    endCharUtf16 := fileMap.leanPosToLspPos endPos |>.character\n  }", "start": [13, 1], "end": [23, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.getDeclarationSelectionRef", "code": "def getDeclarationSelectionRef (stx : Syntax) : Syntax :=\n  if stx.isOfKind ``Lean.Parser.Command.instance then\n    if !stx[3].isNone then\n      stx[3][0]\n    else\n      stx[1]\n  else\n    if stx[1][0].isIdent then\n      stx[1][0]  else if stx[1].isIdent then\n      stx[1]  else\n      stx[0]", "start": [25, 1], "end": [47, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addDeclarationRanges", "code": "def addDeclarationRanges [Monad m] [MonadEnv m] [MonadFileMap m] (declName : Name) (stx : Syntax) : m Unit := do\n  if stx.getKind == ``Parser.Command.\u00abexample\u00bb then\n    return ()\n  else\n    Lean.addDeclarationRanges declName {\n      range          := (\u2190 getDeclarationRange stx)\n      selectionRange := (\u2190 getDeclarationRange (getDeclarationSelectionRef stx))\n    }", "start": [50, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addAuxDeclarationRanges", "code": "def addAuxDeclarationRanges [Monad m] [MonadEnv m] [MonadFileMap m] (declName : Name) (stx : Syntax) (header : Syntax) : m Unit := do\n  Lean.addDeclarationRanges declName {\n    range          := (\u2190 getDeclarationRange stx)\n    selectionRange := (\u2190 getDeclarationRange header)\n  }", "start": [63, 1], "end": [68, 4], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Inductive.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ReplaceLevel.lean", "lake-packages/lean4/src/lean/Lean/Meta/CollectFVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/Injective.lean", "lake-packages/lean4/src/lean/Lean/Meta/IndPredBelow.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectLevelParams.lean", "lake-packages/lean4/src/lean/Lean/Util/ForEachExprWhere.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/DefView.lean", "lake-packages/lean4/src/lean/Lean/Elab/ComputedFields.lean", "lake-packages/lean4/src/lean/Lean/Meta/SizeOf.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclUtil.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Lean/Meta/Constructions.lean"], "premises": [{"full_name": "Lean.Elab.Command.checkValidInductiveModifier", "code": "def checkValidInductiveModifier [Monad m] [MonadError m] (modifiers : Modifiers) : m Unit := do\n  if modifiers.isNoncomputable then\n    throwError \"invalid use of 'noncomputable' in inductive declaration\"\n  if modifiers.isPartial then\n    throwError \"invalid use of 'partial' in inductive declaration\"", "start": [27, 1], "end": [31, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkValidCtorModifier", "code": "def checkValidCtorModifier [Monad m] [MonadError m] (modifiers : Modifiers) : m Unit := do\n  if modifiers.isNoncomputable then\n    throwError \"invalid use of 'noncomputable' in constructor declaration\"\n  if modifiers.isPartial then\n    throwError \"invalid use of 'partial' in constructor declaration\"\n  if modifiers.isUnsafe then\n    throwError \"invalid use of 'unsafe' in constructor declaration\"\n  if modifiers.attrs.size != 0 then\n    throwError \"invalid use of attributes in constructor declaration\"", "start": [33, 1], "end": [41, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.CtorView", "code": "structure CtorView where\n  ref       : Syntax\n  modifiers : Modifiers\n  declName  : Name\n  binders   : Syntax\n  type?     : Option Syntax\n  deriving Inhabited", "start": [43, 1], "end": [49, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.ComputedFieldView", "code": "structure ComputedFieldView where\n  ref       : Syntax\n  modifiers : Syntax\n  fieldId   : Name\n  type      : Syntax.Term\n  matchAlts : TSyntax ``Parser.Term.matchAlts", "start": [51, 1], "end": [56, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.InductiveView", "code": "structure InductiveView where\n  ref             : Syntax\n  declId          : Syntax\n  modifiers       : Modifiers\n  shortDeclName   : Name\n  declName        : Name\n  levelNames      : List Name\n  binders         : Syntax\n  type?           : Option Syntax\n  ctors           : Array CtorView\n  derivingClasses : Array DerivingClassView\n  computedFields  : Array ComputedFieldView\n  deriving Inhabited", "start": [58, 1], "end": [70, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.ElabHeaderResult", "code": "structure ElabHeaderResult where\n  view       : InductiveView\n  lctx       : LocalContext\n  localInsts : LocalInstances\n  params     : Array Expr\n  type       : Expr\n  deriving Inhabited", "start": [72, 1], "end": [78, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabHeaderAux", "code": "private partial def elabHeaderAux (views : Array InductiveView) (i : Nat) (acc : Array ElabHeaderResult) : TermElabM (Array ElabHeaderResult) :=\n  Term.withAutoBoundImplicitForbiddenPred (fun n => views.any (\u00b7.shortDeclName == n)) do\n    if h : i < views.size then\n      let view := views.get \u27e8i, h\u27e9\n      let acc \u2190 Term.withAutoBoundImplicit <| Term.elabBinders view.binders.getArgs fun params => do\n        match view.type? with\n        | none         =>\n          let u \u2190 mkFreshLevelMVar\n          let type := mkSort u\n          Term.synthesizeSyntheticMVarsNoPostponing\n          Term.addAutoBoundImplicits' params type fun params type => do\n            return acc.push { lctx := (\u2190 getLCtx), localInsts := (\u2190 getLocalInstances), params, type, view }\n        | some typeStx =>\n          let (type, _) \u2190 Term.withAutoBoundImplicit do\n            let type \u2190 Term.elabType typeStx\n            unless (\u2190 isTypeFormerType type) do\n              throwErrorAt typeStx \"invalid inductive type, resultant type is not a sort\"\n            Term.synthesizeSyntheticMVarsNoPostponing\n            let indices \u2190 Term.addAutoBoundImplicits #[]\n            return (\u2190 mkForallFVars indices type, indices.size)\n          Term.addAutoBoundImplicits' params type fun params type => do\n            trace[Elab.inductive] \"header params: {params}, type: {type}\"\n            return acc.push { lctx := (\u2190 getLCtx), localInsts := (\u2190 getLocalInstances), params, type, view }\n      elabHeaderAux views (i+1) acc\n    else\n      return acc", "start": [80, 1], "end": [105, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkNumParams", "code": "private def checkNumParams (rs : Array ElabHeaderResult) : TermElabM Nat := do\n  let numParams := rs[0]!.params.size\n  for r in rs do\n    unless r.params.size == numParams do\n      throwErrorAt r.view.ref \"invalid inductive type, number of parameters mismatch in mutually inductive datatypes\"\n  return numParams", "start": [107, 1], "end": [112, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkUnsafe", "code": "private def checkUnsafe (rs : Array ElabHeaderResult) : TermElabM Unit := do\n  let isUnsafe := rs[0]!.view.modifiers.isUnsafe\n  for r in rs do\n    unless r.view.modifiers.isUnsafe == isUnsafe do\n      throwErrorAt r.view.ref \"invalid inductive type, cannot mix unsafe and safe declarations in a mutually inductive datatypes\"", "start": [114, 1], "end": [118, 130], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkLevelNames", "code": "private def checkLevelNames (views : Array InductiveView) : TermElabM Unit := do\n  if views.size > 1 then\n    let levelNames := views[0]!.levelNames\n    for view in views do\n      unless view.levelNames == levelNames do\n        throwErrorAt view.ref \"invalid inductive type, universe parameters mismatch in mutually inductive datatypes\"", "start": [120, 1], "end": [125, 117], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkTypeFor", "code": "private def mkTypeFor (r : ElabHeaderResult) : TermElabM Expr := do\n  withLCtx r.lctx r.localInsts do\n    mkForallFVars r.params r.type", "start": [127, 1], "end": [129, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.throwUnexpectedInductiveType", "code": "private def throwUnexpectedInductiveType : TermElabM \u03b1 :=\n  throwError \"unexpected inductive resulting type\"", "start": [131, 1], "end": [132, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.eqvFirstTypeResult", "code": "private def eqvFirstTypeResult (firstType type : Expr) : MetaM Bool :=\n  forallTelescopeReducing firstType fun _ firstTypeResult => isDefEq firstTypeResult type", "start": [134, 1], "end": [135, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkParamsAndResultType", "code": "private partial def checkParamsAndResultType (type firstType : Expr) (numParams : Nat) : TermElabM Unit := do\n  try\n    forallTelescopeCompatible type firstType numParams fun _ type firstType =>\n    forallTelescopeReducing type fun _ type =>\n    forallTelescopeReducing firstType fun _ firstType => do\n      let type \u2190 whnfD type\n      match type with\n      | .sort .. =>\n        unless (\u2190 isDefEq firstType type) do\n          throwError \"resulting universe mismatch, given{indentExpr type}\\nexpected type{indentExpr firstType}\"\n      | _ =>\n        throwError \"unexpected inductive resulting type\"\n  catch\n    | Exception.error ref msg => throw (Exception.error ref m!\"invalid mutually inductive types, {msg}\")\n    | ex => throw ex", "start": [138, 1], "end": [152, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkHeader", "code": "private def checkHeader (r : ElabHeaderResult) (numParams : Nat) (firstType? : Option Expr) : TermElabM Expr := do\n  let type \u2190 mkTypeFor r\n  match firstType? with\n  | none           => return type\n  | some firstType =>\n    withRef r.view.ref <| checkParamsAndResultType type firstType numParams\n    return firstType", "start": [155, 1], "end": [161, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkHeaders", "code": "private partial def checkHeaders (rs : Array ElabHeaderResult) (numParams : Nat) (i : Nat) (firstType? : Option Expr) : TermElabM Unit := do\n  if i < rs.size then\n    let type \u2190 checkHeader rs[i]! numParams firstType?\n    checkHeaders rs numParams (i+1) type", "start": [164, 1], "end": [167, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabHeader", "code": "private def elabHeader (views : Array InductiveView) : TermElabM (Array ElabHeaderResult) := do\n  let rs \u2190 elabHeaderAux views 0 #[]\n  if rs.size > 1 then\n    checkUnsafe rs\n    let numParams \u2190 checkNumParams rs\n    checkHeaders rs numParams 0 none\n  return rs", "start": [169, 1], "end": [175, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withInductiveLocalDecls", "code": "private partial def withInductiveLocalDecls (rs : Array ElabHeaderResult) (x : Array Expr \u2192 Array Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  let namesAndTypes \u2190 rs.mapM fun r => do\n    let type \u2190 mkTypeFor r\n    pure (r.view.declName, r.view.shortDeclName, type)\n  let r0     := rs[0]!\n  let params := r0.params\n  withLCtx r0.lctx r0.localInsts <| withRef r0.view.ref do\n    let rec loop (i : Nat) (indFVars : Array Expr) := do\n      if h : i < namesAndTypes.size then\n        let (declName, shortDeclName, type) := namesAndTypes.get \u27e8i, h\u27e9\n        Term.withAuxDecl shortDeclName type declName fun indFVar => loop (i+1) (indFVars.push indFVar)\n      else\n        x params indFVars\n    loop 0 #[]", "start": [177, 1], "end": [195, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.isInductiveFamily", "code": "private def isInductiveFamily (numParams : Nat) (indFVar : Expr) : TermElabM Bool := do\n  let indFVarType \u2190 inferType indFVar\n  forallTelescopeReducing indFVarType fun xs _ =>\n    return xs.size > numParams", "start": [197, 1], "end": [200, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getArrowBinderNames", "code": "private def getArrowBinderNames (type : Expr) : Array Name :=\n  go type #[]\nwhere\n  go (type : Expr) (acc : Array Name) : Array Name :=\n    match type with\n    | .forallE n _ b _ => go b (acc.push n)\n    | .mdata _ b       => go b acc\n    | _ => acc", "start": [202, 1], "end": [209, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.replaceArrowBinderNames", "code": "private def replaceArrowBinderNames (type : Expr) (newNames : Array Name) : Expr :=\n  go type 0\nwhere\n  go (type : Expr) (i : Nat) : Expr :=\n    if i < newNames.size then\n      match type with\n      | .forallE n d b bi =>\n        if n.hasMacroScopes then\n          mkForall newNames[i]! bi d (go b (i+1))\n        else\n          mkForall n bi d (go b (i+1))\n      | _ => type\n    else\n      type", "start": [211, 1], "end": [228, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.reorderCtorArgs", "code": "private def reorderCtorArgs (ctorType : Expr) : MetaM Expr := do\n  forallTelescopeReducing ctorType fun as type => do\n    \n    let bs := type.getAppArgs\n    let mut as  := as\n    let mut bsPrefix := #[]\n    for b in bs do\n      unless b.isFVar && as.contains b do\n        break\n      let localDecl \u2190 getFVarLocalDecl b\n      if localDecl.binderInfo.isExplicit then\n        break\n      unless localDecl.userName.hasMacroScopes do\n        break\n      if (\u2190 localDeclDependsOnPred localDecl fun fvarId => as.any fun p => p.fvarId! == fvarId) then\n        break\n      bsPrefix := bsPrefix.push b\n      as := as.erase b\n    if bsPrefix.isEmpty then\n      return ctorType\n    else\n      let r \u2190 mkForallFVars (bsPrefix ++ as) type\n      \n      let C := type.getAppFn\n      let binderNames := getArrowBinderNames (\u2190 instantiateMVars (\u2190 inferType C))\n      return replaceArrowBinderNames r binderNames[:bsPrefix.size]", "start": [230, 1], "end": [287, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withExplicitToImplicit", "code": "private def withExplicitToImplicit (xs : Array Expr) (k : TermElabM \u03b1) : TermElabM \u03b1 := do\n  let mut toImplicit := #[]\n  for x in xs do\n    if (\u2190 getFVarLocalDecl x).binderInfo.isExplicit then\n      toImplicit := toImplicit.push (x.fvarId!, BinderInfo.implicit)\n  withNewBinderInfos toImplicit k", "start": [289, 1], "end": [297, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabCtors", "code": "private def elabCtors (indFVars : Array Expr) (indFVar : Expr) (params : Array Expr) (r : ElabHeaderResult) : TermElabM (List Constructor) := withRef r.view.ref do\n  let indFamily \u2190 isInductiveFamily params.size indFVar\n  r.view.ctors.toList.mapM fun ctorView =>\n    Term.withAutoBoundImplicit <| Term.elabBinders ctorView.binders.getArgs fun ctorParams =>\n      withRef ctorView.ref do\n        let rec elabCtorType (k : Expr \u2192 TermElabM Constructor) : TermElabM Constructor := do\n          match ctorView.type? with\n          | none          =>\n            if indFamily then\n              throwError \"constructor resulting type must be specified in inductive family declaration\"\n            k <| mkAppN indFVar params\n          | some ctorType =>\n            let type \u2190 Term.elabType ctorType\n            trace[Elab.inductive] \"elabType {ctorView.declName} : {type} \"\n            Term.synthesizeSyntheticMVars (mayPostpone := true)\n            let type \u2190 instantiateMVars type\n            let type \u2190 checkParamOccs type\n            forallTelescopeReducing type fun _ resultingType => do\n              unless resultingType.getAppFn == indFVar do\n                throwError \"unexpected constructor resulting type{indentExpr resultingType}\"\n              unless (\u2190 isType resultingType) do\n                throwError \"unexpected constructor resulting type, type expected{indentExpr resultingType}\"\n            k type\n        elabCtorType fun type => do\n          Term.synthesizeSyntheticMVarsNoPostponing\n          let ctorParams \u2190 Term.addAutoBoundImplicits ctorParams\n          let except (mvarId : MVarId) := ctorParams.any fun ctorParam => ctorParam.isMVar && ctorParam.mvarId! == mvarId\n          \n          let extraCtorParams \u2190 Term.collectUnassignedMVars (\u2190 instantiateMVars type) #[] except\n          trace[Elab.inductive] \"extraCtorParams: {extraCtorParams}\"\n          \n          let type  \u2190 mkForallFVars (extraCtorParams ++ ctorParams) type\n          let type \u2190 reorderCtorArgs type\n          let type \u2190 mkForallFVars params type\n          trace[Elab.inductive] \"{ctorView.declName} : {type}\"\n          return { name := ctorView.declName, type }\nwhere\n  checkParamOccs (ctorType : Expr) : MetaM Expr :=\n    let visit (e : Expr) : MetaM TransformStep := do\n      let f := e.getAppFn\n      if indFVars.contains f then\n        let mut args := e.getAppArgs\n        unless args.size \u2265 params.size do\n          throwError \"unexpected inductive type occurrence{indentExpr e}\"\n        for i in [:params.size] do\n          let param := params[i]!\n          let arg := args[i]!\n          unless (\u2190 isDefEq param arg) do\n            throwError \"inductive datatype parameter mismatch{indentExpr arg}\\nexpected{indentExpr param}\"\n          args := args.set! i param\n        return TransformStep.done (mkAppN f args)\n      else\n        return .continue\n    transform ctorType (pre := visit)", "start": [299, 1], "end": [383, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getResultingUniverse", "code": "private def getResultingUniverse : List InductiveType \u2192 TermElabM Level\n  | []           => throwError \"unexpected empty inductive declaration\"\n  | indType :: _ => forallTelescopeReducing indType.type fun _ r => do\n    let r \u2190 whnfD r\n    match r with\n    | Expr.sort u => return u\n    | _           => throwError \"unexpected inductive type resulting type{indentExpr r}\"", "start": [385, 1], "end": [391, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.shouldInferResultUniverse", "code": "def shouldInferResultUniverse (u : Level) : TermElabM (Option LMVarId) := do\n  let u \u2190 instantiateLevelMVars u\n  if u.hasMVar then\n    match u.getLevelOffset with\n    | Level.mvar mvarId => return some mvarId\n    | _ =>\n      throwError \"cannot infer resulting universe level of inductive datatype, given level contains metavariables {mkSort u}, provide universe explicitly\"\n  else\n    return none", "start": [393, 1], "end": [405, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.levelMVarToParam", "code": "private def levelMVarToParam (indTypes : List InductiveType) (univToInfer? : Option LMVarId) : TermElabM (List InductiveType) :=\n  indTypes.mapM fun indType => do\n    let type  \u2190 levelMVarToParam' indType.type\n    let ctors \u2190 indType.ctors.mapM fun ctor => do\n      let ctorType \u2190 levelMVarToParam' ctor.type\n      return { ctor with type := ctorType }\n    return { indType with ctors, type }\nwhere\n  levelMVarToParam' (type : Expr) : TermElabM Expr := do\n    Term.levelMVarToParam type (except := fun mvarId => univToInfer? == some mvarId)", "start": [407, 1], "end": [420, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkResultUniverse", "code": "def mkResultUniverse (us : Array Level) (rOffset : Nat) : Level :=\n  if us.isEmpty && rOffset == 0 then\n    levelOne\n  else\n    let r := Level.mkNaryMax us.toList\n    if rOffset == 0 && !r.isZero && !r.isNeverZero then\n      mkLevelMax r levelOne |>.normalize\n    else\n      r.normalize", "start": [422, 1], "end": [430, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.accLevel", "code": "def accLevel (u : Level) (r : Level) (rOffset : Nat) : OptionT (StateT (Array Level) Id) Unit := do\n  go u rOffset\nwhere\n  go (u : Level) (rOffset : Nat) : OptionT (StateT (Array Level) Id) Unit := do\n    match u, rOffset with\n    | .max u v,  rOffset   => go u rOffset; go v rOffset\n    | .imax u v, rOffset   => go u rOffset; go v rOffset\n    | .zero,     _         => return ()\n    | .succ u,   rOffset+1 => go u rOffset\n    | u,         rOffset   =>\n      if rOffset == 0 && u == r then\n        return ()\n      else if r.occurs u  then\n        failure\n      else if rOffset > 0 then\n        failure\n      else if (\u2190 get).contains u then\n        return ()\n      else\n        modify fun us => us.push u", "start": [432, 2], "end": [462, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.accLevelAtCtor", "code": "def accLevelAtCtor (ctor : Constructor) (ctorParam : Expr) (r : Level) (rOffset : Nat) : StateRefT (Array Level) TermElabM Unit := do\n  let type \u2190 inferType ctorParam\n  let u \u2190 instantiateLevelMVars (\u2190 getLevel type)\n  match (\u2190 modifyGet fun s => accLevel u r rOffset |>.run |>.run s) with\n  | some _ => pure ()\n  | none =>\n    let typeType \u2190 inferType type\n    let mut msg := m!\"failed to compute resulting universe level of inductive datatype, constructor '{ctor.name}' has type{indentExpr ctor.type}\\nparameter\"\n    let localDecl \u2190 getFVarLocalDecl ctorParam\n    unless localDecl.userName.hasMacroScopes do\n      msg := msg ++ m!\" '{ctorParam}'\"\n    msg := msg ++ m!\" has type{indentD m!\"{type} : {typeType}\"}\\ninductive type resulting type{indentExpr (mkSort (r.addOffset rOffset))}\"\n    if r.isMVar then\n      msg := msg ++ \"\\nrecall that Lean only infers the resulting universe level automatically when there is a unique solution for the universe level constraints, consider explicitly providing the inductive type resulting universe level\"\n    throwError msg", "start": [464, 1], "end": [485, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withCtorRef", "code": "def withCtorRef [Monad m] [MonadRef m] (views : Array InductiveView) (ctorName : Name) (k : m \u03b1) : m \u03b1 := do\n  for view in views do\n    for ctorView in view.ctors do\n      if ctorView.declName == ctorName then\n        return (\u2190 withRef ctorView.ref k)\n  k", "start": [487, 1], "end": [495, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.collectUniverses", "code": "private partial def collectUniverses (views : Array InductiveView) (r : Level) (rOffset : Nat) (numParams : Nat) (indTypes : List InductiveType) : TermElabM (Array Level) := do\n  let (_, us) \u2190 go |>.run #[]\n  return us\nwhere\n  go : StateRefT (Array Level) TermElabM Unit :=\n    indTypes.forM fun indType => indType.ctors.forM fun ctor =>\n      withCtorRef views ctor.name do\n        forallTelescopeReducing ctor.type fun ctorParams _ =>\n          for ctorParam in ctorParams[numParams:] do\n            accLevelAtCtor ctor ctorParam r rOffset", "start": [497, 1], "end": [507, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.updateResultingUniverse", "code": "private def updateResultingUniverse (views : Array InductiveView) (numParams : Nat) (indTypes : List InductiveType) : TermElabM (List InductiveType) := do\n  let r \u2190 getResultingUniverse indTypes\n  let rOffset : Nat   := r.getOffset\n  let r       : Level := r.getLevelOffset\n  unless r.isMVar do\n    throwError \"failed to compute resulting universe level of inductive datatype, provide universe explicitly: {r}\"\n  let us \u2190 collectUniverses views r rOffset numParams indTypes\n  trace[Elab.inductive] \"updateResultingUniverse us: {us}, r: {r}, rOffset: {rOffset}\"\n  let rNew := mkResultUniverse us rOffset\n  assignLevelMVar r.mvarId! rNew\n  indTypes.mapM fun indType => do\n    let type \u2190 instantiateMVars indType.type\n    let ctors \u2190 indType.ctors.mapM fun ctor => return { ctor with type := (\u2190 instantiateMVars ctor.type) }\n    return { indType with type, ctors }", "start": [509, 1], "end": [522, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkResultingUniverse", "code": "def checkResultingUniverse (u : Level) : TermElabM Unit := do\n  if bootstrap.inductiveCheckResultingUniverse.get (\u2190 getOptions) then\n    let u \u2190 instantiateLevelMVars u\n    if !u.isZero && !u.isNeverZero then\n      throwError \"invalid universe polymorphic type, the resultant universe is not Prop (i.e., 0), but it may be Prop for some parameter values (solution: use 'u+1' or 'max 1 u'{indentD u}\"", "start": [530, 1], "end": [534, 190], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkResultingUniverses", "code": "private def checkResultingUniverses (views : Array InductiveView) (numParams : Nat) (indTypes : List InductiveType) : TermElabM Unit := do\n  let u := (\u2190 instantiateLevelMVars (\u2190 getResultingUniverse indTypes)).normalize\n  checkResultingUniverse u\n  unless u.isZero do\n    indTypes.forM fun indType => indType.ctors.forM fun ctor =>\n      forallTelescopeReducing ctor.type fun ctorArgs _ => do\n        for ctorArg in ctorArgs[numParams:] do\n          let type \u2190 inferType ctorArg\n          let v := (\u2190 instantiateLevelMVars (\u2190 getLevel type)).normalize\n          let rec check (v' : Level) (u' : Level) : TermElabM Unit :=\n            match v', u' with\n            | .succ v', .succ u' => check v' u'\n            | .mvar id, .param ..  =>\n              \n              assignLevelMVar id u'\n            | .mvar id, .zero => assignLevelMVar id u' | _, _ =>\n              unless u.geq v do\n                let mut msg := m!\"invalid universe level in constructor '{ctor.name}', parameter\"\n                let localDecl \u2190 getFVarLocalDecl ctorArg\n                unless localDecl.userName.hasMacroScopes do\n                  msg := msg ++ m!\" '{ctorArg}'\"\n                msg := msg ++ m!\" has type{indentExpr type}\"\n                msg := msg ++ m!\"\\nat universe level{indentD v}\"\n                msg := msg ++ m!\"\\nit must be smaller than or equal to the inductive datatype universe level{indentD u}\"\n                withCtorRef views ctor.name <| throwError msg\n          check v u", "start": [536, 1], "end": [575, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.collectUsed", "code": "private def collectUsed (indTypes : List InductiveType) : StateRefT CollectFVars.State MetaM Unit := do\n  indTypes.forM fun indType => do\n    indType.type.collectFVars\n    indType.ctors.forM fun ctor =>\n      ctor.type.collectFVars", "start": [577, 1], "end": [581, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.removeUnused", "code": "private def removeUnused (vars : Array Expr) (indTypes : List InductiveType) : TermElabM (LocalContext \u00d7 LocalInstances \u00d7 Array Expr) := do\n  let (_, used) \u2190 (collectUsed indTypes).run {}\n  Meta.removeUnused vars used", "start": [583, 1], "end": [585, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withUsed", "code": "private def withUsed {\u03b1} (vars : Array Expr) (indTypes : List InductiveType) (k : Array Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  let (lctx, localInsts, vars) \u2190 removeUnused vars indTypes\n  withLCtx lctx localInsts <| k vars", "start": [587, 1], "end": [589, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.updateParams", "code": "private def updateParams (vars : Array Expr) (indTypes : List InductiveType) : TermElabM (List InductiveType) :=\n  indTypes.mapM fun indType => do\n    let type \u2190 mkForallFVars vars indType.type\n    let ctors \u2190 indType.ctors.mapM fun ctor => do\n      let ctorType \u2190 withExplicitToImplicit vars (mkForallFVars vars ctor.type)\n      return { ctor with type := ctorType }\n    return { indType with type, ctors }", "start": [591, 1], "end": [597, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.collectLevelParamsInInductive", "code": "private def collectLevelParamsInInductive (indTypes : List InductiveType) : Array Name := Id.run do\n  let mut usedParams : CollectLevelParams.State := {}\n  for indType in indTypes do\n    usedParams := collectLevelParams usedParams indType.type\n    for ctor in indType.ctors do\n      usedParams := collectLevelParams usedParams ctor.type\n  return usedParams.params", "start": [599, 1], "end": [605, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkIndFVar2Const", "code": "private def mkIndFVar2Const (views : Array InductiveView) (indFVars : Array Expr) (levelNames : List Name) : ExprMap Expr := Id.run do\n  let levelParams := levelNames.map mkLevelParam;\n  let mut m : ExprMap Expr := {}\n  for i in [:views.size] do\n    let view    := views[i]!\n    let indFVar := indFVars[i]!\n    m := m.insert indFVar (mkConst view.declName levelParams)\n  return m", "start": [607, 1], "end": [614, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.replaceIndFVarsWithConsts", "code": "private def replaceIndFVarsWithConsts (views : Array InductiveView) (indFVars : Array Expr) (levelNames : List Name)\n    (numVars : Nat) (numParams : Nat) (indTypes : List InductiveType) : TermElabM (List InductiveType) :=\n  let indFVar2Const := mkIndFVar2Const views indFVars levelNames\n  indTypes.mapM fun indType => do\n    let ctors \u2190 indType.ctors.mapM fun ctor => do\n      let type \u2190 forallBoundedTelescope ctor.type numParams fun params type => do\n        let type := type.replace fun e =>\n          if !e.isFVar then\n            none\n          else match indFVar2Const.find? e with\n            | none   => none\n            | some c => mkAppN c (params.extract 0 numVars)\n        instantiateMVars (\u2190 mkForallFVars params type)\n      return { ctor with type }\n    return { indType with ctors }", "start": [616, 1], "end": [632, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkAuxConstructions", "code": "private def mkAuxConstructions (views : Array InductiveView) : TermElabM Unit := do\n  let env \u2190 getEnv\n  let hasEq   := env.contains ``Eq\n  let hasHEq  := env.contains ``HEq\n  let hasUnit := env.contains ``PUnit\n  let hasProd := env.contains ``Prod\n  for view in views do\n    let n := view.declName\n    mkRecOn n\n    if hasUnit then mkCasesOn n\n    if hasUnit && hasEq && hasHEq then mkNoConfusion n\n    if hasUnit && hasProd then mkBelow n\n    if hasUnit && hasProd then mkIBelow n\n  for view in views do\n    let n := view.declName;\n    if hasUnit && hasProd then mkBRecOn n\n    if hasUnit && hasProd then mkBInductionOn n", "start": [634, 1], "end": [650, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getArity", "code": "private def getArity (indType : InductiveType) : MetaM Nat :=\n  forallTelescopeReducing indType.type fun xs _ => return xs.size", "start": [652, 1], "end": [653, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.resetMaskAt", "code": "private def resetMaskAt (mask : Array Bool) (i : Nat) : Array Bool :=\n  if h : i < mask.size then\n    mask.set \u27e8i, h\u27e9 false\n  else\n    mask", "start": [655, 1], "end": [659, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.computeFixedIndexBitMask", "code": "private def computeFixedIndexBitMask (numParams : Nat) (indType : InductiveType) (indFVars : Array Expr) : MetaM (Array Bool) := do\n  let arity \u2190 getArity indType\n  if arity \u2264 numParams then\n    return mkArray arity false\n  else\n    let maskRef \u2190 IO.mkRef (mkArray numParams false ++ mkArray (arity - numParams) true)\n    let rec go (ctors : List Constructor) : MetaM (Array Bool) := do\n      match ctors with\n      | [] => maskRef.get\n      | ctor :: ctors =>\n        forallTelescopeReducing ctor.type fun xs type => do\n          let typeArgs := type.getAppArgs\n          for i in [numParams:arity] do\n            unless i < xs.size && xs[i]! == typeArgs[i]! do maskRef.modify fun mask => mask.set! i false\n          for x in xs[numParams:] do\n            let xType \u2190 inferType x\n            let cond (e : Expr) := indFVars.any (fun indFVar => e.getAppFn == indFVar) && e.getAppNumArgs > numParams\n            xType.forEachWhere cond fun e => do\n              let eArgs := e.getAppArgs\n              for i in [numParams:eArgs.size] do\n                if i >= typeArgs.size then\n                  maskRef.modify (resetMaskAt \u00b7 i)\n                else\n                  unless eArgs[i]! == typeArgs[i]! do\n                    maskRef.modify (resetMaskAt \u00b7 i)\n        go ctors\n    go indType.ctors", "start": [661, 1], "end": [693, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.isDomainDefEq", "code": "private def isDomainDefEq (arrowType : Expr) (type : Expr) : MetaM Bool := do\n  if !arrowType.isForall then\n    return false\n  else\n    \n    isDefEq arrowType.bindingDomain! type", "start": [695, 1], "end": [710, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.fixedIndicesToParams", "code": "private partial def fixedIndicesToParams (numParams : Nat) (indTypes : Array InductiveType) (indFVars : Array Expr) : MetaM Nat := do\n  let masks \u2190 indTypes.mapM (computeFixedIndexBitMask numParams \u00b7 indFVars)\n  if masks.all fun mask => !mask.contains true then\n    return numParams\n  trace[Elab.inductive] \"masks: {masks}\"\n  let mask := masks[0]!\n  forallBoundedTelescope indTypes[0]!.type numParams fun params type => do\n    let otherTypes \u2190 indTypes[1:].toArray.mapM fun indType => do whnfD (\u2190 instantiateForall indType.type params)\n    let ctorTypes \u2190 indTypes.toList.mapM fun indType => indType.ctors.mapM fun ctor => do whnfD (\u2190 instantiateForall ctor.type params)\n    let typesToCheck := otherTypes.toList ++ ctorTypes.join\n    let rec go (i : Nat) (type : Expr) (typesToCheck : List Expr) : MetaM Nat := do\n      if i < mask.size then\n        if !masks.all fun mask => i < mask.size && mask[i]! then\n           return i\n        if !type.isForall then\n          return i\n        let paramType := type.bindingDomain!\n        if !(\u2190 typesToCheck.allM fun type => isDomainDefEq type paramType) then\n          trace[Elab.inductive] \"domain not def eq: {i}, {type} =?= {paramType}\"\n          return i\n        withLocalDeclD `a paramType fun paramNew => do\n          let typesToCheck \u2190 typesToCheck.mapM fun type => whnfD (type.bindingBody!.instantiate1 paramNew)\n          go (i+1) (type.bindingBody!.instantiate1 paramNew) typesToCheck\n      else\n        return i\n    go numParams type typesToCheck", "start": [712, 1], "end": [743, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkInductiveDecl", "code": "private def mkInductiveDecl (vars : Array Expr) (views : Array InductiveView) : TermElabM Unit := Term.withoutSavingRecAppSyntax do\n  let view0 := views[0]!\n  let scopeLevelNames \u2190 Term.getLevelNames\n  checkLevelNames views\n  let allUserLevelNames := view0.levelNames\n  let isUnsafe          := view0.modifiers.isUnsafe\n  withRef view0.ref <| Term.withLevelNames allUserLevelNames do\n    let rs \u2190 elabHeader views\n    withInductiveLocalDecls rs fun params indFVars => do\n      trace[Elab.inductive] \"indFVars: {indFVars}\"\n      let mut indTypesArray := #[]\n      for i in [:views.size] do\n        let indFVar := indFVars[i]!\n        Term.addLocalVarInfo views[i]!.declId indFVar\n        let r       := rs[i]!\n        let type  \u2190 mkForallFVars params r.type\n        let ctors \u2190 withExplicitToImplicit params (elabCtors indFVars indFVar params r)\n        indTypesArray := indTypesArray.push { name := r.view.declName, type, ctors }\n      Term.synthesizeSyntheticMVarsNoPostponing\n      let numExplicitParams \u2190 fixedIndicesToParams params.size indTypesArray indFVars\n      trace[Elab.inductive] \"numExplicitParams: {numExplicitParams}\"\n      let indTypes := indTypesArray.toList\n      let u \u2190 getResultingUniverse indTypes\n      let univToInfer? \u2190 shouldInferResultUniverse u\n      withUsed vars indTypes fun vars => do\n        let numVars   := vars.size\n        let numParams := numVars + numExplicitParams\n        let indTypes \u2190 updateParams vars indTypes\n        let indTypes \u2190 if let some univToInfer := univToInfer? then\n          updateResultingUniverse views numParams (\u2190 levelMVarToParam indTypes univToInfer)\n        else\n          checkResultingUniverses views numParams indTypes\n          levelMVarToParam indTypes none\n        let usedLevelNames := collectLevelParamsInInductive indTypes\n        match sortDeclLevelParams scopeLevelNames allUserLevelNames usedLevelNames with\n        | .error msg      => throwError msg\n        | .ok levelParams => do\n          let indTypes \u2190 replaceIndFVarsWithConsts views indFVars levelParams numVars numParams indTypes\n          let decl := Declaration.inductDecl levelParams numParams indTypes isUnsafe\n          Term.ensureNoUnassignedMVars decl\n          addDecl decl\n          mkAuxConstructions views\n    withSaveInfoContext do  for view in views do\n        Term.addTermInfo' view.ref[1] (\u2190 mkConstWithLevelParams view.declName) (isBinder := true)\n        for ctor in view.ctors do\n          Term.addTermInfo' ctor.ref[3] (\u2190 mkConstWithLevelParams ctor.declName) (isBinder := true)\n        Term.applyAttributesAt view.declName view.modifiers.attrs .afterTypeChecking", "start": [745, 1], "end": [793, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.applyDerivingHandlers", "code": "private def applyDerivingHandlers (views : Array InductiveView) : CommandElabM Unit := do\n  let mut processed : NameSet := {}\n  for view in views do\n    for classView in view.derivingClasses do\n      let className := classView.className\n      unless processed.contains className do\n        processed := processed.insert className\n        let mut declNames := #[]\n        for view in views do\n          if view.derivingClasses.any fun classView => classView.className == className then\n            declNames := declNames.push view.declName\n        classView.applyHandlers declNames", "start": [795, 1], "end": [806, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.applyComputedFields", "code": "private def applyComputedFields (indViews : Array InductiveView) : CommandElabM Unit := do\n  if indViews.all (\u00b7.computedFields.isEmpty) then return\n\n  let mut computedFields := #[]\n  let mut computedFieldDefs := #[]\n  for indView@{declName, ..} in indViews do\n    for {ref, fieldId, type, matchAlts, modifiers, ..} in indView.computedFields do\n      computedFieldDefs := computedFieldDefs.push <| \u2190 do\n        let modifiers \u2190 match modifiers with\n          | `(Lean.Parser.Command.declModifiersT| $[$doc:docComment]? $[$attrs:attributes]? $[$vis]? $[noncomputable]?) =>\n            `(Lean.Parser.Command.declModifiersT| $[$doc]? $[$attrs]? $[$vis]? noncomputable)\n          | _ => do\n            withRef modifiers do logError \"unsupported modifiers for computed field\"\n            `(Parser.Command.declModifiersT| noncomputable)\n        `($(\u27e8modifiers\u27e9):declModifiers\n          def%$ref $(mkIdent <| `_root_ ++ declName ++ fieldId):ident : $type $matchAlts:matchAlts)\n    let computedFieldNames := indView.computedFields.map fun {fieldId, ..} => declName ++ fieldId\n    computedFields := computedFields.push (declName, computedFieldNames)\n  withScope (fun scope => { scope with\n      opts := scope.opts\n        |>.setBool `bootstrap.genMatcherCode false\n        |>.setBool `elaboratingComputedFields true}) <|\n    elabCommand <| \u2190 `(mutual $computedFieldDefs* end)\n\n  liftTermElabM do Term.withDeclName indViews[0]!.declName do\n    ComputedFields.setComputedFields computedFields", "start": [808, 1], "end": [833, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabInductiveViews", "code": "def elabInductiveViews (views : Array InductiveView) : CommandElabM Unit := do\n  let view0 := views[0]!\n  let ref := view0.ref\n  runTermElabM fun vars => Term.withDeclName view0.declName do withRef ref do\n    mkInductiveDecl vars views\n    mkSizeOfInstances view0.declName\n    Lean.Meta.IndPredBelow.mkBelow view0.declName\n    for view in views do\n      mkInjectiveTheorems view.declName\n  applyComputedFields views applyDerivingHandlers views\n  runTermElabM fun _ => Term.withDeclName view0.declName do withRef ref do\n    for view in views do\n      Term.applyAttributesAt view.declName view.modifiers.attrs .afterCompilation", "start": [835, 1], "end": [848, 82], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Main.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/MkInhabitant.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural.lean", "lake-packages/lean4/src/lean/Lean/Util/SCC.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Main.lean"], "premises": [{"full_name": "Lean.Elab.TerminationHints", "code": "structure TerminationHints where\n  terminationBy? : Option Syntax := none\n  decreasingBy? : Option Syntax := none\n  deriving Inhabited", "start": [16, 1], "end": [19, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addAndCompilePartial", "code": "private def addAndCompilePartial (preDefs : Array PreDefinition) (useSorry := false) : TermElabM Unit := do\n  for preDef in preDefs do\n    trace[Elab.definition] \"processing {preDef.declName}\"\n    let all := preDefs.toList.map (\u00b7.declName)\n    forallTelescope preDef.type fun xs type => do\n      let value \u2190 if useSorry then\n        mkLambdaFVars xs (\u2190 mkSorry type (synthetic := true))\n      else\n        liftM <| mkInhabitantFor preDef.declName xs type\n      addNonRec { preDef with\n        kind  := DefKind.\u00abopaque\u00bb\n        value\n      } (all := all)\n  addAndCompilePartialRec preDefs", "start": [21, 1], "end": [34, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.isNonRecursive", "code": "private def isNonRecursive (preDef : PreDefinition) : Bool :=\n  Option.isNone $ preDef.value.find? fun\n    | Expr.const declName _ => preDef.declName == declName\n    | _ => false", "start": [36, 1], "end": [39, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.partitionPreDefs", "code": "private def partitionPreDefs (preDefs : Array PreDefinition) : Array (Array PreDefinition) :=\n  let getPreDef    := fun declName => (preDefs.find? fun preDef => preDef.declName == declName).get!\n  let vertices     := preDefs.toList.map (\u00b7.declName)\n  let successorsOf := fun declName => (getPreDef declName).value.foldConsts [] fun declName successors =>\n    if preDefs.any fun preDef => preDef.declName == declName then\n      declName :: successors\n    else\n      successors\n  let sccs := SCC.scc vertices successorsOf\n  sccs.toArray.map fun scc => scc.toArray.map getPreDef", "start": [41, 1], "end": [50, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.collectMVarsAtPreDef", "code": "private def collectMVarsAtPreDef (preDef : PreDefinition) : StateRefT CollectMVars.State MetaM Unit := do\n  collectMVars preDef.value\n  collectMVars preDef.type", "start": [52, 1], "end": [54, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.getMVarsAtPreDef", "code": "private def getMVarsAtPreDef (preDef : PreDefinition) : MetaM (Array MVarId) := do\n  let (_, s) \u2190 (collectMVarsAtPreDef preDef).run {}\n  pure s.result", "start": [56, 1], "end": [58, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ensureNoUnassignedMVarsAtPreDef", "code": "private def ensureNoUnassignedMVarsAtPreDef (preDef : PreDefinition) : TermElabM PreDefinition := do\n  let pendingMVarIds \u2190 getMVarsAtPreDef preDef\n  if (\u2190 logUnassignedUsingErrorInfos pendingMVarIds) then\n    let preDef := { preDef with value := (\u2190 mkSorry preDef.type (synthetic := true)) }\n    if (\u2190 getMVarsAtPreDef preDef).isEmpty then\n      return preDef\n    else\n      throwAbortCommand\n  else\n    return preDef", "start": [60, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.betaReduceLetRecApps", "code": "private def betaReduceLetRecApps (preDefs : Array PreDefinition) : MetaM (Array PreDefinition) :=\n  preDefs.mapM fun preDef => do\n    let value \u2190 Core.transform preDef.value fun e => do\n      if e.isApp && e.getAppFn.isLambda && e.getAppArgs.all fun arg => arg.getAppFn.isConst && preDefs.any fun preDef => preDef.declName == arg.getAppFn.constName! then\n        return .visit e.headBeta\n      else\n        return .continue\n    return { preDef with value }", "start": [71, 1], "end": [81, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addAsAxioms", "code": "private def addAsAxioms (preDefs : Array PreDefinition) : TermElabM Unit := do\n  for preDef in preDefs do\n    let decl := Declaration.axiomDecl {\n      name        := preDef.declName,\n      levelParams := preDef.levelParams,\n      type        := preDef.type,\n      isUnsafe    := preDef.modifiers.isUnsafe\n    }\n    addDecl decl\n    withSaveInfoContext do  addTermInfo' preDef.ref (\u2190 mkConstWithLevelParams preDef.declName) (isBinder := true)\n    applyAttributesOf #[preDef] AttributeApplicationTime.afterTypeChecking\n    applyAttributesOf #[preDef] AttributeApplicationTime.afterCompilation", "start": [83, 1], "end": [95, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addPreDefinitions", "code": "def addPreDefinitions (preDefs : Array PreDefinition) (hints : TerminationHints) : TermElabM Unit := withLCtx {} {} do\n  for preDef in preDefs do\n    trace[Elab.definition.body] \"{preDef.declName} : {preDef.type} :=\\n{preDef.value}\"\n  let preDefs \u2190 preDefs.mapM ensureNoUnassignedMVarsAtPreDef\n  let preDefs \u2190 betaReduceLetRecApps preDefs\n  let cliques := partitionPreDefs preDefs\n  let mut terminationBy \u2190 liftMacroM <| WF.expandTerminationBy hints.terminationBy? (cliques.map fun ds => ds.map (\u00b7.declName))\n  let mut decreasingBy  \u2190 liftMacroM <| WF.expandTerminationHint hints.decreasingBy? (cliques.map fun ds => ds.map (\u00b7.declName))\n  let mut hasErrors := false\n  for preDefs in cliques do\n    trace[Elab.definition.scc] \"{preDefs.map (\u00b7.declName)}\"\n    if preDefs.size == 1 && isNonRecursive preDefs[0]! then\n      \n      let preDef \u2190 eraseRecAppSyntax preDefs[0]!\n      if preDef.modifiers.isNoncomputable then\n        addNonRec preDef\n      else\n        addAndCompileNonRec preDef\n    else if preDefs.any (\u00b7.modifiers.isUnsafe) then\n      addAndCompileUnsafe preDefs\n    else if preDefs.any (\u00b7.modifiers.isPartial) then\n      for preDef in preDefs do\n        if preDef.modifiers.isPartial && !(\u2190 whnfD preDef.type).isForall then\n          withRef preDef.ref <| throwError \"invalid use of 'partial', '{preDef.declName}' is not a function{indentExpr preDef.type}\"\n      addAndCompilePartial preDefs\n    else\n      try\n        let mut wf? := none\n        let mut decrTactic? := none\n        if let some wf := terminationBy.find? (preDefs.map (\u00b7.declName)) then\n          wf? := some wf\n          terminationBy := terminationBy.markAsUsed (preDefs.map (\u00b7.declName))\n        if let some { ref, value := decrTactic } := decreasingBy.find? (preDefs.map (\u00b7.declName)) then\n          decrTactic? := some (\u2190 withRef ref `(by $(\u27e8decrTactic\u27e9)))\n          decreasingBy := decreasingBy.markAsUsed (preDefs.map (\u00b7.declName))\n        if wf?.isSome || decrTactic?.isSome then\n          wfRecursion preDefs wf? decrTactic?\n        else\n          withRef (preDefs[0]!.ref) <| mapError\n            (orelseMergeErrors\n              (structuralRecursion preDefs)\n              (wfRecursion preDefs none none))\n            (fun msg =>\n              let preDefMsgs := preDefs.toList.map (MessageData.ofExpr $ mkConst \u00b7.declName)\n              m!\"fail to show termination for{indentD (MessageData.joinSep preDefMsgs Format.line)}\\nwith errors\\n{msg}\")\n      catch ex =>\n        hasErrors := true\n        logException ex\n        let s \u2190 saveState\n        try\n          if preDefs.all fun preDef => preDef.kind == DefKind.def || preDefs.all fun preDef => preDef.kind == DefKind.abbrev then\n            try\n              addAndCompilePartial preDefs (useSorry := true)\n            catch _ =>\n              s.restore\n              addAsAxioms preDefs\n          else if preDefs.all fun preDef => preDef.kind == DefKind.theorem then\n            addAsAxioms preDefs\n        catch _ => s.restore\n  unless hasErrors do\n    liftMacroM <| terminationBy.ensureAllUsed\n    liftMacroM <| decreasingBy.ensureAllUsed", "start": [97, 1], "end": [164, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Calc.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/App.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.getCalcRelation?", "code": "def getCalcRelation? (e : Expr) : MetaM (Option (Expr \u00d7 Expr \u00d7 Expr)) :=\n  if e.getAppNumArgs < 2 then\n    return none\n  else\n    return some (e.appFn!.appFn!, e.appFn!.appArg!, e.appArg!)", "start": [11, 1], "end": [19, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getRelUniv", "code": "private def getRelUniv (r : Expr) : MetaM Level := do\n  let rType \u2190 inferType r\n  forallTelescopeReducing rType fun _ sort => do\n    let .sort u \u2190 whnf sort | throwError \"unexpected relation type{indentExpr rType}\"\n    return u", "start": [21, 1], "end": [25, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkCalcTrans", "code": "def mkCalcTrans (result resultType step stepType : Expr) : MetaM (Expr \u00d7 Expr) := do\n  let some (r, a, b) \u2190 getCalcRelation? resultType | unreachable!\n  let some (s, _, c) \u2190 getCalcRelation? (\u2190 instantiateMVars stepType) | unreachable!\n  let u \u2190 getRelUniv r\n  let v \u2190 getRelUniv s\n  let (\u03b1, \u03b2, \u03b3)       := (\u2190 inferType a, \u2190 inferType b, \u2190 inferType c)\n  let (u_1, u_2, u_3) := (\u2190 getLevel \u03b1, \u2190 getLevel \u03b2, \u2190 getLevel \u03b3)\n  let w \u2190 mkFreshLevelMVar\n  let t \u2190 mkFreshExprMVar (\u2190 mkArrow \u03b1 (\u2190 mkArrow \u03b3 (mkSort w)))\n  let selfType := mkAppN (Lean.mkConst ``Trans [u, v, w, u_1, u_2, u_3]) #[\u03b1, \u03b2, \u03b3, r, s, t]\n  match (\u2190 trySynthInstance selfType) with\n  | .some self =>\n    let result := mkAppN (Lean.mkConst ``Trans.trans [u, v, w, u_1, u_2, u_3]) #[\u03b1, \u03b2, \u03b3, r, s, t, self, a, b, c, result, step]\n    let resultType := (\u2190 instantiateMVars (\u2190 inferType result)).headBeta\n    unless (\u2190 getCalcRelation? resultType).isSome do\n      throwError \"invalid 'calc' step, step result is not a relation{indentExpr resultType}\"\n    return (result, resultType)\n  | _ => throwError \"invalid 'calc' step, failed to synthesize `Trans` instance{indentExpr selfType}\"", "start": [27, 1], "end": [44, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.annotateFirstHoleWithType", "code": "partial def annotateFirstHoleWithType (t : Term) (type : Expr) : TermElabM Term :=\n  return \u27e8\u2190 StateT.run' (go t) true\u27e9\nwhere\n  go (t : Syntax) := do\n    unless \u2190 get do return t\n    match t with\n    | .node _ ``Lean.Parser.Term.hole _ =>\n      set false\n      `(($(\u27e8t\u27e9) : $(\u2190 exprToSyntax type)))\n    | .node i k as => return .node i k (\u2190 as.mapM go)\n    | _ => set false; return t", "start": [46, 1], "end": [68, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getCalcFirstStep", "code": "def getCalcFirstStep (step0 : TSyntax ``calcFirstStep) : TermElabM (TSyntax ``calcStep) :=\n  withRef step0 do\n  match step0  with\n  | `(calcFirstStep| $term:term) =>\n    `(calcStep| $term = _ := rfl)\n  | `(calcFirstStep| $term := $proof) =>\n    `(calcStep| $term := $proof)\n  | _ => throwUnsupportedSyntax", "start": [70, 1], "end": [77, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getCalcSteps", "code": "def getCalcSteps (steps : TSyntax ``calcSteps) : TermElabM (Array (TSyntax ``calcStep)) :=\n  match steps with\n  | `(calcSteps|\n        $step0:calcFirstStep\n        $rest*) => do\n    let step0 \u2190 getCalcFirstStep step0\n    pure (#[step0] ++ rest)\n  | _ => unreachable!", "start": [79, 1], "end": [86, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabCalcSteps", "code": "def elabCalcSteps (steps : TSyntax ``calcSteps) : TermElabM Expr := do\n  let mut result? := none\n  let mut prevRhs? := none\n  for step in \u2190 getCalcSteps steps do\n    let `(calcStep| $pred := $proofTerm) := step | unreachable!\n    let type \u2190 elabType <| \u2190 do\n      if let some prevRhs := prevRhs? then\n        annotateFirstHoleWithType pred (\u2190 inferType prevRhs)\n      else\n        pure pred\n    let some (_, lhs, rhs) \u2190 getCalcRelation? type |\n      throwErrorAt pred \"invalid 'calc' step, relation expected{indentExpr type}\"\n    if let some prevRhs := prevRhs? then\n      unless (\u2190 isDefEqGuarded lhs prevRhs) do\n        throwErrorAt pred \"invalid 'calc' step, left-hand-side is{indentD m!\"{lhs} : {\u2190 inferType lhs}\"}\\nprevious right-hand-side is{indentD m!\"{prevRhs} : {\u2190 inferType prevRhs}\"}\" let proof \u2190 withFreshMacroScope do elabTermEnsuringType proofTerm type\n    result? := some <| \u2190 do\n      if let some (result, resultType) := result? then\n        synthesizeSyntheticMVarsUsingDefault\n        withRef pred do mkCalcTrans result resultType proof type\n      else\n        pure (proof, type)\n    prevRhs? := rhs\n  return result?.get!.1", "start": [88, 1], "end": [111, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabCalc", "code": "@[builtin_term_elab \u00abcalc\u00bb]\ndef elabCalc : TermElab := fun stx expectedType? => do\n  let steps : TSyntax ``calcSteps := \u27e8stx[1]\u27e9\n  let result \u2190 elabCalcSteps steps\n  synthesizeSyntheticMVarsUsingDefault\n  let result \u2190 ensureHasType expectedType? result\n  return result", "start": [113, 1], "end": [120, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Congr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Congr.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Conv.congrImplies", "code": "private def congrImplies (mvarId : MVarId) : MetaM (List MVarId) := do\n  let [mvarId\u2081, mvarId\u2082, _, _] \u2190 mvarId.apply (\u2190 mkConstWithFreshMVarLevels ``implies_congr) | throwError \"'apply implies_congr' unexpected result\"\n  let mvarId\u2081 \u2190 markAsConvGoal mvarId\u2081\n  let mvarId\u2082 \u2190 markAsConvGoal mvarId\u2082\n  return [mvarId\u2081, mvarId\u2082]", "start": [13, 1], "end": [17, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.isImplies", "code": "private def isImplies (e : Expr) : MetaM Bool :=\n  if e.isArrow then\n    isProp e.bindingDomain! <&&> isProp e.bindingBody!\n  else\n    return false", "start": [19, 1], "end": [23, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.congr", "code": "def congr (mvarId : MVarId) (addImplicitArgs := false) (nameSubgoals := true) :\n    MetaM (List (Option MVarId)) := mvarId.withContext do\n  let origTag \u2190 mvarId.getTag\n  let (lhs, rhs) \u2190 getLhsRhsCore mvarId\n  let lhs := (\u2190 instantiateMVars lhs).cleanupAnnotations\n  if (\u2190 isImplies lhs) then\n    return (\u2190 congrImplies mvarId).map Option.some\n  else if lhs.isApp then\n    let funInfo \u2190 getFunInfo lhs.getAppFn\n    let args := lhs.getAppArgs\n    let some congrThm \u2190 mkCongrSimp? lhs.getAppFn (subsingletonInstImplicitRhs := false)\n      | throwError \"'congr' conv tactic failed to create congruence theorem\"\n    unless args.size == congrThm.argKinds.size do\n      throwError \"'congr' conv tactic failed, unexpected number of arguments in congruence theorem\"\n    let mut proof := congrThm.proof\n    let mut mvarIdsNew := #[]\n    let mut mvarIdsNewInsts := #[]\n    for i in [:args.size] do\n      let arg := args[i]!\n      let argInfo := funInfo.paramInfo[i]!\n      match congrThm.argKinds[i]! with\n      | .fixed | .cast =>\n        proof := mkApp proof arg;\n        if addImplicitArgs || argInfo.isExplicit then\n          mvarIdsNew := mvarIdsNew.push none\n      | .eq    =>\n        if addImplicitArgs || argInfo.isExplicit then\n          let tag \u2190 if nameSubgoals then\n            pure (appendTag origTag (\u2190 whnf (\u2190 inferType proof)).bindingName!)\n          else pure origTag\n          let (rhs, mvarNew) \u2190 mkConvGoalFor arg tag\n          proof := mkApp3 proof arg rhs mvarNew\n          mvarIdsNew := mvarIdsNew.push (some mvarNew.mvarId!)\n        else\n          proof := mkApp3 proof arg arg (\u2190 mkEqRefl arg)\n      | .subsingletonInst =>\n        proof := mkApp proof arg\n        let rhs \u2190 mkFreshExprMVar (\u2190 whnf (\u2190 inferType proof)).bindingDomain!\n        proof := mkApp proof rhs\n        mvarIdsNewInsts := mvarIdsNewInsts.push (some rhs.mvarId!)\n      | .heq | .fixedNoParam => unreachable!\n    let some (_, _, rhs') := (\u2190 whnf (\u2190 inferType proof)).eq? | throwError \"'congr' conv tactic failed, equality expected\"\n    unless (\u2190 isDefEqGuarded rhs rhs') do\n      throwError \"invalid 'congr' conv tactic, failed to resolve{indentExpr rhs}\\n=?={indentExpr rhs'}\"\n    mvarId.assign proof\n    return mvarIdsNew.toList ++ mvarIdsNewInsts.toList\n  else\n    throwError \"invalid 'congr' conv tactic, application or implication expected{indentExpr lhs}\"", "start": [25, 1], "end": [72, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalCongr", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.congr] def evalCongr : Tactic := fun _ => do\n   replaceMainGoal <| List.filterMap id (\u2190 congr (\u2190 getMainGoal))", "start": [74, 1], "end": [75, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.selectIdx", "code": "private def selectIdx (tacticName : String) (mvarIds : List (Option MVarId)) (i : Int) :\n  TacticM Unit := do\n  if i >= 0 then\n    let i := i.toNat\n    if h : i < mvarIds.length then\n      for mvarId? in mvarIds, j in [:mvarIds.length] do\n        match mvarId? with\n        | none => pure ()\n        | some mvarId =>\n          if i != j then\n            mvarId.refl\n      match mvarIds[i] with\n      | none => throwError \"cannot select argument\"\n      | some mvarId => replaceMainGoal [mvarId]\n      return ()\n  throwError \"invalid '{tacticName}' conv tactic, application has only {mvarIds.length} (nondependent) argument(s)\"", "start": [77, 1], "end": [92, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalSkip", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.skip] def evalSkip : Tactic := fun _ => pure ()", "start": [94, 1], "end": [94, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalLhs", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.lhs] def evalLhs : Tactic := fun _ => do\n   let mvarIds \u2190 congr (\u2190 getMainGoal) (nameSubgoals := false)\n   selectIdx \"lhs\" mvarIds ((mvarIds.length : Int) - 2)", "start": [96, 1], "end": [98, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalRhs", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.rhs] def evalRhs : Tactic := fun _ => do\n   let mvarIds \u2190 congr (\u2190 getMainGoal) (nameSubgoals := false)\n   selectIdx \"rhs\" mvarIds ((mvarIds.length : Int) - 1)", "start": [100, 1], "end": [102, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalArg", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.arg] def evalArg : Tactic := fun stx => do\n   match stx with\n   | `(conv| arg $[@%$tk?]? $i:num) =>\n      let i := i.getNat\n      if i == 0 then\n        throwError \"invalid 'arg' conv tactic, index must be greater than 0\"\n      let i := i - 1\n      let mvarIds \u2190 congr (\u2190 getMainGoal) (addImplicitArgs := tk?.isSome) (nameSubgoals := false)\n      selectIdx \"arg\" mvarIds i\n   | _ => throwUnsupportedSyntax", "start": [104, 1], "end": [113, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.extLetBodyCongr?", "code": "def extLetBodyCongr? (mvarId : MVarId) (lhs rhs : Expr) : MetaM (Option MVarId) := do\n  match lhs with\n  | .letE n t v b _ =>\n    let u\u2081 \u2190 getLevel t\n    let f := mkLambda n .default t b\n    unless (\u2190 isTypeCorrect f) do\n      throwError \"failed to abstract let-expression, result is not type correct\"\n    let (\u03b2, u\u2082, f') \u2190 withLocalDeclD n t fun a => do\n      let type \u2190 inferType (mkApp f a)\n      let \u03b2 \u2190 mkLambdaFVars #[a] type\n      let u\u2082 \u2190 getLevel type\n      let rhsBody \u2190 mkFreshExprMVar type\n      let f' \u2190 mkLambdaFVars #[a] rhsBody\n      let rhs' := mkLet n t v f'.bindingBody!\n      unless (\u2190 isDefEq rhs rhs') do\n        throwError \"failed to go inside let-declaration, type error\"\n      return (\u03b2, u\u2082, f')\n    let (arg, mvarId') \u2190 withLocalDeclD n t fun x => do\n      let eqLhs := f.beta #[x]\n      let eqRhs := f'.beta #[x]\n      let mvarNew \u2190 mkFreshExprSyntheticOpaqueMVar (\u2190 mkEq eqLhs eqRhs)\n      let arg \u2190 mkLambdaFVars #[x] mvarNew\n      return (arg, mvarNew.mvarId!)\n    let val := mkApp6 (mkConst ``let_body_congr [u\u2081, u\u2082]) t \u03b2 f f' v arg\n    mvarId.assign val\n    return some (\u2190 markAsConvGoal mvarId')\n  | _ => return none", "start": [115, 1], "end": [141, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.extCore", "code": "private def extCore (mvarId : MVarId) (userName? : Option Name) : MetaM MVarId :=\n   mvarId.withContext do\n     let (lhs, rhs) \u2190 getLhsRhsCore mvarId\n     let lhs := (\u2190 instantiateMVars lhs).cleanupAnnotations\n     if let .forallE n d b bi := lhs then\n       let u \u2190 getLevel d\n       let p : Expr := .lam n d b bi\n       let userName \u2190 if let some userName := userName? then pure userName else mkFreshBinderNameForTactic n\n       let (q, h, mvarNew) \u2190 withLocalDecl userName bi d fun a => do\n         let pa := b.instantiate1 a\n         let (qa, mvarNew) \u2190 mkConvGoalFor pa\n         let q \u2190 mkLambdaFVars #[a] qa\n         let h \u2190 mkLambdaFVars #[a] mvarNew\n         let rhs' \u2190 mkForallFVars #[a] qa\n         unless (\u2190 isDefEqGuarded rhs rhs') do\n           throwError \"invalid 'ext' conv tactic, failed to resolve{indentExpr rhs}\\n=?={indentExpr rhs'}\"\n         return (q, h, mvarNew)\n       let proof := mkApp4 (mkConst ``forall_congr [u]) d p q h\n       mvarId.assign proof\n       return mvarNew.mvarId!\n     else if let some mvarId \u2190 extLetBodyCongr? mvarId lhs rhs then\n       return mvarId\n     else\n       let lhsType \u2190 whnfD (\u2190 inferType lhs)\n       unless lhsType.isForall do\n         throwError \"invalid 'ext' conv tactic, function or arrow expected{indentD m!\"{lhs} : {lhsType}\"}\"\n       let [mvarId] \u2190 mvarId.apply (\u2190 mkConstWithFreshMVarLevels ``funext) | throwError \"'apply funext' unexpected result\"\n       let userNames := if let some userName := userName? then [userName] else []\n       let (_, mvarId) \u2190 mvarId.introN 1 userNames\n       markAsConvGoal mvarId", "start": [143, 1], "end": [172, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.ext", "code": "private def ext (userName? : Option Name) : TacticM Unit := do\n  replaceMainGoal [\u2190 extCore (\u2190 getMainGoal) userName?]", "start": [174, 1], "end": [175, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalExt", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.ext] def evalExt : Tactic := fun stx => do\n  let ids := stx[1].getArgs\n  if ids.isEmpty then\n    ext none\n  else\n    for id in ids do\n      withRef id <| ext id.getId", "start": [177, 1], "end": [183, 33], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Change.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Conv.evalChange", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.change] def evalChange : Tactic := fun stx => do\n  match stx with\n  | `(conv| change $e) => withMainContext do\n    let lhs \u2190 getLhs\n    let mvarCounterSaved := (\u2190 getMCtx).mvarCounter\n    let r \u2190 elabTermEnsuringType e (\u2190 inferType lhs)\n    logUnassignedAndAbort (\u2190 filterOldMVars (\u2190 getMVars r) mvarCounterSaved)\n    unless (\u2190 isDefEqGuarded r lhs) do\n      throwError \"invalid 'change' conv tactic, term{indentExpr r}\\nis not definitionally equal to current left-hand-side{indentExpr lhs}\"\n    changeLhs r\n  | _ => throwUnsupportedSyntax", "start": [12, 1], "end": [22, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Unfold.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Simp.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Unfold.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Conv.evalUnfold", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.unfold] def evalUnfold : Tactic := fun stx => withMainContext do\n  for declNameId in stx[1].getArgs do\n    let declName \u2190 resolveGlobalConstNoOverloadWithInfo declNameId\n    applySimpResult (\u2190 unfold (\u2190 getLhs) declName)", "start": [12, 1], "end": [15, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Delta.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Delta.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Conv.evalDelta", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.delta] def evalDelta : Tactic := fun stx => withMainContext do\n  let declNames \u2190 stx[1].getArgs.mapM resolveGlobalConstNoOverloadWithInfo\n  let lhsNew \u2190 deltaExpand (\u2190 instantiateMVars (\u2190 getLhs)) declNames.contains\n  changeLhs lhsNew", "start": [12, 1], "end": [15, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Pattern.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Simp.lean", "lake-packages/lean4/src/lean/Lean/HeadIndex.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Conv.getContext", "code": "private def getContext : MetaM Simp.Context := do\n  return {\n    simpTheorems  := {}\n    congrTheorems := (\u2190 getSimpCongrTheorems)\n    config        := Simp.neutralConfig\n  }", "start": [13, 1], "end": [18, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.matchPattern?", "code": "partial def matchPattern? (pattern : AbstractMVarsResult) (e : Expr) : MetaM (Option (Expr \u00d7 Array Expr)) :=\n  withNewMCtxDepth do\n    \n    let (_, _, pattern) \u2190 openAbstractMVarsResult pattern\n    let rec go? (e : Expr) : MetaM (Option (Expr \u00d7 Array Expr)) := do\n      if e.toHeadIndex != pattern.toHeadIndex then\n        return none\n      else if (\u2190 isDefEqGuarded pattern e) then\n        return some (e, #[])\n      else if e.isApp then\n        return (\u2190 go? e.appFn!).map fun (f, extra) => (f, extra.push e.appArg!)\n      else\n        return none\n    withReducible <| go? e", "start": [20, 1], "end": [34, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.PatternMatchState", "code": "inductive PatternMatchState where\n  \n  | all (subgoals : Array MVarId)\n  \n  | occs (subgoals : Array (Nat \u00d7 MVarId)) (idx : Nat) (remaining : List (Nat \u00d7 Nat))", "start": [36, 1], "end": [52, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.PatternMatchState.isDone", "code": "def isDone : PatternMatchState \u2192 Bool\n  | .all _ => false\n  | .occs _ _ remaining => remaining.isEmpty", "start": [56, 1], "end": [59, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.PatternMatchState.isReady", "code": "def isReady : PatternMatchState \u2192 Bool\n  | .all _ => true\n  | .occs _ idx ((i, _) :: _) => idx == i\n  | _ => false", "start": [61, 1], "end": [65, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.PatternMatchState.skip", "code": "def skip : PatternMatchState \u2192 PatternMatchState\n  | .occs subgoals idx remaining => .occs subgoals (idx + 1) remaining\n  | s => s", "start": [67, 1], "end": [70, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.PatternMatchState.accept", "code": "def accept (mvarId : MVarId) : PatternMatchState \u2192 PatternMatchState\n  | .all subgoals => .all (subgoals.push mvarId)\n  | .occs subgoals idx ((_, n) :: remaining) => .occs (subgoals.push (n, mvarId)) (idx + 1) remaining\n  | s => s", "start": [72, 1], "end": [79, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.pre", "code": "private def pre (pattern : AbstractMVarsResult) (state : IO.Ref PatternMatchState) (e : Expr) : SimpM Simp.Step := do\n  if (\u2190 state.get).isDone then\n    return Simp.Step.visit { expr := e }\n  else if let some (e, extraArgs) \u2190 matchPattern? pattern e then\n    if (\u2190 state.get).isReady then\n      let (rhs, newGoal) \u2190 mkConvGoalFor e\n      state.modify (\u00b7.accept newGoal.mvarId!)\n      let mut proof := newGoal\n      for extraArg in extraArgs do\n        proof \u2190 mkCongrFun proof extraArg\n      return Simp.Step.done { expr := mkAppN rhs extraArgs, proof? := proof }\n    else\n      state.modify (\u00b7.skip)\n      return Simp.Step.visit { expr := e }\n  else\n    return Simp.Step.visit { expr := e }", "start": [83, 1], "end": [102, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalPattern", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.pattern] def evalPattern : Tactic := fun stx => withMainContext do\n  match stx with\n  | `(conv| pattern $[(occs := $occs)]? $p) =>\n    let patternA \u2190\n       withTheReader Term.Context (fun ctx => { ctx with ignoreTCFailures := true }) <|\n       Term.withoutModifyingElabMetaStateWithInfo <| withRef p <|\n       Term.withoutErrToSorry do\n         abstractMVars (\u2190 Term.elabTerm p none)\n    let lhs \u2190 getLhs\n    let occs \u2190 match occs with\n    | none => pure (.occs #[] 0 [(0, 0)])\n    | some occs => match occs with\n      | `(Parser.Tactic.Conv.occsWildcard| *) => pure (.all #[])\n      | `(Parser.Tactic.Conv.occsIndexed| $ids*) => do\n        let ids \u2190 ids.mapIdxM fun i id =>\n          match id.getNat with\n          | 0 => throwErrorAt id \"positive integer expected\"\n          | n+1 => pure (n, i.1)\n        let ids := ids.qsort (\u00b7.1 < \u00b7.1)\n        unless @Array.allDiff _ \u27e8(\u00b7.1 == \u00b7.1)\u27e9 ids do\n          throwError \"occurrence list is not distinct\"\n        pure (.occs #[] 0 ids.toList)\n      | _ => throwUnsupportedSyntax\n    let state \u2190 IO.mkRef occs\n    let ctx := { \u2190 getContext with config.memoize := occs matches .all _ }\n    let (result, _) \u2190 Simp.main lhs ctx (methods := { pre := pre patternA state })\n    let subgoals \u2190 match \u2190 state.get with\n    | .all #[] | .occs _ 0 _ =>\n      throwError \"'pattern' conv tactic failed, pattern was not found{indentExpr patternA.expr}\"\n    | .all subgoals => pure subgoals\n    | .occs subgoals idx remaining =>\n      if let some (i, _) := remaining.getLast? then\n        throwError \"'pattern' conv tactic failed, pattern was found only {idx} times but {i+1} expected\"\n      pure <| (subgoals.qsort (\u00b7.1 < \u00b7.1)).map (\u00b7.2)\n    (\u2190 getRhs).mvarId!.assign result.expr\n    (\u2190 getMainGoal).assign (\u2190 result.getProof)\n    replaceMainGoal subgoals.toList\n  | _ => throwUnsupportedSyntax", "start": [104, 1], "end": [141, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Rewrite.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Conv.evalRewrite", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.rewrite] def evalRewrite : Tactic := fun stx => do\n  let config \u2190 Tactic.elabRewriteConfig stx[1]\n  withRWRulesSeq stx[0] stx[2] fun symm term => do\n    Term.withSynthesize <| withMainContext do\n      let e \u2190 elabTerm term none true\n      let r \u2190  (\u2190 getMainGoal).rewrite (\u2190 getLhs) e symm (config := config)\n      updateLhs r.eNew r.eqProof\n      replaceMainGoal ((\u2190 getMainGoal) :: r.mvarIds)", "start": [13, 1], "end": [20, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Util/UnorderedArraySet.lean", "imports": ["lake-packages/std/Std/Data/Array/Merge.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.UnorderedArraySet", "code": "structure UnorderedArraySet (\u03b1) [BEq \u03b1] where\n  private mk ::\n  private rep : Array \u03b1\n  deriving Inhabited", "start": [13, 1], "end": [16, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.empty", "code": "protected def empty : UnorderedArraySet \u03b1 :=\n  \u27e8#[]\u27e9", "start": [22, 1], "end": [24, 8], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.singleton", "code": "protected def singleton (a : \u03b1) : UnorderedArraySet \u03b1 :=\n  \u27e8#[a]\u27e9", "start": [29, 1], "end": [31, 9], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.insert", "code": "def insert (x : \u03b1) : UnorderedArraySet \u03b1 \u2192 UnorderedArraySet \u03b1\n  | \u27e8rep\u27e9 => if rep.contains x then \u27e8rep\u27e9 else \u27e8rep.push x\u27e9", "start": [33, 1], "end": [35, 60], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.ofDeduplicatedArray", "code": "protected def ofDeduplicatedArray (xs : Array \u03b1) : UnorderedArraySet \u03b1 :=\n  \u27e8xs\u27e9", "start": [37, 1], "end": [39, 7], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.ofSortedArray", "code": "protected def ofSortedArray (xs : Array \u03b1) : UnorderedArraySet \u03b1 :=\n  \u27e8xs.deduplicateSorted\u27e9", "start": [41, 1], "end": [43, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.ofArray", "code": "protected def ofArray [ord : Ord \u03b1] [Inhabited \u03b1] (xs : Array \u03b1) :\n    UnorderedArraySet \u03b1 :=\n  \u27e8xs.sortAndDeduplicate\u27e9", "start": [46, 1], "end": [49, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.ofArraySlow", "code": "protected def ofArraySlow (xs : Array \u03b1) : UnorderedArraySet \u03b1 :=\n  xs.foldl (init := {}) \u03bb s x => s.insert x", "start": [51, 1], "end": [53, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.ofHashSet", "code": "protected def ofHashSet [Hashable \u03b1] (xs : HashSet \u03b1) : UnorderedArraySet \u03b1 :=\n  \u27e8xs.toArray\u27e9", "start": [55, 1], "end": [56, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.ofPersistentHashSet", "code": "protected def ofPersistentHashSet [Hashable \u03b1] (xs : PersistentHashSet \u03b1) : UnorderedArraySet \u03b1 :=\n  \u27e8xs.fold (init := Array.mkEmpty xs.size) \u03bb as a => as.push a\u27e9", "start": [58, 1], "end": [59, 64], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.toArray", "code": "protected def toArray (s : UnorderedArraySet \u03b1) : Array \u03b1 :=\n  s.rep", "start": [61, 1], "end": [62, 8], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.erase", "code": "def erase (x : \u03b1) (s : UnorderedArraySet \u03b1) : UnorderedArraySet \u03b1 :=\n  \u27e8s.rep.erase x\u27e9", "start": [64, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.filterM", "code": "def filterM [Monad m] (p : \u03b1 \u2192 m Bool) (s : UnorderedArraySet \u03b1) :\n    m (UnorderedArraySet \u03b1) :=\n  return \u27e8\u2190 s.rep.filterM p\u27e9", "start": [68, 1], "end": [71, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.filter", "code": "def filter (p : \u03b1 \u2192 Bool) (s : UnorderedArraySet \u03b1) : UnorderedArraySet \u03b1 :=\n  \u27e8s.rep.filter p\u27e9", "start": [73, 1], "end": [75, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.merge", "code": "def merge (s t : UnorderedArraySet \u03b1) : UnorderedArraySet \u03b1 :=\n  \u27e8s.rep.mergeUnsortedDeduplicating t.rep\u27e9", "start": [77, 1], "end": [79, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.contains", "code": "def contains (x : \u03b1) (s : UnorderedArraySet \u03b1) : Bool :=\n  s.rep.contains x", "start": [84, 1], "end": [86, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.foldM", "code": "def foldM [Monad m] (f : \u03c3 \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3) (s : UnorderedArraySet \u03b1) :\n    m \u03c3 :=\n  s.rep.foldlM f init", "start": [88, 1], "end": [91, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.fold", "code": "def fold (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3) (init : \u03c3) (s : UnorderedArraySet \u03b1) : \u03c3 :=\n  s.rep.foldl f init", "start": [96, 1], "end": [98, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.partition", "code": "def partition (f : \u03b1 \u2192 Bool) (s : UnorderedArraySet \u03b1) :\n    (UnorderedArraySet \u03b1 \u00d7 UnorderedArraySet \u03b1) :=\n  let (xs, ys) := s.rep.partition f\n  (\u27e8xs\u27e9, \u27e8ys\u27e9)", "start": [100, 1], "end": [103, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.size", "code": "def size (s : UnorderedArraySet \u03b1) : Nat :=\n  s.rep.size", "start": [105, 1], "end": [107, 13], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.isEmpty", "code": "def isEmpty (s : UnorderedArraySet \u03b1) : Bool :=\n  s.rep.isEmpty", "start": [109, 1], "end": [111, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.anyM", "code": "def anyM [Monad m] (p : \u03b1 \u2192 m Bool) (s : UnorderedArraySet \u03b1) (start := 0)\n    (stop := s.size) : m Bool :=\n  s.rep.anyM p start stop", "start": [113, 1], "end": [116, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.any", "code": "def any (p : \u03b1 \u2192 Bool) (s : UnorderedArraySet \u03b1) (start := 0) (stop := s.size) :\n    Bool :=\n  s.rep.any p start stop", "start": [118, 1], "end": [121, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.allM", "code": "def allM [Monad m] (p : \u03b1 \u2192 m Bool) (s : UnorderedArraySet \u03b1) (start := 0)\n    (stop := s.size) : m Bool :=\n  s.rep.allM p start stop", "start": [123, 1], "end": [126, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnorderedArraySet.all", "code": "def all (p : \u03b1 \u2192 Bool) (s : UnorderedArraySet \u03b1) (start := 0) (stop := s.size) :\n    Bool :=\n  s.rep.all p start stop", "start": [128, 1], "end": [131, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Nanos.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Nanos", "code": "structure Nanos where\n  nanos : Nat\n  deriving Inhabited, BEq, Ord", "start": [9, 1], "end": [11, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.Nanos.printAsMillis", "code": "def printAsMillis (n : Nanos) : String :=\n  let str := toString (n.nanos.toFloat / 1000000)\n  match str.split \u03bb c => c == '.' with\n  | [beforePoint] => beforePoint ++ \"ms\"\n  | [beforePoint, afterPoint] => beforePoint ++ \".\" ++ afterPoint.take 3 ++ \"ms\"\n  | _ => unreachable!", "start": [21, 1], "end": [26, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/PersistentHashSet.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/PersistentHashSet.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PersistentHashSet.anyM", "code": "@[specialize]\ndef anyM [Monad m] (s : PersistentHashSet \u03b1) (f : \u03b1 \u2192 m Bool) : m Bool := do\n  for a in s do\n    if \u2190 f a then\n      return true\n  return false", "start": [22, 1], "end": [30, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.any", "code": "@[inline]\ndef any (s : PersistentHashSet \u03b1) (f : \u03b1 \u2192 Bool) : Bool :=\n  Id.run <| s.anyM f", "start": [32, 1], "end": [37, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.allM", "code": "@[specialize]\ndef allM [Monad m] (s : PersistentHashSet \u03b1) (f : \u03b1 \u2192 m Bool) : m Bool := do\n  for a in s do\n    if ! (\u2190 f a) then\n      return false\n  return true", "start": [39, 1], "end": [47, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.all", "code": "@[inline]\ndef all (s : PersistentHashSet \u03b1) (f : \u03b1 \u2192 Bool) : Bool :=\n  Id.run <| s.allM f", "start": [49, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.insert'", "code": "@[inline]\ndef insert' (s : PersistentHashSet \u03b1) (a : \u03b1) : PersistentHashSet \u03b1 \u00d7 Bool :=\n  let oldSize := s.size\n  let s := s.insert a\n  (s, s.size == oldSize)", "start": [59, 1], "end": [67, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.insertMany", "code": "def insertMany [ForIn Id \u03c1 \u03b1] (s : PersistentHashSet \u03b1) (as : \u03c1) :\n    PersistentHashSet \u03b1 := Id.run do\n  let mut s := s\n  for a in as do\n    s := s.insert a\n  return s", "start": [69, 1], "end": [77, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.ofArray", "code": "@[inline]\nprotected def ofArray [BEq \u03b1] [Hashable \u03b1] (as : Array \u03b1) : PersistentHashSet \u03b1 :=\n  PersistentHashSet.empty.insertMany as", "start": [79, 1], "end": [84, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.ofList", "code": "@[inline]\nprotected def ofList [BEq \u03b1] [Hashable \u03b1] (as : List \u03b1) : PersistentHashSet \u03b1 :=\n  PersistentHashSet.empty.insertMany as", "start": [86, 1], "end": [91, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.merge", "code": "@[inline]\ndef merge (s t : PersistentHashSet \u03b1) : PersistentHashSet \u03b1 :=\n  s.insertMany t", "start": [93, 1], "end": [98, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Util/UnionFind.lean", "imports": ["lake-packages/std/Std/Data/HashMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.UnionFind", "code": "structure UnionFind (\u03b1) [BEq \u03b1] [Hashable \u03b1] where\n  parents : Array USize\n  sizes : Array USize\n  toRep : HashMap \u03b1 USize\n  deriving Inhabited", "start": [13, 1], "end": [18, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.size", "code": "def size (u : UnionFind \u03b1) : Nat :=\n  u.parents.size", "start": [27, 1], "end": [28, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.add", "code": "def add (x : \u03b1) (u : UnionFind \u03b1) : UnionFind \u03b1 := Id.run do\n  if u.toRep.contains x then\n    return u\n  let rep := u.parents.size.toUSize\n  { parents := u.parents.push rep\n    sizes := u.parents.push 1\n    toRep := u.toRep.insert x rep }", "start": [30, 1], "end": [36, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.addArray", "code": "def addArray (xs : Array \u03b1) (u : UnionFind \u03b1) : UnionFind \u03b1 :=\n  xs.foldl (init := u) \u03bb u x => u.add x", "start": [38, 1], "end": [39, 40], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.ofArray", "code": "def ofArray (xs : Array \u03b1) : UnionFind \u03b1 :=\n  ({} : UnionFind \u03b1).addArray xs", "start": [41, 1], "end": [42, 33], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.findRepUnsafe", "code": "private unsafe def findRepUnsafe (i : USize) (u : UnionFind \u03b1) :\n    USize \u00d7 UnionFind \u03b1 :=\n  let parent := u.parents.uget i lcProof\n  if parent == i then\n    (parent, u)\n  else\n    let (parent, u) := u.findRepUnsafe parent\n    (parent, { u with parents := u.parents.uset i parent lcProof })", "start": [44, 1], "end": [51, 68], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.findRep", "code": "@[implemented_by findRepUnsafe]\nprivate opaque findRep : USize \u2192 UnionFind \u03b1 \u2192 USize \u00d7 UnionFind \u03b1", "start": [53, 1], "end": [54, 67], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.find?", "code": "partial def find? (x : \u03b1) (u : UnionFind \u03b1) : Option USize \u00d7 UnionFind \u03b1 :=\n  match u.toRep.find? x with\n  | none => (none, u)\n  | some rep =>\n    let (rep, u) := u.findRep rep\n    (some rep, u)", "start": [56, 1], "end": [61, 18], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.mergeUnsafe", "code": "private unsafe def mergeUnsafe (x y : \u03b1) (u : UnionFind \u03b1) :\n    UnionFind \u03b1 := Id.run do\n  let (some xRep, u) := u.find? x | u\n  let (some yRep, u) := u.find? y | u\n  if xRep == yRep then\n    return u\n  else\n    let xSize := u.sizes.uget xRep lcProof\n    let ySize := u.sizes.uget yRep lcProof\n    if xSize < ySize then\n      return {\n        parents := u.parents.uset xRep yRep lcProof\n        sizes := u.sizes.uset yRep (xSize + ySize) lcProof\n        toRep := u.toRep\n      }\n    else\n      return {\n        parents := u.parents.uset yRep xRep lcProof\n        sizes := u.sizes.uset xRep (xSize + ySize) lcProof\n        toRep := u.toRep\n      }", "start": [63, 1], "end": [83, 8], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.merge", "code": "@[implemented_by mergeUnsafe]\nopaque merge (x y : \u03b1) : UnionFind \u03b1 \u2192 UnionFind \u03b1", "start": [85, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnionFind.sets", "code": "def sets {\u03b1 : Type v} [BEq \u03b1] [Hashable \u03b1] (u : UnionFind \u03b1) : Array (Array \u03b1) \u00d7 UnionFind \u03b1 :=\n  let (sets, u) := u.toRep.fold (init := (HashMap.empty, u)) \u03bb ((sets : HashMap USize _), u) x rep =>\n    let (rep, u) := u.findRep rep\n    let sets :=\n      match sets.find? rep with\n      | some set => sets.insert rep (set.push x)\n      | none => sets.insert rep #[x]\n    (sets, u)\n  let sets := sets.fold (init := Array.mkEmpty sets.size) \u03bb (sets : Array _) _ v =>\n    sets.push v\n  (sets, u)", "start": [88, 1], "end": [98, 12], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Expr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.toSyntax", "code": "def toSyntax (e : Expr) : TermElabM Syntax.Term := withFreshMacroScope do\n  let stx \u2190 `(?a)\n  let mvar \u2190 elabTermEnsuringType stx (\u2190 Meta.inferType e)\n  mvar.mvarId!.assign e\n  pure stx", "start": [19, 1], "end": [25, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.forallArity", "code": "def forallArity : Expr \u2192 Nat\n  | mdata _ b => forallArity b\n  | forallE _ _ body _ => 1 + forallArity body\n  | _ => 0", "start": [27, 1], "end": [33, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.lambdaArity", "code": "def lambdaArity : Expr \u2192 Nat\n  | mdata _ b => lambdaArity b\n  | lam _ _ b _ => 1 + lambdaArity b\n  | _ => 0", "start": [35, 1], "end": [41, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppFn'", "code": "def getAppFn' : Expr \u2192 Expr\n  | mdata _ b => getAppFn' b\n  | app f _ => getAppFn' f\n  | e => e", "start": [43, 1], "end": [47, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppNumArgs'", "code": "def getAppNumArgs' (e : Expr) : Nat :=\n  go e 0\nwhere\n  \n  go : Expr \u2192 Nat \u2192 Nat\n    | mdata _ b, n => go b n\n    | app f _  , n => go f (n + 1)\n    | _        , n => n", "start": [49, 1], "end": [57, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.withApp'", "code": "@[inline]\ndef withApp' (e : Expr) (k : Expr \u2192 Array Expr \u2192 \u03b1) : \u03b1 :=\n  let dummy := mkSort levelZero\n  let nargs := e.getAppNumArgs'\n  go e (mkArray nargs dummy) (nargs - 1)\nwhere\n  \n  @[specialize]\n  go : Expr \u2192 Array Expr \u2192 Nat \u2192 \u03b1\n    | mdata _ b, as, i => go b as i\n    | app f a  , as, i => go f (as.set! i a) (i-1)\n    | f        , as, _ => k f as", "start": [59, 1], "end": [71, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppArgs'", "code": "@[inline]\ndef getAppArgs' (e : Expr) : Array Expr :=\n  e.withApp' \u03bb _ as => as", "start": [73, 1], "end": [76, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.traverseApp'", "code": "def traverseApp' {m} [Monad m]\n  (f : Expr \u2192 m Expr) (e : Expr) : m Expr :=\n  e.withApp' \u03bb fn args => return mkAppN (\u2190 f fn) (\u2190 args.mapM f)", "start": [78, 1], "end": [81, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.withAppRev'", "code": "@[inline]\ndef withAppRev' (e : Expr) (k : Expr \u2192 Array Expr \u2192 \u03b1) : \u03b1 :=\n  go e (Array.mkEmpty e.getAppNumArgs')\nwhere\n  \n  @[specialize]\n  go : Expr \u2192 Array Expr \u2192 \u03b1\n    | mdata _ b, as => go b as\n    | app f a  , as => go f (as.push a)\n    | f        , as => k f as", "start": [83, 1], "end": [93, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppRevArgs'", "code": "@[inline]\ndef getAppRevArgs' (e : Expr) : Array Expr :=\n  e.withAppRev' \u03bb _ as => as", "start": [95, 1], "end": [98, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getRevArgD'", "code": "def getRevArgD' : Expr \u2192 Nat \u2192 Expr \u2192 Expr\n  | mdata _ b, n  , v => getRevArgD' b n v\n  | app _ a  , 0  , _ => a\n  | app f _  , i+1, v => getRevArgD' f i v\n  | _        , _  , v => v", "start": [100, 1], "end": [105, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getRevArg!'", "code": "@[inline]\ndef getRevArg!' : Expr \u2192 Nat \u2192 Expr\n  | mdata _ b, n   => getRevArg!' b n\n  | app _ a  , 0   => a\n  | app f _  , i+1 => getRevArg!' f i\n  | _        , _   => panic! \"invalid index\"", "start": [107, 1], "end": [113, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getArgD'", "code": "@[inline]\ndef getArgD' (e : Expr) (i : Nat) (v\u2080 : Expr) (n := e.getAppNumArgs') : Expr :=\n  getRevArgD' e (n - i - 1) v\u2080", "start": [115, 1], "end": [118, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getArg!'", "code": "@[inline]\ndef getArg!' (e : Expr) (i : Nat) (n := e.getAppNumArgs') : Expr :=\n  getRevArg!' e (n - i - 1)", "start": [120, 1], "end": [123, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isAppOf'", "code": "def isAppOf' (e : Expr) (n : Name) : Bool :=\n  match e.getAppFn' with\n  | const c .. => c == n\n  | _ => false", "start": [125, 1], "end": [129, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/MonadBacktrack.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/MonadBacktrack.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.withoutModifyingState'", "code": "def withoutModifyingState' [Monad m] [MonadBacktrack s m] [MonadFinally m]\n    (x : m \u03b1) : m (\u03b1 \u00d7 s) :=\n  withoutModifyingState do\n    let result \u2190 x\n    let finalState \u2190 saveState\n    return (result, finalState)", "start": [11, 1], "end": [20, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/NormCast/Ext.lean", "imports": ["lake-packages/std/Std/Tactic/CoeExt.lean", "lake-packages/lean4/src/lean/Lean/Meta/CongrTheorems.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpTheorems.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.NormCast.Label", "code": "inductive Label\n  \n  | elim\n  \n  | move\n  \n  | squash\n  deriving DecidableEq, Repr, Inhabited", "start": [15, 1], "end": [29, 40], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.getSimpArgs", "code": "def getSimpArgs (e : Expr) : MetaM (Array Expr) := do\n  match \u2190 mkCongrSimp? e.getAppFn with\n  | none => return e.getAppArgs\n  | some {argKinds, ..} =>\n    let mut args := #[]\n    for a in e.getAppArgs, k in argKinds do\n      if k matches .eq then\n        args := args.push a\n    return args", "start": [31, 1], "end": [40, 16], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.countHeadCoes", "code": "partial def countHeadCoes (e : Expr) : MetaM Nat := do\n  if let Expr.const fn .. := e.getAppFn then\n    if let some info \u2190 getCoeFnInfo? fn then\n      if e.getAppNumArgs >= info.numArgs then\n        return (\u2190 countHeadCoes (e.getArg! info.coercee)) + 1\n  return 0", "start": [42, 1], "end": [48, 11], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.countCoes", "code": "partial def countCoes (e : Expr) : MetaM Nat :=\n  lambdaTelescope e fun _ e => do\n    if let Expr.const fn .. := e.getAppFn then\n      if let some info \u2190 getCoeFnInfo? fn then\n        if e.getAppNumArgs >= info.numArgs then\n          let mut coes := (\u2190 countHeadCoes (e.getArg! info.coercee)) + 1\n          for i in [info.numArgs:e.getAppNumArgs] do\n            coes := coes + (\u2190 countCoes (e.getArg! i))\n          return coes\n    return (\u2190 (\u2190 getSimpArgs e).mapM countCoes).foldl (\u00b7+\u00b7) 0", "start": [50, 1], "end": [60, 62], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.countInternalCoes", "code": "def countInternalCoes (e : Expr) : MetaM Nat :=\n  return (\u2190 countCoes e) - (\u2190 countHeadCoes e)", "start": [62, 1], "end": [64, 47], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.classifyType", "code": "def classifyType (ty : Expr) : MetaM Label :=\n  forallTelescopeReducing ty fun _ ty => do\n    let ty \u2190 whnf ty\n    let (lhs, rhs) \u2190\n      if ty.isAppOfArity ``Eq 3 then pure (ty.getArg! 1, ty.getArg! 2)\n      else if ty.isAppOfArity ``Iff 2 then pure (ty.getArg! 0, ty.getArg! 1)\n      else throwError \"norm_cast: lemma must be = or \u2194, but is{indentExpr ty}\"\n    let lhsCoes \u2190 countCoes lhs\n    if lhsCoes = 0 then\n      throwError \"norm_cast: badly shaped lemma, lhs must contain at least one coe{indentExpr lhs}\"\n    let lhsHeadCoes \u2190 countHeadCoes lhs\n    let rhsHeadCoes \u2190 countHeadCoes rhs\n    let rhsInternalCoes \u2190 countInternalCoes rhs\n    if lhsHeadCoes = 0 then\n      return Label.elim\n    else if lhsHeadCoes = 1 then do\n      unless rhsHeadCoes = 0 do\n        throwError \"norm_cast: badly shaped lemma, rhs can't start with coe{indentExpr rhs}\"\n      if rhsInternalCoes = 0 then\n        return Label.squash\n      else\n        return Label.move\n    else if rhsHeadCoes < lhsHeadCoes then do\n      return Label.squash\n    else do\n      throwError\n          (\"norm_cast: badly shaped shaped squash lemma, \" ++\n        \"rhs must have fewer head coes than lhs{indentExpr ty}\")", "start": [66, 1], "end": [94, 65], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.NormCastExtension", "code": "structure NormCastExtension where\n  \n  up : SimpExtension\n  \n  down : SimpExtension\n  \n  squash : SimpExtension\n  deriving Inhabited", "start": [102, 1], "end": [110, 21], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.addElim", "code": "def addElim (decl : Name)\n    (kind := AttributeKind.global) (prio := eval_prio default) : MetaM Unit :=\n  addSimpTheorem normCastExt.up decl (post := true) (inv := false) kind prio", "start": [119, 1], "end": [122, 77], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.addMove", "code": "def addMove (decl : Name)\n    (kind := AttributeKind.global) (prio := eval_prio default) : MetaM Unit := do\n  addSimpTheorem pushCastExt decl (post := true) (inv := false) kind prio\n  addSimpTheorem normCastExt.up decl (post := true) (inv := true) kind prio\n  addSimpTheorem normCastExt.down decl (post := true) (inv := false) kind prio", "start": [124, 1], "end": [129, 79], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.addSquash", "code": "def addSquash (decl : Name)\n    (kind := AttributeKind.global) (prio := eval_prio default) : MetaM Unit := do\n  addSimpTheorem pushCastExt decl (post := true) (inv := false) kind prio\n  addSimpTheorem normCastExt.squash decl (post := true) (inv := false) kind prio\n  addSimpTheorem normCastExt.down decl (post := true) (inv := false) kind prio", "start": [131, 1], "end": [136, 79], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.NormCast.addInfer", "code": "def addInfer (decl : Name)\n    (kind := AttributeKind.global) (prio := eval_prio default) : MetaM Unit := do\n  let ty := (\u2190 getConstInfo decl).type\n  match \u2190 classifyType ty with\n  | Label.elim => addElim decl kind prio\n  | Label.squash => addSquash decl kind prio\n  | Label.move => addMove decl kind prio", "start": [138, 1], "end": [150, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Util/LibraryNote.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Util.LibraryNote.LibraryNoteEntry", "code": "def LibraryNoteEntry := String \u00d7 String", "start": [16, 1], "end": [17, 40], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Level.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CSE.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PullFunDecls.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToLCNF.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Closure.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/LambdaLifting.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ReduceArity.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Simp.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Main.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ConfigOptions.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PhaseExt.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PullLetDecls.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToDecl.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/MonoTypes.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/FixedParams.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Check.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/InferType.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToMono.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/JoinPoints.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Bind.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/LCtx.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/DependsOn.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Passes.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Specialize.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ReduceJpArity.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ToExpr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/SpecInfo.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ElimDead.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Util.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/PassManager.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ForEachExpr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/MonadScope.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/AlphaEqv.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Testing.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/ElimDeadBranches.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Format.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.UnreachableBranches.Value", "code": "inductive Value where\n  | bot | top | ctor (i : CtorInfo) (vs : Array Value)\n  | choice (vs : List Value)\n  deriving Inhabited, Repr", "start": [12, 1], "end": [18, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.Value.toFormat", "code": "protected partial def Value.toFormat : Value \u2192 Format\n  | Value.bot => \"\u22a5\"\n  | Value.top => \"\u22a4\"\n  | Value.ctor info vs =>\n    if vs.isEmpty then\n      format info.name\n    else\n      Format.paren <| format info.name ++ Std.Format.join (vs.toList.map fun v => \" \" ++ Value.toFormat v)\n  | Value.choice vs =>\n    Format.paren <| Std.Format.joinSep (vs.map Value.toFormat) \" | \"", "start": [20, 1], "end": [29, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.Value.beq", "code": "protected partial def beq : Value \u2192 Value \u2192 Bool\n  | bot, bot => true\n  | top, top => true\n  | ctor i\u2081 vs\u2081, ctor i\u2082 vs\u2082 => i\u2081 == i\u2082 && Array.isEqv vs\u2081 vs\u2082 Value.beq\n  | choice vs\u2081, choice vs\u2082 =>\n    vs\u2081.all (fun v\u2081 => vs\u2082.any fun v\u2082 => Value.beq v\u2081 v\u2082)\n    &&\n    vs\u2082.all (fun v\u2082 => vs\u2081.any fun v\u2081 => Value.beq v\u2081 v\u2082)\n  | _, _ => false", "start": [39, 1], "end": [47, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.Value.addChoice", "code": "partial def addChoice (merge : Value \u2192 Value \u2192 Value) : List Value \u2192 Value \u2192 List Value\n  | [], v => [v]\n  | v\u2081@(ctor i\u2081 _) :: cs, v\u2082@(ctor i\u2082 _) =>\n    if i\u2081 == i\u2082 then merge v\u2081 v\u2082 :: cs\n    else v\u2081 :: addChoice merge cs v\u2082\n  | _, _ => panic! \"invalid addChoice\"", "start": [51, 1], "end": [56, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.Value.merge", "code": "partial def merge (v\u2081 v\u2082 : Value) : Value :=\n  match v\u2081, v\u2082 with\n  | bot, v => v\n  | v, bot => v\n  | top, _ => top\n  | _, top => top\n  | v\u2081@(ctor i\u2081 vs\u2081), v\u2082@(ctor i\u2082 vs\u2082) =>\n    if i\u2081 == i\u2082 then ctor i\u2081 <| vs\u2081.size.fold (init := #[]) fun i r => r.push (merge vs\u2081[i]! vs\u2082[i]!)\n    else choice [v\u2081, v\u2082]\n  | choice vs\u2081, choice vs\u2082 => choice <| vs\u2081.foldl (addChoice merge) vs\u2082\n  | choice vs, v => choice <| addChoice merge vs v\n  | v, choice vs => choice <| addChoice merge vs v", "start": [58, 1], "end": [69, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.Value.format", "code": "protected partial def format : Value \u2192 Format\n  | top => \"top\"\n  | bot => \"bot\"\n  | choice vs => format \"@\" ++ @List.format _ \u27e8Value.format\u27e9 vs\n  | ctor i vs => format \"#\" ++ if vs.isEmpty then format i.name else Format.paren (format i.name ++ @formatArray _ \u27e8Value.format\u27e9 vs)", "start": [71, 1], "end": [75, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.Value.truncateMaxDepth", "code": "def truncateMaxDepth := 8", "start": [80, 1], "end": [84, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.Value.truncate", "code": "partial def truncate (env : Environment) (v : Value) (s : NameSet) : Value :=\n  go v s truncateMaxDepth\nwhere\n  go (v : Value) (s : NameSet) (depth : Nat) : Value :=\n    match depth with\n    | 0 => top\n    | depth+1 =>\n      match v, s with\n      | ctor i vs, found =>\n        let I := i.name.getPrefix\n        if found.contains I then\n          top\n        else\n          let cont (found' : NameSet) : Value :=\n            ctor i (vs.map fun v => go v found' depth)\n          match env.find? I with\n          | some (ConstantInfo.inductInfo d) =>\n            if d.isRec then cont (found.insert I)\n            else cont found\n          | _ => cont found\n      | choice vs, found =>\n        let newVs := vs.map fun v => go v found depth\n        if newVs.elem top then top\n        else choice newVs\n      | v, _ => v", "start": [86, 1], "end": [117, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.Value.widening", "code": "def widening (env : Environment) (v\u2081 v\u2082 : Value) : Value :=\n  truncate env (merge v\u2081 v\u2082) {}", "start": [119, 1], "end": [121, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.FunctionSummaries", "code": "abbrev FunctionSummaries := PHashMap FunId Value", "start": [125, 1], "end": [125, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.declLt", "code": "private abbrev declLt (a b : FunId \u00d7 Value) :=\n  Name.quickLt a.1 b.1", "start": [127, 1], "end": [128, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.sortEntries", "code": "private abbrev sortEntries (entries : Array (FunId \u00d7 Value)) : Array (FunId \u00d7 Value) :=\n  entries.qsort declLt", "start": [130, 1], "end": [131, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.findAtSorted?", "code": "private abbrev findAtSorted? (entries : Array (FunId \u00d7 Value)) (fid : FunId) : Option Value :=\n  if let some (_, value) := entries.binSearch (fid, default) declLt then\n    some value\n  else\n    none", "start": [133, 1], "end": [137, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.addFunctionSummary", "code": "def addFunctionSummary (env : Environment) (fid : FunId) (v : Value) : Environment :=\n  functionSummariesExt.addEntry (env.addExtraName fid) (fid, v)", "start": [146, 1], "end": [147, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.getFunctionSummary?", "code": "def getFunctionSummary? (env : Environment) (fid : FunId) : Option Value :=\n  match env.getModuleIdxFor? fid with\n  | some modIdx => findAtSorted? (functionSummariesExt.getModuleEntries env modIdx) fid\n  | none        => functionSummariesExt.getState env |>.find? fid", "start": [149, 1], "end": [152, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.Assignment", "code": "abbrev Assignment := HashMap VarId Value", "start": [154, 1], "end": [154, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.InterpContext", "code": "structure InterpContext where\n  currFnIdx : Nat := 0\n  decls     : Array Decl\n  env       : Environment\n  lctx      : LocalContext := {}", "start": [156, 1], "end": [160, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.InterpState", "code": "structure InterpState where\n  assignments : Array Assignment\n  funVals     : PArray Value", "start": [162, 1], "end": [164, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.M", "code": "abbrev M := ReaderT InterpContext (StateM InterpState)", "start": [166, 1], "end": [166, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.findVarValue", "code": "def findVarValue (x : VarId) : M Value := do\n  let ctx \u2190 read\n  let s \u2190 get\n  let assignment := s.assignments[ctx.currFnIdx]!\n  return assignment.findD x bot", "start": [170, 1], "end": [174, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.findArgValue", "code": "def findArgValue (arg : Arg) : M Value :=\n  match arg with\n  | Arg.var x => findVarValue x\n  | _         => pure top", "start": [176, 1], "end": [179, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.updateVarAssignment", "code": "def updateVarAssignment (x : VarId) (v : Value) : M Unit := do\n  let v' \u2190 findVarValue x\n  let ctx \u2190 read\n  modify fun s => { s with assignments := s.assignments.modify ctx.currFnIdx fun a => a.insert x (merge v v') }", "start": [181, 1], "end": [184, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.resetVarAssignment", "code": "def resetVarAssignment (x : VarId) : M Unit := do\n  let ctx \u2190 read\n  modify fun s => { s with assignments := s.assignments.modify ctx.currFnIdx fun a => a.insert x Value.bot }", "start": [186, 1], "end": [188, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.resetParamAssignment", "code": "def resetParamAssignment (y : Param) : M Unit :=\n  resetVarAssignment y.x", "start": [190, 1], "end": [191, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.projValue", "code": "partial def projValue : Value \u2192 Nat \u2192 Value\n  | ctor _ vs, i => vs.getD i bot\n  | choice vs, i => vs.foldl (fun r v => merge r (projValue v i)) bot\n  | v, _         => v", "start": [193, 1], "end": [196, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.interpExpr", "code": "def interpExpr : Expr \u2192 M Value\n  | Expr.ctor i ys => return ctor i (\u2190 ys.mapM fun y => findArgValue y)\n  | Expr.proj i x  => return projValue (\u2190 findVarValue x) i\n  | Expr.fap fid _  => do\n    let ctx \u2190 read\n    match getFunctionSummary? ctx.env fid with\n    | some v => pure v\n    | none   => do\n      let s \u2190 get\n      match ctx.decls.findIdx? (fun decl => decl.name == fid) with\n      | some idx => pure s.funVals[idx]!\n      | none     => pure top\n  | _ => pure top", "start": [198, 1], "end": [210, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.containsCtor", "code": "partial def containsCtor : Value \u2192 CtorInfo \u2192 Bool\n  | top,       _ => true\n  | ctor i _,  j => i == j\n  | choice vs, j => vs.any fun v => containsCtor v j\n  | _,         _ => false", "start": [212, 1], "end": [216, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.updateCurrFnSummary", "code": "def updateCurrFnSummary (v : Value) : M Unit := do\n  let ctx \u2190 read\n  let currFnIdx := ctx.currFnIdx\n  modify fun s => { s with funVals := s.funVals.modify currFnIdx (fun v' => widening ctx.env v v') }", "start": [218, 1], "end": [221, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.updateJPParamsAssignment", "code": "def updateJPParamsAssignment (ys : Array Param) (xs : Array Arg) : M Bool := do\n  let ctx \u2190 read\n  let currFnIdx := ctx.currFnIdx\n  ys.size.foldM (init := false) fun i r => do\n    let y := ys[i]!\n    let x := xs[i]!\n    let yVal \u2190 findVarValue y.x\n    let xVal \u2190 findArgValue x\n    let newVal := merge yVal xVal\n    if newVal == yVal then\n      pure r\n    else\n      modify fun s => { s with assignments := s.assignments.modify currFnIdx fun a => a.insert y.x newVal }\n      pure true", "start": [223, 1], "end": [237, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.resetNestedJPParams", "code": "private partial def resetNestedJPParams : FnBody \u2192 M Unit\n  | FnBody.jdecl _ ys _ k => do\n    ys.forM resetParamAssignment\n    \n    resetNestedJPParams k\n  | FnBody.case _ _ _ alts =>\n    alts.forM fun alt => match alt with\n      | Alt.ctor _ b  => resetNestedJPParams b\n      | Alt.default b => resetNestedJPParams b\n  | e => do unless e.isTerminal do resetNestedJPParams e.body", "start": [239, 1], "end": [249, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.interpFnBody", "code": "partial def interpFnBody : FnBody \u2192 M Unit\n  | FnBody.vdecl x _ e b => do\n    let v \u2190 interpExpr e\n    updateVarAssignment x v\n    interpFnBody b\n  | FnBody.jdecl j ys v b =>\n    withReader (fun ctx => { ctx with lctx := ctx.lctx.addJP j ys v }) do\n      interpFnBody b\n  | FnBody.case _ x _ alts => do\n    let v \u2190 findVarValue x\n    alts.forM fun alt => do\n      match alt with\n      | Alt.ctor i b  => if containsCtor v i then interpFnBody b\n      | Alt.default b => interpFnBody b\n  | FnBody.ret x => do\n    let v \u2190 findArgValue x\n    updateCurrFnSummary v\n  | FnBody.jmp j xs => do\n    let ctx \u2190 read\n    let ys := (ctx.lctx.getJPParams j).get!\n    let b  := (ctx.lctx.getJPBody j).get!\n    let updated \u2190 updateJPParamsAssignment ys xs\n    if updated then\n      resetNestedJPParams b\n      interpFnBody b\n  | e => do\n    unless e.isTerminal do\n      interpFnBody e.body", "start": [251, 1], "end": [279, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.inferStep", "code": "def inferStep : M Bool := do\n  let ctx \u2190 read\n  modify fun s => { s with assignments := ctx.decls.map fun _ => {} }\n  ctx.decls.size.foldM (init := false) fun idx modified => do\n    match ctx.decls[idx]! with\n    | .fdecl (xs := ys) (body := b) .. => do\n      let s \u2190 get\n      let currVals := s.funVals[idx]!\n      withReader (fun ctx => { ctx with currFnIdx := idx }) do\n        ys.forM fun y => updateVarAssignment y.x top\n        interpFnBody b\n        let s \u2190 get\n        let newVals := s.funVals[idx]!\n        pure (modified || currVals != newVals)\n    | .extern .. => pure modified", "start": [281, 1], "end": [295, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.inferMain", "code": "partial def inferMain : M Unit := do\n  let modified \u2190 inferStep\n  if modified then inferMain else pure ()", "start": [297, 1], "end": [299, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.elimDeadAux", "code": "partial def elimDeadAux (assignment : Assignment) : FnBody \u2192 FnBody\n  | FnBody.vdecl x t e b  => FnBody.vdecl x t e (elimDeadAux assignment b)\n  | FnBody.jdecl j ys v b => FnBody.jdecl j ys (elimDeadAux assignment v) (elimDeadAux assignment b)\n  | FnBody.case tid x xType alts =>\n    let v := assignment.findD x bot\n    let alts := alts.map fun alt =>\n      match alt with\n      | Alt.ctor i b  => Alt.ctor i <| if containsCtor v i then elimDeadAux assignment b else FnBody.unreachable\n      | Alt.default b => Alt.default (elimDeadAux assignment b)\n    FnBody.case tid x xType alts\n  | e =>\n    if e.isTerminal then e\n    else\n      let (instr, b) := e.split\n      let b := elimDeadAux assignment b\n      instr.setBody b", "start": [301, 1], "end": [316, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.UnreachableBranches.elimDead", "code": "partial def elimDead (assignment : Assignment) (d : Decl) : Decl :=\n  match d with\n  | .fdecl (body := b) .. => d.updateBody! <| elimDeadAux assignment b\n  | other => other", "start": [318, 1], "end": [321, 19], "kind": "commanddeclaration"}, {"full_name": "elimDeadBranches", "code": "def elimDeadBranches (decls : Array Decl) : CompilerM (Array Decl) := do\n  let s \u2190 get\n  let env := s.env\n  let assignments : Array Assignment := decls.map fun _ => {}\n  let funVals := mkPArray decls.size Value.bot\n  let ctx : InterpContext := { decls := decls, env := env }\n  let s : InterpState := { assignments := assignments, funVals := funVals }\n  let (_, s) := (inferMain ctx).run s\n  let funVals := s.funVals\n  let assignments := s.assignments\n  modify fun s =>\n    let env := decls.size.fold (init := s.env) fun i env =>\n      addFunctionSummary env decls[i]!.name funVals[i]!\n    { s with env := env }\n  return decls.mapIdx fun i decl => elimDead assignments[i]! decl", "start": [327, 1], "end": [341, 66], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/Sorry.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.Sorry.State", "code": "structure State where\n  localSorryMap : NameMap Name := {}\n  modified : Bool := false", "start": [11, 1], "end": [13, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Sorry.M", "code": "abbrev M := StateT State CompilerM", "start": [15, 1], "end": [15, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Sorry.visitExpr", "code": "def visitExpr : Expr \u2192 ExceptT Name M Unit\n  | Expr.fap f _  => getSorryDepFor? f\n  | Expr.pap f _  => getSorryDepFor? f\n  | _             => return ()\nwhere\n  getSorryDepFor? (f : Name) : ExceptT Name M Unit := do\n    let found (g : Name) :=\n      if g == ``sorryAx then\n        throw f\n      else\n        throw g\n    if f == ``sorryAx then\n      throw f\n    else if let some g := (\u2190 get).localSorryMap.find? f then\n      found g\n    else match (\u2190 findDecl f) with\n      | some (.fdecl (info := { sorryDep? := some g, .. }) ..) => found g\n      | _ => return ()", "start": [17, 1], "end": [34, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Sorry.visitFndBody", "code": "partial def visitFndBody (b : FnBody) : ExceptT Name M Unit := do\n  match b with\n  | .vdecl _ _ v b   => visitExpr v; visitFndBody b\n  | .jdecl _ _ v b   => visitFndBody v; visitFndBody b\n  | .case _ _ _ alts => alts.forM fun alt => visitFndBody alt.body\n  | _ =>\n    unless b.isTerminal do\n      let (_, b) := b.split\n      visitFndBody b", "start": [36, 1], "end": [44, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Sorry.visitDecl", "code": "def visitDecl (d : Decl) : M Unit := do\n  match d with\n  | .fdecl (f := f) (body := b) .. =>\n    match (\u2190 get).localSorryMap.find? f with\n    | some _ => return ()\n    | none =>\n      match (\u2190 visitFndBody b |>.run) with\n      | .ok _    => return ()\n      | .error g =>\n        modify fun s => {\n          localSorryMap := s.localSorryMap.insert f g\n          modified      := true\n        }\n  | _ => return ()", "start": [46, 1], "end": [59, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Sorry.collect", "code": "partial def collect (decls : Array Decl) : M Unit := do\n  modify fun s => { s with modified := false }\n  decls.forM visitDecl\n  if (\u2190 get).modified then\n    collect decls", "start": [61, 1], "end": [65, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.updateSorryDep", "code": "def updateSorryDep (decls : Array Decl) : CompilerM (Array Decl) := do\n  let (_, s) \u2190 Sorry.collect decls |>.run {}\n  return decls.map fun decl =>\n    match decl with\n    | Decl.fdecl f xs t b _    =>\n      match s.localSorryMap.find? f with\n      | some g => Decl.fdecl f xs t b { sorryDep? := some g }\n      | _ => decl\n    | _ => decl", "start": [69, 1], "end": [77, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/EmitC.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ExportAttr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/NameMangling.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/SimpCase.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Boxing.lean", "lake-packages/lean4/src/lean/Lean/Runtime.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/EmitUtil.lean", "lake-packages/lean4/src/lean/Lean/Compiler/InitAttr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/NormIds.lean"], "premises": [{"full_name": "Lean.IR.EmitC.leanMainFn", "code": "def leanMainFn := \"_lean_main\"", "start": [19, 1], "end": [19, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.Context", "code": "structure Context where\n  env        : Environment\n  modName    : Name\n  jpMap      : JPParamsMap := {}\n  mainFn     : FunId := default\n  mainParams : Array Param := #[]", "start": [21, 1], "end": [26, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.M", "code": "abbrev M := ReaderT Context (EStateM String String)", "start": [28, 1], "end": [28, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.getEnv", "code": "def getEnv : M Environment := Context.env <$> read", "start": [30, 1], "end": [30, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.getModName", "code": "def getModName : M Name := Context.modName <$> read", "start": [31, 1], "end": [31, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.getDecl", "code": "def getDecl (n : Name) : M Decl := do\n  let env \u2190 getEnv\n  match findEnvDecl env n with\n  | some d => pure d\n  | none   => throw s!\"unknown declaration '{n}'\"", "start": [32, 1], "end": [36, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emit", "code": "@[inline] def emit {\u03b1 : Type} [ToString \u03b1] (a : \u03b1) : M Unit :=\n  modify fun out => out ++ toString a", "start": [38, 1], "end": [39, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitLn", "code": "@[inline] def emitLn {\u03b1 : Type} [ToString \u03b1] (a : \u03b1) : M Unit := do\n  emit a; emit \"\\n\"", "start": [41, 1], "end": [42, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitLns", "code": "def emitLns {\u03b1 : Type} [ToString \u03b1] (as : List \u03b1) : M Unit :=\n  as.forM fun a => emitLn a", "start": [44, 1], "end": [45, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.argToCString", "code": "def argToCString (x : Arg) : String :=\n  match x with\n  | Arg.var x => toString x\n  | _         => \"lean_box(0)\"", "start": [47, 1], "end": [50, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitArg", "code": "def emitArg (x : Arg) : M Unit :=\n  emit (argToCString x)", "start": [52, 1], "end": [53, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.toCType", "code": "def toCType : IRType \u2192 String\n  | IRType.float      => \"double\"\n  | IRType.uint8      => \"uint8_t\"\n  | IRType.uint16     => \"uint16_t\"\n  | IRType.uint32     => \"uint32_t\"\n  | IRType.uint64     => \"uint64_t\"\n  | IRType.usize      => \"size_t\"\n  | IRType.object     => \"lean_object*\"\n  | IRType.tobject    => \"lean_object*\"\n  | IRType.irrelevant => \"lean_object*\"\n  | IRType.struct _ _ => panic! \"not implemented yet\"\n  | IRType.union _ _  => panic! \"not implemented yet\"", "start": [55, 1], "end": [66, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.throwInvalidExportName", "code": "def throwInvalidExportName {\u03b1 : Type} (n : Name) : M \u03b1 :=\n  throw s!\"invalid export name '{n}'\"", "start": [68, 1], "end": [69, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.toCName", "code": "def toCName (n : Name) : M String := do\n  let env \u2190 getEnv;\n  match getExportNameFor? env n with\n  | some (.str .anonymous s) => pure s\n  | some _                   => throwInvalidExportName n\n  | none                     => if n == `main then pure leanMainFn else pure n.mangle", "start": [71, 1], "end": [77, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitCName", "code": "def emitCName (n : Name) : M Unit :=\n  toCName n >>= emit", "start": [79, 1], "end": [80, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.toCInitName", "code": "def toCInitName (n : Name) : M String := do\n  let env \u2190 getEnv;\n  match getExportNameFor? env n with\n  | some (.str .anonymous s) => return \"_init_\" ++ s\n  | some _                   => throwInvalidExportName n\n  | none                     => pure (\"_init_\" ++ n.mangle)", "start": [82, 1], "end": [88, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitCInitName", "code": "def emitCInitName (n : Name) : M Unit :=\n  toCInitName n >>= emit", "start": [90, 1], "end": [91, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitFnDeclAux", "code": "def emitFnDeclAux (decl : Decl) (cppBaseName : String) (isExternal : Bool) : M Unit := do\n  let ps := decl.params\n  let env \u2190 getEnv\n  if ps.isEmpty then\n    if isClosedTermName env decl.name then emit \"static \"\n    else if isExternal then emit \"extern \"\n    else emit \"LEAN_EXPORT \"\n  else\n    if !isExternal then emit \"LEAN_EXPORT \"\n  emit (toCType decl.resultType ++ \" \" ++ cppBaseName)\n  unless ps.isEmpty do\n    emit \"(\"\n    let ps := if isExternC env decl.name then ps.filter (fun p => !p.ty.isIrrelevant) else ps\n    if ps.size > closureMaxArgs && isBoxedName decl.name then\n      emit \"lean_object**\"\n    else\n      ps.size.forM fun i => do\n        if i > 0 then emit \", \"\n        emit (toCType ps[i]!.ty)\n    emit \")\"\n  emitLn \";\"", "start": [93, 1], "end": [114, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitFnDecl", "code": "def emitFnDecl (decl : Decl) (isExternal : Bool) : M Unit := do\n  let cppBaseName \u2190 toCName decl.name\n  emitFnDeclAux decl cppBaseName isExternal", "start": [116, 1], "end": [118, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitExternDeclAux", "code": "def emitExternDeclAux (decl : Decl) (cNameStr : String) : M Unit := do\n  let env \u2190 getEnv\n  let extC := isExternC env decl.name\n  emitFnDeclAux decl cNameStr extC", "start": [120, 1], "end": [123, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitFnDecls", "code": "def emitFnDecls : M Unit := do\n  let env \u2190 getEnv\n  let decls := getDecls env\n  let modDecls  : NameSet := decls.foldl (fun s d => s.insert d.name) {}\n  let usedDecls : NameSet := decls.foldl (fun s d => collectUsedDecls env d (s.insert d.name)) {}\n  let usedDecls := usedDecls.toList\n  usedDecls.forM fun n => do\n    let decl \u2190 getDecl n;\n    match getExternNameFor env `c decl.name with\n    | some cName => emitExternDeclAux decl cName\n    | none       => emitFnDecl decl (!modDecls.contains n)", "start": [125, 1], "end": [135, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitMainFn", "code": "def emitMainFn : M Unit := do\n  let d \u2190 getDecl `main\n  match d with\n  | .fdecl (xs := xs) .. => do\n    unless xs.size == 2 || xs.size == 1 do throw \"invalid main function, incorrect arity when generating code\"\n    let env \u2190 getEnv\n    let usesLeanAPI := usesModuleFrom env `Lean\n    if usesLeanAPI then\n       emitLn \"void lean_initialize();\"\n    else\n       emitLn \"void lean_initialize_runtime_module();\";\n    emitLn \"\n  #if defined(WIN32) || defined(_WIN32)\n  #include <windows.h>\n  #endif\n\n  int main(int argc, char ** argv) {\n  #if defined(WIN32) || defined(_WIN32)\n  SetErrorMode(SEM_FAILCRITICALERRORS);\n  #endif\n  lean_object* in; lean_object* res;\";\n    if usesLeanAPI then\n      emitLn \"lean_initialize();\"\n    else\n      emitLn \"lean_initialize_runtime_module();\"\n    let modName \u2190 getModName\n    \n    emitLn \"lean_set_panic_messages(false);\"\n    emitLn (\"res = \" ++ mkModuleInitializationFunctionName modName ++ \"(1 /* builtin */, lean_io_mk_world());\")\n    emitLn \"lean_set_panic_messages(true);\"\n    emitLns [\"lean_io_mark_end_initialization();\",\n             \"if (lean_io_result_is_ok(res)) {\",\n             \"lean_dec_ref(res);\",\n             \"lean_init_task_manager();\"];\n    if xs.size == 2 then\n      emitLns [\"in = lean_box(0);\",\n               \"int i = argc;\",\n               \"while (i > 1) {\",\n               \" lean_object* n;\",\n               \" i               \" n = lean_alloc_ctor(1,2,0); lean_ctor_set(n, 0, lean_mk_string(argv[i])); lean_ctor_set(n, 1, in);\",\n               \" in = n;\",\n              \"}\"]\n      emitLn (\"res = \" ++ leanMainFn ++ \"(in, lean_io_mk_world());\")\n    else\n      emitLn (\"res = \" ++ leanMainFn ++ \"(lean_io_mk_world());\")\n    emitLn \"}\"\n    let retTy := env.find? `main |>.get! |>.type |>.getForallBody\n    let retTy := retTy.appArg!\n    emitLns [\"lean_finalize_task_manager();\",\n             \"if (lean_io_result_is_ok(res)) {\",\n             \"  int ret = \" ++ if retTy.constName? == some ``UInt32 then \"lean_unbox_uint32(lean_io_result_get_value(res));\" else \"0;\",\n             \"  lean_dec_ref(res);\",\n             \"  return ret;\",\n             \"} else {\",\n             \"  lean_io_result_show_error(res);\",\n             \"  lean_dec_ref(res);\",\n             \"  return 1;\",\n             \"}\"]\n    emitLn \"}\"\n  | _     => throw \"function declaration expected\"", "start": [137, 1], "end": [201, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.hasMainFn", "code": "def hasMainFn : M Bool := do\n  let env \u2190 getEnv\n  let decls := getDecls env\n  return decls.any (fun d => d.name == `main)", "start": [203, 1], "end": [206, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitMainFnIfNeeded", "code": "def emitMainFnIfNeeded : M Unit := do\n  if (\u2190 hasMainFn) then emitMainFn", "start": [208, 1], "end": [209, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitFileHeader", "code": "def emitFileHeader : M Unit := do\n  let env \u2190 getEnv\n  let modName \u2190 getModName\n  emitLn \"// Lean compiler output\"\n  emitLn (\"// Module: \" ++ toString modName)\n  emit \"// Imports:\"\n  env.imports.forM fun m => emit (\" \" ++ toString m)\n  emitLn \"\"\n  emitLn \"#include <lean/lean.h>\"\n  emitLns [\n    \"#if defined(__clang__)\",\n    \"#pragma clang diagnostic ignored \\\"-Wunused-parameter\\\"\",\n    \"#pragma clang diagnostic ignored \\\"-Wunused-label\\\"\",\n    \"#elif defined(__GNUC__) && !defined(__CLANG__)\",\n    \"#pragma GCC diagnostic ignored \\\"-Wunused-parameter\\\"\",\n    \"#pragma GCC diagnostic ignored \\\"-Wunused-label\\\"\",\n    \"#pragma GCC diagnostic ignored \\\"-Wunused-but-set-variable\\\"\",\n    \"#endif\",\n    \"#ifdef __cplusplus\",\n    \"extern \\\"C\\\" {\",\n    \"#endif\"\n  ]", "start": [211, 1], "end": [232, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitFileFooter", "code": "def emitFileFooter : M Unit :=\n  emitLns [\n   \"#ifdef __cplusplus\",\n   \"}\",\n   \"#endif\"\n  ]", "start": [234, 1], "end": [239, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.throwUnknownVar", "code": "def throwUnknownVar {\u03b1 : Type} (x : VarId) : M \u03b1 :=\n  throw s!\"unknown variable '{x}'\"", "start": [241, 1], "end": [242, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.getJPParams", "code": "def getJPParams (j : JoinPointId) : M (Array Param) := do\n  let ctx \u2190 read;\n  match ctx.jpMap.find? j with\n  | some ps => pure ps\n  | none    => throw \"unknown join point\"", "start": [244, 1], "end": [248, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.declareVar", "code": "def declareVar (x : VarId) (t : IRType) : M Unit := do\n  emit (toCType t); emit \" \"; emit x; emit \"; \"", "start": [250, 1], "end": [251, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.declareParams", "code": "def declareParams (ps : Array Param) : M Unit :=\n  ps.forM fun p => declareVar p.x p.ty", "start": [253, 1], "end": [254, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.declareVars", "code": "partial def declareVars : FnBody \u2192 Bool \u2192 M Bool\n  | e@(FnBody.vdecl x t _ b), d => do\n    let ctx \u2190 read\n    if isTailCallTo ctx.mainFn e then\n      pure d\n    else\n      declareVar x t; declareVars b true\n  | FnBody.jdecl _ xs _ b,    d => do declareParams xs; declareVars b (d || xs.size > 0)\n  | e,                        d => if e.isTerminal then pure d else declareVars e.body d", "start": [256, 1], "end": [264, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitTag", "code": "def emitTag (x : VarId) (xType : IRType) : M Unit := do\n  if xType.isObj then do\n    emit \"lean_obj_tag(\"; emit x; emit \")\"\n  else\n    emit x", "start": [266, 1], "end": [270, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.isIf", "code": "def isIf (alts : Array Alt) : Option (Nat \u00d7 FnBody \u00d7 FnBody) :=\n  if alts.size != 2 then none\n  else match alts[0]! with\n    | Alt.ctor c b => some (c.cidx, b, alts[1]!.body)\n    | _            => none", "start": [272, 1], "end": [276, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitInc", "code": "def emitInc (x : VarId) (n : Nat) (checkRef : Bool) : M Unit := do\n  emit $\n    if checkRef then (if n == 1 then \"lean_inc\" else \"lean_inc_n\")\n    else (if n == 1 then \"lean_inc_ref\" else \"lean_inc_ref_n\")\n  emit \"(\"; emit x\n  if n != 1 then emit \", \"; emit n\n  emitLn \");\"", "start": [278, 1], "end": [284, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitDec", "code": "def emitDec (x : VarId) (n : Nat) (checkRef : Bool) : M Unit := do\n  emit (if checkRef then \"lean_dec\" else \"lean_dec_ref\");\n  emit \"(\"; emit x;\n  if n != 1 then emit \", \"; emit n\n  emitLn \");\"", "start": [286, 1], "end": [290, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitDel", "code": "def emitDel (x : VarId) : M Unit := do\n  emit \"lean_free_object(\"; emit x; emitLn \");\"", "start": [292, 1], "end": [293, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitSetTag", "code": "def emitSetTag (x : VarId) (i : Nat) : M Unit := do\n  emit \"lean_ctor_set_tag(\"; emit x; emit \", \"; emit i; emitLn \");\"", "start": [295, 1], "end": [296, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitSet", "code": "def emitSet (x : VarId) (i : Nat) (y : Arg) : M Unit := do\n  emit \"lean_ctor_set(\"; emit x; emit \", \"; emit i; emit \", \"; emitArg y; emitLn \");\"", "start": [298, 1], "end": [299, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitOffset", "code": "def emitOffset (n : Nat) (offset : Nat) : M Unit := do\n  if n > 0 then\n    emit \"sizeof(void*)*\"; emit n;\n    if offset > 0 then emit \" + \"; emit offset\n  else\n    emit offset", "start": [301, 1], "end": [306, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitUSet", "code": "def emitUSet (x : VarId) (n : Nat) (y : VarId) : M Unit := do\n  emit \"lean_ctor_set_usize(\"; emit x; emit \", \"; emit n; emit \", \"; emit y; emitLn \");\"", "start": [308, 1], "end": [309, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitSSet", "code": "def emitSSet (x : VarId) (n : Nat) (offset : Nat) (y : VarId) (t : IRType) : M Unit := do\n  match t with\n  | IRType.float  => emit \"lean_ctor_set_float\"\n  | IRType.uint8  => emit \"lean_ctor_set_uint8\"\n  | IRType.uint16 => emit \"lean_ctor_set_uint16\"\n  | IRType.uint32 => emit \"lean_ctor_set_uint32\"\n  | IRType.uint64 => emit \"lean_ctor_set_uint64\"\n  | _             => throw \"invalid instruction\";\n  emit \"(\"; emit x; emit \", \"; emitOffset n offset; emit \", \"; emit y; emitLn \");\"", "start": [311, 1], "end": [319, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitJmp", "code": "def emitJmp (j : JoinPointId) (xs : Array Arg) : M Unit := do\n  let ps \u2190 getJPParams j\n  unless xs.size == ps.size do throw \"invalid goto\"\n  xs.size.forM fun i => do\n    let p := ps[i]!\n    let x := xs[i]!\n    emit p.x; emit \" = \"; emitArg x; emitLn \";\"\n  emit \"goto \"; emit j; emitLn \";\"", "start": [321, 1], "end": [328, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitLhs", "code": "def emitLhs (z : VarId) : M Unit := do\n  emit z; emit \" = \"", "start": [330, 1], "end": [331, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitArgs", "code": "def emitArgs (ys : Array Arg) : M Unit :=\n  ys.size.forM fun i => do\n    if i > 0 then emit \", \"\n    emitArg ys[i]!", "start": [333, 1], "end": [336, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitCtorScalarSize", "code": "def emitCtorScalarSize (usize : Nat) (ssize : Nat) : M Unit := do\n  if usize == 0 then emit ssize\n  else if ssize == 0 then emit \"sizeof(size_t)*\"; emit usize\n  else emit \"sizeof(size_t)*\"; emit usize; emit \" + \"; emit ssize", "start": [338, 1], "end": [341, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitAllocCtor", "code": "def emitAllocCtor (c : CtorInfo) : M Unit := do\n  emit \"lean_alloc_ctor(\"; emit c.cidx; emit \", \"; emit c.size; emit \", \"\n  emitCtorScalarSize c.usize c.ssize; emitLn \");\"", "start": [343, 1], "end": [345, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitCtorSetArgs", "code": "def emitCtorSetArgs (z : VarId) (ys : Array Arg) : M Unit :=\n  ys.size.forM fun i => do\n    emit \"lean_ctor_set(\"; emit z; emit \", \"; emit i; emit \", \"; emitArg ys[i]!; emitLn \");\"", "start": [347, 1], "end": [349, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitCtor", "code": "def emitCtor (z : VarId) (c : CtorInfo) (ys : Array Arg) : M Unit := do\n  emitLhs z;\n  if c.size == 0 && c.usize == 0 && c.ssize == 0 then do\n    emit \"lean_box(\"; emit c.cidx; emitLn \");\"\n  else do\n    emitAllocCtor c; emitCtorSetArgs z ys", "start": [351, 1], "end": [356, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitReset", "code": "def emitReset (z : VarId) (n : Nat) (x : VarId) : M Unit := do\n  emit \"if (lean_is_exclusive(\"; emit x; emitLn \")) {\";\n  n.forM fun i => do\n    emit \" lean_ctor_release(\"; emit x; emit \", \"; emit i; emitLn \");\"\n  emit \" \"; emitLhs z; emit x; emitLn \";\";\n  emitLn \"} else {\";\n  emit \" lean_dec_ref(\"; emit x; emitLn \");\";\n  emit \" \"; emitLhs z; emitLn \"lean_box(0);\";\n  emitLn \"}\"", "start": [358, 1], "end": [366, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitReuse", "code": "def emitReuse (z : VarId) (x : VarId) (c : CtorInfo) (updtHeader : Bool) (ys : Array Arg) : M Unit := do\n  emit \"if (lean_is_scalar(\"; emit x; emitLn \")) {\";\n  emit \" \"; emitLhs z; emitAllocCtor c;\n  emitLn \"} else {\";\n  emit \" \"; emitLhs z; emit x; emitLn \";\";\n  if updtHeader then emit \" lean_ctor_set_tag(\"; emit z; emit \", \"; emit c.cidx; emitLn \");\"\n  emitLn \"}\";\n  emitCtorSetArgs z ys", "start": [368, 1], "end": [375, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitProj", "code": "def emitProj (z : VarId) (i : Nat) (x : VarId) : M Unit := do\n  emitLhs z; emit \"lean_ctor_get(\"; emit x; emit \", \"; emit i; emitLn \");\"", "start": [377, 1], "end": [378, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitUProj", "code": "def emitUProj (z : VarId) (i : Nat) (x : VarId) : M Unit := do\n  emitLhs z; emit \"lean_ctor_get_usize(\"; emit x; emit \", \"; emit i; emitLn \");\"", "start": [380, 1], "end": [381, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitSProj", "code": "def emitSProj (z : VarId) (t : IRType) (n offset : Nat) (x : VarId) : M Unit := do\n  emitLhs z;\n  match t with\n  | IRType.float  => emit \"lean_ctor_get_float\"\n  | IRType.uint8  => emit \"lean_ctor_get_uint8\"\n  | IRType.uint16 => emit \"lean_ctor_get_uint16\"\n  | IRType.uint32 => emit \"lean_ctor_get_uint32\"\n  | IRType.uint64 => emit \"lean_ctor_get_uint64\"\n  | _             => throw \"invalid instruction\"\n  emit \"(\"; emit x; emit \", \"; emitOffset n offset; emitLn \");\"", "start": [383, 1], "end": [392, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.toStringArgs", "code": "def toStringArgs (ys : Array Arg) : List String :=\n  ys.toList.map argToCString", "start": [394, 1], "end": [395, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitSimpleExternalCall", "code": "def emitSimpleExternalCall (f : String) (ps : Array Param) (ys : Array Arg) : M Unit := do\n  emit f; emit \"(\"\n  discard <| ys.size.foldM\n    (fun i (first : Bool) =>\n      if ps[i]!.ty.isIrrelevant then\n        pure first\n      else do\n        unless first do emit \", \"\n        emitArg ys[i]!\n        pure false)\n    true\n  emitLn \");\"\n  pure ()", "start": [397, 1], "end": [410, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitExternCall", "code": "def emitExternCall (f : FunId) (ps : Array Param) (extData : ExternAttrData) (ys : Array Arg) : M Unit :=\n  match getExternEntryFor extData `c with\n  | some (ExternEntry.standard _ extFn) => emitSimpleExternalCall extFn ps ys\n  | some (ExternEntry.inline _ pat)     => do emit (expandExternPattern pat (toStringArgs ys)); emitLn \";\"\n  | some (ExternEntry.foreign _ extFn)  => emitSimpleExternalCall extFn ps ys\n  | _ => throw s!\"failed to emit extern application '{f}'\"", "start": [412, 1], "end": [417, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitFullApp", "code": "def emitFullApp (z : VarId) (f : FunId) (ys : Array Arg) : M Unit := do\n  emitLhs z\n  let decl \u2190 getDecl f\n  match decl with\n  | Decl.extern _ ps _ extData => emitExternCall f ps extData ys\n  | _ =>\n    emitCName f\n    if ys.size > 0 then emit \"(\"; emitArgs ys; emit \")\"\n    emitLn \";\"", "start": [419, 1], "end": [427, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitPartialApp", "code": "def emitPartialApp (z : VarId) (f : FunId) (ys : Array Arg) : M Unit := do\n  let decl \u2190 getDecl f\n  let arity := decl.params.size;\n  emitLhs z; emit \"lean_alloc_closure((void*)(\"; emitCName f; emit \"), \"; emit arity; emit \", \"; emit ys.size; emitLn \");\";\n  ys.size.forM fun i => do\n    let y := ys[i]!\n    emit \"lean_closure_set(\"; emit z; emit \", \"; emit i; emit \", \"; emitArg y; emitLn \");\"", "start": [429, 1], "end": [435, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitApp", "code": "def emitApp (z : VarId) (f : VarId) (ys : Array Arg) : M Unit :=\n  if ys.size > closureMaxArgs then do\n    emit \"{ lean_object* _aargs[] = {\"; emitArgs ys; emitLn \"};\";\n    emitLhs z; emit \"lean_apply_m(\"; emit f; emit \", \"; emit ys.size; emitLn \", _aargs); }\"\n  else do\n    emitLhs z; emit \"lean_apply_\"; emit ys.size; emit \"(\"; emit f; emit \", \"; emitArgs ys; emitLn \");\"", "start": [437, 1], "end": [442, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitBoxFn", "code": "def emitBoxFn (xType : IRType) : M Unit :=\n  match xType with\n  | IRType.usize  => emit \"lean_box_usize\"\n  | IRType.uint32 => emit \"lean_box_uint32\"\n  | IRType.uint64 => emit \"lean_box_uint64\"\n  | IRType.float  => emit \"lean_box_float\"\n  | _             => emit \"lean_box\"", "start": [444, 1], "end": [450, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitBox", "code": "def emitBox (z : VarId) (x : VarId) (xType : IRType) : M Unit := do\n  emitLhs z; emitBoxFn xType; emit \"(\"; emit x; emitLn \");\"", "start": [452, 1], "end": [453, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitUnbox", "code": "def emitUnbox (z : VarId) (t : IRType) (x : VarId) : M Unit := do\n  emitLhs z\n  emit (getUnboxOpName t)\n  emit \"(\"; emit x; emitLn \");\"", "start": [455, 1], "end": [458, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitIsShared", "code": "def emitIsShared (z : VarId) (x : VarId) : M Unit := do\n  emitLhs z; emit \"!lean_is_exclusive(\"; emit x; emitLn \");\"", "start": [460, 1], "end": [461, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.toHexDigit", "code": "def toHexDigit (c : Nat) : String :=\n  String.singleton c.digitChar", "start": [463, 1], "end": [464, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.quoteString", "code": "def quoteString (s : String) : String :=\n  let q := \"\\\"\";\n  let q := s.foldl\n    (fun q c => q ++\n      if c == '\\n' then \"\\\\n\"\n      else if c == '\\r' then \"\\\\r\"\n      else if c == '\\t' then \"\\\\t\"\n      else if c == '\\\\' then \"\\\\\\\\\"\n      else if c == '\\\"' then \"\\\\\\\"\"\n      else if c.toNat <= 31 then\n        \"\\\\x\" ++ toHexDigit (c.toNat / 16) ++ toHexDigit (c.toNat % 16)\n      else String.singleton c)\n    q;\n  q ++ \"\\\"\"", "start": [466, 1], "end": [480, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitNumLit", "code": "def emitNumLit (t : IRType) (v : Nat) : M Unit := do\n  if t.isObj then\n    if v < UInt32.size then\n      emit \"lean_unsigned_to_nat(\"; emit v; emit \"u)\"\n    else\n      emit \"lean_cstr_to_nat(\\\"\"; emit v; emit \"\\\")\"\n  else\n    emit v", "start": [482, 1], "end": [489, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitLit", "code": "def emitLit (z : VarId) (t : IRType) (v : LitVal) : M Unit := do\n  emitLhs z;\n  match v with\n  | LitVal.num v => emitNumLit t v; emitLn \";\"\n  | LitVal.str v => emit \"lean_mk_string_from_bytes(\"; emit (quoteString v); emit \", \"; emit v.utf8ByteSize; emitLn \");\"", "start": [491, 1], "end": [495, 121], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitVDecl", "code": "def emitVDecl (z : VarId) (t : IRType) (v : Expr) : M Unit :=\n  match v with\n  | Expr.ctor c ys      => emitCtor z c ys\n  | Expr.reset n x      => emitReset z n x\n  | Expr.reuse x c u ys => emitReuse z x c u ys\n  | Expr.proj i x       => emitProj z i x\n  | Expr.uproj i x      => emitUProj z i x\n  | Expr.sproj n o x    => emitSProj z t n o x\n  | Expr.fap c ys       => emitFullApp z c ys\n  | Expr.pap c ys       => emitPartialApp z c ys\n  | Expr.ap x ys        => emitApp z x ys\n  | Expr.box t x        => emitBox z x t\n  | Expr.unbox x        => emitUnbox z t x\n  | Expr.isShared x     => emitIsShared z x\n  | Expr.lit v          => emitLit z t v", "start": [497, 1], "end": [511, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.isTailCall", "code": "def isTailCall (x : VarId) (v : Expr) (b : FnBody) : M Bool := do\n  let ctx \u2190 read;\n  match v, b with\n  | Expr.fap f _, FnBody.ret (Arg.var y) => return f == ctx.mainFn && x == y\n  | _, _ => pure false", "start": [513, 1], "end": [517, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.paramEqArg", "code": "def paramEqArg (p : Param) (x : Arg) : Bool :=\n  match x with\n  | Arg.var x => p.x == x\n  | _ => false", "start": [519, 1], "end": [522, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.overwriteParam", "code": "def overwriteParam (ps : Array Param) (ys : Array Arg) : Bool :=\n  let n := ps.size;\n  n.any fun i =>\n    let p := ps[i]!\n    (i+1, n).anyI fun j => paramEqArg p ys[j]!", "start": [524, 1], "end": [543, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitTailCall", "code": "def emitTailCall (v : Expr) : M Unit :=\n  match v with\n  | Expr.fap _ ys => do\n    let ctx \u2190 read\n    let ps := ctx.mainParams\n    unless ps.size == ys.size do throw \"invalid tail call\"\n    if overwriteParam ps ys then\n      emitLn \"{\"\n      ps.size.forM fun i => do\n        let p := ps[i]!\n        let y := ys[i]!\n        unless paramEqArg p y do\n          emit (toCType p.ty); emit \" _tmp_\"; emit i; emit \" = \"; emitArg y; emitLn \";\"\n      ps.size.forM fun i => do\n        let p := ps[i]!\n        let y := ys[i]!\n        unless paramEqArg p y do emit p.x; emit \" = _tmp_\"; emit i; emitLn \";\"\n      emitLn \"}\"\n    else\n      ys.size.forM fun i => do\n        let p := ps[i]!\n        let y := ys[i]!\n        unless paramEqArg p y do emit p.x; emit \" = \"; emitArg y; emitLn \";\"\n    emitLn \"goto _start;\"\n  | _ => throw \"bug at emitTailCall\"", "start": [545, 1], "end": [569, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitIf", "code": "partial def emitIf (x : VarId) (xType : IRType) (tag : Nat) (t : FnBody) (e : FnBody) : M Unit := do\n  emit \"if (\"; emitTag x xType; emit \" == \"; emit tag; emitLn \")\";\n  emitFnBody t;\n  emitLn \"else\";\n  emitFnBody e", "start": [573, 1], "end": [577, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitCase", "code": "partial def emitCase (x : VarId) (xType : IRType) (alts : Array Alt) : M Unit :=\n  match isIf alts with\n  | some (tag, t, e) => emitIf x xType tag t e\n  | _ => do\n    emit \"switch (\"; emitTag x xType; emitLn \") {\";\n    let alts := ensureHasDefault alts;\n    alts.forM fun alt => do\n      match alt with\n      | Alt.ctor c b  => emit \"case \"; emit c.cidx; emitLn \":\"; emitFnBody b\n      | Alt.default b => emitLn \"default: \"; emitFnBody b\n    emitLn \"}\"", "start": [579, 1], "end": [589, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitBlock", "code": "partial def emitBlock (b : FnBody) : M Unit := do\n  match b with\n  | FnBody.jdecl _ _  _ b      => emitBlock b\n  | d@(FnBody.vdecl x t v b)   =>\n    let ctx \u2190 read\n    if isTailCallTo ctx.mainFn d then\n      emitTailCall v\n    else\n      emitVDecl x t v\n      emitBlock b\n  | FnBody.inc x n c p b       =>\n    unless p do emitInc x n c\n    emitBlock b\n  | FnBody.dec x n c p b       =>\n    unless p do emitDec x n c\n    emitBlock b\n  | FnBody.del x b             => emitDel x; emitBlock b\n  | FnBody.setTag x i b        => emitSetTag x i; emitBlock b\n  | FnBody.set x i y b         => emitSet x i y; emitBlock b\n  | FnBody.uset x i y b        => emitUSet x i y; emitBlock b\n  | FnBody.sset x i o y t b    => emitSSet x i o y t; emitBlock b\n  | FnBody.mdata _ b           => emitBlock b\n  | FnBody.ret x               => emit \"return \"; emitArg x; emitLn \";\"\n  | FnBody.case _ x xType alts => emitCase x xType alts\n  | FnBody.jmp j xs            => emitJmp j xs\n  | FnBody.unreachable         => emitLn \"lean_internal_panic_unreachable();\"", "start": [591, 1], "end": [616, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitJPs", "code": "partial def emitJPs : FnBody \u2192 M Unit\n  | FnBody.jdecl j _  v b => do emit j; emitLn \":\"; emitFnBody v; emitJPs b\n  | e                     => do unless e.isTerminal do emitJPs e.body", "start": [618, 1], "end": [620, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitFnBody", "code": "partial def emitFnBody (b : FnBody) : M Unit := do\n  emitLn \"{\"\n  let declared \u2190 declareVars b false\n  if declared then emitLn \"\"\n  emitBlock b\n  emitJPs b\n  emitLn \"}\"", "start": [622, 1], "end": [628, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitDeclAux", "code": "def emitDeclAux (d : Decl) : M Unit := do\n  let env \u2190 getEnv\n  let (_, jpMap) := mkVarJPMaps d\n  withReader (fun ctx => { ctx with jpMap := jpMap }) do\n  unless hasInitAttr env d.name do\n    match d with\n    | .fdecl (f := f) (xs := xs) (type := t) (body := b) .. =>\n      let baseName \u2190 toCName f;\n      if xs.size == 0 then\n        emit \"static \"\n      else\n        emit \"LEAN_EXPORT \"  emit (toCType t); emit \" \";\n      if xs.size > 0 then\n        emit baseName;\n        emit \"(\";\n        if xs.size > closureMaxArgs && isBoxedName d.name then\n          emit \"lean_object** _args\"\n        else\n          xs.size.forM fun i => do\n            if i > 0 then emit \", \"\n            let x := xs[i]!\n            emit (toCType x.ty); emit \" \"; emit x.x\n        emit \")\"\n      else\n        emit (\"_init_\" ++ baseName ++ \"()\")\n      emitLn \" {\";\n      if xs.size > closureMaxArgs && isBoxedName d.name then\n        xs.size.forM fun i => do\n          let x := xs[i]!\n          emit \"lean_object* \"; emit x.x; emit \" = _args[\"; emit i; emitLn \"];\"\n      emitLn \"_start:\";\n      withReader (fun ctx => { ctx with mainFn := f, mainParams := xs }) (emitFnBody b);\n      emitLn \"}\"\n    | _ => pure ()", "start": [632, 1], "end": [666, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitDecl", "code": "def emitDecl (d : Decl) : M Unit := do\n  let d := d.normalizeIds; try\n    emitDeclAux d\n  catch err =>\n    throw s!\"{err}\\ncompiling:\\n{d}\"", "start": [668, 1], "end": [673, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitFns", "code": "def emitFns : M Unit := do\n  let env \u2190 getEnv;\n  let decls := getDecls env;\n  decls.reverse.forM emitDecl", "start": [675, 1], "end": [678, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitMarkPersistent", "code": "def emitMarkPersistent (d : Decl) (n : Name) : M Unit := do\n  if d.resultType.isObj then\n    emit \"lean_mark_persistent(\"\n    emitCName n\n    emitLn \");\"", "start": [680, 1], "end": [684, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitDeclInit", "code": "def emitDeclInit (d : Decl) : M Unit := do\n  let env \u2190 getEnv\n  let n := d.name\n  if isIOUnitInitFn env n then\n    if isIOUnitBuiltinInitFn env n then\n      emit \"if (builtin) {\"\n    emit \"res = \"; emitCName n; emitLn \"(lean_io_mk_world());\"\n    emitLn \"if (lean_io_result_is_error(res)) return res;\"\n    emitLn \"lean_dec_ref(res);\"\n    if isIOUnitBuiltinInitFn env n then\n      emit \"}\"\n  else if d.params.size == 0 then\n    match getInitFnNameFor? env d.name with\n    | some initFn =>\n      if getBuiltinInitFnNameFor? env d.name |>.isSome then\n        emit \"if (builtin) {\"\n      emit \"res = \"; emitCName initFn; emitLn \"(lean_io_mk_world());\"\n      emitLn \"if (lean_io_result_is_error(res)) return res;\"\n      emitCName n\n      if d.resultType.isScalar then\n        emitLn (\" = \" ++ getUnboxOpName d.resultType ++ \"(lean_io_result_get_value(res));\")\n      else\n        emitLn \" = lean_io_result_get_value(res);\"\n        emitMarkPersistent d n\n      emitLn \"lean_dec_ref(res);\"\n      if getBuiltinInitFnNameFor? env d.name |>.isSome then\n        emit \"}\"\n    | _ =>\n      emitCName n; emit \" = \"; emitCInitName n; emitLn \"();\"; emitMarkPersistent d n", "start": [686, 1], "end": [714, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.emitInitFn", "code": "def emitInitFn : M Unit := do\n  let env \u2190 getEnv\n  let modName \u2190 getModName\n  env.imports.forM fun imp => emitLn (\"lean_object* \" ++ mkModuleInitializationFunctionName imp.module ++ \"(uint8_t builtin, lean_object*);\")\n  emitLns [\n    \"static bool _G_initialized = false;\",\n    \"LEAN_EXPORT lean_object* \" ++ mkModuleInitializationFunctionName modName ++ \"(uint8_t builtin, lean_object* w) {\",\n    \"lean_object * res;\",\n    \"if (_G_initialized) return lean_io_result_mk_ok(lean_box(0));\",\n    \"_G_initialized = true;\"\n  ]\n  env.imports.forM fun imp => emitLns [\n    \"res = \" ++ mkModuleInitializationFunctionName imp.module ++ \"(builtin, lean_io_mk_world());\",\n    \"if (lean_io_result_is_error(res)) return res;\",\n    \"lean_dec_ref(res);\"]\n  let decls := getDecls env\n  decls.reverse.forM emitDeclInit\n  emitLns [\"return lean_io_result_mk_ok(lean_box(0));\", \"}\"]", "start": [716, 1], "end": [733, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.EmitC.main", "code": "def main : M Unit := do\n  emitFileHeader\n  emitFnDecls\n  emitFns\n  emitInitFn\n  emitMainFnIfNeeded\n  emitFileFooter", "start": [735, 1], "end": [741, 17], "kind": "commanddeclaration"}, {"full_name": "emitC", "code": "@[export lean_ir_emit_c]\ndef emitC (env : Environment) (modName : Name) : Except String String :=\n  match (EmitC.main { env := env, modName := modName }).run \"\" with\n  | EStateM.Result.ok    _   s => Except.ok s\n  | EStateM.Result.error err _ => Except.error err", "start": [745, 1], "end": [749, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/ResetReuse.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Format.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/LiveVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.ResetReuse.mayReuse", "code": "private def mayReuse (c\u2081 c\u2082 : CtorInfo) : Bool :=\n  c\u2081.size == c\u2082.size && c\u2081.usize == c\u2082.usize && c\u2081.ssize == c\u2082.ssize &&\n  \n  c\u2081.name.getPrefix == c\u2082.name.getPrefix", "start": [28, 1], "end": [33, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.S", "code": "private partial def S (w : VarId) (c : CtorInfo) : FnBody \u2192 FnBody\n  | FnBody.vdecl x t v@(Expr.ctor c' ys) b   =>\n    if mayReuse c c' then\n      let updtCidx := c.cidx != c'.cidx\n      FnBody.vdecl x t (Expr.reuse w c' updtCidx ys) b\n    else\n      FnBody.vdecl x t v (S w c b)\n  | FnBody.jdecl j ys v b   =>\n    let v' := S w c v\n    if v == v' then FnBody.jdecl j ys v (S w c b)\n    else FnBody.jdecl j ys v' b\n  | FnBody.case tid x xType alts    => FnBody.case tid x xType <| alts.map fun alt => alt.modifyBody (S w c)\n  | b =>\n    if b.isTerminal then b\n    else let\n      (instr, b) := b.split\n      instr.setBody (S w c b)", "start": [35, 1], "end": [51, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.M", "code": "abbrev M := ReaderT LocalContext (StateT Index Id)", "start": [53, 1], "end": [54, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.mkFresh", "code": "private def mkFresh : M VarId := do\n  let idx \u2190 getModify (fun n => n + 1)\n  pure { idx := idx }", "start": [56, 1], "end": [58, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.tryS", "code": "private def tryS (x : VarId) (c : CtorInfo) (b : FnBody) : M FnBody := do\n  let w \u2190 mkFresh\n  let b' := S w c b\n  if b == b' then pure b\n  else pure $ FnBody.vdecl w IRType.object (Expr.reset c.size x) b'", "start": [60, 1], "end": [64, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.Dfinalize", "code": "private def Dfinalize (x : VarId) (c : CtorInfo) : FnBody \u00d7 Bool \u2192 M FnBody\n  | (b, true)  => pure b\n  | (b, false) => tryS x c b", "start": [66, 1], "end": [68, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.argsContainsVar", "code": "private def argsContainsVar (ys : Array Arg) (x : VarId) : Bool :=\n  ys.any fun arg => match arg with\n    | Arg.var y => x == y\n    | _         => false", "start": [70, 1], "end": [73, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.isCtorUsing", "code": "private def isCtorUsing (b : FnBody) (x : VarId) : Bool :=\n  match b with\n  | (FnBody.vdecl _ _ (Expr.ctor _ ys) _) => argsContainsVar ys x\n  | _ => false", "start": [75, 1], "end": [78, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.Dmain", "code": "private partial def Dmain (x : VarId) (c : CtorInfo) : FnBody \u2192 M (FnBody \u00d7 Bool)\n  | e@(FnBody.case tid y yType alts) => do\n    let ctx \u2190 read\n    if e.hasLiveVar ctx x then do\n      \n      let alts \u2190 alts.mapM fun alt => alt.mmodifyBody fun b => Dmain x c b >>= Dfinalize x c\n      pure (FnBody.case tid y yType alts, true)\n    else pure (e, false)\n  | FnBody.jdecl j ys v b   => do\n    let (b, found) \u2190 withReader (fun ctx => ctx.addJP j ys v) (Dmain x c b)\n    let (v, _ ) \u2190 Dmain x c v\n    \n    pure (FnBody.jdecl j ys v b, found)\n  | e => do\n    let ctx \u2190 read\n    if e.isTerminal then\n      pure (e, e.hasLiveVar ctx x)\n    else do\n      let (instr, b) := e.split\n      if isCtorUsing instr x then\n        \n        pure (e, true)\n      else\n        let (b, found) \u2190 Dmain x c b\n        \n        if found || !instr.hasFreeVar x then\n          pure (instr.setBody b, found)\n        else\n          let b \u2190 tryS x c b\n          pure (instr.setBody b, true)", "start": [80, 1], "end": [121, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.D", "code": "private def D (x : VarId) (c : CtorInfo) (b : FnBody) : M FnBody :=\n  Dmain x c b >>= Dfinalize x c", "start": [123, 1], "end": [124, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ResetReuse.R", "code": "partial def R : FnBody \u2192 M FnBody\n  | FnBody.case tid x xType alts   => do\n      let alts \u2190 alts.mapM fun alt => do\n        let alt \u2190 alt.mmodifyBody R\n        match alt with\n        | Alt.ctor c b =>\n          if c.isScalar then pure alt\n          else Alt.ctor c <$> D x c b\n        | _            => pure alt\n      pure $ FnBody.case tid x xType alts\n  | FnBody.jdecl j ys v b   => do\n    let v \u2190 R v\n    let b \u2190 withReader (fun ctx => ctx.addJP j ys v) (R b)\n    pure $ FnBody.jdecl j ys v b\n  | e => do\n    if e.isTerminal then pure e\n    else do\n      let (instr, b) := e.split\n      let b \u2190 R b\n      pure (instr.setBody b)", "start": [126, 1], "end": [145, 29], "kind": "commanddeclaration"}, {"full_name": "Decl.insertResetReuse", "code": "def Decl.insertResetReuse (d : Decl) : Decl :=\n  match d with\n  | .fdecl (body := b) ..=>\n    let nextIndex := d.maxIndex + 1\n    let bNew      := (R b {}).run' nextIndex\n    d.updateBody! bNew\n  | other => other", "start": [151, 1], "end": [157, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/ExpandResetReuse.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/NormIds.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/FreeVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.ExpandResetReuse.ProjMap", "code": "abbrev ProjMap  := HashMap VarId Expr", "start": [11, 1], "end": [12, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.CollectProjMap.Collector", "code": "abbrev Collector := ProjMap \u2192 ProjMap", "start": [14, 1], "end": [14, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.CollectProjMap.collectVDecl", "code": "@[inline] def collectVDecl (x : VarId) (v : Expr) : Collector := fun m =>\n  match v with\n  | .proj ..  => m.insert x v\n  | .sproj .. => m.insert x v\n  | .uproj .. => m.insert x v\n  | _         => m", "start": [15, 1], "end": [20, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.CollectProjMap.collectFnBody", "code": "partial def collectFnBody : FnBody \u2192 Collector\n  | .vdecl x _ v b   => collectVDecl x v \u2218 collectFnBody b\n  | .jdecl _ _ v b   => collectFnBody v \u2218 collectFnBody b\n  | .case _ _ _ alts => fun s => alts.foldl (fun s alt => collectFnBody alt.body s) s\n  | e                => if e.isTerminal then id else collectFnBody e.body", "start": [22, 1], "end": [26, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.mkProjMap", "code": "def mkProjMap (d : Decl) : ProjMap :=\n  match d with\n  | .fdecl (body := b) .. => CollectProjMap.collectFnBody b {}\n  | _ => {}", "start": [29, 1], "end": [34, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.Context", "code": "structure Context where\n  projMap : ProjMap", "start": [36, 1], "end": [37, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.consumed", "code": "partial def consumed (x : VarId) : FnBody \u2192 Bool\n  | .vdecl _ _ v b   =>\n    match v with\n    | Expr.reuse y _ _ _ => x == y || consumed x b\n    | _                  => consumed x b\n  | .dec y _ _ _ b   => x == y || consumed x b\n  | .case _ _ _ alts => alts.all fun alt => consumed x alt.body\n  | e => !e.isTerminal && consumed x e.body", "start": [39, 1], "end": [48, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.Mask", "code": "abbrev Mask := Array (Option VarId)", "start": [50, 1], "end": [50, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.eraseProjIncForAux", "code": "partial def eraseProjIncForAux (y : VarId) (bs : Array FnBody) (mask : Mask) (keep : Array FnBody) : Array FnBody \u00d7 Mask :=\n  let done (_ : Unit)        := (bs ++ keep.reverse, mask)\n  let keepInstr (b : FnBody) := eraseProjIncForAux y bs.pop mask (keep.push b)\n  if bs.size < 2 then done ()\n  else\n    let b := bs.back\n    match b with\n    | .vdecl _ _ (.sproj _ _ _) _ => keepInstr b\n    | .vdecl _ _ (.uproj _ _) _   => keepInstr b\n    | .inc z n c p _ =>\n      if n == 0 then done () else\n      let b' := bs[bs.size - 2]!\n      match b' with\n      | .vdecl w _ (.proj i x) _ =>\n        if w == z && y == x then\n          \n          let bs   := bs.pop.pop\n          let mask := mask.set! i (some z)\n          let keep := keep.push b'\n          let keep := if n == 1 then keep else keep.push (FnBody.inc z (n-1) c p FnBody.nil)\n          eraseProjIncForAux y bs mask keep\n        else done ()\n      | _ => done ()\n    | _ => done ()", "start": [52, 1], "end": [82, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.eraseProjIncFor", "code": "def eraseProjIncFor (n : Nat) (y : VarId) (bs : Array FnBody) : Array FnBody \u00d7 Mask :=\n  eraseProjIncForAux y bs (mkArray n none) #[]", "start": [84, 1], "end": [87, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.reuseToCtor", "code": "partial def reuseToCtor (x : VarId) : FnBody \u2192 FnBody\n  | FnBody.dec y n c p b   =>\n    if x == y then b else FnBody.dec y n c p (reuseToCtor x b)\n  | FnBody.vdecl z t v b   =>\n    match v with\n    | Expr.reuse y c _ xs =>\n      if x == y then FnBody.vdecl z t (Expr.ctor c xs) b\n      else FnBody.vdecl z t v (reuseToCtor x b)\n    | _ =>\n      FnBody.vdecl z t v (reuseToCtor x b)\n  | FnBody.case tid y yType alts   =>\n    let alts := alts.map fun alt => alt.modifyBody (reuseToCtor x)\n    FnBody.case tid y yType alts\n  | e =>\n    if e.isTerminal then\n      e\n    else\n      let (instr, b) := e.split\n      let b := reuseToCtor x b\n      instr.setBody b", "start": [89, 1], "end": [110, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.mkSlowPath", "code": "def mkSlowPath (x y : VarId) (mask : Mask) (b : FnBody) : FnBody :=\n  let b := reuseToCtor x b\n  let b := FnBody.dec y 1 true false b\n  mask.foldl (init := b) fun b m => match m with\n      | some z => FnBody.inc z 1 true false b\n      | none   => b", "start": [112, 1], "end": [129, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.M", "code": "abbrev M := ReaderT Context (StateM Nat)", "start": [131, 1], "end": [131, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.mkFresh", "code": "def mkFresh : M VarId :=\n  modifyGet fun n => ({ idx := n }, n + 1)", "start": [132, 3], "end": [133, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.releaseUnreadFields", "code": "def releaseUnreadFields (y : VarId) (mask : Mask) (b : FnBody) : M FnBody :=\n  mask.size.foldM (init := b) fun i b =>\n    match mask.get! i with\n    | some _ => pure b | none   => do\n      let fld \u2190 mkFresh\n      pure (FnBody.vdecl fld IRType.object (Expr.proj i y) (FnBody.dec fld 1 true false b))", "start": [135, 1], "end": [141, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.setFields", "code": "def setFields (y : VarId) (zs : Array Arg) (b : FnBody) : FnBody :=\n  zs.size.fold (init := b) fun i b => FnBody.set y i (zs.get! i) b", "start": [143, 1], "end": [144, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.isSelfSet", "code": "def isSelfSet (ctx : Context) (x : VarId) (i : Nat) (y : Arg) : Bool :=\n  match y with\n  | Arg.var y =>\n    match ctx.projMap.find? y with\n    | some (Expr.proj j w) => j == i && w == x\n    | _ => false\n  | _ => false", "start": [146, 1], "end": [153, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.isSelfUSet", "code": "def isSelfUSet (ctx : Context) (x : VarId) (i : Nat) (y : VarId) : Bool :=\n  match ctx.projMap.find? y with\n  | some (Expr.uproj j w) => j == i && w == x\n  | _                     => false", "start": [155, 1], "end": [159, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.isSelfSSet", "code": "def isSelfSSet (ctx : Context) (x : VarId) (n : Nat) (i : Nat) (y : VarId) : Bool :=\n  match ctx.projMap.find? y with\n  | some (Expr.sproj m j w) => n == m && j == i && w == x\n  | _                       => false", "start": [161, 1], "end": [165, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.removeSelfSet", "code": "partial def removeSelfSet (ctx : Context) : FnBody \u2192 FnBody\n  | FnBody.set x i y b   =>\n    if isSelfSet ctx x i y then removeSelfSet ctx b\n    else FnBody.set x i y (removeSelfSet ctx b)\n  | FnBody.uset x i y b   =>\n    if isSelfUSet ctx x i y then removeSelfSet ctx b\n    else FnBody.uset x i y (removeSelfSet ctx b)\n  | FnBody.sset x n i y t b   =>\n    if isSelfSSet ctx x n i y then removeSelfSet ctx b\n    else FnBody.sset x n i y t (removeSelfSet ctx b)\n  | FnBody.case tid y yType alts   =>\n    let alts := alts.map fun alt => alt.modifyBody (removeSelfSet ctx)\n    FnBody.case tid y yType alts\n  | e =>\n    if e.isTerminal then e\n    else\n      let (instr, b) := e.split\n      let b := removeSelfSet ctx b\n      instr.setBody b", "start": [167, 1], "end": [186, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.reuseToSet", "code": "partial def reuseToSet (ctx : Context) (x y : VarId) : FnBody \u2192 FnBody\n  | FnBody.dec z n c p b   =>\n    if x == z then FnBody.del y b\n    else FnBody.dec z n c p (reuseToSet ctx x y b)\n  | FnBody.vdecl z t v b   =>\n    match v with\n    | Expr.reuse w c u zs =>\n      if x == w then\n        let b := setFields y zs (b.replaceVar z y)\n        let b := if u then FnBody.setTag y c.cidx b else b\n        removeSelfSet ctx b\n      else FnBody.vdecl z t v (reuseToSet ctx x y b)\n    | _ => FnBody.vdecl z t v (reuseToSet ctx x y b)\n  | FnBody.case tid z zType alts   =>\n    let alts := alts.map fun alt => alt.modifyBody (reuseToSet ctx x y)\n    FnBody.case tid z zType alts\n  | e =>\n    if e.isTerminal then e\n    else\n      let (instr, b) := e.split\n      let b := reuseToSet ctx x y b\n      instr.setBody b", "start": [188, 1], "end": [209, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.mkFastPath", "code": "def mkFastPath (x y : VarId) (mask : Mask) (b : FnBody) : M FnBody := do\n  let ctx \u2190 read\n  let b := reuseToSet ctx x y b\n  releaseUnreadFields y mask b", "start": [211, 1], "end": [233, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.expand", "code": "partial def expand (mainFn : FnBody \u2192 Array FnBody \u2192 M FnBody)\n    (bs : Array FnBody) (x : VarId) (n : Nat) (y : VarId) (b : FnBody) : M FnBody := do\n  let (bs, mask) := eraseProjIncFor n y bs\n  \n  let bSlow      := mkSlowPath x y mask b\n  let bFast \u2190 mkFastPath x y mask b\n  \n  let bFast \u2190 mainFn bFast #[]\n  let c \u2190 mkFresh\n  let b := FnBody.vdecl c IRType.uint8 (Expr.isShared y) (mkIf c bSlow bFast)\n  return reshape bs b", "start": [236, 1], "end": [247, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.searchAndExpand", "code": "partial def searchAndExpand : FnBody \u2192 Array FnBody \u2192 M FnBody\n  | d@(FnBody.vdecl x _ (Expr.reset n y) b), bs =>\n    if consumed x b then do\n      expand searchAndExpand bs x n y b\n    else\n      searchAndExpand b (push bs d)\n  | FnBody.jdecl j xs v b,   bs => do\n    let v \u2190 searchAndExpand v #[]\n    searchAndExpand b (push bs (FnBody.jdecl j xs v FnBody.nil))\n  | FnBody.case tid x xType alts,   bs => do\n    let alts \u2190 alts.mapM fun alt => alt.mmodifyBody fun b => searchAndExpand b #[]\n    return reshape bs (FnBody.case tid x xType alts)\n  | b, bs =>\n    if b.isTerminal then return reshape bs b\n    else searchAndExpand b.body (push bs b)", "start": [249, 1], "end": [263, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExpandResetReuse.main", "code": "def main (d : Decl) : Decl :=\n  match d with\n  | .fdecl (body := b) .. =>\n    let m := mkProjMap d\n    let nextIdx := d.maxIndex + 1\n    let bNew := (searchAndExpand b #[] { projMap := m }).run' nextIdx\n    d.updateBody! bNew\n  | d => d", "start": [265, 1], "end": [272, 11], "kind": "commanddeclaration"}, {"full_name": "Decl.expandResetReuse", "code": "def Decl.expandResetReuse (d : Decl) : Decl :=\n  (ExpandResetReuse.main d).normalizeIds", "start": [276, 1], "end": [278, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/RC.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Runtime.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/LiveVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.ExplicitRC.VarInfo", "code": "structure VarInfo where\n  ref        : Bool := true  persistent : Bool := false consume    : Bool := false deriving Inhabited", "start": [16, 1], "end": [20, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.VarMap", "code": "abbrev VarMap := RBMap VarId VarInfo (fun x y => compare x.idx y.idx)", "start": [22, 1], "end": [22, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.Context", "code": "structure Context where\n  env            : Environment\n  decls          : Array Decl\n  varMap         : VarMap := {}\n  jpLiveVarMap   : JPLiveVarMap := {} localCtx       : LocalContext := {}", "start": [24, 1], "end": [29, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.getDecl", "code": "def getDecl (ctx : Context) (fid : FunId) : Decl :=\n  match findEnvDecl' ctx.env fid ctx.decls with\n  | some decl => decl\n  | none      => unreachable!", "start": [31, 1], "end": [34, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.getVarInfo", "code": "def getVarInfo (ctx : Context) (x : VarId) : VarInfo :=\n  match ctx.varMap.find? x with\n  | some info => info\n  | none      => unreachable!", "start": [36, 1], "end": [39, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.getJPParams", "code": "def getJPParams (ctx : Context) (j : JoinPointId) : Array Param :=\n  match ctx.localCtx.getJPParams j with\n  | some ps => ps\n  | none    => unreachable!", "start": [41, 1], "end": [44, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.getJPLiveVars", "code": "def getJPLiveVars (ctx : Context) (j : JoinPointId) : LiveVarSet :=\n  match ctx.jpLiveVarMap.find? j with\n  | some s => s\n  | none   => {}", "start": [46, 1], "end": [49, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.mustConsume", "code": "def mustConsume (ctx : Context) (x : VarId) : Bool :=\n  let info := getVarInfo ctx x\n  info.ref && info.consume", "start": [51, 1], "end": [53, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.addInc", "code": "@[inline] def addInc (ctx : Context) (x : VarId) (b : FnBody) (n := 1) : FnBody :=\n  let info := getVarInfo ctx x\n  if n == 0 then b else FnBody.inc x n true info.persistent b", "start": [55, 1], "end": [57, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.addDec", "code": "@[inline] def addDec (ctx : Context) (x : VarId) (b : FnBody) : FnBody :=\n  let info := getVarInfo ctx x\n  FnBody.dec x 1 true info.persistent b", "start": [59, 1], "end": [61, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.updateRefUsingCtorInfo", "code": "private def updateRefUsingCtorInfo (ctx : Context) (x : VarId) (c : CtorInfo) : Context :=\n  if c.isRef then\n    ctx\n  else\n    let m := ctx.varMap\n    { ctx with\n      varMap := match m.find? x with\n      | some info => m.insert x { info with ref := false } | none      => m }", "start": [63, 1], "end": [71, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.addDecForAlt", "code": "private def addDecForAlt (ctx : Context) (caseLiveVars altLiveVars : LiveVarSet) (b : FnBody) : FnBody :=\n  caseLiveVars.fold (init := b) fun b x =>\n    if !altLiveVars.contains x && mustConsume ctx x then addDec ctx x b else b", "start": [73, 1], "end": [75, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.isFirstOcc", "code": "private def isFirstOcc (xs : Array Arg) (i : Nat) : Bool :=\n  let x := xs[i]!\n  i.all fun j => xs[j]! != x", "start": [77, 1], "end": [80, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.isBorrowParamAux", "code": "private def isBorrowParamAux (x : VarId) (ys : Array Arg) (consumeParamPred : Nat \u2192 Bool) : Bool :=\n  ys.size.any fun i =>\n    let y := ys[i]!\n    match y with\n    | Arg.irrelevant => false\n    | Arg.var y      => x == y && !consumeParamPred i", "start": [82, 1], "end": [89, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.isBorrowParam", "code": "private def isBorrowParam (x : VarId) (ys : Array Arg) (ps : Array Param) : Bool :=\n  isBorrowParamAux x ys fun i => not ps[i]!.borrow", "start": [91, 1], "end": [92, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.getNumConsumptions", "code": "private def getNumConsumptions (x : VarId) (ys : Array Arg) (consumeParamPred : Nat \u2192 Bool) : Nat :=\n  ys.size.fold (init := 0) fun i n =>\n    let y := ys[i]!\n    match y with\n    | Arg.irrelevant => n\n    | Arg.var y      => if x == y && consumeParamPred i then n+1 else n", "start": [94, 1], "end": [104, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.addIncBeforeAux", "code": "private def addIncBeforeAux (ctx : Context) (xs : Array Arg) (consumeParamPred : Nat \u2192 Bool) (b : FnBody) (liveVarsAfter : LiveVarSet) : FnBody :=\n  xs.size.fold (init := b) fun i b =>\n    let x := xs[i]!\n    match x with\n    | Arg.irrelevant => b\n    | Arg.var x =>\n      let info := getVarInfo ctx x\n      if !info.ref || !isFirstOcc xs i then b\n      else\n        let numConsuptions := getNumConsumptions x xs consumeParamPred let numIncs :=\n          if !info.consume ||                     liveVarsAfter.contains x ||          isBorrowParamAux x xs consumeParamPred  then numConsuptions\n          else numConsuptions - 1\n        addInc ctx x b numIncs", "start": [106, 1], "end": [122, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.addIncBefore", "code": "private def addIncBefore (ctx : Context) (xs : Array Arg) (ps : Array Param) (b : FnBody) (liveVarsAfter : LiveVarSet) : FnBody :=\n  addIncBeforeAux ctx xs (fun i => not ps[i]!.borrow) b liveVarsAfter", "start": [124, 1], "end": [125, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.addDecAfterFullApp", "code": "private def addDecAfterFullApp (ctx : Context) (xs : Array Arg) (ps : Array Param) (b : FnBody) (bLiveVars : LiveVarSet) : FnBody :=\nxs.size.fold (init := b) fun i b =>\n  match xs[i]! with\n  | Arg.irrelevant => b\n  | Arg.var x      =>\n    \n    if mustConsume ctx x && isFirstOcc xs i && isBorrowParam x xs ps && !bLiveVars.contains x then\n      addDec ctx x b\n    else b", "start": [127, 1], "end": [139, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.addIncBeforeConsumeAll", "code": "private def addIncBeforeConsumeAll (ctx : Context) (xs : Array Arg) (b : FnBody) (liveVarsAfter : LiveVarSet) : FnBody :=\n  addIncBeforeAux ctx xs (fun _ => true) b liveVarsAfter", "start": [141, 1], "end": [142, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.addDecForDeadParams", "code": "private def addDecForDeadParams (ctx : Context) (ps : Array Param) (b : FnBody) (bLiveVars : LiveVarSet) : FnBody :=\n  ps.foldl (init := b) fun b p =>\n    if !p.borrow && p.ty.isObj && !bLiveVars.contains p.x then addDec ctx p.x b else b", "start": [144, 1], "end": [148, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.isPersistent", "code": "private def isPersistent : Expr \u2192 Bool\n  | Expr.fap _ xs => xs.isEmpty | _             => false", "start": [150, 1], "end": [152, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.consumeExpr", "code": "private def consumeExpr (m : VarMap) : Expr \u2192 Bool\n  | Expr.proj _ x   => match m.find? x with\n    | some info => info.consume\n    | none      => true\n  | _     => true", "start": [154, 1], "end": [159, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.isScalarBoxedInTaggedPtr", "code": "private def isScalarBoxedInTaggedPtr (v : Expr) : Bool :=\n  match v with\n  | Expr.ctor c _           => c.size == 0 && c.ssize == 0 && c.usize == 0\n  | Expr.lit (LitVal.num n) => n \u2264 maxSmallNat\n  | _ => false", "start": [161, 1], "end": [167, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.updateVarInfo", "code": "private def updateVarInfo (ctx : Context) (x : VarId) (t : IRType) (v : Expr) : Context :=\n  { ctx with\n    varMap := ctx.varMap.insert x {\n        ref := t.isObj && !isScalarBoxedInTaggedPtr v,\n        persistent := isPersistent v,\n        consume := consumeExpr ctx.varMap v\n    }\n  }", "start": [169, 1], "end": [176, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.addDecIfNeeded", "code": "private def addDecIfNeeded (ctx : Context) (x : VarId) (b : FnBody) (bLiveVars : LiveVarSet) : FnBody :=\n  if mustConsume ctx x && !bLiveVars.contains x then addDec ctx x b else b", "start": [178, 1], "end": [179, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.processVDecl", "code": "private def processVDecl (ctx : Context) (z : VarId) (t : IRType) (v : Expr) (b : FnBody) (bLiveVars : LiveVarSet) : FnBody \u00d7 LiveVarSet :=\n  let b := match v with\n    | (Expr.ctor _ ys)       => addIncBeforeConsumeAll ctx ys (FnBody.vdecl z t v b) bLiveVars\n    | (Expr.reuse _ _ _ ys)  => addIncBeforeConsumeAll ctx ys (FnBody.vdecl z t v b) bLiveVars\n    | (Expr.proj _ x)        =>\n      let b := addDecIfNeeded ctx x b bLiveVars\n      let b := if (getVarInfo ctx x).consume then addInc ctx z b else b\n      (FnBody.vdecl z t v b)\n    | (Expr.uproj _ x)       => FnBody.vdecl z t v (addDecIfNeeded ctx x b bLiveVars)\n    | (Expr.sproj _ _ x)     => FnBody.vdecl z t v (addDecIfNeeded ctx x b bLiveVars)\n    | (Expr.fap f ys)        =>\n      let ps := (getDecl ctx f).params\n      let b  := addDecAfterFullApp ctx ys ps b bLiveVars\n      let b  := FnBody.vdecl z t v b\n      addIncBefore ctx ys ps b bLiveVars\n    | (Expr.pap _ ys)        => addIncBeforeConsumeAll ctx ys (FnBody.vdecl z t v b) bLiveVars\n    | (Expr.ap x ys)         =>\n      let ysx := ys.push (Arg.var x) addIncBeforeConsumeAll ctx ysx (FnBody.vdecl z t v b) bLiveVars\n    | (Expr.unbox x)         => FnBody.vdecl z t v (addDecIfNeeded ctx x b bLiveVars)\n    | _                      => FnBody.vdecl z t v b  let liveVars := updateLiveVars v bLiveVars\n  let liveVars := liveVars.erase z\n  (b, liveVars)", "start": [181, 1], "end": [204, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.updateVarInfoWithParams", "code": "def updateVarInfoWithParams (ctx : Context) (ps : Array Param) : Context :=\n  let m := ps.foldl (init := ctx.varMap) fun m p =>\n    m.insert p.x { ref := p.ty.isObj, consume := !p.borrow }\n  { ctx with varMap := m }", "start": [206, 1], "end": [209, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.visitFnBody", "code": "partial def visitFnBody : FnBody \u2192 Context \u2192 (FnBody \u00d7 LiveVarSet)\n  | FnBody.vdecl x t v b,      ctx =>\n    let ctx := updateVarInfo ctx x t v\n    let (b, bLiveVars) := visitFnBody b ctx\n    processVDecl ctx x t v b bLiveVars\n  | FnBody.jdecl j xs v b,     ctx =>\n    let ctxAtV := updateVarInfoWithParams ctx xs\n    let (v, vLiveVars) := visitFnBody v ctxAtV\n    let v   := addDecForDeadParams ctxAtV xs v vLiveVars\n    let ctx := { ctx with\n      localCtx     := ctx.localCtx.addJP j xs v\n      jpLiveVarMap := updateJPLiveVarMap j xs v ctx.jpLiveVarMap\n    }\n    let (b, bLiveVars) := visitFnBody b ctx\n    (FnBody.jdecl j xs v b, bLiveVars)\n  | FnBody.uset x i y b,       ctx =>\n    let (b, s) := visitFnBody b ctx\n    let s      := s.insert x\n    (FnBody.uset x i y b, s)\n  | FnBody.sset x i o y t b,   ctx =>\n    let (b, s) := visitFnBody b ctx\n    let s      := s.insert x\n    (FnBody.sset x i o y t b, s)\n  | FnBody.mdata m b,          ctx =>\n    let (b, s) := visitFnBody b ctx\n    (FnBody.mdata m b, s)\n  | b@(FnBody.case tid x xType alts), ctx =>\n    let caseLiveVars := collectLiveVars b ctx.jpLiveVarMap\n    let alts         := alts.map fun alt => match alt with\n      | Alt.ctor c b  =>\n        let ctx              := updateRefUsingCtorInfo ctx x c\n        let (b, altLiveVars) := visitFnBody b ctx\n        let b                := addDecForAlt ctx caseLiveVars altLiveVars b\n        Alt.ctor c b\n      | Alt.default b =>\n        let (b, altLiveVars) := visitFnBody b ctx\n        let b                := addDecForAlt ctx caseLiveVars altLiveVars b\n        Alt.default b\n    (FnBody.case tid x xType alts, caseLiveVars)\n  | b@(FnBody.ret x), ctx =>\n    match x with\n    | Arg.var x =>\n      let info := getVarInfo ctx x\n      if info.ref && !info.consume then (addInc ctx x b, mkLiveVarSet x) else (b, mkLiveVarSet x)\n    | _         => (b, {})\n  | b@(FnBody.jmp j xs), ctx =>\n    let jLiveVars := getJPLiveVars ctx j\n    let ps        := getJPParams ctx j\n    let b         := addIncBefore ctx xs ps b jLiveVars\n    let bLiveVars := collectLiveVars b ctx.jpLiveVarMap\n    (b, bLiveVars)\n  | FnBody.unreachable, _ => (FnBody.unreachable, {})\n  | other, _ => (other, {})", "start": [211, 1], "end": [265, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.ExplicitRC.visitDecl", "code": "partial def visitDecl (env : Environment) (decls : Array Decl) (d : Decl) : Decl :=\n  match d with\n  | .fdecl (xs := xs) (body := b) .. =>\n    let ctx : Context  := { env := env, decls := decls }\n    let ctx := updateVarInfoWithParams ctx xs\n    let (b, bLiveVars) := visitFnBody b ctx\n    let b := addDecForDeadParams ctx xs b bLiveVars\n    d.updateBody! b\n  | other => other", "start": [267, 1], "end": [275, 19], "kind": "commanddeclaration"}, {"full_name": "explicitRC", "code": "def explicitRC (decls : Array Decl) : CompilerM (Array Decl) := do\n  let env \u2190 getEnv\n  return decls.map (ExplicitRC.visitDecl env decls)", "start": [279, 1], "end": [281, 52], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/PushProj.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/NormIds.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/FreeVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.pushProjs", "code": "partial def pushProjs (bs : Array FnBody) (alts : Array Alt) (altsF : Array IndexSet) (ctx : Array FnBody) (ctxF : IndexSet) : Array FnBody \u00d7 Array Alt :=\n  if bs.isEmpty then (ctx.reverse, alts)\n  else\n    let b    := bs.back\n    let bs   := bs.pop\n    let done (_ : Unit) := (bs.push b ++ ctx.reverse, alts)\n    let skip (_ : Unit) := pushProjs bs alts altsF (ctx.push b) (b.collectFreeIndices ctxF)\n    let push (x : VarId) :=\n        if !ctxF.contains x.idx then\n          let alts := alts.mapIdx fun i alt => alt.modifyBody fun b' =>\n             if (altsF.get! i).contains x.idx then b.setBody b'\n             else b'\n          let altsF  := altsF.map fun s => if s.contains x.idx then b.collectFreeIndices s else s\n          pushProjs bs alts altsF ctx ctxF\n        else\n          skip ()\n    match b with\n    | FnBody.vdecl x _ v _ =>\n      match v with\n      | Expr.proj _ _      => push x\n      | Expr.uproj _ _     => push x\n      | Expr.sproj _ _ _   => push x\n      | Expr.isShared _    => skip ()\n      | _                  => done ()\n    | _ => done ()", "start": [12, 1], "end": [36, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.pushProj", "code": "partial def FnBody.pushProj (b : FnBody) : FnBody :=\n  let (bs, term) := b.flatten\n  let bs         := modifyJPs bs pushProj\n  match term with\n  | .case tid x xType alts =>\n    let altsF      := alts.map fun alt => alt.body.freeIndices\n    let (bs, alts) := pushProjs bs alts altsF #[] (mkIndexSet x.idx)\n    let alts       := alts.map fun alt => alt.modifyBody pushProj\n    let term       := FnBody.case tid x xType alts\n    reshape bs term\n  | _     => reshape bs term", "start": [38, 1], "end": [48, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.pushProj", "code": "def Decl.pushProj (d : Decl) : Decl :=\n  match d with\n  | .fdecl (body := b) .. => d.updateBody! b.pushProj |>.normalizeIds\n  | other => other", "start": [50, 1], "end": [54, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/Borrow.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/NormIds.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ExportAttr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.Borrow.OwnedSet.Key", "code": "abbrev Key := FunId \u00d7 Index", "start": [15, 1], "end": [15, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.OwnedSet.beq", "code": "def beq : Key \u2192 Key \u2192 Bool\n  | (f\u2081, x\u2081), (f\u2082, x\u2082) => f\u2081 == f\u2082 && x\u2081 == x\u2082", "start": [17, 1], "end": [18, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.OwnedSet.getHash", "code": "def getHash : Key \u2192 UInt64\n  | (f, x) => mixHash (hash f) (hash x)", "start": [22, 1], "end": [23, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.OwnedSet", "code": "abbrev OwnedSet := HashMap Key Unit", "start": [28, 1], "end": [28, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.OwnedSet.insert", "code": "def OwnedSet.insert (s : OwnedSet) (k : OwnedSet.Key) : OwnedSet := HashMap.insert s k ()", "start": [29, 1], "end": [29, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.OwnedSet.contains", "code": "def OwnedSet.contains (s : OwnedSet) (k : OwnedSet.Key) : Bool   := HashMap.contains s k", "start": [30, 1], "end": [30, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ParamMap.Key", "code": "inductive Key where\n  | decl (name : FunId)\n  | jp   (name : FunId) (jpid : JoinPointId)\n  deriving BEq", "start": [38, 1], "end": [41, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ParamMap.getHash", "code": "def getHash : Key \u2192 UInt64\n  | Key.decl n  => hash n\n  | Key.jp n id => mixHash (hash n) (hash id)", "start": [43, 1], "end": [45, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ParamMap", "code": "abbrev ParamMap := HashMap Key (Array Param)", "start": [51, 1], "end": [51, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ParamMap.fmt", "code": "def ParamMap.fmt (map : ParamMap) : Format :=\n  let fmts := map.fold (fun fmt k ps =>\n    let k := match k with\n      | ParamMap.Key.decl n  => format n\n      | ParamMap.Key.jp n id => format n ++ \":\" ++ format id\n    fmt ++ Format.line ++ k ++ \" -> \" ++ formatParams ps)\n   Format.nil\n  \"{\" ++ (Format.nest 1 fmts) ++ \"}\"", "start": [53, 1], "end": [60, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.InitParamMap.initBorrow", "code": "def initBorrow (ps : Array Param) : Array Param :=\n  ps.map fun p => { p with borrow := p.ty.isObj }", "start": [66, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.InitParamMap.initBorrowIfNotExported", "code": "def initBorrowIfNotExported (exported : Bool) (ps : Array Param) : Array Param :=\n  if exported then ps else initBorrow ps", "start": [70, 1], "end": [78, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.InitParamMap.visitFnBody", "code": "partial def visitFnBody (fnid : FunId) : FnBody \u2192 StateM ParamMap Unit\n  | FnBody.jdecl j xs v b  => do\n    modify fun m => m.insert (ParamMap.Key.jp fnid j) (initBorrow xs)\n    visitFnBody fnid v\n    visitFnBody fnid b\n  | FnBody.case _ _ _ alts => alts.forM fun alt => visitFnBody fnid alt.body\n  | e => do\n    unless e.isTerminal do\n      let (_, b) := e.split\n      visitFnBody fnid b", "start": [80, 1], "end": [89, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.InitParamMap.visitDecls", "code": "def visitDecls (env : Environment) (decls : Array Decl) : StateM ParamMap Unit :=\n  decls.forM fun decl => match decl with\n    | .fdecl (f := f) (xs := xs) (body := b) .. => do\n      let exported := isExport env f\n      modify fun m => m.insert (ParamMap.Key.decl f) (initBorrowIfNotExported exported xs)\n      visitFnBody f b\n    | _ => pure ()", "start": [91, 1], "end": [97, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.mkInitParamMap", "code": "def mkInitParamMap (env : Environment) (decls : Array Decl) : ParamMap :=\n(InitParamMap.visitDecls env decls *> get).run' {}", "start": [100, 1], "end": [101, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ApplyParamMap.visitFnBody", "code": "partial def visitFnBody (fn : FunId) (paramMap : ParamMap) : FnBody \u2192 FnBody\n  | FnBody.jdecl j _  v b =>\n    let v := visitFnBody fn paramMap v\n    let b := visitFnBody fn paramMap b\n    match paramMap.find? (ParamMap.Key.jp fn j) with\n    | some ys => FnBody.jdecl j ys v b\n    | none    => unreachable!\n  | FnBody.case tid x xType alts =>\n    FnBody.case tid x xType <| alts.map fun alt => alt.modifyBody (visitFnBody fn paramMap)\n  | e =>\n    if e.isTerminal then e\n    else\n      let (instr, b) := e.split\n      let b := visitFnBody fn paramMap b\n      instr.setBody b", "start": [107, 1], "end": [121, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ApplyParamMap.visitDecls", "code": "def visitDecls (decls : Array Decl) (paramMap : ParamMap) : Array Decl :=\n  decls.map fun decl => match decl with\n    | Decl.fdecl f _  ty b info =>\n      let b := visitFnBody f paramMap b\n      match paramMap.find? (ParamMap.Key.decl f) with\n      | some xs => Decl.fdecl f xs ty b info\n      | none    => unreachable!\n    | other => other", "start": [123, 1], "end": [130, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.applyParamMap", "code": "def applyParamMap (decls : Array Decl) (map : ParamMap) : Array Decl :=\n  ApplyParamMap.visitDecls decls map", "start": [134, 1], "end": [135, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.BorrowInfCtx", "code": "structure BorrowInfCtx where\n  env      : Environment\n  decls    : Array Decl  currFn   : FunId    := default paramSet : IndexSet := {}", "start": [137, 1], "end": [141, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.BorrowInfState", "code": "structure BorrowInfState where\n  \n  owned    : OwnedSet := {}\n  modified : Bool     := false\n  paramMap : ParamMap", "start": [143, 1], "end": [147, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.M", "code": "abbrev M := ReaderT BorrowInfCtx (StateM BorrowInfState)", "start": [149, 1], "end": [149, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.getCurrFn", "code": "def getCurrFn : M FunId := do\n  let ctx \u2190 read\n  pure ctx.currFn", "start": [151, 1], "end": [153, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.markModified", "code": "def markModified : M Unit :=\n  modify fun s => { s with modified := true }", "start": [155, 1], "end": [156, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ownVar", "code": "def ownVar (x : VarId) : M Unit := do\n  let currFn \u2190 getCurrFn\n  modify fun s =>\n    if s.owned.contains (currFn, x.idx) then s\n    else { s with owned := s.owned.insert (currFn, x.idx), modified := true }", "start": [158, 1], "end": [162, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ownArg", "code": "def ownArg (x : Arg) : M Unit :=\n  match x with\n  | Arg.var x => ownVar x\n  | _         => pure ()", "start": [164, 1], "end": [167, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ownArgs", "code": "def ownArgs (xs : Array Arg) : M Unit :=\n  xs.forM ownArg", "start": [169, 1], "end": [170, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.isOwned", "code": "def isOwned (x : VarId) : M Bool := do\n  let currFn \u2190 getCurrFn\n  let s      \u2190 get\n  return s.owned.contains (currFn, x.idx)", "start": [172, 1], "end": [175, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.updateParamMap", "code": "def updateParamMap (k : ParamMap.Key) : M Unit := do\n  let s \u2190 get\n  match s.paramMap.find? k with\n  | some ps => do\n    let ps \u2190 ps.mapM fun (p : Param) => do\n      if !p.borrow then pure p\n      else if (\u2190 isOwned p.x) then\n        markModified\n        pure { p with borrow := false }\n      else\n        pure p\n    modify fun s => { s with paramMap := s.paramMap.insert k ps }\n  | none    => pure ()", "start": [177, 1], "end": [190, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.getParamInfo", "code": "def getParamInfo (k : ParamMap.Key) : M (Array Param) := do\n  let s \u2190 get\n  match s.paramMap.find? k with\n  | some ps => pure ps\n  | none    =>\n    match k with\n    | ParamMap.Key.decl fn => do\n      let ctx \u2190 read\n      match findEnvDecl ctx.env fn with\n      | some decl => pure decl.params\n      | none      => unreachable!\n    | _ => unreachable!", "start": [192, 1], "end": [203, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ownArgsUsingParams", "code": "def ownArgsUsingParams (xs : Array Arg) (ps : Array Param) : M Unit :=\n  xs.size.forM fun i => do\n    let x := xs[i]!\n    let p := ps[i]!\n    unless p.borrow do ownArg x", "start": [205, 1], "end": [210, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ownParamsUsingArgs", "code": "def ownParamsUsingArgs (xs : Array Arg) (ps : Array Param) : M Unit :=\n  xs.size.forM fun i => do\n    let x := xs[i]!\n    let p := ps[i]!\n    match x with\n    | Arg.var x => if (\u2190 isOwned x) then ownVar p.x\n    | _         => pure ()", "start": [212, 1], "end": [223, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.ownArgsIfParam", "code": "def ownArgsIfParam (xs : Array Arg) : M Unit := do\n  let ctx \u2190 read\n  xs.forM fun x => do\n    match x with\n    | Arg.var x => if ctx.paramSet.contains x.idx then ownVar x\n    | _ => pure ()", "start": [225, 1], "end": [240, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.collectExpr", "code": "def collectExpr (z : VarId) : Expr \u2192 M Unit\n  | Expr.reset _ x      => ownVar z *> ownVar x\n  | Expr.reuse x _ _ ys => ownVar z *> ownVar x *> ownArgsIfParam ys\n  | Expr.ctor _ xs      => ownVar z *> ownArgsIfParam xs\n  | Expr.proj _ x       => do\n    if (\u2190 isOwned x) then ownVar z\n    if (\u2190 isOwned z) then ownVar x\n  | Expr.fap g xs       => do\n    let ps \u2190 getParamInfo (ParamMap.Key.decl g)\n    ownVar z *> ownArgsUsingParams xs ps\n  | Expr.ap x ys        => ownVar z *> ownVar x *> ownArgs ys\n  | Expr.pap _ xs       => ownVar z *> ownArgs xs\n  | _                   => pure ()", "start": [242, 1], "end": [254, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.preserveTailCall", "code": "def preserveTailCall (x : VarId) (v : Expr) (b : FnBody) : M Unit := do\n  let ctx \u2190 read\n  match v, b with\n  | (Expr.fap g ys), (FnBody.ret (Arg.var z)) =>\n    if ctx.decls.any (\u00b7.name == g) && x == z then\n      let ps \u2190 getParamInfo (ParamMap.Key.decl g)\n      ownParamsUsingArgs ys ps\n  | _, _ => pure ()", "start": [256, 1], "end": [263, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.updateParamSet", "code": "def updateParamSet (ctx : BorrowInfCtx) (ps : Array Param) : BorrowInfCtx :=\n  { ctx with paramSet := ps.foldl (fun s p => s.insert p.x.idx) ctx.paramSet }", "start": [265, 1], "end": [266, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.collectFnBody", "code": "partial def collectFnBody : FnBody \u2192 M Unit\n  | FnBody.jdecl j ys v b => do\n    withReader (fun ctx => updateParamSet ctx ys) (collectFnBody v)\n    let ctx \u2190 read\n    updateParamMap (ParamMap.Key.jp ctx.currFn j)\n    collectFnBody b\n  | FnBody.vdecl x _ v b => collectFnBody b *> collectExpr x v *> preserveTailCall x v b\n  | FnBody.jmp j ys      => do\n    let ctx \u2190 read\n    let ps \u2190 getParamInfo (ParamMap.Key.jp ctx.currFn j)\n    ownArgsUsingParams ys ps ownParamsUsingArgs ys ps  | FnBody.case _ _ _ alts => alts.forM fun alt => collectFnBody alt.body\n  | e                      => do unless e.isTerminal do collectFnBody e.body", "start": [268, 1], "end": [281, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.collectDecl", "code": "partial def collectDecl : Decl \u2192 M Unit\n  | .fdecl (f := f) (xs := ys) (body := b) .. =>\n    withReader (fun ctx => let ctx := updateParamSet ctx ys; { ctx with currFn := f }) do\n      collectFnBody b\n      updateParamMap (ParamMap.Key.decl f)\n  | _ => pure ()", "start": [283, 1], "end": [288, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.whileModifing", "code": "partial def whileModifing (x : M Unit) : M Unit := do\n  modify fun s => { s with modified := false }\n  x\n  let s \u2190 get\n  if s.modified then\n    whileModifing x\n  else\n    pure ()", "start": [290, 1], "end": [298, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.collectDecls", "code": "def collectDecls : M ParamMap := do\n  whileModifing ((\u2190 read).decls.forM collectDecl)\n  let s \u2190 get\n  pure s.paramMap", "start": [300, 1], "end": [303, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Borrow.infer", "code": "def infer (env : Environment) (decls : Array Decl) : ParamMap :=\n  collectDecls { env, decls } |>.run' { paramMap := mkInitParamMap env decls }", "start": [305, 1], "end": [306, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.inferBorrow", "code": "def inferBorrow (decls : Array Decl) : CompilerM (Array Decl) := do\n  let env \u2190 getEnv\n  let paramMap := Borrow.infer env decls\n  pure (Borrow.applyParamMap decls paramMap)", "start": [310, 1], "end": [313, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/UnboxResult.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Format.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.UnboxResult.hasUnboxAttr", "code": "def hasUnboxAttr (env : Environment) (n : Name) : Bool :=\nunboxAttr.hasTag env n", "start": [20, 1], "end": [21, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/Checker.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Format.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.Checker.getMaxCtorFields", "code": "@[extern \"lean_get_max_ctor_fields\"]\nopaque getMaxCtorFields : Unit \u2192 Nat", "start": [11, 1], "end": [12, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.maxCtorFields", "code": "def maxCtorFields := getMaxCtorFields ()", "start": [13, 1], "end": [13, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.getMaxCtorScalarsSize", "code": "@[extern \"lean_get_max_ctor_scalars_size\"]\nopaque getMaxCtorScalarsSize : Unit \u2192 Nat", "start": [15, 1], "end": [16, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.maxCtorScalarsSize", "code": "def maxCtorScalarsSize := getMaxCtorScalarsSize ()", "start": [17, 1], "end": [17, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.getMaxCtorTag", "code": "@[extern \"lean_get_max_ctor_tag\"]\nopaque getMaxCtorTag : Unit \u2192 Nat", "start": [19, 1], "end": [20, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.maxCtorTag", "code": "def maxCtorTag := getMaxCtorTag ()", "start": [21, 1], "end": [21, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.getUSizeSize", "code": "@[extern \"lean_get_usize_size\"]\nopaque getUSizeSize : Unit \u2192 Nat", "start": [23, 1], "end": [24, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.usizeSize", "code": "def usizeSize := getUSizeSize ()", "start": [25, 1], "end": [25, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.CheckerContext", "code": "structure CheckerContext where\n  env : Environment\n  localCtx : LocalContext := {}\n  decls : Array Decl", "start": [27, 1], "end": [30, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.CheckerState", "code": "structure CheckerState where\n  foundVars : IndexSet := {}", "start": [32, 1], "end": [33, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.M", "code": "abbrev M := ReaderT CheckerContext (ExceptT String (StateT CheckerState Id))", "start": [35, 1], "end": [35, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.markIndex", "code": "def markIndex (i : Index) : M Unit := do\n  let s \u2190 get\n  if s.foundVars.contains i then\n    throw s!\"variable / joinpoint index {i} has already been used\"\n  modify fun s => { s with foundVars := s.foundVars.insert i }", "start": [37, 1], "end": [41, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.markVar", "code": "def markVar (x : VarId) : M Unit :=\n  markIndex x.idx", "start": [43, 1], "end": [44, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.markJP", "code": "def markJP (j : JoinPointId) : M Unit :=\n  markIndex j.idx", "start": [46, 1], "end": [47, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.getDecl", "code": "def getDecl (c : Name) : M Decl := do\n  let ctx \u2190 read\n  match findEnvDecl' ctx.env c ctx.decls with\n  | none   => throw s!\"unknown declaration '{c}'\"\n  | some d => pure d", "start": [49, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkVar", "code": "def checkVar (x : VarId) : M Unit := do\n  let ctx \u2190 read\n  unless ctx.localCtx.isLocalVar x.idx || ctx.localCtx.isParam x.idx do\n   throw s!\"unknown variable '{x}'\"", "start": [55, 1], "end": [58, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkJP", "code": "def checkJP (j : JoinPointId) : M Unit := do\n  let ctx \u2190 read\n  unless ctx.localCtx.isJP j.idx do\n   throw s!\"unknown join point '{j}'\"", "start": [60, 1], "end": [63, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkArg", "code": "def checkArg (a : Arg) : M Unit :=\n  match a with\n  | Arg.var x => checkVar x\n  | _ => pure ()", "start": [65, 1], "end": [68, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkArgs", "code": "def checkArgs (as : Array Arg) : M Unit :=\n  as.forM checkArg", "start": [70, 1], "end": [71, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkEqTypes", "code": "@[inline] def checkEqTypes (ty\u2081 ty\u2082 : IRType) : M Unit := do\n  unless ty\u2081 == ty\u2082 do\n    throw \"unexpected type '{ty\u2081}' != '{ty\u2082}'\"", "start": [73, 1], "end": [75, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkType", "code": "@[inline] def checkType (ty : IRType) (p : IRType \u2192 Bool) (suffix? : Option String := none): M Unit := do\n  unless p ty do\n   let mut msg := s!\"unexpected type '{ty}'\"\n   if let some suffix := suffix? then\n     msg := s!\"{msg}, {suffix}\"\n   throw msg", "start": [77, 1], "end": [82, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkObjType", "code": "def checkObjType (ty : IRType) : M Unit := checkType ty IRType.isObj \"object expected\"", "start": [84, 1], "end": [84, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkScalarType", "code": "def checkScalarType (ty : IRType) : M Unit := checkType ty IRType.isScalar \"scalar expected\"", "start": [86, 1], "end": [86, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.getType", "code": "def getType (x : VarId) : M IRType := do\n  let ctx \u2190 read\n  match ctx.localCtx.getType x with\n  | some ty => pure ty\n  | none    => throw s!\"unknown variable '{x}'\"", "start": [88, 1], "end": [92, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkVarType", "code": "@[inline] def checkVarType (x : VarId) (p : IRType \u2192 Bool) (suffix? : Option String := none) : M Unit := do\n  let ty \u2190 getType x; checkType ty p suffix?", "start": [94, 1], "end": [95, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkObjVar", "code": "def checkObjVar (x : VarId) : M Unit :=\n  checkVarType x IRType.isObj \"object expected\"", "start": [97, 1], "end": [98, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkScalarVar", "code": "def checkScalarVar (x : VarId) : M Unit :=\n  checkVarType x IRType.isScalar \"scalar expected\"", "start": [100, 1], "end": [101, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkFullApp", "code": "def checkFullApp (c : FunId) (ys : Array Arg) : M Unit := do\n  let decl \u2190 getDecl c\n  unless ys.size == decl.params.size do\n    throw s!\"incorrect number of arguments to '{c}', {ys.size} provided, {decl.params.size} expected\"\n  checkArgs ys", "start": [103, 1], "end": [107, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkPartialApp", "code": "def checkPartialApp (c : FunId) (ys : Array Arg) : M Unit := do\n  let decl \u2190 getDecl c\n  unless ys.size < decl.params.size do\n    throw s!\"too many arguments too partial application '{c}', num. args: {ys.size}, arity: {decl.params.size}\"\n  checkArgs ys", "start": [109, 1], "end": [113, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkExpr", "code": "def checkExpr (ty : IRType) : Expr \u2192 M Unit\n  | Expr.pap f ys           => checkPartialApp f ys *> checkObjType ty | Expr.ap x ys            => checkObjVar x *> checkArgs ys\n  | Expr.fap f ys           => checkFullApp f ys\n  | Expr.ctor c ys          => do\n    if c.cidx > maxCtorTag && (c.size > 0 || c.usize > 0 || c.ssize > 0) then\n      throw s!\"tag for constructor '{c.name}' is too big, this is a limitation of the current runtime\"\n    if c.size > maxCtorFields then\n      throw s!\"constructor '{c.name}' has too many fields\"\n    if c.ssize + c.usize * usizeSize > maxCtorScalarsSize then\n      throw s!\"constructor '{c.name}' has too many scalar fields\"\n    if !ty.isStruct && !ty.isUnion && c.isRef then\n      (checkObjType ty) *> checkArgs ys\n  | Expr.reset _ x          => checkObjVar x *> checkObjType ty\n  | Expr.reuse x _ _ ys     => checkObjVar x *> checkArgs ys *> checkObjType ty\n  | Expr.box xty x          => checkObjType ty *> checkScalarVar x *> checkVarType x (fun t => t == xty)\n  | Expr.unbox x            => checkScalarType ty *> checkObjVar x\n  | Expr.proj i x           => do\n    let xType \u2190 getType x;\n    match xType with\n    | IRType.object       => checkObjType ty\n    | IRType.tobject      => checkObjType ty\n    | IRType.struct _ tys => if h : i < tys.size then checkEqTypes (tys.get \u27e8i,h\u27e9) ty else throw \"invalid proj index\"\n    | IRType.union _ tys  => if h : i < tys.size then checkEqTypes (tys.get \u27e8i,h\u27e9) ty else throw \"invalid proj index\"\n    | _                   => throw s!\"unexpected IR type '{xType}'\"\n  | Expr.uproj _ x          => checkObjVar x *> checkType ty (fun t => t == IRType.usize)\n  | Expr.sproj _ _ x        => checkObjVar x *> checkScalarType ty\n  | Expr.isShared x         => checkObjVar x *> checkType ty (fun t => t == IRType.uint8)\n  | Expr.lit (LitVal.str _) => checkObjType ty\n  | Expr.lit _              => pure ()", "start": [115, 1], "end": [144, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.withParams", "code": "@[inline] def withParams (ps : Array Param) (k : M Unit) : M Unit := do\n  let ctx \u2190 read\n  let localCtx \u2190 ps.foldlM (init := ctx.localCtx) fun (ctx : LocalContext) p => do\n     markVar p.x\n     pure $ ctx.addParam p\n  withReader (fun _ => { ctx with localCtx := localCtx }) k", "start": [146, 1], "end": [151, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkFnBody", "code": "partial def checkFnBody : FnBody \u2192 M Unit\n  | .vdecl x t v b    => do\n    checkExpr t v\n    markVar x\n    withReader (fun ctx => { ctx with localCtx := ctx.localCtx.addLocal x t v }) (checkFnBody b)\n  | .jdecl j ys v b => do\n    markJP j\n    withParams ys (checkFnBody v)\n    withReader (fun ctx => { ctx with localCtx := ctx.localCtx.addJP j ys v }) (checkFnBody b)\n  | .set x _ y b      => checkVar x *> checkArg y *> checkFnBody b\n  | .uset x _ y b     => checkVar x *> checkVar y *> checkFnBody b\n  | .sset x _ _ y _ b => checkVar x *> checkVar y *> checkFnBody b\n  | .setTag x _ b     => checkVar x *> checkFnBody b\n  | .inc x _ _ _ b    => checkVar x *> checkFnBody b\n  | .dec x _ _ _ b    => checkVar x *> checkFnBody b\n  | .del x b          => checkVar x *> checkFnBody b\n  | .mdata _ b        => checkFnBody b\n  | .jmp j ys         => checkJP j *> checkArgs ys\n  | .ret x            => checkArg x\n  | .case _ x _ alts  => checkVar x *> alts.forM (fun alt => checkFnBody alt.body)\n  | .unreachable      => pure ()", "start": [153, 1], "end": [173, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Checker.checkDecl", "code": "def checkDecl : Decl \u2192 M Unit\n  | .fdecl (xs := xs) (body := b) .. => withParams xs (checkFnBody b)\n  | .extern (xs := xs) .. => withParams xs (pure ())", "start": [175, 1], "end": [177, 53], "kind": "commanddeclaration"}, {"full_name": "checkDecl", "code": "def checkDecl (decls : Array Decl) (decl : Decl) : CompilerM Unit := do\n  let env \u2190 getEnv\n  match (Checker.checkDecl decl { env := env, decls := decls }).run' {} with\n  | .error msg => throw s!\"compiler IR check failed at '{decl.name}', error: {msg}\"\n  | _ => pure ()", "start": [181, 1], "end": [185, 17], "kind": "commanddeclaration"}, {"full_name": "checkDecls", "code": "def checkDecls (decls : Array Decl) : CompilerM Unit :=\n  decls.forM (checkDecl decls)", "start": [187, 1], "end": [188, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/CtorLayout.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Format.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.CtorFieldInfo", "code": "inductive CtorFieldInfo where\n  | irrelevant\n  | object (i : Nat)\n  | usize  (i : Nat)\n  | scalar (sz : Nat) (offset : Nat) (type : IRType)", "start": [12, 1], "end": [16, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CtorFieldInfo.format", "code": "def format : CtorFieldInfo \u2192 Format\n  | irrelevant => \"\u25fe\"\n  | object i   => f!\"obj@{i}\"\n  | usize i    => f!\"usize@{i}\"\n  | scalar sz offset type => f!\"scalar#{sz}@{offset}:{type}\"", "start": [20, 1], "end": [24, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CtorLayout", "code": "structure CtorLayout where\n  cidx       : Nat\n  fieldInfo  : List CtorFieldInfo\n  numObjs    : Nat\n  numUSize   : Nat\n  scalarSize : Nat", "start": [30, 1], "end": [35, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getCtorLayout", "code": "@[extern \"lean_ir_get_ctor_layout\"]\nopaque getCtorLayout (env : @& Environment) (ctorName : @& Name) : Except String CtorLayout", "start": [37, 1], "end": [38, 92], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/FileWorker/WidgetRequests.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Widget/Basic.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveCode.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/RequestHandling.lean", "lake-packages/lean4/src/lean/Lean/Server/FileWorker/RequestHandling.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveGoal.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveDiagnostic.lean"], "premises": [{"full_name": "Lean.Widget.MsgToInteractive", "code": "structure MsgToInteractive where\n  msg : WithRpcRef MessageData\n  indent : Nat\n  deriving Inhabited, RpcEncodable", "start": [20, 1], "end": [23, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InfoPopup", "code": "structure InfoPopup where\n  type : Option CodeWithInfos\n  \n  exprExplicit : Option CodeWithInfos\n  \n  doc : Option String\n  deriving Inhabited, RpcEncodable", "start": [32, 1], "end": [41, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.makePopup", "code": "def makePopup : WithRpcRef InfoWithCtx \u2192 RequestM (RequestTask InfoPopup)\n  | \u27e8i\u27e9 => RequestM.asTask do\n    i.ctx.runMetaM i.info.lctx do\n      let type? \u2190 match (\u2190 i.info.type?) with\n        | some type => some <$> (ppExprTagged =<< instantiateMVars type)\n        | none => pure none\n      let exprExplicit? \u2190 match i.info with\n        | Elab.Info.ofTermInfo ti =>\n          let ti \u2190 ppExprTagged ti.expr (explicit := true)\n          pure <| some <| match ti with\n            | .tag _ tt => tt\n            | tt => tt\n        | Elab.Info.ofFieldInfo fi => pure <| some <| TaggedText.text fi.fieldName.toString\n        | _ => pure none\n      return {\n        type := type?\n        exprExplicit := exprExplicit?\n        doc := \u2190 i.info.docString? : InfoPopup\n      }", "start": [43, 1], "end": [67, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.GetInteractiveDiagnosticsParams", "code": "structure GetInteractiveDiagnosticsParams where\n  \n  lineRange? : Option Lsp.LineRange\n  deriving Inhabited, FromJson, ToJson", "start": [90, 1], "end": [94, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.getInteractiveDiagnostics", "code": "def getInteractiveDiagnostics (params : GetInteractiveDiagnosticsParams) : RequestM (RequestTask (Array InteractiveDiagnostic)) := do\n  let doc \u2190 readDoc\n  let rangeEnd := params.lineRange?.map fun range =>\n    doc.meta.text.lspPosToUtf8Pos \u27e8range.\u00abend\u00bb, 0\u27e9\n  let t := doc.cmdSnaps.waitUntil fun snap => rangeEnd.any (snap.endPos >= \u00b7)\n  pure <| t.map fun (snaps, _) =>\n    let diags? := snaps.getLast?.map fun snap =>\n      snap.interactiveDiags.toArray.filter fun diag =>\n        params.lineRange?.all fun \u27e8s, e\u27e9 =>\n          s \u2264 diag.fullRange.start.line \u2227 diag.fullRange.start.line < e \u2228\n          diag.fullRange.start.line \u2264 s \u2227 s < diag.fullRange.end.line\n    pure <| diags?.getD #[]", "start": [97, 1], "end": [109, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.GetGoToLocationParams", "code": "structure GetGoToLocationParams where\n  kind : GoToKind\n  info : WithRpcRef InfoWithCtx\n  deriving RpcEncodable", "start": [118, 1], "end": [121, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.lazyTraceChildrenToInteractive", "code": "def lazyTraceChildrenToInteractive (children : WithRpcRef LazyTraceChildren) :\n    RequestM (RequestTask (Array (TaggedText MsgEmbed))) :=\n  RequestM.asTask do\n    let \u27e8indent, children\u27e9 := children\n    children.mapM fun \u27e8child\u27e9 =>\n      msgToInteractive child (hasWidgets := true) (indent := indent)", "start": [139, 1], "end": [144, 69], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/LoadDynlib.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.loadDynlib", "code": "@[extern \"lean_load_dynlib\"]\nopaque loadDynlib (path : @& System.FilePath) : IO Unit", "start": [9, 1], "end": [17, 56], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/Paths.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Path.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LeanPaths", "code": "structure LeanPaths where\n  oleanPath       : SearchPath\n  srcPath         : SearchPath\n  loadDynlibPaths : Array FilePath := #[]\n  deriving ToJson, FromJson", "start": [16, 1], "end": [20, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.initSrcSearchPath", "code": "def initSrcSearchPath (_leanSysroot : FilePath) (sp : SearchPath := \u2205) : IO SearchPath := do\n  let srcSearchPath :=\n    if let some p := (\u2190 IO.getEnv \"LEAN_SRC_PATH\") then\n      System.SearchPath.parse p\n    else []\n  let srcPath := (\u2190 IO.appDir) / \"..\" / \"src\" / \"lean\"\n  return srcSearchPath ++ sp ++ [srcPath / \"lake\", srcPath]", "start": [22, 1], "end": [29, 60], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/Rpc/Deriving.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Lean.Server.RpcEncodable.isOptField", "code": "def isOptField (n : Name) : Bool := n.toString.endsWith \"?\"", "start": [18, 1], "end": [18, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RpcEncodable.deriveStructureInstance", "code": "private def deriveStructureInstance (indVal : InductiveVal) (params : Array Expr)\n    (encInstBinders : Array (TSyntax ``bracketedBinder)) : TermElabM Command := do\n  let fields := getStructureFieldsFlattened (\u2190 getEnv) indVal.name (includeSubobjectFields := false)\n  trace[Elab.Deriving.RpcEncodable] \"for structure {indVal.name} with params {params}\"\n\n  let mut fieldIds := #[]\n  let mut fieldTys := #[]\n  let mut encInits := #[]\n  let mut decInits := #[]\n  for fieldName in fields do\n    let fid := mkIdent fieldName\n    fieldIds := fieldIds.push fid\n    if isOptField fieldName then\n      fieldTys := fieldTys.push (\u2190 `(Option Json))\n      encInits := encInits.push (\u2190 `(structInstField| $fid:ident := \u2190 (a.$fid).mapM rpcEncode))\n      decInits := decInits.push (\u2190 `(structInstField| $fid:ident := \u2190 (a.$fid).mapM rpcDecode))\n    else\n      fieldTys := fieldTys.push (\u2190 `(Json))\n      encInits := encInits.push (\u2190 `(structInstField| $fid:ident := \u2190 rpcEncode a.$fid))\n      decInits := decInits.push (\u2190 `(structInstField| $fid:ident := \u2190 rpcDecode a.$fid))\n\n  let paramIds \u2190 params.mapM fun p => return mkIdent (\u2190 getFVarLocalDecl p).userName\n\n  `(structure RpcEncodablePacket where\n      $[($fieldIds : $fieldTys)]*\n      deriving FromJson, ToJson\n\n    variable $encInstBinders* in\n    instance : RpcEncodable (@$(mkCIdent indVal.name) $paramIds*) :=\n      { rpcEncode := enc, rpcDecode := dec }\n    where\n      enc a := return toJson { $[$encInits],* : RpcEncodablePacket }\n      dec j := do\n        let a : RpcEncodablePacket \u2190 fromJson? j\n        return { $[$decInits],* }\n  )", "start": [22, 1], "end": [58, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RpcEncodable.RpcEncodablePacket", "code": "structure RpcEncodablePacket where\n      $[($fieldIds : $fieldTys)]*\n      deriving FromJson, ToJson", "start": [45, 5], "end": [47, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RpcEncodable.matchAltTerm", "code": "private def matchAltTerm := Lean.Parser.Term.matchAlt (rhsParser := Lean.Parser.termParser)", "start": [60, 1], "end": [60, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RpcEncodable.deriveInductiveInstance", "code": "private def deriveInductiveInstance (indVal : InductiveVal) (params : Array Expr)\n    (encInstBinders : Array (TSyntax ``bracketedBinder)) : TermElabM Command := do\n  trace[Elab.Deriving.RpcEncodable] \"for inductive {indVal.name} with params {params}\"\n  let st \u2190 indVal.ctors.toArray.mapM fun ctorName => do\n    let ctorTy \u2190 instantiateForall (\u2190 getConstInfoCtor ctorName).type params\n    forallTelescopeReducing ctorTy fun argVars _ => do\n    let .str _ ctor := ctorName | throwError m!\"constructor name not a string: {ctorName}\"\n    let ctorId := mkIdent ctor\n\n    let fieldStxs \u2190 argVars.mapM fun arg => do\n      let name := (\u2190 getFVarLocalDecl arg).userName\n      `(bracketedBinderF| ($(mkIdent name) : Json))\n    let pktCtor \u2190 `(Parser.Command.ctor|\n      | $ctorId:ident $[$fieldStxs]* : RpcEncodablePacket)\n\n    let nms \u2190 argVars.mapM fun _ => mkIdent <$> mkFreshBinderName\n    let encArgs \u2190 nms.mapM fun nm => `(\u2190 rpcEncode $nm)\n    let encArm \u2190 `(matchAltTerm| | .$ctorId $nms* => return toJson (.$ctorId $encArgs* : RpcEncodablePacket))\n    let decArgs \u2190 nms.mapM fun nm => `(\u2190 rpcDecode $nm)\n    let decArm \u2190 `(matchAltTerm| | .$ctorId $nms* => return (.$ctorId $decArgs*))\n\n    return (pktCtor, encArm, decArm)\n\n  let (ctors, st) := st.unzip\n  let (encodes, decodes) := st.unzip\n\n  let paramIds \u2190 params.mapM fun p => return mkIdent (\u2190 getFVarLocalDecl p).userName\n  let typeId \u2190 `(@$(mkIdent indVal.name) $paramIds*)\n\n  `(inductive RpcEncodablePacket where\n      $[$ctors:ctor]*\n      deriving FromJson, ToJson\n\n    variable $encInstBinders* in\n    partial instance : RpcEncodable $typeId :=\n      { rpcEncode := enc, rpcDecode := dec }\n    where\n      enc x :=\n        have inst : RpcEncodable $typeId := { rpcEncode := enc, rpcDecode := dec }\n        match x with $[$encodes:matchAlt]*\n      dec j := do\n        have inst : RpcEncodable $typeId := { rpcEncode := enc, rpcDecode := dec }\n        let pkt : RpcEncodablePacket \u2190 fromJson? j\n        id <| match pkt with $[$decodes:matchAlt]*\n  )", "start": [63, 1], "end": [110, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RpcEncodable.RpcEncodablePacket", "code": "inductive RpcEncodablePacket where\n      $[$ctors:ctor]*\n      deriving FromJson, ToJson", "start": [95, 5], "end": [97, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RpcEncodable.deriveInstance", "code": "private def deriveInstance (declNames : Array Name) : CommandElabM Bool := do\n  let #[typeName] := declNames | return false\n  let indVal \u2190 getConstInfoInduct typeName\n  if indVal.all.length \u2260 1 then\n    throwError \"mutually inductive types are not supported\"\n  if indVal.numIndices \u2260 0 then\n    throwError \"indexed inductive families are not supported\"\n\n  elabCommand <| \u2190 liftTermElabM do\n    forallTelescopeReducing indVal.type fun params _ => do\n      let encInstBinders \u2190 (\u2190 params.filterM (isType \u00b7)).mapM fun p => do\n        `(bracketedBinderF| [RpcEncodable $(mkIdent (\u2190 getFVarLocalDecl p).userName):ident])\n      if isStructure (\u2190 getEnv) typeName then\n          deriveStructureInstance indVal params encInstBinders\n      else\n          deriveInductiveInstance indVal params encInstBinders\n\n  return true", "start": [112, 1], "end": [133, 14], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Xml/Parser.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Parsec.lean", "lake-packages/lean4/src/lean/Lean/Data/Xml/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Xml.Parser.LeanChar", "code": "abbrev LeanChar := Char", "start": [20, 1], "end": [20, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.endl", "code": "def endl : Parsec LeanChar := (skipString \"\\r\\n\" <|> skipChar '\\r' <|> skipChar '\\n') *> pure '\\n'", "start": [22, 1], "end": [24, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.quote", "code": "def quote (p : Parsec \u03b1) : Parsec \u03b1 :=\n  skipChar '\\'' *> p <* skipChar '\\''\n  <|> skipChar '\"' *> p <* skipChar '\"'", "start": [26, 1], "end": [28, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Char", "code": "def Char : Parsec LeanChar :=\n  (attempt do\n  let c \u2190 anyChar\n  let cNat := c.toNat\n  if (0x20 \u2264 cNat \u2227 cNat \u2264 0xD7FF)\n   \u2228 (0xE000 \u2264 cNat \u2227 cNat \u2264 0xFFFD)\n   \u2228 (0x10000 \u2264 cNat \u2227 cNat \u2264 0x10FFFF) then pure c else fail \"expected xml char\")\n  <|> pchar '\\t' <|> endl", "start": [30, 1], "end": [38, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.S", "code": "def S : Parsec String :=\n  many1Chars (pchar ' ' <|> endl <|> pchar '\\t')", "start": [40, 1], "end": [42, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Eq", "code": "def Eq : Parsec Unit :=\n  optional S *> skipChar '=' <* optional S", "start": [44, 1], "end": [46, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.nameStartCharRanges", "code": "private def nameStartCharRanges : Array (Nat \u00d7 Nat) :=\n  #[(0xC0, 0xD6),\n    (0xD8, 0xF6),\n    (0xF8, 0x2FF),\n    (0x370, 0x37D),\n    (0x37F, 0x1FFF),\n    (0x200C, 0x200D),\n    (0x2070, 0x218F),\n    (0x2C00, 0x2FEF),\n    (0x3001, 0xD7FF),\n    (0xF900, 0xFDCF),\n    (0xFDF0, 0xFFFD),\n    (0x10000, 0xEFFFF)]", "start": [48, 1], "end": [60, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.NameStartChar", "code": "def NameStartChar : Parsec LeanChar := attempt do\n  let c \u2190 anyChar\n  if ('A' \u2264 c \u2227 c \u2264 'Z') \u2228 ('a' \u2264 c \u2227 c \u2264 'z') then pure c\n  else if c = ':' \u2228 c = '_' then pure c\n  else\n    let cNum := c.toNat\n    if nameStartCharRanges.any (fun (lo, hi) => lo \u2264 cNum \u2227 cNum \u2264 hi) then pure c\n    else fail \"expected a name character\"", "start": [62, 1], "end": [70, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.NameChar", "code": "def NameChar : Parsec LeanChar :=\n  NameStartChar <|> digit <|> pchar '-' <|> pchar '.' <|> pchar '\\xB7'\n  <|> satisfy (\u03bb c => ('\\u0300' \u2264 c \u2227 c \u2264 '\\u036F') \u2228 ('\\u203F' \u2264 c \u2227 c \u2264 '\\u2040'))", "start": [72, 1], "end": [75, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Name", "code": "def Name : Parsec String := do\n  let x \u2190 NameStartChar\n  manyCharsCore NameChar x.toString", "start": [77, 1], "end": [80, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.VersionNum", "code": "def VersionNum : Parsec Unit :=\n  skipString \"1.\" <* (many1 digit)", "start": [82, 1], "end": [84, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.VersionInfo", "code": "def VersionInfo : Parsec Unit := do\n  S *>\n  skipString \"version\"\n  Eq\n  quote VersionNum", "start": [86, 1], "end": [91, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.EncName", "code": "def EncName : Parsec String := do\n  let x \u2190 asciiLetter\n  manyCharsCore (asciiLetter <|> digit <|> pchar '-' <|> pchar '_' <|> pchar '.') x.toString", "start": [93, 1], "end": [96, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.EncodingDecl", "code": "def EncodingDecl : Parsec String := do\n  S *>\n  skipString \"encoding\"\n  Eq\n  quote EncName", "start": [98, 1], "end": [103, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.SDDecl", "code": "def SDDecl : Parsec String := do\n  S *> skipString \"standalone\" *> Eq *> quote (pstring \"yes\" <|> pstring \"no\")", "start": [105, 1], "end": [107, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.XMLdecl", "code": "def XMLdecl : Parsec Unit := do\n  skipString \"<?xml\"\n  VersionInfo\n  optional EncodingDecl *>\n  optional SDDecl *>\n  optional S *>\n  skipString \"?>\"", "start": [109, 1], "end": [116, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Comment", "code": "def Comment : Parsec String :=\n  let notDash := Char.toString <$> satisfy (\u03bb c => c \u2260 '-')\n  skipString \"<!  Array.foldl String.append \"\" <$> many (attempt <| notDash <|> (do\n    let d \u2190 pchar '-'\n    let c \u2190 notDash\n    pure $ d.toString ++ c))\n  <* skipString \"", "start": [118, 1], "end": [126, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.PITarget", "code": "def PITarget : Parsec String :=\n  Name <* (skipChar 'X' <|> skipChar 'x') <* (skipChar 'M' <|> skipChar 'm') <* (skipChar 'L' <|> skipChar 'l')", "start": [128, 1], "end": [130, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.PI", "code": "def PI : Parsec Unit := do\n  skipString \"<?\"\n  <* PITarget <*\n  optional (S *> manyChars (notFollowedBy (skipString \"?>\") *> Char))\n  skipString \"?>\"", "start": [132, 1], "end": [137, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Misc", "code": "def Misc : Parsec Unit :=\n  Comment *> pure () <|> PI <|> S *> pure ()", "start": [139, 1], "end": [141, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.SystemLiteral", "code": "def SystemLiteral : Parsec String :=\n  pchar '\"' *> manyChars (satisfy \u03bb c => c \u2260 '\"') <* pchar '\"'\n  <|> pchar '\\'' *> manyChars (satisfy \u03bb c => c \u2260 '\\'') <* pure '\\''", "start": [143, 1], "end": [146, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.PubidChar", "code": "def PubidChar : Parsec LeanChar :=\n  asciiLetter <|> digit <|> endl <|> attempt do\n  let c \u2190 anyChar\n  if \"-'()+,./:=?;!*#@$_%\".contains c then pure c else fail \"PublidChar expected\"", "start": [148, 1], "end": [152, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.PubidLiteral", "code": "def PubidLiteral : Parsec String :=\n  pchar '\"' *> manyChars PubidChar <* pchar '\"'\n  <|> pchar '\\'' *> manyChars (attempt do\n    let c \u2190 PubidChar\n    if c = '\\'' then fail \"'\\\\'' not expected\" else pure c) <* pchar '\\''", "start": [154, 1], "end": [159, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.ExternalID", "code": "def ExternalID : Parsec Unit :=\n  skipString \"SYSTEM\" *> S *> SystemLiteral *> pure ()\n  <|> skipString \"PUBLIC\" *> S *> PubidLiteral *> S *> SystemLiteral *> pure ()", "start": [161, 1], "end": [164, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Mixed", "code": "def Mixed : Parsec Unit :=\n  (do\n    skipChar '('\n    optional S *>\n    skipString \"#PCDATA\" *>\n    many (optional S *> skipChar '|' *> optional S *> Name) *>\n    optional S *>\n    skipString \")*\")\n  <|> skipChar '(' *> (optional S) *> skipString \"#PCDATA\" <* (optional S) <* skipChar ')'", "start": [166, 1], "end": [175, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.cp", "code": "partial def cp : Parsec Unit :=\n    (Name *> pure () <|> choice <|> seq) <* optional (skipChar '?' <|> skipChar '*' <|> skipChar '+')", "start": [178, 3], "end": [180, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.choice", "code": "partial def choice : Parsec Unit := do\n    skipChar '('\n    optional S *>\n    cp\n    many1 (optional S *> skipChar '|' *> optional S *> cp) *>\n    optional S *>\n    skipChar ')'", "start": [182, 3], "end": [189, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.seq", "code": "partial def seq : Parsec Unit := do\n    skipChar '('\n    optional S *>\n    cp\n    many (optional S *> skipChar ',' *> optional S *> cp) *>\n    optional S *>\n    skipChar ')'", "start": [191, 3], "end": [198, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.children", "code": "def children : Parsec Unit :=\n  (choice <|> seq) <* optional (skipChar '?' <|> skipChar '*' <|> skipChar '+')", "start": [201, 1], "end": [203, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.contentspec", "code": "def contentspec : Parsec Unit := do\n  skipString \"EMPTY\" <|> skipString \"ANY\" <|> Mixed <|> children", "start": [205, 1], "end": [207, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.elementDecl", "code": "def elementDecl : Parsec Unit := do\n  skipString \"<!ELEMENT\"\n  S *>\n  Name *>\n  contentspec *>\n  optional S *>\n  skipChar '>'", "start": [209, 1], "end": [216, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.StringType", "code": "def StringType : Parsec Unit :=\n  skipString \"CDATA\"", "start": [218, 1], "end": [220, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.TokenizedType", "code": "def TokenizedType : Parsec Unit :=\n  skipString \"ID\"\n  <|> skipString \"IDREF\"\n  <|> skipString \"IDREFS\"\n  <|> skipString \"ENTITY\"\n  <|> skipString \"ENTITIES\"\n  <|> skipString \"NMTOKEN\"\n  <|> skipString \"NMTOKENS\"", "start": [222, 1], "end": [230, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.NotationType", "code": "def NotationType : Parsec Unit := do\n  skipString \"NOTATION\"\n  S *>\n  skipChar '(' <*\n  optional S\n  Name *> many (optional S *> skipChar '|' *> optional S *> Name) *>\n  optional S *>\n  skipChar ')'", "start": [232, 1], "end": [240, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Nmtoken", "code": "def Nmtoken : Parsec String := do\n  many1Chars NameChar", "start": [242, 1], "end": [244, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Enumeration", "code": "def Enumeration : Parsec Unit := do\n  skipChar '('\n  optional S *>\n  Nmtoken *> many (optional S *> skipChar '|' *> optional S *> Nmtoken) *>\n  optional S *>\n  skipChar ')'", "start": [246, 1], "end": [252, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.EnumeratedType", "code": "def EnumeratedType : Parsec Unit :=\n  NotationType <|> Enumeration", "start": [254, 1], "end": [256, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.AttType", "code": "def AttType : Parsec Unit :=\n  StringType <|> TokenizedType <|> EnumeratedType", "start": [258, 1], "end": [260, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.predefinedEntityToChar", "code": "def predefinedEntityToChar : String \u2192 Option LeanChar\n| \"lt\" => some '<'\n| \"gt\" => some '>'\n| \"amp\" => some '&'\n| \"apos\" => some '\\''\n| \"quot\" => some '\"'\n| _ => none", "start": [262, 1], "end": [268, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.EntityRef", "code": "def EntityRef : Parsec $ Option LeanChar := attempt $\n  skipChar '&' *> predefinedEntityToChar <$> Name <* skipChar ';'", "start": [270, 1], "end": [272, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.hexDigitToNat", "code": "@[inline]\ndef hexDigitToNat (c : LeanChar) : Nat :=\n  if '0' \u2264 c \u2227 c \u2264 '9' then c.toNat - '0'.toNat\n  else if 'a' \u2264 c \u2227 c \u2264 'f' then c.toNat - 'a'.toNat + 10\n  else c.toNat - 'A'.toNat + 10", "start": [274, 1], "end": [278, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.digitsToNat", "code": "def digitsToNat (base : Nat) (digits : Array Nat) : Nat :=\n  digits.foldl (\u03bb r d => r * base + d) 0", "start": [280, 1], "end": [281, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.CharRef", "code": "def CharRef : Parsec LeanChar := do\n  skipString \"&#\"\n  let charCode \u2190\n    digitsToNat 10 <$> many1 (hexDigitToNat <$> digit)\n    <|> skipChar 'x' *> digitsToNat 16 <$> many1 (hexDigitToNat <$> hexDigit)\n  skipChar ';'\n  return Char.ofNat charCode", "start": [283, 1], "end": [290, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Reference", "code": "def Reference : Parsec $ Option LeanChar :=\n  EntityRef <|> some <$> CharRef", "start": [292, 1], "end": [294, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.AttValue", "code": "def AttValue : Parsec String := do\n  let chars \u2190\n  (do\n    skipChar '\"'\n    many (some <$> satisfy (\u03bb c => c \u2260 '<' \u2227 c \u2260 '&' \u2227 c \u2260 '\"') <|> Reference) <*\n    skipChar '\"')\n  <|> (do\n    skipChar '\\''\n    many (some <$> satisfy (\u03bb c => c \u2260 '<' \u2227 c \u2260 '&' \u2227 c \u2260 '\\'') <|> Reference) <*\n    skipChar '\\'')\n  return chars.foldl (\u03bb s c => if let some c := c then s.push c else s) \"\"", "start": [296, 1], "end": [307, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.DefaultDecl", "code": "def DefaultDecl : Parsec Unit :=\n  skipString \"#REQUIRED\"\n  <|> skipString \"#IMPLIED\"\n  <|> optional (skipString \"#FIXED\" <* S) *> AttValue *> pure ()", "start": [309, 1], "end": [313, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.AttDef", "code": "def AttDef : Parsec Unit :=\n  S *> Name *> S *> AttType *> S *> DefaultDecl", "start": [315, 1], "end": [317, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.AttlistDecl", "code": "def AttlistDecl : Parsec Unit :=\n  skipString \"<!ATTLIST\" *> S *> Name *> many AttDef *> optional S *> skipChar '>'", "start": [319, 1], "end": [321, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.PEReference", "code": "def PEReference : Parsec Unit :=\n  skipChar '%' *> Name *> skipChar ';'", "start": [323, 1], "end": [325, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.EntityValue", "code": "def EntityValue : Parsec String := do\n  let chars \u2190\n  (do\n    skipChar '\"'\n    many (some <$> satisfy (\u03bb c => c \u2260 '%' \u2227 c \u2260 '&' \u2227 c \u2260 '\"') <|> PEReference *> pure none <|> Reference) <*\n    skipChar '\"')\n  <|> (do\n    skipChar '\\''\n    many (some <$> satisfy (\u03bb c => c \u2260 '%' \u2227 c \u2260 '&' \u2227 c \u2260 '\\'') <|> PEReference *> pure none <|> Reference) <*\n    skipChar '\\'')\n  return chars.foldl (\u03bb s c => if let some c := c then s.push c else s) \"\"", "start": [327, 1], "end": [338, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.NDataDecl", "code": "def NDataDecl : Parsec Unit :=\n  S *> skipString \"NDATA\" <* S <* Name", "start": [341, 1], "end": [343, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.EntityDef", "code": "def EntityDef : Parsec Unit :=\n  EntityValue *> pure () <|> (ExternalID <* optional NDataDecl)", "start": [345, 1], "end": [347, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.GEDecl", "code": "def GEDecl : Parsec Unit :=\n  skipString \"<!ENTITY\" *> S *> Name *> S *> EntityDef *> optional S *> skipChar '>'", "start": [349, 1], "end": [351, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.PEDef", "code": "def PEDef : Parsec Unit :=\n  EntityValue *> pure () <|> ExternalID", "start": [353, 1], "end": [355, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.PEDecl", "code": "def PEDecl : Parsec Unit :=\n  skipString \"<!ENTITY\" *> S *> skipChar '%' *> S *> Name *> PEDef *> optional S *> skipChar '>'", "start": [357, 1], "end": [359, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.EntityDecl", "code": "def EntityDecl : Parsec Unit :=\n  GEDecl <|> PEDecl", "start": [361, 1], "end": [363, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.PublicID", "code": "def PublicID : Parsec Unit :=\n  skipString \"PUBLIC\" <* S <* PubidLiteral", "start": [365, 1], "end": [367, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.NotationDecl", "code": "def NotationDecl : Parsec Unit :=\n  skipString \"<!NOTATION\" *> S *> Name *> (ExternalID <|> PublicID) *> optional S *> skipChar '>'", "start": [369, 1], "end": [371, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.markupDecl", "code": "def markupDecl : Parsec Unit :=\n  elementDecl <|> AttlistDecl <|> EntityDecl <|> NotationDecl <|> PI <|> (Comment *> pure ())", "start": [373, 1], "end": [375, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.DeclSep", "code": "def DeclSep : Parsec Unit :=\n  PEReference <|> S *> pure ()", "start": [377, 1], "end": [379, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.intSubset", "code": "def intSubset : Parsec Unit :=\n  many (markupDecl <|> DeclSep) *> pure ()", "start": [381, 1], "end": [383, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.doctypedecl", "code": "def doctypedecl : Parsec Unit := do\n  skipString \"<!DOCTYPE\"\n  S *>\n  Name *>\n  optional (S *> ExternalID) *> pure ()\n  <* optional S\n  optional (skipChar '[' *> intSubset <* skipChar ']' <* optional S) *>\n  skipChar '>'", "start": [385, 1], "end": [393, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.prolog", "code": "def prolog : Parsec Unit :=\n  optional XMLdecl *>\n  many Misc *>\n  optional (doctypedecl <* many Misc) *> pure ()", "start": [395, 1], "end": [399, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.Attribute", "code": "def Attribute : Parsec (String \u00d7 String) := do\n  let name \u2190 Name\n  Eq\n  let value \u2190 AttValue\n  return (name, value)", "start": [401, 1], "end": [406, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.elementPrefix", "code": "protected def elementPrefix : Parsec (Array Content \u2192 Element) := do\n  skipChar '<'\n  let name \u2190 Name\n  let attributes \u2190 many (attempt <| S *> Attribute)\n  optional S *> pure ()\n  return Element.Element name (RBMap.fromList attributes.toList compare)", "start": [408, 1], "end": [413, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.EmptyElemTag", "code": "def EmptyElemTag (elem : Array Content \u2192 Element) : Parsec Element := do\n  skipString \"/>\" *> pure (elem #[])", "start": [415, 1], "end": [417, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.STag", "code": "def STag (elem : Array Content \u2192 Element) : Parsec (Array Content \u2192 Element) := do\n  skipChar '>' *> pure elem", "start": [419, 1], "end": [421, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.ETag", "code": "def ETag : Parsec Unit :=\n  skipString \"</\" *> Name *> optional S *> skipChar '>'", "start": [423, 1], "end": [425, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.CDStart", "code": "def CDStart : Parsec Unit :=\n  skipString \"<![CDATA[\"", "start": [427, 1], "end": [429, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.CDEnd", "code": "def CDEnd : Parsec Unit :=\n  skipString \"]]>\"", "start": [431, 1], "end": [433, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.CData", "code": "def CData : Parsec String :=\n  manyChars (notFollowedBy (skipString \"]]>\") *> anyChar)", "start": [435, 1], "end": [437, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.CDSect", "code": "def CDSect : Parsec String :=\n  CDStart *> CData <* CDEnd", "start": [439, 1], "end": [441, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.CharData", "code": "def CharData : Parsec String :=\n  notFollowedBy (skipString \"]]>\") *> manyChars (satisfy \u03bb c => c \u2260 '<' \u2227 c \u2260 '&')", "start": [443, 1], "end": [445, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.content", "code": "partial def content : Parsec (Array Content) := do\n    let x \u2190 optional (Content.Character <$> CharData)\n    let xs \u2190 many do\n      let y \u2190\n        attempt (some <$> Content.Element <$> element)\n        <|> (do let c \u2190 Reference; pure <| c.map (Content.Character \u2218 Char.toString))\n        <|> some <$> Content.Character <$> CDSect\n        <|> PI *> pure none\n        <|> some <$> Content.Comment <$> Comment\n\n      let z \u2190 optional (Content.Character <$> CharData)\n      pure #[y, z]\n    let xs := #[x] ++ xs.concatMap id |>.filterMap id\n    let mut res := #[]\n    for x in xs do\n      if res.size > 0 then\n        match res.back, x with\n        | Content.Character x, Content.Character y => res := res.set! (res.size - 1) (Content.Character $ x ++ y)\n        | _, x => res := res.push x\n      else res := res.push x\n    return res", "start": [448, 3], "end": [469, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.element", "code": "partial def element : Parsec Element := do\n    let elem \u2190 Parser.elementPrefix\n    EmptyElemTag elem <|> STag elem <*> content <* ETag", "start": [471, 3], "end": [474, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.Parser.document", "code": "def document : Parsec Element := prolog *> element <* many Misc <* eof", "start": [478, 1], "end": [479, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Xml.parse", "code": "def parse (s : String) : Except String Element :=\n  match Xml.Parser.document s.mkIterator with\n  | Parsec.ParseResult.success _ res => Except.ok res\n  | Parsec.ParseResult.error it err  => Except.error s!\"offset {it.i.byteIdx.repr}: {err}\\n{(it.prevn 10).extract it}\"", "start": [483, 1], "end": [486, 119], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Inhabited.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ForEachExprWhere.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.IndexSet", "code": "private abbrev IndexSet := RBTree Nat compare", "start": [12, 1], "end": [12, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.LocalInst2Index", "code": "private abbrev LocalInst2Index := FVarIdMap Nat", "start": [13, 1], "end": [13, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.implicitBinderF", "code": "private def implicitBinderF := Parser.Term.implicitBinder", "start": [15, 1], "end": [15, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.instBinderF", "code": "private def instBinderF     := Parser.Term.instBinder", "start": [16, 1], "end": [16, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkInhabitedInstanceUsing", "code": "private def mkInhabitedInstanceUsing (inductiveTypeName : Name) (ctorName : Name) (addHypotheses : Bool) : CommandElabM Bool := do\n  match (\u2190 liftTermElabM mkInstanceCmd?) with\n  | some cmd =>\n    elabCommand cmd\n    return true\n  | none =>\n    return false\nwhere\n  addLocalInstancesForParamsAux {\u03b1} (k : LocalInst2Index \u2192 TermElabM \u03b1) : List Expr \u2192 Nat \u2192 LocalInst2Index \u2192 TermElabM \u03b1\n    | [], _, map    => k map\n    | x::xs, i, map =>\n      try\n        let instType \u2190 mkAppM `Inhabited #[x]\n        if (\u2190 isTypeCorrect instType) then\n          withLocalDeclD (\u2190 mkFreshUserName `inst) instType fun inst => do\n            trace[Elab.Deriving.inhabited] \"adding local instance {instType}\"\n            addLocalInstancesForParamsAux k xs (i+1) (map.insert inst.fvarId! i)\n        else\n          addLocalInstancesForParamsAux k xs (i+1) map\n      catch _ =>\n        addLocalInstancesForParamsAux k xs (i+1) map\n\n  addLocalInstancesForParams {\u03b1} (xs : Array Expr) (k : LocalInst2Index \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n    if addHypotheses then\n      addLocalInstancesForParamsAux k xs.toList 0 {}\n    else\n      k {}\n\n  collectUsedLocalsInsts (usedInstIdxs : IndexSet) (localInst2Index : LocalInst2Index) (e : Expr) : IndexSet :=\n    if localInst2Index.isEmpty then\n      usedInstIdxs\n    else\n      let visit {\u03c9} : StateRefT IndexSet (ST \u03c9) Unit :=\n        e.forEachWhere Expr.isFVar fun e =>\n          let fvarId := e.fvarId!\n          match localInst2Index.find? fvarId with\n          | some idx => modify (\u00b7.insert idx)\n          | none => pure ()\n      runST (fun _ => visit |>.run usedInstIdxs) |>.2\n\n  \n  mkInstanceCmdWith (assumingParamIdxs : IndexSet) : TermElabM Syntax := do\n    let indVal \u2190 getConstInfoInduct inductiveTypeName\n    let ctorVal \u2190 getConstInfoCtor ctorName\n    let mut indArgs := #[]\n    let mut binders := #[]\n    for i in [:indVal.numParams + indVal.numIndices] do\n      let arg := mkIdent (\u2190 mkFreshUserName `a)\n      indArgs := indArgs.push arg\n      let binder \u2190 `(bracketedBinderF| { $arg:ident })\n      binders := binders.push binder\n      if assumingParamIdxs.contains i then\n        let binder \u2190 `(bracketedBinderF| [Inhabited $arg:ident ])\n        binders := binders.push binder\n    let type \u2190 `(Inhabited (@$(mkIdent inductiveTypeName):ident $indArgs:ident*))\n    let mut ctorArgs := #[]\n    for _ in [:ctorVal.numParams] do\n      ctorArgs := ctorArgs.push (\u2190 `(_))\n    for _ in [:ctorVal.numFields] do\n      ctorArgs := ctorArgs.push (\u2190 ``(Inhabited.default))\n    let val \u2190 `(\u27e8@$(mkIdent ctorName):ident $ctorArgs*\u27e9)\n    `(instance $binders:bracketedBinder* : $type := $val)\n\n  mkInstanceCmd? : TermElabM (Option Syntax) := do\n    let ctorVal \u2190 getConstInfoCtor ctorName\n    forallTelescopeReducing ctorVal.type fun xs _ =>\n      addLocalInstancesForParams xs[:ctorVal.numParams] fun localInst2Index => do\n        let mut usedInstIdxs := {}\n        let mut ok := true\n        for i in [ctorVal.numParams:xs.size] do\n          let x := xs[i]!\n          let instType \u2190 mkAppM `Inhabited #[(\u2190 inferType x)]\n          trace[Elab.Deriving.inhabited] \"checking {instType} for '{ctorName}'\"\n          match (\u2190 trySynthInstance instType) with\n          | LOption.some e =>\n            usedInstIdxs := collectUsedLocalsInsts usedInstIdxs localInst2Index e\n          | _ =>\n            trace[Elab.Deriving.inhabited] \"failed to generate instance using '{ctorName}' {if addHypotheses then \"(assuming parameters are inhabited)\" else \"\"} because of field with type{indentExpr (\u2190 inferType x)}\"\n            ok := false\n            break\n        if !ok then\n          return none\n        else\n          trace[Elab.Deriving.inhabited] \"inhabited instance using '{ctorName}' {if addHypotheses then \"(assuming parameters are inhabited)\" else \"\"} {usedInstIdxs.toList}\"\n          let cmd \u2190 mkInstanceCmdWith usedInstIdxs\n          trace[Elab.Deriving.inhabited] \"\\n{cmd}\"\n          return some cmd", "start": [18, 1], "end": [105, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkInhabitedInstance", "code": "private def mkInhabitedInstance (declName : Name) : CommandElabM Unit := do\n  let indVal \u2190 getConstInfoInduct declName\n  let doIt (addHypotheses : Bool) : CommandElabM Bool := do\n    for ctorName in indVal.ctors do\n      if (\u2190 mkInhabitedInstanceUsing declName ctorName addHypotheses) then\n        return true\n    return false\n  unless (\u2190 doIt false <||> doIt true) do\n    throwError \"failed to generate 'Inhabited' instance for '{declName}'\"", "start": [107, 1], "end": [115, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkInhabitedInstanceHandler", "code": "def mkInhabitedInstanceHandler (declNames : Array Name) : CommandElabM Bool := do\n  if (\u2190 declNames.allM isInductive) then\n    declNames.forM mkInhabitedInstance\n    return true\n  else\n    return false", "start": [117, 1], "end": [122, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/FromToJson.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/FromToJson.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean"], "premises": [{"full_name": "Lean.Elab.Deriving.FromToJson.mkJsonField", "code": "def mkJsonField (n : Name) : CoreM (Bool \u00d7 Term) := do\n  let .str .anonymous s := n | throwError \"invalid json field name {n}\"\n  let s\u2081 := s.dropRightWhile (\u00b7 == '?')\n  return (s != s\u2081, Syntax.mkStrLit s\u2081)", "start": [17, 1], "end": [20, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.FromToJson.mkToJsonInstanceHandler", "code": "def mkToJsonInstanceHandler (declNames : Array Name) : CommandElabM Bool := do\n  if declNames.size == 1 then\n    if isStructure (\u2190 getEnv) declNames[0]! then\n      let cmds \u2190 liftTermElabM do\n        let ctx \u2190 mkContext \"toJson\" declNames[0]!\n        let header \u2190 mkHeader ``ToJson 1 ctx.typeInfos[0]!\n        let fields := getStructureFieldsFlattened (\u2190 getEnv) declNames[0]! (includeSubobjectFields := false)\n        let fields \u2190 fields.mapM fun field => do\n          let (isOptField, nm) \u2190 mkJsonField field\n          let target := mkIdent header.targetNames[0]!\n          if isOptField then ``(opt $nm ($target).$(mkIdent field))\n          else ``([($nm, toJson ($target).$(mkIdent field))])\n        let cmd \u2190 `(private def $(mkIdent ctx.auxFunNames[0]!):ident $header.binders:bracketedBinder* : Json :=\n          mkObj <| List.join [$fields,*])\n        return #[cmd] ++ (\u2190 mkInstanceCmds ctx ``ToJson declNames)\n      cmds.forM elabCommand\n      return true\n    else\n      let indVal \u2190 getConstInfoInduct declNames[0]!\n      let cmds \u2190 liftTermElabM do\n        let ctx \u2190 mkContext \"toJson\" declNames[0]!\n        let toJsonFuncId := mkIdent ctx.auxFunNames[0]!\n        let mkToJson (id : Ident) (type : Expr) : TermElabM Term := do\n          if type.isAppOf indVal.name then `($toJsonFuncId:ident $id:ident)\n          else ``(toJson $id:ident)\n        let header \u2190 mkHeader ``ToJson 1 ctx.typeInfos[0]!\n        let discrs \u2190 mkDiscrs header indVal\n        let alts \u2190 mkAlts indVal fun ctor args userNames => do\n          let ctorStr := ctor.name.eraseMacroScopes.getString!\n          match args, userNames with\n          | #[], _ => ``(toJson $(quote ctorStr))\n          | #[(x, t)], none => ``(mkObj [($(quote ctorStr), $(\u2190 mkToJson x t))])\n          | xs, none =>\n            let xs \u2190 xs.mapM fun (x, t) => mkToJson x t\n            ``(mkObj [($(quote ctorStr), Json.arr #[$[$xs:term],*])])\n          | xs, some userNames =>\n            let xs \u2190 xs.mapIdxM fun idx (x, t) => do\n              `(($(quote userNames[idx]!.eraseMacroScopes.getString!), $(\u2190 mkToJson x t)))\n            ``(mkObj [($(quote ctorStr), mkObj [$[$xs:term],*])])\n        let auxTerm \u2190 `(match $[$discrs],* with $alts:matchAlt*)\n        let auxCmd \u2190\n          if ctx.usePartial then\n            let letDecls \u2190 mkLocalInstanceLetDecls ctx ``ToJson header.argNames\n            let auxTerm \u2190 mkLet letDecls auxTerm\n            `(private partial def $toJsonFuncId:ident $header.binders:bracketedBinder* : Json := $auxTerm)\n          else\n            `(private def $toJsonFuncId:ident $header.binders:bracketedBinder* : Json := $auxTerm)\n        return #[auxCmd] ++ (\u2190 mkInstanceCmds ctx ``ToJson declNames)\n      cmds.forM elabCommand\n      return true\n  else\n    return false\nwhere\n  mkAlts\n    (indVal : InductiveVal)\n    (rhs : ConstructorVal \u2192 Array (Ident \u00d7 Expr) \u2192 Option (Array Name) \u2192 TermElabM Term) : TermElabM (Array (TSyntax ``matchAlt)) := do\n  indVal.ctors.toArray.mapM fun ctor => do\n    let ctorInfo \u2190 getConstInfoCtor ctor\n    forallTelescopeReducing ctorInfo.type fun xs _ => do\n      let mut patterns := #[]\n      for _ in [:indVal.numIndices] do\n        patterns := patterns.push (\u2190 `(_))\n      let mut ctorArgs := #[]\n      for _ in [:indVal.numParams] do\n        ctorArgs := ctorArgs.push (\u2190 `(_))\n      let mut binders := #[]\n      let mut userNames := #[]\n      for i in [:ctorInfo.numFields] do\n        let x := xs[indVal.numParams + i]!\n        let localDecl \u2190 x.fvarId!.getDecl\n        if !localDecl.userName.hasMacroScopes then\n          userNames := userNames.push localDecl.userName\n        let a := mkIdent (\u2190 mkFreshUserName `a)\n        binders := binders.push (a, localDecl.type)\n        ctorArgs := ctorArgs.push a\n      patterns := patterns.push (\u2190 `(@$(mkIdent ctorInfo.name):ident $ctorArgs:term*))\n      let rhs \u2190 rhs ctorInfo binders (if userNames.size == binders.size then some userNames else none)\n      `(matchAltExpr| | $[$patterns:term],* => $rhs:term)", "start": [22, 1], "end": [104, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.FromToJson.$", "code": "private def $(mkIdent ctx.auxFunNames[0]!):ident $header.binders:bracketedBinder* : Json :=\n          mkObj <| List.join [$fields,*]", "start": [34, 21], "end": [35, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.FromToJson.$toJsonFuncId", "code": "private partial def $toJsonFuncId:ident $header.binders:bracketedBinder* : Json := $auxTerm", "start": [68, 15], "end": [68, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.FromToJson.$toJsonFuncId", "code": "private def $toJsonFuncId:ident $header.binders:bracketedBinder* : Json := $auxTerm", "start": [70, 15], "end": [70, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.FromToJson.mkFromJsonInstanceHandler", "code": "def mkFromJsonInstanceHandler (declNames : Array Name) : CommandElabM Bool := do\n  if declNames.size == 1 then\n    let declName := declNames[0]!\n    if isStructure (\u2190 getEnv) declName then\n      let cmds \u2190 liftTermElabM do\n        let ctx \u2190 mkContext \"fromJson\" declName\n        let header \u2190 mkHeader ``FromJson 0 ctx.typeInfos[0]!\n        let fields := getStructureFieldsFlattened (\u2190 getEnv) declName (includeSubobjectFields := false)\n        let getters \u2190 fields.mapM (fun field => do\n          let getter \u2190 `(getObjValAs? j _ $(Prod.snd <| \u2190 mkJsonField field))\n          let getter \u2190 `(doElem| Except.mapError (fun s => (toString $(quote declName)) ++ \".\" ++ (toString $(quote field)) ++ \": \" ++ s) <| $getter)\n          return getter\n        )\n        let fields := fields.map mkIdent\n        let cmd \u2190 `(private def $(mkIdent ctx.auxFunNames[0]!):ident $header.binders:bracketedBinder* (j : Json)\n          : Except String $(\u2190 mkInductiveApp ctx.typeInfos[0]! header.argNames) := do\n          $[let $fields:ident \u2190 $getters]*\n          return { $[$fields:ident := $(id fields)],* })\n        return #[cmd] ++ (\u2190 mkInstanceCmds ctx ``FromJson declNames)\n      cmds.forM elabCommand\n      return true\n    else\n      let indVal \u2190 getConstInfoInduct declName\n      let cmds \u2190 liftTermElabM do\n        let ctx \u2190 mkContext \"fromJson\" declName\n        let header \u2190 mkHeader ``FromJson 0 ctx.typeInfos[0]!\n        let fromJsonFuncId := mkIdent ctx.auxFunNames[0]!\n        let alts \u2190 mkAlts indVal fromJsonFuncId\n        let mut auxTerm \u2190 alts.foldrM (fun xs x => `(Except.orElseLazy $xs (fun _ => $x))) (\u2190 `(Except.error \"no inductive constructor matched\"))\n        if ctx.usePartial then\n          let letDecls \u2190 mkLocalInstanceLetDecls ctx ``FromJson header.argNames\n          auxTerm \u2190 mkLet letDecls auxTerm\n        let auxCmd \u2190\n          if ctx.usePartial || indVal.isRec then\n            `(private partial def $fromJsonFuncId:ident $header.binders:bracketedBinder* (json : Json)\n                  : Except String $(\u2190 mkInductiveApp ctx.typeInfos[0]! header.argNames) :=\n                $auxTerm)\n          else\n            `(private def $fromJsonFuncId:ident $header.binders:bracketedBinder* (json : Json)\n                  : Except String $(\u2190 mkInductiveApp ctx.typeInfos[0]! header.argNames) :=\n                $auxTerm)\n        return #[auxCmd] ++ (\u2190 mkInstanceCmds ctx ``FromJson declNames)\n      cmds.forM elabCommand\n      return true\n  else\n    return false\nwhere\n  mkAlts (indVal : InductiveVal) (fromJsonFuncId : Ident) : TermElabM (Array Term) := do\n  let alts \u2190\n    indVal.ctors.toArray.mapM fun ctor => do\n      let ctorInfo \u2190 getConstInfoCtor ctor\n      forallTelescopeReducing ctorInfo.type fun xs _ => do\n        let mut binders := #[]\n        let mut userNames := #[]\n        for i in [:ctorInfo.numFields] do\n          let x := xs[indVal.numParams + i]!\n          let localDecl \u2190 x.fvarId!.getDecl\n          if !localDecl.userName.hasMacroScopes then\n            userNames := userNames.push localDecl.userName\n          let a := mkIdent (\u2190 mkFreshUserName `a)\n          binders := binders.push (a, localDecl.type)\n\n        let mkFromJson (idx : Nat) (type : Expr) : TermElabM (TSyntax ``doExpr) :=\n          if type.isAppOf indVal.name then `(Lean.Parser.Term.doExpr| $fromJsonFuncId:ident jsons[$(quote idx)]!)\n          else `(Lean.Parser.Term.doExpr| fromJson? jsons[$(quote idx)]!)\n        let identNames := binders.map Prod.fst\n        let fromJsons \u2190 binders.mapIdxM fun idx (_, type) => mkFromJson idx type\n        let userNamesOpt \u2190 if binders.size == userNames.size then\n          ``(some #[$[$(userNames.map quote)],*])\n        else\n          ``(none)\n        let stx \u2190\n          `((Json.parseTagged json $(quote ctor.eraseMacroScopes.getString!) $(quote ctorInfo.numFields) $(quote userNamesOpt)).bind\n            (fun jsons => do\n              $[let $identNames:ident \u2190 $fromJsons:doExpr]*\n              return $(mkIdent ctor):ident $identNames*))\n        pure (stx, ctorInfo.numFields)\n  let alts := alts.qsort (fun (_, x) (_, y) => x < y)\n  return alts.map Prod.fst", "start": [106, 1], "end": [189, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.FromToJson.$", "code": "private def $(mkIdent ctx.auxFunNames[0]!):ident $header.binders:bracketedBinder* (j : Json)\n          : Except String $(\u2190 mkInductiveApp ctx.typeInfos[0]! header.argNames) := do\n          $[let $fields:ident \u2190 $getters]*\n          return { $[$fields:ident := $(id fields)],* }", "start": [120, 21], "end": [123, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.FromToJson.$fromJsonFuncId", "code": "private partial def $fromJsonFuncId:ident $header.binders:bracketedBinder* (json : Json)\n                  : Except String $(\u2190 mkInductiveApp ctx.typeInfos[0]! header.argNames) :=\n                $auxTerm", "start": [142, 15], "end": [144, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.FromToJson.$fromJsonFuncId", "code": "private def $fromJsonFuncId:ident $header.binders:bracketedBinder* (json : Json)\n                  : Except String $(\u2190 mkInductiveApp ctx.typeInfos[0]! header.argNames) :=\n                $auxTerm", "start": [146, 15], "end": [148, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/SizeOf.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/SizeOf.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Deriving.SizeOf.mkSizeOfHandler", "code": "def mkSizeOfHandler (declNames : Array Name) : CommandElabM Bool := do\n  if (\u2190 declNames.allM isInductive) && declNames.size > 0 then\n    liftTermElabM <| Meta.mkSizeOfInstances declNames[0]!\n    return true\n  else\n    return false", "start": [18, 1], "end": [23, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/TypeName.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.deriveTypeNameInstance", "code": "private def deriveTypeNameInstance (declNames : Array Name) : CommandElabM Bool := do\n  for declName in declNames do\n    let cinfo \u2190 getConstInfo declName\n    unless cinfo.levelParams.isEmpty do\n      throwError m!\"{mkConst declName} has universe level parameters\"\n    elabCommand <| \u2190 withFreshMacroScope `(\n      unsafe def instImpl : TypeName @$(mkCIdent declName) := .mk _ $(quote declName)\n      @[implemented_by instImpl] opaque inst : TypeName @$(mkCIdent declName)\n      instance : TypeName @$(mkCIdent declName) := inst\n    )\n  return true", "start": [12, 1], "end": [22, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.instImpl", "code": "unsafe def instImpl : TypeName @$(mkCIdent declName) := .mk _ $(quote declName)", "start": [18, 7], "end": [18, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.inst", "code": "@[implemented_by instImpl] opaque inst : TypeName @$(mkCIdent declName)", "start": [19, 7], "end": [19, 78], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Hashable.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Inductive.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Deriving.Hashable.mkHashableHeader", "code": "def mkHashableHeader (indVal : InductiveVal) : TermElabM Header := do\n  mkHeader `Hashable 1 indVal", "start": [15, 1], "end": [16, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Hashable.mkMatch", "code": "def mkMatch (ctx : Context) (header : Header) (indVal : InductiveVal) : TermElabM Term := do\n  let discrs \u2190 mkDiscrs header indVal\n  let alts \u2190 mkAlts\n  `(match $[$discrs],* with $alts:matchAlt*)\nwhere\n\n  mkAlts : TermElabM (Array (TSyntax ``matchAlt)) := do\n    let mut alts := #[]\n    let mut ctorIdx := 0\n    let allIndVals := indVal.all.toArray\n    for ctorName in indVal.ctors do\n      let ctorInfo \u2190 getConstInfoCtor ctorName\n      let alt \u2190 forallTelescopeReducing ctorInfo.type fun xs _ => do\n        let mut patterns := #[]\n        for _ in [:indVal.numIndices] do\n          patterns := patterns.push (\u2190 `(_))\n        let mut ctorArgs := #[]\n        let mut rhs \u2190 `($(quote ctorIdx))\n        for _ in [:indVal.numParams] do\n          ctorArgs := ctorArgs.push (\u2190 `(_))\n        for i in [:ctorInfo.numFields] do\n          let x := xs[indVal.numParams + i]!\n          let a := mkIdent (\u2190 mkFreshUserName `a)\n          ctorArgs := ctorArgs.push a\n          let xTy \u2190 whnf (\u2190 inferType x)\n          match xTy.getAppFn with\n          | .const declName .. =>\n            match allIndVals.findIdx? (\u00b7 == declName) with\n            | some x => rhs \u2190 `(mixHash $rhs ($(mkIdent ctx.auxFunNames[x]!) $a:ident))\n            | none => rhs \u2190 `(mixHash $rhs (hash $a:ident))\n          | _ => rhs \u2190 `(mixHash $rhs (hash $a:ident))\n        patterns := patterns.push (\u2190 `(@$(mkIdent ctorName):ident $ctorArgs:term*))\n        `(matchAltExpr| | $[$patterns:term],* => $rhs:term)\n      alts := alts.push alt\n      ctorIdx := ctorIdx + 1\n    return alts", "start": [18, 1], "end": [55, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Hashable.mkAuxFunction", "code": "def mkAuxFunction (ctx : Context) (i : Nat) : TermElabM Command := do\n  let auxFunName := ctx.auxFunNames[i]!\n  let indVal     := ctx.typeInfos[i]!\n  let header     \u2190 mkHashableHeader indVal\n  let mut body   \u2190 mkMatch ctx header indVal\n  if ctx.usePartial then\n    let letDecls \u2190 mkLocalInstanceLetDecls ctx `Hashable header.argNames\n    body \u2190 mkLet letDecls body\n  let binders    := header.binders\n  if ctx.usePartial then\n    `(private partial def $(mkIdent auxFunName):ident $binders:bracketedBinder* : UInt64 := $body:term)\n  else\n    `(private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : UInt64 := $body:term)", "start": [57, 1], "end": [70, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Hashable.$", "code": "private partial def $(mkIdent auxFunName):ident $binders:bracketedBinder* : UInt64 := $body:term", "start": [68, 7], "end": [68, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Hashable.$", "code": "private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : UInt64 := $body:term", "start": [70, 7], "end": [70, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Hashable.mkHashFuncs", "code": "def mkHashFuncs (ctx : Context) : TermElabM Syntax := do\n  let mut auxDefs := #[]\n  for i in [:ctx.typeInfos.size] do\n    auxDefs := auxDefs.push (\u2190 mkAuxFunction ctx i)\n  `(mutual $auxDefs:command* end)", "start": [72, 1], "end": [76, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Hashable.mkHashableInstanceCmds", "code": "private def mkHashableInstanceCmds (declNames : Array Name) : TermElabM (Array Syntax) := do\n  let ctx \u2190 mkContext \"hash\" declNames[0]!\n  let cmds := #[\u2190 mkHashFuncs ctx] ++ (\u2190 mkInstanceCmds ctx `Hashable declNames)\n  trace[Elab.Deriving.hashable] \"\\n{cmds}\"\n  return cmds", "start": [78, 1], "end": [82, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Hashable.mkHashableHandler", "code": "def mkHashableHandler (declNames : Array Name) : CommandElabM Bool := do\n  if (\u2190 declNames.allM isInductive) && declNames.size > 0 then\n    let cmds \u2190 liftTermElabM <| mkHashableInstanceCmds declNames\n    cmds.forM elabCommand\n    return true\n  else\n    return false", "start": [84, 1], "end": [90, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Nonempty.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.mkNonemptyInstance", "code": "private def mkNonemptyInstance (declName : Name) : TermElabM Syntax.Command := do\n  let indVal \u2190 getConstInfoInduct declName\n  forallTelescopeReducing indVal.type fun paramsIndices _ => do\n  let mut indArgs := #[]\n  let mut binders := #[]\n  for x in paramsIndices do\n    let arg := mkIdent (\u2190 mkFreshUserName (\u2190 x.fvarId!.getUserName).eraseMacroScopes)\n    indArgs := indArgs.push arg\n    binders := binders.push (\u2190 `(bracketedBinderF| {$arg}))\n    if let .sort u \u2190 whnf (\u2190 inferType x) then\n      if let .some _ \u2190 decLevel? u then\n        binders := binders.push (\u2190 `(bracketedBinderF| [Nonempty $arg]))\n  let ctorTacs \u2190 indVal.ctors.toArray.mapM fun ctor =>\n    `(tactic| apply @$(mkCIdent ctor) <;> exact Classical.ofNonempty)\n  `(command| variable $binders* in\n    instance : Nonempty (@$(mkCIdent declName) $indArgs*) :=\n      \u27e8by first $[| $ctorTacs:tactic]*\u27e9)", "start": [11, 1], "end": [27, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkNonemptyInstanceHandler", "code": "def mkNonemptyInstanceHandler (declNames : Array Name) : CommandElabM Bool := do\n  if (\u2190 declNames.allM isInductive) then\n    for declName in declNames do\n      elabCommand (\u2190 liftTermElabM do mkNonemptyInstance declName)\n    return true\n  else\n    return false", "start": [29, 1], "end": [35, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/DecEq.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Inductive.lean", "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean"], "premises": [{"full_name": "Lean.Elab.Deriving.DecEq.mkDecEqHeader", "code": "def mkDecEqHeader (indVal : InductiveVal) : TermElabM Header := do\n  mkHeader `DecidableEq 2 indVal", "start": [15, 1], "end": [16, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.mkMatch", "code": "def mkMatch (ctx : Context) (header : Header) (indVal : InductiveVal) : TermElabM Term := do\n  let discrs \u2190 mkDiscrs header indVal\n  let alts \u2190 mkAlts\n  `(match $[$discrs],* with $alts:matchAlt*)\nwhere\n  mkSameCtorRhs : List (Ident \u00d7 Ident \u00d7 Option Name \u00d7 Bool) \u2192 TermElabM Term\n    | [] => ``(isTrue rfl)\n    | (a, b, recField, isProof) :: todo => withFreshMacroScope do\n      let rhs \u2190 if isProof then\n        `(have h : $a = $b := rfl; by subst h; exact $(\u2190 mkSameCtorRhs todo):term)\n      else\n        `(if h : $a = $b then\n           by subst h; exact $(\u2190 mkSameCtorRhs todo):term\n          else\n           isFalse (by intro n; injection n; apply h _; assumption))\n      if let some auxFunName := recField then\n        `(let inst := $(mkIdent auxFunName) $a $b; $rhs)\n      else\n        return rhs\n\n  mkAlts : TermElabM (Array (TSyntax ``matchAlt)) := do\n    let mut alts := #[]\n    for ctorName\u2081 in indVal.ctors do\n      let ctorInfo \u2190 getConstInfoCtor ctorName\u2081\n      for ctorName\u2082 in indVal.ctors do\n        let mut patterns := #[]\n        for _ in [:indVal.numIndices] do\n          patterns := patterns.push (\u2190 `(_))\n        if ctorName\u2081 == ctorName\u2082 then\n          let alt \u2190 forallTelescopeReducing ctorInfo.type fun xs type => do\n            let type \u2190 Core.betaReduce type let mut patterns  := patterns\n            let mut ctorArgs1 := #[]\n            let mut ctorArgs2 := #[]\n            for _ in [:indVal.numParams] do\n              ctorArgs1 := ctorArgs1.push (\u2190 `(_))\n              ctorArgs2 := ctorArgs2.push (\u2190 `(_))\n            let mut todo := #[]\n            for i in [:ctorInfo.numFields] do\n              let x := xs[indVal.numParams + i]!\n              if type.containsFVar x.fvarId! then\n                ctorArgs1 := ctorArgs1.push (\u2190 `(_))\n                ctorArgs2 := ctorArgs2.push (\u2190 `(_))\n              else\n                let a := mkIdent (\u2190 mkFreshUserName `a)\n                let b := mkIdent (\u2190 mkFreshUserName `b)\n                ctorArgs1 := ctorArgs1.push a\n                ctorArgs2 := ctorArgs2.push b\n                let indValNum :=\n                  ctx.typeInfos.findIdx?\n                  ((\u2190 inferType x).isAppOf \u2218 ConstantVal.name \u2218 InductiveVal.toConstantVal)\n                let recField  := indValNum.map (ctx.auxFunNames[\u00b7]!)\n                let isProof   := (\u2190 inferType (\u2190 inferType x)).isProp\n                todo := todo.push (a, b, recField, isProof)\n            patterns := patterns.push (\u2190 `(@$(mkIdent ctorName\u2081):ident $ctorArgs1:term*))\n            patterns := patterns.push (\u2190 `(@$(mkIdent ctorName\u2081):ident $ctorArgs2:term*))\n            let rhs \u2190 mkSameCtorRhs todo.toList\n            `(matchAltExpr| | $[$patterns:term],* => $rhs:term)\n          alts := alts.push alt\n        else if (\u2190 compatibleCtors ctorName\u2081 ctorName\u2082) then\n          patterns := patterns ++ #[(\u2190 `($(mkIdent ctorName\u2081) ..)), (\u2190 `($(mkIdent ctorName\u2082) ..))]\n          let rhs \u2190 `(isFalse (by intro h; injection h))\n          alts := alts.push (\u2190 `(matchAltExpr| | $[$patterns:term],* => $rhs:term))\n    return alts", "start": [18, 1], "end": [85, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.mkAuxFunction", "code": "def mkAuxFunction (ctx : Context) (auxFunName : Name) (indVal : InductiveVal): TermElabM (TSyntax `command) := do\n  let header  \u2190 mkDecEqHeader indVal\n  let body    \u2190 mkMatch ctx header indVal\n  let binders := header.binders\n  let type    \u2190 `(Decidable ($(mkIdent header.targetNames[0]!) = $(mkIdent header.targetNames[1]!)))\n  `(private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : $type:term := $body:term)", "start": [87, 1], "end": [92, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.$", "code": "private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : $type:term := $body:term", "start": [92, 5], "end": [92, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.mkAuxFunctions", "code": "def mkAuxFunctions (ctx : Context) : TermElabM (TSyntax `command) := do\n  let mut res : Array (TSyntax `command) := #[]\n  for i in [:ctx.auxFunNames.size] do\n    let auxFunName := ctx.auxFunNames[i]!\n    let indVal     := ctx.typeInfos[i]!\n    res := res.push (\u2190 mkAuxFunction ctx auxFunName indVal)\n  `(command| mutual $[$res:command]* end)", "start": [94, 1], "end": [100, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.mkDecEqCmds", "code": "def mkDecEqCmds (indVal : InductiveVal) : TermElabM (Array Syntax) := do\n  let ctx \u2190 mkContext \"decEq\" indVal.name\n  let cmds := #[\u2190 mkAuxFunctions ctx] ++ (\u2190 mkInstanceCmds ctx `DecidableEq #[indVal.name] (useAnonCtor := false))\n  trace[Elab.Deriving.decEq] \"\\n{cmds}\"\n  return cmds", "start": [102, 1], "end": [106, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.mkDecEq", "code": "def mkDecEq (declName : Name) : CommandElabM Bool := do\n  let indVal \u2190 getConstInfoInduct declName\n  if indVal.isNested then\n    return false else\n    let cmds \u2190 liftTermElabM <| mkDecEqCmds indVal\n    cmds.forM elabCommand\n    return true", "start": [110, 1], "end": [117, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.mkEnumOfNat", "code": "partial def mkEnumOfNat (declName : Name) : MetaM Unit := do\n  let indVal \u2190 getConstInfoInduct declName\n  let enumType := mkConst declName\n  let ctors := indVal.ctors.toArray\n  withLocalDeclD `n (mkConst ``Nat) fun n => do\n    let cond := mkConst ``cond [levelZero]\n    let rec mkDecTree (low high : Nat) : Expr :=\n      if low + 1 == high then\n        mkConst ctors[low]!\n      else if low + 2 == high then\n        mkApp4 cond enumType (mkApp2 (mkConst ``Nat.beq) n (mkRawNatLit low)) (mkConst ctors[low]!) (mkConst ctors[low+1]!)\n      else\n        let mid := (low + high)/2\n        let lowBranch := mkDecTree low mid\n        let highBranch := mkDecTree mid high\n        mkApp4 cond enumType (mkApp2 (mkConst ``Nat.ble) (mkRawNatLit mid) n) highBranch lowBranch\n    let value \u2190 mkLambdaFVars #[n] (mkDecTree 0 ctors.size)\n    let type \u2190 mkArrow (mkConst ``Nat) enumType\n    addAndCompile <| Declaration.defnDecl {\n      name := Name.mkStr declName \"ofNat\"\n      levelParams := []\n      safety := DefinitionSafety.safe\n      hints  := ReducibilityHints.abbrev\n      value, type\n    }", "start": [119, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.mkEnumOfNatThm", "code": "def mkEnumOfNatThm (declName : Name) : MetaM Unit := do\n  let indVal \u2190 getConstInfoInduct declName\n  let toCtorIdx := mkConst (Name.mkStr declName \"toCtorIdx\")\n  let ofNat     := mkConst (Name.mkStr declName \"ofNat\")\n  let enumType  := mkConst declName\n  let eqEnum    := mkApp (mkConst ``Eq [levelOne]) enumType\n  let rflEnum   := mkApp (mkConst ``Eq.refl [levelOne]) enumType\n  let ctors := indVal.ctors\n  withLocalDeclD `x enumType fun x => do\n    let resultType := mkApp2 eqEnum (mkApp ofNat (mkApp toCtorIdx x)) x\n    let motive     \u2190 mkLambdaFVars #[x] resultType\n    let casesOn    := mkConst (mkCasesOnName declName) [levelZero]\n    let mut value  := mkApp2 casesOn motive x\n    for ctor in ctors do\n      value := mkApp value (mkApp rflEnum (mkConst ctor))\n    value \u2190 mkLambdaFVars #[x] value\n    let type \u2190 mkForallFVars #[x] resultType\n    addAndCompile <| Declaration.thmDecl {\n      name := Name.mkStr declName \"ofNat_toCtorIdx\"\n      levelParams := []\n      value, type\n    }", "start": [145, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.mkDecEqEnum", "code": "def mkDecEqEnum (declName : Name) : CommandElabM Unit := do\n  liftTermElabM <| mkEnumOfNat declName\n  liftTermElabM <| mkEnumOfNatThm declName\n  let ofNatIdent  := mkIdent (Name.mkStr declName \"ofNat\")\n  let auxThmIdent := mkIdent (Name.mkStr declName \"ofNat_toCtorIdx\")\n  let cmd \u2190 `(\n    instance : DecidableEq $(mkIdent declName) :=\n      fun x y =>\n        if h : x.toCtorIdx = y.toCtorIdx then\n          isTrue (by first | have aux := congrArg $ofNatIdent h; rw [$auxThmIdent:ident, $auxThmIdent:ident] at aux; assumption | rfl)\n        else\n          isFalse fun h => by subst h; contradiction\n  )\n  trace[Elab.Deriving.decEq] \"\\n{cmd}\"\n  elabCommand cmd", "start": [168, 1], "end": [183, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.DecEq.mkDecEqInstanceHandler", "code": "def mkDecEqInstanceHandler (declNames : Array Name) : CommandElabM Bool := do\n  if (\u2190 isEnumType declNames[0]!) then\n    mkDecEqEnum declNames[0]!\n    return true\n  else\n    mkDecEq declNames[0]!", "start": [185, 1], "end": [190, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/BEq.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Deriving.BEq.mkBEqHeader", "code": "def mkBEqHeader (indVal : InductiveVal) : TermElabM Header := do\n  mkHeader `BEq 2 indVal", "start": [14, 1], "end": [15, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.mkMatch", "code": "def mkMatch (header : Header) (indVal : InductiveVal) (auxFunName : Name) : TermElabM Term := do\n  let discrs \u2190 mkDiscrs header indVal\n  let alts \u2190 mkAlts\n  `(match $[$discrs],* with $alts:matchAlt*)\nwhere\n  mkElseAlt : TermElabM (TSyntax ``matchAltExpr) := do\n    let mut patterns := #[]\n    for _ in [:indVal.numIndices] do\n      patterns := patterns.push (\u2190 `(_))\n    patterns := patterns.push (\u2190 `(_))\n    patterns := patterns.push (\u2190 `(_))\n    let altRhs \u2190 `(false)\n    `(matchAltExpr| | $[$patterns:term],* => $altRhs:term)\n\n  mkAlts : TermElabM (Array (TSyntax ``matchAlt)) := do\n    let mut alts := #[]\n    for ctorName in indVal.ctors do\n      let ctorInfo \u2190 getConstInfoCtor ctorName\n      let alt \u2190 forallTelescopeReducing ctorInfo.type fun xs type => do\n        let type \u2190 Core.betaReduce type let mut patterns := #[]\n        for _ in [:indVal.numIndices] do\n          patterns := patterns.push (\u2190 `(_))\n        let mut ctorArgs1 := #[]\n        let mut ctorArgs2 := #[]\n        let mut rhs \u2190 `(true)\n        for _ in [:indVal.numParams] do\n          ctorArgs1 := ctorArgs1.push (\u2190 `(_))\n          ctorArgs2 := ctorArgs2.push (\u2190 `(_))\n        for i in [:ctorInfo.numFields] do\n          let x := xs[indVal.numParams + i]!\n          if type.containsFVar x.fvarId! then\n            ctorArgs1 := ctorArgs1.push (\u2190 `(_))\n            ctorArgs2 := ctorArgs2.push (\u2190 `(_))\n          else\n            let a := mkIdent (\u2190 mkFreshUserName `a)\n            let b := mkIdent (\u2190 mkFreshUserName `b)\n            ctorArgs1 := ctorArgs1.push a\n            ctorArgs2 := ctorArgs2.push b\n            if (\u2190 inferType x).isAppOf indVal.name then\n              rhs \u2190 `($rhs && $(mkIdent auxFunName):ident $a:ident $b:ident)\n            else\n              rhs \u2190 `($rhs && $a:ident == $b:ident)\n        patterns := patterns.push (\u2190 `(@$(mkIdent ctorName):ident $ctorArgs1:term*))\n        patterns := patterns.push (\u2190 `(@$(mkIdent ctorName):ident $ctorArgs2:term*))\n        `(matchAltExpr| | $[$patterns:term],* => $rhs:term)\n      alts := alts.push alt\n    alts := alts.push (\u2190 mkElseAlt)\n    return alts", "start": [17, 1], "end": [69, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.mkAuxFunction", "code": "def mkAuxFunction (ctx : Context) (i : Nat) : TermElabM Command := do\n  let auxFunName := ctx.auxFunNames[i]!\n  let indVal     := ctx.typeInfos[i]!\n  let header     \u2190 mkBEqHeader indVal\n  let mut body   \u2190 mkMatch header indVal auxFunName\n  if ctx.usePartial then\n    let letDecls \u2190 mkLocalInstanceLetDecls ctx `BEq header.argNames\n    body \u2190 mkLet letDecls body\n  let binders    := header.binders\n  if ctx.usePartial then\n    `(private partial def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Bool := $body:term)\n  else\n    `(private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Bool := $body:term)", "start": [71, 1], "end": [83, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.$", "code": "private partial def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Bool := $body:term", "start": [81, 7], "end": [81, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.$", "code": "private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Bool := $body:term", "start": [83, 7], "end": [83, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.mkMutualBlock", "code": "def mkMutualBlock (ctx : Context) : TermElabM Syntax := do\n  let mut auxDefs := #[]\n  for i in [:ctx.typeInfos.size] do\n    auxDefs := auxDefs.push (\u2190 mkAuxFunction ctx i)\n  `(mutual\n     set_option match.ignoreUnusedAlts true\n     $auxDefs:command*\n    end)", "start": [85, 1], "end": [92, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.mkBEqInstanceCmds", "code": "private def mkBEqInstanceCmds (declNames : Array Name) : TermElabM (Array Syntax) := do\n  let ctx \u2190 mkContext \"beq\" declNames[0]!\n  let cmds := #[\u2190 mkMutualBlock ctx] ++ (\u2190 mkInstanceCmds ctx `BEq declNames)\n  trace[Elab.Deriving.beq] \"\\n{cmds}\"\n  return cmds", "start": [94, 1], "end": [98, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.mkBEqEnumFun", "code": "private def mkBEqEnumFun (ctx : Context) (name : Name) : TermElabM Syntax := do\n  let auxFunName := ctx.auxFunNames[0]!\n  `(private def $(mkIdent auxFunName):ident  (x y : $(mkIdent name)) : Bool := x.toCtorIdx == y.toCtorIdx)", "start": [100, 1], "end": [102, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.$", "code": "private def $(mkIdent auxFunName):ident  (x y : $(mkIdent name)) : Bool := x.toCtorIdx == y.toCtorIdx", "start": [102, 5], "end": [102, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.mkBEqEnumCmd", "code": "private def mkBEqEnumCmd (name : Name): TermElabM (Array Syntax) := do\n  let ctx \u2190 mkContext \"beq\" name\n  let cmds := #[\u2190 mkBEqEnumFun ctx name] ++ (\u2190 mkInstanceCmds ctx `BEq #[name])\n  trace[Elab.Deriving.beq] \"\\n{cmds}\"\n  return cmds", "start": [104, 1], "end": [108, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.BEq.mkBEqInstanceHandler", "code": "def mkBEqInstanceHandler (declNames : Array Name) : CommandElabM Bool := do\n  if declNames.size == 1 && (\u2190 isEnumType declNames[0]!) then\n    let cmds \u2190 liftTermElabM <| mkBEqEnumCmd declNames[0]!\n    cmds.forM elabCommand\n    return true\n  else if (\u2190 declNames.allM isInductive) && declNames.size > 0 then\n    let cmds \u2190 liftTermElabM <| mkBEqInstanceCmds declNames\n    cmds.forM elabCommand\n    return true\n  else\n    return false", "start": [112, 1], "end": [122, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Ord.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Deriving.Ord.mkOrdHeader", "code": "def mkOrdHeader (indVal : InductiveVal) : TermElabM Header := do\n  mkHeader `Ord 2 indVal", "start": [14, 1], "end": [15, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Ord.mkMatch", "code": "def mkMatch (header : Header) (indVal : InductiveVal) : TermElabM Term := do\n  let discrs \u2190 mkDiscrs header indVal\n  let alts \u2190 mkAlts\n  `(match $[$discrs],* with $alts:matchAlt*)\nwhere\n  mkAlts : TermElabM (Array (TSyntax ``matchAlt)) := do\n    let mut alts := #[]\n    for ctorName in indVal.ctors do\n      let ctorInfo \u2190 getConstInfoCtor ctorName\n      let alt \u2190 forallTelescopeReducing ctorInfo.type fun xs type => do\n        let type \u2190 Core.betaReduce type let mut indPatterns := #[]\n        for _ in [:indVal.numIndices] do\n          indPatterns := indPatterns.push (\u2190 `(_))\n        let mut ctorArgs1 := #[]\n        let mut ctorArgs2 := #[]\n        let mut rhsCont : Term \u2192 TermElabM Term := fun rhs => pure rhs\n        for _ in [:indVal.numParams] do\n          ctorArgs1 := ctorArgs1.push (\u2190 `(_))\n          ctorArgs2 := ctorArgs2.push (\u2190 `(_))\n        for i in [:ctorInfo.numFields] do\n          let x := xs[indVal.numParams + i]!\n          if type.containsFVar x.fvarId! || (\u2190isProp (\u2190inferType x)) then\n            ctorArgs1 := ctorArgs1.push (\u2190 `(_))\n            ctorArgs2 := ctorArgs2.push (\u2190 `(_))\n          else\n            let a := mkIdent (\u2190 mkFreshUserName `a)\n            let b := mkIdent (\u2190 mkFreshUserName `b)\n            ctorArgs1 := ctorArgs1.push a\n            ctorArgs2 := ctorArgs2.push b\n            rhsCont := fun rhs => `(match compare $a $b with\n              | Ordering.lt => Ordering.lt\n              | Ordering.gt => Ordering.gt\n              | Ordering.eq => $rhs) >>= rhsCont\n        let lPat \u2190 `(@$(mkIdent ctorName):ident $ctorArgs1:term*)\n        let rPat \u2190 `(@$(mkIdent ctorName):ident $ctorArgs2:term*)\n        let patterns := indPatterns ++ #[lPat, rPat]\n        let ltPatterns := indPatterns ++ #[lPat, \u2190`(_)]\n        let gtPatterns := indPatterns ++ #[\u2190`(_), rPat]\n        let rhs \u2190 rhsCont (\u2190 `(Ordering.eq))\n        pure #[\u2190`(matchAltExpr| | $[$(patterns):term],* => $rhs:term),\n               \u2190`(matchAltExpr| | $[$(ltPatterns):term],* => Ordering.lt),\n               \u2190`(matchAltExpr| | $[$(gtPatterns):term],* => Ordering.gt)]\n      alts := alts ++ (alt : Array (TSyntax ``matchAlt))\n    return alts.pop.pop", "start": [17, 1], "end": [65, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Ord.mkAuxFunction", "code": "def mkAuxFunction (ctx : Context) (i : Nat) : TermElabM Command := do\n  let auxFunName := ctx.auxFunNames[i]!\n  let indVal     := ctx.typeInfos[i]!\n  let header     \u2190 mkOrdHeader indVal\n  let mut body   \u2190 mkMatch header indVal\n  if ctx.usePartial || indVal.isRec then\n    let letDecls \u2190 mkLocalInstanceLetDecls ctx `Ord header.argNames\n    body \u2190 mkLet letDecls body\n  let binders    := header.binders\n  if ctx.usePartial || indVal.isRec then\n    `(private partial def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Ordering := $body:term)\n  else\n    `(private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Ordering := $body:term)", "start": [67, 1], "end": [79, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Ord.$", "code": "private partial def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Ordering := $body:term", "start": [77, 7], "end": [77, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Ord.$", "code": "private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Ordering := $body:term", "start": [79, 7], "end": [79, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Ord.mkMutualBlock", "code": "def mkMutualBlock (ctx : Context) : TermElabM Syntax := do\n  let mut auxDefs := #[]\n  for i in [:ctx.typeInfos.size] do\n    auxDefs := auxDefs.push (\u2190 mkAuxFunction ctx i)\n  `(mutual\n     $auxDefs:command*\n    end)", "start": [81, 1], "end": [87, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Ord.mkOrdInstanceCmds", "code": "private def mkOrdInstanceCmds (declNames : Array Name) : TermElabM (Array Syntax) := do\n  let ctx \u2190 mkContext \"ord\" declNames[0]!\n  let cmds := #[\u2190 mkMutualBlock ctx] ++ (\u2190 mkInstanceCmds ctx `Ord declNames)\n  trace[Elab.Deriving.ord] \"\\n{cmds}\"\n  return cmds", "start": [89, 1], "end": [93, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Ord.mkOrdInstanceHandler", "code": "def mkOrdInstanceHandler (declNames : Array Name) : CommandElabM Bool := do\n  if (\u2190 declNames.allM isInductive) && declNames.size > 0 then\n    let cmds \u2190 liftTermElabM <| mkOrdInstanceCmds declNames\n    cmds.forM elabCommand\n    return true\n  else\n    return false", "start": [97, 1], "end": [103, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Repr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Inductive.lean", "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean"], "premises": [{"full_name": "Lean.Elab.Deriving.Repr.mkReprHeader", "code": "def mkReprHeader (indVal : InductiveVal) : TermElabM Header := do\n  let header \u2190 mkHeader `Repr 1 indVal\n  return { header with\n    binders := header.binders.push (\u2190 `(bracketedBinderF| (prec : Nat)))\n  }", "start": [16, 1], "end": [20, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Repr.mkBodyForStruct", "code": "def mkBodyForStruct (header : Header) (indVal : InductiveVal) : TermElabM Term := do\n  let ctorVal \u2190 getConstInfoCtor indVal.ctors.head!\n  let fieldNames := getStructureFields (\u2190 getEnv) indVal.name\n  let numParams  := indVal.numParams\n  let target     := mkIdent header.targetNames[0]!\n  forallTelescopeReducing ctorVal.type fun xs _ => do\n    let mut fields \u2190 `(Format.nil)\n    if xs.size != numParams + fieldNames.size then\n      throwError \"'deriving Repr' failed, unexpected number of fields in structure\"\n    for i in [:fieldNames.size] do\n      let fieldName := fieldNames[i]!\n      let fieldNameLit := Syntax.mkStrLit (toString fieldName)\n      let x := xs[numParams + i]!\n      if i != 0 then\n        fields \u2190 `($fields ++ \",\" ++ Format.line)\n      if (\u2190 isType x <||> isProof x) then\n        fields \u2190 `($fields ++ $fieldNameLit ++ \" := \" ++ \"_\")\n      else\n        let indent := Syntax.mkNumLit <| toString ((toString fieldName |>.length) + \" := \".length)\n        fields \u2190 `($fields ++ $fieldNameLit ++ \" := \" ++ (Format.group (Format.nest $indent (repr ($target.$(mkIdent fieldName):ident)))))\n    `(Format.bracket \"{ \" $fields:term \" }\")", "start": [22, 1], "end": [42, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Repr.mkBodyForInduct", "code": "def mkBodyForInduct (header : Header) (indVal : InductiveVal) (auxFunName : Name) : TermElabM Term := do\n  let discrs \u2190 mkDiscrs header indVal\n  let alts \u2190 mkAlts\n  `(match $[$discrs],* with $alts:matchAlt*)\nwhere\n  mkAlts : TermElabM (Array (TSyntax ``matchAlt)) := do\n    let mut alts := #[]\n    for ctorName in indVal.ctors do\n      let ctorInfo \u2190 getConstInfoCtor ctorName\n      let alt \u2190 forallTelescopeReducing ctorInfo.type fun xs _ => do\n        let mut patterns := #[]\n        for _ in [:indVal.numIndices] do\n          patterns := patterns.push (\u2190 `(_))\n        let mut ctorArgs := #[]\n        let mut rhs : Term := Syntax.mkStrLit (toString ctorInfo.name)\n        rhs \u2190 `(Format.text $rhs)\n        for _ in [:indVal.numParams] do\n          ctorArgs := ctorArgs.push (\u2190 `(_))\n        for i in [:ctorInfo.numFields] do\n          let x := xs[indVal.numParams + i]!\n          let a := mkIdent (\u2190 mkFreshUserName `a)\n          ctorArgs := ctorArgs.push a\n          let localDecl \u2190 x.fvarId!.getDecl\n          if localDecl.binderInfo.isExplicit then\n            if (\u2190 inferType x).isAppOf indVal.name then\n              rhs \u2190 `($rhs ++ Format.line ++ $(mkIdent auxFunName):ident $a:ident max_prec)\n            else\n              rhs \u2190 `($rhs ++ Format.line ++ reprArg $a)\n        patterns := patterns.push (\u2190 `(@$(mkIdent ctorName):ident $ctorArgs:term*))\n        `(matchAltExpr| | $[$patterns:term],* => Repr.addAppParen (Format.group (Format.nest (if prec >= max_prec then 1 else 2) ($rhs:term))) prec)\n      alts := alts.push alt\n    return alts", "start": [44, 1], "end": [77, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Repr.mkBody", "code": "def mkBody (header : Header) (indVal : InductiveVal) (auxFunName : Name) : TermElabM Term := do\n  if isStructure (\u2190 getEnv) indVal.name then\n    mkBodyForStruct header indVal\n  else\n    mkBodyForInduct header indVal auxFunName", "start": [79, 1], "end": [83, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Repr.mkAuxFunction", "code": "def mkAuxFunction (ctx : Context) (i : Nat) : TermElabM Command := do\n  let auxFunName := ctx.auxFunNames[i]!\n  let indVal     := ctx.typeInfos[i]!\n  let header     \u2190 mkReprHeader indVal\n  let mut body   \u2190 mkBody header indVal auxFunName\n  if ctx.usePartial then\n    let letDecls \u2190 mkLocalInstanceLetDecls ctx `Repr header.argNames\n    body \u2190 mkLet letDecls body\n  let binders    := header.binders\n  if ctx.usePartial then\n    `(private partial def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Format := $body:term)\n  else\n    `(private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Format := $body:term)", "start": [85, 1], "end": [97, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Repr.$", "code": "private partial def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Format := $body:term", "start": [95, 7], "end": [95, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Repr.$", "code": "private def $(mkIdent auxFunName):ident $binders:bracketedBinder* : Format := $body:term", "start": [97, 7], "end": [97, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Repr.mkMutualBlock", "code": "def mkMutualBlock (ctx : Context) : TermElabM Syntax := do\n  let mut auxDefs := #[]\n  for i in [:ctx.typeInfos.size] do\n    auxDefs := auxDefs.push (\u2190 mkAuxFunction ctx i)\n  `(mutual\n     $auxDefs:command*\n    end)", "start": [99, 1], "end": [105, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Repr.mkReprInstanceCmds", "code": "private def mkReprInstanceCmds (declNames : Array Name) : TermElabM (Array Syntax) := do\n  let ctx \u2190 mkContext \"repr\" declNames[0]!\n  let cmds := #[\u2190 mkMutualBlock ctx] ++ (\u2190 mkInstanceCmds ctx `Repr declNames)\n  trace[Elab.Deriving.repr] \"\\n{cmds}\"\n  return cmds", "start": [107, 1], "end": [111, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Deriving.Repr.mkReprInstanceHandler", "code": "def mkReprInstanceHandler (declNames : Array Name) : CommandElabM Bool := do\n  if (\u2190 declNames.allM isInductive) && declNames.size > 0 then\n    let cmds \u2190 liftTermElabM <| mkReprInstanceCmds declNames\n    cmds.forM elabCommand\n    return true\n  else\n    return false", "start": [115, 1], "end": [121, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Structure.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Injective.lean", "lake-packages/lean4/src/lean/Lean/Elab/Inductive.lean", "lake-packages/lean4/src/lean/Lean/Meta/Closure.lean", "lake-packages/lean4/src/lean/Lean/Parser/Command.lean", "lake-packages/lean4/src/lean/Lean/Elab/Binders.lean", "lake-packages/lean4/src/lean/Lean/Meta/Structure.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclModifiers.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclUtil.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Meta/SizeOf.lean", "lake-packages/lean4/src/lean/Lean/Class.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.Elab.Command.StructCtorView", "code": "structure StructCtorView where\n  ref       : Syntax\n  modifiers : Modifiers\n  name      : Name\n  declName  : Name", "start": [31, 1], "end": [35, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.StructFieldView", "code": "structure StructFieldView where\n  ref        : Syntax\n  modifiers  : Modifiers\n  binderInfo : BinderInfo\n  declName   : Name\n  name       : Name rawName    : Name binders    : Syntax\n  type?      : Option Syntax\n  value?     : Option Syntax", "start": [37, 1], "end": [46, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.StructView", "code": "structure StructView where\n  ref               : Syntax\n  modifiers         : Modifiers\n  scopeLevelNames   : List Name  allUserLevelNames : List Name  isClass           : Bool\n  declName          : Name\n  scopeVars         : Array Expr params            : Array Expr parents           : Array Syntax\n  type              : Syntax\n  ctor              : StructCtorView\n  fields            : Array StructFieldView", "start": [48, 1], "end": [60, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.StructFieldKind", "code": "inductive StructFieldKind where\n  | newField | copiedField | fromParent | subobject\n  deriving Inhabited, DecidableEq, Repr", "start": [62, 1], "end": [64, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.StructFieldInfo", "code": "structure StructFieldInfo where\n  name     : Name\n  declName : Name fvar     : Expr\n  kind     : StructFieldKind\n  value?   : Option Expr := none\n  deriving Inhabited, Repr", "start": [66, 1], "end": [72, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.StructFieldInfo.isFromParent", "code": "def StructFieldInfo.isFromParent (info : StructFieldInfo) : Bool :=\n  match info.kind with\n  | StructFieldKind.fromParent => true\n  | _                          => false", "start": [74, 1], "end": [77, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.StructFieldInfo.isSubobject", "code": "def StructFieldInfo.isSubobject (info : StructFieldInfo) : Bool :=\n  match info.kind with\n  | StructFieldKind.subobject => true\n  | _                         => false", "start": [79, 1], "end": [82, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.ElabStructResult", "code": "structure ElabStructResult where\n  decl            : Declaration\n  projInfos       : List ProjectionInfo\n  projInstances   : List Name mctx            : MetavarContext\n  lctx            : LocalContext\n  localInsts      : LocalInstances\n  defaultAuxDecls : Array (Name \u00d7 Expr \u00d7 Expr)", "start": [84, 1], "end": [91, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.defaultCtorName", "code": "private def defaultCtorName := `mk", "start": [93, 1], "end": [93, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandCtor", "code": "private def expandCtor (structStx : Syntax) (structModifiers : Modifiers) (structDeclName : Name) : TermElabM StructCtorView := do\n  let useDefault := do\n    let declName := structDeclName ++ defaultCtorName\n    addAuxDeclarationRanges declName structStx[2] structStx[2]\n    pure { ref := structStx, modifiers := {}, name := defaultCtorName, declName }\n  if structStx[5].isNone then\n    useDefault\n  else\n    let optCtor := structStx[5][1]\n    if optCtor.isNone then\n      useDefault\n    else\n      let ctor := optCtor[0]\n      withRef ctor do\n      let ctorModifiers \u2190 elabModifiers ctor[0]\n      checkValidCtorModifier ctorModifiers\n      if ctorModifiers.isPrivate && structModifiers.isPrivate then\n        throwError \"invalid 'private' constructor in a 'private' structure\"\n      if ctorModifiers.isProtected && structModifiers.isPrivate then\n        throwError \"invalid 'protected' constructor in a 'private' structure\"\n      let name := ctor[1].getId\n      let declName := structDeclName ++ name\n      let declName \u2190 applyVisibility ctorModifiers.visibility declName\n      addDocString' declName ctorModifiers.docString?\n      addAuxDeclarationRanges declName ctor[1] ctor[1]\n      pure { ref := ctor, name, modifiers := ctorModifiers, declName }", "start": [101, 1], "end": [126, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkValidFieldModifier", "code": "def checkValidFieldModifier (modifiers : Modifiers) : TermElabM Unit := do\n  if modifiers.isNoncomputable then\n    throwError \"invalid use of 'noncomputable' in field declaration\"\n  if modifiers.isPartial then\n    throwError \"invalid use of 'partial' in field declaration\"\n  if modifiers.isUnsafe then\n    throwError \"invalid use of 'unsafe' in field declaration\"\n  if modifiers.attrs.size != 0 then\n    throwError \"invalid use of attributes in field declaration\"", "start": [128, 1], "end": [136, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandFields", "code": "private def expandFields (structStx : Syntax) (structModifiers : Modifiers) (structDeclName : Name) : TermElabM (Array StructFieldView) :=\n  let fieldBinders := if structStx[5].isNone then #[] else structStx[5][2][0].getArgs\n  fieldBinders.foldlM (init := #[]) fun (views : Array StructFieldView) fieldBinder => withRef fieldBinder do\n    let mut fieldBinder := fieldBinder\n    if fieldBinder.getKind == ``Parser.Command.structSimpleBinder then\n      fieldBinder := mkNode ``Parser.Command.structExplicitBinder\n        #[ fieldBinder[0], mkAtomFrom fieldBinder \"(\", mkNullNode #[ fieldBinder[1] ], fieldBinder[2], fieldBinder[3], fieldBinder[4], mkAtomFrom fieldBinder \")\" ]\n    let k := fieldBinder.getKind\n    let binfo \u2190\n      if k == ``Parser.Command.structExplicitBinder then pure BinderInfo.default\n      else if k == ``Parser.Command.structImplicitBinder then pure BinderInfo.implicit\n      else if k == ``Parser.Command.structInstBinder then pure BinderInfo.instImplicit\n      else throwError \"unexpected kind of structure field\"\n    let fieldModifiers \u2190 elabModifiers fieldBinder[0]\n    checkValidFieldModifier fieldModifiers\n    if fieldModifiers.isPrivate && structModifiers.isPrivate then\n      throwError \"invalid 'private' field in a 'private' structure\"\n    if fieldModifiers.isProtected && structModifiers.isPrivate then\n      throwError \"invalid 'protected' field in a 'private' structure\"\n    let (binders, type?) \u2190\n      if binfo == BinderInfo.default then\n        let (binders, type?) := expandOptDeclSig fieldBinder[3]\n        let optBinderTacticDefault := fieldBinder[4]\n        if optBinderTacticDefault.isNone then\n          pure (binders, type?)\n        else if optBinderTacticDefault[0].getKind != ``Parser.Term.binderTactic then\n          pure (binders, type?)\n        else\n          let binderTactic := optBinderTacticDefault[0]\n          match type? with\n          | none => throwErrorAt binderTactic \"invalid field declaration, type must be provided when auto-param (tactic) is used\"\n          | some type =>\n            let tac := binderTactic[2]\n            let name \u2190 Term.declareTacticSyntax tac\n            let type \u2190 `(forall $(binders.getArgs):bracketedBinder*, $type)\n            let type \u2190 `(autoParam $type $(mkIdentFrom tac name))\n            pure (mkNullNode, some type.raw)\n      else\n        let (binders, type) := expandDeclSig fieldBinder[3]\n        pure (binders, some type)\n    let value? \u2190 if binfo != BinderInfo.default then\n      pure none\n    else\n      let optBinderTacticDefault := fieldBinder[4]\n      if optBinderTacticDefault.isNone then\n        pure none\n      else if optBinderTacticDefault[0].getKind == ``Parser.Term.binderTactic then\n        pure none\n      else\n        pure (some optBinderTacticDefault[0][1])\n    let idents := fieldBinder[2].getArgs\n    idents.foldlM (init := views) fun (views : Array StructFieldView) ident => withRef ident do\n      let rawName := ident.getId\n      let name    := rawName.eraseMacroScopes\n      unless name.isAtomic do\n        throwErrorAt ident \"invalid field name '{name.eraseMacroScopes}', field names must be atomic\"\n      let declName := structDeclName ++ name\n      let declName \u2190 applyVisibility fieldModifiers.visibility declName\n      addDocString' declName fieldModifiers.docString?\n      return views.push {\n        ref        := ident\n        modifiers  := fieldModifiers\n        binderInfo := binfo\n        declName\n        name\n        rawName\n        binders\n        type?\n        value?\n      }", "start": [147, 1], "end": [220, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.validStructType", "code": "private def validStructType (type : Expr) : Bool :=\n  match type with\n  | Expr.sort .. => true\n  | _            => false", "start": [222, 1], "end": [225, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.findFieldInfo?", "code": "private def findFieldInfo? (infos : Array StructFieldInfo) (fieldName : Name) : Option StructFieldInfo :=\n  infos.find? fun info => info.name == fieldName", "start": [227, 1], "end": [228, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.containsFieldName", "code": "private def containsFieldName (infos : Array StructFieldInfo) (fieldName : Name) : Bool :=\n  (findFieldInfo? infos fieldName).isSome", "start": [230, 1], "end": [231, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.updateFieldInfoVal", "code": "private def updateFieldInfoVal (infos : Array StructFieldInfo) (fieldName : Name) (value : Expr) : Array StructFieldInfo :=\n  infos.map fun info =>\n    if info.name == fieldName then\n      { info with value? := value  }\n    else\n      info", "start": [233, 1], "end": [238, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.findExistingField?", "code": "private def findExistingField? (infos : Array StructFieldInfo) (parentStructName : Name) : CoreM (Option Name) := do\n  let fieldNames := getStructureFieldsFlattened (\u2190 getEnv) parentStructName\n  for fieldName in fieldNames do\n    if containsFieldName infos fieldName then\n      return some fieldName\n  return none", "start": [245, 1], "end": [251, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.processSubfields", "code": "private partial def processSubfields (structDeclName : Name) (parentFVar : Expr) (parentStructName : Name) (subfieldNames : Array Name)\n    (infos : Array StructFieldInfo) (k : Array StructFieldInfo \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  go 0 infos\nwhere\n  go (i : Nat) (infos : Array StructFieldInfo) := do\n    if h : i < subfieldNames.size then\n      let subfieldName := subfieldNames.get \u27e8i, h\u27e9\n      if containsFieldName infos subfieldName then\n        throwError \"field '{subfieldName}' from '{parentStructName}' has already been declared\"\n      let val  \u2190 mkProjection parentFVar subfieldName\n      let type \u2190 inferType val\n      withLetDecl subfieldName type val fun subfieldFVar =>\n        \n        let declName := structDeclName ++ subfieldName\n        let infos := infos.push { name := subfieldName, declName, fvar := subfieldFVar, kind := StructFieldKind.fromParent }\n        go (i+1) infos\n    else\n      k infos", "start": [253, 1], "end": [271, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getNestedProjectionArg", "code": "private partial def getNestedProjectionArg (e : Expr) : MetaM Expr := do\n  if let Expr.const subProjName .. := e.getAppFn then\n    if let some { numParams, .. } \u2190 getProjectionFnInfo? subProjName then\n      if e.getAppNumArgs == numParams + 1 then\n        return \u2190 getNestedProjectionArg e.appArg!\n  return e", "start": [273, 1], "end": [279, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getFieldType", "code": "private def getFieldType (infos : Array StructFieldInfo) (parentType : Expr) (fieldName : Name) : MetaM Expr := do\n  withLocalDeclD (\u2190 mkFreshId) parentType fun parent => do\n    let proj \u2190 mkProjection parent fieldName\n    let projType \u2190 inferType proj\n    \n    let visit (e : Expr) : MetaM TransformStep := do\n      if let Expr.const subProjName .. := e.getAppFn then\n        if let some { numParams, .. } \u2190 getProjectionFnInfo? subProjName then\n          let Name.str _ subFieldName .. := subProjName\n            | throwError \"invalid projection name {subProjName}\"\n          let args := e.getAppArgs\n          if let some major := args.get? numParams then\n            if (\u2190 getNestedProjectionArg major) == parent then\n              if let some existingFieldInfo := findFieldInfo? infos subFieldName then\n                return TransformStep.done <| mkAppN existingFieldInfo.fvar args[numParams+1:args.size]\n      return TransformStep.done e\n    let projType \u2190 Meta.transform projType (post := visit)\n    if projType.containsFVar parent.fvarId! then\n      throwError \"unsupported dependent field in {fieldName} : {projType}\"\n    if let some info := getFieldInfo? (\u2190 getEnv) (\u2190 getStructureName parentType) fieldName then\n      if let some autoParamExpr := info.autoParam? then\n        return (\u2190 mkAppM ``autoParam #[projType, autoParamExpr])\n    return projType", "start": [281, 1], "end": [312, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.toVisibility", "code": "private def toVisibility (fieldInfo : StructureFieldInfo) : CoreM Visibility := do\n  if isProtected (\u2190 getEnv) fieldInfo.projFn then\n    return Visibility.protected\n  else if isPrivateName fieldInfo.projFn then\n    return Visibility.private\n  else\n    return Visibility.regular", "start": [314, 1], "end": [320, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.FieldMap", "code": "abbrev FieldMap := NameMap Expr", "start": [322, 1], "end": [322, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.reduceProjs", "code": "private def reduceProjs (e : Expr) (structNames : NameSet) : MetaM Expr :=\n  let reduce (e : Expr) : MetaM TransformStep := do\n    match (\u2190 reduceProjOf? e structNames.contains) with\n    | some v => return TransformStep.done v\n    | _ => return TransformStep.done e\n  transform e (post := reduce)", "start": [324, 1], "end": [330, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.copyDefaultValue?", "code": "private partial def copyDefaultValue? (fieldMap : FieldMap) (expandedStructNames : NameSet) (structName : Name) (fieldName : Name) : TermElabM (Option Expr) := do\n  match getDefaultFnForField? (\u2190 getEnv) structName fieldName with\n  | none => return none\n  | some defaultFn =>\n    let cinfo \u2190 getConstInfo defaultFn\n    let us \u2190 mkFreshLevelMVarsFor cinfo\n    go? (\u2190 instantiateValueLevelParams cinfo us)\nwhere\n  failed : TermElabM (Option Expr) := do\n    logWarning s!\"ignoring default value for field '{fieldName}' defined at '{structName}'\"\n    return none\n\n  go? (e : Expr) : TermElabM (Option Expr) := do\n    match e with\n    | Expr.lam n d b c =>\n      if c.isExplicit then\n        match fieldMap.find? n with\n        | none => failed\n        | some val =>\n          let valType \u2190 inferType val\n          if (\u2190 isDefEq valType d) then\n            go? (b.instantiate1 val)\n          else\n            failed\n      else\n        let arg \u2190 mkFreshExprMVar d\n        go? (b.instantiate1 arg)\n    | e =>\n      let r := if e.isAppOfArity ``id 2 then e.appArg! else e\n      return some (\u2190 reduceProjs (\u2190 instantiateMVars r) expandedStructNames)", "start": [332, 1], "end": [391, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.copyNewFieldsFrom", "code": "private partial def copyNewFieldsFrom (structDeclName : Name) (infos : Array StructFieldInfo) (parentType : Expr) (k : Array StructFieldInfo \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  copyFields infos {} parentType fun infos _ _ => k infos\nwhere\n  copyFields (infos : Array StructFieldInfo) (expandedStructNames : NameSet) (parentType : Expr) (k : Array StructFieldInfo \u2192 FieldMap \u2192 NameSet \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n    let parentStructName \u2190 getStructureName parentType\n    let fieldNames := getStructureFields (\u2190 getEnv) parentStructName\n    let rec copy (i : Nat) (infos : Array StructFieldInfo) (fieldMap : FieldMap) (expandedStructNames : NameSet) : TermElabM \u03b1 := do\n      if h : i < fieldNames.size then\n        let fieldName := fieldNames.get \u27e8i, h\u27e9\n        let fieldType \u2190 getFieldType infos parentType fieldName\n        match findFieldInfo? infos fieldName with\n        | some existingFieldInfo =>\n          let existingFieldType \u2190 inferType existingFieldInfo.fvar\n          unless (\u2190 isDefEq fieldType existingFieldType) do\n            throwError \"parent field type mismatch, field '{fieldName}' from parent '{parentStructName}' {\u2190 mkHasTypeButIsExpectedMsg fieldType existingFieldType}\"\n          \n          copy (i+1) infos (fieldMap.insert fieldName existingFieldInfo.fvar) expandedStructNames\n        | none =>\n          let some fieldInfo := getFieldInfo? (\u2190 getEnv) parentStructName fieldName | unreachable!\n          let addNewField : TermElabM \u03b1 := do\n            let value? \u2190 copyDefaultValue? fieldMap expandedStructNames parentStructName fieldName\n            withLocalDecl fieldName fieldInfo.binderInfo fieldType fun fieldFVar => do\n              let fieldDeclName := structDeclName ++ fieldName\n              let fieldDeclName \u2190 applyVisibility (\u2190 toVisibility fieldInfo) fieldDeclName\n              addDocString' fieldDeclName (\u2190 findDocString? (\u2190 getEnv) fieldInfo.projFn)\n              let infos := infos.push { name := fieldName, declName := fieldDeclName, fvar := fieldFVar, value?,\n                                        kind := StructFieldKind.copiedField }\n              copy (i+1) infos (fieldMap.insert fieldName fieldFVar) expandedStructNames\n          if fieldInfo.subobject?.isSome then\n            let fieldParentStructName \u2190 getStructureName fieldType\n            if (\u2190 findExistingField? infos fieldParentStructName).isSome then\n              let expandedStructNames := expandedStructNames.insert fieldParentStructName\n              copyFields infos expandedStructNames fieldType fun infos nestedFieldMap expandedStructNames => do\n                let fieldVal \u2190 mkCompositeField fieldType nestedFieldMap\n                copy (i+1) infos (fieldMap.insert fieldName fieldVal) expandedStructNames\n            else\n              let subfieldNames := getStructureFieldsFlattened (\u2190 getEnv) fieldParentStructName\n              let fieldName := fieldInfo.fieldName\n              withLocalDecl fieldName fieldInfo.binderInfo fieldType fun parentFVar =>\n                let infos := infos.push { name := fieldName, declName := structDeclName ++ fieldName, fvar := parentFVar, kind := StructFieldKind.subobject }\n                processSubfields structDeclName parentFVar fieldParentStructName subfieldNames infos fun infos =>\n                  copy (i+1) infos (fieldMap.insert fieldName parentFVar) expandedStructNames\n          else\n            addNewField\n      else\n        let infos \u2190 processOveriddenDefaultValues infos fieldMap expandedStructNames parentStructName\n        k infos fieldMap expandedStructNames\n    copy 0 infos {} expandedStructNames\n\n  processOveriddenDefaultValues (infos : Array StructFieldInfo) (fieldMap : FieldMap) (expandedStructNames : NameSet) (parentStructName : Name) : TermElabM (Array StructFieldInfo) :=\n    infos.mapM fun info => do\n      match (\u2190 copyDefaultValue? fieldMap expandedStructNames parentStructName info.name) with\n      | some value => return { info with value? := value }\n      | none       => return info\n\n  mkCompositeField (parentType : Expr) (fieldMap : FieldMap) : TermElabM Expr := do\n    let env \u2190 getEnv\n    let Expr.const parentStructName us \u2190 pure parentType.getAppFn | unreachable!\n    let parentCtor := getStructureCtor env parentStructName\n    let mut result := mkAppN (mkConst parentCtor.name us) parentType.getAppArgs\n    for fieldName in getStructureFields env parentStructName do\n      match fieldMap.find? fieldName with\n      | some val => result := mkApp result val\n      | none => throwError \"failed to copy fields from parent structure{indentExpr parentType}\" return result", "start": [393, 1], "end": [458, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkToParentName", "code": "private partial def mkToParentName (parentStructName : Name) (p : Name \u2192 Bool) : Name := Id.run do\n  let base := Name.mkSimple $ \"to\" ++ parentStructName.eraseMacroScopes.getString!\n  if p base then\n    base\n  else\n    let rec go (i : Nat) : Name :=\n      let curr := base.appendIndexAfter i\n      if p curr then curr else go (i+1)\n    go 1", "start": [460, 1], "end": [468, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withParents", "code": "private partial def withParents (view : StructView) (k : Array StructFieldInfo \u2192 Array Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  go 0 #[] #[]\nwhere\n  go (i : Nat) (infos : Array StructFieldInfo) (copiedParents : Array Expr) : TermElabM \u03b1 := do\n    if h : i < view.parents.size then\n      let parentStx := view.parents.get \u27e8i, h\u27e9\n      withRef parentStx do\n      let parentType \u2190 Term.elabType parentStx\n      let parentStructName \u2190 getStructureName parentType\n      if let some existingFieldName \u2190 findExistingField? infos parentStructName then\n        if structureDiamondWarning.get (\u2190 getOptions) then\n          logWarning s!\"field '{existingFieldName}' from '{parentStructName}' has already been declared\"\n        copyNewFieldsFrom view.declName infos parentType fun infos => go (i+1) infos (copiedParents.push parentType)\n        else\n        let env \u2190 getEnv\n        let subfieldNames := getStructureFieldsFlattened env parentStructName\n        let toParentName := mkToParentName parentStructName fun n => !containsFieldName infos n && !subfieldNames.contains n\n        let binfo := if view.isClass && isClass env parentStructName then BinderInfo.instImplicit else BinderInfo.default\n        withLocalDecl toParentName binfo parentType fun parentFVar =>\n          let infos := infos.push { name := toParentName, declName := view.declName ++ toParentName, fvar := parentFVar, kind := StructFieldKind.subobject }\n          processSubfields view.declName parentFVar parentStructName subfieldNames infos fun infos => go (i+1) infos copiedParents\n    else\n      k infos copiedParents", "start": [470, 1], "end": [493, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabFieldTypeValue", "code": "private def elabFieldTypeValue (view : StructFieldView) : TermElabM (Option Expr \u00d7 Option Expr) :=\n  Term.withAutoBoundImplicit <| Term.withAutoBoundImplicitForbiddenPred (fun n => view.name == n) <| Term.elabBinders view.binders.getArgs fun params => do\n    match view.type? with\n    | none         =>\n      match view.value? with\n      | none        => return (none, none)\n      | some valStx =>\n        Term.synthesizeSyntheticMVarsNoPostponing\n        let params \u2190 Term.addAutoBoundImplicits params\n        let value \u2190 Term.withoutAutoBoundImplicit <| Term.elabTerm valStx none\n        let value \u2190 mkLambdaFVars params value\n        return (none, value)\n    | some typeStx =>\n      let type \u2190 Term.elabType typeStx\n      Term.synthesizeSyntheticMVarsNoPostponing\n      let params \u2190 Term.addAutoBoundImplicits params\n      match view.value? with\n      | none        =>\n        let type  \u2190 mkForallFVars params type\n        return (type, none)\n      | some valStx =>\n        let value \u2190 Term.withoutAutoBoundImplicit <| Term.elabTermEnsuringType valStx type\n        Term.synthesizeSyntheticMVarsNoPostponing\n        let type  \u2190 mkForallFVars params type\n        let value \u2190 mkLambdaFVars params value\n        return (type, value)", "start": [495, 1], "end": [521, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withFields", "code": "private partial def withFields (views : Array StructFieldView) (infos : Array StructFieldInfo) (k : Array StructFieldInfo \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  go 0 {} infos\nwhere\n  go (i : Nat) (defaultValsOverridden : NameSet) (infos : Array StructFieldInfo) : TermElabM \u03b1 := do\n    if h : i < views.size then\n      let view := views.get \u27e8i, h\u27e9\n      withRef view.ref do\n      match findFieldInfo? infos view.name with\n      | none      =>\n        let (type?, value?) \u2190 elabFieldTypeValue view\n        match type?, value? with\n        | none,      none => throwError \"invalid field, type expected\"\n        | some type, _    =>\n          withLocalDecl view.rawName view.binderInfo type fun fieldFVar =>\n            let infos := infos.push { name := view.name, declName := view.declName, fvar := fieldFVar, value? := value?,\n                                      kind := StructFieldKind.newField }\n            go (i+1) defaultValsOverridden infos\n        | none, some value =>\n          let type \u2190 inferType value\n          withLocalDecl view.rawName view.binderInfo type fun fieldFVar =>\n            let infos := infos.push { name := view.name, declName := view.declName, fvar := fieldFVar, value? := value,\n                                      kind := StructFieldKind.newField }\n            go (i+1) defaultValsOverridden infos\n      | some info =>\n        let updateDefaultValue : TermElabM \u03b1 := do\n          match view.value? with\n          | none       => throwError \"field '{view.name}' has been declared in parent structure\"\n          | some valStx =>\n            if let some type := view.type? then\n              throwErrorAt type \"omit field '{view.name}' type to set default value\"\n            else\n              if defaultValsOverridden.contains info.name then\n                throwError \"field '{view.name}' new default value has already been set\"\n              let defaultValsOverridden := defaultValsOverridden.insert info.name\n              let mut valStx := valStx\n              if view.binders.getArgs.size > 0 then\n                valStx \u2190 `(fun $(view.binders.getArgs)* => $valStx:term)\n              let fvarType \u2190 inferType info.fvar\n              let value \u2190 Term.elabTermEnsuringType valStx fvarType\n              pushInfoLeaf <| .ofFieldRedeclInfo { stx := view.ref }\n              let infos := updateFieldInfoVal infos info.name value\n              go (i+1) defaultValsOverridden infos\n        match info.kind with\n        | StructFieldKind.newField    => throwError \"field '{view.name}' has already been declared\"\n        | StructFieldKind.subobject   => throwError \"unexpected subobject field reference\" | StructFieldKind.copiedField => updateDefaultValue\n        | StructFieldKind.fromParent  => updateDefaultValue\n    else\n      k infos", "start": [523, 1], "end": [571, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getResultUniverse", "code": "private def getResultUniverse (type : Expr) : TermElabM Level := do\n  let type \u2190 whnf type\n  match type with\n  | Expr.sort u => pure u\n  | _           => throwError \"unexpected structure resulting type\"", "start": [573, 1], "end": [577, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.collectUsed", "code": "private def collectUsed (params : Array Expr) (fieldInfos : Array StructFieldInfo) : StateRefT CollectFVars.State MetaM Unit := do\n  params.forM fun p => do\n    let type \u2190 inferType p\n    type.collectFVars\n  fieldInfos.forM fun info => do\n    let fvarType \u2190 inferType info.fvar\n    fvarType.collectFVars\n    match info.value? with\n    | none       => pure ()\n    | some value => value.collectFVars", "start": [579, 1], "end": [588, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.removeUnused", "code": "private def removeUnused (scopeVars : Array Expr) (params : Array Expr) (fieldInfos : Array StructFieldInfo)\n    : TermElabM (LocalContext \u00d7 LocalInstances \u00d7 Array Expr) := do\n  let (_, used) \u2190 (collectUsed params fieldInfos).run {}\n  Meta.removeUnused scopeVars used", "start": [590, 1], "end": [593, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withUsed", "code": "private def withUsed {\u03b1} (scopeVars : Array Expr) (params : Array Expr) (fieldInfos : Array StructFieldInfo) (k : Array Expr \u2192 TermElabM \u03b1)\n    : TermElabM \u03b1 := do\n  let (lctx, localInsts, vars) \u2190 removeUnused scopeVars params fieldInfos\n  withLCtx lctx localInsts <| k vars", "start": [595, 1], "end": [598, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.levelMVarToParam", "code": "private def levelMVarToParam (scopeVars : Array Expr) (params : Array Expr) (fieldInfos : Array StructFieldInfo) (univToInfer? : Option LMVarId) : TermElabM (Array StructFieldInfo) := do\n  levelMVarToParamFVars scopeVars\n  levelMVarToParamFVars params\n  fieldInfos.mapM fun info => do\n    levelMVarToParamFVar info.fvar\n    match info.value? with\n    | none       => pure info\n    | some value =>\n      let value \u2190 levelMVarToParam' value\n      pure { info with value? := value }\nwhere\n  levelMVarToParam' (type : Expr) : TermElabM Expr := do\n    Term.levelMVarToParam type (except := fun mvarId => univToInfer? == some mvarId)\n\n  levelMVarToParamFVars (fvars : Array Expr) : TermElabM Unit :=\n    fvars.forM levelMVarToParamFVar\n\n  levelMVarToParamFVar (fvar : Expr) : TermElabM Unit := do\n    let type \u2190 inferType fvar\n    discard <| levelMVarToParam' type", "start": [600, 1], "end": [619, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.collectUniversesFromFields", "code": "private partial def collectUniversesFromFields (r : Level) (rOffset : Nat) (fieldInfos : Array StructFieldInfo) : TermElabM (Array Level) := do\n  let (_, us) \u2190 go |>.run #[]\n  return us\nwhere\n  go : StateRefT (Array Level) TermElabM Unit :=\n    for info in fieldInfos do\n      let type \u2190 inferType info.fvar\n      let u \u2190 getLevel type\n      let u \u2190 instantiateLevelMVars u\n      match (\u2190 modifyGet fun s => accLevel u r rOffset |>.run |>.run s) with\n      | some _ => pure ()\n      | none =>\n        let typeType \u2190 inferType type\n        let mut msg := m!\"failed to compute resulting universe level of structure, field '{info.declName}' has type{indentD m!\"{type} : {typeType}\"}\\nstructure resulting type{indentExpr (mkSort (r.addOffset rOffset))}\"\n        if r.isMVar then\n          msg := msg ++ \"\\nrecall that Lean only infers the resulting universe level automatically when there is a unique solution for the universe level constraints, consider explicitly providing the structure resulting universe level\"\n        throwError msg", "start": [622, 1], "end": [638, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.updateResultingUniverse", "code": "private def updateResultingUniverse (fieldInfos : Array StructFieldInfo) (type : Expr) : TermElabM Expr := do\n  let r \u2190 getResultUniverse type\n  let rOffset : Nat   := r.getOffset\n  let r       : Level := r.getLevelOffset\n  match r with\n  | Level.mvar mvarId =>\n    let us \u2190 collectUniversesFromFields r rOffset fieldInfos\n    let rNew := mkResultUniverse us rOffset\n    assignLevelMVar mvarId rNew\n    instantiateMVars type\n  | _ => throwError \"failed to compute resulting universe level of structure, provide universe explicitly\"", "start": [640, 1], "end": [650, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.collectLevelParamsInFVar", "code": "private def collectLevelParamsInFVar (s : CollectLevelParams.State) (fvar : Expr) : TermElabM CollectLevelParams.State := do\n  let type \u2190 inferType fvar\n  let type \u2190 instantiateMVars type\n  return collectLevelParams s type", "start": [652, 1], "end": [655, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.collectLevelParamsInFVars", "code": "private def collectLevelParamsInFVars (fvars : Array Expr) (s : CollectLevelParams.State) : TermElabM CollectLevelParams.State :=\n  fvars.foldlM collectLevelParamsInFVar s", "start": [657, 1], "end": [658, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.collectLevelParamsInStructure", "code": "private def collectLevelParamsInStructure (structType : Expr) (scopeVars : Array Expr) (params : Array Expr) (fieldInfos : Array StructFieldInfo)\n    : TermElabM (Array Name) := do\n  let s := collectLevelParams {} structType\n  let s \u2190 collectLevelParamsInFVars scopeVars s\n  let s \u2190 collectLevelParamsInFVars params s\n  let s \u2190 fieldInfos.foldlM (init := s) fun s info => collectLevelParamsInFVar s info.fvar\n  return s.params", "start": [660, 1], "end": [666, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addCtorFields", "code": "private def addCtorFields (fieldInfos : Array StructFieldInfo) : Nat \u2192 Expr \u2192 TermElabM Expr\n  | 0,   type => pure type\n  | i+1, type => do\n    let info := fieldInfos[i]!\n    let decl \u2190 Term.getFVarLocalDecl! info.fvar\n    let type \u2190 instantiateMVars type\n    let type := type.abstract #[info.fvar]\n    match info.kind with\n    | StructFieldKind.fromParent =>\n      let val := decl.value\n      addCtorFields fieldInfos i (type.instantiate1 val)\n    | _  =>\n      addCtorFields fieldInfos i (mkForall decl.userName decl.binderInfo decl.type type)", "start": [668, 1], "end": [680, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkCtor", "code": "private def mkCtor (view : StructView) (levelParams : List Name) (params : Array Expr) (fieldInfos : Array StructFieldInfo) : TermElabM Constructor :=\n  withRef view.ref do\n  let type := mkAppN (mkConst view.declName (levelParams.map mkLevelParam)) params\n  let type \u2190 addCtorFields fieldInfos fieldInfos.size type\n  let type \u2190 mkForallFVars params type\n  let type \u2190 instantiateMVars type\n  let type := type.inferImplicit params.size true\n  pure { name := view.ctor.declName, type }", "start": [682, 1], "end": [689, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkProjections", "code": "@[extern \"lean_mk_projections\"]\nprivate opaque mkProjections (env : Environment) (structName : Name) (projs : List Name) (isClass : Bool) : Except KernelException Environment", "start": [691, 1], "end": [692, 143], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addProjections", "code": "private def addProjections (structName : Name) (projs : List Name) (isClass : Bool) : TermElabM Unit := do\n  let env \u2190 getEnv\n  let env \u2190 ofExceptKernelException (mkProjections env structName projs isClass)\n  setEnv env", "start": [694, 1], "end": [697, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.registerStructure", "code": "private def registerStructure (structName : Name) (infos : Array StructFieldInfo) : TermElabM Unit := do\n  let fields \u2190 infos.filterMapM fun info => do\n      if info.kind == StructFieldKind.fromParent then\n        return none\n      else\n        return some {\n          fieldName  := info.name\n          projFn     := info.declName\n          binderInfo := (\u2190 getFVarLocalDecl info.fvar).binderInfo\n          autoParam? := (\u2190 inferType info.fvar).getAutoParamTactic?\n          subobject? :=\n            if info.kind == StructFieldKind.subobject then\n              match (\u2190 getEnv).find? info.declName with\n              | some (ConstantInfo.defnInfo val) =>\n                match val.type.getForallBody.getAppFn with\n                | Expr.const parentName .. => some parentName\n                | _ => panic! \"ill-formed structure\"\n              | _ => panic! \"ill-formed environment\"\n            else\n              none\n        }\n  modifyEnv fun env => Lean.registerStructure env { structName, fields }", "start": [699, 1], "end": [720, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkAuxConstructions", "code": "private def mkAuxConstructions (declName : Name) : TermElabM Unit := do\n  let env \u2190 getEnv\n  let hasUnit := env.contains `PUnit\n  let hasEq   := env.contains `Eq\n  let hasHEq  := env.contains `HEq\n  mkRecOn declName\n  if hasUnit then mkCasesOn declName\n  if hasUnit && hasEq && hasHEq then mkNoConfusion declName", "start": [722, 1], "end": [729, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addDefaults", "code": "private def addDefaults (lctx : LocalContext) (defaultAuxDecls : Array (Name \u00d7 Expr \u00d7 Expr)) : TermElabM Unit := do\n  let localInsts \u2190 getLocalInstances\n  withLCtx lctx localInsts do\n    defaultAuxDecls.forM fun (declName, type, value) => do\n      let value \u2190 instantiateMVars value\n      if value.hasExprMVar then\n        throwError \"invalid default value for field, it contains metavariables{indentExpr value}\"\n      \n      let value \u2190 mkId value\n      discard <| mkAuxDefinition declName type value (zeta := true)\n      setReducibleAttribute declName", "start": [731, 1], "end": [741, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.setSourceInstImplicit", "code": "private def setSourceInstImplicit (type : Expr) : Expr :=\n  match type with\n  | .forallE _ d b _ =>\n    if b.isForall then\n      type.updateForallE! d (setSourceInstImplicit b)\n    else\n      type.updateForall! .instImplicit d b\n  | _ => unreachable!", "start": [743, 1], "end": [753, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkCoercionToCopiedParent", "code": "private partial def mkCoercionToCopiedParent (levelParams : List Name) (params : Array Expr) (view : StructView) (parentType : Expr) : MetaM Unit := do\n  let env \u2190 getEnv\n  let structName := view.declName\n  let sourceFieldNames := getStructureFieldsFlattened env structName\n  let structType := mkAppN (Lean.mkConst structName (levelParams.map mkLevelParam)) params\n  let Expr.const parentStructName _ \u2190 pure parentType.getAppFn | unreachable!\n  let binfo := if view.isClass && isClass env parentStructName then BinderInfo.instImplicit else BinderInfo.default\n  withLocalDeclD `self structType fun source => do\n    let mut declType \u2190 instantiateMVars (\u2190 mkForallFVars params (\u2190 mkForallFVars #[source] parentType))\n    if view.isClass && isClass env parentStructName then\n      declType := setSourceInstImplicit declType\n    declType := declType.inferImplicit params.size true\n    let rec copyFields (parentType : Expr) : MetaM Expr := do\n      let Expr.const parentStructName us \u2190 pure parentType.getAppFn | unreachable!\n      let parentCtor := getStructureCtor env parentStructName\n      let mut result := mkAppN (mkConst parentCtor.name us) parentType.getAppArgs\n      for fieldName in getStructureFields env parentStructName do\n        if sourceFieldNames.contains fieldName then\n          let fieldVal \u2190 mkProjection source fieldName\n          result := mkApp result fieldVal\n        else\n          let some fieldInfo := getFieldInfo? env parentStructName fieldName | unreachable!\n          if fieldInfo.subobject?.isNone then throwError \"failed to build coercion to parent structure\"\n          let resultType \u2190 whnfD (\u2190 inferType result)\n          unless resultType.isForall do throwError \"failed to build coercion to parent structure, unexpect type{indentExpr resultType}\"\n          let fieldVal \u2190 copyFields resultType.bindingDomain!\n          result := mkApp result fieldVal\n      return result\n    let declVal \u2190 instantiateMVars (\u2190 mkLambdaFVars params (\u2190 mkLambdaFVars #[source] (\u2190 copyFields parentType)))\n    let declName := structName ++ mkToParentName (\u2190 getStructureName parentType) fun n => !env.contains (structName ++ n)\n    addAndCompile <| Declaration.defnDecl {\n      name        := declName\n      levelParams := levelParams\n      type        := declType\n      value       := declVal\n      hints       := ReducibilityHints.abbrev\n      safety      := if view.modifiers.isUnsafe then DefinitionSafety.unsafe else DefinitionSafety.safe\n    }\n    if binfo.isInstImplicit then\n      addInstance declName AttributeKind.global (eval_prio default)\n    else\n      setReducibleAttribute declName", "start": [755, 1], "end": [797, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabStructureView", "code": "private def elabStructureView (view : StructView) : TermElabM Unit := do\n  view.fields.forM fun field => do\n    if field.declName == view.ctor.declName then\n      throwErrorAt field.ref \"invalid field name '{field.name}', it is equal to structure constructor name\"\n    addAuxDeclarationRanges field.declName field.ref field.ref\n  let type \u2190 Term.elabType view.type\n  unless validStructType type do throwErrorAt view.type \"expected Type\"\n  withRef view.ref do\n  withParents view fun fieldInfos copiedParents => do\n  withFields view.fields fieldInfos fun fieldInfos => do\n    Term.synthesizeSyntheticMVarsNoPostponing\n    let u \u2190 getResultUniverse type\n    let univToInfer? \u2190 shouldInferResultUniverse u\n    withUsed view.scopeVars view.params fieldInfos fun scopeVars => do\n      let fieldInfos \u2190 levelMVarToParam scopeVars view.params fieldInfos univToInfer?\n      let type \u2190 withRef view.ref do\n        if univToInfer?.isSome then\n          updateResultingUniverse fieldInfos type\n        else\n          checkResultingUniverse (\u2190 getResultUniverse type)\n          pure type\n      trace[Elab.structure] \"type: {type}\"\n      let usedLevelNames \u2190 collectLevelParamsInStructure type scopeVars view.params fieldInfos\n      match sortDeclLevelParams view.scopeLevelNames view.allUserLevelNames usedLevelNames with\n      | Except.error msg      => withRef view.ref <| throwError msg\n      | Except.ok levelParams =>\n        let params := scopeVars ++ view.params\n        let ctor \u2190 mkCtor view levelParams params fieldInfos\n        let type \u2190 mkForallFVars params type\n        let type \u2190 instantiateMVars type\n        let indType := { name := view.declName, type := type, ctors := [ctor] : InductiveType }\n        let decl    := Declaration.inductDecl levelParams params.size [indType] view.modifiers.isUnsafe\n        Term.ensureNoUnassignedMVars decl\n        addDecl decl\n        let projNames := (fieldInfos.filter fun (info : StructFieldInfo) => !info.isFromParent).toList.map fun (info : StructFieldInfo) => info.declName\n        addProjections view.declName projNames view.isClass\n        registerStructure view.declName fieldInfos\n        mkAuxConstructions view.declName\n        let instParents \u2190 fieldInfos.filterM fun info => do\n          let decl \u2190 Term.getFVarLocalDecl! info.fvar\n          pure (info.isSubobject && decl.binderInfo.isInstImplicit)\n        withSaveInfoContext do  Term.addLocalVarInfo view.ref[1] (\u2190 mkConstWithLevelParams view.declName)\n          if let some _ := view.ctor.ref[1].getPos? (canonicalOnly := true) then\n            Term.addTermInfo' view.ctor.ref[1] (\u2190 mkConstWithLevelParams view.ctor.declName) (isBinder := true)\n          for field in view.fields do\n            if (\u2190 getEnv).contains field.declName then\n              Term.addTermInfo' field.ref (\u2190 mkConstWithLevelParams field.declName) (isBinder := true)\n        Term.applyAttributesAt view.declName view.modifiers.attrs AttributeApplicationTime.afterTypeChecking\n        let projInstances := instParents.toList.map fun info => info.declName\n        projInstances.forM fun declName => addInstance declName AttributeKind.global (eval_prio default)\n        copiedParents.forM fun parent => mkCoercionToCopiedParent levelParams params view parent\n        let lctx \u2190 getLCtx\n        let fieldsWithDefault := fieldInfos.filter fun info => info.value?.isSome\n        let defaultAuxDecls \u2190 fieldsWithDefault.mapM fun info => do\n          let type \u2190 inferType info.fvar\n          pure (mkDefaultFnOfProjFn info.declName, type, info.value?.get!)\n        \n        let lctx :=\n          params.foldl (init := lctx) fun (lctx : LocalContext) (p : Expr) =>\n            if p.isFVar then\n              lctx.setBinderInfo p.fvarId! BinderInfo.implicit\n            else\n              lctx\n        let lctx :=\n          fieldInfos.foldl (init := lctx) fun (lctx : LocalContext) (info : StructFieldInfo) =>\n            if info.isFromParent then lctx else lctx.setBinderInfo info.fvar.fvarId! BinderInfo.default\n        addDefaults lctx defaultAuxDecls", "start": [799, 1], "end": [869, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabStructure", "code": "def elabStructure (modifiers : Modifiers) (stx : Syntax) : CommandElabM Unit := do\n  checkValidInductiveModifier modifiers\n  let isClass   := stx[0].getKind == ``Parser.Command.classTk\n  let modifiers := if isClass then modifiers.addAttribute { name := `class } else modifiers\n  let declId    := stx[1]\n  let params    := stx[2].getArgs\n  let exts      := stx[3]\n  let parents   := if exts.isNone then #[] else exts[0][1].getSepArgs\n  let optType   := stx[4]\n  let derivingClassViews \u2190 getOptDerivingClasses stx[6]\n  let type \u2190 if optType.isNone then `(Sort _) else pure optType[0][1]\n  let declName \u2190\n    runTermElabM fun scopeVars => do\n      let scopeLevelNames \u2190 Term.getLevelNames\n      let \u27e8name, declName, allUserLevelNames\u27e9 \u2190 Elab.expandDeclId (\u2190 getCurrNamespace) scopeLevelNames declId modifiers\n      Term.withAutoBoundImplicitForbiddenPred (fun n => name == n) do\n        addDeclarationRanges declName stx\n        Term.withDeclName declName do\n          let ctor \u2190 expandCtor stx modifiers declName\n          let fields \u2190 expandFields stx modifiers declName\n          Term.withLevelNames allUserLevelNames <| Term.withAutoBoundImplicit <|\n            Term.elabBinders params fun params => do\n              Term.synthesizeSyntheticMVarsNoPostponing\n              let params \u2190 Term.addAutoBoundImplicits params\n              let allUserLevelNames \u2190 Term.getLevelNames\n              elabStructureView {\n                ref := stx\n                modifiers\n                scopeLevelNames\n                allUserLevelNames\n                declName\n                isClass\n                scopeVars\n                params\n                parents\n                type\n                ctor\n                fields\n              }\n              unless isClass do\n                mkSizeOfInstances declName\n                mkInjectiveTheorems declName\n              return declName\n  derivingClassViews.forM fun view => view.applyHandlers #[declName]\n  runTermElabM fun _ => Term.withDeclName declName do\n    Term.applyAttributesAt declName modifiers.attrs .afterCompilation", "start": [883, 1], "end": [928, 70], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/MutualDef.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Match.lean", "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Options.lean", "lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Lean/Meta/Closure.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/DefView.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Main.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean"], "premises": [{"full_name": "Lean.Elab.DefViewElabHeader", "code": "structure DefViewElabHeader where\n  ref           : Syntax\n  modifiers     : Modifiers\n  \n  kind          : DefKind\n  \n  shortDeclName : Name\n  \n  declName      : Name\n  \n  levelNames    : List Name\n  \n  binderIds     : Array Syntax\n  \n  numParams     : Nat\n  \n  type          : Expr\n  \n  valueStx      : Syntax\n  deriving Inhabited", "start": [21, 1], "end": [43, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.checkModifiers", "code": "private def checkModifiers (m\u2081 m\u2082 : Modifiers) : TermElabM Unit := do\n  unless m\u2081.isUnsafe == m\u2082.isUnsafe do\n    throwError \"cannot mix unsafe and safe definitions\"\n  unless m\u2081.isNoncomputable == m\u2082.isNoncomputable do\n    throwError \"cannot mix computable and non-computable definitions\"\n  unless m\u2081.isPartial == m\u2082.isPartial do\n    throwError \"cannot mix partial and non-partial definitions\"", "start": [48, 1], "end": [54, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.checkKinds", "code": "private def checkKinds (k\u2081 k\u2082 : DefKind) : TermElabM Unit := do\n  unless k\u2081.isExample == k\u2082.isExample do\n    throwError \"cannot mix examples and definitions\" unless k\u2081.isTheorem == k\u2082.isTheorem do\n    throwError \"cannot mix theorems and definitions\"", "start": [56, 1], "end": [60, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.check", "code": "private def check (prevHeaders : Array DefViewElabHeader) (newHeader : DefViewElabHeader) : TermElabM Unit := do\n  if newHeader.kind.isTheorem && newHeader.modifiers.isUnsafe then\n    throwError \"'unsafe' theorems are not allowed\"\n  if newHeader.kind.isTheorem && newHeader.modifiers.isPartial then\n    throwError \"'partial' theorems are not allowed, 'partial' is a code generation directive\"\n  if newHeader.kind.isTheorem && newHeader.modifiers.isNoncomputable then\n    throwError \"'theorem' subsumes 'noncomputable', code is not generated for theorems\"\n  if newHeader.modifiers.isNoncomputable && newHeader.modifiers.isUnsafe then\n    throwError \"'noncomputable unsafe' is not allowed\"\n  if newHeader.modifiers.isNoncomputable && newHeader.modifiers.isPartial then\n    throwError \"'noncomputable partial' is not allowed\"\n  if newHeader.modifiers.isPartial && newHeader.modifiers.isUnsafe then\n    throwError \"'unsafe' subsumes 'partial'\"\n  if h : 0 < prevHeaders.size then\n    let firstHeader := prevHeaders.get \u27e80, h\u27e9\n    try\n      unless newHeader.levelNames == firstHeader.levelNames do\n        throwError \"universe parameters mismatch\"\n      checkModifiers newHeader.modifiers firstHeader.modifiers\n      checkKinds newHeader.kind firstHeader.kind\n    catch\n       | .error ref msg => throw (.error ref m!\"invalid mutually recursive definitions, {msg}\")\n       | ex => throw ex\n  else\n    pure ()", "start": [62, 1], "end": [86, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerFailedToInferDefTypeInfo", "code": "private def registerFailedToInferDefTypeInfo (type : Expr) (ref : Syntax) : TermElabM Unit :=\n  registerCustomErrorIfMVar type ref \"failed to infer definition type\"", "start": [88, 1], "end": [89, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isMultiConstant?", "code": "private def isMultiConstant? (views : Array DefView) : Option (List Name) :=\n  if views.size == 1 &&\n     views[0]!.kind == .opaque &&\n     views[0]!.binders.getArgs.size > 0 &&\n     views[0]!.binders.getArgs.all (\u00b7.isIdent) then\n    some (views[0]!.binders.getArgs.toList.map (\u00b7.getId))\n  else\n    none", "start": [91, 1], "end": [103, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getPendindMVarErrorMessage", "code": "private def getPendindMVarErrorMessage (views : Array DefView) : String :=\n  match isMultiConstant? views with\n  | some ids =>\n    let idsStr := \", \".intercalate <| ids.map fun id => s!\"`{id}`\"\n    let paramsStr := \", \".intercalate <| ids.map fun id => s!\"`({id} : _)`\"\n    s!\"\\nrecall that you cannot declare multiple constants in a single declaration. The identifier(s) {idsStr} are being interpreted as parameters {paramsStr}\"\n  | none =>\n    \"\\nwhen the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed\"", "start": [105, 1], "end": [112, 163], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.cleanupOfNat", "code": "private def cleanupOfNat (type : Expr) : MetaM Expr := do\n  Meta.transform type fun e => do\n    if !e.isAppOfArity ``OfNat 2 then return .continue\n    let arg \u2190 instantiateMVars e.appArg!\n    if !arg.isAppOfArity ``OfNat.ofNat 3 then return .continue\n    let argArgs := arg.getAppArgs\n    if !argArgs[0]!.isConstOf ``Nat then return .continue\n    let eNew := mkApp e.appFn! argArgs[1]!\n    return .done eNew", "start": [114, 1], "end": [128, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabHeaders", "code": "private def elabHeaders (views : Array DefView) : TermElabM (Array DefViewElabHeader) := do\n  let expandedDeclIds \u2190 views.mapM fun view => withRef view.ref do\n    Term.expandDeclId (\u2190 getCurrNamespace) (\u2190 getLevelNames) view.declId view.modifiers\n  withAutoBoundImplicitForbiddenPred (fun n => expandedDeclIds.any (\u00b7.shortName == n)) do\n    let mut headers := #[]\n    for view in views, \u27e8shortDeclName, declName, levelNames\u27e9 in expandedDeclIds do\n      let newHeader \u2190 withRef view.ref do\n        addDeclarationRanges declName view.ref\n        applyAttributesAt declName view.modifiers.attrs .beforeElaboration\n        withDeclName declName <| withAutoBoundImplicit <| withLevelNames levelNames <|\n          elabBindersEx view.binders.getArgs fun xs => do\n            let refForElabFunType := view.value\n            let mut type \u2190 match view.type? with\n              | some typeStx =>\n                let type \u2190 elabType typeStx\n                registerFailedToInferDefTypeInfo type typeStx\n                pure type\n              | none =>\n                let hole := mkHole refForElabFunType\n                let type \u2190 elabType hole\n                trace[Elab.definition] \">> type: {type}\\n{type.mvarId!}\"\n                registerFailedToInferDefTypeInfo type refForElabFunType\n                pure type\n            Term.synthesizeSyntheticMVarsNoPostponing\n            if view.isInstance then\n              type \u2190 cleanupOfNat type\n            let (binderIds, xs) := xs.unzip\n            let xs \u2190 addAutoBoundImplicits xs\n            type \u2190 mkForallFVars' xs type\n            type \u2190 instantiateMVars type\n            let levelNames \u2190 getLevelNames\n            if view.type?.isSome then\n              let pendingMVarIds \u2190 getMVars type\n              discard <| logUnassignedUsingErrorInfos pendingMVarIds <|\n                getPendindMVarErrorMessage views\n            let newHeader := {\n              ref           := view.ref\n              modifiers     := view.modifiers\n              kind          := view.kind\n              shortDeclName := shortDeclName\n              declName, type, levelNames, binderIds\n              numParams     := xs.size\n              valueStx      := view.value : DefViewElabHeader }\n            check headers newHeader\n            return newHeader\n      headers := headers.push newHeader\n    return headers", "start": [130, 1], "end": [178, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withFunLocalDecls", "code": "private partial def withFunLocalDecls {\u03b1} (headers : Array DefViewElabHeader) (k : Array Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  let rec loop (i : Nat) (fvars : Array Expr) := do\n    if h : i < headers.size then\n      let header := headers.get \u27e8i, h\u27e9\n      if header.modifiers.isNonrec then\n        loop (i+1) fvars\n      else\n        withAuxDecl header.shortDeclName header.type header.declName fun fvar => loop (i+1) (fvars.push fvar)\n    else\n      k fvars\n  loop 0 #[]", "start": [180, 1], "end": [195, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandWhereStructInst", "code": "private def expandWhereStructInst : Macro\n  | `(Parser.Command.whereStructInst|where $[$decls:letDecl];* $[$whereDecls?:whereDecls]?) => do\n    let letIdDecls \u2190 decls.mapM fun stx => match stx with\n      | `(letDecl|$_decl:letPatDecl) => Macro.throwErrorAt stx \"patterns are not allowed here\"\n      | `(letDecl|$decl:letEqnsDecl) => expandLetEqnsDecl decl (useExplicit := false)\n      | `(letDecl|$decl:letIdDecl)   => pure decl\n      | _                            => Macro.throwUnsupported\n    let structInstFields \u2190 letIdDecls.mapM fun\n      | stx@`(letIdDecl|$id:ident $binders* $[: $ty?]? := $val) => withRef stx do\n        let mut val := val\n        if let some ty := ty? then\n          val \u2190 `(($val : $ty))\n        have : Coe (TSyntax ``letIdBinder) (TSyntax ``funBinder) := \u27e8(\u27e8\u00b7\u27e9)\u27e9\n        val \u2190 if binders.size > 0 then `(fun $binders* => $val) else pure val\n        `(structInstField|$id:ident := $val)\n      | stx@`(letIdDecl|_ $_* $[: $_]? := $_) => Macro.throwErrorAt stx \"'_' is not allowed here\"\n      | _ => Macro.throwUnsupported\n    let body \u2190 `({ $structInstFields,* })\n    match whereDecls? with\n    | some whereDecls => expandWhereDecls whereDecls body\n    | none => return body\n  | _ => Macro.throwUnsupported", "start": [197, 1], "end": [219, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.declValToTerm", "code": "private def declValToTerm (declVal : Syntax) : MacroM Syntax := withRef declVal do\n  if declVal.isOfKind ``Parser.Command.declValSimple then\n    expandWhereDeclsOpt declVal[2] declVal[1]\n  else if declVal.isOfKind ``Parser.Command.declValEqns then\n    expandMatchAltsWhereDecls declVal[0]\n  else if declVal.isOfKind ``Parser.Command.whereStructInst then\n    expandWhereStructInst declVal\n  else if declVal.isMissing then\n    Macro.throwErrorAt declVal \"declaration body is missing\"\n  else\n    Macro.throwErrorAt declVal \"unexpected declaration body\"", "start": [229, 1], "end": [239, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabFunValues", "code": "private def elabFunValues (headers : Array DefViewElabHeader) : TermElabM (Array Expr) :=\n  headers.mapM fun header => withDeclName header.declName <| withLevelNames header.levelNames do\n    let valStx \u2190 liftMacroM <| declValToTerm header.valueStx\n    forallBoundedTelescope header.type header.numParams fun xs type => do\n      for i in [0:header.binderIds.size] do\n        addLocalVarInfo header.binderIds[i]! xs[header.numParams - header.binderIds.size + i]!\n      let val \u2190 elabTermEnsuringType valStx type\n      mkLambdaFVars xs val", "start": [241, 1], "end": [250, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.collectUsed", "code": "private def collectUsed (headers : Array DefViewElabHeader) (values : Array Expr) (toLift : List LetRecToLift)\n    : StateRefT CollectFVars.State MetaM Unit := do\n  headers.forM fun header => header.type.collectFVars\n  values.forM fun val => val.collectFVars\n  toLift.forM fun letRecToLift => do\n    letRecToLift.type.collectFVars\n    letRecToLift.val.collectFVars", "start": [252, 1], "end": [258, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.removeUnusedVars", "code": "private def removeUnusedVars (vars : Array Expr) (headers : Array DefViewElabHeader) (values : Array Expr) (toLift : List LetRecToLift)\n    : TermElabM (LocalContext \u00d7 LocalInstances \u00d7 Array Expr) := do\n  let (_, used) \u2190 (collectUsed headers values toLift).run {}\n  removeUnused vars used", "start": [260, 1], "end": [263, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withUsed", "code": "private def withUsed {\u03b1} (vars : Array Expr) (headers : Array DefViewElabHeader) (values : Array Expr) (toLift : List LetRecToLift)\n    (k : Array Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  let (lctx, localInsts, vars) \u2190 removeUnusedVars vars headers values toLift\n  withLCtx lctx localInsts <| k vars", "start": [265, 1], "end": [268, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isExample", "code": "private def isExample (views : Array DefView) : Bool :=\n  views.any (\u00b7.kind.isExample)", "start": [270, 1], "end": [271, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isTheorem", "code": "private def isTheorem (views : Array DefView) : Bool :=\n  views.any (\u00b7.kind.isTheorem)", "start": [273, 1], "end": [274, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.instantiateMVarsAtHeader", "code": "private def instantiateMVarsAtHeader (header : DefViewElabHeader) : TermElabM DefViewElabHeader := do\n  let type \u2190 instantiateMVars header.type\n  pure { header with type := type }", "start": [276, 1], "end": [278, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.instantiateMVarsAtLetRecToLift", "code": "private def instantiateMVarsAtLetRecToLift (toLift : LetRecToLift) : TermElabM LetRecToLift := do\n  let type \u2190 instantiateMVars toLift.type\n  let val \u2190 instantiateMVars toLift.val\n  pure { toLift with type, val }", "start": [280, 1], "end": [283, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.typeHasRecFun", "code": "private def typeHasRecFun (type : Expr) (funFVars : Array Expr) (letRecsToLift : List LetRecToLift) : Option FVarId :=\n  let occ? := type.find? fun e => match e with\n    | Expr.fvar fvarId => funFVars.contains e || letRecsToLift.any fun toLift => toLift.fvarId == fvarId\n    | _ => false\n  match occ? with\n  | some (Expr.fvar fvarId) => some fvarId\n  | _ => none", "start": [285, 1], "end": [291, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getFunName", "code": "private def getFunName (fvarId : FVarId) (letRecsToLift : List LetRecToLift) : TermElabM Name := do\n  match (\u2190 fvarId.findDecl?) with\n  | some decl => return decl.userName\n  | none =>\n    \n    match letRecsToLift.findSome? fun toLift => if toLift.fvarId == fvarId then some toLift.shortDeclName else none with\n    | none   => throwError \"unknown function\"\n    | some n => return n", "start": [293, 1], "end": [300, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.checkLetRecsToLiftTypes", "code": "private def checkLetRecsToLiftTypes (funVars : Array Expr) (letRecsToLift : List LetRecToLift) : TermElabM Unit :=\n  letRecsToLift.forM fun toLift =>\n    match typeHasRecFun toLift.type funVars letRecsToLift with\n    | none        => pure ()\n    | some fvarId => do\n      let fnName \u2190 getFunName fvarId letRecsToLift\n      throwErrorAt toLift.ref \"invalid type in 'let rec', it uses '{fnName}' which is being defined simultaneously\"", "start": [302, 1], "end": [313, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.UsedFVarsMap", "code": "abbrev UsedFVarsMap := FVarIdMap FVarIdSet", "start": [317, 1], "end": [318, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.mkInitialUsedFVarsMap", "code": "private def mkInitialUsedFVarsMap [Monad m] [MonadMCtx m] (sectionVars : Array Expr) (mainFVarIds : Array FVarId) (letRecsToLift : Array LetRecToLift)\n    : m UsedFVarsMap := do\n  let mut sectionVarSet := {}\n  for var in sectionVars do\n    sectionVarSet := sectionVarSet.insert var.fvarId!\n  let mut usedFVarMap := {}\n  for mainFVarId in mainFVarIds do\n    usedFVarMap := usedFVarMap.insert mainFVarId sectionVarSet\n  for toLift in letRecsToLift do\n    let state := Lean.collectFVars {} toLift.val\n    let state := Lean.collectFVars state toLift.type\n    let mut set := state.fvarSet\n    \n    let mvarIds := (toLift.val.collectMVars {}).result\n    for mvarId in mvarIds do\n      match (\u2190 letRecsToLift.findSomeM? fun (toLift : LetRecToLift) => return if toLift.mvarId == (\u2190 getDelayedMVarRoot mvarId) then some toLift.fvarId else none) with\n      | some fvarId => set := set.insert fvarId\n      | none        => pure ()\n    usedFVarMap := usedFVarMap.insert toLift.fvarId set\n  return usedFVarMap", "start": [320, 1], "end": [385, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.State", "code": "structure State where\n  usedFVarsMap : UsedFVarsMap := {}\n  modified     : Bool         := false", "start": [408, 1], "end": [410, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.M", "code": "abbrev M := ReaderT (Array FVarId) $ StateM State", "start": [412, 1], "end": [412, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.isModified", "code": "private def isModified : M Bool := do pure (\u2190 get).modified", "start": [414, 1], "end": [414, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.resetModified", "code": "private def resetModified : M Unit := modify fun s => { s with modified := false }", "start": [415, 1], "end": [415, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.markModified", "code": "private def markModified : M Unit := modify fun s => { s with modified := true }", "start": [416, 1], "end": [416, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.getUsedFVarsMap", "code": "private def getUsedFVarsMap : M UsedFVarsMap := do pure (\u2190 get).usedFVarsMap", "start": [417, 1], "end": [417, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.modifyUsedFVars", "code": "private def modifyUsedFVars (f : UsedFVarsMap \u2192 UsedFVarsMap) : M Unit := modify fun s => { s with usedFVarsMap := f s.usedFVarsMap }", "start": [418, 1], "end": [418, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.merge", "code": "private def merge (s\u2081 s\u2082 : FVarIdSet) : M FVarIdSet :=\n  s\u2082.foldM (init := s\u2081) fun s\u2081 k => do\n    if s\u2081.contains k then\n      return s\u2081\n    else\n      markModified\n      return s\u2081.insert k", "start": [421, 1], "end": [427, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.updateUsedVarsOf", "code": "private def updateUsedVarsOf (fvarId : FVarId) : M Unit := do\n  let usedFVarsMap \u2190 getUsedFVarsMap\n  match usedFVarsMap.find? fvarId with\n  | none         => return ()\n  | some fvarIds =>\n    let fvarIdsNew \u2190 fvarIds.foldM (init := fvarIds) fun fvarIdsNew fvarId' => do\n      if fvarId == fvarId' then\n        return fvarIdsNew\n      else\n        match usedFVarsMap.find? fvarId' with\n        | none => return fvarIdsNew\n          \n        | some otherFVarIds => merge fvarIdsNew otherFVarIds\n    modifyUsedFVars fun usedFVars => usedFVars.insert fvarId fvarIdsNew", "start": [429, 1], "end": [444, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.fixpoint", "code": "private partial def fixpoint : Unit \u2192 M Unit\n  | _ => do\n    resetModified\n    let letRecFVarIds \u2190 read\n    letRecFVarIds.forM updateUsedVarsOf\n    if (\u2190 isModified) then\n      fixpoint ()", "start": [446, 1], "end": [452, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FixPoint.run", "code": "def run (letRecFVarIds : Array FVarId) (usedFVarsMap : UsedFVarsMap) : UsedFVarsMap :=\n  let (_, s) := fixpoint () |>.run letRecFVarIds |>.run { usedFVarsMap := usedFVarsMap }\n  s.usedFVarsMap", "start": [454, 1], "end": [456, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.FreeVarMap", "code": "abbrev FreeVarMap := FVarIdMap (Array FVarId)", "start": [460, 1], "end": [460, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.mkFreeVarMap", "code": "private def mkFreeVarMap [Monad m] [MonadMCtx m]\n    (sectionVars : Array Expr) (mainFVarIds : Array FVarId)\n    (recFVarIds : Array FVarId) (letRecsToLift : Array LetRecToLift) : m FreeVarMap := do\n  let usedFVarsMap   \u2190 mkInitialUsedFVarsMap sectionVars mainFVarIds letRecsToLift\n  let letRecFVarIds  := letRecsToLift.map fun toLift => toLift.fvarId\n  let usedFVarsMap   := FixPoint.run letRecFVarIds usedFVarsMap\n  let mut freeVarMap := {}\n  for toLift in letRecsToLift do\n    let lctx       := toLift.lctx\n    let fvarIdsSet := usedFVarsMap.find? toLift.fvarId |>.get!\n    let fvarIds    := fvarIdsSet.fold (init := #[]) fun fvarIds fvarId =>\n      if lctx.contains fvarId && !recFVarIds.contains fvarId then\n        fvarIds.push fvarId\n      else\n        fvarIds\n    freeVarMap := freeVarMap.insert toLift.fvarId fvarIds\n  return freeVarMap", "start": [462, 1], "end": [478, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.ClosureState", "code": "structure ClosureState where\n  newLocalDecls : Array LocalDecl := #[]\n  localDecls    : Array LocalDecl := #[]\n  newLetDecls   : Array LocalDecl := #[]\n  exprArgs      : Array Expr      := #[]", "start": [480, 1], "end": [484, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.pickMaxFVar?", "code": "private def pickMaxFVar? (lctx : LocalContext) (fvarIds : Array FVarId) : Option FVarId :=\n  fvarIds.getMax? fun fvarId\u2081 fvarId\u2082 => (lctx.get! fvarId\u2081).index < (lctx.get! fvarId\u2082).index", "start": [486, 1], "end": [487, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.preprocess", "code": "private def preprocess (e : Expr) : TermElabM Expr := do\n  let e \u2190 instantiateMVars e\n  Meta.check e\n  pure e", "start": [489, 1], "end": [493, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.pushNewVars", "code": "private def pushNewVars (toProcess : Array FVarId) (s : CollectFVars.State) : Array FVarId :=\n  s.fvarSet.fold (init := toProcess) fun toProcess fvarId =>\n    if toProcess.contains fvarId then toProcess else toProcess.push fvarId", "start": [495, 1], "end": [498, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.pushLocalDecl", "code": "private def pushLocalDecl (toProcess : Array FVarId) (fvarId : FVarId) (userName : Name) (type : Expr) (bi : BinderInfo) (kind : LocalDeclKind)\n    : StateRefT ClosureState TermElabM (Array FVarId) := do\n  let type \u2190 preprocess type\n  modify fun s => { s with\n    newLocalDecls := s.newLocalDecls.push <| LocalDecl.cdecl default fvarId userName type bi kind\n    exprArgs      := s.exprArgs.push (mkFVar fvarId)\n  }\n  return pushNewVars toProcess (collectFVars {} type)", "start": [500, 1], "end": [507, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.mkClosureForAux", "code": "private partial def mkClosureForAux (toProcess : Array FVarId) : StateRefT ClosureState TermElabM Unit := do\n  let lctx \u2190 getLCtx\n  match pickMaxFVar? lctx toProcess with\n  | none        => return ()\n  | some fvarId =>\n    trace[Elab.definition.mkClosure] \"toProcess: {toProcess.map mkFVar}, maxVar: {mkFVar fvarId}\"\n    let toProcess := toProcess.erase fvarId\n    let localDecl \u2190 fvarId.getDecl\n    match localDecl with\n    | .cdecl _ _ userName type bi k =>\n      let toProcess \u2190 pushLocalDecl toProcess fvarId userName type bi k\n      mkClosureForAux toProcess\n    | .ldecl _ _ userName type val _ k =>\n      let zetaFVarIds \u2190 getZetaFVarIds\n      if !zetaFVarIds.contains fvarId then\n        \n        let toProcess \u2190 pushLocalDecl toProcess fvarId userName type .default k\n        mkClosureForAux toProcess\n      else\n        \n        let type \u2190 preprocess type\n        let val  \u2190 preprocess val\n        modify fun s => { s with\n          newLetDecls   := s.newLetDecls.push <| .ldecl default fvarId userName type val false k,\n          \n          newLocalDecls := s.newLocalDecls.map (\u00b7.replaceFVarId fvarId val)\n          localDecls := s.localDecls.map (\u00b7.replaceFVarId fvarId val)\n        }\n        mkClosureForAux (pushNewVars toProcess (collectFVars (collectFVars {} type) val))", "start": [509, 1], "end": [538, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.mkClosureFor", "code": "private partial def mkClosureFor (freeVars : Array FVarId) (localDecls : Array LocalDecl) : TermElabM ClosureState := do\n  let (_, s) \u2190 mkClosureForAux freeVars |>.run { localDecls := localDecls }\n  return { s with\n    newLocalDecls := s.newLocalDecls.reverse\n    newLetDecls   := s.newLetDecls.reverse\n    exprArgs      := s.exprArgs.reverse\n  }", "start": [540, 1], "end": [546, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.LetRecClosure", "code": "structure LetRecClosure where\n  ref        : Syntax\n  localDecls : Array LocalDecl\n  \n  closed     : Expr\n  toLift     : LetRecToLift", "start": [548, 1], "end": [553, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.mkLetRecClosureFor", "code": "private def mkLetRecClosureFor (toLift : LetRecToLift) (freeVars : Array FVarId) : TermElabM LetRecClosure := do\n  let lctx := toLift.lctx\n  withLCtx lctx toLift.localInstances do\n  lambdaTelescope toLift.val fun xs val => do\n    \n    let userNameAndBinderInfos \u2190 forallBoundedTelescope toLift.type xs.size fun xs _ =>\n      xs.mapM fun x => do\n        let localDecl \u2190 x.fvarId!.getDecl\n        return (localDecl.userName, localDecl.binderInfo)\n    \n    let mut userNameBinderInfoMap : FVarIdMap (Name \u00d7 BinderInfo) := {}\n    for x in xs, (userName, bi) in userNameAndBinderInfos do\n      userNameBinderInfoMap := userNameBinderInfoMap.insert x.fvarId! (userName, bi)\n    let type \u2190 instantiateForall toLift.type xs\n    let lctx \u2190 getLCtx\n    let s \u2190 mkClosureFor freeVars <| xs.map fun x => lctx.get! x.fvarId!\n    \n    let typeLocalDecls := s.localDecls.map fun localDecl =>\n      if let some (userName, bi) := userNameBinderInfoMap.find? localDecl.fvarId then\n        localDecl.setBinderInfo bi |>.setUserName userName\n      else\n        localDecl\n    let type := Closure.mkForall typeLocalDecls <| Closure.mkForall s.newLetDecls type\n    let val  := Closure.mkLambda s.localDecls <| Closure.mkLambda s.newLetDecls val\n    let c    := mkAppN (Lean.mkConst toLift.declName) s.exprArgs\n    toLift.mvarId.assign c\n    return {\n      ref        := toLift.ref\n      localDecls := s.newLocalDecls\n      closed     := c\n      toLift     := { toLift with val, type }\n    }", "start": [555, 1], "end": [589, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.mkLetRecClosures", "code": "private def mkLetRecClosures (sectionVars : Array Expr) (mainFVarIds : Array FVarId) (recFVarIds : Array FVarId) (letRecsToLift : Array LetRecToLift) : TermElabM (List LetRecClosure) := do\n  let mut letRecsToLift := letRecsToLift\n  let mut freeVarMap    \u2190 mkFreeVarMap sectionVars mainFVarIds recFVarIds letRecsToLift\n  let mut result := #[]\n  for i in [:letRecsToLift.size] do\n    if letRecsToLift[i]!.val.hasExprMVar then\n      let valNew \u2190 instantiateMVars letRecsToLift[i]!.val\n      letRecsToLift := letRecsToLift.modify i fun t => { t with val := valNew }\n      freeVarMap \u2190 mkFreeVarMap sectionVars mainFVarIds recFVarIds letRecsToLift\n    let toLift := letRecsToLift[i]!\n    result := result.push (\u2190 mkLetRecClosureFor toLift (freeVarMap.find? toLift.fvarId).get!)\n  return result.toList", "start": [591, 1], "end": [607, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.Replacement", "code": "abbrev Replacement := FVarIdMap Expr", "start": [609, 1], "end": [610, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.insertReplacementForMainFns", "code": "def insertReplacementForMainFns (r : Replacement) (sectionVars : Array Expr) (mainHeaders : Array DefViewElabHeader) (mainFVars : Array Expr) : Replacement :=\n  mainFVars.size.fold (init := r) fun i r =>\n    r.insert mainFVars[i]!.fvarId! (mkAppN (Lean.mkConst mainHeaders[i]!.declName) sectionVars)", "start": [612, 1], "end": [614, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.insertReplacementForLetRecs", "code": "def insertReplacementForLetRecs (r : Replacement) (letRecClosures : List LetRecClosure) : Replacement :=\n  letRecClosures.foldl (init := r) fun r c =>\n    r.insert c.toLift.fvarId c.closed", "start": [617, 1], "end": [619, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.Replacement.apply", "code": "def Replacement.apply (r : Replacement) (e : Expr) : Expr :=\n  e.replace fun e => match e with\n    | .fvar fvarId => match r.find? fvarId with\n      | some c => some c\n      | _      => none\n    | _ => none", "start": [621, 1], "end": [626, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.pushMain", "code": "def pushMain (preDefs : Array PreDefinition) (sectionVars : Array Expr) (mainHeaders : Array DefViewElabHeader) (mainVals : Array Expr)\n    : TermElabM (Array PreDefinition) :=\n  mainHeaders.size.foldM (init := preDefs) fun i preDefs => do\n    let header := mainHeaders[i]!\n    let value \u2190 mkLambdaFVars sectionVars mainVals[i]!\n    let type \u2190 mkForallFVars sectionVars header.type\n    return preDefs.push {\n      ref         := getDeclarationSelectionRef header.ref\n      kind        := header.kind\n      declName    := header.declName\n      levelParams := [], modifiers   := header.modifiers\n      type, value\n    }", "start": [628, 1], "end": [641, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.pushLetRecs", "code": "def pushLetRecs (preDefs : Array PreDefinition) (letRecClosures : List LetRecClosure) (kind : DefKind) (modifiers : Modifiers) : MetaM (Array PreDefinition) :=\n  letRecClosures.foldlM (init := preDefs) fun preDefs c => do\n    let type  := Closure.mkForall c.localDecls c.toLift.type\n    let value := Closure.mkLambda c.localDecls c.toLift.val\n    let kind \u2190 if kind.isDefOrAbbrevOrOpaque then\n      withLCtx c.toLift.lctx c.toLift.localInstances do\n        return if (\u2190 inferType c.toLift.type).isProp then .theorem else kind\n    else\n      pure kind\n    return preDefs.push {\n      ref         := c.ref\n      declName    := c.toLift.declName\n      levelParams := [] modifiers   := { modifiers with attrs := c.toLift.attrs }\n      kind, type, value\n    }", "start": [643, 1], "end": [659, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.getKindForLetRecs", "code": "def getKindForLetRecs (mainHeaders : Array DefViewElabHeader) : DefKind :=\n  if mainHeaders.any fun h => h.kind.isTheorem then DefKind.\u00abtheorem\u00bb\n  else DefKind.\u00abdef\u00bb", "start": [661, 1], "end": [663, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.getModifiersForLetRecs", "code": "def getModifiersForLetRecs (mainHeaders : Array DefViewElabHeader) : Modifiers := {\n  isNoncomputable := mainHeaders.any fun h => h.modifiers.isNoncomputable\n  recKind         := if mainHeaders.any fun h => h.modifiers.isPartial then RecKind.partial else RecKind.default\n  isUnsafe        := mainHeaders.any fun h => h.modifiers.isUnsafe\n}", "start": [665, 1], "end": [669, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MutualClosure.main", "code": "def main (sectionVars : Array Expr) (mainHeaders : Array DefViewElabHeader) (mainFVars : Array Expr) (mainVals : Array Expr) (letRecsToLift : List LetRecToLift)\n    : TermElabM (Array PreDefinition) := do\n  let letRecsToLift := letRecsToLift.toArray\n  let mainFVarIds := mainFVars.map Expr.fvarId!\n  let recFVarIds  := (letRecsToLift.map fun toLift => toLift.fvarId) ++ mainFVarIds\n  resetZetaFVarIds\n  withTrackingZeta do\n    let letRecsToLift \u2190 letRecsToLift.mapM fun toLift => withLCtx toLift.lctx toLift.localInstances do\n      Meta.check toLift.type\n      Meta.check toLift.val\n      return { toLift with val := (\u2190 instantiateMVars toLift.val), type := (\u2190 instantiateMVars toLift.type) }\n    let letRecClosures \u2190 mkLetRecClosures sectionVars mainFVarIds recFVarIds letRecsToLift\n    let mainVals    \u2190 mainVals.mapM (instantiateMVars \u00b7)\n    let mainHeaders \u2190 mainHeaders.mapM instantiateMVarsAtHeader\n    let letRecClosures \u2190 letRecClosures.mapM fun closure => do pure { closure with toLift := (\u2190 instantiateMVarsAtLetRecToLift closure.toLift) }\n    let r              := insertReplacementForMainFns {} sectionVars mainHeaders mainFVars\n    let r              := insertReplacementForLetRecs r letRecClosures\n    let mainVals       := mainVals.map r.apply\n    let mainHeaders    := mainHeaders.map fun h => { h with type := r.apply h.type }\n    let letRecClosures := letRecClosures.map fun c => { c with toLift := { c.toLift with type := r.apply c.toLift.type, val := r.apply c.toLift.val } }\n    let letRecKind     := getKindForLetRecs mainHeaders\n    let letRecMods     := getModifiersForLetRecs mainHeaders\n    pushMain (\u2190 pushLetRecs #[] letRecClosures letRecKind letRecMods) sectionVars mainHeaders mainVals", "start": [671, 1], "end": [704, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getAllUserLevelNames", "code": "private def getAllUserLevelNames (headers : Array DefViewElabHeader) : List Name :=\n  if h : 0 < headers.size then\n    (headers.get \u27e80, h\u27e9).levelNames\n  else\n    []", "start": [708, 1], "end": [713, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.levelMVarToParamHeaders", "code": "private def levelMVarToParamHeaders (views : Array DefView) (headers : Array DefViewElabHeader) : TermElabM (Array DefViewElabHeader) := do\n  let rec process : StateRefT Nat TermElabM (Array DefViewElabHeader) := do\n    let mut newHeaders := #[]\n    for view in views, header in headers do\n      if view.kind.isTheorem then\n        newHeaders \u2190\n          withLevelNames header.levelNames do\n            return newHeaders.push { header with type := (\u2190 levelMVarToParam header.type), levelNames := (\u2190 getLevelNames) }\n      else\n        newHeaders := newHeaders.push header\n    return newHeaders\n  let newHeaders \u2190 (process).run' 1\n  newHeaders.mapM fun header => return { header with type := (\u2190 instantiateMVars header.type) }", "start": [715, 1], "end": [728, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.checkForHiddenUnivLevels", "code": "partial def checkForHiddenUnivLevels (allUserLevelNames : List Name) (preDefs : Array PreDefinition) : TermElabM Unit :=\n  unless (\u2190 MonadLog.hasErrors) do\n    let mut sTypes : CollectLevelParams.State := {}\n    let mut sValues : CollectLevelParams.State := {}\n    for preDef in preDefs do\n      sTypes  := collectLevelParams sTypes preDef.type\n      sValues := collectLevelParams sValues preDef.value\n    if sValues.params.all fun u => sTypes.params.contains u || allUserLevelNames.contains u then\n      return ()\n    let checkPreDef (preDef : PreDefinition) : TermElabM Unit :=\n      let rec visitLevel (u : Level) : ReaderT Expr TermElabM Unit := do\n        match u with\n        | .succ u => visitLevel u\n        | .imax u v | .max u v => visitLevel u; visitLevel v\n        | .param n =>\n          unless sTypes.visitedLevel.contains u || allUserLevelNames.contains n do\n            let parent \u2190 withOptions (fun o => pp.universes.set o true) do addMessageContext m!\"{indentExpr (\u2190 read)}\"\n            let body \u2190 withOptions (fun o => pp.letVarTypes.setIfNotSet (pp.funBinderTypes.setIfNotSet o true) true) do addMessageContext m!\"{indentExpr preDef.value}\"\n            throwError \"invalid occurrence of universe level '{u}' at '{preDef.declName}', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression{parent}\\nat declaration body{body}\"\n        | _ => pure ()\n      let rec visit (e : Expr) : ReaderT Expr (MonadCacheT ExprStructEq Unit TermElabM) Unit := do\n        checkCache { val := e : ExprStructEq } fun _ => do\n          match e with\n          | .forallE n d b c | .lam n d b c => visit d e; withLocalDecl n c d fun x => visit (b.instantiate1 x) e\n          | .letE n t v b _  => visit t e; visit v e; withLetDecl n t v fun x => visit (b.instantiate1 x) e\n          | .app ..        => e.withApp fun f args => do visit f e; args.forM fun arg => visit arg e\n          | .mdata _ b     => visit b e\n          | .proj _ _ b    => visit b e\n          | .sort u        => visitLevel u (\u2190 read)\n          | .const _ us    => us.forM (visitLevel \u00b7 (\u2190 read))\n          | _              => pure ()\n      visit preDef.value preDef.value |>.run {}\n    for preDef in preDefs do\n      checkPreDef preDef", "start": [730, 1], "end": [767, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabMutualDef", "code": "def elabMutualDef (vars : Array Expr) (views : Array DefView) (hints : TerminationHints) : TermElabM Unit :=\n  if isExample views then\n    withoutModifyingEnv do\n      withSaveInfoContext do\n        go\n  else\n    go\nwhere\n  go := do\n    let scopeLevelNames \u2190 getLevelNames\n    let headers \u2190 elabHeaders views\n    let headers \u2190 levelMVarToParamHeaders views headers\n    let allUserLevelNames := getAllUserLevelNames headers\n    withFunLocalDecls headers fun funFVars => do\n      for view in views, funFVar in funFVars do\n        addLocalVarInfo view.declId funFVar\n      let values \u2190\n        try\n          let values \u2190 elabFunValues headers\n          Term.synthesizeSyntheticMVarsNoPostponing\n          values.mapM (instantiateMVars \u00b7)\n        catch ex =>\n          logException ex\n          headers.mapM fun header => mkSorry header.type (synthetic := true)\n      let headers \u2190 headers.mapM instantiateMVarsAtHeader\n      let letRecsToLift \u2190 getLetRecsToLift\n      let letRecsToLift \u2190 letRecsToLift.mapM instantiateMVarsAtLetRecToLift\n      checkLetRecsToLiftTypes funFVars letRecsToLift\n      withUsed vars headers values letRecsToLift fun vars => do\n        let preDefs \u2190 MutualClosure.main vars headers funFVars values letRecsToLift\n        for preDef in preDefs do\n          trace[Elab.definition] \"{preDef.declName} : {preDef.type} :=\\n{preDef.value}\"\n        let preDefs \u2190 withLevelNames allUserLevelNames <| levelMVarToParamPreDecls preDefs\n        let preDefs \u2190 instantiateMVarsAtPreDecls preDefs\n        let preDefs \u2190 fixLevelParams preDefs scopeLevelNames allUserLevelNames\n        for preDef in preDefs do\n          trace[Elab.definition] \"after eraseAuxDiscr, {preDef.declName} : {preDef.type} :=\\n{preDef.value}\"\n        checkForHiddenUnivLevels allUserLevelNames preDefs\n        addPreDefinitions preDefs hints\n        processDeriving headers\n\n  processDeriving (headers : Array DefViewElabHeader) := do\n    for header in headers, view in views do\n      if let some classNamesStx := view.deriving? then\n        for classNameStx in classNamesStx do\n          let className \u2190 resolveGlobalConstNoOverload classNameStx\n          withRef classNameStx do\n            unless (\u2190 processDefDeriving className header.declName) do\n              throwError \"failed to synthesize instance '{className}' for '{header.declName}'\"", "start": [769, 1], "end": [818, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabMutualDef", "code": "def elabMutualDef (ds : Array Syntax) (hints : TerminationHints) : CommandElabM Unit := do\n  let views \u2190 ds.mapM fun d => do\n    let modifiers \u2190 elabModifiers d[0]\n    if ds.size > 1 && modifiers.isNonrec then\n      throwErrorAt d \"invalid use of 'nonrec' modifier in 'mutual' block\"\n    mkDefView modifiers d[1]\n  runTermElabM fun vars => Term.elabMutualDef vars views hints", "start": [823, 1], "end": [829, 63], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Calc.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Calc.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.evalCalc", "code": "@[builtin_tactic calcTactic]\ndef evalCalc : Tactic := fun stx => withMainContext do\n  let steps : TSyntax ``calcSteps := \u27e8stx[1]\u27e9\n  let (val, mvarIds) \u2190 withCollectingNewGoalsFrom (tagSuffix := `calc) do\n    let target \u2190 getMainTarget\n    let tag \u2190 getMainTag\n    runTermElab do\n    let mut val \u2190 Term.elabCalcSteps steps\n    let mut valType \u2190 inferType val\n    unless (\u2190 isDefEq valType target) do\n      let rec throwFailed :=\n        throwError \"'calc' tactic failed, has type{indentExpr valType}\\nbut it is expected to have type{indentExpr target}\"\n      let some (_, _, rhs) \u2190 Term.getCalcRelation? valType | throwFailed\n      let some (r, _, rhs') \u2190 Term.getCalcRelation? target | throwFailed\n      let lastStep := mkApp2 r rhs rhs'\n      let lastStepGoal \u2190 mkFreshExprSyntheticOpaqueMVar lastStep (tag := tag ++ `calc.step)\n      (val, valType) \u2190 Term.mkCalcTrans val valType lastStepGoal lastStep\n      unless (\u2190 isDefEq valType target) do throwFailed\n    return val\n  (\u2190 getMainGoal).assign val\n  replaceMainGoal mvarIds", "start": [12, 1], "end": [33, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Match.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Match.lean", "lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Induction.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.mkAuxiliaryMatchTerm", "code": "private def mkAuxiliaryMatchTerm (parentTag : Name) (matchTac : Syntax) : MacroM (Term \u00d7 Array Syntax) := do\n  let matchAlts := matchTac[5]\n  let alts      := matchAlts[0].getArgs\n  let mut newAlts := #[]\n  let mut nextIdx := 1\n  let mut newCases := #[]\n  for alt in alts do\n    let alt := alt.setKind ``Parser.Term.matchAlt\n    let holeOrTacticSeq := alt[3]\n    for patGroup in alt[1].getSepArgs do\n      let mut alt := alt.setArg 1 (mkNullNode #[patGroup])\n      if holeOrTacticSeq.isOfKind ``Parser.Term.syntheticHole then\n        pure ()\n      else if holeOrTacticSeq.isOfKind ``Parser.Term.hole then\n        let tag := if alts.size > 1 then parentTag ++ (`match).appendIndexAfter nextIdx else parentTag\n        let holeName := mkIdentFrom holeOrTacticSeq tag\n        let newHole \u2190 `(?$holeName:ident)\n        nextIdx := nextIdx + 1\n        alt := alt.setArg 3 newHole\n      else\n        let newHole \u2190 withFreshMacroScope `(?rhs)\n        let newHoleId := newHole.raw[1]\n        let newCase \u2190 `(tactic|\n          case $newHoleId:ident =>%$(alt[2])\n            with_annotate_state $(mkNullNode #[alt[0], alt[2]]) skip\n            $holeOrTacticSeq)\n        newCases := newCases.push newCase\n        alt := alt.setArg 3 newHole\n      newAlts := newAlts.push alt\n  let result  := matchTac.setKind ``Parser.Term.\u00abmatch\u00bb\n  let result  := result.setArg 5 (mkNode ``Parser.Term.matchAlts #[mkNullNode newAlts])\n  return (result, newCases)", "start": [16, 1], "end": [49, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalMatch", "code": "@[builtin_tactic Lean.Parser.Tactic.match]\ndef evalMatch : Tactic := fun stx => do\n  let tag \u2190 getMainTag\n  let (matchTerm, casesStx) \u2190 liftMacroM <| mkAuxiliaryMatchTerm tag stx\n  let refineMatchTerm \u2190 `(tactic| refine no_implicit_lambda% $matchTerm)\n  let stxNew := mkNullNode (#[refineMatchTerm] ++ casesStx)\n  withMacroExpansion stx stxNew <| evalTactic stxNew", "start": [51, 1], "end": [57, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Meta.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.runTactic", "code": "def runTactic (mvarId : MVarId) (tacticCode : Syntax) (ctx : Context := {}) (s : State := {}) : MetaM (List MVarId \u00d7 State) := do\n  instantiateMVarDeclMVars mvarId\n  let go : TermElabM (List MVarId) :=\n    withSynthesize (mayPostpone := false) do Tactic.run mvarId (Tactic.evalTactic tacticCode *> Tactic.pruneSolvedGoals)\n  go.run ctx s", "start": [12, 1], "end": [17, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Pattern.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Delta.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Unfold.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Simp.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Change.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Congr.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Congr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Congr.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Lean.Elab.Tactic.evalCongr", "code": "@[builtin_tactic Parser.Tactic.congr] def evalCongr : Tactic := fun stx =>\n  match stx with\n  | `(tactic| congr $[$n?]?) =>\n    let hugeDepth := 1000000\n    let depth := n?.map (\u00b7.getNat) |>.getD hugeDepth\n    liftMetaTactic fun mvarId => mvarId.congrN depth\n  | _ => throwUnsupportedSyntax", "start": [12, 1], "end": [18, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Injection.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Injection.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.getInjectionNewIds", "code": "private def getInjectionNewIds (stx : Syntax) : List Name :=\n  if stx.isNone then\n    []\n  else\n    stx[1].getArgs.toList.map getNameOfIdent'", "start": [12, 1], "end": [16, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.checkUnusedIds", "code": "private def checkUnusedIds (tacticName : Name) (mvarId : MVarId) (unusedIds : List Name) : MetaM Unit :=\n  unless unusedIds.isEmpty do\n    Meta.throwTacticEx tacticName mvarId m!\"too many identifiers provided, unused: {unusedIds}\"", "start": [18, 1], "end": [20, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.tryAssumption", "code": "private def tryAssumption (mvarId : MVarId) : MetaM (List MVarId) := do\n  if (\u2190 mvarId.assumptionCore) then\n    return []\n  else\n    return [mvarId]", "start": [23, 1], "end": [27, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalInjection", "code": "@[builtin_tactic \u00abinjection\u00bb] def evalInjection : Tactic := fun stx => do\n  let fvarId \u2190 elabAsFVar stx[1]\n  let ids := getInjectionNewIds stx[2]\n  liftMetaTactic fun mvarId => do\n    match (\u2190 Meta.injection mvarId fvarId ids) with\n    | .solved                      => checkUnusedIds `injection mvarId ids; return []\n    | .subgoal mvarId' _ unusedIds => checkUnusedIds `injection mvarId unusedIds; tryAssumption mvarId'", "start": [29, 1], "end": [36, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalInjections", "code": "@[builtin_tactic \u00abinjections\u00bb] def evalInjections : Tactic := fun stx => do\n  let ids := stx[1].getArgs.toList.map getNameOfIdent'\n  liftMetaTactic fun mvarId => do\n    match (\u2190 Meta.injections mvarId ids) with\n    | .solved                    => checkUnusedIds `injections mvarId ids; return []\n    | .subgoal mvarId' unusedIds => checkUnusedIds `injections mvarId unusedIds; tryAssumption mvarId'", "start": [38, 1], "end": [43, 103], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Cache.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.equivMVarDecl", "code": "private def equivMVarDecl (d\u2081 d\u2082 : MetavarDecl) : Bool :=\n  d\u2081.type == d\u2082.type", "start": [11, 1], "end": [12, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.dbg_cache", "code": "private def dbg_cache (msg : String) : TacticM Unit := do\n  if tactic.dbg_cache.get (\u2190 getOptions) then\n    dbg_trace msg", "start": [32, 1], "end": [34, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.dbg_cache'", "code": "private def dbg_cache' (cacheRef : IO.Ref Cache) (pos : String.Pos) (mvarId : MVarId) (msg : String) : TacticM Unit := do\n  if tactic.dbg_cache.get (\u2190 getOptions) then\n    let {line, column} := (\u2190 getFileMap).toPosition pos\n    dbg_trace \"{msg}, cache size: {(\u2190 cacheRef.get).pre.size}, line: {line}, column: {column}, contains entry: {(\u2190 cacheRef.get).pre.find? { mvarId, pos } |>.isSome}\"", "start": [36, 1], "end": [39, 167], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.findCache?", "code": "private def findCache? (cacheRef : IO.Ref Cache) (mvarId : MVarId) (stx : Syntax) (pos : String.Pos) : TacticM (Option Snapshot) := do\n  let some s := (\u2190 cacheRef.get).pre.find? { mvarId, pos } | do dbg_cache \"cache key not found\"; return none\n  let mvarDecl \u2190 mvarId.getDecl\n  let some mvarDeclOld := s.meta.mctx.findDecl? mvarId | return none\n  if equivMVarDecl mvarDecl mvarDeclOld then\n    if stx == s.stx then\n      return some s\n    else\n      dbg_cache \"syntax is different\"\n      return none\n  else\n    dbg_cache \"cached state is not compatible\"\n    return none", "start": [41, 1], "end": [53, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalCheckpoint", "code": "@[builtin_tactic checkpoint] def evalCheckpoint : Tactic := fun stx =>\n  focus do\n    let mvarId \u2190 getMainGoal\n    let some cacheRef := (\u2190 readThe Term.Context).tacticCache? | evalTactic stx[1]\n    let some pos := stx.getPos? | evalTactic stx[1]\n    match (\u2190 findCache? cacheRef mvarId stx[1] pos) with\n    | some s =>\n      cacheRef.modify fun { pre, post } => { pre, post := post.insert { mvarId, pos } s }\n      set s.core\n      set s.meta\n      set s.term\n      set s.tactic\n      dbg_cache' cacheRef pos mvarId \"cache hit\"\n    | none =>\n      evalTactic stx[1]\n      let s := {\n        stx    := stx[1]\n        core   := (\u2190 getThe Core.State)\n        meta   := (\u2190 getThe Meta.State)\n        term   := (\u2190 getThe Term.State)\n        tactic := (\u2190 get)\n      }\n      dbg_cache' cacheRef pos mvarId \"cache miss\"\n      cacheRef.modify fun { pre, post } => { pre, post := post.insert { mvarId, pos } s }", "start": [55, 1], "end": [78, 90], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Util/Basic.lean", "imports": ["lake-packages/std/Std/Lean/Format.lean", "lake-packages/std/Std/Lean/Expr.lean", "lake-packages/std/Std/Lean/Meta/DiscrTree.lean", "lake-packages/aesop/Aesop/Util/UnionFind.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Lean/PersistentHashSet.lean", "lake-packages/std/Std/Tactic/TryThis.lean", "lake-packages/aesop/Aesop/Nanos.lean", "lake-packages/aesop/Aesop/Util/UnorderedArraySet.lean"], "premises": [{"full_name": "Aesop.Subarray.popFront?", "code": "def popFront? (as : Subarray \u03b1) : Option (\u03b1 \u00d7 Subarray \u03b1) :=\n  if h : as.start < as.stop\n    then\n      let head := as.as.get \u27e8as.start, Nat.lt_of_lt_of_le h as.h\u2082\u27e9\n      let tail :=\n        { as with\n          start := as.start + 1\n          h\u2081 := Nat.le_of_lt_succ $ Nat.succ_lt_succ h  }\n      some (head, tail)\n    else\n      none", "start": [21, 1], "end": [31, 11], "kind": "commanddeclaration"}, {"full_name": "time", "code": "@[inline]\ndef time [Monad m] [MonadLiftT BaseIO m] (x : m \u03b1) : m (\u03b1 \u00d7 Aesop.Nanos) := do\n  let start \u2190 IO.monoNanosNow\n  let a \u2190 x\n  let stop \u2190 IO.monoNanosNow\n  return (a, \u27e8stop - start\u27e9)", "start": [35, 1], "end": [40, 29], "kind": "commanddeclaration"}, {"full_name": "time'", "code": "@[inline]\ndef time' [Monad m] [MonadLiftT BaseIO m] (x : m Unit) : m Aesop.Nanos := do\n  let start \u2190 IO.monoNanosNow\n  x\n  let stop \u2190 IO.monoNanosNow\n  return \u27e8stop - start\u27e9", "start": [42, 1], "end": [47, 24], "kind": "commanddeclaration"}, {"full_name": "HashSet.filter", "code": "def filter [BEq \u03b1] [Hashable \u03b1] (hs : HashSet \u03b1) (p : \u03b1 \u2192 Bool) : HashSet \u03b1 :=\n  hs.fold (init := \u2205) \u03bb hs a => if p a then hs.insert a else hs", "start": [52, 1], "end": [53, 64], "kind": "commanddeclaration"}, {"full_name": "PersistentHashSet.toList", "code": "@[inline]\ndef toList [BEq \u03b1] [Hashable \u03b1] (s : PersistentHashSet \u03b1) :\n    List \u03b1 :=\n  s.fold (init := []) \u03bb as a => a :: as", "start": [60, 1], "end": [63, 40], "kind": "commanddeclaration"}, {"full_name": "PersistentHashSet.toArray", "code": "@[inline]\ndef toArray [BEq \u03b1] [Hashable \u03b1] (s : PersistentHashSet \u03b1) :\n    Array \u03b1 :=\n  s.fold (init := Array.mkEmpty s.size) \u03bb as a => as.push a", "start": [67, 1], "end": [70, 60], "kind": "commanddeclaration"}, {"full_name": "getConclusionDiscrTreeKeys", "code": "def getConclusionDiscrTreeKeys (type : Expr) :\n    MetaM (Array (Key s)) :=\n  withoutModifyingState do\n    let (_, _, conclusion) \u2190 forallMetaTelescope type\n    mkPath conclusion", "start": [80, 1], "end": [84, 22], "kind": "commanddeclaration"}, {"full_name": "getConstDiscrTreeKeys", "code": "def getConstDiscrTreeKeys (decl : Name) : MetaM (Array (Key s)) := do\n  let arity := (\u2190 getConstInfo decl).type.forallArity\n  let mut keys := Array.mkEmpty (arity + 1)\n  keys := keys.push $ .const decl arity\n  for _ in [0:arity] do\n    keys := keys.push $ .star\n  return keys", "start": [90, 1], "end": [96, 14], "kind": "commanddeclaration"}, {"full_name": "isEmptyTrie", "code": "def isEmptyTrie : Trie \u03b1 s \u2192 Bool\n  | .node vs children => vs.isEmpty && children.isEmpty", "start": [98, 1], "end": [99, 56], "kind": "commanddeclaration"}, {"full_name": "filterTrieM", "code": "@[specialize]\nprivate partial def filterTrieM [Monad m] [Inhabited \u03c3] (f : \u03c3 \u2192 \u03b1 \u2192 m \u03c3)\n    (p : \u03b1 \u2192 m (ULift Bool)) (init : \u03c3) : Trie \u03b1 s \u2192 m (Trie \u03b1 s \u00d7 \u03c3)\n  | .node vs children => do\n    let (vs, acc) \u2190 vs.foldlM (init := (#[], init)) \u03bb (vs, acc) v => do\n      if (\u2190 p v).down then\n        return (vs.push v, acc)\n      else\n        return (vs, \u2190 f acc v)\n    let (children, acc) \u2190 go acc 0 children\n    let children := children.filter \u03bb (_, c) => ! isEmptyTrie c\n    return (.node vs children, acc)\n  where\n    go (acc : \u03c3) (i : Nat) (children : Array (Key s \u00d7 Trie \u03b1 s)) :\n        m (Array (Key s \u00d7 Trie \u03b1 s) \u00d7 \u03c3) := do\n      if h : i < children.size then\n        let (key, t) := children[i]'h\n        let (t, acc) \u2190 filterTrieM f p acc t\n        go acc (i + 1) (children.set \u27e8i, h\u27e9 (key, t))\n      else\n        return (children, acc)", "start": [101, 1], "end": [121, 31], "kind": "commanddeclaration"}, {"full_name": "filterDiscrTreeM", "code": "@[specialize]\ndef filterDiscrTreeM [Monad m] [Inhabited \u03c3] (p : \u03b1 \u2192 m (ULift Bool))\n    (f : \u03c3 \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3) (t : DiscrTree \u03b1 s) :\n    m (DiscrTree \u03b1 s \u00d7 \u03c3) := do\n  let (root, acc) \u2190\n    t.root.foldlM (init := (.empty, init)) \u03bb (root, acc) key t => do\n      let (t, acc) \u2190 filterTrieM f p acc t\n      let root := if isEmptyTrie t then root else root.insert key t\n      return (root, acc)\n  return (\u27e8root\u27e9, acc)", "start": [123, 1], "end": [138, 23], "kind": "commanddeclaration"}, {"full_name": "filterDiscrTree", "code": "def filterDiscrTree [Inhabited \u03c3] (p : \u03b1 \u2192 Bool) (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3) (init : \u03c3)\n    (t : DiscrTree \u03b1 s) : DiscrTree \u03b1 s \u00d7 \u03c3 := Id.run $\n  filterDiscrTreeM (\u03bb a => pure \u27e8p a\u27e9) (\u03bb s a => pure (f s a)) init t", "start": [140, 1], "end": [147, 70], "kind": "commanddeclaration"}, {"full_name": "SimpTheorems.addSimpEntry", "code": "def addSimpEntry (s : SimpTheorems) : SimpEntry \u2192 SimpTheorems\n  | SimpEntry.thm l =>\n    { addSimpTheoremEntry s l with erased := s.erased.erase l.origin }\n  | SimpEntry.toUnfold d =>\n    { s with toUnfold := s.toUnfold.insert d }\n  | SimpEntry.toUnfoldThms n thms => s.registerDeclToUnfoldThms n thms", "start": [153, 1], "end": [158, 71], "kind": "commanddeclaration"}, {"full_name": "SimpTheorems.eraseSimpEntry", "code": "def eraseSimpEntry (s : SimpTheorems) : SimpEntry \u2192 SimpTheorems\n  | SimpEntry.thm l =>\n    let o := l.origin\n    { s with erased := s.erased.insert o, lemmaNames := s.lemmaNames.erase o }\n  | SimpEntry.toUnfold d =>\n    { s with toUnfold := s.toUnfold.erase d }\n  | SimpEntry.toUnfoldThms n _ =>\n    { s with toUnfoldThms := s.toUnfoldThms.erase n }", "start": [160, 1], "end": [167, 54], "kind": "commanddeclaration"}, {"full_name": "SimpTheorems.foldSimpEntriesM", "code": "def foldSimpEntriesM [Monad m] (f : \u03c3 \u2192 SimpEntry \u2192 m \u03c3) (init : \u03c3)\n    (thms : SimpTheorems) : m \u03c3 := do\n  let s \u2190 thms.pre.foldValuesM  (init := init) processTheorem\n  let s \u2190 thms.post.foldValuesM (init := s)    processTheorem\n  let s \u2190 thms.toUnfold.foldM (init := s) \u03bb s n => f s (SimpEntry.toUnfold n)\n  thms.toUnfoldThms.foldlM (init := s) \u03bb s n thms =>\n    f s (SimpEntry.toUnfoldThms n thms)\n  where\n    @[inline]\n    processTheorem (s : \u03c3) (thm : SimpTheorem) : m \u03c3 :=\n      if thms.erased.contains thm.origin then\n        return s\n      else\n        f s (SimpEntry.thm thm)", "start": [169, 1], "end": [182, 32], "kind": "commanddeclaration"}, {"full_name": "SimpTheorems.foldSimpEntries", "code": "def foldSimpEntries (f : \u03c3 \u2192 SimpEntry \u2192 \u03c3) (init : \u03c3) (thms : SimpTheorems) :\n    \u03c3 :=\n  Id.run $ foldSimpEntriesM f init thms", "start": [184, 1], "end": [186, 40], "kind": "commanddeclaration"}, {"full_name": "SimpTheorems.simpEntries", "code": "def simpEntries (thms : SimpTheorems) : Array SimpEntry :=\n  foldSimpEntries (thms := thms) (init := #[]) \u03bb s thm => s.push thm", "start": [188, 1], "end": [189, 69], "kind": "commanddeclaration"}, {"full_name": "SimpTheorems.merge", "code": "def merge (s t : SimpTheorems) : SimpTheorems := {\n    pre := s.pre.mergePreservingDuplicates t.pre\n    post := s.post.mergePreservingDuplicates t.post\n    lemmaNames := s.lemmaNames.merge t.lemmaNames\n    toUnfold := s.toUnfold.merge t.toUnfold\n    toUnfoldThms := s.toUnfoldThms.mergeWith t.toUnfoldThms\n      (\u03bb _ thms\u2081 _ => thms\u2081)\n      erased := mkErased t s $ mkErased s t {}\n  }\n  where\n    mkErased (s t : SimpTheorems) (init : PHashSet Origin) : PHashSet Origin :=\n      s.erased.fold (init := init) \u03bb x origin =>\n        if t.lemmaNames.contains origin || t.toUnfold.contains origin.key then\n          x\n        else\n          x.insert origin", "start": [191, 1], "end": [213, 26], "kind": "commanddeclaration"}, {"full_name": "setThe", "code": "@[inline]\ndef setThe (\u03c3) {m} [MonadStateOf \u03c3 m] (s : \u03c3) : m PUnit :=\n  MonadStateOf.set s", "start": [218, 1], "end": [220, 21], "kind": "commanddeclaration"}, {"full_name": "runMetaMAsCoreM", "code": "@[inline]\ndef runMetaMAsCoreM (x : MetaM \u03b1) : CoreM \u03b1 :=\n  Prod.fst <$> x.run {} {}", "start": [222, 1], "end": [224, 27], "kind": "commanddeclaration"}, {"full_name": "runTermElabMAsCoreM", "code": "@[inline]\ndef runTermElabMAsCoreM (x : Elab.TermElabM \u03b1) : CoreM \u03b1 :=\n  runMetaMAsCoreM x.run'", "start": [226, 1], "end": [228, 25], "kind": "commanddeclaration"}, {"full_name": "updateSimpEntryPriority", "code": "def updateSimpEntryPriority (priority : Nat) (e : SimpEntry) : SimpEntry :=\n  match e with\n  | .thm t => .thm { t with priority }\n  | .toUnfoldThms .. | .toUnfold .. => e", "start": [230, 1], "end": [233, 41], "kind": "commanddeclaration"}, {"full_name": "isAppOfUpToDefeq", "code": "def isAppOfUpToDefeq (f : Expr) (e : Expr) : MetaM Bool :=\n  withoutModifyingState do\n    let type \u2190 inferType f\n    let (mvars, _, _) \u2190 forallMetaTelescope type\n    let app := mkAppN f mvars\n    if \u2190 isDefEq app e then\n      return true\n    else\n      return false", "start": [235, 1], "end": [243, 19], "kind": "commanddeclaration"}, {"full_name": "partitionGoalsAndMVars", "code": "def partitionGoalsAndMVars (goals : Array MVarId) :\n    MetaM (Array (MVarId \u00d7 UnorderedArraySet MVarId) \u00d7 UnorderedArraySet MVarId) := do\n  let mut goalsAndMVars := #[]\n  let mut mvars : UnorderedArraySet MVarId := {}\n  for g in goals do\n    let gMVars \u2190 .ofHashSet <$> g.getMVarDependencies\n    mvars := mvars.merge gMVars\n    goalsAndMVars := goalsAndMVars.push (g, gMVars)\n  let goals :=\n    if mvars.isEmpty then\n      goalsAndMVars\n    else\n      goalsAndMVars.filter \u03bb (g, _) => ! mvars.contains g\n  return (goals, mvars)", "start": [245, 1], "end": [264, 24], "kind": "commanddeclaration"}, {"full_name": "withTransparencySeqSyntax", "code": "def withTransparencySeqSyntax (md : TransparencyMode)\n    (k : TSyntax ``tacticSeq) : m (TSyntax ``tacticSeq) :=\n  match md with\n  | .default => return k\n  | .all => `(tacticSeq| with_unfolding_all $k)\n  | .reducible => `(tacticSeq| with_reducible $k)\n  | .instances => `(tacticSeq| with_reducible_and_instances $k)", "start": [272, 1], "end": [278, 64], "kind": "commanddeclaration"}, {"full_name": "withAllTransparencySeqSyntax", "code": "def withAllTransparencySeqSyntax (md : TransparencyMode)\n    (k : TSyntax ``tacticSeq) : m (TSyntax ``tacticSeq) :=\n  match md with\n  | .all => `(tacticSeq| with_unfolding_all $k)\n  | _ => return k", "start": [280, 1], "end": [284, 18], "kind": "commanddeclaration"}, {"full_name": "withTransparencySyntax", "code": "def withTransparencySyntax (md : TransparencyMode) (k : TSyntax `tactic) :\n    m (TSyntax `tactic) :=\n  match md with\n  | .default   => return k\n  | .all       => `(tactic| with_unfolding_all $k:tactic)\n  | .reducible => `(tactic| with_reducible $k:tactic)\n  | .instances => `(tactic| with_reducible_and_instances $k:tactic)", "start": [286, 1], "end": [292, 68], "kind": "commanddeclaration"}, {"full_name": "withAllTransparencySyntax", "code": "def withAllTransparencySyntax (md : TransparencyMode) (k : TSyntax `tactic) :\n    m (TSyntax `tactic) :=\n  match md with\n  | .all  => `(tactic| with_unfolding_all $k:tactic)\n  | _     => return k", "start": [294, 1], "end": [298, 22], "kind": "commanddeclaration"}, {"full_name": "getAppUpToDefeq", "code": "partial def getAppUpToDefeq (e : Expr) : MetaM (Expr \u00d7 Array Expr) :=\n  go #[] e\nwhere\n  go (args : Array Expr) (e : Expr) : MetaM (Expr \u00d7 Array Expr) := do\n    match \u2190 whnf e with\n    | .app f e => go (args.push e) f\n    | _ => return (e, args.reverse)", "start": [302, 1], "end": [313, 36], "kind": "commanddeclaration"}, {"full_name": "addTryThisTacticSeqSuggestion", "code": "def addTryThisTacticSeqSuggestion (ref : Syntax)\n    (suggestion : TSyntax ``Lean.Parser.Tactic.tacticSeq)\n    (origSpan? : Option Syntax := none)\n    (extraMsg : String := \"\") : MetaM Unit := do\n  let fmt \u2190 PrettyPrinter.ppCategory ``Lean.Parser.Tactic.tacticSeq suggestion\n  let text := fmt.prettyExtra (indent := 0) (column := 0)\n  logInfoAt ref m!\"Try this:\\n  {text}\"\n  if let some range := (origSpan?.getD ref).getRange? then\n    let map \u2190 getFileMap\n    let start := findLineStart map.source range.start\n    let indent := (range.start - start).1\n    let text := fmt.prettyExtra (indent := indent - 2) (column := indent)\n    let stxRange := ref.getRange?.getD range\n    let stxRange :=\n      { start := map.lineStart (map.toPosition stxRange.start).line\n        stop := map.lineStart ((map.toPosition stxRange.stop).line + 1) }\n    let range := map.utf8RangeToLspRange range\n    let json := Json.mkObj\n      [(\"suggestion\", text), (\"range\", toJson range), (\"info\", extraMsg)]\n    Widget.saveWidgetInfo ``Std.Tactic.TryThis.tryThisWidget json\n      (.ofRange stxRange)", "start": [332, 1], "end": [352, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Meta/SavedState.lean", "imports": ["lake-packages/std/Std/Lean/MonadBacktrack.lean", "lake-packages/std/Std/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.SavedState.runMetaM", "code": "def runMetaM (s : Meta.SavedState) (x : MetaM \u03b1) :\n    MetaM (\u03b1 \u00d7 Meta.SavedState) :=\n  withoutModifyingState' do restoreState s; x", "start": [12, 1], "end": [18, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SavedState.runMetaM'", "code": "def runMetaM' (s : Meta.SavedState) (x : MetaM \u03b1) : MetaM \u03b1 :=\n  withoutModifyingState do restoreState s; x", "start": [20, 1], "end": [25, 45], "kind": "commanddeclaration"}, {"full_name": "getIntroducedExprMVars", "code": "def getIntroducedExprMVars (preState postState : SavedState) :\n    MetaM (Array MVarId) := do\n  let unassignedPost \u2190 postState.runMetaM' getUnassignedExprMVars\n  preState.runMetaM' do\n    unassignedPost.filterM \u03bb mvarId => return ! (\u2190 mvarId.isDeclared)", "start": [30, 1], "end": [38, 70], "kind": "commanddeclaration"}, {"full_name": "getAssignedExprMVars", "code": "def getAssignedExprMVars (preState postState : SavedState) :\n    MetaM (Array MVarId) := do\n  let unassignedPre \u2190 preState.runMetaM' getUnassignedExprMVars\n  postState.runMetaM' do\n    unassignedPre.filterM (\u00b7.isAssignedOrDelayedAssigned)", "start": [40, 1], "end": [48, 58], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Options/Public.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/TransparencyMode.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Strategy", "code": "inductive Strategy\n  \n  | bestFirst\n  \n  | depthFirst\n  \n  | breadthFirst\n  deriving Inhabited, BEq, Repr", "start": [9, 1], "end": [29, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.Options", "code": "structure Options where\n  \n  strategy := Strategy.bestFirst\n  \n  maxRuleApplicationDepth := 30\n  \n  maxRuleApplications := 200\n  \n  maxGoals := 0\n  \n  maxNormIterations := 100\n  \n  applyHypsTransparency : TransparencyMode := .default\n  \n  assumptionTransparency : TransparencyMode := .default\n  \n  destructProductsTransparency : TransparencyMode := .reducible\n  \n  introsTransparency? : Option TransparencyMode := none\n  \n  terminal := false\n  \n  warnOnNonterminal := true\n  \n  traceScript := false\n  \n  enableUnfold := true\n  deriving Inhabited, BEq, Repr", "start": [31, 1], "end": [113, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.SimpConfig", "code": "structure SimpConfig extends Lean.Meta.Simp.ConfigCtx where\n   maxDischargeDepth := 1\n  \n  enabled := true\n  \n  useHyps := true", "start": [115, 1], "end": [136, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Check.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.registerCheckOption", "code": "def registerCheckOption (checkName : Name) (defValue : Bool)\n    (descr : String) : IO (Lean.Option Bool) :=\n  Option.register (`aesop.check ++ checkName)\n    { defValue := defValue, group := \"aesop\", descr := descr }", "start": [16, 1], "end": [19, 63], "kind": "commanddeclaration"}, {"full_name": "Aesop.Check", "code": "inductive Check\n  | all\n  | tree\n  | proofReconstruction\n  | unificationGoalAssignments\n  | rules\n  | script\n  | scriptSteps", "start": [49, 1], "end": [56, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.Check.toOption", "code": "@[inline_if_reduce]\ndef toOption : Check \u2192 Lean.Option Bool\n  | all => checkAllOption\n  | tree => checkTreeOption\n  | proofReconstruction => checkProofReconstructionOption\n  | unificationGoalAssignments => checkUnificationGoalAssignmentsOption\n  | rules => checkRulesOption\n  | script => checkScriptOption\n  | scriptSteps => checkScriptStepsOption", "start": [60, 1], "end": [68, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.Check.isEnabled", "code": "def isEnabled [Monad m] [MonadOptions m] : Check \u2192 m Bool\n  | all => return all.toOption.get (\u2190 getOptions)\n  | c => do\n    let opts \u2190 getOptions\n    match c.toOption.get? opts with\n    | none => return all.toOption.get opts\n    | some v => return v", "start": [70, 1], "end": [76, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.Check.name", "code": "def name (c : Check) : Name := c.toOption.name", "start": [78, 1], "end": [78, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/BuiltinTerm.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Eval.lean", "lake-packages/lean4/src/lean/Lean/Elab/Open.lean", "lake-packages/lean4/src/lean/Lean/Elab/SetOption.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.elabProp", "code": "@[builtin_term_elab \u00abprop\u00bb] def elabProp : TermElab := fun _ _ =>\n  return mkSort levelZero", "start": [13, 1], "end": [14, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabOptLevel", "code": "private def elabOptLevel (stx : Syntax) : TermElabM Level :=\n  if stx.isNone then\n    pure levelZero\n  else\n    elabLevel stx[0]", "start": [16, 1], "end": [20, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabSort", "code": "@[builtin_term_elab \u00absort\u00bb] def elabSort : TermElab := fun stx _ =>\n  return mkSort (\u2190 elabOptLevel stx[1])", "start": [22, 1], "end": [23, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabTypeStx", "code": "@[builtin_term_elab \u00abtype\u00bb] def elabTypeStx : TermElab := fun stx _ =>\n  return mkSort (mkLevelSucc (\u2190 elabOptLevel stx[1]))", "start": [25, 1], "end": [26, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabPipeCompletion", "code": "@[builtin_term_elab \u00abpipeCompletion\u00bb] def elabPipeCompletion : TermElab := fun stx expectedType? => do\n  let e \u2190 elabTerm stx[0] none\n  unless e.isSorry do\n    addDotCompletionInfo stx e expectedType?\n  throwErrorAt stx[1] \"invalid field notation, identifier or numeral expected\"", "start": [34, 1], "end": [38, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabCompletion", "code": "@[builtin_term_elab \u00abcompletion\u00bb] def elabCompletion : TermElab := fun stx expectedType? => do\n  \n  if stx[0].isIdent then\n    \n    let s \u2190 saveState\n    try\n      let e \u2190 elabTerm stx[0] none\n      addDotCompletionInfo stx e expectedType?\n    catch _ =>\n      s.restore\n      addCompletionInfo <| CompletionInfo.id stx stx[0].getId (danglingDot := true) (\u2190 getLCtx) expectedType?\n    throwErrorAt stx[1] \"invalid field notation, identifier or numeral expected\"\n  else\n    elabPipeCompletion stx expectedType?", "start": [40, 1], "end": [55, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabHole", "code": "@[builtin_term_elab \u00abhole\u00bb] def elabHole : TermElab := fun stx expectedType? => do\n  let kind := if (\u2190 read).inPattern || !(\u2190 read).holesAsSyntheticOpaque then MetavarKind.natural else MetavarKind.syntheticOpaque\n  let mvar \u2190 mkFreshExprMVar expectedType? kind\n  registerMVarErrorHoleInfo mvar.mvarId! stx\n  pure mvar", "start": [57, 1], "end": [61, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabSyntheticHole", "code": "@[builtin_term_elab \u00absyntheticHole\u00bb] def elabSyntheticHole : TermElab := fun stx expectedType? => do\n  let arg  := stx[1]\n  let userName := if arg.isIdent then arg.getId else Name.anonymous\n  let mkNewHole : Unit \u2192 TermElabM Expr := fun _ => do\n    let kind := if (\u2190 read).inPattern then MetavarKind.natural else MetavarKind.syntheticOpaque\n    let mvar \u2190 mkFreshExprMVar expectedType? kind userName\n    registerMVarErrorHoleInfo mvar.mvarId! stx\n    return mvar\n  if userName.isAnonymous || (\u2190 read).inPattern then\n    mkNewHole ()\n  else\n    match (\u2190 getMCtx).findUserName? userName with\n    | none => mkNewHole ()\n    | some mvarId =>\n      let mvar := mkMVar mvarId\n      let mvarDecl \u2190 getMVarDecl mvarId\n      let lctx \u2190 getLCtx\n      if mvarDecl.lctx.isSubPrefixOf lctx then\n        return mvar\n      else match (\u2190 getExprMVarAssignment? mvarId) with\n      | some val =>\n        let val \u2190 instantiateMVars val\n        if (\u2190 MetavarContext.isWellFormed lctx val) then\n          return val\n        else\n          withLCtx mvarDecl.lctx mvarDecl.localInstances do\n            throwError \"synthetic hole has already been defined and assigned to value incompatible with the current context{indentExpr val}\"\n      | none =>\n        if (\u2190 mvarId.isDelayedAssigned) then\n          throwError \"synthetic hole has already beend defined and delayed assigned with an incompatible local context\"\n        else if lctx.isSubPrefixOf mvarDecl.lctx then\n          let mvarNew \u2190 mkNewHole ()\n          mvarId.assign mvarNew\n          return mvarNew\n        else\n          throwError \"synthetic hole has already been defined with an incompatible local context\"", "start": [63, 1], "end": [99, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLetMVar", "code": "@[builtin_term_elab \u00abletMVar\u00bb] def elabLetMVar : TermElab := fun stx expectedType? => do\n  match stx with\n  | `(let_mvar% ? $n := $e; $b) =>\n     match (\u2190 getMCtx).findUserName? n.getId with\n     | some _ => throwError \"invalid 'let_mvar%', metavariable '?{n.getId}' has already been used\"\n     | none =>\n       let e \u2190 elabTerm e none\n       let mvar \u2190 mkFreshExprMVar (\u2190 inferType e) MetavarKind.syntheticOpaque n.getId\n       mvar.mvarId!.assign e\n       return mkSaveInfoAnnotation (\u2190 elabTerm b expectedType?)\n  | _ => throwUnsupportedSyntax", "start": [101, 1], "end": [112, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getMVarFromUserName", "code": "private def getMVarFromUserName (ident : Syntax) : MetaM Expr := do\n  match (\u2190 getMCtx).findUserName? ident.getId with\n  | none => throwError \"unknown metavariable '?{ident.getId}'\"\n  | some mvarId => instantiateMVars (mkMVar mvarId)", "start": [114, 1], "end": [117, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabWaitIfTypeMVar", "code": "@[builtin_term_elab \u00abwaitIfTypeMVar\u00bb] def elabWaitIfTypeMVar : TermElab := fun stx expectedType? => do\n  match stx with\n  | `(wait_if_type_mvar% ? $n; $b) =>\n    tryPostponeIfMVar (\u2190 inferType (\u2190 getMVarFromUserName n))\n    elabTerm b expectedType?\n  | _ => throwUnsupportedSyntax", "start": [120, 1], "end": [125, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabWaitIfTypeContainsMVar", "code": "@[builtin_term_elab \u00abwaitIfTypeContainsMVar\u00bb] def elabWaitIfTypeContainsMVar : TermElab := fun stx expectedType? => do\n  match stx with\n  | `(wait_if_type_contains_mvar% ? $n; $b) =>\n    if (\u2190 instantiateMVars (\u2190 inferType (\u2190 getMVarFromUserName n))).hasExprMVar then\n      tryPostpone\n    elabTerm b expectedType?\n  | _ => throwUnsupportedSyntax", "start": [127, 1], "end": [133, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabWaitIfContainsMVar", "code": "@[builtin_term_elab \u00abwaitIfContainsMVar\u00bb] def elabWaitIfContainsMVar : TermElab := fun stx expectedType? => do\n  match stx with\n  | `(wait_if_contains_mvar% ? $n; $b) =>\n    if (\u2190 getMVarFromUserName n).hasExprMVar then\n      tryPostpone\n    elabTerm b expectedType?\n  | _ => throwUnsupportedSyntax", "start": [135, 1], "end": [141, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkTacticMVar", "code": "private def mkTacticMVar (type : Expr) (tacticCode : Syntax) : TermElabM Expr := do\n  let mvar \u2190 mkFreshExprMVar type MetavarKind.syntheticOpaque\n  let mvarId := mvar.mvarId!\n  let ref \u2190 getRef\n  registerSyntheticMVar ref mvarId <| SyntheticMVarKind.tactic tacticCode (\u2190 saveContext)\n  return mvar", "start": [143, 1], "end": [148, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabByTactic", "code": "@[builtin_term_elab byTactic] def elabByTactic : TermElab := fun stx expectedType? => do\n  match expectedType? with\n  | some expectedType => mkTacticMVar expectedType stx\n  | none =>\n    tryPostpone\n    throwError (\"invalid 'by' tactic, expected type has not been provided\")", "start": [150, 1], "end": [155, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabNoImplicitLambda", "code": "@[builtin_term_elab noImplicitLambda] def elabNoImplicitLambda : TermElab := fun stx expectedType? =>\n  elabTerm stx[1] (mkNoImplicitLambdaAnnotation <$> expectedType?)", "start": [157, 1], "end": [158, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabBadCDot", "code": "@[builtin_term_elab Lean.Parser.Term.cdot] def elabBadCDot : TermElab := fun _ _ =>\n  throwError \"invalid occurrence of `\u00b7` notation, it must be surrounded by parentheses (e.g. `(\u00b7 + 1)`)\"", "start": [160, 1], "end": [161, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabStrLit", "code": "@[builtin_term_elab str] def elabStrLit : TermElab := fun stx _ => do\n  match stx.isStrLit? with\n  | some val => pure $ mkStrLit val\n  | none     => throwIllFormedSyntax", "start": [163, 1], "end": [166, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkFreshTypeMVarFor", "code": "private def mkFreshTypeMVarFor (expectedType? : Option Expr) : TermElabM Expr := do\n  let typeMVar \u2190 mkFreshTypeMVar MetavarKind.synthetic\n  match expectedType? with\n  | some expectedType => discard <| isDefEq expectedType typeMVar\n  | _                 => pure ()\n  return typeMVar", "start": [168, 1], "end": [173, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabNumLit", "code": "@[builtin_term_elab num] def elabNumLit : TermElab := fun stx expectedType? => do\n  let val \u2190 match stx.isNatLit? with\n    | some val => pure val\n    | none     => throwIllFormedSyntax\n  let typeMVar \u2190 mkFreshTypeMVarFor expectedType?\n  let u \u2190 getDecLevel typeMVar\n  let mvar \u2190 mkInstMVar (mkApp2 (Lean.mkConst ``OfNat [u]) typeMVar (mkRawNatLit val))\n  let r := mkApp3 (Lean.mkConst ``OfNat.ofNat [u]) typeMVar (mkRawNatLit val) mvar\n  registerMVarErrorImplicitArgInfo mvar.mvarId! stx r\n  return r", "start": [175, 1], "end": [184, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabRawNatLit", "code": "@[builtin_term_elab rawNatLit] def elabRawNatLit : TermElab :=  fun stx _ => do\n  match stx[1].isNatLit? with\n  | some val => return mkRawNatLit val\n  | none     => throwIllFormedSyntax", "start": [186, 1], "end": [189, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabScientificLit", "code": "@[builtin_term_elab scientific]\ndef elabScientificLit : TermElab := fun stx expectedType? => do\n  match stx.isScientificLit? with\n  | none        => throwIllFormedSyntax\n  | some (m, sign, e) =>\n    let typeMVar \u2190 mkFreshTypeMVarFor expectedType?\n    let u \u2190 getDecLevel typeMVar\n    let mvar \u2190 mkInstMVar (mkApp (Lean.mkConst ``OfScientific [u]) typeMVar)\n    let r := mkApp5 (Lean.mkConst ``OfScientific.ofScientific [u]) typeMVar mvar (mkRawNatLit m) (toExpr sign) (mkRawNatLit e)\n    registerMVarErrorImplicitArgInfo mvar.mvarId! stx r\n    return r", "start": [191, 1], "end": [201, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabCharLit", "code": "@[builtin_term_elab char] def elabCharLit : TermElab := fun stx _ => do\n  match stx.isCharLit? with\n  | some val => return mkApp (Lean.mkConst ``Char.ofNat) (mkRawNatLit val.toNat)\n  | none     => throwIllFormedSyntax", "start": [203, 1], "end": [206, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabQuotedName", "code": "@[builtin_term_elab quotedName] def elabQuotedName : TermElab := fun stx _ =>\n  match stx[0].isNameLit? with\n  | some val => pure $ toExpr val\n  | none     => throwIllFormedSyntax", "start": [208, 1], "end": [211, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabDoubleQuotedName", "code": "@[builtin_term_elab doubleQuotedName] def elabDoubleQuotedName : TermElab := fun stx _ =>\n  return toExpr (\u2190 resolveGlobalConstNoOverloadWithInfo stx[2])", "start": [213, 1], "end": [214, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabDeclName", "code": "@[builtin_term_elab declName] def elabDeclName : TermElab := adaptExpander fun _ => do\n  let some declName \u2190 getDeclName?\n    | throwError \"invalid `decl_name%` macro, the declaration name is not available\"\n  return (quote declName : Term)", "start": [216, 1], "end": [219, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabWithDeclName", "code": "@[builtin_term_elab Parser.Term.withDeclName] def elabWithDeclName : TermElab := fun stx expectedType? => do\n  let id := stx[2].getId\n  let id := if stx[1].isNone then id else (\u2190 getCurrNamespace) ++ id\n  let e := stx[3]\n  withMacroExpansion stx e <| withDeclName id <| elabTerm e expectedType?", "start": [221, 1], "end": [225, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabTypeOf", "code": "@[builtin_term_elab typeOf] def elabTypeOf : TermElab := fun stx _ => do\n  inferType (\u2190 elabTerm stx[1] none)", "start": [227, 1], "end": [228, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkSilentAnnotationIfHole", "code": "private def mkSilentAnnotationIfHole (e : Expr) : TermElabM Expr := do\n  if (\u2190 isTacticOrPostponedHole? e).isSome then\n    return mkAnnotation `_silent e\n  else\n    return e", "start": [230, 1], "end": [256, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabEnsureTypeOf", "code": "@[builtin_term_elab ensureTypeOf] def elabEnsureTypeOf : TermElab := fun stx _ =>\n  match stx[2].isStrLit? with\n  | none     => throwIllFormedSyntax\n  | some msg => do\n    let refTerm \u2190 elabTerm stx[1] none\n    let refTermType \u2190 inferType refTerm\n    mkSilentAnnotationIfHole (\u2190 elabTermEnsuringType stx[3] refTermType (errorMsgHeader? := msg))", "start": [258, 1], "end": [265, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabEnsureExpectedType", "code": "@[builtin_term_elab ensureExpectedType] def elabEnsureExpectedType : TermElab := fun stx expectedType? =>\n  match stx[1].isStrLit? with\n  | none     => throwIllFormedSyntax\n  | some msg => elabTermEnsuringType stx[2] expectedType? (errorMsgHeader? := msg)", "start": [267, 1], "end": [270, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabClear", "code": "@[builtin_term_elab clear] def elabClear : TermElab := fun stx expectedType? => do\n  let some (.fvar fvarId) \u2190 isLocalIdent? stx[1]\n    | throwErrorAt stx[1] \"not in scope\"\n  let body := stx[3]\n  let canClear \u2190 id do\n    if let some expectedType := expectedType? then\n      if \u2190 dependsOn expectedType fvarId then\n        return false\n    for ldecl in \u2190 getLCtx do\n      if ldecl.fvarId != fvarId then\n        if \u2190 localDeclDependsOn ldecl fvarId then\n          return false\n    return true\n  if canClear then\n    let lctx := (\u2190 getLCtx).erase fvarId\n    let localInsts := (\u2190 getLocalInstances).filter (\u00b7.fvar.fvarId! != fvarId)\n    withLCtx lctx localInsts do elabTerm body expectedType?\n  else\n    elabTerm body expectedType?", "start": [272, 1], "end": [290, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabOpen", "code": "@[builtin_term_elab \u00abopen\u00bb] def elabOpen : TermElab := fun stx expectedType? => do\n  let `(open $decl in $e) := stx | throwUnsupportedSyntax\n  try\n    pushScope\n    let openDecls \u2190 elabOpenDecl decl\n    withTheReader Core.Context (fun ctx => { ctx with openDecls := openDecls }) do\n      elabTerm e expectedType?\n  finally\n    popScope", "start": [292, 1], "end": [300, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabSetOption", "code": "@[builtin_term_elab \u00abset_option\u00bb] def elabSetOption : TermElab := fun stx expectedType? => do\n  let options \u2190 Elab.elabSetOption stx[1] stx[2]\n  withTheReader Core.Context (fun ctx => { ctx with maxRecDepth := maxRecDepth.get options, options := options }) do\n    elabTerm stx[4] expectedType?", "start": [302, 1], "end": [305, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabWithAnnotateTerm", "code": "@[builtin_term_elab withAnnotateTerm] def elabWithAnnotateTerm : TermElab := fun stx expectedType? => do\n  match stx with\n  | `(with_annotate_term $stx $e) =>\n    withInfoContext' stx (elabTerm e expectedType?) (mkTermInfo .anonymous (expectedType? := expectedType?) stx)\n  | _ => throwUnsupportedSyntax", "start": [307, 1], "end": [311, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.evalFilePathUnsafe", "code": "private unsafe def evalFilePathUnsafe (stx : Syntax) : TermElabM System.FilePath :=\n  evalTerm System.FilePath (Lean.mkConst ``System.FilePath) stx", "start": [313, 1], "end": [314, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.evalFilePath", "code": "@[implemented_by evalFilePathUnsafe]\nprivate opaque evalFilePath (stx : Syntax) : TermElabM System.FilePath", "start": [316, 1], "end": [317, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabIncludeStr", "code": "@[builtin_term_elab includeStr] def elabIncludeStr : TermElab\n  | `(include_str $path:term), _ => do\n    let path \u2190 evalFilePath path\n    let ctx \u2190 readThe Lean.Core.Context\n    let srcPath := System.FilePath.mk ctx.fileName\n    let some srcDir := srcPath.parent\n      | throwError \"cannot compute parent directory of '{srcPath}'\"\n    let path := srcDir / path\n    mkStrLit <$> IO.FS.readFile path\n  | _, _ => throwUnsupportedSyntax", "start": [319, 1], "end": [328, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/CodeAction/Attr.lean", "imports": ["lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/lean4/src/lean/Lean/Server/CodeActions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.CodeAction.HoleCodeAction", "code": "abbrev HoleCodeAction :=\n  CodeActionParams \u2192 Snapshot \u2192\n  (ctx : ContextInfo) \u2192 (hole : TermInfo) \u2192 RequestM (Array LazyCodeAction)", "start": [25, 1], "end": [28, 76], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.mkHoleCodeAction", "code": "def mkHoleCodeAction (n : Name) : ImportM HoleCodeAction := do\n  let { env, opts, .. } \u2190 read\n  IO.ofExcept <| unsafe env.evalConstCheck HoleCodeAction opts ``HoleCodeAction n", "start": [30, 1], "end": [33, 82], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.TacticCodeAction", "code": "abbrev TacticCodeAction :=\n  CodeActionParams \u2192 Snapshot \u2192\n  (ctx : ContextInfo) \u2192 (stack : Syntax.Stack) \u2192 (node : InfoTree) \u2192\n  RequestM (Array LazyCodeAction)", "start": [59, 1], "end": [63, 34], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.TacticSeqCodeAction", "code": "abbrev TacticSeqCodeAction :=\n  CodeActionParams \u2192 Snapshot \u2192\n  (ctx : ContextInfo) \u2192 (i : Nat) \u2192 (stack : Syntax.Stack) \u2192 (goals : List MVarId) \u2192\n  RequestM (Array LazyCodeAction)", "start": [65, 1], "end": [69, 34], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.mkTacticCodeAction", "code": "def mkTacticCodeAction (n : Name) : ImportM TacticCodeAction := do\n  let { env, opts, .. } \u2190 read\n  IO.ofExcept <| unsafe env.evalConstCheck TacticCodeAction opts ``TacticCodeAction n", "start": [71, 1], "end": [74, 86], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.mkTacticSeqCodeAction", "code": "def mkTacticSeqCodeAction (n : Name) : ImportM TacticSeqCodeAction := do\n  let { env, opts, .. } \u2190 read\n  IO.ofExcept <| unsafe env.evalConstCheck TacticSeqCodeAction opts ``TacticSeqCodeAction n", "start": [76, 1], "end": [79, 92], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.TacticCodeActionEntry", "code": "structure TacticCodeActionEntry where\n  \n  declName : Name\n  \n  tacticKinds : Array Name\n  deriving Inhabited", "start": [81, 1], "end": [87, 21], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.TacticCodeActions", "code": "structure TacticCodeActions where\n  \n  onAnyTactic : Array TacticCodeAction := {}\n  \n  onTactic : NameMap (Array TacticCodeAction) := {}\n  deriving Inhabited", "start": [89, 1], "end": [95, 21], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.TacticCodeActions.insert", "code": "def TacticCodeActions.insert (self : TacticCodeActions)\n    (tacticKinds : Array Name) (action : TacticCodeAction) : TacticCodeActions :=\n  if tacticKinds.isEmpty then\n    { self with onAnyTactic := self.onAnyTactic.push action }\n  else\n    { self with onTactic := tacticKinds.foldl (init := self.onTactic) fun m a =>\n        m.insert a ((m.findD a #[]).push action) }", "start": [97, 1], "end": [104, 51], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.CommandCodeAction", "code": "abbrev CommandCodeAction :=\n  CodeActionParams \u2192 Snapshot \u2192 (ctx : ContextInfo) \u2192 (node : InfoTree) \u2192\n  RequestM (Array LazyCodeAction)", "start": [171, 1], "end": [174, 34], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.mkCommandCodeAction", "code": "def mkCommandCodeAction (n : Name) : ImportM CommandCodeAction := do\n  let { env, opts, .. } \u2190 read\n  IO.ofExcept <| unsafe env.evalConstCheck CommandCodeAction opts ``CommandCodeAction n", "start": [176, 1], "end": [179, 88], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.CommandCodeActionEntry", "code": "structure CommandCodeActionEntry where\n  \n  declName : Name\n  \n  cmdKinds : Array Name\n  deriving Inhabited", "start": [181, 1], "end": [188, 21], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.CommandCodeActions", "code": "structure CommandCodeActions where\n  \n  onAnyCmd : Array CommandCodeAction := {}\n  \n  onCmd : NameMap (Array CommandCodeAction) := {}\n  deriving Inhabited", "start": [190, 1], "end": [196, 21], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.CommandCodeActions.insert", "code": "def CommandCodeActions.insert (self : CommandCodeActions)\n    (tacticKinds : Array Name) (action : CommandCodeAction) : CommandCodeActions :=\n  if tacticKinds.isEmpty then\n    { self with onAnyCmd := self.onAnyCmd.push action }\n  else\n    { self with onCmd := tacticKinds.foldl (init := self.onCmd) fun m a =>\n        m.insert a ((m.findD a #[]).push action) }", "start": [198, 1], "end": [205, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/InfoTree.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.InfoTree.foldInfo'", "code": "partial def InfoTree.foldInfo' (init : \u03b1) (f : ContextInfo \u2192 InfoTree \u2192 \u03b1 \u2192 \u03b1) : InfoTree \u2192 \u03b1 :=\n  go none init\nwhere\n  \n  go ctx? a\n  | context ctx t => go ctx a t\n  | t@(node i ts) =>\n    let a := match ctx? with\n      | none => a\n      | some ctx => f ctx t a\n    ts.foldl (init := a) (go <| i.updateContext? ctx?)\n  | _ => a", "start": [11, 1], "end": [23, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/NormCast/Lemmas.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/std/Std/Tactic/NormCast/Ext.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Classes/Cast.lean", "imports": ["lake-packages/std/Std/Tactic/CoeExt.lean", "lake-packages/std/Std/Util/LibraryNote.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NatCast", "code": "class NatCast (R : Type u) where\n  \n  protected natCast : Nat \u2192 R", "start": [9, 1], "end": [12, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.cast", "code": "@[coe, reducible, match_pattern] protected def Nat.cast {R : Type u} [NatCast R] : Nat \u2192 R :=\n  NatCast.natCast", "start": [17, 1], "end": [20, 18], "kind": "commanddeclaration"}, {"full_name": "IntCast", "code": "class IntCast (R : Type u) where\n  \n  protected intCast : Int \u2192 R", "start": [31, 1], "end": [34, 30], "kind": "commanddeclaration"}, {"full_name": "Int.cast", "code": "@[coe, reducible, match_pattern] protected def Int.cast {R : Type u} [IntCast R] : Int \u2192 R :=\n  IntCast.intCast", "start": [38, 1], "end": [41, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Int/Basic.lean", "imports": ["lake-packages/std/Std/Classes/Dvd.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.sign", "code": "def sign : Int \u2192 Int\n  | succ _ => 1\n  | 0      => 0\n  | -[_+1] => -1", "start": [20, 1], "end": [27, 17], "kind": "commanddeclaration"}, {"full_name": "Int.toNat'", "code": "def toNat' : Int \u2192 Option Nat\n  | (n : Nat) => some n\n  | -[_+1] => none", "start": [31, 1], "end": [37, 19], "kind": "commanddeclaration"}, {"full_name": "Int.ediv", "code": "def ediv : Int \u2192 Int \u2192 Int\n  | ofNat m, ofNat n => ofNat (m / n)\n  | ofNat m, -[n+1]  => -ofNat (m / succ n)\n  | -[_+1],  0       => 0\n  | -[m+1],  succ n  => -[m / succ n +1]\n  | -[m+1],  -[n+1]  => ofNat (succ (m / succ n))", "start": [52, 1], "end": [62, 50], "kind": "commanddeclaration"}, {"full_name": "Int.emod", "code": "def emod : Int \u2192 Int \u2192 Int\n  | ofNat m, n => ofNat (m % natAbs n)\n  | -[m+1],  n => subNatNat (natAbs n) (succ (m % natAbs n))", "start": [64, 1], "end": [71, 61], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv", "code": "def fdiv : Int \u2192 Int \u2192 Int\n  | 0,       _       => 0\n  | ofNat m, ofNat n => ofNat (m / n)\n  | succ m,  -[n+1]  => -[m / succ n +1]\n  | -[_+1],  0       => 0\n  | -[m+1],  succ n  => -[m / succ n +1]\n  | -[m+1],  -[n+1]  => ofNat (succ m / succ n)", "start": [79, 1], "end": [90, 48], "kind": "commanddeclaration"}, {"full_name": "Int.fmod", "code": "def fmod : Int \u2192 Int \u2192 Int\n  | 0,       _       => 0\n  | ofNat m, ofNat n => ofNat (m % n)\n  | succ m,  -[n+1]  => subNatNat (m % succ n) n\n  | -[m+1],  ofNat n => subNatNat n (succ (m % n))\n  | -[m+1],  -[n+1]  => -ofNat (succ m % succ n)", "start": [92, 1], "end": [102, 49], "kind": "commanddeclaration"}, {"full_name": "Int.gcd", "code": "def gcd (m n : Int) : Nat := m.natAbs.gcd n.natAbs", "start": [119, 1], "end": [120, 51], "kind": "commanddeclaration"}, {"full_name": "Int.not", "code": "protected def not : Int -> Int\n  | Int.ofNat n => Int.negSucc n\n  | Int.negSucc n => Int.ofNat n", "start": [132, 1], "end": [145, 33], "kind": "commanddeclaration"}, {"full_name": "Int.shiftRight", "code": "protected def shiftRight : Int \u2192 Nat \u2192 Int\n  | Int.ofNat n, s => Int.ofNat (n >>> s)\n  | Int.negSucc n, s => Int.negSucc (n >>> s)", "start": [149, 1], "end": [164, 46], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/CSimpAttr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean", "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean", "lake-packages/lean4/src/lean/Lean/Util/Recognizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.CSimp.Entry", "code": "structure Entry where\n  fromDeclName : Name\n  toDeclName   : Name\n  thmName      : Name\n  deriving Inhabited", "start": [13, 1], "end": [17, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.CSimp.State", "code": "structure State where\n  map : SMap Name Name := {}\n  thmNames : SSet Name := {}\n  deriving Inhabited", "start": [19, 1], "end": [22, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.CSimp.State.switch", "code": "def State.switch : State \u2192 State\n  | { map, thmNames } => { map := map.switch, thmNames := thmNames.switch }", "start": [24, 1], "end": [25, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.CSimp.isConstantReplacement?", "code": "private def isConstantReplacement? (declName : Name) : CoreM (Option Entry) := do\n  let info \u2190 getConstInfo declName\n  match info.type.eq? with\n  | some (_, Expr.const fromDeclName us .., Expr.const toDeclName vs ..) =>\n    if us == vs then\n      return some { fromDeclName, toDeclName, thmName := declName }\n    else\n      return none\n  | _ => return none", "start": [34, 1], "end": [42, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.CSimp.add", "code": "def add (declName : Name) (kind : AttributeKind) : CoreM Unit := do\n  if let some entry \u2190 isConstantReplacement? declName then\n    ext.add entry kind\n  else\n    throwError \"invalid 'csimp' theorem, only constant replacement theorems (e.g., `@f = @g`) are currently supported.\"", "start": [44, 1], "end": [48, 120], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.CSimp.replaceConstants", "code": "@[export lean_csimp_replace_constants]\ndef replaceConstants (env : Environment) (e : Expr) : Expr :=\n  let s := ext.getState env\n  e.replace fun e =>\n    if e.isConst then\n      match s.map.find? e.constName! with\n      | some declNameNew => some (mkConst declNameNew e.constLevels!)\n      | none => none\n    else\n      none", "start": [59, 1], "end": [68, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasCSimpAttribute", "code": "def hasCSimpAttribute (env : Environment) (declName : Name) : Bool :=\n  CSimp.ext.getState env |>.thmNames.contains declName", "start": [72, 1], "end": [73, 55], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/Main.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.compile", "code": "def compile (declNames : Array Name) : CoreM Unit := do profileitM Exception \"compiler new\" (\u2190 getOptions) do\n  discard <| LCNF.compile declNames", "start": [9, 1], "end": [14, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/NeverExtractAttr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.hasNeverExtractAttribute", "code": "@[export lean_has_never_extract_attribute]\npartial def hasNeverExtractAttribute (env : Environment) (n : Name) : Bool :=\n  let rec visit (n : Name) : Bool := neverExtractAttr.hasTag env n || (n.isInternal && visit n.getPrefix)\n  visit n", "start": [14, 1], "end": [17, 10], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/ConstFolding.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.mkLcProof", "code": "def mkLcProof (p : Expr) :=\n  mkApp (mkConst ``lcProof []) p", "start": [12, 1], "end": [13, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.BinFoldFn", "code": "abbrev BinFoldFn := Bool \u2192 Expr \u2192 Expr \u2192 Option Expr", "start": [15, 1], "end": [15, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.UnFoldFn", "code": "abbrev UnFoldFn  := Bool \u2192 Expr \u2192 Option Expr", "start": [16, 1], "end": [16, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.mkUIntTypeName", "code": "def mkUIntTypeName (nbytes : Nat) : Name :=\n  Name.mkSimple (\"UInt\" ++ toString nbytes)", "start": [18, 1], "end": [19, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.NumScalarTypeInfo", "code": "structure NumScalarTypeInfo where\n  nbits : Nat\n  id : Name      := mkUIntTypeName nbits\n  ofNatFn : Name := Name.mkStr id \"ofNat\"\n  toNatFn : Name := Name.mkStr id \"toNat\"\n  size : Nat     := 2^nbits", "start": [21, 1], "end": [26, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.numScalarTypes", "code": "def numScalarTypes : List NumScalarTypeInfo :=\n  [{nbits := 8}, {nbits := 16}, {nbits := 32}, {nbits := 64},\n   {id := ``USize, nbits := System.Platform.numBits}]", "start": [28, 1], "end": [30, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.isOfNat", "code": "def isOfNat (fn : Name) : Bool :=\n  numScalarTypes.any (fun info => info.ofNatFn == fn)", "start": [32, 1], "end": [33, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.isToNat", "code": "def isToNat (fn : Name) : Bool :=\n  numScalarTypes.any (fun info => info.toNatFn == fn)", "start": [35, 1], "end": [36, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.getInfoFromFn", "code": "def getInfoFromFn (fn : Name) : List NumScalarTypeInfo \u2192 Option NumScalarTypeInfo\n  | []          => none\n  | info::infos =>\n    if info.ofNatFn == fn then some info\n    else getInfoFromFn fn infos", "start": [38, 1], "end": [42, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.getInfoFromVal", "code": "def getInfoFromVal : Expr \u2192 Option NumScalarTypeInfo\n  | Expr.app (Expr.const fn _) _ => getInfoFromFn fn numScalarTypes\n  | _                            => none", "start": [44, 1], "end": [46, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.getNumLit", "code": "@[export lean_get_num_lit]\ndef getNumLit : Expr \u2192 Option Nat\n  | Expr.lit (Literal.natVal n)  => some n\n  | Expr.app (Expr.const fn _) a => if isOfNat fn then getNumLit a else none\n  | _                            => none", "start": [48, 1], "end": [52, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.mkUIntLit", "code": "def mkUIntLit (info : NumScalarTypeInfo) (n : Nat) : Expr :=\n  mkApp (mkConst info.ofNatFn) (mkRawNatLit (n%info.size))", "start": [54, 1], "end": [55, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.mkUInt32Lit", "code": "def mkUInt32Lit (n : Nat) : Expr :=\n  mkUIntLit {nbits := 32} n", "start": [57, 1], "end": [58, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldBinUInt", "code": "def foldBinUInt (fn : NumScalarTypeInfo \u2192 Bool \u2192 Nat \u2192 Nat \u2192 Nat) (beforeErasure : Bool) (a\u2081 a\u2082 : Expr) : Option Expr := do\n  let n\u2081   \u2190 getNumLit a\u2081\n  let n\u2082   \u2190 getNumLit a\u2082\n  let info \u2190 getInfoFromVal a\u2081\n  return mkUIntLit info (fn info beforeErasure n\u2081 n\u2082)", "start": [60, 1], "end": [64, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldUIntAdd", "code": "def foldUIntAdd := foldBinUInt fun _ _ => Add.add", "start": [66, 1], "end": [66, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldUIntMul", "code": "def foldUIntMul := foldBinUInt fun _ _ => Mul.mul", "start": [67, 1], "end": [67, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldUIntDiv", "code": "def foldUIntDiv := foldBinUInt fun _ _ => Div.div", "start": [68, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldUIntMod", "code": "def foldUIntMod := foldBinUInt fun _ _ => Mod.mod", "start": [69, 1], "end": [69, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldUIntSub", "code": "def foldUIntSub := foldBinUInt fun info _ a b => (a + (info.size - b))", "start": [70, 1], "end": [70, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.preUIntBinFoldFns", "code": "def preUIntBinFoldFns : List (Name \u00d7 BinFoldFn) :=\n  [(`add, foldUIntAdd), (`mul, foldUIntMul), (`div, foldUIntDiv),\n   (`mod, foldUIntMod), (`sub, foldUIntSub)]", "start": [72, 1], "end": [74, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.uintBinFoldFns", "code": "def uintBinFoldFns : List (Name \u00d7 BinFoldFn) :=\n  numScalarTypes.foldl (fun r info => r ++ (preUIntBinFoldFns.map (fun \u27e8suffix, fn\u27e9 => (info.id ++ suffix, fn)))) []", "start": [76, 1], "end": [77, 117], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatBinOp", "code": "def foldNatBinOp (fn : Nat \u2192 Nat \u2192 Nat) (a\u2081 a\u2082 : Expr) : Option Expr := do\n  let n\u2081   \u2190 getNumLit a\u2081\n  let n\u2082   \u2190 getNumLit a\u2082\n  return mkRawNatLit (fn n\u2081 n\u2082)", "start": [79, 1], "end": [82, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatAdd", "code": "def foldNatAdd (_ : Bool) := foldNatBinOp Add.add", "start": [84, 1], "end": [84, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatMul", "code": "def foldNatMul (_ : Bool) := foldNatBinOp Mul.mul", "start": [85, 1], "end": [85, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatDiv", "code": "def foldNatDiv (_ : Bool) := foldNatBinOp Div.div", "start": [86, 1], "end": [86, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatMod", "code": "def foldNatMod (_ : Bool) := foldNatBinOp Mod.mod", "start": [87, 1], "end": [87, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.natPowThreshold", "code": "def natPowThreshold := 256", "start": [90, 1], "end": [90, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatPow", "code": "def foldNatPow (_ : Bool) (a\u2081 a\u2082 : Expr) : Option Expr := do\n  let n\u2081   \u2190 getNumLit a\u2081\n  let n\u2082   \u2190 getNumLit a\u2082\n  if n\u2082 < natPowThreshold then\n    return mkRawNatLit (n\u2081 ^ n\u2082)\n  else\n    failure", "start": [92, 1], "end": [98, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.mkNatEq", "code": "def mkNatEq (a b : Expr) : Expr :=\n  mkAppN (mkConst ``Eq [levelOne]) #[(mkConst `Nat), a, b]", "start": [100, 1], "end": [101, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.mkNatLt", "code": "def mkNatLt (a b : Expr) : Expr :=\n  mkAppN (mkConst ``LT.lt [levelZero]) #[mkConst ``Nat, mkConst ``Nat.lt, a, b]", "start": [103, 1], "end": [104, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.mkNatLe", "code": "def mkNatLe (a b : Expr) : Expr :=\n  mkAppN (mkConst ``LE.le [levelZero]) #[mkConst ``Nat, mkConst ``Nat.le, a, b]", "start": [106, 1], "end": [107, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.toDecidableExpr", "code": "def toDecidableExpr (beforeErasure : Bool) (pred : Expr) (r : Bool) : Expr :=\n  match beforeErasure, r with\n  | false, true  => mkConst ``Bool.true\n  | false, false => mkConst ``Bool.false\n  | true,  true  => mkDecIsTrue pred (mkLcProof pred)\n  | true,  false => mkDecIsFalse pred (mkLcProof pred)", "start": [109, 1], "end": [114, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatBinPred", "code": "def foldNatBinPred (mkPred : Expr \u2192 Expr \u2192 Expr) (fn : Nat \u2192 Nat \u2192 Bool)\n    (beforeErasure : Bool) (a\u2081 a\u2082 : Expr) : Option Expr := do\n  let n\u2081   \u2190 getNumLit a\u2081\n  let n\u2082   \u2190 getNumLit a\u2082\n  return toDecidableExpr beforeErasure (mkPred a\u2081 a\u2082) (fn n\u2081 n\u2082)", "start": [116, 1], "end": [120, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatDecEq", "code": "def foldNatDecEq := foldNatBinPred mkNatEq (fun a b => a = b)", "start": [122, 1], "end": [122, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatDecLt", "code": "def foldNatDecLt := foldNatBinPred mkNatLt (fun a b => a < b)", "start": [123, 1], "end": [123, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatDecLe", "code": "def foldNatDecLe := foldNatBinPred mkNatLe (fun a b => a \u2264 b)", "start": [124, 1], "end": [124, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatBinBoolPred", "code": "def foldNatBinBoolPred (fn : Nat \u2192 Nat \u2192 Bool) (a\u2081 a\u2082 : Expr) : Option Expr := do\n  let n\u2081   \u2190 getNumLit a\u2081\n  let n\u2082   \u2190 getNumLit a\u2082\n  if fn n\u2081 n\u2082 then\n    return mkConst ``Bool.true\n  else\n    return mkConst ``Bool.false", "start": [126, 1], "end": [132, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatBeq", "code": "def foldNatBeq := fun _ : Bool => foldNatBinBoolPred (fun a b => a == b)", "start": [134, 1], "end": [134, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatBle", "code": "def foldNatBle := fun _ : Bool => foldNatBinBoolPred (fun a b => a < b)", "start": [135, 1], "end": [135, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatBlt", "code": "def foldNatBlt := fun _ : Bool => foldNatBinBoolPred (fun a b => a \u2264 b)", "start": [136, 1], "end": [136, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.natFoldFns", "code": "def natFoldFns : List (Name \u00d7 BinFoldFn) :=\n  [(``Nat.add, foldNatAdd),\n   (``Nat.mul, foldNatMul),\n   (``Nat.div, foldNatDiv),\n   (``Nat.mod, foldNatMod),\n   (``Nat.pow, foldNatPow),\n   (``Nat.decEq, foldNatDecEq),\n   (``Nat.decLt, foldNatDecLt),\n   (``Nat.decLe, foldNatDecLe),\n   (``Nat.beq,   foldNatBeq),\n   (``Nat.blt,   foldNatBlt),\n   (``Nat.ble,   foldNatBle)\n]", "start": [138, 1], "end": [150, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.getBoolLit", "code": "def getBoolLit : Expr \u2192 Option Bool\n  | Expr.const ``Bool.true _  => some true\n  | Expr.const ``Bool.false _ => some false\n  | _                         => none", "start": [152, 1], "end": [155, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldStrictAnd", "code": "def foldStrictAnd (_ : Bool) (a\u2081 a\u2082 : Expr) : Option Expr :=\n  let v\u2081 := getBoolLit a\u2081\n  let v\u2082 := getBoolLit a\u2082\n  match v\u2081, v\u2082 with\n  | some true,  _ => a\u2082\n  | some false, _ => a\u2081\n  | _, some true  => a\u2081\n  | _, some false => a\u2082\n  | _, _          => none", "start": [157, 1], "end": [165, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldStrictOr", "code": "def foldStrictOr (_ : Bool) (a\u2081 a\u2082 : Expr) : Option Expr :=\n  let v\u2081 := getBoolLit a\u2081\n  let v\u2082 := getBoolLit a\u2082\n  match v\u2081, v\u2082 with\n  | some true,  _ => a\u2081\n  | some false, _ => a\u2082\n  | _, some true  => a\u2082\n  | _, some false => a\u2081\n  | _, _          => none", "start": [167, 1], "end": [175, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.boolFoldFns", "code": "def boolFoldFns : List (Name \u00d7 BinFoldFn) :=\n  [(``strictOr, foldStrictOr), (``strictAnd, foldStrictAnd)]", "start": [177, 1], "end": [178, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.binFoldFns", "code": "def binFoldFns : List (Name \u00d7 BinFoldFn) :=\n  boolFoldFns ++ uintBinFoldFns ++ natFoldFns", "start": [180, 1], "end": [181, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldNatSucc", "code": "def foldNatSucc (_ : Bool) (a : Expr) : Option Expr := do\n  let n \u2190 getNumLit a\n  return mkRawNatLit (n+1)", "start": [183, 1], "end": [185, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldCharOfNat", "code": "def foldCharOfNat (beforeErasure : Bool) (a : Expr) : Option Expr := do\n  guard (!beforeErasure)\n  let n \u2190 getNumLit a\n  if isValidChar n.toUInt32 then\n    return mkUInt32Lit n\n  else\n    return mkUInt32Lit 0", "start": [187, 1], "end": [193, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldToNat", "code": "def foldToNat (_ : Bool) (a : Expr) : Option Expr := do\n  let n \u2190 getNumLit a\n  return mkRawNatLit n", "start": [195, 1], "end": [197, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.uintFoldToNatFns", "code": "def uintFoldToNatFns : List (Name \u00d7 UnFoldFn) :=\n  numScalarTypes.foldl (fun r info => (info.toNatFn, foldToNat) :: r) []", "start": [199, 1], "end": [200, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.unFoldFns", "code": "def unFoldFns : List (Name \u00d7 UnFoldFn) :=\n  [(``Nat.succ, foldNatSucc),\n   (``Char.ofNat, foldCharOfNat)]\n  ++ uintFoldToNatFns", "start": [202, 1], "end": [205, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.findBinFoldFn", "code": "def findBinFoldFn (fn : Name) : Option BinFoldFn :=\n  binFoldFns.lookup fn", "start": [207, 1], "end": [208, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.findUnFoldFn", "code": "def findUnFoldFn (fn : Name) : Option UnFoldFn :=\n  unFoldFns.lookup fn", "start": [210, 1], "end": [211, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldBinOp", "code": "@[export lean_fold_bin_op]\ndef foldBinOp (beforeErasure : Bool) (f : Expr) (a : Expr) (b : Expr) : Option Expr := do\n  match f with\n  | Expr.const fn _ =>\n     let foldFn \u2190 findBinFoldFn fn\n     foldFn beforeErasure a b\n  | _ =>\n    failure", "start": [213, 1], "end": [220, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.foldUnOp", "code": "@[export lean_fold_un_op]\ndef foldUnOp (beforeErasure : Bool) (f : Expr) (a : Expr) : Option Expr := do\n  match f with\n  | Expr.const fn _ =>\n     let foldFn \u2190 findUnFoldFn fn\n     foldFn beforeErasure a\n  | _ => failure", "start": [222, 1], "end": [228, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/AtMostOnce.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.atMostOnce.AtMostOnceData", "code": "structure AtMostOnceData where\n  found : Bool\n  result : Bool", "start": [12, 1], "end": [14, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.atMostOnce.Visitor", "code": "def Visitor := AtMostOnceData \u2192 AtMostOnceData", "start": [16, 1], "end": [16, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.atMostOnce.seq", "code": "@[inline] def seq (f g : Visitor) : Visitor := fun d =>\n  match f d with\n  | \u27e8found, false\u27e9 => \u27e8found, false\u27e9\n  | other          => g other", "start": [18, 1], "end": [21, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.atMostOnce.skip", "code": "@[inline] def skip : Visitor := id", "start": [26, 1], "end": [26, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.atMostOnce.visitFVar", "code": "@[inline] def visitFVar (x y : FVarId) : Visitor\n  | d@{result := false, ..} => d\n  | {found := false, result := true} => {found := x == y, result := true}\n  | {found := true,  result := true} => {found := true, result := x != y}", "start": [28, 1], "end": [31, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.atMostOnce.visit", "code": "def visit (x : FVarId) : Expr \u2192 Visitor\n  | Expr.fvar y          => visitFVar y x\n  | Expr.app f a         => visit x a >> visit x f\n  | Expr.lam _ d b _     => visit x d >> visit x b\n  | Expr.forallE _ d b _ => visit x d >> visit x b\n  | Expr.letE _ t v b _  => visit x t >> visit x v >> visit x b\n  | Expr.mdata _ e       => visit x e\n  | Expr.proj _ _ e      => visit x e\n  | _                    => skip", "start": [33, 1], "end": [41, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.atMostOnce", "code": "@[export lean_at_most_once]\ndef atMostOnce (e : Expr) (x : FVarId) : Bool :=\n  let {result := result, ..} := visit x e {found := false, result := true}\n  result", "start": [46, 1], "end": [50, 9], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/CtorLayout.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Format.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Checker.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Boxing.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/UnboxResult.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/NormIds.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Borrow.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/PushProj.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/RC.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/ExpandResetReuse.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/ResetReuse.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/SimpCase.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/EmitC.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Sorry.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/ElimDeadVars.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/ElimDeadBranches.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean"], "premises": [{"full_name": "Lean.IR.compileAux", "code": "private def compileAux (decls : Array Decl) : CompilerM Unit := do\n  logDecls `init decls\n  checkDecls decls\n  let mut decls \u2190 elimDeadBranches decls\n  logDecls `elim_dead_branches decls\n  decls := decls.map Decl.pushProj\n  logDecls `push_proj decls\n  if compiler.reuse.get (\u2190 read) then\n    decls := decls.map Decl.insertResetReuse\n    logDecls `reset_reuse decls\n  decls := decls.map Decl.elimDead\n  logDecls `elim_dead decls\n  decls := decls.map Decl.simpCase\n  logDecls `simp_case decls\n  decls := decls.map Decl.normalizeIds\n  decls \u2190 inferBorrow decls\n  logDecls `borrow decls\n  decls \u2190 explicitBoxing decls\n  logDecls `boxing decls\n  decls \u2190 explicitRC decls\n  logDecls `rc decls\n  if compiler.reuse.get (\u2190 read) then\n    decls := decls.map Decl.expandResetReuse\n    logDecls `expand_reset_reuse decls\n  decls := decls.map Decl.pushProj\n  logDecls `push_proj decls\n  decls \u2190 updateSorryDep decls\n  logDecls `result decls\n  checkDecls decls\n  addDecls decls", "start": [32, 1], "end": [61, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.compile", "code": "@[export lean_ir_compile]\ndef compile (env : Environment) (opts : Options) (decls : Array Decl) : Log \u00d7 (Except String Environment) :=\n  match (compileAux decls opts).run { env := env } with\n  | EStateM.Result.ok     _  s => (s.log, Except.ok s.env)\n  | EStateM.Result.error msg s => (s.log, Except.error msg)", "start": [63, 1], "end": [67, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.addBoxedVersionAux", "code": "def addBoxedVersionAux (decl : Decl) : CompilerM Unit := do\n  let env \u2190 getEnv\n  if !ExplicitBoxing.requiresBoxedVersion env decl then\n    pure ()\n  else\n    let decl := ExplicitBoxing.mkBoxedVersion decl\n    let decls : Array Decl := #[decl]\n    let decls \u2190 explicitRC decls\n    decls.forM fun decl => modifyEnv fun env => addDeclAux env decl\n    pure ()", "start": [69, 1], "end": [78, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.addBoxedVersion", "code": "@[export lean_ir_add_boxed_version]\ndef addBoxedVersion (env : Environment) (decl : Decl) : Except String Environment :=\n  match (addBoxedVersionAux decl Options.empty).run { env := env } with\n  | EStateM.Result.ok     _  s => Except.ok s.env\n  | EStateM.Result.error msg _ => Except.error msg", "start": [81, 1], "end": [85, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/FFI.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.FFI.getLeancExtraFlags", "code": "@[extern \"lean_get_leanc_extra_flags\"]\nprivate opaque getLeancExtraFlags : Unit \u2192 String", "start": [11, 1], "end": [12, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.FFI.getCFlags", "code": "def getCFlags (leanSysroot : FilePath) : Array String :=\n  #[\"-I\", (leanSysroot / \"include\").toString] ++ (getLeancExtraFlags ()).trim.splitOn", "start": [14, 1], "end": [16, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.FFI.getBuiltinLinkerFlags", "code": "@[extern \"lean_get_linker_flags\"]\nprivate opaque getBuiltinLinkerFlags (linkStatic : Bool) : String", "start": [18, 1], "end": [19, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.FFI.getLinkerFlags", "code": "def getLinkerFlags (leanSysroot : FilePath) (linkStatic := true) : Array String :=\n  #[\"-L\", (leanSysroot / \"lib\" / \"lean\").toString] ++ (getBuiltinLinkerFlags linkStatic).trim.splitOn", "start": [21, 1], "end": [23, 102], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/ShareCommon.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashSet.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/PersistentHashSet.lean", "lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "lake-packages/lean4/src/lean/Lean/Data/PersistentHashMap.lean"], "premises": [{"full_name": "Lean.ShareCommon.objectFactory", "code": "def objectFactory :=\n  StateFactory.mk {\n    Map := HashMap, mkMap := (mkHashMap \u00b7), mapFind? := (\u00b7.find?), mapInsert := (\u00b7.insert)\n    Set := HashSet, mkSet := (mkHashSet \u00b7), setFind? := (\u00b7.find?), setInsert := (\u00b7.insert)\n  }", "start": [14, 1], "end": [18, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.persistentObjectFactory", "code": "def persistentObjectFactory :=\n  StateFactory.mk {\n    Map := PersistentHashMap, mkMap := fun _ => .empty, mapFind? := (\u00b7.find?), mapInsert := (\u00b7.insert)\n    Set := PersistentHashSet, mkSet := fun _ => .empty, setFind? := (\u00b7.find?), setInsert := (\u00b7.insert)\n  }", "start": [20, 1], "end": [24, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.ShareCommonT", "code": "abbrev ShareCommonT := _root_.ShareCommonT objectFactory", "start": [26, 1], "end": [26, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.PShareCommonT", "code": "abbrev PShareCommonT := _root_.ShareCommonT persistentObjectFactory", "start": [27, 1], "end": [27, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.ShareCommonM", "code": "abbrev ShareCommonM := ShareCommonT Id", "start": [28, 1], "end": [28, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.PShareCommonM", "code": "abbrev PShareCommonM := PShareCommonT Id", "start": [29, 1], "end": [29, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.ShareCommonT.withShareCommon", "code": "@[specialize] def ShareCommonT.withShareCommon [Monad m] (a : \u03b1) : ShareCommonT m \u03b1 :=\n  modifyGet fun s => s.shareCommon a", "start": [31, 1], "end": [32, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.PShareCommonT.withShareCommon", "code": "@[specialize] def PShareCommonT.withShareCommon [Monad m] (a : \u03b1) : PShareCommonT m \u03b1 :=\n  modifyGet fun s => s.shareCommon a", "start": [34, 1], "end": [35, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.ShareCommonT.monadShareCommon", "code": "instance ShareCommonT.monadShareCommon [Monad m] : MonadShareCommon (ShareCommonT m) where\n  withShareCommon := ShareCommonT.withShareCommon", "start": [37, 1], "end": [38, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.PShareCommonT.monadShareCommon", "code": "instance PShareCommonT.monadShareCommon [Monad m] : MonadShareCommon (PShareCommonT m) where\n  withShareCommon := PShareCommonT.withShareCommon", "start": [40, 1], "end": [41, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.ShareCommonT.run", "code": "@[inline] def ShareCommonT.run [Monad m] : ShareCommonT m \u03b1 \u2192 m \u03b1 := _root_.ShareCommonT.run", "start": [43, 1], "end": [43, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.PShareCommonT.run", "code": "@[inline] def PShareCommonT.run [Monad m] : PShareCommonT m \u03b1 \u2192 m \u03b1 := _root_.ShareCommonT.run", "start": [44, 1], "end": [44, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.ShareCommonM.run", "code": "@[inline] def ShareCommonM.run : ShareCommonM \u03b1 \u2192 \u03b1 := ShareCommonT.run", "start": [45, 1], "end": [45, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.PShareCommonM.run", "code": "@[inline] def PShareCommonM.run : PShareCommonM \u03b1 \u2192 \u03b1 := PShareCommonT.run", "start": [46, 1], "end": [46, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.ShareCommon.shareCommon", "code": "def shareCommon (a : \u03b1) : \u03b1 := (withShareCommon a : ShareCommonM \u03b1).run", "start": [48, 1], "end": [48, 72], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/FileWorker.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Server/References.lean", "lake-packages/lean4/src/lean/Lean/Util/Paths.lean", "lake-packages/lean4/src/lean/Lean/Server/AsyncList.lean", "lake-packages/lean4/src/lean/Lean/Server/Utils.lean", "lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Lean/LoadDynlib.lean", "lake-packages/lean4/src/lean/Lean/Server/FileWorker/Utils.lean", "lake-packages/lean4/src/lean/Lean/Server/FileWorker/WidgetRequests.lean", "lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Lean/Server/Snapshots.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp.lean", "lake-packages/lean4/src/lean/Lean/Server/FileWorker/RequestHandling.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/FromToJson.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveDiagnostic.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean"], "premises": [{"full_name": "Lean.Server.FileWorker.WorkerContext", "code": "structure WorkerContext where\n  hIn              : FS.Stream\n  hOut             : FS.Stream\n  hLog             : FS.Stream\n  headerTask       : Task (Except Error (Snapshot \u00d7 SearchPath))\n  initParams       : InitializeParams\n  clientHasWidgets : Bool", "start": [58, 1], "end": [64, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.AsyncElabState", "code": "structure AsyncElabState where\n    snaps : Array Snapshot", "start": [69, 3], "end": [70, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.AsyncElabM", "code": "abbrev AsyncElabM := StateT AsyncElabState <| EIO ElabTaskError", "start": [72, 3], "end": [72, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.publishIleanInfo", "code": "private def publishIleanInfo (method : String) (m : DocumentMeta) (hOut : FS.Stream)\n      (snaps : Array Snapshot) : IO Unit := do\n    let trees := snaps.map fun snap => snap.infoTree\n    let references := findModuleRefs m.text trees (localVars := true)\n    let param := { version := m.version, references : LeanIleanInfoParams }\n    hOut.writeLspNotification { method, param }", "start": [75, 3], "end": [80, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.publishIleanInfoUpdate", "code": "private def publishIleanInfoUpdate : DocumentMeta \u2192 FS.Stream \u2192 Array Snapshot \u2192 IO Unit :=\n    publishIleanInfo \"$/lean/ileanInfoUpdate\"", "start": [82, 3], "end": [83, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.publishIleanInfoFinal", "code": "private def publishIleanInfoFinal : DocumentMeta \u2192 FS.Stream \u2192 Array Snapshot \u2192 IO Unit :=\n    publishIleanInfo \"$/lean/ileanInfoFinal\"", "start": [85, 3], "end": [86, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.nextCmdSnap", "code": "private def nextCmdSnap (ctx : WorkerContext) (m : DocumentMeta) (cancelTk : CancelToken)\n      : AsyncElabM (Option Snapshot) := do\n    cancelTk.check\n    let s \u2190 get\n    let .some lastSnap := s.snaps.back? | panic! \"empty snapshots\"\n    if lastSnap.isAtEnd then\n      publishDiagnostics m lastSnap.diagnostics.toArray ctx.hOut\n      publishProgressDone m ctx.hOut\n      publishIleanInfoFinal m ctx.hOut s.snaps\n      return none\n    publishProgressAtPos m lastSnap.endPos ctx.hOut\n    let snap \u2190 compileNextCmd m.mkInputContext lastSnap ctx.clientHasWidgets\n    set { s with snaps := s.snaps.push snap }\n    cancelTk.check\n    \n                publishDiagnostics m snap.diagnostics.toArray ctx.hOut\n    publishIleanInfoUpdate m ctx.hOut #[snap]\n    return some snap", "start": [88, 3], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.unfoldCmdSnaps", "code": "def unfoldCmdSnaps (m : DocumentMeta) (snaps : Array Snapshot) (cancelTk : CancelToken) (startAfterMs : UInt32)\n      : ReaderT WorkerContext IO (AsyncList ElabTaskError Snapshot) := do\n    let ctx \u2190 read\n    let some headerSnap := snaps[0]? | panic! \"empty snapshots\"\n    if headerSnap.msgLog.hasErrors then\n      publishProgressAtPos m headerSnap.beginPos ctx.hOut (kind := LeanFileProgressKind.fatalError)\n      publishIleanInfoFinal m ctx.hOut #[headerSnap]\n      return AsyncList.ofList [headerSnap]\n    else\n      publishIleanInfoUpdate m ctx.hOut snaps\n      return AsyncList.ofList snaps.toList ++ AsyncList.delayed (\u2190 EIO.asTask (\u03b5 := ElabTaskError) (prio := .dedicated) do\n        IO.sleep startAfterMs\n        AsyncList.unfoldAsync (nextCmdSnap ctx m cancelTk) { snaps })", "start": [122, 3], "end": [139, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.PendingRequestMap", "code": "abbrev PendingRequestMap := RBMap RequestID (Task (Except IO.Error Unit)) compare", "start": [143, 1], "end": [143, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.WorkerState", "code": "structure WorkerState where\n  doc             : EditableDocument\n  initHeaderStx   : Syntax\n  pendingRequests : PendingRequestMap\n  \n  rpcSessions     : RBMap UInt64 (IO.Ref RpcSession) compare", "start": [145, 1], "end": [152, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.WorkerM", "code": "abbrev WorkerM := ReaderT WorkerContext <| StateRefT WorkerState IO", "start": [154, 1], "end": [154, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.lakeSetupSearchPath", "code": "partial def lakeSetupSearchPath (lakePath : System.FilePath) (m : DocumentMeta) (imports : Array Import) (hOut : FS.Stream) : IO SearchPath := do\n    let mut args := #[\"print-paths\"] ++ imports.map (toString \u00b7.module)\n    if m.dependencyBuildMode matches .never then\n      args := args.push \"    let cmdStr := \" \".intercalate (toString lakePath :: args.toList)\n    let lakeProc \u2190 Process.spawn {\n      stdin  := Process.Stdio.null\n      stdout := Process.Stdio.piped\n      stderr := Process.Stdio.piped\n      cmd    := lakePath.toString\n      args\n    }\n    let rec processStderr (acc : String) : IO String := do\n      let line \u2190 lakeProc.stderr.getLine\n      if line == \"\" then\n        return acc\n      else\n        publishDiagnostics m #[{ range := \u27e8\u27e80, 0\u27e9, \u27e80, 0\u27e9\u27e9, severity? := DiagnosticSeverity.information, message := line }] hOut\n        processStderr (acc ++ line)\n    let stderr \u2190 IO.asTask (processStderr \"\") Task.Priority.dedicated\n    let stdout := String.trim (\u2190 lakeProc.stdout.readToEnd)\n    let stderr \u2190 IO.ofExcept stderr.get\n    match (\u2190 lakeProc.wait) with\n    | 0 =>\n      let Except.ok (paths : LeanPaths) \u2190 pure (Json.parse stdout >>= fromJson?)\n        | throwServerError s!\"invalid output from `{cmdStr}`:\\n{stdout}\\nstderr:\\n{stderr}\"\n      initSearchPath (\u2190 getBuildDir) paths.oleanPath\n      paths.loadDynlibPaths.forM loadDynlib\n      paths.srcPath.mapM realPathNormalized\n    | 2 => pure []  | 3 => throwServerError s!\"Imports are out of date and must be rebuilt; use the \\\"Restart File\\\" command in your editor.\\n\\n{stdout}\"\n    | _ => throwServerError s!\"`{cmdStr}` failed:\\n{stdout}\\nstderr:\\n{stderr}\"", "start": [158, 3], "end": [194, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.compileHeader", "code": "def compileHeader (m : DocumentMeta) (hOut : FS.Stream) (opts : Options) (hasWidgets : Bool)\n      : IO (Syntax \u00d7 Task (Except Error (Snapshot \u00d7 SearchPath))) := do\n    let (headerStx, headerParserState, msgLog) \u2190 Parser.parseHeader m.mkInputContext\n    (headerStx, \u00b7) <$> EIO.asTask do\n      let mut srcSearchPath \u2190 initSrcSearchPath (\u2190 getBuildDir)\n      let lakePath \u2190 match (\u2190 IO.getEnv \"LAKE\") with\n        | some path => pure <| System.FilePath.mk path\n        | none =>\n          let lakePath \u2190 match (\u2190 IO.getEnv \"LEAN_SYSROOT\") with\n            | some path => pure <| System.FilePath.mk path / \"bin\" / \"lake\"\n            | _         => pure <| (\u2190 appDir) / \"lake\"\n          pure <| lakePath.withExtension System.FilePath.exeExtension\n      let (headerEnv, msgLog) \u2190 try\n        if let some path := System.Uri.fileUriToPath? m.uri then\n          if path.fileName != \"lakefile.lean\" && (\u2190 System.FilePath.pathExists lakePath) then\n            let pkgSearchPath \u2190 lakeSetupSearchPath lakePath m (Lean.Elab.headerToImports headerStx) hOut\n            srcSearchPath \u2190 initSrcSearchPath (\u2190 getBuildDir) pkgSearchPath\n        Elab.processHeader headerStx opts msgLog m.mkInputContext\n      catch e =>  let msgs := MessageLog.empty.add { fileName := \"<ignored>\", pos := \u27e80, 0\u27e9, data := e.toString }\n        pure (\u2190 mkEmptyEnvironment, msgs)\n      let mut headerEnv := headerEnv\n      try\n        if let some path := System.Uri.fileUriToPath? m.uri then\n          headerEnv := headerEnv.setMainModule (\u2190 moduleNameOfFileName path none)\n      catch _ => pure ()\n      let cmdState := Elab.Command.mkState headerEnv msgLog opts\n      let cmdState := { cmdState with infoState := {\n        enabled := true\n        trees := #[Elab.InfoTree.context ({\n          env     := headerEnv\n          fileMap := m.text\n          ngen    := { namePrefix := `_worker }\n        }) (Elab.InfoTree.node\n            (Elab.Info.ofCommandInfo { elaborator := `header, stx := headerStx })\n            (headerStx[1].getArgs.toList.map (fun importStx =>\n              Elab.InfoTree.node (Elab.Info.ofCommandInfo {\n                elaborator := `import\n                stx := importStx\n              }) #[].toPArray'\n            )).toPArray'\n        )].toPArray'\n      }}\n      let headerSnap := {\n        beginPos := 0\n        stx := headerStx\n        mpState := headerParserState\n        cmdState := cmdState\n        interactiveDiags := \u2190 cmdState.messages.msgs.mapM (Widget.msgToInteractiveDiagnostic m.text \u00b7 hasWidgets)\n        tacticCache := (\u2190 IO.mkRef {})\n      }\n      publishDiagnostics m headerSnap.diagnostics.toArray hOut\n      return (headerSnap, srcSearchPath)", "start": [196, 3], "end": [251, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.initializeWorker", "code": "def initializeWorker (meta : DocumentMeta) (i o e : FS.Stream) (initParams : InitializeParams) (opts : Options)\n      : IO (WorkerContext \u00d7 WorkerState) := do\n    let clientHasWidgets := initParams.initializationOptions?.bind (\u00b7.hasWidgets?) |>.getD false\n    let (headerStx, headerTask) \u2190 compileHeader meta o opts (hasWidgets := clientHasWidgets)\n    let cancelTk \u2190 CancelToken.new\n    let ctx :=\n      { hIn  := i\n        hOut := o\n        hLog := e\n        headerTask\n        initParams\n        clientHasWidgets\n      }\n    let cmdSnaps \u2190 EIO.mapTask (t := headerTask) (match \u00b7 with\n      | Except.ok (s, _) => unfoldCmdSnaps meta #[s] cancelTk ctx (startAfterMs := 0)\n      | Except.error e   => throw (e : ElabTaskError))\n    let doc : EditableDocument := { meta, cmdSnaps := AsyncList.delayed cmdSnaps, cancelTk }\n    return (ctx,\n    { doc             := doc\n      initHeaderStx   := headerStx\n      pendingRequests := RBMap.empty\n      rpcSessions     := RBMap.empty\n    })", "start": [253, 3], "end": [275, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.updatePendingRequests", "code": "def updatePendingRequests (map : PendingRequestMap \u2192 PendingRequestMap) : WorkerM Unit := do\n    modify fun st => { st with pendingRequests := map st.pendingRequests }", "start": [279, 3], "end": [280, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.updateDocument", "code": "def updateDocument (newMeta : DocumentMeta) : WorkerM Unit := do\n    let ctx \u2190 read\n    let oldDoc := (\u2190get).doc\n    oldDoc.cancelTk.set\n    let initHeaderStx := (\u2190 get).initHeaderStx\n    let (newHeaderStx, newMpState, _) \u2190 Parser.parseHeader newMeta.mkInputContext\n    let cancelTk \u2190 CancelToken.new\n    let headSnapTask := oldDoc.cmdSnaps.waitHead?\n    let newSnaps \u2190 if initHeaderStx != newHeaderStx then\n      EIO.asTask (\u03b5 := ElabTaskError) (prio := .dedicated) do\n        IO.sleep ctx.initParams.editDelay.toUInt32\n        cancelTk.check\n        IO.Process.exit 2\n    else EIO.mapTask (\u03b5 := ElabTaskError) (t := headSnapTask) (prio := .dedicated) fun headSnap?? => do\n      let some headSnap \u2190 MonadExcept.ofExcept headSnap?? | panic! \"empty snapshots\"\n      let newHeaderSnap := { headSnap with stx := newHeaderStx, mpState := newMpState }\n      let changePos := oldDoc.meta.text.source.firstDiffPos newMeta.text.source\n      let (cmdSnaps, _) \u2190 oldDoc.cmdSnaps.getFinishedPrefix\n      let mut validSnaps \u2190 pure (cmdSnaps.takeWhile (fun s => s.endPos < changePos))\n      if h : validSnaps.length \u2264 1 then\n        validSnaps := [newHeaderSnap]\n      else\n        \n        have : validSnaps.length \u2265 2 := Nat.gt_of_not_le h\n        let mut lastSnap := validSnaps.getLast (by subst \u00b7; simp at h)\n        let preLastSnap :=\n          have : 0 < validSnaps.length := Nat.lt_of_lt_of_le (by decide) this\n          have : validSnaps.length - 2 < validSnaps.length := Nat.sub_lt this (by decide)\n          validSnaps[validSnaps.length - 2]\n        let newLastStx \u2190 parseNextCmd newMeta.mkInputContext preLastSnap\n        if newLastStx != lastSnap.stx then\n          validSnaps := validSnaps.dropLast\n      unfoldCmdSnaps newMeta validSnaps.toArray cancelTk ctx\n        (startAfterMs := ctx.initParams.editDelay.toUInt32)\n    modify fun st => { st with doc := { meta := newMeta, cmdSnaps := AsyncList.delayed newSnaps, cancelTk } }", "start": [282, 3], "end": [327, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleDidChange", "code": "def handleDidChange (p : DidChangeTextDocumentParams) : WorkerM Unit := do\n    let docId := p.textDocument\n    let changes := p.contentChanges\n    let oldDoc := (\u2190get).doc\n    let newVersion := docId.version?.getD 0\n    if \u00ac changes.isEmpty then\n      let newDocText := foldDocumentChanges changes oldDoc.meta.text\n      updateDocument \u27e8docId.uri, newVersion, newDocText, oldDoc.meta.dependencyBuildMode\u27e9", "start": [333, 3], "end": [340, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleCancelRequest", "code": "def handleCancelRequest (p : CancelParams) : WorkerM Unit := do\n    updatePendingRequests (fun pendingRequests => pendingRequests.erase p.id)", "start": [342, 3], "end": [343, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleRpcRelease", "code": "def handleRpcRelease (p : Lsp.RpcReleaseParams) : WorkerM Unit := do\n  if let some seshRef := (\u2190 get).rpcSessions.find? p.sessionId then\n    let monoMsNow \u2190 IO.monoMsNow\n    let discardRefs : StateM RpcObjectStore Unit := do\n      for ref in p.refs do\n        discard do rpcReleaseRef ref\n    seshRef.modify fun st =>\n      let st := st.keptAlive monoMsNow\n      let ((), objects) := discardRefs st.objects\n      { st with objects }", "start": [345, 1], "end": [356, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleRpcKeepAlive", "code": "def handleRpcKeepAlive (p : Lsp.RpcKeepAliveParams) : WorkerM Unit := do\n  match (\u2190 get).rpcSessions.find? p.sessionId with\n  | none => return\n  | some seshRef =>\n    seshRef.modify (\u00b7.keptAlive (\u2190 IO.monoMsNow))", "start": [358, 1], "end": [362, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleRpcConnect", "code": "def handleRpcConnect (_ : RpcConnectParams) : WorkerM RpcConnected := do\n  let (newId, newSesh) \u2190 RpcSession.new\n  let newSeshRef \u2190 IO.mkRef newSesh\n  modify fun st => { st with rpcSessions := st.rpcSessions.insert newId newSeshRef }\n  return { sessionId := newId }", "start": [369, 1], "end": [373, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.parseParams", "code": "def parseParams (paramType : Type) [FromJson paramType] (params : Json) : WorkerM paramType :=\n    match fromJson? params with\n    | Except.ok parsed => pure parsed\n    | Except.error inner => throwServerError s!\"Got param with wrong structure: {params.compress}\\n{inner}\"", "start": [378, 3], "end": [381, 108], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleNotification", "code": "def handleNotification (method : String) (params : Json) : WorkerM Unit := do\n    let handle := fun paramType [FromJson paramType] (handler : paramType \u2192 WorkerM Unit) =>\n      parseParams paramType params >>= handler\n    match method with\n    | \"textDocument/didChange\" => handle DidChangeTextDocumentParams handleDidChange\n    | \"$/cancelRequest\"        => handle CancelParams handleCancelRequest\n    | \"$/lean/rpc/release\"     => handle RpcReleaseParams handleRpcRelease\n    | \"$/lean/rpc/keepAlive\"   => handle RpcKeepAliveParams handleRpcKeepAlive\n    | _                        => throwServerError s!\"Got unsupported notification method: {method}\"", "start": [383, 3], "end": [391, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.queueRequest", "code": "def queueRequest (id : RequestID) (requestTask : Task (Except IO.Error Unit))\n      : WorkerM Unit := do\n    updatePendingRequests (fun pendingRequests => pendingRequests.insert id requestTask)", "start": [393, 3], "end": [395, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleRequest", "code": "def handleRequest (id : RequestID) (method : String) (params : Json)\n      : WorkerM Unit := do\n    let ctx \u2190 read\n    let st \u2190 get\n\n    if method == \"$/lean/rpc/connect\" then\n      try\n        let ps \u2190 parseParams RpcConnectParams params\n        let resp \u2190 handleRpcConnect ps\n        ctx.hOut.writeLspResponse \u27e8id, resp\u27e9\n      catch e =>\n        ctx.hOut.writeLspResponseError\n          { id\n            code := ErrorCode.internalError\n            message := toString e }\n      return\n\n    let t \u2190 IO.bindTask ctx.headerTask fun x => do\n     let (_, srcSearchPath) \u2190 IO.ofExcept x\n     let rc : RequestContext :=\n       { rpcSessions := st.rpcSessions\n         srcSearchPath\n         doc := st.doc\n         hLog := ctx.hLog\n         hOut := ctx.hOut\n         initParams := ctx.initParams }\n     let t? \u2190 EIO.toIO' <| handleLspRequest method params rc\n     let t\u2081 \u2190 match t? with\n       | Except.error e =>\n         IO.asTask do\n           ctx.hOut.writeLspResponseError <| e.toLspResponseError id\n       | Except.ok t => (IO.mapTask \u00b7 t) fun\n         | Except.ok resp =>\n           ctx.hOut.writeLspResponse \u27e8id, resp\u27e9\n         | Except.error e =>\n           ctx.hOut.writeLspResponseError <| e.toLspResponseError id\n    queueRequest id t", "start": [397, 3], "end": [434, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.mainLoop", "code": "partial def mainLoop : WorkerM Unit := do\n    let ctx \u2190 read\n    let mut st \u2190 get\n    let msg \u2190 ctx.hIn.readLspMessage\n    let filterFinishedTasks (acc : PendingRequestMap) (id : RequestID) (task : Task (Except IO.Error Unit))\n        : IO PendingRequestMap := do\n      if (\u2190 hasFinished task) then\n        \n        if let Except.error e := task.get then\n          throwServerError s!\"Failed responding to request {id}: {e}\"\n        pure <| acc.erase id\n      else pure acc\n    let pendingRequests \u2190 st.pendingRequests.foldM (fun acc id task => filterFinishedTasks acc id task) st.pendingRequests\n    st := { st with pendingRequests }\n\n    for (id, seshRef) in st.rpcSessions do\n      let sesh \u2190 seshRef.get\n      if (\u2190 sesh.hasExpired) then\n        st := { st with rpcSessions := st.rpcSessions.erase id }\n\n    set st\n    match msg with\n    | Message.request id method (some params) =>\n      handleRequest id method (toJson params)\n      mainLoop\n    | Message.notification \"exit\" none =>\n      let doc := st.doc\n      doc.cancelTk.set\n      return ()\n    | Message.notification method (some params) =>\n      handleNotification method (toJson params)\n      mainLoop\n    | _ => throwServerError \"Got invalid JSON-RPC message\"", "start": [438, 3], "end": [472, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.initAndRunWorker", "code": "def initAndRunWorker (i o e : FS.Stream) (opts : Options) : IO UInt32 := do\n  let i \u2190 maybeTee \"fwIn.txt\" false i\n  let o \u2190 maybeTee \"fwOut.txt\" true o\n  let initParams \u2190 i.readLspRequestAs \"initialize\" InitializeParams\n  let \u27e8_, param\u27e9 \u2190 i.readLspNotificationAs \"textDocument/didOpen\" LeanDidOpenTextDocumentParams\n  let doc := param.textDocument\n  \n  let meta : DocumentMeta := \u27e8doc.uri, doc.version, doc.text.toFileMap, param.dependencyBuildMode?.getD .always\u27e9\n  let e := e.withPrefix s!\"[{param.textDocument.uri}] \"\n  let _ \u2190 IO.setStderr e\n  try\n    let (ctx, st) \u2190 initializeWorker meta i o e initParams.param opts\n    let _ \u2190 StateRefT'.run (s := st) <| ReaderT.run (r := ctx) mainLoop\n    return (0 : UInt32)\n  catch e =>\n    IO.eprintln e\n    publishDiagnostics meta #[{ range := \u27e8\u27e80, 0\u27e9, \u27e80, 0\u27e9\u27e9, severity? := DiagnosticSeverity.error, message := e.toString }] o\n    return (1 : UInt32)", "start": [475, 1], "end": [496, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.workerMain", "code": "@[export lean_server_worker_main]\ndef workerMain (opts : Options) : IO UInt32 := do\n  let i \u2190 IO.getStdin\n  let o \u2190 IO.getStdout\n  let e \u2190 IO.getStderr\n  try\n    let exitCode \u2190 initAndRunWorker i o e opts\n    o.flush\n    e.flush\n    IO.Process.exit exitCode.toUInt8\n  catch err =>\n    e.putStrLn s!\"worker initialization error: {err}\"\n    return (1 : UInt32)", "start": [498, 1], "end": [512, 24], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/Rpc.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Server/Rpc/RequestHandling.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Deriving.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Server/Watchdog.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Paths.lean", "lake-packages/lean4/src/lean/Lean/Server/Utils.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp.lean", "lake-packages/lean4/src/lean/Init/Data/ByteArray.lean", "lake-packages/lean4/src/lean/Lean/Data/FuzzyMatching.lean", "lake-packages/lean4/src/lean/Lean/Server/References.lean", "lake-packages/lean4/src/lean/Lean/Server/Requests.lean"], "premises": [{"full_name": "Lean.Server.Watchdog.workerCfg", "code": "def workerCfg : Process.StdioConfig := {\n    stdin  := Process.Stdio.piped\n    stdout := Process.Stdio.piped\n    stderr := Process.Stdio.inherit\n  }", "start": [71, 3], "end": [76, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.WorkerEvent", "code": "inductive WorkerEvent where\n    | terminated\n    | importsChanged\n    | crashed (e : IO.Error)\n    | ioError (e : IO.Error)", "start": [78, 3], "end": [83, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.WorkerState", "code": "inductive WorkerState where\n    \n    | crashed (queuedMsgs : Array JsonRpc.Message)\n    | running", "start": [85, 3], "end": [94, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.PendingRequestMap", "code": "abbrev PendingRequestMap := RBMap RequestID JsonRpc.Message compare", "start": [96, 3], "end": [96, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.FileWorker", "code": "structure FileWorker where\n    doc                : DocumentMeta\n    proc               : Process.Child workerCfg\n    commTask           : Task WorkerEvent\n    state              : WorkerState\n    \n    pendingRequestsRef : IO.Ref PendingRequestMap", "start": [100, 3], "end": [110, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.FileWorker.stdin", "code": "def stdin (fw : FileWorker) : FS.Stream :=\n    FS.Stream.ofHandle fw.proc.stdin", "start": [114, 3], "end": [115, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.FileWorker.stdout", "code": "def stdout (fw : FileWorker) : FS.Stream :=\n    FS.Stream.ofHandle fw.proc.stdout", "start": [117, 3], "end": [118, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.FileWorker.erasePendingRequest", "code": "def erasePendingRequest (fw : FileWorker) (id : RequestID) : IO Unit :=\n    fw.pendingRequestsRef.modify fun pendingRequests => pendingRequests.erase id", "start": [120, 3], "end": [121, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.FileWorker.errorPendingRequests", "code": "def errorPendingRequests (fw : FileWorker) (hError : FS.Stream) (code : ErrorCode) (msg : String) : IO Unit := do\n    let pendingRequests \u2190 fw.pendingRequestsRef.modifyGet (fun pendingRequests => (pendingRequests, RBMap.empty))\n    for \u27e8id, _\u27e9 in pendingRequests do\n      hError.writeLspResponseError { id := id, code := code, message := msg }", "start": [123, 3], "end": [126, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.FileWorkerMap", "code": "abbrev FileWorkerMap := RBMap DocumentUri FileWorker compare", "start": [132, 3], "end": [132, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.ServerContext", "code": "structure ServerContext where\n    hIn            : FS.Stream\n    hOut           : FS.Stream\n    hLog           : FS.Stream\n    \n    args           : List String\n    fileWorkersRef : IO.Ref FileWorkerMap\n    \n    initParams     : InitializeParams\n    workerPath     : System.FilePath\n    srcSearchPath  : System.SearchPath\n    references     : IO.Ref References", "start": [134, 3], "end": [145, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.ServerM", "code": "abbrev ServerM := ReaderT ServerContext IO", "start": [147, 3], "end": [147, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.updateFileWorkers", "code": "def updateFileWorkers (val : FileWorker) : ServerM Unit := do\n    (\u2190read).fileWorkersRef.modify (fun fileWorkers => fileWorkers.insert val.doc.uri val)", "start": [149, 3], "end": [150, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.findFileWorker?", "code": "def findFileWorker? (uri : DocumentUri) : ServerM (Option FileWorker) :=\n    return (\u2190 (\u2190read).fileWorkersRef.get).find? uri", "start": [152, 3], "end": [153, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.findFileWorker!", "code": "def findFileWorker! (uri : DocumentUri) : ServerM FileWorker := do\n    let some fw \u2190 findFileWorker? uri\n      | throwServerError s!\"cannot find open document '{uri}'\"\n    return fw", "start": [155, 3], "end": [158, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.eraseFileWorker", "code": "def eraseFileWorker (uri : DocumentUri) : ServerM Unit := do\n    let s \u2190 read\n    s.fileWorkersRef.modify (fun fileWorkers => fileWorkers.erase uri)\n    if let some path := fileUriToPath? uri then\n      if let some module \u2190 searchModuleNameOfFileName path s.srcSearchPath then\n        s.references.modify fun refs => refs.removeWorkerRefs module", "start": [160, 3], "end": [165, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.log", "code": "def log (msg : String) : ServerM Unit := do\n    let st \u2190 read\n    st.hLog.putStrLn msg\n    st.hLog.flush", "start": [167, 3], "end": [170, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleIleanInfoUpdate", "code": "def handleIleanInfoUpdate (fw : FileWorker) (params : LeanIleanInfoParams) : ServerM Unit := do\n    let s \u2190 read\n    if let some path := fileUriToPath? fw.doc.uri then\n      if let some module \u2190 searchModuleNameOfFileName path s.srcSearchPath then\n        s.references.modify fun refs => refs.updateWorkerRefs module params.version params.references", "start": [172, 3], "end": [176, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleIleanInfoFinal", "code": "def handleIleanInfoFinal (fw : FileWorker) (params : LeanIleanInfoParams) : ServerM Unit := do\n    let s \u2190 read\n    if let some path := fileUriToPath? fw.doc.uri then\n      if let some module \u2190 searchModuleNameOfFileName path s.srcSearchPath then\n        s.references.modify fun refs => refs.finalizeWorkerRefs module params.version params.references", "start": [178, 3], "end": [182, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.forwardMessages", "code": "private partial def forwardMessages (fw : FileWorker) : ServerM (Task WorkerEvent) := do\n    let o := (\u2190read).hOut\n    let rec loop : ServerM WorkerEvent := do\n      try\n        let msg \u2190 fw.stdout.readLspMessage\n        match msg with\n          | Message.response id _ => do\n            fw.erasePendingRequest id\n            o.writeLspMessage msg\n          | Message.responseError id _ _ _ => do\n            fw.erasePendingRequest id\n            o.writeLspMessage msg\n          | Message.notification \"$/lean/ileanInfoUpdate\" params =>\n            if let some params := params then\n              if let Except.ok params := FromJson.fromJson? <| ToJson.toJson params then\n                handleIleanInfoUpdate fw params\n          | Message.notification \"$/lean/ileanInfoFinal\" params =>\n            if let some params := params then\n              if let Except.ok params := FromJson.fromJson? <| ToJson.toJson params then\n                handleIleanInfoFinal fw params\n          | _ => o.writeLspMessage msg\n      catch err =>\n        let exitCode \u2190 fw.proc.wait\n        try fw.proc.kill catch _ => pure ()\n        match exitCode with\n        | 0 =>\n          fw.errorPendingRequests o ErrorCode.contentModified\n            (s!\"The file worker for {fw.doc.uri} has been terminated. Either the header has changed,\"\n            ++ \" or the file was closed, or the server is shutting down.\")\n          publishDiagnostics fw.doc #[] o\n          return WorkerEvent.terminated\n        | 2 =>\n          return .importsChanged\n        | _ =>\n          fw.errorPendingRequests o (if exitCode = 1 then ErrorCode.workerExited else ErrorCode.workerCrashed)\n            s!\"Server process for {fw.doc.uri} crashed, {if exitCode = 1 then \"see stderr for exception\" else \"likely due to a stack overflow or a bug\"}.\"\n          publishProgressAtPos fw.doc 0 o (kind := LeanFileProgressKind.fatalError)\n          return WorkerEvent.crashed err\n      loop\n    let task \u2190 IO.asTask (loop $ \u2190read) Task.Priority.dedicated\n    return task.map fun\n      | Except.ok ev   => ev\n      | Except.error e => WorkerEvent.ioError e", "start": [184, 3], "end": [238, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.startFileWorker", "code": "def startFileWorker (m : DocumentMeta) : ServerM Unit := do\n    publishProgressAtPos m 0 (\u2190 read).hOut\n    let st \u2190 read\n    let workerProc \u2190 Process.spawn {\n      toStdioConfig := workerCfg\n      cmd           := st.workerPath.toString\n      args          := #[\"      setsid        := true\n    }\n    let pendingRequestsRef \u2190 IO.mkRef (RBMap.empty : PendingRequestMap)\n    let initialDependencyBuildMode := m.dependencyBuildMode\n    let updatedDependencyBuildMode :=\n      if initialDependencyBuildMode matches .once then\n        .never\n      else\n        initialDependencyBuildMode\n    let fw : FileWorker := {\n      doc                := { m with dependencyBuildMode := updatedDependencyBuildMode}\n      proc               := workerProc\n      commTask           := Task.pure WorkerEvent.terminated\n      state              := WorkerState.running\n      pendingRequestsRef := pendingRequestsRef\n    }\n    let commTask \u2190 forwardMessages fw\n    let fw : FileWorker := { fw with commTask := commTask }\n    fw.stdin.writeLspRequest \u27e80, \"initialize\", st.initParams\u27e9\n    fw.stdin.writeLspNotification {\n      method := \"textDocument/didOpen\"\n      param  := {\n        textDocument := {\n          uri        := m.uri\n          languageId := \"lean\"\n          version    := m.version\n          text       := m.text.source\n        }\n        dependencyBuildMode? := initialDependencyBuildMode\n        : LeanDidOpenTextDocumentParams\n      }\n    }\n    updateFileWorkers fw", "start": [240, 3], "end": [283, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.terminateFileWorker", "code": "def terminateFileWorker (uri : DocumentUri) : ServerM Unit := do\n    let fw \u2190 findFileWorker! uri\n    try\n      fw.stdin.writeLspMessage (Message.notification \"exit\" none)\n    catch _ =>\n      \n      return\n    eraseFileWorker uri", "start": [285, 3], "end": [297, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleCrash", "code": "def handleCrash (uri : DocumentUri) (queuedMsgs : Array JsonRpc.Message) : ServerM Unit := do\n    updateFileWorkers { \u2190findFileWorker! uri with state := WorkerState.crashed queuedMsgs }", "start": [299, 3], "end": [300, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.tryWriteMessage", "code": "def tryWriteMessage (uri : DocumentUri) (msg : JsonRpc.Message) (queueFailedMessage := true) (restartCrashedWorker := false) :\n      ServerM Unit := do\n    let some fw \u2190 findFileWorker? uri\n      | do\n        (\u2190read).hLog.putStrLn s!\"Cannot send message to unknown document '{uri}':\\n{(toJson msg).compress}\"\n        return\n    match fw.state with\n    | WorkerState.crashed queuedMsgs =>\n      let mut queuedMsgs := queuedMsgs\n      if queueFailedMessage then\n        queuedMsgs := queuedMsgs.push msg\n      if !restartCrashedWorker then\n        return\n      eraseFileWorker uri\n      startFileWorker fw.doc\n      let newFw \u2190 findFileWorker! uri\n      let mut crashedMsgs := #[]\n      for msg in queuedMsgs do\n        try\n          newFw.stdin.writeLspMessage msg\n        catch _ =>\n          crashedMsgs := crashedMsgs.push msg\n      if \u00ac crashedMsgs.isEmpty then\n        handleCrash uri crashedMsgs\n    | WorkerState.running =>\n      let initialQueuedMsgs :=\n        if queueFailedMessage then\n          #[msg]\n        else\n          #[]\n      try\n        fw.stdin.writeLspMessage msg\n      catch _ =>\n        handleCrash uri initialQueuedMsgs", "start": [302, 3], "end": [342, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.findDefinitions", "code": "def findDefinitions (p : TextDocumentPositionParams) : ServerM <| Array Location := do\n  let mut definitions := #[]\n  if let some path := fileUriToPath? p.textDocument.uri then\n    let srcSearchPath := (\u2190 read).srcSearchPath\n    if let some module \u2190 searchModuleNameOfFileName path srcSearchPath then\n      let references \u2190 (\u2190 read).references.get\n      for ident in references.findAt module p.position do\n        if let some definition \u2190 references.definitionOf? ident srcSearchPath then\n          definitions := definitions.push definition\n  return definitions", "start": [349, 1], "end": [358, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleReference", "code": "def handleReference (p : ReferenceParams) : ServerM (Array Location) := do\n  let mut result := #[]\n  if let some path := fileUriToPath? p.textDocument.uri then\n    let srcSearchPath := (\u2190 read).srcSearchPath\n    if let some module \u2190 searchModuleNameOfFileName path srcSearchPath then\n      let references \u2190 (\u2190 read).references.get\n      for ident in references.findAt module p.position do\n        let identRefs \u2190 references.referringTo module ident srcSearchPath p.context.includeDeclaration\n        result := result.append identRefs\n  return result", "start": [360, 1], "end": [369, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleWorkspaceSymbol", "code": "def handleWorkspaceSymbol (p : WorkspaceSymbolParams) : ServerM (Array SymbolInformation) := do\n  if p.query.isEmpty then\n    return #[]\n  let references \u2190 (\u2190 read).references.get\n  let srcSearchPath := (\u2190 read).srcSearchPath\n  let symbols \u2190 references.definitionsMatching srcSearchPath (maxAmount? := none)\n    fun name =>\n      let name := privateToUserName? name |>.getD name\n      if let some score := fuzzyMatchScoreWithThreshold? p.query name.toString then\n        some (name.toString, score)\n      else\n        none\n  return symbols\n    |>.qsort (fun ((_, s1), _) ((_, s2), _) => s1 > s2)\n    |>.extract 0 100 |>.map fun ((name, _), location) =>\n      { name, kind := SymbolKind.constant, location }", "start": [371, 1], "end": [387, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleDidOpen", "code": "def handleDidOpen (p : LeanDidOpenTextDocumentParams) : ServerM Unit :=\n    let doc := p.textDocument\n    \n    startFileWorker \u27e8doc.uri, doc.version, doc.text.toFileMap, p.dependencyBuildMode?.getD .always\u27e9", "start": [392, 3], "end": [399, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleDidChange", "code": "def handleDidChange (p : DidChangeTextDocumentParams) : ServerM Unit := do\n    let doc := p.textDocument\n    let changes := p.contentChanges\n    let fw \u2190 findFileWorker! p.textDocument.uri\n    let oldDoc := fw.doc\n    let newVersion := doc.version?.getD 0\n    if changes.isEmpty then\n      return\n    let newDocText := foldDocumentChanges changes oldDoc.text\n    let newDoc : DocumentMeta := \u27e8doc.uri, newVersion, newDocText, oldDoc.dependencyBuildMode\u27e9\n    updateFileWorkers { fw with doc := newDoc }\n    tryWriteMessage doc.uri (Notification.mk \"textDocument/didChange\" p) (restartCrashedWorker := true)", "start": [401, 3], "end": [412, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleDidClose", "code": "def handleDidClose (p : DidCloseTextDocumentParams) : ServerM Unit :=\n    terminateFileWorker p.textDocument.uri", "start": [414, 3], "end": [415, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleDidChangeWatchedFiles", "code": "def handleDidChangeWatchedFiles (p : DidChangeWatchedFilesParams) : ServerM Unit := do\n    let references := (\u2190 read).references\n    let oleanSearchPath \u2190 Lean.searchPathRef.get\n    let ileans \u2190 oleanSearchPath.findAllWithExt \"ilean\"\n    for change in p.changes do\n      if let some path := fileUriToPath? change.uri then\n      if let FileChangeType.Deleted := change.type then\n        references.modify (fun r => r.removeIlean path)\n      else if ileans.contains path then\n        try\n          let ilean \u2190 Ilean.load path\n          if let FileChangeType.Changed := change.type then\n            references.modify (fun r => r.removeIlean path |>.addIlean path ilean)\n          else\n            references.modify (fun r => r.addIlean path ilean)\n        catch\n          | .noFileOrDirectory .. => references.modify (\u00b7.removeIlean path)\n          | e => throw e", "start": [417, 3], "end": [435, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleCancelRequest", "code": "def handleCancelRequest (p : CancelParams) : ServerM Unit := do\n    let fileWorkers \u2190 (\u2190read).fileWorkersRef.get\n    for \u27e8uri, fw\u27e9 in fileWorkers do\n      if (\u2190 fw.pendingRequestsRef.get).contains p.id then\n        tryWriteMessage uri (Notification.mk \"$/cancelRequest\" p) (queueFailedMessage := false)", "start": [437, 3], "end": [443, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.forwardNotification", "code": "def forwardNotification {\u03b1 : Type} [ToJson \u03b1] [FileSource \u03b1] (method : String) (params : \u03b1) : ServerM Unit :=\n    tryWriteMessage (fileSource params) (Notification.mk method params) (queueFailedMessage := true)", "start": [445, 3], "end": [446, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.parseParams", "code": "def parseParams (paramType : Type) [FromJson paramType] (params : Json) : ServerM paramType :=\n    match fromJson? params with\n    | Except.ok parsed => pure parsed\n    | Except.error inner => throwServerError s!\"Got param with wrong structure: {params.compress}\\n{inner}\"", "start": [450, 3], "end": [453, 108], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.forwardRequestToWorker", "code": "def forwardRequestToWorker (id : RequestID) (method : String) (params : Json) : ServerM Unit := do\n    let uri: DocumentUri \u2190\n      if method == \"$/lean/rpc/connect\" then\n        let ps \u2190 parseParams Lsp.RpcConnectParams params\n        pure <| fileSource ps\n      else match (\u2190 routeLspRequest method params) with\n      | Except.error e =>\n        (\u2190read).hOut.writeLspResponseError <| e.toLspResponseError id\n        return\n      | Except.ok uri => pure uri\n    let some fw \u2190 findFileWorker? uri\n      \n      | do\n        (\u2190read).hOut.writeLspResponseError\n          { id      := id\n            \n            code    := ErrorCode.contentModified\n            message := s!\"Cannot process request to closed file '{uri}'\" }\n        return\n    let r := Request.mk id method params\n    fw.pendingRequestsRef.modify (\u00b7.insert id r)\n    tryWriteMessage uri r", "start": [455, 3], "end": [480, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleRequest", "code": "def handleRequest (id : RequestID) (method : String) (params : Json) : ServerM Unit := do\n    let handle \u03b1 \u03b2 [FromJson \u03b1] [ToJson \u03b2] (handler : \u03b1 \u2192 ServerM \u03b2) : ServerM Unit := do\n      let hOut := (\u2190 read).hOut\n      try\n        let params \u2190 parseParams \u03b1 params\n        let result \u2190 handler params\n        hOut.writeLspResponse \u27e8id, result\u27e9\n      catch\n        | e => hOut.writeLspResponseError {\n          id := id\n          code := ErrorCode.internalError\n          message := s!\"Failed to process request {id}: {e}\"\n        }\n    if method == \"textDocument/definition\" || method == \"textDocument/declaration\" then\n      let params \u2190 parseParams TextDocumentPositionParams params\n      let definitions \u2190 findDefinitions params\n      if !definitions.isEmpty then\n        (\u2190 read).hOut.writeLspResponse \u27e8id, definitions\u27e9\n        return\n    match method with\n      | \"textDocument/references\" => handle ReferenceParams (Array Location) handleReference\n      | \"workspace/symbol\" => handle WorkspaceSymbolParams (Array SymbolInformation) handleWorkspaceSymbol\n      | _ => forwardRequestToWorker id method params", "start": [482, 3], "end": [510, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.handleNotification", "code": "def handleNotification (method : String) (params : Json) : ServerM Unit := do\n    let handle := (fun \u03b1 [FromJson \u03b1] (handler : \u03b1 \u2192 ServerM Unit) => parseParams \u03b1 params >>= handler)\n    match method with\n    | \"textDocument/didOpen\"            => handle _ handleDidOpen\n    | \"textDocument/didChange\"          => handle DidChangeTextDocumentParams handleDidChange\n    | \"textDocument/didClose\"           => handle DidCloseTextDocumentParams handleDidClose\n    | \"workspace/didChangeWatchedFiles\" => handle DidChangeWatchedFilesParams handleDidChangeWatchedFiles\n    | \"$/cancelRequest\"                 => handle CancelParams handleCancelRequest\n    | \"$/lean/rpc/connect\"              => handle RpcConnectParams (forwardNotification method)\n    | \"$/lean/rpc/release\"              => handle RpcReleaseParams (forwardNotification method)\n    | \"$/lean/rpc/keepAlive\"            => handle RpcKeepAliveParams (forwardNotification method)\n    | _                                 =>\n      if !\"$/\".isPrefixOf method then  (\u2190read).hLog.putStrLn s!\"Got unsupported notification: {method}\"", "start": [512, 3], "end": [525, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.shutdown", "code": "def shutdown : ServerM Unit := do\n    let fileWorkers \u2190 (\u2190read).fileWorkersRef.get\n    for \u27e8uri, _\u27e9 in fileWorkers do\n      terminateFileWorker uri\n    for \u27e8_, fw\u27e9 in fileWorkers do\n      discard <| IO.wait fw.commTask", "start": [529, 3], "end": [534, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.ServerEvent", "code": "inductive ServerEvent where\n    | workerEvent (fw : FileWorker) (ev : WorkerEvent)\n    | clientMsg (msg : JsonRpc.Message)\n    | clientError (e : IO.Error)", "start": [536, 3], "end": [539, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.runClientTask", "code": "def runClientTask : ServerM (Task ServerEvent) := do\n    let st \u2190 read\n    let readMsgAction : IO ServerEvent := do\n      \n      let msg \u2190 st.hIn.readLspMessage\n      pure <| ServerEvent.clientMsg msg\n    let clientTask := (\u2190 IO.asTask readMsgAction).map fun\n      | Except.ok ev   => ev\n      | Except.error e => ServerEvent.clientError e\n    return clientTask", "start": [541, 3], "end": [550, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.mainLoop", "code": "partial def mainLoop (clientTask : Task ServerEvent) : ServerM Unit := do\n    let st \u2190 read\n    let workers \u2190 st.fileWorkersRef.get\n    let mut workerTasks := #[]\n    for (_, fw) in workers do\n      if let WorkerState.running := fw.state then\n        workerTasks := workerTasks.push <| fw.commTask.map (ServerEvent.workerEvent fw)\n\n    let ev \u2190 IO.waitAny (clientTask :: workerTasks.toList)\n    match ev with\n    | ServerEvent.clientMsg msg =>\n      match msg with\n      | Message.request id \"shutdown\" _ =>\n        shutdown\n        st.hOut.writeLspResponse \u27e8id, Json.null\u27e9\n      | Message.request id method (some params) =>\n        handleRequest id method (toJson params)\n        mainLoop (\u2190runClientTask)\n      | Message.response .. =>\n        mainLoop (\u2190runClientTask)\n      | Message.responseError _ _ e .. =>\n        throwServerError s!\"Unhandled response error: {e}\"\n      | Message.notification method (some params) =>\n        handleNotification method (toJson params)\n        mainLoop (\u2190runClientTask)\n      | _ => throwServerError \"Got invalid JSON-RPC message\"\n    | ServerEvent.clientError e => throw e\n    | ServerEvent.workerEvent fw ev =>\n      match ev with\n      | WorkerEvent.ioError e =>\n        throwServerError s!\"IO error while processing events for {fw.doc.uri}: {e}\"\n      | WorkerEvent.crashed _ =>\n        handleCrash fw.doc.uri #[]\n        mainLoop clientTask\n      | WorkerEvent.terminated =>\n        throwServerError \"Internal server error: got termination event for worker that should have been removed\"\n      | .importsChanged =>\n        startFileWorker fw.doc\n        mainLoop clientTask", "start": [552, 3], "end": [591, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.mkLeanServerCapabilities", "code": "def mkLeanServerCapabilities : ServerCapabilities := {\n  textDocumentSync? := some {\n    openClose         := true\n    change            := TextDocumentSyncKind.incremental\n    willSave          := false\n    willSaveWaitUntil := false\n    save?             := none\n  }\n  completionProvider? := some {\n    triggerCharacters? := some #[\".\"]\n  }\n  hoverProvider := true\n  declarationProvider := true\n  definitionProvider := true\n  typeDefinitionProvider := true\n  referencesProvider := true\n  workspaceSymbolProvider := true\n  documentHighlightProvider := true\n  documentSymbolProvider := true\n  foldingRangeProvider := true\n  semanticTokensProvider? := some {\n    legend := {\n      tokenTypes     := SemanticTokenType.names\n      tokenModifiers := SemanticTokenModifier.names\n    }\n    full  := true\n    range := true\n  }\n  codeActionProvider? := some {\n    resolveProvider? := true,\n    codeActionKinds? := some #[\"quickfix\", \"refactor\"]\n  }\n}", "start": [594, 1], "end": [627, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.initAndRunWatchdogAux", "code": "def initAndRunWatchdogAux : ServerM Unit := do\n  let st \u2190 read\n  try\n    discard $ st.hIn.readLspNotificationAs \"initialized\" InitializedParams\n    let clientTask \u2190 runClientTask\n    mainLoop clientTask\n  catch err =>\n    shutdown\n    throw err\n  \n  let Message.notification \"exit\" none \u2190\n    try st.hIn.readLspMessage\n    catch _ => pure (Message.notification \"exit\" none)\n    | throwServerError \"Got `shutdown` request, expected an `exit` notification\"", "start": [629, 1], "end": [643, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.findWorkerPath", "code": "def findWorkerPath : IO System.FilePath := do\n  let mut workerPath \u2190 IO.appPath\n  if let some path := (\u2190IO.getEnv \"LEAN_SYSROOT\") then\n    workerPath := System.FilePath.mk path / \"bin\" / \"lean\" |>.withExtension System.FilePath.exeExtension\n  if let some path := (\u2190IO.getEnv \"LEAN_WORKER_PATH\") then\n    workerPath := System.FilePath.mk path\n  return workerPath", "start": [645, 1], "end": [651, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.loadReferences", "code": "def loadReferences : IO References := do\n  let oleanSearchPath \u2190 Lean.searchPathRef.get\n  let mut refs := References.empty\n  for path in \u2190 oleanSearchPath.findAllWithExt \"ilean\" do\n    try\n      refs := refs.addIlean path (\u2190 Ilean.load path)\n    catch _ =>\n      pure ()\n  return refs", "start": [653, 1], "end": [664, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.initAndRunWatchdog", "code": "def initAndRunWatchdog (args : List String) (i o e : FS.Stream) : IO Unit := do\n  let workerPath \u2190 findWorkerPath\n  let srcSearchPath \u2190 initSrcSearchPath (\u2190 getBuildDir)\n  let references \u2190 IO.mkRef (\u2190 loadReferences)\n  let fileWorkersRef \u2190 IO.mkRef (RBMap.empty : FileWorkerMap)\n  let i \u2190 maybeTee \"wdIn.txt\" false i\n  let o \u2190 maybeTee \"wdOut.txt\" true o\n  let e \u2190 maybeTee \"wdErr.txt\" true e\n  let initRequest \u2190 i.readLspRequestAs \"initialize\" InitializeParams\n  o.writeLspResponse {\n    id     := initRequest.id\n    result := {\n      capabilities := mkLeanServerCapabilities\n      serverInfo?  := some {\n        name     := \"Lean 4 Server\"\n        version? := \"0.1.2\"\n      }\n      : InitializeResult\n    }\n  }\n  o.writeLspRequest {\n    id := RequestID.str \"register_ilean_watcher\"\n    method := \"client/registerCapability\"\n    param := some {\n      registrations := #[ {\n        id := \"ilean_watcher\"\n        method := \"workspace/didChangeWatchedFiles\"\n        registerOptions := some <| toJson {\n          watchers := #[ { globPattern := \"**/*.ilean\" } ]\n        : DidChangeWatchedFilesRegistrationOptions }\n      } ]\n    : RegistrationParams }\n  }\n  ReaderT.run initAndRunWatchdogAux {\n    hIn            := i\n    hOut           := o\n    hLog           := e\n    args           := args\n    fileWorkersRef := fileWorkersRef\n    initParams     := initRequest.param\n    workerPath\n    srcSearchPath\n    references\n    : ServerContext\n  }", "start": [666, 1], "end": [710, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Watchdog.watchdogMain", "code": "@[export lean_server_watchdog_main]\ndef watchdogMain (args : List String) : IO UInt32 := do\n  let i \u2190 IO.getStdin\n  let o \u2190 IO.getStdout\n  let e \u2190 IO.getStderr\n  try\n    initAndRunWatchdog args i o e\n    return 0\n  catch err =>\n    e.putStrLn s!\"Watchdog error: {err}\"\n    return 1", "start": [712, 1], "end": [722, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Linter/Builtin.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Linter/Util.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Linter.getLinterSuspiciousUnexpanderPatterns", "code": "def getLinterSuspiciousUnexpanderPatterns (o : Options) : Bool := getLinterValue linter.suspiciousUnexpanderPatterns o", "start": [11, 1], "end": [11, 119], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.suspiciousUnexpanderPatterns", "code": "def suspiciousUnexpanderPatterns : Linter where\n  run cmdStx := do\n    unless getLinterSuspiciousUnexpanderPatterns (\u2190 getOptions) do\n      return\n\n    let `($[$_:docComment]? @[$[$attrs:attr],*] $(_vis)? def $_ : $_ $[| $pats => $_]*) := cmdStx | return\n\n    unless attrs.any (\u00b7 matches `(attr| app_unexpander $_)) do\n      return\n\n    for pat in pats do\n      let patHead \u2190 match pat with\n        | `(`($patHead:ident $_args*)) => pure patHead\n        | `(`($patHead:ident))         => pure patHead\n        | _                            => continue\n\n      logLint linter.suspiciousUnexpanderPatterns patHead\n        \"Unexpanders should match the function name against an antiquotation `$_` so as to be independent of the specific pretty printing of the name.\"", "start": [13, 1], "end": [31, 152], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Xml.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Xml/Parser.lean", "lake-packages/lean4/src/lean/Lean/Data/Xml/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Deriving.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Deriving/Repr.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Ord.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/BEq.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/DecEq.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Nonempty.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Hashable.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/TypeName.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/SizeOf.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Util.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/FromToJson.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving/Inhabited.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Print.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/FoldConsts.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.throwUnknownId", "code": "private def throwUnknownId (id : Name) : CommandElabM Unit :=\n  throwError \"unknown identifier '{mkConst id}'\"", "start": [11, 1], "end": [12, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.levelParamsToMessageData", "code": "private def levelParamsToMessageData (levelParams : List Name) : MessageData :=\n  match levelParams with\n  | []    => \"\"\n  | u::us => Id.run do\n    let mut m := m!\".\\{{u}\"\n    for u in us do\n      m := m ++ \", \" ++ toMessageData u\n    return m ++ \"}\"", "start": [14, 1], "end": [21, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkHeader", "code": "private def mkHeader (kind : String) (id : Name) (levelParams : List Name) (type : Expr) (safety : DefinitionSafety) : CommandElabM MessageData := do\n  let m : MessageData :=\n    match (\u2190 getReducibilityStatus id) with\n    | ReducibilityStatus.irreducible => \"@[irreducible] \"\n    | ReducibilityStatus.reducible => \"@[reducible] \"\n    | ReducibilityStatus.semireducible => \"\"\n  let m :=\n    m ++\n    match safety with\n    | DefinitionSafety.unsafe  => \"unsafe \"\n    | DefinitionSafety.partial => \"partial \"\n    | DefinitionSafety.safe    => \"\"\n  let m := if isProtected (\u2190 getEnv) id then m ++ \"protected \" else m\n  let (m, id) := match privateToUserName? id with\n    | some id => (m ++ \"private \", id)\n    | none    => (m, id)\n  let m := m ++ kind ++ \" \" ++ id ++ levelParamsToMessageData levelParams ++ \" : \" ++ type\n  pure m", "start": [23, 1], "end": [40, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkHeader'", "code": "private def mkHeader' (kind : String) (id : Name) (levelParams : List Name) (type : Expr) (isUnsafe : Bool) : CommandElabM MessageData :=\n  mkHeader kind id levelParams type (if isUnsafe then DefinitionSafety.unsafe else DefinitionSafety.safe)", "start": [42, 1], "end": [43, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.printDefLike", "code": "private def printDefLike (kind : String) (id : Name) (levelParams : List Name) (type : Expr) (value : Expr) (safety := DefinitionSafety.safe) : CommandElabM Unit := do\n  let m \u2190 mkHeader kind id levelParams type safety\n  let m := m ++ \" :=\" ++ Format.line ++ value\n  logInfo m", "start": [45, 1], "end": [48, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.printAxiomLike", "code": "private def printAxiomLike (kind : String) (id : Name) (levelParams : List Name) (type : Expr) (isUnsafe := false) : CommandElabM Unit := do\n  logInfo (\u2190 mkHeader' kind id levelParams type isUnsafe)", "start": [50, 1], "end": [51, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.printQuot", "code": "private def printQuot (id : Name) (levelParams : List Name) (type : Expr) : CommandElabM Unit := do\n  printAxiomLike \"Quotient primitive\" id levelParams type", "start": [53, 1], "end": [54, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.printInduct", "code": "private def printInduct (id : Name) (levelParams : List Name) (numParams : Nat) (type : Expr)\n    (ctors : List Name) (isUnsafe : Bool) : CommandElabM Unit := do\n  let mut m \u2190 mkHeader' \"inductive\" id levelParams type isUnsafe\n  m := m ++ Format.line ++ \"number of parameters: \" ++ toString numParams\n  m := m ++ Format.line ++ \"constructors:\"\n  for ctor in ctors do\n    let cinfo \u2190 getConstInfo ctor\n    m := m ++ Format.line ++ ctor ++ \" : \" ++ cinfo.type\n  logInfo m", "start": [56, 1], "end": [64, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.printIdCore", "code": "private def printIdCore (id : Name) : CommandElabM Unit := do\n  match (\u2190 getEnv).find? id with\n  | ConstantInfo.axiomInfo { levelParams := us, type := t, isUnsafe := u, .. } => printAxiomLike \"axiom\" id us t u\n  | ConstantInfo.defnInfo  { levelParams := us, type := t, value := v, safety := s, .. } => printDefLike \"def\" id us t v s\n  | ConstantInfo.thmInfo  { levelParams := us, type := t, value := v, .. } => printDefLike \"theorem\" id us t v\n  | ConstantInfo.opaqueInfo  { levelParams := us, type := t, isUnsafe := u, .. } => printAxiomLike \"opaque\" id us t u\n  | ConstantInfo.quotInfo  { levelParams := us, type := t, .. } => printQuot id us t\n  | ConstantInfo.ctorInfo { levelParams := us, type := t, isUnsafe := u, .. } => printAxiomLike \"constructor\" id us t u\n  | ConstantInfo.recInfo { levelParams := us, type := t, isUnsafe := u, .. } => printAxiomLike \"recursor\" id us t u\n  | ConstantInfo.inductInfo { levelParams := us, numParams, type := t, ctors, isUnsafe := u, .. } =>\n    printInduct id us numParams t ctors u\n  | none => throwUnknownId id", "start": [66, 1], "end": [77, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.printId", "code": "private def printId (id : Syntax) : CommandElabM Unit := do\n  addCompletionInfo <| CompletionInfo.id id id.getId (danglingDot := false) {} none\n  let cs \u2190 resolveGlobalConstWithInfos id\n  cs.forM printIdCore", "start": [79, 1], "end": [82, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabPrint", "code": "@[builtin_command_elab \u00abprint\u00bb] def elabPrint : CommandElab\n  | `(#print%$tk $id:ident) => withRef tk <| printId id\n  | `(#print%$tk $s:str) => logInfoAt tk s.getString\n  | _                       => throwError \"invalid #print command\"", "start": [84, 1], "end": [87, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.CollectAxioms.State", "code": "structure State where\n  visited : NameSet    := {}\n  axioms  : Array Name := #[]", "start": [91, 1], "end": [93, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.CollectAxioms.M", "code": "abbrev M := ReaderT Environment $ StateM State", "start": [95, 1], "end": [95, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.CollectAxioms.collect", "code": "partial def collect (c : Name) : M Unit := do\n  let collectExpr (e : Expr) : M Unit := e.getUsedConstants.forM collect\n  let s \u2190 get\n  unless s.visited.contains c do\n    modify fun s => { s with visited := s.visited.insert c }\n    let env \u2190 read\n    match env.find? c with\n    | some (ConstantInfo.axiomInfo _)  => modify fun s => { s with axioms := s.axioms.push c }\n    | some (ConstantInfo.defnInfo v)   => collectExpr v.type *> collectExpr v.value\n    | some (ConstantInfo.thmInfo v)    => collectExpr v.type *> collectExpr v.value\n    | some (ConstantInfo.opaqueInfo v) => collectExpr v.type *> collectExpr v.value\n    | some (ConstantInfo.quotInfo _)   => pure ()\n    | some (ConstantInfo.ctorInfo v)   => collectExpr v.type\n    | some (ConstantInfo.recInfo v)    => collectExpr v.type\n    | some (ConstantInfo.inductInfo v) => collectExpr v.type *> v.ctors.forM collect\n    | none                             => pure ()", "start": [97, 1], "end": [112, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.printAxiomsOf", "code": "private def printAxiomsOf (constName : Name) : CommandElabM Unit := do\n  let env \u2190 getEnv\n  let (_, s) := ((CollectAxioms.collect constName).run env).run {}\n  if s.axioms.isEmpty then\n    logInfo m!\"'{constName}' does not depend on any axioms\"\n  else\n    logInfo m!\"'{constName}' depends on axioms: {s.axioms.toList}\"", "start": [116, 1], "end": [122, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabPrintAxioms", "code": "@[builtin_command_elab \u00abprintAxioms\u00bb] def elabPrintAxioms : CommandElab\n  | `(#print%$tk axioms $id) => withRef tk do\n    let cs \u2190 resolveGlobalConstWithInfos id\n    cs.forM printAxiomsOf\n  | _ => throwUnsupportedSyntax", "start": [124, 1], "end": [128, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Declaration.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/MutualDef.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectLevelParams.lean", "lake-packages/lean4/src/lean/Lean/Elab/Inductive.lean", "lake-packages/lean4/src/lean/Lean/Elab/DefView.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclUtil.lean", "lake-packages/lean4/src/lean/Lean/Elab/Structure.lean"], "premises": [{"full_name": "Lean.Elab.Command.ensureValidNamespace", "code": "private def ensureValidNamespace (name : Name) : MacroM Unit := do\n  match name with\n  | .str p s =>\n    if s == \"_root_\" then\n      Macro.throwError s!\"invalid namespace '{name}', '_root_' is a reserved namespace\"\n    ensureValidNamespace p\n  | .num .. => Macro.throwError s!\"invalid namespace '{name}', it must not contain numeric parts\"\n  | .anonymous => return ()", "start": [17, 1], "end": [24, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.setDeclIdName", "code": "private def setDeclIdName (declId : Syntax) (nameNew : Name) : Syntax :=\n  let (id, _) := expandDeclIdCore declId\n  assert! !(`_root_).isPrefixOf id\n  let idStx := mkIdent nameNew |>.raw.setInfo declId.getHeadInfo\n  if declId.isIdent then\n    idStx\n  else\n    declId.setArg 0 idStx", "start": [26, 1], "end": [34, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.isNamedDef", "code": "private def isNamedDef (stx : Syntax) : Bool :=\n  if !stx.isOfKind ``Lean.Parser.Command.declaration then\n    false\n  else\n    let decl := stx[1]\n    let k := decl.getKind\n    k == ``Lean.Parser.Command.abbrev ||\n    k == ``Lean.Parser.Command.def ||\n    k == ``Lean.Parser.Command.theorem ||\n    k == ``Lean.Parser.Command.opaque ||\n    k == ``Lean.Parser.Command.axiom ||\n    k == ``Lean.Parser.Command.inductive ||\n    k == ``Lean.Parser.Command.classInductive ||\n    k == ``Lean.Parser.Command.structure", "start": [36, 1], "end": [50, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.isInstanceDef", "code": "private def isInstanceDef (stx : Syntax) : Bool :=\n  stx.isOfKind ``Lean.Parser.Command.declaration &&\n  stx[1].getKind == ``Lean.Parser.Command.instance", "start": [52, 1], "end": [55, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getDefName?", "code": "private def getDefName? (stx : Syntax) : Option Name := do\n  if isNamedDef stx then\n    let (id, _) := expandDeclIdCore stx[1][1]\n    some id\n  else if isInstanceDef stx then\n    let optDeclId := stx[1][3]\n    if optDeclId.isNone then none\n    else\n      let (id, _) := expandDeclIdCore optDeclId[0]\n      some id\n  else\n    none", "start": [57, 1], "end": [69, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.setDefName", "code": "private def setDefName (stx : Syntax) (name : Name) : Syntax :=\n  if isNamedDef stx then\n    stx.setArg 1 <| stx[1].setArg 1 <| setDeclIdName stx[1][1] name\n  else if isInstanceDef stx then\n    assert! !stx[1][3].isNone\n    stx.setArg 1 <| stx[1].setArg 3 <| stx[1][3].setArg 0 <| setDeclIdName stx[1][3][0] name\n  else\n    stx", "start": [71, 1], "end": [83, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandDeclNamespace?", "code": "private def expandDeclNamespace? (stx : Syntax) : MacroM (Option (Name \u00d7 Syntax)) := do\n  let some name := getDefName? stx | return none\n  if (`_root_).isPrefixOf name then\n    ensureValidNamespace (name.replacePrefix `_root_ Name.anonymous)\n    return none\n  let scpView := extractMacroScopes name\n  match scpView.name with\n  | .str .anonymous _ => return none\n  | .str pre shortName => return some (pre, setDefName stx { scpView with name := shortName }.review)\n  | _ => return none", "start": [85, 1], "end": [98, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabAxiom", "code": "def elabAxiom (modifiers : Modifiers) (stx : Syntax) : CommandElabM Unit := do\n  let declId             := stx[1]\n  let (binders, typeStx) := expandDeclSig stx[2]\n  let scopeLevelNames \u2190 getLevelNames\n  let \u27e8_, declName, allUserLevelNames\u27e9 \u2190 expandDeclId declId modifiers\n  addDeclarationRanges declName stx\n  runTermElabM fun vars =>\n    Term.withDeclName declName <| Term.withLevelNames allUserLevelNames <| Term.elabBinders binders.getArgs fun xs => do\n      Term.applyAttributesAt declName modifiers.attrs AttributeApplicationTime.beforeElaboration\n      let type \u2190 Term.elabType typeStx\n      Term.synthesizeSyntheticMVarsNoPostponing\n      let type \u2190 instantiateMVars type\n      let type \u2190 mkForallFVars xs type\n      let type \u2190 mkForallFVars vars type (usedOnly := true)\n      let type \u2190 Term.levelMVarToParam type\n      let usedParams  := collectLevelParams {} type |>.params\n      match sortDeclLevelParams scopeLevelNames allUserLevelNames usedParams with\n      | Except.error msg      => throwErrorAt stx msg\n      | Except.ok levelParams =>\n        let type \u2190 instantiateMVars type\n        let decl := Declaration.axiomDecl {\n          name        := declName,\n          levelParams := levelParams,\n          type        := type,\n          isUnsafe    := modifiers.isUnsafe\n        }\n        trace[Elab.axiom] \"{declName} : {type}\"\n        Term.ensureNoUnassignedMVars decl\n        addDecl decl\n        withSaveInfoContext do  Term.addTermInfo' declId (\u2190 mkConstWithLevelParams declName) (isBinder := true)\n        Term.applyAttributesAt declName modifiers.attrs AttributeApplicationTime.afterTypeChecking\n        if isExtern (\u2190 getEnv) declName then\n          compileDecl decl\n        Term.applyAttributesAt declName modifiers.attrs AttributeApplicationTime.afterCompilation", "start": [100, 1], "end": [135, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.inductiveSyntaxToView", "code": "private def inductiveSyntaxToView (modifiers : Modifiers) (decl : Syntax) : CommandElabM InductiveView := do\n  checkValidInductiveModifier modifiers\n  let (binders, type?) := expandOptDeclSig decl[2]\n  let declId           := decl[1]\n  let \u27e8name, declName, levelNames\u27e9 \u2190 expandDeclId declId modifiers\n  addDeclarationRanges declName decl\n  let ctors      \u2190 decl[4].getArgs.mapM fun ctor => withRef ctor do\n    let mut ctorModifiers \u2190 elabModifiers ctor[2]\n    if let some leadingDocComment := ctor[0].getOptional? then\n      if ctorModifiers.docString?.isSome then\n        logErrorAt leadingDocComment \"duplicate doc string\"\n      ctorModifiers := { ctorModifiers with docString? := TSyntax.getDocString \u27e8leadingDocComment\u27e9 }\n    if ctorModifiers.isPrivate && modifiers.isPrivate then\n      throwError \"invalid 'private' constructor in a 'private' inductive datatype\"\n    if ctorModifiers.isProtected && modifiers.isPrivate then\n      throwError \"invalid 'protected' constructor in a 'private' inductive datatype\"\n    checkValidCtorModifier ctorModifiers\n    let ctorName := ctor.getIdAt 3\n    let ctorName := declName ++ ctorName\n    let ctorName \u2190 withRef ctor[3] <| applyVisibility ctorModifiers.visibility ctorName\n    let (binders, type?) := expandOptDeclSig ctor[4]\n    addDocString' ctorName ctorModifiers.docString?\n    addAuxDeclarationRanges ctorName ctor ctor[3]\n    return { ref := ctor, modifiers := ctorModifiers, declName := ctorName, binders := binders, type? := type? : CtorView }\n  let computedFields \u2190 (decl[5].getOptional?.map (\u00b7[1].getArgs) |>.getD #[]).mapM fun cf => withRef cf do\n    return { ref := cf, modifiers := cf[0], fieldId := cf[1].getId, type := \u27e8cf[3]\u27e9, matchAlts := \u27e8cf[4]\u27e9 }\n  let classes \u2190 getOptDerivingClasses decl[6]\n  return {\n    ref             := decl\n    shortDeclName   := name\n    derivingClasses := classes\n    declId, modifiers, declName, levelNames\n    binders, type?, ctors\n    computedFields\n  }", "start": [141, 1], "end": [176, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.classInductiveSyntaxToView", "code": "private def classInductiveSyntaxToView (modifiers : Modifiers) (decl : Syntax) : CommandElabM InductiveView :=\n  inductiveSyntaxToView modifiers decl", "start": [178, 1], "end": [179, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabInductive", "code": "def elabInductive (modifiers : Modifiers) (stx : Syntax) : CommandElabM Unit := do\n  let v \u2190 inductiveSyntaxToView modifiers stx\n  elabInductiveViews #[v]", "start": [181, 1], "end": [183, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabClassInductive", "code": "def elabClassInductive (modifiers : Modifiers) (stx : Syntax) : CommandElabM Unit := do\n  let modifiers := modifiers.addAttribute { name := `class }\n  let v \u2190 classInductiveSyntaxToView modifiers stx\n  elabInductiveViews #[v]", "start": [185, 1], "end": [188, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getTerminationHints", "code": "def getTerminationHints (stx : Syntax) : TerminationHints :=\n  let decl := stx[1]\n  let k := decl.getKind\n  if k == ``Parser.Command.def || k == ``Parser.Command.abbrev || k == ``Parser.Command.theorem || k == ``Parser.Command.instance then\n    let args := decl.getArgs\n    { terminationBy? := args[args.size - 2]!.getOptional?, decreasingBy? := args[args.size - 1]!.getOptional? }\n  else\n    {}", "start": [190, 1], "end": [197, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabDeclaration", "code": "@[builtin_command_elab declaration]\ndef elabDeclaration : CommandElab := fun stx => do\n  match (\u2190 liftMacroM <| expandDeclNamespace? stx) with\n  | some (ns, newStx) => do\n    let ns := mkIdentFrom stx ns\n    let newStx \u2190 `(namespace $ns $(\u27e8newStx\u27e9) end $ns)\n    withMacroExpansion stx newStx <| elabCommand newStx\n  | none => do\n    let decl     := stx[1]\n    let declKind := decl.getKind\n    if declKind == ``Lean.Parser.Command.\u00abaxiom\u00bb then\n      let modifiers \u2190 elabModifiers stx[0]\n      elabAxiom modifiers decl\n    else if declKind == ``Lean.Parser.Command.\u00abinductive\u00bb then\n      let modifiers \u2190 elabModifiers stx[0]\n      elabInductive modifiers decl\n    else if declKind == ``Lean.Parser.Command.classInductive then\n      let modifiers \u2190 elabModifiers stx[0]\n      elabClassInductive modifiers decl\n    else if declKind == ``Lean.Parser.Command.\u00abstructure\u00bb then\n      let modifiers \u2190 elabModifiers stx[0]\n      elabStructure modifiers decl\n    else if isDefLike decl then\n      elabMutualDef #[stx] (getTerminationHints stx)\n    else\n      throwError \"unexpected declaration\"", "start": [199, 1], "end": [224, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.isMutualInductive", "code": "private def isMutualInductive (stx : Syntax) : Bool :=\n  stx[1].getArgs.all fun elem =>\n    let decl     := elem[1]\n    let declKind := decl.getKind\n    declKind == `Lean.Parser.Command.inductive", "start": [226, 1], "end": [231, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabMutualInductive", "code": "private def elabMutualInductive (elems : Array Syntax) : CommandElabM Unit := do\n  let views \u2190 elems.mapM fun stx => do\n     let modifiers \u2190 elabModifiers stx[0]\n     inductiveSyntaxToView modifiers stx[1]\n  elabInductiveViews views", "start": [233, 1], "end": [237, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.isMutualDef", "code": "private def isMutualDef (stx : Syntax) : Bool :=\n  stx[1].getArgs.all fun elem =>\n    let decl := elem[1]\n    isDefLike decl", "start": [239, 1], "end": [243, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.isMutualPreambleCommand", "code": "private def isMutualPreambleCommand (stx : Syntax) : Bool :=\n  let k := stx.getKind\n  k == ``Lean.Parser.Command.variable ||\n  k == ``Lean.Parser.Command.universe ||\n  k == ``Lean.Parser.Command.check ||\n  k == ``Lean.Parser.Command.set_option ||\n  k == ``Lean.Parser.Command.open", "start": [245, 1], "end": [251, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.splitMutualPreamble", "code": "private partial def splitMutualPreamble (elems : Array Syntax) : Option (Array Syntax \u00d7 Array Syntax) :=\n  let rec loop (i : Nat) : Option (Array Syntax \u00d7 Array Syntax) :=\n    if h : i < elems.size then\n      let elem := elems.get \u27e8i, h\u27e9\n      if isMutualPreambleCommand elem then\n        loop (i+1)\n      else if i == 0 then\n        none else\n        some (elems[0:i], elems[i:elems.size])\n    else\n      none loop 0", "start": [253, 1], "end": [265, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.findCommonPrefix", "code": "def findCommonPrefix (ns : List Name) : Name :=\n  match ns with\n  | [] => .anonymous\n  | n :: ns => go n ns\nwhere\n  go (n : Name) (ns : List Name) : Name :=\n    match n with\n    | .anonymous => .anonymous\n    | _ => match ns with\n      | [] => n\n      | n' :: ns => go (findCommon n.components n'.components) ns\n  findCommon (as bs : List Name) : Name :=\n    match as, bs with\n    | a :: as, b :: bs => if a == b then a ++ findCommon as bs else .anonymous\n    | _, _ => .anonymous", "start": [267, 1], "end": [289, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandMutualNamespace", "code": "@[builtin_macro Lean.Parser.Command.mutual]\ndef expandMutualNamespace : Macro := fun stx => do\n  let mut nss := #[]\n  for elem in stx[1].getArgs do\n    match (\u2190 expandDeclNamespace? elem) with\n    | none        => Macro.throwUnsupported\n    | some (n, _) => nss := nss.push n\n  let common := findCommonPrefix nss.toList\n  if common.isAnonymous then Macro.throwUnsupported\n  let elemsNew \u2190 stx[1].getArgs.mapM fun elem => do\n    let some name := getDefName? elem | unreachable!\n    let view := extractMacroScopes name\n    let nameNew := { view with name := view.name.replacePrefix common .anonymous }.review\n    return setDefName elem nameNew\n  let ns := mkIdentFrom stx common\n  let stxNew := stx.setArg 1 (mkNullNode elemsNew)\n  `(namespace $ns $(\u27e8stxNew\u27e9) end $ns)", "start": [292, 1], "end": [308, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandMutualElement", "code": "@[builtin_macro Lean.Parser.Command.mutual]\ndef expandMutualElement : Macro := fun stx => do\n  let mut elemsNew := #[]\n  let mut modified := false\n  for elem in stx[1].getArgs do\n    match (\u2190 expandMacro? elem) with\n    | some elemNew => elemsNew := elemsNew.push elemNew; modified := true\n    | none         => elemsNew := elemsNew.push elem\n  if modified then\n    return stx.setArg 1 (mkNullNode elemsNew)\n  else\n    Macro.throwUnsupported", "start": [310, 1], "end": [321, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandMutualPreamble", "code": "@[builtin_macro Lean.Parser.Command.mutual]\ndef expandMutualPreamble : Macro := fun stx =>\n  match splitMutualPreamble stx[1].getArgs with\n  | none => Macro.throwUnsupported\n  | some (preamble, rest) => do\n    let secCmd    \u2190 `(section)\n    let newMutual := stx.setArg 1 (mkNullNode rest)\n    let endCmd    \u2190 `(end)\n    return mkNullNode (#[secCmd] ++ preamble ++ #[newMutual] ++ #[endCmd])", "start": [323, 1], "end": [331, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabMutual", "code": "@[builtin_command_elab \u00abmutual\u00bb]\ndef elabMutual : CommandElab := fun stx => do\n  let hints := { terminationBy? := stx[3].getOptional?, decreasingBy? := stx[4].getOptional? }\n  if isMutualInductive stx then\n    if let some bad := hints.terminationBy? then\n      throwErrorAt bad \"invalid 'termination_by' in mutually inductive datatype declaration\"\n    if let some bad := hints.decreasingBy? then\n      throwErrorAt bad \"invalid 'decreasing_by' in mutually inductive datatype declaration\"\n    elabMutualInductive stx[1].getArgs\n  else if isMutualDef stx then\n    for arg in stx[1].getArgs do\n      let argHints := getTerminationHints arg\n      if let some bad := argHints.terminationBy? then\n        throwErrorAt bad \"invalid 'termination_by' in 'mutual' block, it must be used after the 'end' keyword\"\n      if let some bad := argHints.decreasingBy? then\n        throwErrorAt bad \"invalid 'decreasing_by' in 'mutual' block, it must be used after the 'end' keyword\"\n    elabMutualDef stx[1].getArgs hints\n  else\n    throwError \"invalid mutual block\"", "start": [333, 1], "end": [351, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabAttr", "code": "@[builtin_command_elab \u00abattribute\u00bb] def elabAttr : CommandElab := fun stx => do\n  let mut attrInsts := #[]\n  let mut toErase := #[]\n  for attrKindStx in stx[2].getSepArgs do\n    if attrKindStx.getKind == ``Lean.Parser.Command.eraseAttr then\n      let attrName := attrKindStx[1].getId.eraseMacroScopes\n      if isAttribute (\u2190 getEnv) attrName then\n        toErase := toErase.push attrName\n      else\n        logErrorAt attrKindStx m!\"unknown attribute [{attrName}]\"\n    else\n      attrInsts := attrInsts.push attrKindStx\n  let attrs \u2190 elabAttrs attrInsts\n  let idents := stx[4].getArgs\n  for ident in idents do withRef ident <| liftTermElabM do\n    let declName \u2190 resolveGlobalConstNoOverloadWithInfo ident\n    Term.applyAttributes declName attrs\n    for attrName in toErase do\n      Attribute.erase declName attrName", "start": [354, 1], "end": [372, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandInitialize", "code": "@[builtin_macro Lean.Parser.Command.\u00abinitialize\u00bb] def expandInitialize : Macro\n  | stx@`($declModifiers:declModifiers $kw:initializeKeyword $[$id? : $type? \u2190]? $doSeq) => do\n    let attrId := mkIdentFrom stx <| if kw.raw[0].isToken \"initialize\" then `init else `builtin_init\n    if let (some id, some type) := (id?, type?) then\n      let `(Parser.Command.declModifiersT| $[$doc?:docComment]? $[@[$attrs?,*]]? $(vis?)? $[unsafe%$unsafe?]?) := stx[0]\n        | Macro.throwErrorAt declModifiers \"invalid initialization command, unexpected modifiers\"\n      `($[unsafe%$unsafe?]? def initFn : IO $type := with_decl_name% ?$id do $doSeq\n        $[$doc?:docComment]? @[$attrId:ident initFn, $(attrs?.getD \u2205),*] $(vis?)? opaque $id : $type)\n    else\n      let `(Parser.Command.declModifiersT| $[$doc?:docComment]? ) := declModifiers\n        | Macro.throwErrorAt declModifiers \"invalid initialization command, unexpected modifiers\"\n      `($[$doc?:docComment]? @[$attrId:ident] def initFn : IO Unit := do $doSeq)\n  | _ => Macro.throwUnsupported", "start": [374, 1], "end": [386, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.initFn", "code": "$[unsafe%$unsafe?]? def initFn : IO $type := with_decl_name% ?$id do $doSeq", "start": [380, 9], "end": [380, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.initFn", "code": "$[$doc?:docComment]? @[$attrId:ident] def initFn : IO Unit := do $doSeq", "start": [385, 9], "end": [385, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Do.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Quotation/Util.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Lean/Parser/Do.lean", "lake-packages/lean4/src/lean/Lean/Elab/PatternVar.lean", "lake-packages/lean4/src/lean/Lean/Elab/BindersUtil.lean"], "premises": [{"full_name": "Lean.Elab.Term.getDoSeqElems", "code": "private def getDoSeqElems (doSeq : Syntax) : List Syntax :=\n  if doSeq.getKind == ``Parser.Term.doSeqBracketed then\n    doSeq[1].getArgs.toList.map fun arg => arg[0]\n  else if doSeq.getKind == ``Parser.Term.doSeqIndent then\n    doSeq[0].getArgs.toList.map fun arg => arg[0]\n  else\n    []", "start": [20, 1], "end": [26, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getDoSeq", "code": "private def getDoSeq (doStx : Syntax) : Syntax :=\n  doStx[1]", "start": [28, 1], "end": [29, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLiftMethod", "code": "@[builtin_term_elab liftMethod] def elabLiftMethod : TermElab := fun stx _ =>\n  throwErrorAt stx \"invalid use of `(<- ...)`, must be nested inside a 'do' expression\"", "start": [31, 1], "end": [32, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.liftMethodDelimiter", "code": "private def liftMethodDelimiter (k : SyntaxNodeKind) : Bool :=\n  k == ``Parser.Term.do ||\n  k == ``Parser.Term.doSeqIndent ||\n  k == ``Parser.Term.doSeqBracketed ||\n  k == ``Parser.Term.termReturn ||\n  k == ``Parser.Term.termUnless ||\n  k == ``Parser.Term.termTry ||\n  k == ``Parser.Term.termFor", "start": [34, 1], "end": [42, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.letDeclArgHasBinders", "code": "private def letDeclArgHasBinders (letDeclArg : Syntax) : Bool :=\n  let k := letDeclArg.getKind\n  if k == ``Parser.Term.letPatDecl then\n    false\n  else if k == ``Parser.Term.letEqnsDecl then\n    true\n  else if k == ``Parser.Term.letIdDecl then\n    let binders := letDeclArg[1]\n    binders.getNumArgs > 0\n  else\n    false", "start": [44, 1], "end": [56, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.letDeclHasBinders", "code": "private def letDeclHasBinders (letDecl : Syntax) : Bool :=\n  letDeclArgHasBinders letDecl[0]", "start": [58, 1], "end": [60, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.liftMethodForbiddenBinder", "code": "private def liftMethodForbiddenBinder (stx : Syntax) : Bool :=\n  let k := stx.getKind\n  if k == ``Parser.Term.fun || k == ``Parser.Term.matchAlts ||\n     k == ``Parser.Term.doLetRec || k == ``Parser.Term.letrec  then\n     true\n  else if k == ``Parser.Term.let then\n    letDeclHasBinders stx[1]\n  else if k == ``Parser.Term.doLet then\n    letDeclHasBinders stx[2]\n  else if k == ``Parser.Term.doLetArrow then\n    letDeclArgHasBinders stx[2]\n  else\n    false", "start": [62, 1], "end": [77, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.hasLiftMethod", "code": "private partial def hasLiftMethod : Syntax \u2192 Bool\n  | Syntax.node _ k args =>\n    if liftMethodDelimiter k then false\n    else if k == ``Parser.Term.liftMethod then true\n    else args.any hasLiftMethod\n  | _ => false", "start": [79, 1], "end": [86, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ExtractMonadResult", "code": "structure ExtractMonadResult where\n  m            : Expr\n  returnType   : Expr\n  expectedType : Expr", "start": [88, 1], "end": [91, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkUnknownMonadResult", "code": "private def mkUnknownMonadResult : MetaM ExtractMonadResult := do\n  let u \u2190 mkFreshLevelMVar\n  let v \u2190 mkFreshLevelMVar\n  let m \u2190 mkFreshExprMVar (\u2190 mkArrow (mkSort (mkLevelSucc u)) (mkSort (mkLevelSucc v)))\n  let returnType \u2190 mkFreshExprMVar (mkSort (mkLevelSucc u))\n  return { m, returnType, expectedType := mkApp m returnType }", "start": [93, 1], "end": [98, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.extractBind", "code": "private partial def extractBind (expectedType? : Option Expr) : TermElabM ExtractMonadResult := do\n  let some expectedType := expectedType? | mkUnknownMonadResult\n  let extractStep? (type : Expr) : MetaM (Option ExtractMonadResult) := do\n    let .app m returnType := type | return none\n    try\n      let bindInstType \u2190 mkAppM ``Bind #[m]\n      discard <| Meta.synthInstance bindInstType\n      return some { m, returnType, expectedType }\n    catch _ =>\n      return none\n  let rec extract? (type : Expr) : MetaM (Option ExtractMonadResult) := do\n    match (\u2190 extractStep? type) with\n    | some r => return r\n    | none =>\n      let typeNew \u2190 whnfCore type\n      if typeNew != type then\n        extract? typeNew\n      else\n        if typeNew.getAppFn.isMVar then\n          mkUnknownMonadResult\n        else match (\u2190 unfoldDefinition? typeNew) with\n          | some typeNew => extract? typeNew\n          | none => return none\n  match (\u2190 extract? expectedType) with\n  | some r => return r\n  | none   => throwError \"invalid `do` notation, expected type is not a monad application{indentExpr expectedType}\\nYou can use the `do` notation in pure code by writing `Id.run do` instead of `do`, where `Id` is the identity monad.\"", "start": [100, 1], "end": [125, 234], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.Var", "code": "abbrev Var := Syntax", "start": [129, 1], "end": [129, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.Alt", "code": "structure Alt (\u03c3 : Type) where\n  ref : Syntax\n  vars : Array Var\n  patterns : Syntax\n  rhs : \u03c3\n  deriving Inhabited", "start": [131, 1], "end": [137, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.Code", "code": "inductive Code where\n  | decl         (xs : Array Var) (doElem : Syntax) (k : Code)\n  | reassign     (xs : Array Var) (doElem : Syntax) (k : Code)\n  \n  | joinpoint    (name : Name) (params : Array (Var \u00d7 Bool)) (body : Code) (k : Code)\n  | seq          (action : Syntax) (k : Code)\n  | action       (action : Syntax)\n  | break        (ref : Syntax)\n  | continue     (ref : Syntax)\n  | return       (ref : Syntax) (val : Syntax)\n  \n  | ite          (ref : Syntax) (h? : Option Var) (optIdent : Syntax) (cond : Syntax) (thenBranch : Code) (elseBranch : Code)\n  | match        (ref : Syntax) (gen : Syntax) (discrs : Syntax) (optMotive : Syntax) (alts : Array (Alt Code))\n  | jmp          (ref : Syntax) (jpName : Name) (args : Array Syntax)\n  deriving Inhabited", "start": [139, 1], "end": [201, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.Code.getRef?", "code": "def Code.getRef? : Code \u2192 Option Syntax\n  | .decl _ doElem _     => doElem\n  | .reassign _ doElem _ => doElem\n  | .joinpoint ..        => none\n  | .seq a _             => a\n  | .action a            => a\n  | .break ref           => ref\n  | .continue ref        => ref\n  | .return ref _        => ref\n  | .ite ref ..          => ref\n  | .match ref ..        => ref\n  | .jmp ref ..          => ref", "start": [203, 1], "end": [214, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.VarSet", "code": "abbrev VarSet := RBMap Name Syntax Name.cmp", "start": [216, 1], "end": [216, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.CodeBlock", "code": "structure CodeBlock where\n  code  : Code\n  uvars : VarSet := {}", "start": [218, 1], "end": [221, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.varSetToArray", "code": "private def varSetToArray (s : VarSet) : Array Var :=\n  s.fold (fun xs _ x => xs.push x) #[]", "start": [223, 1], "end": [224, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.varsToMessageData", "code": "private def varsToMessageData (vars : Array Var) : MessageData :=\n  MessageData.joinSep (vars.toList.map fun n => MessageData.ofName (n.getId.simpMacroScopes)) \" \"", "start": [226, 1], "end": [227, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.CodeBlocl.toMessageData", "code": "partial def CodeBlocl.toMessageData (codeBlock : CodeBlock) : MessageData :=\n  let us := MessageData.ofList <| (varSetToArray codeBlock.uvars).toList.map MessageData.ofSyntax\n  let rec loop : Code \u2192 MessageData\n    | .decl xs _ k           => m!\"let {varsToMessageData xs} := ...\\n{loop k}\"\n    | .reassign xs _ k       => m!\"{varsToMessageData xs} := ...\\n{loop k}\"\n    | .joinpoint n ps body k => m!\"let {n.simpMacroScopes} {varsToMessageData (ps.map Prod.fst)} := {indentD (loop body)}\\n{loop k}\"\n    | .seq e k               => m!\"{e}\\n{loop k}\"\n    | .action e              => e\n    | .ite _ _ _ c t e       => m!\"if {c} then {indentD (loop t)}\\nelse{loop e}\"\n    | .jmp _ j xs            => m!\"jmp {j.simpMacroScopes} {xs.toList}\"\n    | .break _               => m!\"break {us}\"\n    | .continue _            => m!\"continue {us}\"\n    | .return _ v            => m!\"return {v} {us}\"\n    | .match _ _ ds _ alts   =>\n      m!\"match {ds} with\"\n      ++ alts.foldl (init := m!\"\") fun acc alt => acc ++ m!\"\\n| {alt.patterns} => {loop alt.rhs}\"\n  loop codeBlock.code", "start": [229, 1], "end": [245, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.hasExitPointPred", "code": "partial def hasExitPointPred (c : Code) (p : Code \u2192 Bool) : Bool :=\n  let rec loop : Code \u2192 Bool\n    | .decl _ _ k         => loop k\n    | .reassign _ _ k     => loop k\n    | .joinpoint _ _ b k  => loop b || loop k\n    | .seq _ k            => loop k\n    | .ite _ _ _ _ t e    => loop t || loop e\n    | .match _ _ _ _ alts => alts.any (loop \u00b7.rhs)\n    | .jmp ..             => false\n    | c                   => p c\n  loop c", "start": [247, 1], "end": [258, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.hasExitPoint", "code": "def hasExitPoint (c : Code) : Bool :=\n  hasExitPointPred c fun _ => true", "start": [260, 1], "end": [261, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.hasReturn", "code": "def hasReturn (c : Code) : Bool :=\n  hasExitPointPred c fun\n    | .return .. => true\n    | _ => false", "start": [263, 1], "end": [266, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.hasTerminalAction", "code": "def hasTerminalAction (c : Code) : Bool :=\n  hasExitPointPred c fun\n    | .action _ => true\n    | _ => false", "start": [268, 1], "end": [271, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.hasBreakContinue", "code": "def hasBreakContinue (c : Code) : Bool :=\n  hasExitPointPred c fun\n    | .break _    => true\n    | .continue _ => true\n    | _ => false", "start": [273, 1], "end": [277, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.hasBreakContinueReturn", "code": "def hasBreakContinueReturn (c : Code) : Bool :=\n  hasExitPointPred c fun\n    | .break _    => true\n    | .continue _ => true\n    | .return _ _ => true\n    | _ => false", "start": [279, 1], "end": [284, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkAuxDeclFor", "code": "def mkAuxDeclFor {m} [Monad m] [MonadQuotation m] (e : Syntax) (mkCont : Syntax \u2192 m Code) : m Code := withRef e <| withFreshMacroScope do\n  let y \u2190 `(y)\n  let doElem \u2190 `(doElem| let y \u2190 $e:term)\n  let y \u2190 `(ensure_expected_type% \"type mismatch, result value\" $y)\n  let k \u2190 mkCont y\n  return .decl #[y] doElem k", "start": [286, 1], "end": [292, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.convertTerminalActionIntoJmp", "code": "partial def convertTerminalActionIntoJmp (code : Code) (jp : Name) (xs : Array Var) : MacroM Code :=\n  let rec loop : Code \u2192 MacroM Code\n    | .decl xs stx k         => return .decl xs stx (\u2190 loop k)\n    | .reassign xs stx k     => return .reassign xs stx (\u2190 loop k)\n    | .joinpoint n ps b k    => return .joinpoint n ps (\u2190 loop b) (\u2190 loop k)\n    | .seq e k               => return .seq e (\u2190 loop k)\n    | .ite ref x? h c t e    => return .ite ref x? h c (\u2190 loop t) (\u2190 loop e)\n    | .match ref g ds t alts => return .match ref g ds t (\u2190 alts.mapM fun alt => do pure { alt with rhs := (\u2190 loop alt.rhs) })\n    | .action e              => mkAuxDeclFor e fun y =>\n      let ref := e\n      let jmpArgs := xs.push y\n      return Code.jmp ref jp jmpArgs\n    | c                            => return c\n  loop code", "start": [294, 1], "end": [309, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.JPDecl", "code": "structure JPDecl where\n  name : Name\n  params : Array (Var \u00d7 Bool)\n  body : Code", "start": [311, 1], "end": [314, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.attachJP", "code": "def attachJP (jpDecl : JPDecl) (k : Code) : Code :=\n  Code.joinpoint jpDecl.name jpDecl.params jpDecl.body k", "start": [316, 1], "end": [317, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.attachJPs", "code": "def attachJPs (jpDecls : Array JPDecl) (k : Code) : Code :=\n  jpDecls.foldr attachJP k", "start": [319, 1], "end": [320, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkFreshJP", "code": "def mkFreshJP (ps : Array (Var \u00d7 Bool)) (body : Code) : TermElabM JPDecl := do\n  let ps \u2190 if ps.isEmpty then\n    let y \u2190 `(y)\n    pure #[(y.raw, false)]\n  else\n    pure ps\n  let name \u2190 mkFreshUserName `__do_jp\n  pure { name := name, params := ps, body := body }", "start": [322, 1], "end": [332, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.addFreshJP", "code": "def addFreshJP (ps : Array (Var \u00d7 Bool)) (body : Code) : StateRefT (Array JPDecl) TermElabM Name := do\n  let jp \u2190 mkFreshJP ps body\n  modify fun (jps : Array JPDecl) => jps.push jp\n  pure jp.name", "start": [334, 1], "end": [337, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.insertVars", "code": "def insertVars (rs : VarSet) (xs : Array Var) : VarSet :=\n  xs.foldl (fun rs x => rs.insert x.getId x) rs", "start": [339, 1], "end": [340, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.eraseVars", "code": "def eraseVars (rs : VarSet) (xs : Array Var) : VarSet :=\n  xs.foldl (\u00b7.erase \u00b7.getId) rs", "start": [342, 1], "end": [343, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.eraseOptVar", "code": "def eraseOptVar (rs : VarSet) (x? : Option Var) : VarSet :=\n  match x? with\n  | none   => rs\n  | some x => rs.insert x.getId x", "start": [345, 1], "end": [348, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkSimpleJmp", "code": "def mkSimpleJmp (ref : Syntax) (rs : VarSet) (c : Code) : StateRefT (Array JPDecl) TermElabM Code := do\n  let xs := varSetToArray rs\n  let jp \u2190 addFreshJP (xs.map fun x => (x, true)) c\n  if xs.isEmpty then\n    let unit \u2190 ``(Unit.unit)\n    return Code.jmp ref jp #[unit]\n  else\n    return Code.jmp ref jp xs", "start": [350, 1], "end": [358, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkJmp", "code": "def mkJmp (ref : Syntax) (rs : VarSet) (val : Syntax) (mkJPBody : Syntax \u2192 MacroM Code) : StateRefT (Array JPDecl) TermElabM Code := do\n  let xs := varSetToArray rs\n  let args := xs.push val\n  let yFresh \u2190 withRef ref `(y)\n  let ps := xs.map fun x => (x, true)\n  let ps := ps.push (yFresh, false)\n  let jpBody \u2190 liftMacroM <| mkJPBody yFresh\n  let jp \u2190 addFreshJP ps jpBody\n  return Code.jmp ref jp args", "start": [360, 1], "end": [371, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.pullExitPointsAux", "code": "partial def pullExitPointsAux (rs : VarSet) (c : Code) : StateRefT (Array JPDecl) TermElabM Code :=\n  match c with\n  | .decl xs stx k         => return .decl xs stx (\u2190 pullExitPointsAux (eraseVars rs xs) k)\n  | .reassign xs stx k     => return .reassign xs stx (\u2190 pullExitPointsAux (insertVars rs xs) k)\n  | .joinpoint j ps b k    => return .joinpoint j ps (\u2190 pullExitPointsAux rs b) (\u2190 pullExitPointsAux rs k)\n  | .seq e k               => return .seq e (\u2190 pullExitPointsAux rs k)\n  | .ite ref x? o c t e    => return .ite ref x? o c (\u2190 pullExitPointsAux (eraseOptVar rs x?) t) (\u2190 pullExitPointsAux (eraseOptVar rs x?) e)\n  | .match ref g ds t alts => return .match ref g ds t (\u2190 alts.mapM fun alt => do pure { alt with rhs := (\u2190 pullExitPointsAux (eraseVars rs alt.vars) alt.rhs) })\n  | .jmp ..                => return  c\n  | .break ref             => mkSimpleJmp ref rs (.break ref)\n  | .continue ref          => mkSimpleJmp ref rs (.continue ref)\n  | .return ref val        => mkJmp ref rs val (fun y => return .return ref y)\n  | .action e              =>\n    mkAuxDeclFor e fun y =>\n      let ref := e\n      mkJmp ref rs y (fun yFresh => return .action (\u2190 ``(Pure.pure $yFresh)))", "start": [373, 1], "end": [390, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.pullExitPoints", "code": "def pullExitPoints (c : Code) : TermElabM Code := do\n  if hasExitPoint c then\n    let (c, jpDecls) \u2190 (pullExitPointsAux {} c).run #[]\n    return attachJPs jpDecls c\n  else\n    return c", "start": [392, 1], "end": [446, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.extendUpdatedVarsAux", "code": "partial def extendUpdatedVarsAux (c : Code) (ws : VarSet) : TermElabM Code :=\n  let rec update (c : Code) : TermElabM Code := do\n    match c with\n    | .joinpoint j ps b k    => return .joinpoint j ps (\u2190 update b) (\u2190 update k)\n    | .seq e k               => return .seq e (\u2190 update k)\n    | .match ref g ds t alts =>\n      if alts.any fun alt => alt.vars.any fun x => ws.contains x.getId then\n        pullExitPoints c\n      else\n        return .match ref g ds t (\u2190 alts.mapM fun alt => do pure { alt with rhs := (\u2190 update alt.rhs) })\n    | .ite ref none o c t e => return .ite ref none o c (\u2190 update t) (\u2190 update e)\n    | .ite ref (some h) o cond t e =>\n      if ws.contains h.getId then\n        pullExitPoints c\n      else\n        return Code.ite ref (some h) o cond (\u2190 update t) (\u2190 update e)\n    | .reassign xs stx k => return .reassign xs stx (\u2190 update k)\n    | .decl xs stx k => do\n      if xs.any fun x => ws.contains x.getId then\n        pullExitPoints c\n      else\n        return .decl xs stx (\u2190 update k)\n    | c => return  c\n  update c", "start": [448, 1], "end": [474, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.extendUpdatedVars", "code": "partial def extendUpdatedVars (c : CodeBlock) (ws : VarSet) : TermElabM CodeBlock := do\n  if ws.any fun x _ => !c.uvars.contains x then\n    pure { code := (\u2190 extendUpdatedVarsAux c.code ws), uvars := ws }\n  else\n    pure { c with uvars := ws }", "start": [476, 1], "end": [486, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.union", "code": "private def union (s\u2081 s\u2082 : VarSet) : VarSet :=\n  s\u2081.fold (\u00b7.insert \u00b7) s\u2082", "start": [488, 1], "end": [489, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.homogenize", "code": "def homogenize (c\u2081 c\u2082 : CodeBlock) : TermElabM (CodeBlock \u00d7 CodeBlock) := do\n  let ws := union c\u2081.uvars c\u2082.uvars\n  let c\u2081 \u2190 extendUpdatedVars c\u2081 ws\n  let c\u2082 \u2190 extendUpdatedVars c\u2082 ws\n  pure (c\u2081, c\u2082)", "start": [491, 1], "end": [500, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkVarDeclCore", "code": "def mkVarDeclCore (xs : Array Var) (stx : Syntax) (c : CodeBlock) : CodeBlock := {\n  code := Code.decl xs stx c.code,\n  uvars := eraseVars c.uvars xs\n}", "start": [502, 1], "end": [512, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkReassignCore", "code": "def mkReassignCore (xs : Array Var) (stx : Syntax) (c : CodeBlock) : TermElabM CodeBlock := do\n  let us := c.uvars\n  let ws := insertVars us xs\n  let code \u2190 if xs.any fun x => !us.contains x.getId then extendUpdatedVarsAux c.code ws else pure c.code\n  pure { code := .reassign xs stx code, uvars := ws }", "start": [514, 1], "end": [526, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkSeq", "code": "def mkSeq (action : Syntax) (c : CodeBlock) : CodeBlock :=\n  { c with code := .seq action c.code }", "start": [528, 1], "end": [529, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkTerminalAction", "code": "def mkTerminalAction (action : Syntax) : CodeBlock :=\n  { code := .action action }", "start": [531, 1], "end": [532, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkReturn", "code": "def mkReturn (ref : Syntax) (val : Syntax) : CodeBlock :=\n  { code := .return ref val }", "start": [534, 1], "end": [535, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkBreak", "code": "def mkBreak (ref : Syntax) : CodeBlock :=\n  { code := .break ref }", "start": [537, 1], "end": [538, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkContinue", "code": "def mkContinue (ref : Syntax) : CodeBlock :=\n  { code := .continue ref }", "start": [540, 1], "end": [541, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkIte", "code": "def mkIte (ref : Syntax) (optIdent : Syntax) (cond : Syntax) (thenBranch : CodeBlock) (elseBranch : CodeBlock) : TermElabM CodeBlock := do\n  let x? := optIdent.getOptional?\n  let (thenBranch, elseBranch) \u2190 homogenize thenBranch elseBranch\n  return {\n    code  := .ite ref x? optIdent cond thenBranch.code elseBranch.code,\n    uvars := thenBranch.uvars,\n  }", "start": [543, 1], "end": [549, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkUnit", "code": "private def mkUnit : MacroM Syntax :=\n  ``((\u27e8\u27e9 : PUnit))", "start": [551, 1], "end": [552, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkPureUnit", "code": "private def mkPureUnit : MacroM Syntax :=\n  ``(pure PUnit.unit)", "start": [554, 1], "end": [555, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkPureUnitAction", "code": "def mkPureUnitAction : MacroM CodeBlock := do\n  return mkTerminalAction (\u2190 mkPureUnit)", "start": [557, 1], "end": [558, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkUnless", "code": "def mkUnless (cond : Syntax) (c : CodeBlock) : MacroM CodeBlock := do\n  let thenBranch \u2190 mkPureUnitAction\n  return { c with code := .ite (\u2190 getRef) none mkNullNode cond thenBranch.code c.code }", "start": [560, 1], "end": [562, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkMatch", "code": "def mkMatch (ref : Syntax) (genParam : Syntax) (discrs : Syntax) (optMotive : Syntax) (alts : Array (Alt CodeBlock)) : TermElabM CodeBlock := do\n  let ws := alts.foldl (union \u00b7 \u00b7.rhs.uvars) {}\n  let alts \u2190 alts.mapM fun alt => do\n    let rhs \u2190 extendUpdatedVars alt.rhs ws\n    return { ref := alt.ref, vars := alt.vars, patterns := alt.patterns, rhs := rhs.code : Alt Code }\n  return { code := .match ref genParam discrs optMotive alts, uvars := ws }", "start": [564, 1], "end": [570, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.concat", "code": "def concat (terminal : CodeBlock) (kRef : Syntax) (y? : Option Var) (k : CodeBlock) : TermElabM CodeBlock := do\n  unless hasTerminalAction terminal.code do\n    throwErrorAt kRef \"`do` element is unreachable\"\n  let (terminal, k) \u2190 homogenize terminal k\n  let xs := varSetToArray k.uvars\n  let y \u2190 match y? with | some y => pure y | none => `(y)\n  let ps := xs.map fun x => (x, true)\n  let ps := ps.push (y, false)\n  let jpDecl \u2190 mkFreshJP ps k.code\n  let jp := jpDecl.name\n  let terminal \u2190 liftMacroM <| convertTerminalActionIntoJmp terminal.code jp xs\n  return { code  := attachJP jpDecl terminal, uvars := k.uvars }", "start": [572, 1], "end": [585, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getLetIdDeclVars", "code": "def getLetIdDeclVars (letIdDecl : Syntax) : Array Var :=\n  if letIdDecl[0].isIdent then\n    #[letIdDecl[0]]\n  else\n    #[]", "start": [587, 1], "end": [591, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getPatternVarsEx", "code": "def getPatternVarsEx (pattern : Syntax) : TermElabM (Array Var) :=\n  getPatternVars pattern <|>\n  Quotation.getPatternVars pattern", "start": [594, 1], "end": [596, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getPatternsVarsEx", "code": "def getPatternsVarsEx (patterns : Array Syntax) : TermElabM (Array Var) :=\n  getPatternsVars patterns <|>\n  Quotation.getPatternsVars patterns", "start": [598, 1], "end": [600, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getLetPatDeclVars", "code": "def getLetPatDeclVars (letPatDecl : Syntax) : TermElabM (Array Var) := do\n  let pattern := letPatDecl[0]\n  getPatternVarsEx pattern", "start": [602, 1], "end": [604, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getLetEqnsDeclVars", "code": "def getLetEqnsDeclVars (letEqnsDecl : Syntax) : Array Var :=\n  if letEqnsDecl[0].isIdent then\n    #[letEqnsDecl[0]]\n  else\n    #[]", "start": [606, 1], "end": [610, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getLetDeclVars", "code": "def getLetDeclVars (letDecl : Syntax) : TermElabM (Array Var) := do\n  let arg := letDecl[0]\n  if arg.getKind == ``Parser.Term.letIdDecl then\n    return getLetIdDeclVars arg\n  else if arg.getKind == ``Parser.Term.letPatDecl then\n    getLetPatDeclVars arg\n  else if arg.getKind == ``Parser.Term.letEqnsDecl then\n    return getLetEqnsDeclVars arg\n  else\n    throwError \"unexpected kind of let declaration\"", "start": [612, 1], "end": [621, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getDoLetVars", "code": "def getDoLetVars (doLet : Syntax) : TermElabM (Array Var) :=\n  getLetDeclVars doLet[2]", "start": [623, 1], "end": [625, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getHaveIdLhsVar", "code": "def getHaveIdLhsVar (optIdent : Syntax) : Var :=\n  if optIdent.getKind == hygieneInfoKind then\n    HygieneInfo.mkIdent optIdent[0] `this\n  else\n    optIdent", "start": [627, 1], "end": [631, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getDoHaveVars", "code": "def getDoHaveVars (doHave : Syntax) : TermElabM (Array Var) := do\n  let arg := doHave[1][0]\n  if arg.getKind == ``Parser.Term.haveIdDecl then\n    return #[getHaveIdLhsVar arg[0]]\n  else if arg.getKind == ``Parser.Term.letPatDecl then\n    getLetPatDeclVars arg\n  else if arg.getKind == ``Parser.Term.haveEqnsDecl then\n    return #[getHaveIdLhsVar arg[0]]\n  else\n    throwError \"unexpected kind of have declaration\"", "start": [633, 1], "end": [647, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getDoLetRecVars", "code": "def getDoLetRecVars (doLetRec : Syntax) : TermElabM (Array Var) := do\n  let letRecDecls := doLetRec[1][0].getSepArgs\n  let letDecls := letRecDecls.map fun p => p[2]\n  let mut allVars := #[]\n  for letDecl in letDecls do\n    let vars \u2190 getLetDeclVars letDecl\n    allVars := allVars ++ vars\n  return allVars", "start": [649, 1], "end": [657, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getDoIdDeclVar", "code": "def getDoIdDeclVar (doIdDecl : Syntax) : Var :=\n  doIdDecl[0]", "start": [660, 1], "end": [661, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getDoPatDeclVars", "code": "def getDoPatDeclVars (doPatDecl : Syntax) : TermElabM (Array Var) := do\n  let pattern := doPatDecl[0]\n  getPatternVarsEx pattern", "start": [664, 1], "end": [666, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getDoLetArrowVars", "code": "def getDoLetArrowVars (doLetArrow : Syntax) : TermElabM (Array Var) := do\n  let decl := doLetArrow[2]\n  if decl.getKind == ``Parser.Term.doIdDecl then\n    return #[getDoIdDeclVar decl]\n  else if decl.getKind == ``Parser.Term.doPatDecl then\n    getDoPatDeclVars decl\n  else\n    throwError \"unexpected kind of `do` declaration\"", "start": [669, 1], "end": [676, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.getDoReassignVars", "code": "def getDoReassignVars (doReassign : Syntax) : TermElabM (Array Var) := do\n  let arg := doReassign[0]\n  if arg.getKind == ``Parser.Term.letIdDecl then\n    return getLetIdDeclVars arg\n  else if arg.getKind == ``Parser.Term.letPatDecl then\n    getLetPatDeclVars arg\n  else\n    throwError \"unexpected kind of reassignment\"", "start": [678, 1], "end": [685, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkDoSeq", "code": "def mkDoSeq (doElems : Array Syntax) : Syntax :=\n  mkNode `Lean.Parser.Term.doSeqIndent #[mkNullNode <| doElems.map fun doElem => mkNullNode #[doElem, mkNullNode]]", "start": [687, 1], "end": [688, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.expandDoIf?", "code": "private def expandDoIf? (stx : Syntax) : MacroM (Option Syntax) := match stx with\n  | `(doElem|if $_:doIfProp then $_ else $_) => pure none\n  | `(doElem|if $cond:doIfCond then $t $[else if $conds:doIfCond then $ts]* $[else $e?]?) => withRef stx do\n    let mut e      := e?.getD (\u2190 `(doSeq|pure PUnit.unit))\n    let mut eIsSeq := true\n    for (cond, t) in Array.zip (conds.reverse.push cond) (ts.reverse.push t) do\n      e \u2190 if eIsSeq then pure e else `(doSeq|$e:doElem)\n      e \u2190 match cond with\n        | `(doIfCond|let $pat := $d) => `(doElem| match $d:term with | $pat:term => $t | _ => $e)\n        | `(doIfCond|let $pat \u2190 $d)  => `(doElem| match \u2190 $d    with | $pat:term => $t | _ => $e)\n        | `(doIfCond|$cond:doIfProp) => `(doElem| if $cond:doIfProp then $t else $e)\n        | _                          => `(doElem| if $(Syntax.missing) then $t else $e)\n      eIsSeq := false\n    return some e\n  | _ => pure none", "start": [690, 1], "end": [706, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.DoIfView", "code": "structure DoIfView where\n  ref        : Syntax\n  optIdent   : Syntax\n  cond       : Syntax\n  thenBranch : Syntax\n  elseBranch : Syntax", "start": [708, 1], "end": [713, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkDoIfView", "code": "private def mkDoIfView (doIf : Syntax) : DoIfView := {\n  ref        := doIf\n  optIdent   := doIf[1][0]\n  cond       := doIf[1][1]\n  thenBranch := doIf[3]\n  elseBranch := doIf[5][1]\n}", "start": [715, 1], "end": [722, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.mkTuple", "code": "private def mkTuple (elems : Array Syntax) : MacroM Syntax := do\n  if elems.size == 0 then\n    mkUnit\n  else if elems.size == 1 then\n    return elems[0]!\n  else\n    elems.extract 0 (elems.size - 1) |>.foldrM (init := elems.back) fun elem tuple =>\n      ``(MProd.mk $elem $tuple)", "start": [724, 1], "end": [740, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.isDoExpr?", "code": "def isDoExpr? (doElem : Syntax) : Option Syntax :=\n  if doElem.getKind == ``Parser.Term.doExpr then\n    some doElem[0]\n  else\n    none", "start": [742, 1], "end": [747, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.destructTuple", "code": "private def destructTuple (uvars : Array Var) (x : Syntax) (body : Syntax) : MacroM Syntax := do\n  if uvars.size == 0 then\n    return body\n  else if uvars.size == 1 then\n    `(let $(uvars[0]!):ident := $x; $body)\n  else\n    destruct uvars.toList x body\nwhere\n  destruct (as : List Var) (x : Syntax) (body : Syntax) : MacroM Syntax := do\n    match as with\n      | [a, b]  => `(let $a:ident := $x.1; let $b:ident := $x.2; $body)\n      | a :: as => withFreshMacroScope do\n        let rest \u2190 destruct as (\u2190 `(x)) body\n        `(let $a:ident := $x.1; let x := $x.2; $rest)\n      | _ => unreachable!", "start": [749, 1], "end": [782, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.annotate", "code": "def annotate [Monad m] [MonadRef m] [MonadQuotation m] (ref : Syntax) (term : Syntax) : m Syntax :=\n  withRef term <| `(with_annotate_term $ref $term)", "start": [866, 1], "end": [886, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.Kind", "code": "inductive Kind where\n  | regular\n  | forIn\n  | forInWithReturn\n  | nestedBC\n  | nestedPR\n  | nestedSBC\n  | nestedPRBC", "start": [890, 1], "end": [897, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.Kind.isRegular", "code": "def Kind.isRegular : Kind \u2192 Bool\n  | .regular => true\n  | _        => false", "start": [901, 1], "end": [903, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.Context", "code": "structure Context where\n  \n  m          : Syntax\n  \n  returnType : Syntax\n  uvars      : Array Var\n  kind       : Kind", "start": [905, 1], "end": [911, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.M", "code": "abbrev M := ReaderT Context MacroM", "start": [913, 1], "end": [913, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.mkUVarTuple", "code": "def mkUVarTuple : M Syntax := do\n  let ctx \u2190 read\n  mkTuple ctx.uvars", "start": [915, 1], "end": [917, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.returnToTerm", "code": "def returnToTerm (val : Syntax) : M Syntax := do\n  let ctx \u2190 read\n  let u \u2190 mkUVarTuple\n  match ctx.kind with\n  | .regular         => if ctx.uvars.isEmpty then ``(Pure.pure $val) else ``(Pure.pure (MProd.mk $val $u))\n  | .forIn           => ``(Pure.pure (ForInStep.done $u))\n  | .forInWithReturn => ``(Pure.pure (ForInStep.done (MProd.mk (some $val) $u)))\n  | .nestedBC        => unreachable!\n  | .nestedPR        => ``(Pure.pure (DoResultPR.\u00abreturn\u00bb $val $u))\n  | .nestedSBC       => ``(Pure.pure (DoResultSBC.\u00abpureReturn\u00bb $val $u))\n  | .nestedPRBC      => ``(Pure.pure (DoResultPRBC.\u00abreturn\u00bb $val $u))", "start": [919, 1], "end": [929, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.continueToTerm", "code": "def continueToTerm : M Syntax := do\n  let ctx \u2190 read\n  let u \u2190 mkUVarTuple\n  match ctx.kind with\n  | .regular         => unreachable!\n  | .forIn           => ``(Pure.pure (ForInStep.yield $u))\n  | .forInWithReturn => ``(Pure.pure (ForInStep.yield (MProd.mk none $u)))\n  | .nestedBC        => ``(Pure.pure (DoResultBC.\u00abcontinue\u00bb $u))\n  | .nestedPR        => unreachable!\n  | .nestedSBC       => ``(Pure.pure (DoResultSBC.\u00abcontinue\u00bb $u))\n  | .nestedPRBC      => ``(Pure.pure (DoResultPRBC.\u00abcontinue\u00bb $u))", "start": [931, 1], "end": [941, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.breakToTerm", "code": "def breakToTerm : M Syntax := do\n  let ctx \u2190 read\n  let u \u2190 mkUVarTuple\n  match ctx.kind with\n  | .regular         => unreachable!\n  | .forIn           => ``(Pure.pure (ForInStep.done $u))\n  | .forInWithReturn => ``(Pure.pure (ForInStep.done (MProd.mk none $u)))\n  | .nestedBC        => ``(Pure.pure (DoResultBC.\u00abbreak\u00bb $u))\n  | .nestedPR        => unreachable!\n  | .nestedSBC       => ``(Pure.pure (DoResultSBC.\u00abbreak\u00bb $u))\n  | .nestedPRBC      => ``(Pure.pure (DoResultPRBC.\u00abbreak\u00bb $u))", "start": [943, 1], "end": [953, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.actionTerminalToTerm", "code": "def actionTerminalToTerm (action : Syntax) : M Syntax := withRef action <| withFreshMacroScope do\n  let ctx \u2190 read\n  let u \u2190 mkUVarTuple\n  match ctx.kind with\n  | .regular         => if ctx.uvars.isEmpty then pure action else ``(Bind.bind $action fun y => Pure.pure (MProd.mk y $u))\n  | .forIn           => ``(Bind.bind $action fun (_ : PUnit) => Pure.pure (ForInStep.yield $u))\n  | .forInWithReturn => ``(Bind.bind $action fun (_ : PUnit) => Pure.pure (ForInStep.yield (MProd.mk none $u)))\n  | .nestedBC        => unreachable!\n  | .nestedPR        => ``(Bind.bind $action fun y => (Pure.pure (DoResultPR.\u00abpure\u00bb y $u)))\n  | .nestedSBC       => ``(Bind.bind $action fun y => (Pure.pure (DoResultSBC.\u00abpureReturn\u00bb y $u)))\n  | .nestedPRBC      => ``(Bind.bind $action fun y => (Pure.pure (DoResultPRBC.\u00abpure\u00bb y $u)))", "start": [955, 1], "end": [965, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.seqToTerm", "code": "def seqToTerm (action : Syntax) (k : Syntax) : M Syntax := withRef action <| withFreshMacroScope do\n  if action.getKind == ``Parser.Term.doDbgTrace then\n    let msg := action[1]\n    `(dbg_trace $msg; $k)\n  else if action.getKind == ``Parser.Term.doAssert then\n    let cond := action[1]\n    `(assert! $cond; $k)\n  else\n    let action \u2190 withRef action ``(($action : $((\u2190read).m) PUnit))\n    ``(Bind.bind $action (fun (_ : PUnit) => $k))", "start": [967, 1], "end": [976, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.declToTerm", "code": "def declToTerm (decl : Syntax) (k : Syntax) : M Syntax := withRef decl <| withFreshMacroScope do\n  let kind := decl.getKind\n  if kind == ``Parser.Term.doLet then\n    let letDecl := decl[2]\n    `(let $letDecl:letDecl; $k)\n  else if kind == ``Parser.Term.doLetRec then\n    let letRecToken := decl[0]\n    let letRecDecls := decl[1]\n    return mkNode ``Parser.Term.letrec #[letRecToken, letRecDecls, mkNullNode, k]\n  else if kind == ``Parser.Term.doLetArrow then\n    let arg := decl[2]\n    if arg.getKind == ``Parser.Term.doIdDecl then\n      let id     := arg[0]\n      let type   := expandOptType id arg[1]\n      let doElem := arg[3]\n      match isDoExpr? doElem with\n      | some action =>\n        let action \u2190 withRef action `(($action : $((\u2190 read).m) $type))\n        ``(Bind.bind $action (fun ($id:ident : $type) => $k))\n      | none        => Macro.throwErrorAt decl \"unexpected kind of `do` declaration\"\n    else\n      Macro.throwErrorAt decl \"unexpected kind of `do` declaration\"\n  else if kind == ``Parser.Term.doHave then\n    let args := decl.getArgs\n    let args := args ++ #[mkNullNode , k]\n    return mkNode `Lean.Parser.Term.\u00abhave\u00bb args\n  else\n    Macro.throwErrorAt decl \"unexpected kind of `do` declaration\"", "start": [978, 1], "end": [1007, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.reassignToTerm", "code": "def reassignToTerm (reassign : Syntax) (k : Syntax) : MacroM Syntax := withRef reassign <| withFreshMacroScope do\n  match reassign with\n  | `(doElem| $x:ident := $rhs) => `(let $x:ident := ensure_type_of% $x $(quote \"invalid reassignment, value\") $rhs; $k)\n  | `(doElem| $e:term  := $rhs) => `(let $e:term  := ensure_type_of% $e $(quote \"invalid reassignment, value\") $rhs; $k)\n  | _ =>\n    Macro.throwErrorAt reassign \"unexpected kind of `do` reassignment\"", "start": [1009, 1], "end": [1015, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.mkIte", "code": "def mkIte (optIdent : Syntax) (cond : Syntax) (thenBranch : Syntax) (elseBranch : Syntax) : MacroM Syntax := do\n  if optIdent.isNone then\n    ``(if $cond then $thenBranch else $elseBranch)\n  else\n    let h := optIdent[0]\n    ``(if $h:ident : $cond then $thenBranch else $elseBranch)", "start": [1017, 1], "end": [1022, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.mkJoinPoint", "code": "def mkJoinPoint (j : Name) (ps : Array (Syntax \u00d7 Bool)) (body : Syntax) (k : Syntax) : M Syntax := withRef body <| withFreshMacroScope do\n  let pTypes \u2190 ps.mapM fun \u27e8id, useTypeOf\u27e9 => do if useTypeOf then `(type_of% $id) else `(_)\n  let ps     := ps.map (\u00b7.1)\n  \n  `(let_delayed $(\u2190 mkIdentFromRef j):ident $[($ps : $pTypes)]* : $((\u2190 read).m) _ := $body; $k)", "start": [1024, 1], "end": [1051, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.mkJmp", "code": "def mkJmp (ref : Syntax) (j : Name) (args : Array Syntax) : Syntax :=\n  Syntax.mkApp (mkIdentFrom ref j) args", "start": [1053, 1], "end": [1054, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.toTerm", "code": "partial def toTerm (c : Code) : M Syntax := do\n  let term \u2190 go c\n  if let some ref := c.getRef? then\n    annotate ref term\n  else\n    return term\nwhere\n  go (c : Code) : M Syntax := do\n    match c with\n    | .return ref val     => withRef ref <| returnToTerm val\n    | .continue ref       => withRef ref continueToTerm\n    | .break ref          => withRef ref breakToTerm\n    | .action e           => actionTerminalToTerm e\n    | .joinpoint j ps b k => mkJoinPoint j ps (\u2190 toTerm b) (\u2190 toTerm k)\n    | .jmp ref j args     => return mkJmp ref j args\n    | .decl _ stx k       => declToTerm stx (\u2190 toTerm k)\n    | .reassign _ stx k   => reassignToTerm stx (\u2190 toTerm k)\n    | .seq stx k          => seqToTerm stx (\u2190 toTerm k)\n    | .ite ref _ o c t e  => withRef ref <| do mkIte o c (\u2190 toTerm t) (\u2190 toTerm e)\n    | .match ref genParam discrs optMotive alts =>\n      let mut termAlts := #[]\n      for alt in alts do\n        let rhs \u2190 toTerm alt.rhs\n        let termAlt := mkNode `Lean.Parser.Term.matchAlt #[mkAtomFrom alt.ref \"|\", mkNullNode #[alt.patterns], mkAtomFrom alt.ref \"=>\", rhs]\n        termAlts := termAlts.push termAlt\n      let termMatchAlts := mkNode `Lean.Parser.Term.matchAlts #[mkNullNode termAlts]\n      return mkNode `Lean.Parser.Term.\u00abmatch\u00bb #[mkAtomFrom ref \"match\", genParam, optMotive, discrs, mkAtomFrom ref \"with\", termMatchAlts]", "start": [1056, 1], "end": [1082, 139], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.run", "code": "def run (code : Code) (m : Syntax) (returnType : Syntax) (uvars : Array Var := #[]) (kind := Kind.regular) : MacroM Syntax :=\n  toTerm code { m, returnType, kind, uvars }", "start": [1084, 1], "end": [1085, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.mkNestedKind", "code": "def mkNestedKind (a r bc : Bool) : Kind :=\n  match a, r, bc with\n  | true,  false, false => .regular\n  | false, true,  false => .regular\n  | false, false, true  => .nestedBC\n  | true,  true,  false => .nestedPR\n  | true,  false, true  => .nestedSBC\n  | false, true,  true  => .nestedSBC\n  | true,  true,  true  => .nestedPRBC\n  | false, false, false => unreachable!", "start": [1087, 1], "end": [1102, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.mkNestedTerm", "code": "def mkNestedTerm (code : Code) (m : Syntax) (returnType : Syntax) (uvars : Array Var) (a r bc : Bool) : MacroM Syntax := do\n  ToTerm.run code m returnType uvars (mkNestedKind a r bc)", "start": [1104, 1], "end": [1105, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToTerm.matchNestedTermResult", "code": "def matchNestedTermResult (term : Syntax) (uvars : Array Var) (a r bc : Bool) : MacroM (List Syntax) := do\n  let toDoElems (auxDo : Syntax) : List Syntax := getDoSeqElems (getDoSeq auxDo)\n  let u \u2190 mkTuple uvars\n  match a, r, bc with\n  | true, false, false =>\n    if uvars.isEmpty then\n      return toDoElems (\u2190 `(do $term:term))\n    else\n      return toDoElems (\u2190 `(do let r \u2190 $term:term; $u:term := r.2; pure r.1))\n  | false, true, false =>\n    if uvars.isEmpty then\n      return toDoElems (\u2190 `(do let r \u2190 $term:term; return r))\n    else\n      return toDoElems (\u2190 `(do let r \u2190 $term:term; $u:term := r.2; return r.1))\n  | false, false, true => toDoElems <$>\n    `(do let r \u2190 $term:term;\n         match r with\n         | .break u => $u:term := u; break\n         | .continue u => $u:term := u; continue)\n  | true, true, false => toDoElems <$>\n    `(do let r \u2190 $term:term;\n         match r with\n         | .pure a u => $u:term := u; pure a\n         | .return b u => $u:term := u; return b)\n  | true, false, true => toDoElems <$>\n    `(do let r \u2190 $term:term;\n         match r with\n         | .pureReturn a u => $u:term := u; pure a\n         | .break u => $u:term := u; break\n         | .continue u => $u:term := u; continue)\n  | false, true, true => toDoElems <$>\n    `(do let r \u2190 $term:term;\n         match r with\n         | .pureReturn a u => $u:term := u; return a\n         | .break u => $u:term := u; break\n         | .continue u => $u:term := u; continue)\n  | true, true, true => toDoElems <$>\n    `(do let r \u2190 $term:term;\n         match r with\n         | .pure a u => $u:term := u; pure a\n         | .return a u => $u:term := u; return a\n         | .break u => $u:term := u; break\n         | .continue u => $u:term := u; continue)\n  | false, false, false => unreachable!", "start": [1107, 1], "end": [1158, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.isMutableLet", "code": "def isMutableLet (doElem : Syntax) : Bool :=\n  let kind := doElem.getKind\n  (kind == ``doLetArrow || kind == ``doLet || kind == ``doLetElse)\n  &&\n  !doElem[1].isNone", "start": [1162, 1], "end": [1166, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.Context", "code": "structure Context where\n  ref         : Syntax\n  \n  m           : Syntax\n  \n  returnType  : Syntax\n  mutableVars : VarSet := {}\n  insideFor   : Bool := false", "start": [1170, 1], "end": [1177, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.M", "code": "abbrev M := ReaderT Context TermElabM", "start": [1179, 1], "end": [1179, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.withNewMutableVars", "code": "def withNewMutableVars {\u03b1} (newVars : Array Var) (mutable : Bool) (x : M \u03b1) : M \u03b1 :=\n  withReader (fun ctx => if mutable then { ctx with mutableVars := insertVars ctx.mutableVars newVars } else ctx) x", "start": [1181, 1], "end": [1182, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.checkReassignable", "code": "def checkReassignable (xs : Array Var) : M Unit := do\n  let throwInvalidReassignment (x : Name) : M Unit :=\n    throwError \"`{x.simpMacroScopes}` cannot be mutated, only variables declared using `let mut` can be mutated. If you did not intent to mutate but define `{x.simpMacroScopes}`, consider using `let {x.simpMacroScopes}` instead\"\n  let ctx \u2190 read\n  for x in xs do\n    unless ctx.mutableVars.contains x.getId do\n      throwInvalidReassignment x.getId", "start": [1184, 1], "end": [1190, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.checkNotShadowingMutable", "code": "def checkNotShadowingMutable (xs : Array Var) : M Unit := do\n  let throwInvalidShadowing (x : Name) : M Unit :=\n    throwError \"mutable variable `{x.simpMacroScopes}` cannot be shadowed\"\n  let ctx \u2190 read\n  for x in xs do\n    if ctx.mutableVars.contains x.getId then\n      withRef x <| throwInvalidShadowing x.getId", "start": [1192, 1], "end": [1198, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.withFor", "code": "def withFor {\u03b1} (x : M \u03b1) : M \u03b1 :=\n  withReader (fun ctx => { ctx with insideFor := true }) x", "start": [1200, 1], "end": [1201, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult", "code": "structure ToForInTermResult where\n  uvars      : Array Var\n  term       : Syntax", "start": [1203, 1], "end": [1205, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.mkForInBody", "code": "def mkForInBody  (_ : Syntax) (forInBody : CodeBlock) : M ToForInTermResult := do\n  let ctx \u2190 read\n  let uvars := forInBody.uvars\n  let uvars := varSetToArray uvars\n  let term \u2190 liftMacroM <| ToTerm.run forInBody.code ctx.m ctx.returnType uvars (if hasReturn forInBody.code then ToTerm.Kind.forInWithReturn else ToTerm.Kind.forIn)\n  return \u27e8uvars, term\u27e9", "start": [1207, 1], "end": [1212, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.ensureInsideFor", "code": "def ensureInsideFor : M Unit :=\n  unless (\u2190 read).insideFor do\n    throwError \"invalid `do` element, it must be inside `for`\"", "start": [1214, 1], "end": [1216, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.ensureEOS", "code": "def ensureEOS (doElems : List Syntax) : M Unit :=\n  unless doElems.isEmpty do\n    throwError \"must be last element in a `do` sequence\"", "start": [1218, 1], "end": [1220, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.expandLiftMethodAux", "code": "private partial def expandLiftMethodAux (inQuot : Bool) (inBinder : Bool) : Syntax \u2192 StateT (List Syntax) M Syntax\n  | stx@(Syntax.node i k args) =>\n    if k == choiceKind then do\n      let alts \u2190 stx.getArgs.mapM (expandLiftMethodAux inQuot inBinder \u00b7 |>.run [])\n      let (_, lifts) := alts[0]!\n      unless alts.all (\u00b7.2 == lifts) do\n        throwErrorAt stx \"cannot lift `(<- ...)` over inconsistent syntax variants, consider lifting out the binding manually\"\n      modify (\u00b7 ++ lifts)\n      return .node i k (alts.map (\u00b7.1))\n    else if liftMethodDelimiter k then\n      return stx\n    else if k == ``Parser.Term.liftMethod && !inQuot then withFreshMacroScope do\n      if inBinder then\n        throwErrorAt stx \"cannot lift `(<- ...)` over a binder, this error usually happens when you are trying to lift a method nested in a `fun`, `let`, or `match`-alternative, and it can often be fixed by adding a missing `do`\"\n      let term := args[1]!\n      let term \u2190 expandLiftMethodAux inQuot inBinder term\n      let id \u2190 mkIdentFromRef (.num baseId (\u2190 get).length)\n      let auxDoElem : Syntax \u2190 `(doElem| let $id:ident \u2190 $term:term)\n      modify fun s => s ++ [auxDoElem]\n      return id\n    else do\n      let inAntiquot := stx.isAntiquot && !stx.isEscapedAntiquot\n      let inBinder   := inBinder || (!inQuot && liftMethodForbiddenBinder stx)\n      let args \u2190 args.mapM (expandLiftMethodAux (inQuot && !inAntiquot || stx.isQuot) inBinder)\n      return Syntax.node i k args\n  | stx => return stx", "start": [1223, 1], "end": [1250, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.expandLiftMethod", "code": "def expandLiftMethod (doElem : Syntax) : M (List Syntax \u00d7 Syntax) := do\n  if !hasLiftMethod doElem then\n    return ([], doElem)\n  else\n    let baseId \u2190 withFreshMacroScope (MonadQuotation.addMacroScope `__do_lift)\n    let (doElem, doElemsNew) \u2190 (expandLiftMethodAux baseId false false doElem).run []\n    return (doElemsNew, doElem)", "start": [1252, 1], "end": [1258, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.checkLetArrowRHS", "code": "def checkLetArrowRHS (doElem : Syntax) : M Unit := do\n  let kind := doElem.getKind\n  if kind == ``Parser.Term.doLetArrow ||\n     kind == ``Parser.Term.doLet ||\n     kind == ``Parser.Term.doLetRec ||\n     kind == ``Parser.Term.doHave ||\n     kind == ``Parser.Term.doReassign ||\n     kind == ``Parser.Term.doReassignArrow then\n    throwErrorAt doElem \"invalid kind of value `{kind}` in an assignment\"", "start": [1260, 1], "end": [1268, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doReturnToCode", "code": "def doReturnToCode (doReturn : Syntax) (doElems: List Syntax) : M CodeBlock := withRef doReturn do\n  ensureEOS doElems\n  let argOpt := doReturn[1]\n  let arg \u2190 if argOpt.isNone then liftMacroM mkUnit else pure argOpt[0]\n  return mkReturn (\u2190 getRef) arg", "start": [1270, 1], "end": [1279, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.Catch", "code": "structure Catch where\n  x         : Syntax\n  optType   : Syntax\n  codeBlock : CodeBlock", "start": [1281, 1], "end": [1284, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.getTryCatchUpdatedVars", "code": "def getTryCatchUpdatedVars (tryCode : CodeBlock) (catches : Array Catch) (finallyCode? : Option CodeBlock) : VarSet :=\n  let ws := tryCode.uvars\n  let ws := catches.foldl (init := ws) fun ws alt => union alt.codeBlock.uvars ws\n  let ws := match finallyCode? with\n    | none   => ws\n    | some c => union c.uvars ws\n  ws", "start": [1286, 1], "end": [1292, 5], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.tryCatchPred", "code": "def tryCatchPred (tryCode : CodeBlock) (catches : Array Catch) (finallyCode? : Option CodeBlock) (p : Code \u2192 Bool) : Bool :=\n  p tryCode.code ||\n  catches.any (fun \u00abcatch\u00bb => p \u00abcatch\u00bb.codeBlock.code) ||\n  match finallyCode? with\n  | none => false\n  | some finallyCode => p finallyCode.code", "start": [1294, 1], "end": [1299, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.concatWith", "code": "partial def concatWith (c : CodeBlock) (doElems : List Syntax) : M CodeBlock :=\n    match doElems with\n    | [] => pure c\n    | nextDoElem :: _  => do\n      let k \u2190 doSeqToCode doElems\n      let ref := nextDoElem\n      concat c ref none k", "start": [1302, 3], "end": [1309, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doLetArrowToCode", "code": "partial def doLetArrowToCode (doLetArrow : Syntax) (doElems : List Syntax) : M CodeBlock := do\n    let decl    := doLetArrow[2]\n    if decl.getKind == ``Parser.Term.doIdDecl then\n      let y := decl[0]\n      checkNotShadowingMutable #[y]\n      let doElem := decl[3]\n      let k \u2190 withNewMutableVars #[y] (isMutableLet doLetArrow) (doSeqToCode doElems)\n      match isDoExpr? doElem with\n      | some _      => return mkVarDeclCore #[y] doLetArrow k\n      | none =>\n        checkLetArrowRHS doElem\n        let c \u2190 doSeqToCode [doElem]\n        match doElems with\n        | []       => pure c\n        | kRef::_  => concat c kRef y k\n    else if decl.getKind == ``Parser.Term.doPatDecl then\n      let pattern := decl[0]\n      let doElem  := decl[2]\n      let optElse := decl[3]\n      if optElse.isNone then withFreshMacroScope do\n        let auxDo \u2190 if isMutableLet doLetArrow then\n          `(do let%$doLetArrow __discr \u2190 $doElem; let%$doLetArrow mut $pattern:term := __discr)\n        else\n          `(do let%$doLetArrow __discr \u2190 $doElem; let%$doLetArrow $pattern:term := __discr)\n        doSeqToCode <| getDoSeqElems (getDoSeq auxDo) ++ doElems\n      else\n        let contSeq \u2190 if isMutableLet doLetArrow then\n          let vars \u2190 (\u2190 getPatternVarsEx pattern).mapM fun var => `(doElem| let mut $var := $var)\n          pure (vars ++ doElems.toArray)\n        else\n          pure doElems.toArray\n        let contSeq := mkDoSeq contSeq\n        let elseSeq := optElse[1]\n        let auxDo \u2190 `(do let%$doLetArrow __discr \u2190 $doElem; match%$doLetArrow __discr with | $pattern:term => $contSeq | _ => $elseSeq)\n        doSeqToCode <| getDoSeqElems (getDoSeq auxDo)\n    else\n      throwError \"unexpected kind of `do` declaration\"", "start": [1311, 3], "end": [1358, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doLetElseToCode", "code": "partial def doLetElseToCode (doLetElse : Syntax) (doElems : List Syntax) : M CodeBlock := do\n    let pattern := doLetElse[2]\n    let val     := doLetElse[4]\n    let elseSeq := doLetElse[6]\n    let contSeq \u2190 if isMutableLet doLetElse then\n      let vars \u2190 (\u2190 getPatternVarsEx pattern).mapM fun var => `(doElem| let mut $var := $var)\n      pure (vars ++ doElems.toArray)\n    else\n      pure doElems.toArray\n    let contSeq := mkDoSeq contSeq\n    let auxDo \u2190 `(do let __discr := $val; match __discr with | $pattern:term => $contSeq | _ => $elseSeq)\n    doSeqToCode <| getDoSeqElems (getDoSeq auxDo)", "start": [1360, 3], "end": [1372, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doReassignArrowToCode", "code": "partial def doReassignArrowToCode (doReassignArrow : Syntax) (doElems : List Syntax) : M CodeBlock := do\n    let decl := doReassignArrow[0]\n    if decl.getKind == ``Parser.Term.doIdDecl then\n      let doElem := decl[3]\n      let y      := decl[0]\n      let auxDo \u2190 `(do let r \u2190 $doElem; $y:ident := r)\n      doSeqToCode <| getDoSeqElems (getDoSeq auxDo) ++ doElems\n    else if decl.getKind == ``Parser.Term.doPatDecl then\n      let pattern := decl[0]\n      let doElem  := decl[2]\n      let optElse := decl[3]\n      if optElse.isNone then withFreshMacroScope do\n        let auxDo \u2190 `(do let __discr \u2190 $doElem; $pattern:term := __discr)\n        doSeqToCode <| getDoSeqElems (getDoSeq auxDo) ++ doElems\n      else\n        throwError \"reassignment with `|` (i.e., \\\"else clause\\\") is not currently supported\"\n    else\n      throwError \"unexpected kind of `do` reassignment\"", "start": [1374, 3], "end": [1397, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doIfToCode", "code": "partial def doIfToCode (doIf : Syntax) (doElems : List Syntax) : M CodeBlock := do\n    let view := mkDoIfView doIf\n    let thenBranch \u2190 doSeqToCode (getDoSeqElems view.thenBranch)\n    let elseBranch \u2190 doSeqToCode (getDoSeqElems view.elseBranch)\n    let ite \u2190 mkIte view.ref view.optIdent view.cond thenBranch elseBranch\n    concatWith ite doElems", "start": [1399, 3], "end": [1411, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doUnlessToCode", "code": "partial def doUnlessToCode (doUnless : Syntax) (doElems : List Syntax) : M CodeBlock := withRef doUnless do\n    let cond  := doUnless[1]\n    let doSeq := doUnless[3]\n    let body \u2190 doSeqToCode (getDoSeqElems doSeq)\n    let unlessCode \u2190 liftMacroM <| mkUnless cond body\n    concatWith unlessCode doElems", "start": [1413, 3], "end": [1423, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doForToCode", "code": "partial def doForToCode (doFor : Syntax) (doElems : List Syntax) : M CodeBlock := do\n    let doForDecls := doFor[1].getSepArgs\n    if doForDecls.size > 1 then\n      \n            let doForDecl := doForDecls[1]!\n      unless doForDecl[0].isNone do\n        throwErrorAt doForDecl[0] \"the proof annotation here has not been implemented yet\"\n      let y  := doForDecl[1]\n      let ys := doForDecl[3]\n      let doForDecls := doForDecls.eraseIdx 1\n      let body := doFor[3]\n      withFreshMacroScope do\n        \n        let toStreamApp \u2190 withRef ys `(@toStream _ _ _ $ys)\n        let auxDo \u2190\n          `(do let mut s := $toStreamApp:term\n               for $doForDecls:doForDecl,* do\n                 match @Stream.next? _ _ _ s with\n                 | none => break\n                 | some ($y, s') =>\n                   s := s'\n                   do $body)\n        doSeqToCode (getDoSeqElems (getDoSeq auxDo) ++ doElems)\n    else withRef doFor do\n      let h?        := if doForDecls[0]![0].isNone then none else some doForDecls[0]![0][0]\n      let x         := doForDecls[0]![1]\n      withRef x <| checkNotShadowingMutable (\u2190 getPatternVarsEx x)\n      let xs        := doForDecls[0]![3]\n      let forElems  := getDoSeqElems doFor[3]\n      let forInBodyCodeBlock \u2190 withFor (doSeqToCode forElems)\n      let \u27e8uvars, forInBody\u27e9 \u2190 mkForInBody x forInBodyCodeBlock\n      let ctx \u2190 read\n      let uvars := uvars.map fun v => ctx.mutableVars.findD v.getId v\n      let uvarsTuple \u2190 liftMacroM do mkTuple uvars\n      if hasReturn forInBodyCodeBlock.code then\n        let forInBody \u2190 liftMacroM <| destructTuple uvars (\u2190 `(r)) forInBody\n        let optType \u2190 `(Option $((\u2190 read).returnType))\n        let forInTerm \u2190 if let some h := h? then\n          annotate doFor\n            (\u2190 `(for_in'% $(xs) (MProd.mk (none : $optType) $uvarsTuple) fun $x $h (r : MProd $optType _) => let r := r.2; $forInBody))\n        else\n          annotate doFor\n            (\u2190 `(for_in% $(xs) (MProd.mk (none : $optType) $uvarsTuple) fun $x (r : MProd $optType _) => let r := r.2; $forInBody))\n        let auxDo \u2190 `(do let r \u2190 $forInTerm:term;\n                         $uvarsTuple:term := r.2;\n                         match r.1 with\n                         | none => Pure.pure (ensure_expected_type% \"type mismatch, `for`\" PUnit.unit)\n                         | some a => return ensure_expected_type% \"type mismatch, `for`\" a)\n        doSeqToCode (getDoSeqElems (getDoSeq auxDo) ++ doElems)\n      else\n        let forInBody \u2190 liftMacroM <| destructTuple uvars (\u2190 `(r)) forInBody\n        let forInTerm \u2190 if let some h := h? then\n          annotate doFor (\u2190 `(for_in'% $(xs) $uvarsTuple fun $x $h r => $forInBody))\n        else\n          annotate doFor (\u2190 `(for_in% $(xs) $uvarsTuple fun $x r => $forInBody))\n        if doElems.isEmpty then\n          let auxDo \u2190 `(do let r \u2190 $forInTerm:term;\n                           $uvarsTuple:term := r;\n                           Pure.pure (ensure_expected_type% \"type mismatch, `for`\" PUnit.unit))\n          doSeqToCode <| getDoSeqElems (getDoSeq auxDo)\n        else\n          let auxDo \u2190 `(do let r \u2190 $forInTerm:term; $uvarsTuple:term := r)\n          doSeqToCode <| getDoSeqElems (getDoSeq auxDo) ++ doElems", "start": [1425, 3], "end": [1515, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doMatchToCode", "code": "partial def doMatchToCode (doMatch : Syntax) (doElems: List Syntax) : M CodeBlock := do\n    let ref       := doMatch\n    let genParam  := doMatch[1]\n    let optMotive := doMatch[2]\n    let discrs    := doMatch[3]\n    let matchAlts := doMatch[5][0].getArgs let matchAlts \u2190 matchAlts.foldlM (init := #[]) fun result matchAlt => return result ++ (\u2190 liftMacroM <| expandMatchAlt matchAlt)\n    let alts \u2190  matchAlts.mapM fun matchAlt => do\n      let patterns := matchAlt[1][0]\n      let vars \u2190 getPatternsVarsEx patterns.getSepArgs\n      withRef patterns <| checkNotShadowingMutable vars\n      let rhs  := matchAlt[3]\n      let rhs \u2190 doSeqToCode (getDoSeqElems rhs)\n      pure { ref := matchAlt, vars := vars, patterns := patterns, rhs := rhs : Alt CodeBlock }\n    let matchCode \u2190 mkMatch ref genParam discrs optMotive alts\n    concatWith matchCode doElems", "start": [1517, 3], "end": [1533, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doTryToCode", "code": "partial def doTryToCode (doTry : Syntax) (doElems: List Syntax) : M CodeBlock := do\n    let tryCode \u2190 doSeqToCode (getDoSeqElems doTry[1])\n    let optFinally := doTry[3]\n    let catches \u2190 doTry[2].getArgs.mapM fun catchStx : Syntax => do\n      if catchStx.getKind == ``Parser.Term.doCatch then\n        let x       := catchStx[1]\n        if x.isIdent then\n          withRef x <| checkNotShadowingMutable #[x]\n        let optType := catchStx[2]\n        let c \u2190 doSeqToCode (getDoSeqElems catchStx[4])\n        return { x := x, optType := optType, codeBlock := c : Catch }\n      else if catchStx.getKind == ``Parser.Term.doCatchMatch then\n        let matchAlts := catchStx[1]\n        let x \u2190 `(ex)\n        let auxDo \u2190 `(do match ex with $matchAlts)\n        let c \u2190 doSeqToCode (getDoSeqElems (getDoSeq auxDo))\n        return { x := x, codeBlock := c, optType := mkNullNode : Catch }\n      else\n        throwError \"unexpected kind of `catch`\"\n    let finallyCode? \u2190 if optFinally.isNone then pure none else some <$> doSeqToCode (getDoSeqElems optFinally[0][1])\n    if catches.isEmpty && finallyCode?.isNone then\n      throwError \"invalid `try`, it must have a `catch` or `finally`\"\n    let ctx \u2190 read\n    let ws    := getTryCatchUpdatedVars tryCode catches finallyCode?\n    let uvars := varSetToArray ws\n    let a     := tryCatchPred tryCode catches finallyCode? hasTerminalAction\n    let r     := tryCatchPred tryCode catches finallyCode? hasReturn\n    let bc    := tryCatchPred tryCode catches finallyCode? hasBreakContinue\n    let toTerm (codeBlock : CodeBlock) : M Syntax := do\n      let codeBlock \u2190 liftM $ extendUpdatedVars codeBlock ws\n      liftMacroM <| ToTerm.mkNestedTerm codeBlock.code ctx.m ctx.returnType uvars a r bc\n    let term \u2190 toTerm tryCode\n    let term \u2190 catches.foldlM (init := term) fun term \u00abcatch\u00bb => do\n      let catchTerm \u2190 toTerm \u00abcatch\u00bb.codeBlock\n      if catch.optType.isNone then\n        annotate doTry (\u2190 ``(MonadExcept.tryCatch $term (fun $(\u00abcatch\u00bb.x):ident => $catchTerm)))\n      else\n        let type := \u00abcatch\u00bb.optType[1]\n        annotate doTry (\u2190 ``(tryCatchThe $type $term (fun $(\u00abcatch\u00bb.x):ident => $catchTerm)))\n    let term \u2190 match finallyCode? with\n      | none             => pure term\n      | some finallyCode => withRef optFinally do\n        unless finallyCode.uvars.isEmpty do\n          throwError \"`finally` currently does not support reassignments\"\n        if hasBreakContinueReturn finallyCode.code then\n          throwError \"`finally` currently does `return`, `break`, nor `continue`\"\n        let finallyTerm \u2190 liftMacroM <| ToTerm.run finallyCode.code ctx.m ctx.returnType {} ToTerm.Kind.regular\n        annotate doTry (\u2190 ``(tryFinally $term $finallyTerm))\n    let doElemsNew \u2190 liftMacroM <| ToTerm.matchNestedTermResult term uvars a r bc\n    doSeqToCode (doElemsNew ++ doElems)", "start": [1535, 3], "end": [1593, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.doSeqToCode", "code": "partial def doSeqToCode : List Syntax \u2192 M CodeBlock\n    | [] => do liftMacroM mkPureUnitAction\n    | doElem::doElems => withIncRecDepth <| withRef doElem do\n      checkMaxHeartbeats \"`do`-expander\"\n      match (\u2190 liftMacroM <| expandMacro? doElem) with\n      | some doElem => doSeqToCode (doElem::doElems)\n      | none =>\n      match (\u2190 liftMacroM <| expandDoIf? doElem) with\n      | some doElem => doSeqToCode (doElem::doElems)\n      | none =>\n        let (liftedDoElems, doElem) \u2190 expandLiftMethod doElem\n        if !liftedDoElems.isEmpty then\n          doSeqToCode (liftedDoElems ++ [doElem] ++ doElems)\n        else\n          let ref := doElem\n          let k := doElem.getKind\n          if k == ``Parser.Term.doLet then\n            let vars \u2190 getDoLetVars doElem\n            checkNotShadowingMutable vars\n            mkVarDeclCore vars doElem <$> withNewMutableVars vars (isMutableLet doElem) (doSeqToCode doElems)\n          else if k == ``Parser.Term.doHave then\n            let vars \u2190 getDoHaveVars doElem\n            checkNotShadowingMutable vars\n            mkVarDeclCore vars doElem <$> (doSeqToCode doElems)\n          else if k == ``Parser.Term.doLetRec then\n            let vars \u2190 getDoLetRecVars doElem\n            checkNotShadowingMutable vars\n            mkVarDeclCore vars doElem <$> (doSeqToCode doElems)\n          else if k == ``Parser.Term.doReassign then\n            let vars \u2190 getDoReassignVars doElem\n            checkReassignable vars\n            let k \u2190 doSeqToCode doElems\n            mkReassignCore vars doElem k\n          else if k == ``Parser.Term.doLetArrow then\n            doLetArrowToCode doElem doElems\n          else if k == ``Parser.Term.doLetElse then\n            doLetElseToCode doElem doElems\n          else if k == ``Parser.Term.doReassignArrow then\n            doReassignArrowToCode doElem doElems\n          else if k == ``Parser.Term.doIf then\n            doIfToCode doElem doElems\n          else if k == ``Parser.Term.doUnless then\n            doUnlessToCode doElem doElems\n          else if k == ``Parser.Term.doFor then withFreshMacroScope do\n            doForToCode doElem doElems\n          else if k == ``Parser.Term.doMatch then\n            doMatchToCode doElem doElems\n          else if k == ``Parser.Term.doTry then\n            doTryToCode doElem doElems\n          else if k == ``Parser.Term.doBreak then\n            ensureInsideFor\n            ensureEOS doElems\n            return mkBreak ref\n          else if k == ``Parser.Term.doContinue then\n            ensureInsideFor\n            ensureEOS doElems\n            return mkContinue ref\n          else if k == ``Parser.Term.doReturn then\n            doReturnToCode doElem doElems\n          else if k == ``Parser.Term.doDbgTrace then\n            return mkSeq doElem (\u2190 doSeqToCode doElems)\n          else if k == ``Parser.Term.doAssert then\n            return mkSeq doElem (\u2190 doSeqToCode doElems)\n          else if k == ``Parser.Term.doNested then\n            let nestedDoSeq := doElem[1]\n            doSeqToCode (getDoSeqElems nestedDoSeq ++ doElems)\n          else if k == ``Parser.Term.doExpr then\n            let term := doElem[0]\n            if doElems.isEmpty then\n              return mkTerminalAction term\n            else\n              return mkSeq term (\u2190 doSeqToCode doElems)\n          else\n            throwError \"unexpected do-element of kind {doElem.getKind}:\\n{doElem}\"", "start": [1595, 3], "end": [1668, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.ToCodeBlock.run", "code": "def run (doStx : Syntax) (m : Syntax) (returnType : Syntax) : TermElabM CodeBlock :=\n  (doSeqToCode <| getDoSeqElems <| getDoSeq doStx).run { ref := doStx, m, returnType }", "start": [1671, 1], "end": [1672, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Do.elabDo", "code": "@[builtin_term_elab \u00abdo\u00bb] def elabDo : TermElab := fun stx expectedType? => do\n  tryPostponeIfNoneOrMVar expectedType?\n  let bindInfo \u2190 extractBind expectedType?\n  let m \u2190 Term.exprToSyntax bindInfo.m\n  let returnType \u2190 Term.exprToSyntax bindInfo.returnType\n  let codeBlock \u2190 ToCodeBlock.run stx m returnType\n  let stxNew \u2190 liftMacroM <| ToTerm.run codeBlock.code m returnType\n  trace[Elab.do] stxNew\n  withMacroExpansion stx stxNew <| elabTermEnsuringType stxNew bindInfo.expectedType", "start": [1676, 1], "end": [1684, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.toDoElem", "code": "private def toDoElem (newKind : SyntaxNodeKind) : Macro := fun stx => do\n  let stx := stx.setKind newKind\n  withRef stx `(do $stx:doElem)", "start": [1690, 1], "end": [1692, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandTermFor", "code": "@[builtin_macro Lean.Parser.Term.termFor]\ndef expandTermFor : Macro := toDoElem ``Parser.Term.doFor", "start": [1694, 1], "end": [1695, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandTermTry", "code": "@[builtin_macro Lean.Parser.Term.termTry]\ndef expandTermTry : Macro := toDoElem ``Parser.Term.doTry", "start": [1697, 1], "end": [1698, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandTermUnless", "code": "@[builtin_macro Lean.Parser.Term.termUnless]\ndef expandTermUnless : Macro := toDoElem ``Parser.Term.doUnless", "start": [1700, 1], "end": [1701, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandTermReturn", "code": "@[builtin_macro Lean.Parser.Term.termReturn]\ndef expandTermReturn : Macro := toDoElem ``Parser.Term.doReturn", "start": [1703, 1], "end": [1704, 64], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/ParseImportsFast.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Module.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ParseImports.State", "code": "structure State where\n  imports : Array Import := #[]\n  pos     : String.Pos := 0\n  error?  : Option String := none\n  deriving Inhabited", "start": [11, 1], "end": [15, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.Parser", "code": "def Parser := String \u2192 State \u2192 State", "start": [17, 1], "end": [17, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.State.setPos", "code": "@[inline] def State.setPos (s : State) (pos : String.Pos) : State :=\n  { s with pos := pos }", "start": [22, 1], "end": [23, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.State.mkError", "code": "@[inline] def State.mkError (s : State) (msg : String) : State :=\n  { s with error? := some msg }", "start": [25, 1], "end": [26, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.State.mkEOIError", "code": "def State.mkEOIError (s : State) : State :=\n  s.mkError \"unexpected end of input\"", "start": [28, 1], "end": [29, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.State.next", "code": "@[inline] def State.next (s : State) (input : String) (pos : String.Pos) : State :=\n  { s with pos := input.next pos }", "start": [31, 1], "end": [32, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.State.next'", "code": "@[inline] def State.next' (s : State) (input : String) (pos : String.Pos) (h : \u00ac input.atEnd pos): State :=\n  { s with pos := input.next' pos h }", "start": [34, 1], "end": [35, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.finishCommentBlock", "code": "partial def finishCommentBlock (nesting : Nat) : Parser := fun input s =>\n  let input := input\n  let i     := s.pos\n  if h : input.atEnd i then eoi s\n  else\n    let curr := input.get' i h\n    let i    := input.next' i h\n    if curr == '-' then\n      if h : input.atEnd i then eoi s\n      else\n        let curr := input.get' i h\n        if curr == '/' then if nesting == 1 then s.next input i\n          else finishCommentBlock (nesting-1) input (s.next' input i h)\n        else\n          finishCommentBlock nesting input (s.next' input i h)\n    else if curr == '/' then\n      if h : input.atEnd i then eoi s\n      else\n        let curr := input.get' i h\n        if curr == '-' then finishCommentBlock (nesting+1) input (s.next' input i h)\n        else finishCommentBlock nesting input (s.setPos i)\n    else finishCommentBlock nesting input (s.setPos i)\nwhere\n  eoi s := s.mkError \"unterminated comment\"", "start": [37, 1], "end": [61, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.takeUntil", "code": "@[specialize] partial def takeUntil (p : Char \u2192 Bool) : Parser := fun input s =>\n  let i := s.pos\n  if h : input.atEnd i then s\n  else if p (input.get' i h) then s\n  else takeUntil p input (s.next' input i h)", "start": [63, 1], "end": [67, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.takeWhile", "code": "@[inline] def takeWhile (p : Char \u2192 Bool) : Parser :=\n  takeUntil (fun c => !p c)", "start": [69, 1], "end": [70, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.andthen", "code": "@[inline] def andthen (p q : Parser) : Parser := fun input s =>\n  let s := p input s\n  if s.error? matches some .. then s else q input s", "start": [72, 1], "end": [74, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.whitespace", "code": "partial def whitespace : Parser := fun input s =>\n  let i := s.pos\n  if h : input.atEnd i then s\n  else\n    let curr := input.get' i h\n    if curr == '\\t' then\n      s.mkError \"tabs are not allowed; please configure your editor to expand them\"\n    else if curr.isWhitespace then whitespace input (s.next input i)\n    else if curr == '-' then\n      let i    := input.next' i h\n      let curr := input.get i\n      if curr == '-' then andthen (takeUntil (fun c => c = '\\n')) whitespace input (s.next input i)\n      else s\n    else if curr == '/' then\n      let i        := input.next' i h\n      let curr     := input.get i\n      if curr == '-' then\n        let i    := input.next i\n        let curr := input.get i\n        if curr == '-' || curr == '!' then s else andthen (finishCommentBlock 1) whitespace input (s.next input i)\n      else s\n    else s", "start": [79, 1], "end": [101, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.keywordCore", "code": "@[inline] partial def keywordCore (k : String) (failure : Parser) (success : Parser) : Parser := fun input s =>\n  let rec @[specialize] go (i j : String.Pos) : State :=\n    if h\u2081 : k.atEnd i then\n      success input <| whitespace input (s.setPos j)\n    else if h\u2082 : input.atEnd j then\n      failure input s\n    else\n      let curr\u2081 := k.get' i h\u2081\n      let curr\u2082 := input.get' j h\u2082\n      if curr\u2081 != curr\u2082 then\n        failure input s\n      else\n        go (k.next' i h\u2081) (input.next' j h\u2082)\n  go 0 s.pos", "start": [103, 1], "end": [116, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.keyword", "code": "@[inline] partial def keyword (k : String) : Parser :=\n  keywordCore k (fun _ s => s.mkError s!\"`{k}` expected\") (fun _ s => s)", "start": [118, 1], "end": [119, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.isIdCont", "code": "@[inline] def isIdCont : String \u2192 State \u2192 Bool := fun input s =>\n  let i := s.pos\n  let curr := input.get i\n  if curr == '.' then\n    let i := input.next i\n    if h : input.atEnd i then\n      false\n    else\n      let curr := input.get' i h\n      isIdFirst curr || isIdBeginEscape curr\n  else\n    false", "start": [121, 1], "end": [132, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.State.pushModule", "code": "def State.pushModule (module : Name) (runtimeOnly : Bool) (s : State) : State :=\n  { s with imports := s.imports.push { module, runtimeOnly } }", "start": [134, 1], "end": [135, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.isIdRestCold", "code": "@[inline] def isIdRestCold (c : Char) : Bool :=\n  c = '_' || c = '\\'' || c == '!' || c == '?' || isLetterLike c || isSubScriptAlnum c", "start": [137, 1], "end": [138, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.isIdRestFast", "code": "@[inline] def isIdRestFast (c : Char) : Bool :=\n  c.isAlphanum || (c != '.' && c != '\\n' && c != ' ' && isIdRestCold c)", "start": [140, 1], "end": [141, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.moduleIdent", "code": "partial def moduleIdent (runtimeOnly : Bool) : Parser := fun input s =>\n  let rec parse (module : Name) (s : State) :=\n    let i := s.pos\n    if h : input.atEnd i then\n      s.mkEOIError\n    else\n      let curr := input.get' i h\n      if isIdBeginEscape curr then\n        let startPart := input.next' i h\n        let s         := takeUntil isIdEndEscape input (s.setPos startPart)\n        if h : input.atEnd s.pos then\n          s.mkError \"unterminated identifier escape\"\n        else\n          let stopPart  := s.pos\n          let s         := s.next' input s.pos h\n          let module    := .str module (input.extract startPart stopPart)\n          if isIdCont input s then\n            let s := s.next input s.pos\n            parse module s\n          else\n            whitespace input (s.pushModule module runtimeOnly)\n      else if isIdFirst curr then\n        let startPart := i\n        let s         := takeWhile isIdRestFast input (s.next' input i h)\n        let stopPart  := s.pos\n        let module    := .str module (input.extract startPart stopPart)\n        if isIdCont input s then\n          let s := s.next input s.pos\n          parse module s\n        else\n          whitespace input (s.pushModule module runtimeOnly)\n      else\n        s.mkError \"expected identifier\"\n  parse .anonymous s", "start": [143, 1], "end": [176, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.many", "code": "@[specialize] partial def many (p : Parser) : Parser := fun input s =>\n  let pos := s.pos\n  let size := s.imports.size\n  let s := p input s\n  match s.error? with\n  | none => many p input s\n  | some _ => { pos, error? := none, imports := s.imports.shrink size }", "start": [178, 1], "end": [184, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.preludeOpt", "code": "@[inline] partial def preludeOpt (k : String) : Parser :=\n  keywordCore k (fun _ s => s.pushModule `Init false) (fun _ s => s)", "start": [186, 1], "end": [187, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.ParseImports.main", "code": "def main : Parser :=\n  preludeOpt \"prelude\" >>\n  many (keyword \"import\" >> keywordCore \"runtime\" (moduleIdent false) (moduleIdent true))", "start": [189, 1], "end": [191, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.parseImports'", "code": "def parseImports' (input : String) (fileName : String) : IO (Array Lean.Import) := do\n  let s := ParseImports.main input (ParseImports.whitespace input {})\n  match s.error? with\n  | none => return s.imports\n  | some err => throw <| IO.userError s!\"{fileName}: {err}\"", "start": [195, 1], "end": [202, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.PrintImportResult", "code": "structure PrintImportResult where\n  imports? : Option (Array Import) := none\n  errors   : Array String := #[]\n  deriving ToJson", "start": [206, 1], "end": [209, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.PrintImportsResult", "code": "structure PrintImportsResult where\n  imports : Array PrintImportResult\n  deriving ToJson", "start": [211, 1], "end": [213, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.printImportsJson", "code": "@[export lean_print_imports_json]\ndef printImportsJson (fileNames : Array String) : IO Unit := do\n  let rs \u2190 fileNames.mapM fun fn => do\n    try\n      let deps \u2190 parseImports' (\u2190 IO.FS.readFile \u27e8fn\u27e9) fn\n      return { imports? := some deps }\n    catch e => return { errors := #[e.toString] }\n  IO.println (toJson { imports := rs : PrintImportsResult } |>.compress)", "start": [215, 1], "end": [222, 73], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Mixfix.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.expandMixfix", "code": "@[builtin_macro Lean.Parser.Command.mixfix] def expandMixfix : Macro := fun stx =>\n  withAttrKindGlobal stx fun stx => do\n    match stx with\n    | `($[$doc?:docComment]? $[@[$attrs?,*]]? infixl:$prec $[(name := $name)]? $[(priority := $prio)]? $op => $f) =>\n      let prec1 := quote <| (\u2190 evalPrec prec) + 1\n      `($[$doc?:docComment]? $[@[$attrs?,*]]? notation:$prec $[(name := $name)]? $[(priority := $prio)]? lhs:$prec $op:str rhs:$prec1 => $f lhs rhs)\n    | `($[$doc?:docComment]? $[@[$attrs?,*]]? infix:$prec $[(name := $name)]? $[(priority := $prio)]? $op => $f) =>\n      let prec1 := quote <| (\u2190 evalPrec prec) + 1\n      `($[$doc?:docComment]? $[@[$attrs?,*]]? notation:$prec $[(name := $name)]? $[(priority := $prio)]? lhs:$prec1 $op:str rhs:$prec1 => $f lhs rhs)\n    | `($[$doc?:docComment]? $[@[$attrs?,*]]? infixr:$prec $[(name := $name)]? $[(priority := $prio)]? $op => $f) =>\n      let prec1 := quote <| (\u2190 evalPrec prec) + 1\n      `($[$doc?:docComment]? $[@[$attrs?,*]]? notation:$prec $[(name := $name)]? $[(priority := $prio)]? lhs:$prec1 $op:str rhs:$prec => $f lhs rhs)\n    | `($[$doc?:docComment]? $[@[$attrs?,*]]? prefix:$prec $[(name := $name)]? $[(priority := $prio)]? $op => $f) =>\n      `($[$doc?:docComment]? $[@[$attrs?,*]]? notation:$prec $[(name := $name)]? $[(priority := $prio)]? $op:str arg:$prec => $f arg)\n    | `($[$doc?:docComment]? $[@[$attrs?,*]]? postfix:$prec $[(name := $name)]? $[(priority := $prio)]? $op => $f) =>\n      `($[$doc?:docComment]? $[@[$attrs?,*]]? notation:$prec $[(name := $name)]? $[(priority := $prio)]? arg:$prec $op:str => $f arg)\n    | _ => Macro.throwUnsupported\nwhere\n  withAttrKindGlobal stx f := do\n    let attrKind := stx[2]\n    let stx  := stx.setArg 2 mkAttrKindGlobal\n    let stx \u2190 f stx\n    return stx.raw.setArg 2 attrKind", "start": [10, 1], "end": [33, 37], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Macro.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/MacroArgUtil.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.elabMacro", "code": "@[builtin_command_elab Lean.Parser.Command.macro] def elabMacro : CommandElab\n  | `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind\n      macro%$tk$[:$prec?]? $[(name := $name?)]? $[(priority := $prio?)]? $args:macroArg* : $cat => $rhs) =>\n    withRef (mkNullNode #[tk, rhs]) do\n      let prio  \u2190 liftMacroM <| evalOptPrio prio?\n      let (stxParts, patArgs) := (\u2190 args.mapM expandMacroArg).unzip\n      let name \u2190 match name? with\n        | some name => pure name.getId\n        | none => addMacroScopeIfLocal (\u2190 liftMacroM <| mkNameFromParserSyntax cat.getId (mkNullNode stxParts)) attrKind\n      \n      let pat := \u27e8mkNode ((\u2190 getCurrNamespace) ++ name) patArgs\u27e9\n      let stxCmd \u2190 `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind\n        syntax$[:$prec?]?\n          (name := $(name?.getD (mkIdentFrom tk name (canonical := true))))\n          (priority := $(quote prio):num)\n          $[$stxParts]* : $cat)\n      let rhs := rhs.raw\n      let macroRulesCmd \u2190 if rhs.getArgs.size == 1 then\n        let rhs := \u27e8rhs[0]\u27e9\n        `($[$doc?:docComment]? macro_rules | `($pat) => Functor.map (@TSyntax.raw $(quote cat.getId.eraseMacroScopes)) $rhs)\n      else\n        let rhsBody := \u27e8rhs[1]\u27e9\n        `($[$doc?:docComment]? macro_rules | `($pat) => `($rhsBody))\n      elabCommand <| mkNullNode #[stxCmd, macroRulesCmd]\n  | _ => throwUnsupportedSyntax", "start": [13, 1], "end": [43, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/MacroRules.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/AuxDef.lean", "lake-packages/lean4/src/lean/Lean/Elab/Syntax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.elabMacroRulesAux", "code": "def elabMacroRulesAux (doc? : Option (TSyntax ``docComment))\n    (attrs? : Option (TSepArray ``attrInstance \",\")) (attrKind : TSyntax ``attrKind)\n    (tk : Syntax) (k : SyntaxNodeKind) (alts : Array (TSyntax ``matchAlt)) :\n    CommandElabM Syntax := do\n  let alts \u2190 alts.mapM fun (alt : TSyntax ``matchAlt) => match alt with\n    | `(matchAltExpr| | $pats,* => $rhs) => do\n      let pat := pats.elemsAndSeps[0]!\n      if !pat.isQuot then\n        throwUnsupportedSyntax\n      let quoted := getQuotContent pat\n      let k' := quoted.getKind\n      if checkRuleKind k' k then\n        pure alt\n      else if k' == choiceKind then\n         match quoted.getArgs.find? fun quotAlt => checkRuleKind quotAlt.getKind k with\n         | none        => throwErrorAt alt \"invalid macro_rules alternative, expected syntax node kind '{k}'\"\n         | some quoted =>\n           let pat := pat.setArg 1 quoted\n           let pats := pats.elemsAndSeps.set! 0 pat\n           `(matchAltExpr| | $(\u27e8pats\u27e9),* => $rhs)\n      else\n        throwErrorAt alt \"invalid macro_rules alternative, unexpected syntax node kind '{k'}'\"\n    | _ => throwUnsupportedSyntax\n  let attr \u2190 `(attrInstance| $attrKind macro $(Lean.mkIdent k))\n  let attrs := match attrs? with\n    | some attrs => attrs.getElems.push attr\n    | none => #[attr]\n  `($[$doc?:docComment]? @[$attrs,*]\n    aux_def macroRules $(mkIdentFrom tk k (canonical := true)) : Macro :=\n     fun $alts:matchAlt* | _ => no_error_if_unused% throw Lean.Macro.Exception.unsupportedSyntax)", "start": [14, 1], "end": [47, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabMacroRules", "code": "@[builtin_command_elab \u00abmacro_rules\u00bb] def elabMacroRules : CommandElab :=\n  adaptExpander fun stx => match stx with\n  | `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind macro_rules%$tk $alts:matchAlt*) =>\n    withRef (mkNullNode #[tk, mkNullNode alts]) do\n      expandNoKindMacroRulesAux alts \"macro_rules\" fun kind? alts =>\n        `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind macro_rules $[(kind := $(mkIdent <$> kind?))]? $alts:matchAlt*)\n  | `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind macro_rules%$tk (kind := $kind) | $x:ident => $rhs) =>\n    withRef (mkNullNode #[tk, rhs]) do\n      let attr \u2190 `(attrInstance| $attrKind:attrKind macro $kind)\n      let attrs := match attrs? with\n        | some attrs => attrs.getElems.push attr\n        | none => #[attr]\n      `($[$doc?:docComment]? @[$attrs,*]\n        aux_def $(mkIdentFrom tk kind.getId (canonical := true)) $kind : Macro := fun $x:ident => $rhs)\n  | `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind macro_rules%$tk (kind := $kind) $alts:matchAlt*) =>\n    withRef (mkNullNode #[tk, mkNullNode alts]) do\n      elabMacroRulesAux doc? attrs? attrKind tk (\u2190 resolveSyntaxKind kind.getId) alts\n  | _  => throwUnsupportedSyntax", "start": [49, 1], "end": [67, 33], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Quotation.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Quotation/Util.lean", "lake-packages/lean4/src/lean/Lean/ResolveName.lean", "lake-packages/lean4/src/lean/Lean/Elab/Quotation/Precheck.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Lean/Syntax.lean", "lake-packages/lean4/src/lean/Lean/Elab/Syntax.lean", "lake-packages/lean4/src/lean/Lean/Parser/Syntax.lean"], "premises": [{"full_name": "Lean.Elab.Term.Quotation.floatOutAntiquotTerms", "code": "private partial def floatOutAntiquotTerms (stx : Syntax) : StateT (Syntax \u2192 TermElabM Syntax) TermElabM Syntax :=\n  if isAntiquots stx && !isEscapedAntiquot (getCanonicalAntiquot stx) then\n    let e := getAntiquotTerm (getCanonicalAntiquot stx)\n    if !e.isIdent || !e.getId.isAtomic then\n      withFreshMacroScope do\n        let a \u2190 `(__stx_lift)\n        modify (fun _ (stx : Syntax) => (`(let $a:ident := $e; $stx) : TermElabM Syntax))\n        let stx := if stx.isOfKind choiceKind then\n            mkNullNode <| stx.getArgs.map (\u00b7.setArg 2 a)\n          else\n            stx.setArg 2 a\n        return stx\n    else\n      return stx\n  else if let Syntax.node i k args := stx then\n    return Syntax.node i k (\u2190 args.mapM floatOutAntiquotTerms)\n  else\n    return stx", "start": [25, 1], "end": [43, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.getSepFromSplice", "code": "private def getSepFromSplice (splice : Syntax) : String :=\n  if let Syntax.atom _ sep := getAntiquotSpliceSuffix splice then\n    sep.dropRight 1 else\n    unreachable!", "start": [45, 1], "end": [49, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.getSepStxFromSplice", "code": "private def getSepStxFromSplice (splice : Syntax) : Syntax := Unhygienic.run do\n  match getSepFromSplice splice with\n  | \"\" => `(mkNullNode) | sep => `(mkAtom $(Syntax.mkStrLit sep))", "start": [51, 1], "end": [54, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.mkTuple", "code": "partial def mkTuple : Array Syntax \u2192 TermElabM Syntax\n  | #[]  => `(Unit.unit)\n  | #[e] => return e\n  | es   => do\n    let stx \u2190 mkTuple (es.eraseIdx 0)\n    `(Prod.mk $(es[0]!) $stx)", "start": [56, 1], "end": [61, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.resolveSectionVariable", "code": "def resolveSectionVariable (sectionVars : NameMap Name) (id : Name) : List (Name \u00d7 List String) :=\n  let extractionResult := extractMacroScopes id\n  let rec loop : Name \u2192 List String \u2192 List (Name \u00d7 List String)\n    | id@(.str p s), projs =>\n      let id := { extractionResult with name := id }.review\n      match sectionVars.find? id with\n      | some newId => [(newId, projs)]\n      | none       => loop p (s::projs)\n    | _, _ => []\n  loop extractionResult.name []", "start": [63, 1], "end": [74, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.ArrayStxBuilder", "code": "def ArrayStxBuilder := Sum (Array Term) Term", "start": [76, 1], "end": [77, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.ArrayStxBuilder.empty", "code": "def empty : ArrayStxBuilder := .inl #[]", "start": [81, 1], "end": [81, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.ArrayStxBuilder.build", "code": "def build : ArrayStxBuilder \u2192 Term\n  | .inl elems => quote elems\n  | .inr arr   => arr", "start": [83, 1], "end": [85, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.ArrayStxBuilder.push", "code": "def push (b : ArrayStxBuilder) (elem : Syntax) : ArrayStxBuilder :=\n  match b with\n  | .inl elems => .inl <| elems.push elem\n  | .inr arr   => .inr <| mkCApp ``Array.push #[arr, elem]", "start": [87, 1], "end": [90, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.ArrayStxBuilder.append", "code": "def append (b : ArrayStxBuilder) (arr : Syntax) (appendName := ``Array.append) : ArrayStxBuilder :=\n  .inr <| mkCApp appendName #[b.build, arr]", "start": [92, 1], "end": [93, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.ArrayStxBuilder.mkNode", "code": "def mkNode (b : ArrayStxBuilder) (k : SyntaxNodeKind) : TermElabM Term := do\n  let k := quote k\n  match b with\n  | .inl #[a\u2081] => `(Syntax.node1 info $(k) $(a\u2081))\n  | .inl #[a\u2081, a\u2082] => `(Syntax.node2 info $(k) $(a\u2081) $(a\u2082))\n  | .inl #[a\u2081, a\u2082, a\u2083] => `(Syntax.node3 info $(k) $(a\u2081) $(a\u2082) $(a\u2083))\n  | .inl #[a\u2081, a\u2082, a\u2083, a\u2084] => `(Syntax.node4 info $(k) $(a\u2081) $(a\u2082) $(a\u2083) $(a\u2084))\n  | .inl #[a\u2081, a\u2082, a\u2083, a\u2084, a\u2085] => `(Syntax.node5 info $(k) $(a\u2081) $(a\u2082) $(a\u2083) $(a\u2084) $(a\u2085))\n  | .inl #[a\u2081, a\u2082, a\u2083, a\u2084, a\u2085, a\u2086] => `(Syntax.node6 info $(k) $(a\u2081) $(a\u2082) $(a\u2083) $(a\u2084) $(a\u2085) $(a\u2086))\n  | .inl #[a\u2081, a\u2082, a\u2083, a\u2084, a\u2085, a\u2086, a\u2087] => `(Syntax.node7 info $(k) $(a\u2081) $(a\u2082) $(a\u2083) $(a\u2084) $(a\u2085) $(a\u2086) $(a\u2087))\n  | .inl #[a\u2081, a\u2082, a\u2083, a\u2084, a\u2085, a\u2086, a\u2087, a\u2088] => `(Syntax.node8 info $(k) $(a\u2081) $(a\u2082) $(a\u2083) $(a\u2084) $(a\u2085) $(a\u2086) $(a\u2087) $(a\u2088))\n  | _ => `(Syntax.node info $(k) $(b.build))", "start": [95, 1], "end": [106, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.tryAddSyntaxNodeKindInfo", "code": "def tryAddSyntaxNodeKindInfo (stx : Syntax) (k : SyntaxNodeKind) : TermElabM Unit := do\n  if (\u2190 getEnv).contains k then\n    addTermInfo' stx (\u2190 mkConstWithFreshMVarLevels k)\n  else\n    let k := ``Lean.Parser.Category ++ k\n    if (\u2190 getEnv).contains k then\n      addTermInfo' stx (\u2190 mkConstWithFreshMVarLevels k)", "start": [110, 1], "end": [117, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.quoteSyntax", "code": "private partial def quoteSyntax : Syntax \u2192 TermElabM Term\n  | Syntax.ident _ rawVal val preresolved => do\n    if !hygiene.get (\u2190 getOptions) then\n      return \u2190 `(Syntax.ident info $(quote rawVal) $(quote val) $(quote preresolved))\n    let consts \u2190 resolveGlobalName val\n    let sectionVars := resolveSectionVariable (\u2190 read).sectionVars val\n    let namespaces \u2190 resolveNamespaceCore (allowEmpty := true) val\n    let preresolved := (consts ++ sectionVars).map (fun (n, projs) => Preresolved.decl n projs) ++\n      namespaces.map .namespace ++\n      preresolved\n    let val := quote val\n    `(Syntax.ident info $(quote rawVal) (addMacroScope mainModule $val scp) $(quote preresolved))\n  | stx@(Syntax.node _ k _) => do\n    if let some (k, _) := stx.antiquotKind? then\n      if let some name := getAntiquotKindSpec? stx then\n        tryAddSyntaxNodeKindInfo name k\n    if isAntiquots stx && !isEscapedAntiquot (getCanonicalAntiquot stx) then\n      let ks := antiquotKinds stx\n      `(@TSyntax.raw $(quote <| ks.map (\u00b7.1)) $(getAntiquotTerm (getCanonicalAntiquot stx)))\n    else if isTokenAntiquot stx && !isEscapedAntiquot stx then\n      match stx[0] with\n      | Syntax.atom _ val => `(Syntax.atom (SourceInfo.fromRef $(getAntiquotTerm stx) (canonical := true)) $(quote val))\n      | _                 => throwErrorAt stx \"expected token\"\n    else if isAntiquotSuffixSplice stx && !isEscapedAntiquot (getCanonicalAntiquot (getAntiquotSuffixSpliceInner stx)) then\n      throwErrorAt stx \"unexpected antiquotation splice\"\n    else if isAntiquotSplice stx && !isEscapedAntiquot stx then\n      throwErrorAt stx \"unexpected antiquotation splice\"\n    else\n      let stx := unescapeAntiquot stx\n      let mut args := ArrayStxBuilder.empty\n      let appendName := if (\u2190 getEnv).contains ``Array.append then ``Array.append else ``Array.appendCore\n      for arg in stx.getArgs do\n        if k == nullKind && isAntiquotSuffixSplice arg && !isEscapedAntiquot (getCanonicalAntiquot (getAntiquotSuffixSpliceInner arg)) then\n          let antiquot := getAntiquotSuffixSpliceInner arg\n          let ks := antiquotKinds antiquot |>.map (\u00b7.1)\n          let val := getAntiquotTerm (getCanonicalAntiquot antiquot)\n          args := args.append (appendName := appendName) <| \u2190\n            match antiquotSuffixSplice? arg with\n            | `optional => `(match Option.map (@TSyntax.raw $(quote ks)) $val:term with\n              | some x => Array.empty.push x\n              | none   => Array.empty)\n            | `many     => `(@TSyntaxArray.raw $(quote ks) $val)\n            | `sepBy    =>\n              let sep := quote <| getSepFromSplice arg\n              `(@TSepArray.elemsAndSeps $(quote ks) $sep $val)\n            | k         => throwErrorAt arg \"invalid antiquotation suffix splice kind '{k}'\"\n        else if k == nullKind && isAntiquotSplice arg && !isEscapedAntiquot arg then\n          let k := antiquotSpliceKind? arg\n          let (arg, bindLets) \u2190 floatOutAntiquotTerms arg |>.run pure\n          let inner \u2190 (getAntiquotSpliceContents arg).mapM quoteSyntax\n          let ids \u2190 getAntiquotationIds arg\n          if ids.isEmpty then\n            throwErrorAt stx \"antiquotation splice must contain at least one antiquotation\"\n          let arr \u2190 match k with\n            | `optional => `(match $[$ids:ident],* with\n                | $[some $ids:ident],* => $(quote inner)\n                | $[_%$ids],*          => Array.empty)\n            | _ =>\n              let arr \u2190 ids[:ids.size-1].foldrM (fun id arr => `(Array.zip $id:ident $arr)) ids.back\n              `(Array.map (fun $(\u2190 mkTuple ids) => $(inner[0]!)) $arr)\n          let arr \u2190 if k == `sepBy then\n            `(mkSepArray $arr $(getSepStxFromSplice arg))\n          else\n            pure arr\n          let arr \u2190 bindLets arr\n          args := args.append (appendName := appendName) arr\n        else do\n          let arg \u2190 quoteSyntax arg\n          args := args.push arg\n      args.mkNode k\n  | Syntax.atom _ val =>\n    `(Syntax.atom info $(quote val))\n  | Syntax.missing => throwUnsupportedSyntax", "start": [124, 1], "end": [206, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.addNamedQuotInfo", "code": "def addNamedQuotInfo (stx : Syntax) (k : SyntaxNodeKind) : TermElabM SyntaxNodeKind := do\n  if stx.getNumArgs == 3 && stx[0].isAtom then\n    let s := stx[0].getAtomVal\n    if s.length > 3 then\n      if let (some l, some r) := (stx[0].getPos? true, stx[0].getTailPos? true) then\n        let name := stx[0].setInfo <| .synthetic \u27e8l.1 + 2\u27e9 \u27e8r.1 - 1\u27e9 (canonical := true)\n        tryAddSyntaxNodeKindInfo name k\n  pure k", "start": [208, 1], "end": [216, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.getQuotKind", "code": "def getQuotKind (stx : Syntax) : TermElabM SyntaxNodeKind := do\n  match stx.getKind with\n  | ``Parser.Command.quot => addNamedQuotInfo stx `command\n  | ``Parser.Term.quot => addNamedQuotInfo stx `term\n  | ``Parser.Tactic.quot => addNamedQuotInfo stx `tactic\n  | ``Parser.Tactic.quotSeq => addNamedQuotInfo stx `tactic.seq\n  | .str kind \"quot\" => addNamedQuotInfo stx kind\n  | ``dynamicQuot => match \u2190 elabParserName stx[1] with\n    | .parser n _ => return n\n    | .category c => return c\n  | k => throwError \"unexpected quotation kind {k}\"", "start": [218, 1], "end": [228, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.mkSyntaxQuotation", "code": "def mkSyntaxQuotation (stx : Syntax) (kind : Name) : TermElabM Syntax := do\n  \n  `(Bind.bind MonadRef.mkInfoFromRefPos (fun info =>\n      Bind.bind getCurrMacroScope (fun scp =>\n        Bind.bind getMainModule (fun mainModule => Pure.pure (@TSyntax.mk $(quote kind) $stx)))))", "start": [230, 1], "end": [238, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.stxQuot.expand", "code": "def stxQuot.expand (stx : Syntax) : TermElabM Syntax := do\n  let stx := if stx.getNumArgs == 1 then stx[0] else stx\n  let kind \u2190 getQuotKind stx\n  let stx \u2190 quoteSyntax stx.getQuotContent\n  mkSyntaxQuotation stx kind", "start": [255, 1], "end": [259, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.elabQuot", "code": "@[builtin_term_elab $kind:ident] def elabQuot : TermElab := adaptExpander stxQuot.expand", "start": [262, 5], "end": [262, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.Alt", "code": "private abbrev Alt := List Term \u00d7 Term", "start": [272, 1], "end": [273, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.HeadCheck", "code": "inductive HeadCheck where\n  \n  | unconditional\n  \n  | shape (k : List SyntaxNodeKind) (arity : Option Nat)\n  \n  | slice (numPrefix numSuffix : Nat)\n  \n  | other (pat : Syntax)", "start": [275, 1], "end": [296, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.MatchResult", "code": "inductive MatchResult where\n  \n  | covered (f : Alt \u2192 TermElabM Alt) (exhaustive : Bool)\n  \n  | uncovered\n  \n  | undecided", "start": [300, 1], "end": [308, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.HeadInfo", "code": "structure HeadInfo where\n  \n  check : HeadCheck\n  \n  onMatch (taken : HeadCheck) : MatchResult\n  \n  doMatch (yes : (newDiscrs : List Term) \u2192 TermElabM Term) (no : TermElabM Term) : TermElabM Term", "start": [318, 1], "end": [325, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.noOpMatchAdaptPats", "code": "private def noOpMatchAdaptPats : HeadCheck \u2192 Alt \u2192 Alt\n  | shape _ (some sz), (pats, rhs) => (List.replicate sz (Unhygienic.run `(_)) ++ pats, rhs)\n  | slice p s,         (pats, rhs) => (List.replicate (p + 1 + s) (Unhygienic.run `(_)) ++ pats, rhs)\n  | _,                 alt         => alt", "start": [327, 1], "end": [331, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.adaptRhs", "code": "private def adaptRhs (fn : Term \u2192 TermElabM Term) : Alt \u2192 TermElabM Alt\n  | (pats, rhs) => return (pats, \u2190 fn rhs)", "start": [333, 1], "end": [334, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.getHeadInfo", "code": "private partial def getHeadInfo (alt : Alt) : TermElabM HeadInfo :=\n  let pat := alt.fst.head!\n  let unconditionally rhsFn := pure {\n    check := unconditional,\n    doMatch := fun yes _ => yes [],\n    onMatch := fun taken => covered (adaptRhs rhsFn \u2218 noOpMatchAdaptPats taken) (taken matches unconditional)\n  }\n  if isQuot pat then do\n    let quoted := getQuotContent pat\n    if let some (k, _) := quoted.antiquotKind? then\n      if let some name := getAntiquotKindSpec? quoted then\n        tryAddSyntaxNodeKindInfo name k\n    if quoted.isAtom || quoted.isOfKind `patternIgnore then\n      unconditionally pure\n    else if quoted.isTokenAntiquot then\n      unconditionally (`(have $(quoted.getAntiquotTerm) := __discr; $(\u00b7)))\n    else if isAntiquots quoted && !isEscapedAntiquot (getCanonicalAntiquot quoted) then\n      let (ks, pseudoKinds) := antiquotKinds quoted |>.unzip\n      let rhsFn := match getAntiquotTerm (getCanonicalAntiquot quoted) with\n        | `(_)         => pure\n        | `($id:ident) => fun stx => `(have $id := @TSyntax.mk $(quote ks) __discr; $(stx))\n        | anti =>         fun _   => throwErrorAt anti \"unsupported antiquotation kind in pattern\"\n      if (getCanonicalAntiquot quoted)[3].isNone || pseudoKinds.all id then unconditionally rhsFn else pure {\n        check   := shape ks none,\n        onMatch := fun\n          | taken@(shape ks' sz) =>\n            if ks' == ks then\n              covered (adaptRhs rhsFn \u2218 noOpMatchAdaptPats taken) (exhaustive := sz.isNone)\n            else uncovered\n          | _ => undecided,\n        doMatch := fun yes no => do\n          let cond \u2190 ks.foldlM (fun cond k => `(or $cond (Syntax.isOfKind __discr $(quote k)))) (\u2190 `(false))\n          `(cond $cond $(\u2190 yes []) $(\u2190 no)),\n      }\n    else if isAntiquotSuffixSplice quoted then throwErrorAt quoted \"unexpected antiquotation splice\"\n    else if isAntiquotSplice quoted then throwErrorAt quoted \"unexpected antiquotation splice\"\n    else if quoted.getArgs.size == 1 && isAntiquotSuffixSplice quoted[0] then\n      let inner := getAntiquotSuffixSpliceInner quoted[0]\n      let ks := antiquotKinds inner |>.map (\u00b7.1)\n      unconditionally <| match getAntiquotTerm (getCanonicalAntiquot inner) with\n        | `(_)         => pure\n        | `($id:ident) => fun rhs => match antiquotSuffixSplice? quoted[0] with\n          | `optional => `(have $id := Option.map (@TSyntax.mk $(quote ks)) (Syntax.getOptional? __discr); $rhs)\n          | `many     => `(have $id := @TSyntaxArray.mk $(quote ks) (Syntax.getArgs __discr); $rhs)\n          | `sepBy    => `(have $id := @TSepArray.mk $(quote ks) $(quote <| getSepFromSplice quoted[0]) (Syntax.getArgs __discr); $rhs)\n          | k         => throwErrorAt quoted \"invalid antiquotation suffix splice kind '{k}'\"\n        | anti         => fun _   => throwErrorAt anti \"unsupported antiquotation kind in pattern\"\n    else if quoted.getArgs.size == 1 && isAntiquotSplice quoted[0] then pure {\n      check   := other pat,\n      onMatch := fun\n        | other pat' => if pat' == pat then covered pure (exhaustive := true) else undecided\n        | _          => undecided,\n      doMatch := fun yes no => do\n        let splice := quoted[0]\n        let k := antiquotSpliceKind? splice\n        let contents := getAntiquotSpliceContents splice\n        let ids \u2190 getAntiquotationIds splice\n        let yes \u2190 yes []\n        let no \u2190 no\n        match k with\n        | `optional =>\n          let nones := mkArray ids.size (\u2190 `(none))\n          `(let_delayed yes _ $ids* := $yes;\n            if __discr.isNone then yes () $[ $nones]*\n            else match __discr with\n              | `($(mkNullNode contents)) => yes () $[ (some $ids)]*\n              | _                         => $no)\n        | _ =>\n          let mut discrs \u2190 `(Syntax.getArgs __discr)\n          if k == `sepBy then\n            discrs \u2190 `(Array.getSepElems $discrs)\n          let tuple \u2190 mkTuple ids\n          let mut yes := yes\n          let resId \u2190 match ids with\n            | #[id] => pure id\n            | _     =>\n              for id in ids do\n                yes \u2190 `(have $id := tuples.map (fun $tuple => $id); $yes)\n              `(tuples)\n          let contents := if contents.size == 1\n            then contents[0]!\n            else mkNullNode contents\n          `(match ($(discrs).sequenceMap fun\n                | `($contents) => no_error_if_unused% some $tuple\n                | _            => no_error_if_unused% none) with\n              | some $resId => $yes\n              | none => $no)\n    }\n    else if let some idx := quoted.getArgs.findIdx? (fun arg => isAntiquotSuffixSplice arg || isAntiquotSplice arg) then do\n      \n      let numSuffix := quoted.getNumArgs - 1 - idx\n      pure {\n        check    := slice idx numSuffix\n        onMatch  := fun\n          | slice p s =>\n            if p == idx && s == numSuffix then\n              let argPats := quoted.getArgs.mapIdx fun i arg =>\n                let arg := if (i : Nat) == idx then mkNullNode #[arg] else arg\n                Unhygienic.run `(`($(arg)))\n              covered (fun (pats, rhs) => pure (argPats.toList ++ pats, rhs)) (exhaustive := true)\n            else uncovered\n          | _ => undecided\n        doMatch := fun yes no => do\n          let prefixDiscrs \u2190 (List.range idx).mapM (`(Syntax.getArg __discr $(quote \u00b7)))\n          let sliceDiscr \u2190 `(mkNullNode (__discr.getArgs.extract $(quote idx) (Nat.sub __discr.getNumArgs $(quote numSuffix))))\n          let suffixDiscrs \u2190 (List.range numSuffix).mapM fun i =>\n            `(Syntax.getArg __discr (Nat.sub __discr.getNumArgs $(quote (numSuffix - i))))\n          `(ite (GE.ge __discr.getNumArgs $(quote (quoted.getNumArgs - 1)))\n              $(\u2190 yes (prefixDiscrs ++ sliceDiscr :: suffixDiscrs))\n              $(\u2190 no))\n      }\n    else\n      let quoted  := unescapeAntiquot quoted\n      let kind := quoted.getKind\n      let lit := isLitKind kind\n      let argPats := quoted.getArgs.map fun arg => Unhygienic.run `(`($(arg)))\n      pure {\n        check :=\n          if quoted.isIdent || lit then\n            other quoted\n          else\n            shape [kind] argPats.size,\n        onMatch := fun\n          | other stx' =>\n            if quoted.isIdent || lit then\n              if quoted == stx' then\n                covered pure (exhaustive := true)\n              else\n                uncovered\n            else\n              undecided\n          | shape ks sz =>\n            if ks == [kind] && sz == argPats.size then\n              covered (fun (pats, rhs) => pure (argPats.toList ++ pats, rhs)) (exhaustive := true)\n            else\n              uncovered\n          | _ => undecided,\n        doMatch := fun yes no => do\n          let (cond, newDiscrs) \u2190 if lit then\n            let cond \u2190 `(Syntax.matchesLit __discr $(quote kind) $(quote (isLit? kind quoted).get!))\n            pure (cond, [])\n          else\n            let cond \u2190 match kind with\n            | `null => `(Syntax.matchesNull __discr $(quote argPats.size))\n            | `ident => `(Syntax.matchesIdent __discr $(quote quoted.getId))\n            | _     => `(Syntax.isOfKind __discr $(quote kind))\n            let newDiscrs \u2190 (List.range argPats.size).mapM fun i => `(Syntax.getArg __discr $(quote i))\n            pure (cond, newDiscrs)\n          `(ite (Eq $cond true) $(\u2190 yes newDiscrs) $(\u2190 no))\n      }\n  else match pat with\n    | `(_)              => unconditionally pure\n    | `($id:ident)      => unconditionally (`(have $id := __discr; $(\u00b7)))\n    | `($id:ident@$pat) => do\n      let info \u2190 getHeadInfo (pat::alt.1.tail!, alt.2)\n      return { info with onMatch := fun taken => match info.onMatch taken with\n          | covered f exh => covered (fun alt => f alt >>= adaptRhs (`(have $id := __discr; $(\u00b7)))) exh\n          | r             => r }\n    | _               => throwErrorAt pat \"match (syntax) : unexpected pattern kind {pat}\"", "start": [336, 1], "end": [523, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.deduplicate", "code": "private def deduplicate (floatedLetDecls : Array Syntax) : Alt \u2192 TermElabM (Array Syntax \u00d7 Alt)\n  | (pats, rhs) => do\n    if let `($_:ident $[ $_:ident]*) := rhs then\n      return (floatedLetDecls, (pats, rhs))\n    withFreshMacroScope do\n      match (\u2190 getPatternsVars pats.toArray) with\n      | #[] =>\n        let rhs' \u2190 `(rhs Unit.unit)\n        pure (floatedLetDecls.push (\u2190 `(letDecl|rhs _ := $rhs)), (pats, rhs'))\n      | vars =>\n        let rhs' \u2190 `(rhs $vars*)\n        pure (floatedLetDecls.push (\u2190 `(letDecl|rhs $vars:ident* := $rhs)), (pats, rhs'))", "start": [525, 1], "end": [540, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.compileStxMatch", "code": "private partial def compileStxMatch (discrs : List Term) (alts : List Alt) : TermElabM Syntax := do\n  trace[Elab.match_syntax] \"match {discrs} with {alts}\"\n  match discrs, alts with\n  | [],            ([], rhs)::_ => pure rhs  | _,             []           =>\n   logError \"non-exhaustive 'match' (syntax)\"\n   pure Syntax.missing\n  | discr::discrs, alt::alts    => do\n    let info \u2190 getHeadInfo alt\n    let alts := (info.onMatch info.check, alt) :: (\u2190 alts.mapM fun alt =>\n      return ((\u2190 getHeadInfo alt).onMatch info.check, alt))\n    let mut yesAlts           := #[]\n    let mut undecidedAlts     := #[]\n    let mut nonExhaustiveAlts := #[]\n    let mut floatedLetDecls   := #[]\n    for (x, alt') in alts do\n      let mut alt' := alt'\n      trace[Elab.match_syntax.onMatch] \"{alt'} ~> {repr x}\"\n      match x with\n      | covered f exh =>\n        if undecidedAlts.isEmpty then\n          yesAlts \u2190 yesAlts.push <$> f (alt'.1.tail!, alt'.2)\n          if !exh then\n            nonExhaustiveAlts := nonExhaustiveAlts.push alt'\n        else\n          (floatedLetDecls, alt') \u2190 deduplicate floatedLetDecls alt'\n          undecidedAlts := undecidedAlts.push alt'\n          nonExhaustiveAlts := nonExhaustiveAlts.push alt'\n      | undecided =>\n        (floatedLetDecls, alt') \u2190 deduplicate floatedLetDecls alt'\n        undecidedAlts := undecidedAlts.push alt'\n        nonExhaustiveAlts := nonExhaustiveAlts.push alt'\n      | uncovered =>\n        nonExhaustiveAlts := nonExhaustiveAlts.push alt'\n    let mut stx \u2190 info.doMatch\n      (yes := fun newDiscrs => do\n        let mut yesAlts := yesAlts\n        if !undecidedAlts.isEmpty then\n          let vars \u2190 discrs.mapM fun _ => withFreshMacroScope `(__discr)\n          let pats := List.replicate newDiscrs.length (Unhygienic.run `(_)) ++ vars\n          let alts \u2190 undecidedAlts.mapM fun alt => `(matchAltExpr| | $(alt.1.toArray),* => no_error_if_unused% $(alt.2))\n          let rhs  \u2190 `(match __discr, $[$(vars.toArray):term],* with $alts:matchAlt*)\n          yesAlts := yesAlts.push (pats, rhs)\n        withFreshMacroScope $ compileStxMatch (newDiscrs ++ discrs) yesAlts.toList)\n      (no := withFreshMacroScope $ compileStxMatch (discr::discrs) nonExhaustiveAlts.toList)\n    for d in floatedLetDecls do\n      stx \u2190 `(let_delayed $d:letDecl; $stx)\n    `(have __discr := $discr; $stx)\n  | _, _ => unreachable!", "start": [542, 1], "end": [593, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.IdxSet", "code": "abbrev IdxSet := HashSet Nat", "start": [595, 1], "end": [595, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.hasNoErrorIfUnused", "code": "private partial def hasNoErrorIfUnused : Syntax \u2192 Bool\n  | `(no_error_if_unused% $_) => true\n  | `(clear% $_; $body) => hasNoErrorIfUnused body\n  | _ => false", "start": [597, 1], "end": [600, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.markRhss", "code": "private def markRhss (rhss : Array Term) : TermElabM (NameMap Nat \u00d7 IdxSet \u00d7 Array Term) := do\n  let mut altIdxMap : NameMap Nat := {}\n  let mut ignoreIfUnused : IdxSet := {}\n  let mut rhssNew := #[]\n  for rhs in rhss do\n    if hasNoErrorIfUnused rhs then\n      ignoreIfUnused := ignoreIfUnused.insert rhssNew.size\n    let (idx, rhs) \u2190 withFreshMacroScope do\n      let idx \u2190 `(alt_idx)\n      let rhs \u2190 `(alt_idx $rhs)\n      return (idx, rhs)\n    altIdxMap := altIdxMap.insert idx.getId rhssNew.size\n    rhssNew := rhssNew.push rhs\n  return (altIdxMap, ignoreIfUnused, rhssNew)", "start": [602, 1], "end": [625, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.findUsedAlts", "code": "private partial def findUsedAlts (stx : Syntax) (altIdxMap : NameMap Nat) : TermElabM (Syntax \u00d7 IdxSet) := do\n  go stx |>.run {}\nwhere\n  go (stx : Syntax) : StateRefT IdxSet TermElabM Syntax := do\n    match stx with\n    | `($id:ident $rhs:term) =>\n      if let some idx := altIdxMap.find? id.getId then\n        modify fun s => s.insert idx\n        return rhs\n    | _ => pure ()\n    match stx with\n    | .node info kind cs => return .node info kind (\u2190 cs.mapM go)\n    | _ => return stx", "start": [627, 1], "end": [645, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.checkUnusedAlts", "code": "private def checkUnusedAlts (stx : Syntax) (alts : Array Syntax) (altIdxMap : NameMap Nat) (ignoreIfUnused : IdxSet) : TermElabM Syntax := do\n  let (stx, used) \u2190 findUsedAlts stx altIdxMap\n  for i in [:alts.size] do\n    unless used.contains i || ignoreIfUnused.contains i do\n      logErrorAt alts[i]! s!\"redundant alternative #{i+1}\"\n  return stx", "start": [647, 1], "end": [657, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.match_syntax.expand", "code": "def match_syntax.expand (stx : Syntax) : TermElabM Syntax := do\n  match stx with\n  | `(match $[$discrs:term],* with $[|%$alt $[$patss],* => $rhss]*) => do\n    if !patss.any (\u00b7.any (fun\n      | `($_@$pat) => pat.raw.isQuot\n      | pat        => pat.raw.isQuot)) then\n      throwUnsupportedSyntax\n    let (altIdxMap, ignoreIfUnused, rhss) \u2190 markRhss rhss\n    patss.forM (\u00b7.forM fun \u27e8pat\u27e9 => do if pat.isQuot then _ \u2190 getQuotKind pat)\n    let stx \u2190 compileStxMatch discrs.toList (patss.map (\u00b7.toList) |>.zip rhss).toList\n    let stx \u2190 checkUnusedAlts stx alt altIdxMap ignoreIfUnused\n    trace[Elab.match_syntax.result] \"{stx}\"\n    return stx\n  | _ => throwUnsupportedSyntax", "start": [659, 1], "end": [675, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.elabMatchSyntax", "code": "@[builtin_term_elab \u00abmatch\u00bb] def elabMatchSyntax : TermElab :=\n  adaptExpander match_syntax.expand", "start": [677, 1], "end": [678, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.elabNoErrorIfUnused", "code": "@[builtin_term_elab noErrorIfUnused] def elabNoErrorIfUnused : TermElab := fun stx expectedType? =>\n  match stx with\n  | `(no_error_if_unused% $term) => elabTerm term expectedType?\n  | _ => throwUnsupportedSyntax", "start": [680, 1], "end": [683, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/MkInhabitant.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Eqns.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Structural.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/WF.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition/Main.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Notation.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/AuxDef.lean", "lake-packages/lean4/src/lean/Lean/Elab/BuiltinNotation.lean", "lake-packages/lean4/src/lean/Lean/Elab/Syntax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.antiquote", "code": "private partial def antiquote (vars : Array Syntax) : Syntax \u2192 Syntax\n  | stx => match stx with\n  | `($id:ident) =>\n    if (vars.findIdx? (fun var => var.getId == id.getId)).isSome then\n      mkAntiquotNode id (kind := `term) (isPseudoKind := true)\n    else\n      stx\n  | _ => match stx with\n    | Syntax.node i k args => Syntax.node i k (args.map (antiquote vars))\n    | stx => stx", "start": [15, 1], "end": [25, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addInheritDocDefault", "code": "def addInheritDocDefault (rhs : Term) (attrs? : Option (TSepArray ``attrInstance \",\")) :\n    Option (TSepArray ``attrInstance \",\") :=\n  attrs?.map fun attrs =>\n    match rhs with\n    | `($f:ident $_args*) | `($f:ident) =>\n      attrs.getElems.map fun stx => Unhygienic.run do\n        if let `(attrInstance| $attr:ident) := stx then\n          if attr.getId.eraseMacroScopes == `inherit_doc then\n            return \u2190 `(attrInstance| $attr:ident $f:ident)\n        pure \u27e8stx\u27e9\n    | _ => attrs", "start": [27, 2], "end": [37, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandNotationItemIntoSyntaxItem", "code": "def expandNotationItemIntoSyntaxItem : TSyntax ``notationItem \u2192 MacroM (TSyntax `stx)\n  | `(notationItem| $_:ident$[:$prec?]?) => `(stx| term $[:$prec?]?)\n  | `(notationItem| $s:str)              => `(stx| $s:str)\n  | _                                    => Macro.throwUnsupported", "start": [39, 1], "end": [43, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandNotationItemIntoPattern", "code": "def expandNotationItemIntoPattern (stx : Syntax) : MacroM Syntax :=\n  let k := stx.getKind\n  if k == `Lean.Parser.Command.identPrec then\n    return mkAntiquotNode stx[0] (kind := `term) (isPseudoKind := true)\n  else if k == strLitKind then\n    strLitToPattern stx\n  else\n    Macro.throwUnsupported", "start": [45, 1], "end": [53, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.removeParenthesesAux", "code": "def removeParenthesesAux (parens body : Syntax) : Syntax :=\n  match parens.getHeadInfo, body.getHeadInfo, body.getTailInfo, parens.getTailInfo with\n  | .original lead _ _ _, .original _ pos trail pos',\n    .original endLead endPos _ endPos', .original _ _ endTrail _ =>\n      body.setHeadInfo (.original lead pos trail pos') |>.setTailInfo (.original endLead endPos endTrail endPos')\n  | _, _, _, _ => body", "start": [55, 1], "end": [60, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.removeParentheses", "code": "partial def removeParentheses (stx : Syntax) : MacroM Syntax := do\n  match stx with\n  | `(($e)) => pure $ removeParenthesesAux stx (\u2190removeParentheses $ (\u2190Term.expandCDot? e).getD e)\n  | _ =>\n    match stx with\n    | .node info kind args => pure $ .node info kind (\u2190args.mapM removeParentheses)\n    | _ => pure stx", "start": [62, 1], "end": [68, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.hasDuplicateAntiquot", "code": "partial def hasDuplicateAntiquot (stxs : Array Syntax) : Bool := Id.run do\n  let mut seen := NameSet.empty\n  for stx in stxs do\n    for node in Syntax.topDown stx true do\n      if node.isAntiquot then\n        let ident := node.getAntiquotTerm.getId\n        if seen.contains ident then\n          return true\n        else\n          seen := seen.insert ident\n  pure false", "start": [70, 1], "end": [80, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkUnexpander", "code": "def mkUnexpander (attrKind : TSyntax ``attrKind) (pat qrhs : Term) : OptionT MacroM Syntax := do\n  let (c, args) \u2190 match qrhs with\n    | `($c:ident $args*) => pure (c, args)\n    | `($c:ident)        => pure (c, #[])\n    | _                  => failure\n  let [(c, [])] \u2190 Macro.resolveGlobalName c.getId | failure\n  \n  let args \u2190 liftM <| args.mapM removeParentheses\n  \n  guard !hasDuplicateAntiquot args\n  let lhs \u2190 `($$f:ident)\n  let lhs := Syntax.mkApp lhs (.mk args)\n  let lhsWithMoreArgs := flattenApp (\u2190 `($lhs $$moreArgs*))\n  let patWithMoreArgs := flattenApp (\u2190 `($pat $$moreArgs*))\n  `(@[$attrKind app_unexpander $(mkIdent c)]\n    aux_def unexpand $(mkIdent c) : Lean.PrettyPrinter.Unexpander := fun\n      | `($lhs)             => withRef f `($pat)\n      | `($lhsWithMoreArgs) => withRef f `($patWithMoreArgs)\n      | _                   => throw ())\nwhere\n  flattenApp : Term \u2192 Term\n    | stx@`($f $xs*) => match f with\n      | `($f' $xs'*) => Syntax.mkApp f' (xs' ++ xs)\n      | _            => stx\n    | stx            => stx", "start": [82, 1], "end": [124, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandNotationAux", "code": "private def expandNotationAux (ref : Syntax) (currNamespace : Name)\n    (doc? : Option (TSyntax ``docComment))\n    (attrs? : Option (TSepArray ``attrInstance \",\"))\n    (attrKind : TSyntax ``attrKind)\n    (prec? : Option Prec) (name? : Option Ident) (prio? : Option Prio)\n    (items : Array (TSyntax ``notationItem)) (rhs : Term) : MacroM Syntax := do\n  let prio \u2190 evalOptPrio prio?\n  let syntaxParts \u2190 items.mapM expandNotationItemIntoSyntaxItem\n  let cat := mkIdentFrom ref `term\n  let name \u2190\n    match name? with\n    | some name => pure name.getId\n    | none => addMacroScopeIfLocal (\u2190 mkNameFromParserSyntax `term (mkNullNode syntaxParts)) attrKind\n  let vars := items.filter fun item => item.raw.getKind == ``identPrec\n  let vars := vars.map fun var => var.raw[0]\n  let qrhs := \u27e8antiquote vars rhs\u27e9\n  let attrs? := addInheritDocDefault rhs attrs?\n  let patArgs \u2190 items.mapM expandNotationItemIntoPattern\n  \n  let fullName := currNamespace ++ name\n  let pat : Term := \u27e8mkNode fullName patArgs\u27e9\n  let stxDecl \u2190 `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind\n    syntax $[: $prec?]? (name := $(name?.getD (mkIdent name))) (priority := $(quote prio)) $[$syntaxParts]* : $cat)\n  let macroDecl \u2190 `(macro_rules | `($pat) => ``($qrhs))\n  let macroDecls \u2190\n    if isLocalAttrKind attrKind then\n      `(section set_option quotPrecheck.allowSectionVars true $macroDecl end)\n    else\n      pure \u27e8mkNullNode #[macroDecl]\u27e9\n  match (\u2190 mkUnexpander attrKind pat qrhs |>.run) with\n  | some delabDecl => return mkNullNode #[stxDecl, macroDecls, delabDecl]\n  | none           => return mkNullNode #[stxDecl, macroDecls]", "start": [126, 1], "end": [161, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandNotation", "code": "@[builtin_macro Lean.Parser.Command.notation] def expandNotation : Macro\n  | stx@`($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind\n      notation $[: $prec?]? $[(name := $name?)]? $[(priority := $prio?)]? $items* => $rhs) => do\n    let _ \u2190 toAttributeKind attrKind\n    expandNotationAux stx (\u2190 Macro.getCurrNamespace) doc? attrs? attrKind prec? name? prio? items rhs\n  | _ => Macro.throwUnsupported", "start": [163, 1], "end": [169, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Extra.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/BuiltinNotation.lean", "lake-packages/lean4/src/lean/Lean/Elab/App.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.getMonadForIn", "code": "private def getMonadForIn (expectedType? : Option Expr) : TermElabM Expr := do\n    match expectedType? with\n    | none => throwError \"invalid 'for_in%' notation, expected type is not available\"\n    | some expectedType =>\n      match (\u2190 isTypeApp? expectedType) with\n      | some (m, _) => return m\n      | none => throwError \"invalid 'for_in%' notation, expected type is not of of the form `M \u03b1`{indentExpr expectedType}\"", "start": [14, 1], "end": [20, 124], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.throwForInFailure", "code": "private def throwForInFailure (forInInstance : Expr) : TermElabM Expr :=\n  throwError \"failed to synthesize instance for 'for_in%' notation{indentExpr forInInstance}\"", "start": [22, 1], "end": [23, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabForIn", "code": "@[builtin_term_elab forInMacro] def elabForIn : TermElab :=  fun stx expectedType? => do\n  match stx with\n  | `(for_in% $col $init $body) =>\n      match (\u2190 isLocalIdent? col) with\n      | none   => elabTerm (\u2190 `(let col := $col; for_in% col $init $body)) expectedType?\n      | some colFVar =>\n        tryPostponeIfNoneOrMVar expectedType?\n        let m \u2190 getMonadForIn expectedType?\n        let colType \u2190 inferType colFVar\n        let elemType \u2190 mkFreshExprMVar (mkSort (mkLevelSucc (\u2190 mkFreshLevelMVar)))\n        let forInInstance \u2190 try\n          mkAppM ``ForIn #[m, colType, elemType]\n        catch _ =>\n          tryPostpone; throwError \"failed to construct 'ForIn' instance for collection{indentExpr colType}\\nand monad{indentExpr m}\"\n        match (\u2190 trySynthInstance forInInstance) with\n        | .some inst =>\n          let forInFn \u2190 mkConst ``forIn\n          elabAppArgs forInFn\n            (namedArgs := #[{ name := `m, val := Arg.expr m}, { name := `\u03b1, val := Arg.expr elemType }, { name := `self, val := Arg.expr inst }])\n            (args := #[Arg.stx col, Arg.stx init, Arg.stx body])\n            (expectedType? := expectedType?)\n            (explicit := false) (ellipsis := false) (resultIsOutParamSupport := false)\n        | .undef    => tryPostpone; throwForInFailure forInInstance\n        | .none     => throwForInFailure forInInstance\n  | _ => throwUnsupportedSyntax", "start": [25, 1], "end": [49, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabForIn'", "code": "@[builtin_term_elab forInMacro'] def elabForIn' : TermElab :=  fun stx expectedType? => do\n  match stx with\n  | `(for_in'% $col $init $body) =>\n      match (\u2190 isLocalIdent? col) with\n      | none   => elabTerm (\u2190 `(let col := $col; for_in'% col $init $body)) expectedType?\n      | some colFVar =>\n        tryPostponeIfNoneOrMVar expectedType?\n        let m \u2190 getMonadForIn expectedType?\n        let colType \u2190 inferType colFVar\n        let elemType \u2190 mkFreshExprMVar (mkSort (mkLevelSucc (\u2190 mkFreshLevelMVar)))\n        let forInInstance \u2190\n          try\n            let memType \u2190 mkFreshExprMVar (\u2190 mkAppM ``Membership #[elemType, colType])\n            mkAppM ``ForIn' #[m, colType, elemType, memType]\n          catch _ =>\n            tryPostpone; throwError \"failed to construct `ForIn'` instance for collection{indentExpr colType}\\nand monad{indentExpr m}\"\n        match (\u2190 trySynthInstance forInInstance) with\n        | .some inst  =>\n          let forInFn \u2190 mkConst ``forIn'\n          elabAppArgs forInFn\n            (namedArgs := #[{ name := `m, val := Arg.expr m}, { name := `\u03b1, val := Arg.expr elemType}, { name := `self, val := Arg.expr inst }])\n            (args := #[Arg.expr colFVar, Arg.stx init, Arg.stx body])\n            (expectedType? := expectedType?)\n            (explicit := false) (ellipsis := false) (resultIsOutParamSupport := false)\n        | .undef    => tryPostpone; throwForInFailure forInInstance\n        | .none     => throwForInFailure forInInstance\n  | _ => throwUnsupportedSyntax", "start": [51, 1], "end": [77, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.Tree", "code": "private inductive Tree where\n  \n  | term (ref : Syntax) (infoTrees : PersistentArray InfoTree) (val : Expr)\n  \n  | binop (ref : Syntax) (lazy : Bool) (f : Expr) (lhs rhs : Tree)\n  \n  | unop (ref : Syntax) (f : Expr) (arg : Tree)\n  \n  | macroExpansion (macroName : Name) (stx stx' : Syntax) (nested : Tree)", "start": [132, 1], "end": [151, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.toTree", "code": "private partial def toTree (s : Syntax) : TermElabM Tree := do\n  \n  let result \u2190 go s\n  synthesizeSyntheticMVars (mayPostpone := true)\n  return result\nwhere\n  go (s : Syntax) := do\n    match s with\n    | `(binop% $f $lhs $rhs) => processBinOp (lazy := false) s f lhs rhs\n    | `(binop_lazy% $f $lhs $rhs) => processBinOp (lazy := true) s f lhs rhs\n    | `(unop% $f $arg) => processUnOp s f arg\n    | `(($e)) =>\n      if hasCDot e then\n        processLeaf s\n      else\n        go e\n    | _ =>\n      withRef s do\n        match (\u2190 liftMacroM <| expandMacroImpl? (\u2190 getEnv) s) with\n        | some (macroName, s?) =>\n          let s' \u2190 liftMacroM <| liftExcept s?\n          withPushMacroExpansionStack s s' do\n            return .macroExpansion macroName s s' (\u2190 go s')\n        | none => processLeaf s\n\n  processBinOp (ref : Syntax) (f lhs rhs : Syntax) (lazy : Bool) := do\n    let some f \u2190 resolveId? f | throwUnknownConstant f.getId\n    return .binop (lazy := lazy) ref f (\u2190 go lhs) (\u2190 go rhs)\n\n  processUnOp (ref : Syntax) (f arg : Syntax) := do\n    let some f \u2190 resolveId? f | throwUnknownConstant f.getId\n    return .unop ref f (\u2190 go arg)\n\n  processLeaf (s : Syntax) := do\n    let e \u2190 elabTerm s none\n    let info \u2190 getResetInfoTrees\n    return .term s info e", "start": [154, 1], "end": [195, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.hasCoe", "code": "private def hasCoe (fromType toType : Expr) : TermElabM Bool := do\n  if (\u2190 getEnv).contains ``CoeT then\n    withLocalDeclD `x fromType fun x => do\n    match \u2190 coerceSimple? x toType with\n    | .some _ => return true\n    | .none   => return false\n    | .undef  => return false else\n    return false", "start": [198, 1], "end": [206, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.AnalyzeResult", "code": "private structure AnalyzeResult where\n  max?            : Option Expr := none\n  hasUncomparable : Bool := false", "start": [208, 1], "end": [210, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.isUnknown", "code": "private def isUnknown : Expr \u2192 Bool\n  | .mvar ..        => true\n  | .app f _        => isUnknown f\n  | .letE _ _ _ b _ => isUnknown b\n  | .mdata _ b      => isUnknown b\n  | _               => false", "start": [212, 1], "end": [217, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.analyze", "code": "private def analyze (t : Tree) (expectedType? : Option Expr) : TermElabM AnalyzeResult := do\n  let max? \u2190\n    match expectedType? with\n    | none => pure none\n    | some expectedType =>\n      let expectedType \u2190 instantiateMVars expectedType\n      if isUnknown expectedType then pure none else pure (some expectedType)\n  (go t *> get).run' { max? }\nwhere\n   go (t : Tree) : StateRefT AnalyzeResult TermElabM Unit := do\n     unless (\u2190 get).hasUncomparable do\n       match t with\n       | .macroExpansion _ _ _ nested => go nested\n       | .binop _ _ _ lhs rhs => go lhs; go rhs\n       | .unop _ _ arg => go arg\n       | .term _ _ val =>\n         let type \u2190 instantiateMVars (\u2190 inferType val)\n         unless isUnknown type do\n           match (\u2190 get).max? with\n           | none     => modify fun s => { s with max? := type }\n           | some max =>\n             unless (\u2190 withNewMCtxDepth <| isDefEqGuarded max type) do\n               if (\u2190 hasCoe type max) then\n                 return ()\n               else if (\u2190 hasCoe max type) then\n                 modify fun s => { s with max? := type }\n               else\n                 trace[Elab.binop] \"uncomparable types: {max}, {type}\"\n                 modify fun s => { s with hasUncomparable := true }", "start": [219, 1], "end": [247, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.mkBinOp", "code": "private def mkBinOp (lazy : Bool) (f : Expr) (lhs rhs : Expr) : TermElabM Expr := do\n  let mut rhs := rhs\n  if lazy then\n    rhs \u2190 mkFunUnit rhs\n  elabAppArgs f #[] #[Arg.expr lhs, Arg.expr rhs] (expectedType? := none) (explicit := false) (ellipsis := false) (resultIsOutParamSupport := false)", "start": [249, 1], "end": [253, 149], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.mkUnOp", "code": "private def mkUnOp (f : Expr) (arg : Expr) : TermElabM Expr := do\n  elabAppArgs f #[] #[Arg.expr arg] (expectedType? := none) (explicit := false) (ellipsis := false) (resultIsOutParamSupport := false)", "start": [255, 1], "end": [256, 135], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.toExprCore", "code": "private def toExprCore (t : Tree) : TermElabM Expr := do\n  match t with\n  | .term _ trees e =>\n    modifyInfoState (fun s => { s with trees := s.trees ++ trees }); return e\n  | .binop ref lazy f lhs rhs =>\n    withRef ref <| withInfoContext' ref (mkInfo := mkTermInfo .anonymous ref) do\n      mkBinOp lazy f (\u2190 toExprCore lhs) (\u2190 toExprCore rhs)\n  | .unop ref f arg =>\n    withRef ref <| withInfoContext' ref (mkInfo := mkTermInfo .anonymous ref) do\n      mkUnOp f (\u2190 toExprCore arg)\n  | .macroExpansion macroName stx stx' nested =>\n    withRef stx <| withInfoContext' stx (mkInfo := mkTermInfo macroName stx) do\n      withMacroExpansion stx stx' do\n        toExprCore nested", "start": [258, 1], "end": [271, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.hasHeterogeneousDefaultInstances", "code": "private def hasHeterogeneousDefaultInstances (f : Expr) (maxType : Expr) (lhs : Bool) : MetaM Bool := do\n  let .const fName .. := f | return false\n  let .const typeName .. := maxType.getAppFn | return false\n  let className := fName.getPrefix\n  let defInstances \u2190 getDefaultInstances className\n  if defInstances.length \u2264 1 then return false\n  for (instName, _) in defInstances do\n    if let .app (.app (.app _heteroClass lhsType) rhsType) _resultType :=\n        (\u2190 getConstInfo instName).type.getForallBody then\n      if  lhs && rhsType.isAppOf typeName then return true\n      if !lhs && lhsType.isAppOf typeName then return true\n  return false", "start": [273, 1], "end": [308, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.hasHomogeneousInstance", "code": "private def hasHomogeneousInstance (f : Expr) (maxType : Expr) : MetaM Bool := do\n  let .const fName .. := f | return false\n  let className := fName.getPrefix\n  try\n    let inst \u2190 mkAppM className #[maxType, maxType, maxType]\n    return (\u2190 trySynthInstance inst) matches .some _\n  catch _ =>\n    return false", "start": [310, 1], "end": [324, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.applyCoe", "code": "private partial def applyCoe (t : Tree) (maxType : Expr) (isPred : Bool) : TermElabM Tree := do\n    go t none false isPred\n  where\n    go (t : Tree) (f? : Option Expr) (lhs : Bool) (isPred : Bool) : TermElabM Tree := do\n      match t with\n      | .binop ref lazy f lhs rhs =>\n        \n        if (\u2190 pure isPred <||> hasHomogeneousInstance f maxType) then\n          return .binop ref lazy f (\u2190 go lhs f true false) (\u2190 go rhs f false false)\n        else\n          let r \u2190 withRef ref do\n            mkBinOp lazy f (\u2190 toExpr lhs none) (\u2190 toExpr rhs none)\n          let infoTrees \u2190 getResetInfoTrees\n          return .term ref infoTrees r\n      | .unop ref f arg =>\n        return .unop ref f (\u2190 go arg none false false)\n      | .term ref trees e =>\n        let type \u2190 instantiateMVars (\u2190 inferType e)\n        trace[Elab.binop] \"visiting {e} : {type} =?= {maxType}\"\n        if isUnknown type then\n          if let some f := f? then\n            if (\u2190 hasHeterogeneousDefaultInstances f maxType lhs) then\n              return t\n        if (\u2190 isDefEqGuarded maxType type) then\n          return t\n        else\n          trace[Elab.binop] \"added coercion: {e} : {type} => {maxType}\"\n          withRef ref <| return .term ref trees (\u2190 mkCoe maxType e)\n      | .macroExpansion macroName stx stx' nested =>\n        withRef stx <| withPushMacroExpansionStack stx stx' do\n          return .macroExpansion macroName stx stx' (\u2190 go nested f? lhs isPred)", "start": [327, 3], "end": [381, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.toExpr", "code": "private partial def toExpr (tree : Tree) (expectedType? : Option Expr) : TermElabM Expr := do\n    let r \u2190 analyze tree expectedType?\n    trace[Elab.binop] \"hasUncomparable: {r.hasUncomparable}, maxType: {r.max?}\"\n    if r.hasUncomparable || r.max?.isNone then\n      let result \u2190 toExprCore tree\n      ensureHasType expectedType? result\n    else\n      let result \u2190 toExprCore (\u2190 applyCoe tree r.max?.get! (isPred := false))\n      trace[Elab.binop] \"result: {result}\"\n      ensureHasType expectedType? result", "start": [383, 3], "end": [392, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.elabOp", "code": "def elabOp : TermElab := fun stx expectedType? => do\n  toExpr (\u2190 toTree stx) expectedType?", "start": [396, 1], "end": [397, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.elabBinOp", "code": "@[builtin_term_elab binop]\ndef elabBinOp : TermElab := elabOp", "start": [399, 1], "end": [400, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.elabBinOpLazy", "code": "@[builtin_term_elab binop_lazy]\ndef elabBinOpLazy : TermElab := elabOp", "start": [402, 1], "end": [403, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.elabUnOp", "code": "@[builtin_term_elab unop]\ndef elabUnOp : TermElab := elabOp", "start": [405, 1], "end": [406, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.elabBinRelCore", "code": "def elabBinRelCore (noProp : Bool) (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr :=  do\n  match (\u2190 resolveId? stx[1]) with\n  | some f => withSynthesizeLight do\n    \n    let lhs \u2190 withRef stx[2] <| toTree stx[2]\n    let rhs \u2190 withRef stx[3] <| toTree stx[3]\n    let tree := .binop (lazy := false) stx f lhs rhs\n    let r \u2190 analyze tree none\n    trace[Elab.binrel] \"hasUncomparable: {r.hasUncomparable}, maxType: {r.max?}\"\n    if r.hasUncomparable || r.max?.isNone then\n      let lhs \u2190 toExprCore lhs\n      let rhs \u2190 toExprCore rhs\n      let lhs \u2190 toBoolIfNecessary lhs\n      let rhs \u2190 toBoolIfNecessary rhs\n      let lhsType \u2190 inferType lhs\n      let rhs \u2190 ensureHasType lhsType rhs\n      elabAppArgs f #[] #[Arg.expr lhs, Arg.expr rhs] expectedType? (explicit := false) (ellipsis := false) (resultIsOutParamSupport := false)\n    else\n      let mut maxType := r.max?.get!\n      \n      if noProp then\n        if (\u2190 withNewMCtxDepth <| isDefEq maxType (mkSort levelZero)) then\n          maxType := Lean.mkConst ``Bool\n      let result \u2190 toExprCore (\u2190 applyCoe tree maxType (isPred := true))\n      trace[Elab.binrel] \"result: {result}\"\n      return result\n  | none   => throwUnknownConstant stx[1].getId\nwhere\n  \n  toBoolIfNecessary (e : Expr) : TermElabM Expr := do\n    if noProp then\n      if (\u2190 withNewMCtxDepth <| isDefEq (\u2190 inferType e) (mkSort levelZero)) then\n        return (\u2190 ensureHasType (Lean.mkConst ``Bool) e)\n    return e", "start": [408, 1], "end": [480, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.elabBinRel", "code": "@[builtin_term_elab binrel] def elabBinRel : TermElab := elabBinRelCore false", "start": [482, 1], "end": [482, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.elabBinRelNoProp", "code": "@[builtin_term_elab binrel_no_prop] def elabBinRelNoProp : TermElab := elabBinRelCore true", "start": [484, 1], "end": [484, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Op.elabDefaultOrNonempty", "code": "@[builtin_term_elab defaultOrOfNonempty]\ndef elabDefaultOrNonempty : TermElab :=  fun stx expectedType? => do\n  tryPostponeIfNoneOrMVar expectedType?\n  match expectedType? with\n  | none => throwError \"invalid 'default_or_ofNonempty%', expected type is not known\"\n  | some expectedType =>\n    try\n      mkDefault expectedType\n    catch ex => try\n      mkOfNonempty expectedType\n    catch _ =>\n      if stx[1].isNone then\n        throw ex\n      else\n        mkSorry expectedType false", "start": [486, 1], "end": [502, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/GenInjective.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Injective.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.elabGenInjectiveTheorems", "code": "@[builtin_command_elab genInjectiveTheorems] def elabGenInjectiveTheorems : CommandElab := fun stx => do\n  let declName \u2190 resolveGlobalConstNoOverloadWithInfo stx[1]\n  liftTermElabM do\n    Meta.mkInjectiveTheorems declName", "start": [11, 1], "end": [14, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/BuiltinCommand.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/CollectLevelParams.lean", "lake-packages/lean4/src/lean/Lean/Elab/SetOption.lean", "lake-packages/lean4/src/lean/Lean/Elab/Eval.lean", "lake-packages/lean4/src/lean/Lean/Meta/Reduce.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Open.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Lean.Elab.Command.elabModuleDoc", "code": "@[builtin_command_elab moduleDoc] def elabModuleDoc : CommandElab := fun stx => do\n   match stx[1] with\n   | Syntax.atom _ val =>\n     let doc := val.extract 0 (val.endPos - \u27e82\u27e9)\n     let range \u2190 Elab.getDeclarationRange stx\n     modifyEnv fun env => addMainModuleDoc env \u27e8doc, range\u27e9\n   | _ => throwErrorAt stx \"unexpected module doc string{indentD stx[1]}\"", "start": [17, 1], "end": [23, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addScope", "code": "private def addScope (isNewNamespace : Bool) (isNoncomputable : Bool) (header : String) (newNamespace : Name) : CommandElabM Unit := do\n  modify fun s => { s with\n    env    := s.env.registerNamespace newNamespace,\n    scopes := { s.scopes.head! with header := header, currNamespace := newNamespace, isNoncomputable := s.scopes.head!.isNoncomputable || isNoncomputable } :: s.scopes\n  }\n  pushScope\n  if isNewNamespace then\n    activateScoped newNamespace", "start": [25, 1], "end": [32, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addScopes", "code": "private def addScopes (isNewNamespace : Bool) (isNoncomputable : Bool) : Name \u2192 CommandElabM Unit\n  | .anonymous => pure ()\n  | .str p header => do\n    addScopes isNewNamespace isNoncomputable p\n    let currNamespace \u2190 getCurrNamespace\n    addScope isNewNamespace isNoncomputable header (if isNewNamespace then Name.mkStr currNamespace header else currNamespace)\n  | _ => throwError \"invalid scope\"", "start": [34, 1], "end": [40, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addNamespace", "code": "private def addNamespace (header : Name) : CommandElabM Unit :=\n  addScopes (isNewNamespace := true) (isNoncomputable := false) header", "start": [42, 1], "end": [43, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withNamespace", "code": "def withNamespace {\u03b1} (ns : Name) (elabFn : CommandElabM \u03b1) : CommandElabM \u03b1 := do\n  addNamespace ns\n  let a \u2190 elabFn\n  modify fun s => { s with scopes := s.scopes.drop ns.getNumParts }\n  pure a", "start": [45, 1], "end": [49, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.popScopes", "code": "private def popScopes (numScopes : Nat) : CommandElabM Unit :=\n  for _ in [0:numScopes] do\n    popScope", "start": [51, 1], "end": [53, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkAnonymousScope", "code": "private def checkAnonymousScope : List Scope \u2192 Option Name\n  | { header := \"\", .. } :: _ => none\n  | { header := h, .. }  :: _ => some h\n  | _                         => some .anonymous", "start": [55, 1], "end": [58, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.checkEndHeader", "code": "private def checkEndHeader : Name \u2192 List Scope \u2192 Option Name\n  | .anonymous, _ => none\n  | .str p s, { header := h, .. } :: scopes =>\n    if h == s then\n      (.str \u00b7 s) <$> checkEndHeader p scopes\n    else\n      some h\n  | _, _ => some .anonymous", "start": [60, 1], "end": [67, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabNamespace", "code": "@[builtin_command_elab \u00abnamespace\u00bb] def elabNamespace : CommandElab := fun stx =>\n  match stx with\n  | `(namespace $n) => addNamespace n.getId\n  | _               => throwUnsupportedSyntax", "start": [69, 1], "end": [72, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabSection", "code": "@[builtin_command_elab \u00absection\u00bb] def elabSection : CommandElab := fun stx => do\n  match stx with\n  | `(section $header:ident) => addScopes (isNewNamespace := false) (isNoncomputable := false) header.getId\n  | `(section)               => addScope (isNewNamespace := false) (isNoncomputable := false) \"\" (\u2190 getCurrNamespace)\n  | _                        => throwUnsupportedSyntax", "start": [74, 1], "end": [78, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabNonComputableSection", "code": "@[builtin_command_elab noncomputableSection] def elabNonComputableSection : CommandElab := fun stx => do\n  match stx with\n  | `(noncomputable section $header:ident) => addScopes (isNewNamespace := false) (isNoncomputable := true) header.getId\n  | `(noncomputable section)               => addScope (isNewNamespace := false) (isNoncomputable := true) \"\" (\u2190 getCurrNamespace)\n  | _                        => throwUnsupportedSyntax", "start": [80, 1], "end": [84, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabEnd", "code": "@[builtin_command_elab \u00abend\u00bb] def elabEnd : CommandElab := fun stx => do\n  let header? := (stx.getArg 1).getOptionalIdent?;\n  let endSize := match header? with\n    | none   => 1\n    | some n => n.getNumParts\n  let scopes \u2190 getScopes\n  if endSize < scopes.length then\n    modify fun s => { s with scopes := s.scopes.drop endSize }\n    popScopes endSize\n  else let n := (\u2190 get).scopes.length - 1\n    modify fun s => { s with scopes := s.scopes.drop n }\n    popScopes n\n    throwError \"invalid 'end', insufficient scopes\"\n  match header? with\n  | none        =>\n    if let some name := checkAnonymousScope scopes then\n      throwError \"invalid 'end', name is missing (expected {name})\"\n  | some header =>\n    if let some name := checkEndHeader header scopes then\n      addCompletionInfo <| CompletionInfo.endSection stx (scopes.map fun scope => scope.header)\n      throwError \"invalid 'end', name mismatch (expected {if name == `\u00ab\u00bb then `nothing else name})\"", "start": [86, 1], "end": [107, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabChoiceAux", "code": "private partial def elabChoiceAux (cmds : Array Syntax) (i : Nat) : CommandElabM Unit :=\n  if h : i < cmds.size then\n    let cmd := cmds.get \u27e8i, h\u27e9;\n    catchInternalId unsupportedSyntaxExceptionId\n      (elabCommand cmd)\n      (fun _ => elabChoiceAux cmds (i+1))\n  else\n    throwUnsupportedSyntax", "start": [109, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabChoice", "code": "@[builtin_command_elab choice] def elabChoice : CommandElab := fun stx =>\n  elabChoiceAux stx.getArgs 0", "start": [118, 1], "end": [119, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabUniverse", "code": "@[builtin_command_elab \u00abuniverse\u00bb] def elabUniverse : CommandElab := fun n => do\n  n[1].forArgsM addUnivLevel", "start": [121, 1], "end": [122, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabInitQuot", "code": "@[builtin_command_elab \u00abinit_quot\u00bb] def elabInitQuot : CommandElab := fun _ => do\n  match (\u2190 getEnv).addDecl Declaration.quotDecl with\n  | Except.ok env   => setEnv env\n  | Except.error ex => throwError (ex.toMessageData (\u2190 getOptions))", "start": [124, 1], "end": [127, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabExport", "code": "@[builtin_command_elab \u00abexport\u00bb] def elabExport : CommandElab := fun stx => do\n  let `(export $ns ($ids*)) := stx | throwUnsupportedSyntax\n  let nss \u2190 resolveNamespace ns\n  let currNamespace \u2190 getCurrNamespace\n  if nss == [currNamespace] then throwError \"invalid 'export', self export\"\n  let mut aliases := #[]\n  for idStx in ids do\n    let id := idStx.getId\n    let declName \u2190 resolveNameUsingNamespaces nss idStx\n    aliases := aliases.push (currNamespace ++ id, declName)\n  modify fun s => { s with env := aliases.foldl (init := s.env) fun env p => addAlias env p.1 p.2 }", "start": [129, 1], "end": [139, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabOpen", "code": "@[builtin_command_elab \u00abopen\u00bb] def elabOpen : CommandElab\n  | `(open $decl:openDecl) => do\n    let openDecls \u2190 elabOpenDecl decl\n    modifyScope fun scope => { scope with openDecls := openDecls }\n  | _ => throwUnsupportedSyntax", "start": [141, 1], "end": [145, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.typelessBinder?", "code": "private def typelessBinder? : Syntax \u2192 Option (Array (TSyntax [`ident, `Lean.Parser.Term.hole]) \u00d7 Bool)\n  | `(bracketedBinderF|($ids*)) => some (ids, true)\n  | `(bracketedBinderF|{$ids*}) => some (ids, false)\n  | _                          => none", "start": [149, 1], "end": [152, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.containsId", "code": "private def containsId (ids : Array (TSyntax [`ident, ``Parser.Term.hole])) (id : TSyntax [`ident, ``Parser.Term.hole]) : Bool :=\n  id.raw.isIdent && ids.any fun id' => id'.raw.getId == id.raw.getId", "start": [154, 1], "end": [156, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.replaceBinderAnnotation", "code": "private def replaceBinderAnnotation (binder : TSyntax ``Parser.Term.bracketedBinder) : CommandElabM (Array (TSyntax ``Parser.Term.bracketedBinder)) := do\n  let some (binderIds, explicit) := typelessBinder? binder | return #[binder]\n  let varDecls := (\u2190 getScope).varDecls\n  let mut varDeclsNew := #[]\n  let mut binderIds := binderIds\n  let mut binderIdsIniSize := binderIds.size\n  let mut modifiedVarDecls := false\n  for varDecl in varDecls do\n    let (ids, ty?, explicit') \u2190 match varDecl with\n      | `(bracketedBinderF|($ids* $[: $ty?]? $(annot?)?)) =>\n        if annot?.isSome then\n          for binderId in binderIds do\n            if containsId ids binderId then\n              throwErrorAt binderId \"cannot update binder annotation of variables with default values/tactics\"\n        pure (ids, ty?, true)\n      | `(bracketedBinderF|{$ids* $[: $ty?]?}) =>\n        pure (ids, ty?, false)\n      | `(bracketedBinderF|[$id : $_]) =>\n        for binderId in binderIds do\n          if binderId.raw.isIdent && binderId.raw.getId == id.getId then\n            throwErrorAt binderId \"cannot change the binder annotation of the previously declared local instance `{id.getId}`\"\n        varDeclsNew := varDeclsNew.push varDecl; continue\n      | _ =>\n        varDeclsNew := varDeclsNew.push varDecl; continue\n    if explicit == explicit' then\n      for binderId in binderIds do\n        if containsId ids binderId then\n          throwErrorAt binderId \"redundant binder annotation update\"\n      varDeclsNew := varDeclsNew.push varDecl\n    else if binderIds.all fun binderId => !containsId ids binderId then\n      varDeclsNew := varDeclsNew.push varDecl\n    else\n      let mkBinder (id : TSyntax [`ident, ``Parser.Term.hole]) (explicit : Bool) : CommandElabM (TSyntax ``Parser.Term.bracketedBinder) :=\n        if explicit then\n          `(bracketedBinderF| ($id $[: $ty?]?))\n        else\n          `(bracketedBinderF| {$id $[: $ty?]?})\n      for id in ids do\n        if let some idx := binderIds.findIdx? fun binderId => binderId.raw.isIdent && binderId.raw.getId == id.raw.getId then\n          binderIds := binderIds.eraseIdx idx\n          modifiedVarDecls := true\n          varDeclsNew := varDeclsNew.push (\u2190 mkBinder id explicit)\n        else\n          varDeclsNew := varDeclsNew.push (\u2190 mkBinder id explicit')\n  if modifiedVarDecls then\n    modifyScope fun scope => { scope with varDecls := varDeclsNew }\n  if binderIds.size != binderIdsIniSize then\n    binderIds.mapM fun binderId =>\n      if explicit then\n        `(bracketedBinderF| ($binderId))\n      else\n        `(bracketedBinderF| {$binderId})\n  else\n    return #[binder]", "start": [158, 1], "end": [224, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabVariable", "code": "@[builtin_command_elab \u00abvariable\u00bb] def elabVariable : CommandElab\n  | `(variable $binders*) => do\n    runTermElabM fun _ => Term.withAutoBoundImplicit <|\n      Term.elabBinders binders fun _ => pure ()\n    for binder in binders do\n      let binders \u2190 replaceBinderAnnotation binder\n      for binder in binders do\n        let varUIds \u2190 getBracketedBinderIds binder |>.mapM (withFreshMacroScope \u2218 MonadQuotation.addMacroScope)\n        modifyScope fun scope => { scope with varDecls := scope.varDecls.push binder, varUIds := scope.varUIds ++ varUIds }\n  | _ => throwUnsupportedSyntax", "start": [226, 1], "end": [237, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabCheckCore", "code": "def elabCheckCore (ignoreStuckTC : Bool) : CommandElab\n  | `(#check%$tk $term) => withoutModifyingEnv <| runTermElabM fun _ => Term.withDeclName `_check do\n    if let `($_:ident) := term then\n      try\n        for c in (\u2190 resolveGlobalConstWithInfos term) do\n          addCompletionInfo <| .id term c (danglingDot := false) {} none\n          logInfoAt tk <| .ofPPFormat { pp := fun\n            | some ctx => ctx.runMetaM <| PrettyPrinter.ppSignature c\n            | none     => return f!\"{c}\"  }\n          return\n      catch _ => pure ()  let e \u2190 Term.elabTerm term none\n    Term.synthesizeSyntheticMVarsNoPostponing (ignoreStuckTC := ignoreStuckTC)\n    let e \u2190 Term.levelMVarToParam (\u2190 instantiateMVars e)\n    let type \u2190 inferType e\n    if e.isSyntheticSorry then\n      return\n    logInfoAt tk m!\"{e} : {type}\"\n  | _ => throwUnsupportedSyntax", "start": [241, 1], "end": [261, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabCheck", "code": "@[builtin_command_elab Lean.Parser.Command.check] def elabCheck : CommandElab := elabCheckCore (ignoreStuckTC := true)", "start": [263, 1], "end": [263, 119], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabReduce", "code": "@[builtin_command_elab Lean.Parser.Command.reduce] def elabReduce : CommandElab\n  | `(#reduce%$tk $term) => withoutModifyingEnv <| runTermElabM fun _ => Term.withDeclName `_reduce do\n    let e \u2190 Term.elabTerm term none\n    Term.synthesizeSyntheticMVarsNoPostponing\n    let e \u2190 Term.levelMVarToParam (\u2190 instantiateMVars e)\n    withTheReader Core.Context (fun ctx => { ctx with options := ctx.options.setBool `smartUnfolding false }) do\n      let e \u2190 withTransparency (mode := TransparencyMode.all) <| reduce e (skipProofs := false) (skipTypes := false)\n      logInfoAt tk e\n  | _ => throwUnsupportedSyntax", "start": [265, 1], "end": [274, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.hasNoErrorMessages", "code": "def hasNoErrorMessages : CommandElabM Bool := do\n  return !(\u2190 get).messages.hasErrors", "start": [276, 1], "end": [277, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.failIfSucceeds", "code": "def failIfSucceeds (x : CommandElabM Unit) : CommandElabM Unit := do\n  let resetMessages : CommandElabM MessageLog := do\n    let s \u2190 get\n    let messages := s.messages;\n    modify fun s => { s with messages := {} };\n    pure messages\n  let restoreMessages (prevMessages : MessageLog) : CommandElabM Unit := do\n    modify fun s => { s with messages := prevMessages ++ s.messages.errorsToWarnings }\n  let prevMessages \u2190 resetMessages\n  let succeeded \u2190 try\n    x\n    hasNoErrorMessages\n  catch\n    | ex@(Exception.error _ _) => do logException ex; pure false\n    | Exception.internal id _  => do logError (\u2190 id.getName); pure false\n  finally\n    restoreMessages prevMessages\n  if succeeded then\n    throwError \"unexpected success\"", "start": [279, 1], "end": [297, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabCheckFailure", "code": "@[builtin_command_elab \u00abcheck_failure\u00bb] def elabCheckFailure : CommandElab\n  | `(#check_failure $term) => do\n    failIfSucceeds <| elabCheckCore (ignoreStuckTC := false) (\u2190 `(#check $term))\n  | _ => throwUnsupportedSyntax", "start": [299, 1], "end": [302, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkEvalInstCore", "code": "private def mkEvalInstCore (evalClassName : Name) (e : Expr) : MetaM Expr := do\n  let \u03b1    \u2190 inferType e\n  let u    \u2190 getDecLevel \u03b1\n  let inst := mkApp (Lean.mkConst evalClassName [u]) \u03b1\n  try\n    synthInstance inst\n  catch _ =>\n    try\n      let \u03b1 \u2190 whnf \u03b1\n      synthInstance (mkApp (Lean.mkConst evalClassName [u]) \u03b1)\n    catch _ =>\n      try\n        let \u03b1 \u2190 reduce (skipTypes := false) \u03b1\n        synthInstance (mkApp (Lean.mkConst evalClassName [u]) \u03b1)\n      catch _ =>\n        throwError \"expression{indentExpr e}\\nhas type{indentExpr \u03b1}\\nbut instance{indentExpr inst}\\nfailed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `{evalClassName}` class\"", "start": [304, 1], "end": [321, 291], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkRunMetaEval", "code": "private def mkRunMetaEval (e : Expr) : MetaM Expr :=\n  withLocalDeclD `env (mkConst ``Lean.Environment) fun env =>\n  withLocalDeclD `opts (mkConst ``Lean.Options) fun opts => do\n    let \u03b1 \u2190 inferType e\n    let u \u2190 getDecLevel \u03b1\n    let instVal \u2190 mkEvalInstCore ``Lean.MetaEval e\n    let e := mkAppN (mkConst ``Lean.runMetaEval [u]) #[\u03b1, instVal, env, opts, e]\n    instantiateMVars (\u2190 mkLambdaFVars #[env, opts] e)", "start": [323, 1], "end": [330, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkRunEval", "code": "private def mkRunEval (e : Expr) : MetaM Expr := do\n  let \u03b1 \u2190 inferType e\n  let u \u2190 getDecLevel \u03b1\n  let instVal \u2190 mkEvalInstCore ``Lean.Eval e\n  instantiateMVars (mkAppN (mkConst ``Lean.runEval [u]) #[\u03b1, instVal, mkSimpleThunk e])", "start": [332, 1], "end": [336, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabEvalUnsafe", "code": "unsafe def elabEvalUnsafe : CommandElab\n  | `(#eval%$tk $term) => do\n    let declName := `_eval\n    let addAndCompile (value : Expr) : TermElabM Unit := do\n      let value \u2190 Term.levelMVarToParam (\u2190 instantiateMVars value)\n      let type \u2190 inferType value\n      let us := collectLevelParams {} value |>.params\n      let value \u2190 instantiateMVars value\n      let decl := Declaration.defnDecl {\n        name        := declName\n        levelParams := us.toList\n        type        := type\n        value       := value\n        hints       := ReducibilityHints.opaque\n        safety      := DefinitionSafety.unsafe\n      }\n      Term.ensureNoUnassignedMVars decl\n      addAndCompile decl\n    let elabEvalTerm : TermElabM Expr := do\n      let e \u2190 Term.elabTerm term none\n      Term.synthesizeSyntheticMVarsNoPostponing\n      if (\u2190 Term.logUnassignedUsingErrorInfos (\u2190 getMVars e)) then throwAbortTerm\n      if (\u2190 isProp e) then\n        mkDecide e\n      else\n        return e\n    let elabMetaEval : CommandElabM Unit := do\n      let act? \u2190 runTermElabM fun _ => Term.withDeclName declName do\n        let e \u2190 elabEvalTerm\n        let eType \u2190 instantiateMVars (\u2190 inferType e)\n        if eType.isAppOfArity ``CommandElabM 1 then\n          let mut stx \u2190 Term.exprToSyntax e\n          unless (\u2190 isDefEq eType.appArg! (mkConst ``Unit)) do\n            stx \u2190 `($stx >>= fun v => IO.println (repr v))\n          let act \u2190 Lean.Elab.Term.evalTerm (CommandElabM Unit) (mkApp (mkConst ``CommandElabM) (mkConst ``Unit)) stx\n          pure <| some act\n        else\n          let e \u2190 mkRunMetaEval e\n          let env \u2190 getEnv\n          let opts \u2190 getOptions\n          let act \u2190 try addAndCompile e; evalConst (Environment \u2192 Options \u2192 IO (String \u00d7 Except IO.Error Environment)) declName finally setEnv env\n          let (out, res) \u2190 act env opts logInfoAt tk out\n          match res with\n          | Except.error e => throwError e.toString\n          | Except.ok env  => do setEnv env; pure none\n      let some act := act? | return ()\n      act\n    let elabEval : CommandElabM Unit := runTermElabM fun _ => Term.withDeclName declName do\n      let e \u2190 mkRunEval (\u2190 elabEvalTerm)\n      let env \u2190 getEnv\n      let act \u2190 try addAndCompile e; evalConst (IO (String \u00d7 Except IO.Error Unit)) declName finally setEnv env\n      let (out, res) \u2190 liftM (m := IO) act\n      logInfoAt tk out\n      match res with\n      | Except.error e => throwError e.toString\n      | Except.ok _    => pure ()\n    if (\u2190 getEnv).contains ``Lean.MetaEval then do\n      elabMetaEval\n    else\n      elabEval\n  | _ => throwUnsupportedSyntax", "start": [338, 1], "end": [405, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabEval", "code": "@[builtin_command_elab \u00abeval\u00bb, implemented_by elabEvalUnsafe]\nopaque elabEval : CommandElab", "start": [407, 1], "end": [408, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabSynth", "code": "@[builtin_command_elab \u00absynth\u00bb] def elabSynth : CommandElab := fun stx => do\n  let term := stx[1]\n  withoutModifyingEnv <| runTermElabM fun _ => Term.withDeclName `_synth_cmd do\n    let inst \u2190 Term.elabTerm term none\n    Term.synthesizeSyntheticMVarsNoPostponing\n    let inst \u2190 instantiateMVars inst\n    let val  \u2190 synthInstance inst\n    logInfo val\n    pure ()", "start": [410, 1], "end": [418, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabSetOption", "code": "@[builtin_command_elab \u00abset_option\u00bb] def elabSetOption : CommandElab := fun stx => do\n  let options \u2190 Elab.elabSetOption stx[1] stx[2]\n  modify fun s => { s with maxRecDepth := maxRecDepth.get options }\n  modifyScope fun scope => { scope with opts := options }", "start": [420, 1], "end": [423, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandInCmd", "code": "@[builtin_macro Lean.Parser.Command.\u00abin\u00bb] def expandInCmd : Macro\n  | `($cmd\u2081 in $cmd\u2082) => `(section $cmd\u2081:command $cmd\u2082 end)\n  | _                 => Macro.throwUnsupported", "start": [425, 1], "end": [427, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabAddDeclDoc", "code": "@[builtin_command_elab Parser.Command.addDocString] def elabAddDeclDoc : CommandElab := fun stx => do\n  match stx with\n  | `($doc:docComment add_decl_doc $id) =>\n    let declName \u2190 resolveGlobalConstNoOverloadWithInfo id\n    if let .none \u2190 findDeclarationRangesCore? declName then\n      addAuxDeclarationRanges declName stx id\n    addDocString declName (\u2190 getDocStringText doc)\n  | _ => throwUnsupportedSyntax", "start": [429, 1], "end": [438, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabExit", "code": "@[builtin_command_elab Parser.Command.exit] def elabExit : CommandElab := fun _ =>\n  logWarning \"using 'exit' to interrupt Lean\"", "start": [440, 1], "end": [441, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabImport", "code": "@[builtin_command_elab Parser.Command.import] def elabImport : CommandElab := fun _ =>\n  throwError \"invalid 'import' command, it must be used in the beginning of the file\"", "start": [443, 1], "end": [444, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabEoi", "code": "@[builtin_command_elab Parser.Command.eoi] def elabEoi : CommandElab := fun _ =>\n  return", "start": [446, 1], "end": [447, 9], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/LetRec.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Binders.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean", "lake-packages/lean4/src/lean/Lean/Elab/Attributes.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclModifiers.lean"], "premises": [{"full_name": "Lean.Elab.Term.LetRecDeclView", "code": "structure LetRecDeclView where\n  ref           : Syntax\n  attrs         : Array Attribute\n  shortDeclName : Name\n  declName      : Name\n  binderIds     : Array Syntax\n  type          : Expr\n  mvar          : Expr valStx        : Syntax", "start": [15, 1], "end": [23, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.LetRecView", "code": "structure LetRecView where\n  decls     : Array LetRecDeclView\n  body      : Syntax", "start": [25, 1], "end": [27, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkLetRecDeclView", "code": "private def mkLetRecDeclView (letRec : Syntax) : TermElabM LetRecView := do\n  let decls \u2190 letRec[1][0].getSepArgs.mapM fun (attrDeclStx : Syntax) => do\n    let docStr? \u2190 expandOptDocComment? attrDeclStx[0]\n    let attrOptStx := attrDeclStx[1]\n    let attrs \u2190 if attrOptStx.isNone then pure #[] else elabDeclAttrs attrOptStx[0]\n    let decl := attrDeclStx[2][0]\n    if decl.isOfKind `Lean.Parser.Term.letPatDecl then\n      throwErrorAt decl \"patterns are not allowed in 'let rec' expressions\"\n    else if decl.isOfKind `Lean.Parser.Term.letIdDecl || decl.isOfKind `Lean.Parser.Term.letEqnsDecl then\n      let declId := decl[0]\n      unless declId.isIdent do\n        throwErrorAt declId \"'let rec' expressions must be named\"\n      let shortDeclName := declId.getId\n      let currDeclName? \u2190 getDeclName?\n      let declName := currDeclName?.getD Name.anonymous ++ shortDeclName\n      checkNotAlreadyDeclared declName\n      applyAttributesAt declName attrs AttributeApplicationTime.beforeElaboration\n      addDocString' declName docStr?\n      addAuxDeclarationRanges declName decl declId\n      let binders := decl[1].getArgs\n      let typeStx := expandOptType declId decl[2]\n      let (type, binderIds) \u2190 elabBindersEx binders fun xs => do\n          let type \u2190 elabType typeStx\n          registerCustomErrorIfMVar type typeStx \"failed to infer 'let rec' declaration type\"\n          let (binderIds, xs) := xs.unzip\n          let type \u2190 mkForallFVars xs type\n          pure (type, binderIds)\n      let mvar \u2190 mkFreshExprMVar type MetavarKind.syntheticOpaque\n      let valStx \u2190 if decl.isOfKind `Lean.Parser.Term.letIdDecl then\n        pure decl[4]\n      else\n        liftMacroM <| expandMatchAltsIntoMatch decl decl[3]\n      pure { ref := declId, attrs, shortDeclName, declName, binderIds, type, mvar, valStx : LetRecDeclView }\n    else\n      throwUnsupportedSyntax\n  return { decls, body := letRec[3] }", "start": [30, 1], "end": [65, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withAuxLocalDecls", "code": "private partial def withAuxLocalDecls {\u03b1} (views : Array LetRecDeclView) (k : Array Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  let rec loop (i : Nat) (fvars : Array Expr) : TermElabM \u03b1 :=\n    if h : i < views.size then\n      let view := views.get \u27e8i, h\u27e9\n      withAuxDecl view.shortDeclName view.type view.declName fun fvar => loop (i+1) (fvars.push fvar)\n    else\n      k fvars\n  loop 0 #[]", "start": [67, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLetRecDeclValues", "code": "private def elabLetRecDeclValues (view : LetRecView) : TermElabM (Array Expr) :=\n  view.decls.mapM fun view => do\n    forallBoundedTelescope view.type view.binderIds.size fun xs type => do\n      for i in [0:view.binderIds.size] do\n        addLocalVarInfo view.binderIds[i]! xs[i]!\n      withDeclName view.declName do\n         let value \u2190 elabTermEnsuringType view.valStx type\n         mkLambdaFVars xs value", "start": [76, 1], "end": [84, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerLetRecsToLift", "code": "private def registerLetRecsToLift (views : Array LetRecDeclView) (fvars : Array Expr) (values : Array Expr) : TermElabM Unit := do\n  let letRecsToLiftCurr := (\u2190 get).letRecsToLift\n  for view in views do\n    if letRecsToLiftCurr.any fun toLift => toLift.declName == view.declName then\n      withRef view.ref do\n        throwError \"'{view.declName}' has already been declared\"\n  let lctx \u2190 getLCtx\n  let localInstances \u2190 getLocalInstances\n  let toLift := views.mapIdx fun i view => {\n    ref            := view.ref\n    fvarId         := fvars[i]!.fvarId!\n    attrs          := view.attrs\n    shortDeclName  := view.shortDeclName\n    declName       := view.declName\n    lctx\n    localInstances\n    type           := view.type\n    val            := values[i]!\n    mvarId         := view.mvar.mvarId!\n    : LetRecToLift }\n  modify fun s => { s with letRecsToLift := toLift.toList ++ s.letRecsToLift }", "start": [86, 1], "end": [106, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLetRec", "code": "@[builtin_term_elab \u00abletrec\u00bb] def elabLetRec : TermElab := fun stx expectedType? => do\n  let view \u2190 mkLetRecDeclView stx\n  withAuxLocalDecls view.decls fun fvars => do\n    for decl in view.decls, fvar in fvars do\n      addLocalVarInfo decl.ref fvar\n    let values \u2190 elabLetRecDeclValues view\n    let body \u2190 elabTermEnsuringType view.body expectedType?\n    registerLetRecsToLift view.decls fvars values\n    let mvars := view.decls.map (\u00b7.mvar)\n    return mkAppN (\u2190 mkLambdaFVars fvars body) mvars", "start": [108, 1], "end": [117, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Unfold.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Cache.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Injection.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Induction.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Congr.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Simp.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Generalize.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Meta.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Delta.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Split.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/BuiltinTactic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Match.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Calc.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/InheritDoc.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Main.lean", "lake-packages/lean4/src/lean/Lean/DocString.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/StructInst.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/App.lean", "lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/Binders.lean", "lake-packages/lean4/src/lean/Lean/Meta/Structure.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Util/FindExpr.lean"], "premises": [{"full_name": "Lean.Elab.Term.StructInst.expandStructInstExpectedType", "code": "@[builtin_macro Lean.Parser.Term.structInst] def expandStructInstExpectedType : Macro := fun stx =>\n  let expectedArg := stx[4]\n  if expectedArg.isNone then\n    Macro.throwUnsupported\n  else\n    let expected := expectedArg[1]\n    let stxNew   := stx.setArg 4 mkNullNode\n    `(($stxNew : $expected))", "start": [27, 1], "end": [34, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.expandStructInstFieldAbbrev", "code": "@[builtin_macro Lean.Parser.Term.structInst] def expandStructInstFieldAbbrev : Macro\n  | `({ $[$srcs,* with]? $fields,* $[..%$ell]? $[: $ty]? }) =>\n    if fields.getElems.raw.any (\u00b7.getKind == ``Lean.Parser.Term.structInstFieldAbbrev) then do\n      let fieldsNew \u2190 fields.getElems.mapM fun\n        | `(Parser.Term.structInstFieldAbbrev| $id:ident) =>\n          `(Parser.Term.structInstField| $id:ident := $id:ident)\n        | field => return field\n      `({ $[$srcs,* with]? $fieldsNew,* $[..%$ell]? $[: $ty]? })\n    else\n      Macro.throwUnsupported\n  | _ => Macro.throwUnsupported", "start": [36, 1], "end": [47, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.expandNonAtomicExplicitSources", "code": "private def expandNonAtomicExplicitSources (stx : Syntax) : TermElabM (Option Syntax) := do\n  let sourcesOpt := stx[1]\n  if sourcesOpt.isNone then\n    return none\n  else\n    let sources := sourcesOpt[0]\n    if sources.isMissing then\n      throwAbortTerm\n    let sources := sources.getSepArgs\n    if (\u2190 sources.allM fun source => return (\u2190 isLocalIdent? source).isSome) then\n      return none\n    if sources.any (\u00b7.isMissing) then\n      throwAbortTerm\n    return some (\u2190 go sources.toList #[])\nwhere\n  go (sources : List Syntax) (sourcesNew : Array Syntax) : TermElabM Syntax := do\n    match sources with\n    | [] =>\n      let sources := Syntax.mkSep sourcesNew (mkAtomFrom stx \", \")\n      return stx.setArg 1 (stx[1].setArg 0 sources)\n    | source :: sources =>\n      if (\u2190 isLocalIdent? source).isSome then\n        go sources (sourcesNew.push source)\n      else\n        withFreshMacroScope do\n          let sourceNew \u2190 `(src)\n          let r \u2190 go sources (sourcesNew.push sourceNew)\n          `(let src := $source; $r)", "start": [49, 1], "end": [81, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.ExplicitSourceInfo", "code": "structure ExplicitSourceInfo where\n  stx        : Syntax\n  structName : Name\n  deriving Inhabited", "start": [83, 1], "end": [86, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Source", "code": "structure Source where\n  explicit : Array ExplicitSourceInfo implicit : Option Syntax deriving Inhabited", "start": [88, 1], "end": [91, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Source.isNone", "code": "def Source.isNone : Source \u2192 Bool\n  | { explicit := #[], implicit := none } => true\n  | _ => false", "start": [93, 1], "end": [95, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.mkSourcesWithSyntax", "code": "private def mkSourcesWithSyntax (sources : Array Syntax) : Syntax :=\n  let ref := sources[0]!\n  let stx := Syntax.mkSep sources (mkAtomFrom ref \", \")\n  mkNullNode #[stx, mkAtomFrom ref \"with \"]", "start": [97, 1], "end": [101, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.getStructSource", "code": "private def getStructSource (structStx : Syntax) : TermElabM Source :=\n  withRef structStx do\n    let explicitSource := structStx[1]\n    let implicitSource := structStx[3]\n    let explicit \u2190 if explicitSource.isNone then\n      pure #[]\n    else\n      explicitSource[0].getSepArgs.mapM fun stx => do\n        let some src \u2190 isLocalIdent? stx | unreachable!\n        addTermInfo' stx src\n        let srcType \u2190 whnf (\u2190 inferType src)\n        tryPostponeIfMVar srcType\n        let structName \u2190 getStructureName srcType\n        return { stx, structName }\n    let implicit := if implicitSource[0].isNone then none else implicitSource\n    return { explicit, implicit }", "start": [103, 1], "end": [118, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.isModifyOp?", "code": "private def isModifyOp? (stx : Syntax) : TermElabM (Option Syntax) := do\n  let s? \u2190 stx[2].getSepArgs.foldlM (init := none) fun s? arg => do\n    \n    if arg.getKind == ``Lean.Parser.Term.structInstField then\n      \n      let lval := arg[0]\n      let k    := lval[0].getKind\n      if k == ``Lean.Parser.Term.structInstArrayRef then\n        match s? with\n        | none   => return some arg\n        | some s =>\n          if s.getKind == ``Lean.Parser.Term.structInstArrayRef then\n            throwErrorAt arg \"invalid \\{...} notation, at most one `[..]` at a given level\"\n          else\n            throwErrorAt arg \"invalid \\{...} notation, can't mix field and `[..]` at a given level\"\n      else\n        match s? with\n        | none   => return some arg\n        | some s =>\n          if s.getKind == ``Lean.Parser.Term.structInstArrayRef then\n            throwErrorAt arg \"invalid \\{...} notation, can't mix field and `[..]` at a given level\"\n          else\n            return s?\n    else\n      return s?\n  match s? with\n  | none   => return none\n  | some s => if s[0][0].getKind == ``Lean.Parser.Term.structInstArrayRef then return s? else return none", "start": [120, 1], "end": [158, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.elabModifyOp", "code": "private def elabModifyOp (stx modifyOp : Syntax) (sources : Array ExplicitSourceInfo) (expectedType? : Option Expr) : TermElabM Expr := do\n  if sources.size > 1 then\n    throwError \"invalid \\{...} notation, multiple sources and array update is not supported.\"\n  let cont (val : Syntax) : TermElabM Expr := do\n    let lval := modifyOp[0][0]\n    let idx  := lval[1]\n    let self := sources[0]!.stx\n    let stxNew \u2190 `($(self).modifyOp (idx := $idx) (fun s => $val))\n    trace[Elab.struct.modifyOp] \"{stx}\\n===>\\n{stxNew}\"\n    withMacroExpansion stx stxNew <| elabTerm stxNew expectedType?\n  let rest := modifyOp[0][1]\n  if rest.isNone then\n    cont modifyOp[2]\n  else\n    let s \u2190 `(s)\n    let valFirst  := rest[0]\n    let valFirst  := if valFirst.getKind == ``Lean.Parser.Term.structInstArrayRef then valFirst else valFirst[1]\n    let restArgs  := rest.getArgs\n    let valRest   := mkNullNode restArgs[1:restArgs.size]\n    let valField  := modifyOp.setArg 0 <| mkNode ``Parser.Term.structInstLVal #[valFirst, valRest]\n    let valSource := mkSourcesWithSyntax #[s]\n    let val       := stx.setArg 1 valSource\n    let val       := val.setArg 2 <| mkNullNode #[valField]\n    trace[Elab.struct.modifyOp] \"{stx}\\nval: {val}\"\n    cont val", "start": [160, 1], "end": [184, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.getStructName", "code": "private def getStructName (expectedType? : Option Expr) (sourceView : Source) : TermElabM Name := do\n  tryPostponeIfNoneOrMVar expectedType?\n  let useSource : Unit \u2192 TermElabM Name := fun _ => do\n    unless sourceView.explicit.isEmpty do\n      return sourceView.explicit[0]!.structName\n    match expectedType? with\n    | some expectedType => throwUnexpectedExpectedType expectedType\n    | none => throwUnknownExpectedType\n  match expectedType? with\n  | none => useSource ()\n  | some expectedType =>\n    let expectedType \u2190 whnf expectedType\n    match expectedType.getAppFn with\n    | Expr.const constName _ =>\n      unless isStructure (\u2190 getEnv) constName do\n        throwError \"invalid \\{...} notation, structure type expected{indentExpr expectedType}\"\n      return constName\n    | _                        => useSource ()\nwhere\n  throwUnknownExpectedType :=\n    throwError \"invalid \\{...} notation, expected type is not known\"\n  throwUnexpectedExpectedType type (kind := \"expected\") := do\n    let type \u2190 instantiateMVars type\n    if type.getAppFn.isMVar then\n      throwUnknownExpectedType\n    else\n      throwError \"invalid \\{...} notation, {kind} type is not of the form (C ...){indentExpr type}\"", "start": [186, 1], "end": [218, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.FieldLHS", "code": "inductive FieldLHS where\n  | fieldName  (ref : Syntax) (name : Name)\n  | fieldIndex (ref : Syntax) (idx : Nat)\n  | modifyOp   (ref : Syntax) (index : Syntax)\n  deriving Inhabited", "start": [220, 1], "end": [224, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.FieldVal", "code": "inductive FieldVal (\u03c3 : Type) where\n  | term  (stx : Syntax) : FieldVal \u03c3\n  | nested (s : \u03c3)       : FieldVal \u03c3\n  | default              : FieldVal \u03c3 deriving Inhabited", "start": [232, 1], "end": [236, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Field", "code": "structure Field (\u03c3 : Type) where\n  ref   : Syntax\n  lhs   : List FieldLHS\n  val   : FieldVal \u03c3\n  expr? : Option Expr := none\n  deriving Inhabited", "start": [238, 1], "end": [243, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Field.isSimple", "code": "def Field.isSimple {\u03c3} : Field \u03c3 \u2192 Bool\n  | { lhs := [_], .. } => true\n  | _                  => false", "start": [245, 1], "end": [247, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct", "code": "inductive Struct where\n  \n  | mk (ref : Syntax) (structName : Name) (params : Array (Name \u00d7 Expr)) (fields : List (Field Struct)) (source : Source)\n  deriving Inhabited", "start": [249, 1], "end": [252, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Fields", "code": "abbrev Fields := List (Field Struct)", "start": [254, 1], "end": [254, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.ref", "code": "def Struct.ref : Struct \u2192 Syntax\n  | \u27e8ref, _, _, _, _\u27e9 => ref", "start": [256, 1], "end": [257, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.structName", "code": "def Struct.structName : Struct \u2192 Name\n  | \u27e8_, structName, _, _, _\u27e9 => structName", "start": [259, 1], "end": [260, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.params", "code": "def Struct.params : Struct \u2192 Array (Name \u00d7 Expr)\n  | \u27e8_, _, params, _, _\u27e9 => params", "start": [262, 1], "end": [263, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.fields", "code": "def Struct.fields : Struct \u2192 Fields\n  | \u27e8_, _, _, fields, _\u27e9 => fields", "start": [265, 1], "end": [266, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.source", "code": "def Struct.source : Struct \u2192 Source\n  | \u27e8_, _, _, _, s\u27e9 => s", "start": [268, 1], "end": [269, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.allDefault", "code": "partial def Struct.allDefault (s : Struct) : Bool :=\n  s.fields.all fun { val := val,  .. } => match val with\n    | .term _   => false\n    | .default  => true\n    | .nested s => allDefault s", "start": [271, 1], "end": [276, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.formatField", "code": "def formatField (formatStruct : Struct \u2192 Format) (field : Field Struct) : Format :=\n  Format.joinSep field.lhs \" . \" ++ \" := \" ++\n    match field.val with\n    | .term v   => v.prettyPrint\n    | .nested s => formatStruct s\n    | .default  => \"<default>\"", "start": [278, 1], "end": [283, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.formatStruct", "code": "partial def formatStruct : Struct \u2192 Format\n  | \u27e8_, _,          _, fields, source\u27e9 =>\n    let fieldsFmt := Format.joinSep (fields.map (formatField formatStruct)) \", \"\n    let implicitFmt := if source.implicit.isSome then \" .. \" else \"\"\n    if source.explicit.isEmpty then\n      \"{\" ++ fieldsFmt ++ implicitFmt ++ \"}\"\n    else\n      \"{\" ++ format (source.explicit.map (\u00b7.stx)) ++ \" with \" ++ fieldsFmt ++ implicitFmt ++ \"}\"", "start": [285, 1], "end": [292, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.FieldLHS.toSyntax", "code": "def FieldLHS.toSyntax (first : Bool) : FieldLHS \u2192 Syntax\n  | .modifyOp   stx _    => stx\n  | .fieldName  stx name => if first then mkIdentFrom stx name else mkGroupNode #[mkAtomFrom stx \".\", mkIdentFrom stx name]\n  | .fieldIndex stx _    => if first then stx else mkGroupNode #[mkAtomFrom stx \".\", stx]", "start": [309, 1], "end": [312, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.FieldVal.toSyntax", "code": "def FieldVal.toSyntax : FieldVal Struct \u2192 Syntax\n  | .term stx => stx\n  | _                 => unreachable!", "start": [314, 1], "end": [316, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Field.toSyntax", "code": "def Field.toSyntax : Field Struct \u2192 Syntax\n  | field =>\n    let stx := field.ref\n    let stx := stx.setArg 2 field.val.toSyntax\n    match field.lhs with\n    | first::rest => stx.setArg 0 <| mkNullNode #[first.toSyntax true, mkNullNode <| rest.toArray.map (FieldLHS.toSyntax false) ]\n    | _ => unreachable!", "start": [318, 1], "end": [324, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.toFieldLHS", "code": "private def toFieldLHS (stx : Syntax) : MacroM FieldLHS :=\n  if stx.getKind == ``Lean.Parser.Term.structInstArrayRef then\n    return FieldLHS.modifyOp stx stx[1]\n  else\n    let stx := if stx.getKind == groupKind then stx[1] else stx\n    if stx.isIdent then\n      return FieldLHS.fieldName stx stx.getId.eraseMacroScopes\n    else match stx.isFieldIdx? with\n      | some idx => return FieldLHS.fieldIndex stx idx\n      | none     => Macro.throwError \"unexpected structure syntax\"", "start": [326, 1], "end": [336, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.mkStructView", "code": "private def mkStructView (stx : Syntax) (structName : Name) (source : Source) : MacroM Struct := do\n  \n  let fields \u2190 stx[2].getSepArgs.toList.mapM fun fieldStx => do\n    let val      := fieldStx[2]\n    let first    \u2190 toFieldLHS fieldStx[0][0]\n    let rest     \u2190 fieldStx[0][1].getArgs.toList.mapM toFieldLHS\n    return { ref := fieldStx, lhs := first :: rest, val := FieldVal.term val : Field Struct }\n  return \u27e8stx, structName, #[], fields, source\u27e9", "start": [338, 1], "end": [355, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.modifyFieldsM", "code": "def Struct.modifyFieldsM {m : Type \u2192 Type} [Monad m] (s : Struct) (f : Fields \u2192 m Fields) : m Struct :=\n  match s with\n  | \u27e8ref, structName, params, fields, source\u27e9 => return \u27e8ref, structName, params, (\u2190 f fields), source\u27e9", "start": [357, 1], "end": [359, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.modifyFields", "code": "def Struct.modifyFields (s : Struct) (f : Fields \u2192 Fields) : Struct :=\n  Id.run <| s.modifyFieldsM f", "start": [361, 1], "end": [362, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.setFields", "code": "def Struct.setFields (s : Struct) (fields : Fields) : Struct :=\n  s.modifyFields fun _ => fields", "start": [364, 1], "end": [365, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.Struct.setParams", "code": "def Struct.setParams (s : Struct) (ps : Array (Name \u00d7 Expr)) : Struct :=\n  match s with\n  | \u27e8ref, structName, _, fields, source\u27e9 => \u27e8ref, structName, ps, fields, source\u27e9", "start": [367, 1], "end": [369, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.expandCompositeFields", "code": "private def expandCompositeFields (s : Struct) : Struct :=\n  s.modifyFields fun fields => fields.map fun field => match field with\n    | { lhs := .fieldName _ (.str Name.anonymous ..) :: _, .. } => field\n    | { lhs := .fieldName ref n@(.str ..) :: rest, .. } =>\n      let newEntries := n.components.map <| FieldLHS.fieldName ref\n      { field with lhs := newEntries ++ rest }\n    | _ => field", "start": [371, 1], "end": [377, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.expandNumLitFields", "code": "private def expandNumLitFields (s : Struct) : TermElabM Struct :=\n  s.modifyFieldsM fun fields => do\n    let env \u2190 getEnv\n    let fieldNames := getStructureFields env s.structName\n    fields.mapM fun field => match field with\n      | { lhs := .fieldIndex ref idx :: rest, .. } =>\n        if idx == 0 then throwErrorAt ref \"invalid field index, index must be greater than 0\"\n        else if idx > fieldNames.size then throwErrorAt ref \"invalid field index, structure has only #{fieldNames.size} fields\"\n        else return { field with lhs := .fieldName ref fieldNames[idx - 1]! :: rest }\n      | _ => return field", "start": [379, 1], "end": [388, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.expandParentFields", "code": "private def expandParentFields (s : Struct) : TermElabM Struct := do\n  let env \u2190 getEnv\n  s.modifyFieldsM fun fields => fields.mapM fun field => do match field with\n    | { lhs := .fieldName ref fieldName :: _,    .. } =>\n      addCompletionInfo <| CompletionInfo.fieldId ref fieldName (\u2190 getLCtx) s.structName\n      match findField? env s.structName fieldName with\n      | none => throwErrorAt ref \"'{fieldName}' is not a field of structure '{s.structName}'\"\n      | some baseStructName =>\n        if baseStructName == s.structName then pure field\n        else match getPathToBaseStructure? env baseStructName s.structName with\n          | some path =>\n            let path := path.map fun funName => match funName with\n              | .str _ s => .fieldName ref (Name.mkSimple s)\n              | _        => unreachable!\n            return { field with lhs := path ++ field.lhs }\n          | _ => throwErrorAt ref \"failed to access field '{fieldName}' in parent structure\"\n    | _ => return field", "start": [390, 1], "end": [427, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.FieldMap", "code": "private abbrev FieldMap := HashMap Name Fields", "start": [429, 1], "end": [429, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.mkFieldMap", "code": "private def mkFieldMap (fields : Fields) : TermElabM FieldMap :=\n  fields.foldlM (init := {}) fun fieldMap field =>\n    match field.lhs with\n    | .fieldName _ fieldName :: _    =>\n      match fieldMap.find? fieldName with\n      | some (prevField::restFields) =>\n        if field.isSimple || prevField.isSimple then\n          throwErrorAt field.ref \"field '{fieldName}' has already been specified\"\n        else\n          return fieldMap.insert fieldName (field::prevField::restFields)\n      | _ => return fieldMap.insert fieldName [field]\n    | _ => unreachable!", "start": [431, 1], "end": [442, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.isSimpleField?", "code": "private def isSimpleField? : Fields \u2192 Option (Field Struct)\n  | [field] => if field.isSimple then some field else none\n  | _       => none", "start": [444, 1], "end": [446, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.getFieldIdx", "code": "private def getFieldIdx (structName : Name) (fieldNames : Array Name) (fieldName : Name) : TermElabM Nat := do\n  match fieldNames.findIdx? fun n => n == fieldName with\n  | some idx => return idx\n  | none     => throwError \"field '{fieldName}' is not a valid field of '{structName}'\"", "start": [448, 1], "end": [451, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.mkProjStx?", "code": "def mkProjStx? (s : Syntax) (structName : Name) (fieldName : Name) : TermElabM (Option Syntax) := do\n  if (findField? (\u2190 getEnv) structName fieldName).isNone then\n    return none\n  return some <| mkNode ``Parser.Term.proj #[s, mkAtomFrom s \".\", mkIdentFrom s fieldName]", "start": [453, 1], "end": [456, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.findField?", "code": "def findField? (fields : Fields) (fieldName : Name) : Option (Field Struct) :=\n  fields.find? fun field =>\n    match field.lhs with\n    | [.fieldName _ n] => n == fieldName\n    | _                => false", "start": [458, 1], "end": [462, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.groupFields", "code": "private partial def groupFields (s : Struct) : TermElabM Struct := do\n    let env \u2190 getEnv\n    withRef s.ref do\n    s.modifyFieldsM fun fields => do\n      let fieldMap \u2190 mkFieldMap fields\n      fieldMap.toList.mapM fun \u27e8fieldName, fields\u27e9 => do\n        match isSimpleField? fields with\n        | some field => pure field\n        | none =>\n          let substructFields := fields.map fun field => { field with lhs := field.lhs.tail! }\n          let field := fields.head!\n          match Lean.isSubobjectField? env s.structName fieldName with\n          | some substructName =>\n            let substruct := Struct.mk s.ref substructName #[] substructFields s.source\n            let substruct \u2190 expandStruct substruct\n            pure { field with lhs := [field.lhs.head!], val := FieldVal.nested substruct }\n          | none =>\n            let updateSource (structStx : Syntax) : TermElabM Syntax := do\n              let sourcesNew \u2190 s.source.explicit.filterMapM fun source => mkProjStx? source.stx source.structName fieldName\n              let explicitSourceStx := if sourcesNew.isEmpty then mkNullNode else mkSourcesWithSyntax sourcesNew\n              let implicitSourceStx := s.source.implicit.getD mkNullNode\n              return (structStx.setArg 1 explicitSourceStx).setArg 3 implicitSourceStx\n            let valStx := s.ref let valStx := valStx.setArg 4 mkNullNode let args   := substructFields.toArray.map (\u00b7.toSyntax)\n            let valStx := valStx.setArg 2 (mkNullNode <| mkSepArray args (mkAtom \",\"))\n            let valStx \u2190 updateSource valStx\n            return { field with lhs := [field.lhs.head!], val := FieldVal.term valStx }", "start": [466, 3], "end": [493, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.addMissingFields", "code": "private partial def addMissingFields (s : Struct) : TermElabM Struct := do\n    let env \u2190 getEnv\n    let fieldNames := getStructureFields env s.structName\n    let ref := s.ref.mkSynthetic\n    withRef ref do\n      let fields \u2190 fieldNames.foldlM (init := []) fun fields fieldName => do\n        match findField? s.fields fieldName with\n        | some field => return field::fields\n        | none       =>\n          let addField (val : FieldVal Struct) : TermElabM Fields := do\n            return { ref, lhs := [FieldLHS.fieldName ref fieldName], val := val } :: fields\n          match Lean.isSubobjectField? env s.structName fieldName with\n          | some substructName =>\n            if let some val \u2190 s.source.explicit.findSomeM? fun source => mkProjStx? source.stx source.structName fieldName then\n              addField (FieldVal.term val)\n            else\n              let substruct := Struct.mk ref substructName #[] [] s.source\n              let substruct \u2190 expandStruct substruct\n              addField (FieldVal.nested substruct)\n          | none =>\n            if let some val \u2190 s.source.explicit.findSomeM? fun source => mkProjStx? source.stx source.structName fieldName then\n              addField (FieldVal.term val)\n            else if s.source.implicit.isSome then\n              addField (FieldVal.term (mkHole ref))\n            else\n              addField FieldVal.default\n      return s.setFields fields.reverse", "start": [495, 3], "end": [522, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.expandStruct", "code": "private partial def expandStruct (s : Struct) : TermElabM Struct := do\n    let s := expandCompositeFields s\n    let s \u2190 expandNumLitFields s\n    let s \u2190 expandParentFields s\n    let s \u2190 groupFields s\n    addMissingFields s", "start": [524, 3], "end": [529, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.CtorHeaderResult", "code": "structure CtorHeaderResult where\n  ctorFn     : Expr\n  ctorFnType : Expr\n  instMVars  : Array MVarId\n  params     : Array (Name \u00d7 Expr)", "start": [533, 1], "end": [537, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.mkCtorHeaderAux", "code": "private def mkCtorHeaderAux : Nat \u2192 Expr \u2192 Expr \u2192 Array MVarId \u2192 Array (Name \u00d7 Expr) \u2192 TermElabM CtorHeaderResult\n  | 0,   type, ctorFn, instMVars, params => return { ctorFn , ctorFnType := type, instMVars, params }\n  | n+1, type, ctorFn, instMVars, params => do\n    match (\u2190 whnfForall type) with\n    | .forallE paramName d b c =>\n      match c with\n      | .instImplicit =>\n        let a \u2190 mkFreshExprMVar d .synthetic\n        mkCtorHeaderAux n (b.instantiate1 a) (mkApp ctorFn a) (instMVars.push a.mvarId!) (params.push (paramName, a))\n      | _ =>\n        let a \u2190 mkFreshExprMVar d\n        mkCtorHeaderAux n (b.instantiate1 a) (mkApp ctorFn a) instMVars (params.push (paramName, a))\n    | _ => throwError \"unexpected constructor type\"", "start": [539, 1], "end": [551, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.getForallBody", "code": "private partial def getForallBody : Nat \u2192 Expr \u2192 Option Expr\n  | i+1, .forallE _ _ b _ => getForallBody i b\n  | _+1, _                => none\n  | 0,   type             => type", "start": [553, 1], "end": [556, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.propagateExpectedType", "code": "private def propagateExpectedType (type : Expr) (numFields : Nat) (expectedType? : Option Expr) : TermElabM Unit := do\n  match expectedType? with\n  | none              => return ()\n  | some expectedType =>\n    match getForallBody numFields type with\n      | none           => pure ()\n      | some typeBody =>\n        unless typeBody.hasLooseBVars do\n          discard <| isDefEq expectedType typeBody", "start": [558, 1], "end": [566, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.mkCtorHeader", "code": "private def mkCtorHeader (ctorVal : ConstructorVal) (expectedType? : Option Expr) : TermElabM CtorHeaderResult := do\n  let us \u2190 mkFreshLevelMVars ctorVal.levelParams.length\n  let val  := Lean.mkConst ctorVal.name us\n  let type \u2190 instantiateTypeLevelParams (ConstantInfo.ctorInfo ctorVal) us\n  let r \u2190 mkCtorHeaderAux ctorVal.numParams type val #[] #[]\n  propagateExpectedType r.ctorFnType ctorVal.numFields expectedType?\n  synthesizeAppInstMVars r.instMVars r.ctorFn\n  return r", "start": [568, 1], "end": [575, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.markDefaultMissing", "code": "def markDefaultMissing (e : Expr) : Expr :=\n  mkAnnotation `structInstDefault e", "start": [577, 1], "end": [578, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.defaultMissing?", "code": "def defaultMissing? (e : Expr) : Option Expr :=\n  annotation? `structInstDefault e", "start": [580, 1], "end": [581, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.throwFailedToElabField", "code": "def throwFailedToElabField {\u03b1} (fieldName : Name) (structName : Name) (msgData : MessageData) : TermElabM \u03b1 :=\n  throwError \"failed to elaborate field '{fieldName}' of '{structName}, {msgData}\"", "start": [583, 1], "end": [584, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.trySynthStructInstance?", "code": "def trySynthStructInstance? (s : Struct) (expectedType : Expr) : TermElabM (Option Expr) := do\n  if !s.allDefault then\n    return none\n  else\n    try synthInstance? expectedType catch _ => return none", "start": [586, 1], "end": [590, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.ElabStructResult", "code": "structure ElabStructResult where\n  val       : Expr\n  struct    : Struct\n  instMVars : Array MVarId", "start": [592, 1], "end": [595, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.elabStruct", "code": "private partial def elabStruct (s : Struct) (expectedType? : Option Expr) : TermElabM ElabStructResult := withRef s.ref do\n  let env \u2190 getEnv\n  let ctorVal := getStructureCtor env s.structName\n  if isPrivateNameFromImportedModule env ctorVal.name then\n    throwError \"invalid \\{...} notation, constructor for `{s.structName}` is marked as private\"\n  let { ctorFn, ctorFnType, params, .. } \u2190 mkCtorHeader ctorVal expectedType?\n  let (e, _, fields, instMVars) \u2190 s.fields.foldlM (init := (ctorFn, ctorFnType, [], #[])) fun (e, type, fields, instMVars) field => do\n    match field.lhs with\n    | [.fieldName ref fieldName] =>\n      let type \u2190 whnfForall type\n      trace[Elab.struct] \"elabStruct {field}, {type}\"\n      match type with\n      | .forallE _ d b bi =>\n        let cont (val : Expr) (field : Field Struct) (instMVars := instMVars) : TermElabM (Expr \u00d7 Expr \u00d7 Fields \u00d7 Array MVarId) := do\n          pushInfoTree <| InfoTree.node (children := {}) <| Info.ofFieldInfo {\n            projName := s.structName.append fieldName, fieldName, lctx := (\u2190 getLCtx), val, stx := ref }\n          let e     := mkApp e val\n          let type  := b.instantiate1 val\n          let field := { field with expr? := some val }\n          return (e, type, field::fields, instMVars)\n        match field.val with\n        | .term stx => cont (\u2190 elabTermEnsuringType stx d.consumeTypeAnnotations) field\n        | .nested s =>\n          match (\u2190 trySynthStructInstance? s d) with\n          | some val => cont val { field with val := FieldVal.term (mkHole field.ref) }\n          | none     =>\n            let { val, struct := sNew, instMVars := instMVarsNew } \u2190 elabStruct s (some d)\n            let val \u2190 ensureHasType d val\n            cont val { field with val := FieldVal.nested sNew } (instMVars ++ instMVarsNew)\n        | .default  =>\n          match d.getAutoParamTactic? with\n          | some (.const tacticDecl ..) =>\n            match evalSyntaxConstant env (\u2190 getOptions) tacticDecl with\n            | .error err       => throwError err\n            | .ok tacticSyntax =>\n              let stx \u2190 `(by $tacticSyntax)\n              cont (\u2190 elabTermEnsuringType stx (d.getArg! 0).consumeTypeAnnotations) field\n          | _ =>\n            if bi == .instImplicit then\n              let val \u2190 withRef field.ref <| mkFreshExprMVar d .synthetic\n              cont val field (instMVars.push val.mvarId!)\n            else\n              let val \u2190 withRef field.ref <| mkFreshExprMVar (some d)\n              cont (markDefaultMissing val) field\n      | _ => withRef field.ref <| throwFailedToElabField fieldName s.structName m!\"unexpected constructor type{indentExpr type}\"\n    | _ => throwErrorAt field.ref \"unexpected unexpanded structure field\"\n  return { val := e, struct := s.setFields fields.reverse |>.setParams params, instMVars }", "start": [597, 1], "end": [645, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.Context", "code": "structure Context where\n  structs : Array Struct := #[]\n  allStructNames : Array Name := #[]\n  \n  maxDistance : Nat := 0", "start": [649, 1], "end": [679, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.State", "code": "structure State where\n  progress : Bool := false", "start": [681, 1], "end": [682, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.collectStructNames", "code": "partial def collectStructNames (struct : Struct) (names : Array Name) : Array Name :=\n  let names := names.push struct.structName\n  struct.fields.foldl (init := names) fun names field =>\n    match field.val with\n    | .nested struct => collectStructNames struct names\n    | _ => names", "start": [684, 1], "end": [689, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.getHierarchyDepth", "code": "partial def getHierarchyDepth (struct : Struct) : Nat :=\n  struct.fields.foldl (init := 0) fun max field =>\n    match field.val with\n    | .nested struct => Nat.max max (getHierarchyDepth struct + 1)\n    | _ => max", "start": [691, 1], "end": [695, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.isDefaultMissing?", "code": "def isDefaultMissing? [Monad m] [MonadMCtx m] (field : Field Struct) : m Bool := do\n  if let some expr := field.expr? then\n    if let some (.mvar mvarId) := defaultMissing? expr then\n      unless (\u2190 mvarId.isAssigned) do\n        return true\n  return false", "start": [697, 1], "end": [702, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.findDefaultMissing?", "code": "partial def findDefaultMissing? [Monad m] [MonadMCtx m] (struct : Struct) : m (Option (Field Struct)) :=\n  struct.fields.findSomeM? fun field => do\n   match field.val with\n   | .nested struct => findDefaultMissing? struct\n   | _ => return if (\u2190 isDefaultMissing? field) then field else none", "start": [704, 1], "end": [708, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.allDefaultMissing", "code": "partial def allDefaultMissing [Monad m] [MonadMCtx m] (struct : Struct) : m (Array (Field Struct)) :=\n  go struct *> get |>.run' #[]\nwhere\n  go (struct : Struct) : StateT (Array (Field Struct)) m Unit :=\n    for field in struct.fields do\n      if let .nested struct := field.val then\n        go struct\n      else if (\u2190 isDefaultMissing? field) then\n        modify (\u00b7.push field)", "start": [710, 1], "end": [718, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.getFieldName", "code": "def getFieldName (field : Field Struct) : Name :=\n  match field.lhs with\n  | [.fieldName _ fieldName] => fieldName\n  | _ => unreachable!", "start": [720, 1], "end": [723, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.M", "code": "abbrev M := ReaderT Context (StateRefT State TermElabM)", "start": [725, 1], "end": [725, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.isRoundDone", "code": "def isRoundDone : M Bool := do\n  return (\u2190 get).progress && (\u2190 read).maxDistance > 0", "start": [727, 1], "end": [728, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.getFieldValue?", "code": "def getFieldValue? (struct : Struct) (fieldName : Name) : Option Expr :=\n  struct.fields.findSome? fun field =>\n    if getFieldName field == fieldName then\n      field.expr?\n    else\n      none", "start": [730, 1], "end": [735, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.mkDefaultValueAux?", "code": "partial def mkDefaultValueAux? (struct : Struct) : Expr \u2192 TermElabM (Option Expr)\n  | .lam n d b c => withRef struct.ref do\n    if c.isExplicit then\n      let fieldName := n\n      match getFieldValue? struct fieldName with\n      | none     => return none\n      | some val =>\n        let valType \u2190 inferType val\n        if (\u2190 isDefEq valType d) then\n          mkDefaultValueAux? struct (b.instantiate1 val)\n        else\n          return none\n    else\n      if let some (_, param) := struct.params.find? fun (paramName, _) => paramName == n then\n        if (\u2190 isDefEq (\u2190 inferType param) d) then\n          mkDefaultValueAux? struct (b.instantiate1 param)\n        else\n          return none\n      else\n        let arg \u2190 mkFreshExprMVar d\n        mkDefaultValueAux? struct (b.instantiate1 arg)\n  | e =>\n    if e.isAppOfArity ``id 2 then\n      return some e.appArg!\n    else\n      return some e", "start": [737, 1], "end": [763, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.mkDefaultValue?", "code": "def mkDefaultValue? (struct : Struct) (cinfo : ConstantInfo) : TermElabM (Option Expr) :=\n  withRef struct.ref do\n  let us \u2190 mkFreshLevelMVarsFor cinfo\n  mkDefaultValueAux? struct (\u2190 instantiateValueLevelParams cinfo us)", "start": [765, 1], "end": [768, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.reduce", "code": "partial def reduce (structNames : Array Name) (e : Expr) : MetaM Expr := do\n  match e with\n  | .lam ..       => lambdaLetTelescope e fun xs b => do mkLambdaFVars xs (\u2190 reduce structNames b)\n  | .forallE ..   => forallTelescope e fun xs b => do mkForallFVars xs (\u2190 reduce structNames b)\n  | .letE ..      => lambdaLetTelescope e fun xs b => do mkLetFVars xs (\u2190 reduce structNames b)\n  | .proj _ i b   =>\n    match (\u2190 Meta.project? b i) with\n    | some r => reduce structNames r\n    | none   => return e.updateProj! (\u2190 reduce structNames b)\n  | .app f .. =>\n    match (\u2190 reduceProjOf? e structNames.contains) with\n    | some r => reduce structNames r\n    | none   =>\n      let f := f.getAppFn\n      let f' \u2190 reduce structNames f\n      if f'.isLambda then\n        let revArgs := e.getAppRevArgs\n        reduce structNames (f'.betaRev revArgs)\n      else\n        let args \u2190 e.getAppArgs.mapM (reduce structNames)\n        return mkAppN f' args\n  | .mdata _ b =>\n    let b \u2190 reduce structNames b\n    if (defaultMissing? e).isSome && !b.isMVar then\n      return b\n    else\n      return e.updateMData! b\n  | .mvar mvarId =>\n    match (\u2190 getExprMVarAssignment? mvarId) with\n    | some val => if val.isMVar then pure val else reduce structNames val\n    | none     => return e\n  | e => return e", "start": [770, 1], "end": [802, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.tryToSynthesizeDefault", "code": "partial def tryToSynthesizeDefault (structs : Array Struct) (allStructNames : Array Name) (maxDistance : Nat) (fieldName : Name) (mvarId : MVarId) : TermElabM Bool :=\n  let rec loop (i : Nat) (dist : Nat) := do\n    if dist > maxDistance then\n      return false\n    else if h : i < structs.size then\n      let struct := structs.get \u27e8i, h\u27e9\n      match getDefaultFnForField? (\u2190 getEnv) struct.structName fieldName with\n      | some defFn =>\n        let cinfo \u2190 getConstInfo defFn\n        let mctx \u2190 getMCtx\n        match (\u2190 mkDefaultValue? struct cinfo) with\n        | none     => setMCtx mctx; loop (i+1) (dist+1)\n        | some val =>\n          let val \u2190 reduce allStructNames val\n          match val.find? fun e => (defaultMissing? e).isSome with\n          | some _ => setMCtx mctx; loop (i+1) (dist+1)\n          | none   =>\n            let mvarDecl \u2190 getMVarDecl mvarId\n            let val \u2190 ensureHasType mvarDecl.type val\n            mvarId.assign val\n            return true\n      | _ => loop (i+1) dist\n    else\n      return false\n  loop 0 0", "start": [804, 1], "end": [828, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.step", "code": "partial def step (struct : Struct) : M Unit :=\n  unless (\u2190 isRoundDone) do\n    withReader (fun ctx => { ctx with structs := ctx.structs.push struct }) do\n      for field in struct.fields do\n        match field.val with\n        | .nested struct => step struct\n        | _ => match field.expr? with\n          | none      => unreachable!\n          | some expr =>\n            match defaultMissing? expr with\n            | some (.mvar mvarId) =>\n              unless (\u2190 mvarId.isAssigned) do\n                let ctx \u2190 read\n                if (\u2190 withRef field.ref <| tryToSynthesizeDefault ctx.structs ctx.allStructNames ctx.maxDistance (getFieldName field) mvarId) then\n                  modify fun _ => { progress := true }\n            | _ => pure ()", "start": [830, 1], "end": [845, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.propagateLoop", "code": "partial def propagateLoop (hierarchyDepth : Nat) (d : Nat) (struct : Struct) : M Unit := do\n  match (\u2190 findDefaultMissing? struct) with\n  | none       => return () | some field =>\n    trace[Elab.struct] \"propagate [{d}] [field := {field}]: {struct}\"\n    if d > hierarchyDepth then\n      let missingFields := (\u2190 allDefaultMissing struct).map getFieldName\n      let missingFieldsWithoutDefault :=\n        let env := (\u2190 getEnv)\n        let structs := (\u2190 read).allStructNames\n        missingFields.filter fun fieldName => structs.all fun struct =>\n          (getDefaultFnForField? env struct fieldName).isNone\n      let fieldsToReport :=\n        if missingFieldsWithoutDefault.isEmpty then missingFields else missingFieldsWithoutDefault\n      throwErrorAt field.ref \"fields missing: {fieldsToReport.toList.map (s!\"'{\u00b7}'\") |> \", \".intercalate}\"\n    else withReader (fun ctx => { ctx with maxDistance := d }) do\n      modify fun _ => { progress := false }\n      step struct\n      if (\u2190 get).progress then\n        propagateLoop hierarchyDepth 0 struct\n      else\n        propagateLoop hierarchyDepth (d+1) struct", "start": [847, 1], "end": [868, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.DefaultFields.propagate", "code": "def propagate (struct : Struct) : TermElabM Unit :=\n  let hierarchyDepth := getHierarchyDepth struct\n  let structNames := collectStructNames struct #[]\n  propagateLoop hierarchyDepth 0 struct { allStructNames := structNames } |>.run' {}", "start": [870, 1], "end": [873, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.elabStructInstAux", "code": "private def elabStructInstAux (stx : Syntax) (expectedType? : Option Expr) (source : Source) : TermElabM Expr := do\n  let structName \u2190 getStructName expectedType? source\n  let struct \u2190 liftMacroM <| mkStructView stx structName source\n  let struct \u2190 expandStruct struct\n  trace[Elab.struct] \"{struct}\"\n  \n  let { val := r, struct, instMVars } \u2190 withSynthesize (mayPostpone := true) <| elabStruct struct expectedType?\n  trace[Elab.struct] \"before propagate {r}\"\n  DefaultFields.propagate struct\n  synthesizeAppInstMVars instMVars r\n  return r", "start": [877, 1], "end": [901, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.StructInst.elabStructInst", "code": "@[builtin_term_elab structInst] def elabStructInst : TermElab := fun stx expectedType? => do\n  match (\u2190 expandNonAtomicExplicitSources stx) with\n  | some stxNew => withMacroExpansion stx stxNew <| elabTerm stxNew expectedType?\n  | none =>\n    let sourceView \u2190 getStructSource stx\n    if let some modifyOp \u2190 isModifyOp? stx then\n      if sourceView.explicit.isEmpty then\n        throwError \"invalid \\{...} notation, explicit source is required when using '[<index>] := <value>'\"\n      elabModifyOp stx modifyOp sourceView.explicit expectedType?\n    else\n      elabStructInstAux stx expectedType? sourceView", "start": [903, 1], "end": [913, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Frontend.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Profile.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Import.lean", "lake-packages/lean4/src/lean/Lean/Server/References.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Lean.Elab.Frontend.State", "code": "structure State where\n  commandState : Command.State\n  parserState  : Parser.ModuleParserState\n  cmdPos       : String.Pos\n  commands     : Array Syntax := #[]", "start": [13, 1], "end": [17, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.Context", "code": "structure Context where\n  inputCtx : Parser.InputContext", "start": [19, 1], "end": [20, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.FrontendM", "code": "abbrev FrontendM := ReaderT Context $ StateRefT State IO", "start": [22, 1], "end": [22, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.setCommandState", "code": "def setCommandState (commandState : Command.State) : FrontendM Unit :=\n  modify fun s => { s with commandState := commandState }", "start": [24, 1], "end": [25, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.runCommandElabM", "code": "@[inline] def runCommandElabM (x : Command.CommandElabM \u03b1) : FrontendM \u03b1 := do\n  let ctx \u2190 read\n  let s \u2190 get\n  let cmdCtx : Command.Context := {\n    cmdPos       := s.cmdPos\n    fileName     := ctx.inputCtx.fileName\n    fileMap      := ctx.inputCtx.fileMap\n    tacticCache? := none\n  }\n  match (\u2190 liftM <| EIO.toIO' <| (x cmdCtx).run s.commandState) with\n  | Except.error e      => throw <| IO.Error.userError s!\"unexpected internal error: {\u2190 e.toMessageData.toString}\"\n  | Except.ok (a, sNew) => setCommandState sNew; return a", "start": [27, 1], "end": [38, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.elabCommandAtFrontend", "code": "def elabCommandAtFrontend (stx : Syntax) : FrontendM Unit := do\n  runCommandElabM do\n    Command.elabCommandTopLevel stx", "start": [40, 1], "end": [42, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.updateCmdPos", "code": "def updateCmdPos : FrontendM Unit := do\n  modify fun s => { s with cmdPos := s.parserState.pos }", "start": [44, 1], "end": [45, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.getParserState", "code": "def getParserState : FrontendM Parser.ModuleParserState := do pure (\u2190 get).parserState", "start": [47, 1], "end": [47, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.getCommandState", "code": "def getCommandState : FrontendM Command.State := do pure (\u2190 get).commandState", "start": [48, 1], "end": [48, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.setParserState", "code": "def setParserState (ps : Parser.ModuleParserState) : FrontendM Unit := modify fun s => { s with parserState := ps }", "start": [49, 1], "end": [49, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.setMessages", "code": "def setMessages (msgs : MessageLog) : FrontendM Unit := modify fun s => { s with commandState := { s.commandState with messages := msgs } }", "start": [50, 1], "end": [50, 140], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.getInputContext", "code": "def getInputContext : FrontendM Parser.InputContext := do pure (\u2190 read).inputCtx", "start": [51, 1], "end": [51, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.processCommand", "code": "def processCommand : FrontendM Bool := do\n  updateCmdPos\n  let cmdState \u2190 getCommandState\n  let ictx \u2190 getInputContext\n  let pstate \u2190 getParserState\n  let scope := cmdState.scopes.head!\n  let pmctx := { env := cmdState.env, options := scope.opts, currNamespace := scope.currNamespace, openDecls := scope.openDecls }\n  match profileit \"parsing\" scope.opts fun _ => Parser.parseCommand ictx pmctx pstate cmdState.messages with\n  | (cmd, ps, messages) =>\n    modify fun s => { s with commands := s.commands.push cmd }\n    setParserState ps\n    setMessages messages\n    elabCommandAtFrontend cmd\n    pure (Parser.isTerminalCommand cmd)", "start": [53, 1], "end": [66, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Frontend.processCommands", "code": "partial def processCommands : FrontendM Unit := do\n  let done \u2190 processCommand\n  unless done do\n    processCommands", "start": [68, 1], "end": [71, 20], "kind": "commanddeclaration"}, {"full_name": "IO.processCommands", "code": "def IO.processCommands (inputCtx : Parser.InputContext) (parserState : Parser.ModuleParserState) (commandState : Command.State) : IO State := do\n  let (_, s) \u2190 (Frontend.processCommands.run { inputCtx := inputCtx }).run { commandState := commandState, parserState := parserState, cmdPos := parserState.pos }\n  pure s", "start": [77, 1], "end": [79, 9], "kind": "commanddeclaration"}, {"full_name": "process", "code": "def process (input : String) (env : Environment) (opts : Options) (fileName : Option String := none) : IO (Environment \u00d7 MessageLog) := do\n  let fileName   := fileName.getD \"<input>\"\n  let inputCtx   := Parser.mkInputContext input fileName\n  let s \u2190 IO.processCommands inputCtx { : Parser.ModuleParserState } (Command.mkState env {} opts)\n  pure (s.commandState.env, s.commandState.messages)", "start": [81, 1], "end": [85, 53], "kind": "commanddeclaration"}, {"full_name": "getPrintMessageEndPos", "code": "def getPrintMessageEndPos (opts : Options) : Bool :=\n  opts.getBool `printMessageEndPos false", "start": [91, 1], "end": [92, 41], "kind": "commanddeclaration"}, {"full_name": "runFrontend", "code": "@[export lean_run_frontend]\ndef runFrontend\n    (input : String)\n    (opts : Options)\n    (fileName : String)\n    (mainModuleName : Name)\n    (trustLevel : UInt32 := 0)\n    (ileanFileName? : Option String := none)\n    : IO (Environment \u00d7 Bool) := do\n  let inputCtx := Parser.mkInputContext input fileName\n  let (header, parserState, messages) \u2190 Parser.parseHeader inputCtx\n  let (env, messages) \u2190 processHeader header opts messages inputCtx trustLevel\n  let env := env.setMainModule mainModuleName\n  let mut commandState := Command.mkState env messages opts\n\n  if ileanFileName?.isSome then\n    commandState := { commandState with infoState.enabled := true }\n\n  let s \u2190 IO.processCommands inputCtx parserState commandState\n  for msg in s.commandState.messages.toList do\n    IO.print (\u2190 msg.toString (includeEndPos := getPrintMessageEndPos opts))\n\n  if let some ileanFileName := ileanFileName? then\n    let trees := s.commandState.infoState.trees.toArray\n    let references := Lean.Server.findModuleRefs inputCtx.fileMap trees (localVars := false)\n    let ilean := { module := mainModuleName, references : Lean.Server.Ilean }\n    IO.FS.writeFile ileanFileName $ Json.compress $ toJson ilean\n\n  pure (s.commandState.env, !s.commandState.messages.hasErrors)", "start": [94, 1], "end": [123, 64], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/HashSet.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashSet.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.HashSet.anyM", "code": "@[specialize]\ndef anyM [Monad m] (s : HashSet \u03b1) (f : \u03b1 \u2192 m Bool) : m Bool := do\n  for a in s do\n    if \u2190 f a then\n      return true\n  return false", "start": [13, 1], "end": [21, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.any", "code": "@[inline]\ndef any (s : HashSet \u03b1) (f : \u03b1 \u2192 Bool) : Bool :=\n  Id.run <| s.anyM f", "start": [23, 1], "end": [28, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.allM", "code": "@[specialize]\ndef allM [Monad m] (s : HashSet \u03b1) (f : \u03b1 \u2192 m Bool) : m Bool := do\n  for a in s do\n    if !(\u2190 f a) then\n      return false\n  return true", "start": [30, 1], "end": [38, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.all", "code": "@[inline]\ndef all (s : HashSet \u03b1) (f : \u03b1 \u2192 Bool) : Bool :=\n  Id.run <| s.allM f", "start": [40, 1], "end": [45, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.insert'", "code": "@[inline]\ndef insert' (s : HashSet \u03b1) (a : \u03b1) : HashSet \u03b1 \u00d7 Bool :=\n  let oldSize := s.size\n  let s := s.insert a\n  (s, s.size == oldSize)", "start": [50, 1], "end": [58, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.ofArray", "code": "@[inline]\nprotected def ofArray [BEq \u03b1] [Hashable \u03b1] (as : Array \u03b1) : HashSet \u03b1 :=\n  HashSet.empty.insertMany as", "start": [60, 1], "end": [65, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.ofList", "code": "@[inline]\nprotected def ofList [BEq \u03b1] [Hashable \u03b1] (as : List \u03b1) : HashSet \u03b1 :=\n  HashSet.empty.insertMany as", "start": [67, 1], "end": [72, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.merge", "code": "@[inline]\ndef merge {\u03b1 : Type u} [BEq \u03b1] [Hashable \u03b1] (s t : HashSet \u03b1) : HashSet \u03b1 :=\n  t.fold (init := s) fun s a => s.insert a", "start": [74, 1], "end": [79, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Meta/Clear.lean", "imports": ["lake-packages/std/Std/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.tryClearMany'", "code": "def Lean.MVarId.tryClearMany' (goal : MVarId) (hyps : Array FVarId) :\n    MetaM (MVarId \u00d7 Array FVarId) :=\n  goal.withContext do\n    let hyps \u2190 sortFVarsByContextOrder hyps\n    hyps.foldrM (init := (goal, Array.mkEmpty hyps.size))\n      \u03bb h (goal, cleared) => do\n        let goal' \u2190 goal.tryClear h\n        let cleared := if goal == goal' then cleared else cleared.push h\n        return (goal', cleared)", "start": [11, 1], "end": [25, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Util/Tactic.lean", "imports": ["lake-packages/aesop/Aesop/Util/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.UnfoldResult", "code": "inductive UnfoldResult\n  | unchanged\n  | changed (goal : MVarId) (usedDecls : HashSet Name)", "start": [26, 1], "end": [28, 55], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnfoldResult.newGoal?", "code": "def newGoal? : UnfoldResult \u2192 Option MVarId\n  | unchanged => none\n  | changed goal _ => some goal", "start": [32, 1], "end": [34, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnfoldResult.usedDecls?", "code": "def usedDecls? : UnfoldResult \u2192 Option (HashSet Name)\n  | unchanged => none\n  | changed _ usedDecls => some usedDecls", "start": [36, 1], "end": [38, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnfoldResult.usedDecls", "code": "def usedDecls (r : UnfoldResult) : HashSet Name :=\n  r.usedDecls?.getD {}", "start": [40, 1], "end": [41, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkUnfoldSimpContext", "code": "def mkUnfoldSimpContext : MetaM Simp.Context := do\n  return {\n    simpTheorems := #[]\n    congrTheorems := \u2190 getSimpCongrTheorems\n    config := Simp.neutralConfig\n    dischargeDepth := 0\n  }", "start": [46, 1], "end": [52, 4], "kind": "commanddeclaration"}, {"full_name": "Aesop.unfoldManyStar", "code": "def unfoldManyStar (goal : MVarId)\n    (unfold? : Name \u2192 Option (Option Name)) : MetaM UnfoldResult :=\n  goal.withContext do\n    let initialGoal := goal\n    let mut goal := goal\n    let usedDecls \u2190 IO.mkRef {}\n    let ctx \u2190 mkUnfoldSimpContext\n\n    let target \u2190 instantiateMVars (\u2190 goal.getType)\n    let r \u2190 unfold usedDecls ctx target\n    if (\u2190 instantiateMVars r.expr) != target then\n      goal \u2190 applySimpResultToTarget goal target r\n\n    for ldecl in (\u2190 goal.getDecl).lctx do\n      let r \u2190 unfold usedDecls ctx (\u2190 instantiateMVars ldecl.type)\n      if (\u2190 instantiateMVars r.expr) != ldecl.type then\n        let some (_, goal') \u2190\n          applySimpResultToLocalDecl goal ldecl.fvarId r (mayCloseGoal := false)\n          | throwTacticEx `unfoldManyStar goal \"internal error: unexpected result of applySimpResultToLocalDecl\"\n        goal := goal'\n\n    if goal == initialGoal then\n      return .unchanged\n    else\n      return .changed goal (\u2190 usedDecls.get)\n  where\n    @[inline]\n    unfold (usedDecls : IO.Ref (HashSet Name)) (ctx : Simp.Context) (e : Expr) :\n        MetaM Simp.Result :=\n      (\u00b7.fst) <$> Simp.main e ctx (methods := { pre := pre usedDecls })\n\n    pre (usedDecls : IO.Ref (HashSet Name)) (e : Expr) : SimpM Simp.Step := do\n      let some decl := e.getAppFn'.constName?\n        | return .visit { expr := e }\n      match unfold? decl with\n      | none =>\n        return .visit { expr := e }\n      | some none =>\n        if let some e' \u2190 delta? e (\u03bb n => n == decl) then\n          usedDecls.modify (\u00b7.insert decl)\n          return .done { expr := e' }\n        else\n          return .visit { expr := e }\n      | some (some unfoldThm) =>\n        let result? \u2190 withReducible <|\n          Simp.tryTheorem? e\n            { origin := .decl unfoldThm\n              proof := mkConst unfoldThm\n              rfl := \u2190 isRflTheorem unfoldThm }\n            (fun _ => return none)\n        match result? with\n        | none   => return .visit { expr := e }\n        | some r =>\n          usedDecls.modify (\u00b7.insert decl)\n          match (\u2190 reduceMatcher? r.expr) with\n          | .reduced e' => return .done { r with expr := e' }\n          | _ => return .done r", "start": [56, 1], "end": [123, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Meta/Inaccessible.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LocalContext.inaccessibleFVars", "code": "def Lean.LocalContext.inaccessibleFVars (lctx : LocalContext) :\n    Array LocalDecl :=\n  let (result, _) :=\n    lctx.foldr (\u03b2 := Array LocalDecl \u00d7 HashSet Name)\n      (init := (Array.mkEmpty lctx.numIndices, {}))\n      \u03bb ldecl (result, seen) =>\n        if ldecl.isImplementationDetail then\n          (result, seen)\n        else\n          let result :=\n            if ldecl.userName.hasMacroScopes || seen.contains ldecl.userName then\n              result.push ldecl\n            else\n              result\n          (result, seen.insert ldecl.userName)\n  result.reverse", "start": [5, 1], "end": [25, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getInaccessibleFVars", "code": "def Lean.Meta.getInaccessibleFVars [Monad m] [MonadLCtx m] :\n    m (Array LocalDecl) :=\n  return (\u2190 getLCtx).inaccessibleFVars", "start": [27, 1], "end": [34, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.renameInaccessibleFVars", "code": "def Lean.MVarId.renameInaccessibleFVars (mvarId : MVarId) :\n    MetaM (MVarId \u00d7 Array FVarId) := do\n  let mdecl \u2190 mvarId.getDecl\n  let mut lctx := mdecl.lctx\n  let inaccessibleFVars := lctx.inaccessibleFVars\n  if inaccessibleFVars.isEmpty then\n    return (mvarId, #[])\n  let mut renamedFVars := Array.mkEmpty lctx.decls.size\n  for ldecl in inaccessibleFVars do\n    let newName := lctx.getUnusedName ldecl.userName\n    lctx := lctx.setUserName ldecl.fvarId newName\n    renamedFVars := renamedFVars.push ldecl.fvarId\n  let newMVar \u2190 mkFreshExprMVarAt lctx mdecl.localInstances mdecl.type\n  mvarId.assign newMVar\n  return (newMVar.mvarId!, renamedFVars)", "start": [36, 1], "end": [56, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Util/EqualUpToIds.lean", "imports": ["lake-packages/std/Std/Lean/Meta/SavedState.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.EqualUpToIds.EqualUpToIdsM.Context", "code": "structure Context where\n  commonMCtx : MetavarContext\n  mctx\u2081 : MetavarContext\n  mctx\u2082 : MetavarContext", "start": [19, 1], "end": [22, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.EqualUpToIdsM.State", "code": "structure State where\n  equalMVarIds : HashMap MVarId MVarId := {}\n  equalLMVarIds : HashMap LMVarId LMVarId := {}", "start": [24, 1], "end": [26, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.EqualUpToIdsM", "code": "abbrev EqualUpToIdsM :=\n  ReaderT EqualUpToIdsM.Context $ StateRefT EqualUpToIdsM.State MetaM", "start": [31, 1], "end": [32, 70], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.readCommonMCtx", "code": "def readCommonMCtx : EqualUpToIdsM MetavarContext :=\n  return (\u2190 read).commonMCtx", "start": [34, 1], "end": [35, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.readMCtx\u2081", "code": "def readMCtx\u2081 : EqualUpToIdsM MetavarContext :=\n  return (\u2190 read).mctx\u2081", "start": [37, 1], "end": [38, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.readMCtx\u2082", "code": "def readMCtx\u2082 : EqualUpToIdsM MetavarContext :=\n  return (\u2190 read).mctx\u2082", "start": [40, 1], "end": [41, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.EqualUpToIdsM.run", "code": "protected def EqualUpToIdsM.run (x : EqualUpToIdsM \u03b1)\n    (commonMCtx mctx\u2081 mctx\u2082 : MetavarContext) :\n    MetaM \u03b1 :=\n  (\u00b7.fst) <$> (x { commonMCtx, mctx\u2081, mctx\u2082 }).run {}", "start": [49, 1], "end": [52, 54], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.GoalContext", "code": "structure GoalContext where\n  mdecl\u2081 : MetavarDecl\n  mdecl\u2082 : MetavarDecl\n  equalFVarIds : HashMap FVarId FVarId := {}", "start": [54, 1], "end": [57, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.MVarValue", "code": "inductive MVarValue where\n  | mvarId (mvarId : MVarId)\n  | expr (e : Expr)\n  | delayedAssignment (da : DelayedMetavarAssignment)", "start": [59, 1], "end": [62, 54], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.Unsafe.levelsEqualUpToIdsCore", "code": "unsafe def levelsEqualUpToIdsCore (l\u2081 l\u2082 : Level) : EqualUpToIdsM Bool :=\n    if ptrEq l\u2081 l\u2082 then\n      return true\n    else\n      levelsEqualUpToIdsCore' l\u2081 l\u2082", "start": [67, 3], "end": [71, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.Unsafe.levelsEqualUpToIdsCore'", "code": "unsafe def levelsEqualUpToIdsCore' : Level \u2192 Level \u2192 EqualUpToIdsM Bool\n    | .zero, .zero => return true\n    | .succ l\u2081, .succ l\u2082 => levelsEqualUpToIdsCore l\u2081 l\u2082\n    | .max l\u2081 m\u2081, .max l\u2082 m\u2082 =>\n      levelsEqualUpToIdsCore l\u2081 l\u2082 <&&> levelsEqualUpToIdsCore m\u2081 m\u2082\n    | .imax l\u2081 m\u2081, .imax l\u2082 m\u2082 =>\n      levelsEqualUpToIdsCore l\u2081 l\u2082 <&&> levelsEqualUpToIdsCore m\u2081 m\u2082\n    | .param n\u2081, .param n\u2082 =>\n      return n\u2081 == n\u2082\n    | .mvar m\u2081, .mvar m\u2082 => do\n      let commonMCtx := (\u2190 read).commonMCtx\n      if commonMCtx.lDepth.contains m\u2081 || commonMCtx.lDepth.contains m\u2082 then\n        return m\u2081 == m\u2082\n      if let some m\u2082' := (\u2190 get).equalLMVarIds.find? m\u2081 then\n        return m\u2082' == m\u2082\n      else\n        modify \u03bb s => { s with equalLMVarIds := s.equalLMVarIds.insert m\u2081 m\u2082 }\n        return true\n    | _, _ => return false", "start": [73, 3], "end": [91, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.levelsEqualUpToIdsCore", "code": "@[implemented_by Unsafe.levelsEqualUpToIdsCore]\nopaque levelsEqualUpToIdsCore (l\u2081 l\u2082 : Level) : EqualUpToIdsM Bool", "start": [96, 1], "end": [97, 67], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.namesEqualUpToMacroScopes", "code": "private def namesEqualUpToMacroScopes (n\u2081 n\u2082 : Name) : Bool :=\n  n\u2081.hasMacroScopes == n\u2082.hasMacroScopes &&\n  n\u2081.eraseMacroScopes == n\u2082.eraseMacroScopes", "start": [99, 1], "end": [101, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.lctxDecls", "code": "private def lctxDecls (lctx : LocalContext) : Array LocalDecl :=\n  lctx.foldl (init := Array.mkEmpty lctx.numIndices) \u03bb decls d =>\n    if d.isImplementationDetail then decls else decls.push d", "start": [103, 1], "end": [105, 61], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.Unsafe.exprsEqualUpToIdsCore", "code": "unsafe def exprsEqualUpToIdsCore (e\u2081 e\u2082 : Expr) :\n      ReaderT GoalContext EqualUpToIdsM Bool := do\n    withTraceNodeBefore `Aesop.Util.EqualUpToIds (return m!\"comparing exprs {\u2190 printExpr (\u2190 readMCtx\u2081) (\u2190 read).mdecl\u2081 e\u2081}, {\u2190 printExpr (\u2190 readMCtx\u2082) (\u2190 read).mdecl\u2082 e\u2082}\") do\n      if ptrEq e\u2081 e\u2082 then\n        return true\n      else\n        exprsEqualUpToIdsCore' (\u2190 instMVars (\u2190 readMCtx\u2081) e\u2081)\n          (\u2190 instMVars (\u2190 readMCtx\u2082) e\u2082)\n  where\n    instMVars (mctx : MetavarContext) (e : Expr) : MetaM Expr :=\n      withMCtx mctx (instantiateMVars e)\n\n    printExpr (mctx : MetavarContext) (mdecl : MetavarDecl) (e : Expr) :\n        MetaM MessageData :=\n      withMCtx mctx do\n        withLCtx mdecl.lctx mdecl.localInstances do\n          addMessageContext m!\"{e}\"", "start": [110, 3], "end": [126, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.Unsafe.exprsEqualUpToIdsCore'", "code": "unsafe def exprsEqualUpToIdsCore' :\n      Expr \u2192 Expr \u2192 ReaderT GoalContext EqualUpToIdsM Bool\n    | .bvar i, .bvar j => return i == j\n    | .fvar fvarId\u2081, .fvar fvarId\u2082 =>\n      return (\u2190 read).equalFVarIds.find? fvarId\u2081 == some fvarId\u2082\n    | .sort u, .sort v => levelsEqualUpToIdsCore u v\n    | .const decl\u2081 lvls\u2081, .const decl\u2082 lvls\u2082 => do\n      if decl\u2081 == decl\u2082 && lvls\u2081.length == lvls\u2082.length then\n        for l\u2081 in lvls\u2081, l\u2082 in lvls\u2082 do\n          if ! (\u2190 levelsEqualUpToIdsCore l\u2081 l\u2082) then\n            return false\n        return true\n      else\n        return false\n    | .app f\u2081 x\u2081, .app f\u2082 x\u2082 =>\n      exprsEqualUpToIdsCore f\u2081 f\u2082 <&&> exprsEqualUpToIdsCore x\u2081 x\u2082\n    | .lam n\u2081 t\u2081 e\u2081 bi\u2081, .lam n\u2082 t\u2082 e\u2082 bi\u2082 =>\n      pure (n\u2081 == n\u2082 && bi\u2081 == bi\u2082) <&&>\n      exprsEqualUpToIdsCore t\u2081 t\u2082 <&&>\n      exprsEqualUpToIdsCore e\u2081 e\u2082\n    | .forallE n\u2081 t\u2081 e\u2081 bi\u2081, .forallE n\u2082 t\u2082 e\u2082 bi\u2082 =>\n      pure (n\u2081 == n\u2082 && bi\u2081 == bi\u2082) <&&>\n      exprsEqualUpToIdsCore t\u2081 t\u2082 <&&>\n      exprsEqualUpToIdsCore e\u2081 e\u2082\n    | .letE n\u2081 t\u2081 v\u2081 e\u2081 _, .letE n\u2082 t\u2082 v\u2082 e\u2082 _ =>\n      pure (n\u2081 == n\u2082) <&&>\n      exprsEqualUpToIdsCore t\u2081 t\u2082 <&&>\n      exprsEqualUpToIdsCore v\u2081 v\u2082 <&&>\n      exprsEqualUpToIdsCore e\u2081 e\u2082\n    | .lit l\u2081, .lit l\u2082 => return l\u2081 == l\u2082\n    | .mdata _ e\u2081, e\u2082 => exprsEqualUpToIdsCore e\u2081 e\u2082\n    | e\u2081, .mdata _ e\u2082 => exprsEqualUpToIdsCore e\u2081 e\u2082\n    | .proj n\u2081 i\u2081 e\u2081, .proj n\u2082 i\u2082 e\u2082 =>\n      pure (n\u2081 == n\u2082 && i\u2081 == i\u2082) <&&> exprsEqualUpToIdsCore e\u2081 e\u2082\n    | .mvar m\u2081, .mvar m\u2082 => do\n      let v\u2081 \u2190 normalizeMVar (\u2190 readMCtx\u2081) m\u2081\n      let v\u2082 \u2190 normalizeMVar (\u2190 readMCtx\u2082) m\u2082\n      compareMVarValues v\u2081 v\u2082\n    | .mvar m\u2081, e\u2082 => do\n      let v\u2081 \u2190 normalizeMVar (\u2190 readMCtx\u2081) m\u2081\n      compareMVarValues v\u2081 (.expr e\u2082)\n    | e\u2081, .mvar m\u2082 => do\n      let v\u2082 \u2190 normalizeMVar (\u2190 readMCtx\u2082) m\u2082\n      compareMVarValues (.expr e\u2081) v\u2082\n    | _, _ => return false\n  where\n    normalizeMVar (mctx : MetavarContext) (m : MVarId) : MetaM MVarValue :=\n      withMCtx mctx do\n        if let some dAss \u2190 getDelayedMVarAssignment? m then\n          return .delayedAssignment dAss\n        else\n          return .mvarId m\n\n    compareMVarValues :\n        (v\u2081 v\u2082 : MVarValue) \u2192 ReaderT GoalContext EqualUpToIdsM Bool\n      | .expr e\u2081, .expr e\u2082 => exprsEqualUpToIdsCore e\u2081 e\u2082\n      | .mvarId m\u2081, .mvarId m\u2082 => unassignedMVarsEqualUpToIdsCore m\u2081 m\u2082\n      | .delayedAssignment dAss\u2081, .delayedAssignment dAss\u2082 =>\n        unassignedMVarsEqualUpToIdsCore dAss\u2081.mvarIdPending dAss\u2082.mvarIdPending\n        | _, _ => return false", "start": [128, 3], "end": [189, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.Unsafe.localDeclsEqualUpToIdsCore", "code": "unsafe def localDeclsEqualUpToIdsCore :\n      LocalDecl \u2192 LocalDecl \u2192 ReaderT GoalContext EqualUpToIdsM Bool\n    | .cdecl _ _ userName\u2081 type\u2081 bi\u2081 kind\u2081,\n      .cdecl _ _ userName\u2082 type\u2082 bi\u2082 kind\u2082 =>\n      pure (namesEqualUpToMacroScopes userName\u2081 userName\u2082 && bi\u2081 == bi\u2082 &&\n            kind\u2081 == kind\u2082) <&&>\n      exprsEqualUpToIdsCore type\u2081 type\u2082\n    | .ldecl _ _ userName\u2081 type\u2081 v\u2081 _ kind\u2081,\n      .ldecl _ _ userName\u2082 type\u2082 v\u2082 _ kind\u2082 =>\n      pure (namesEqualUpToMacroScopes userName\u2081 userName\u2082 &&\n            kind\u2081 == kind\u2082) <&&>\n      exprsEqualUpToIdsCore type\u2081 type\u2082 <&&>\n      exprsEqualUpToIdsCore v\u2081 v\u2082\n    | _, _ => return false", "start": [191, 3], "end": [204, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.Unsafe.localContextsEqualUpToIdsCore", "code": "unsafe def localContextsEqualUpToIdsCore (mdecl\u2081 mdecl\u2082 : MetavarDecl) :\n      EqualUpToIdsM (Option GoalContext) := do\n    let decls\u2081 := lctxDecls mdecl\u2081.lctx\n    let decls\u2082 := lctxDecls mdecl\u2082.lctx\n    if h : decls\u2081.size = decls\u2082.size then\n      go decls\u2081 decls\u2082 h 0 { mdecl\u2081, mdecl\u2082 }\n    else\n      trace[Aesop.Util.EqualUpToIds] \"number of hyps differs\"\n      return none\n  where\n    go (decls\u2081 decls\u2082 : Array LocalDecl) (h : decls\u2081.size = decls\u2082.size)\n        (i : Nat) (gctx : GoalContext) : EqualUpToIdsM (Option GoalContext) := do\n      if h' : i < decls\u2081.size then\n        let ldecl\u2081 := decls\u2081[i]\n        let ldecl\u2082 := decls\u2082[i]'(by simp [\u2190 h, h'])\n        withTraceNodeBefore `Aesop.Util.EqualUpToIds (return m!\"comparing hyps {ldecl\u2081.userName}, {ldecl\u2082.userName}\") do\n          if ! (\u2190 localDeclsEqualUpToIdsCore ldecl\u2081 ldecl\u2082 |>.run gctx) then\n            return none\n          else\n            let equalFVarIds :=\n              gctx.equalFVarIds.insert ldecl\u2081.fvarId ldecl\u2082.fvarId\n            go decls\u2081 decls\u2082 h (i + 1) { gctx with equalFVarIds }\n      else\n        return some gctx", "start": [206, 3], "end": [229, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.Unsafe.unassignedMVarsEqualUpToIdsCore", "code": "unsafe def unassignedMVarsEqualUpToIdsCore (mvarId\u2081 mvarId\u2082 : MVarId) :\n      EqualUpToIdsM Bool :=\n    withTraceNodeBefore `Aesop.Util.EqualUpToIds (return m!\"comparing mvars {mvarId\u2081.name}, {mvarId\u2082.name}\") do\n      let commonMCtx \u2190 readCommonMCtx\n      if commonMCtx.decls.contains mvarId\u2081 || commonMCtx.decls.contains mvarId\u2082 then\n        if mvarId\u2081 == mvarId\u2082 then\n          trace[Aesop.Util.EqualUpToIds] \"common mvars are identical\"\n          return true\n        else\n          trace[Aesop.Util.EqualUpToIds] \"common mvars are different\"\n          return false\n      else if let some m\u2082 := (\u2190 get).equalMVarIds.find? mvarId\u2081 then\n        if mvarId\u2082 == m\u2082 then\n          trace[Aesop.Util.EqualUpToIds] \"mvars already known to be equal\"\n          return true\n        else\n          trace[Aesop.Util.EqualUpToIds] \"mvar {mvarId\u2081.name} known to be equal to different mvar {m\u2082.name}\"\n          return false\n      else\n        let ctx \u2190 read\n        let (some mdecl\u2081) := ctx.mctx\u2081.decls.find? mvarId\u2081 | throwError\n          \"unknown metavariable '?{mvarId\u2081.name}'\"\n        let (some mdecl\u2082) := ctx.mctx\u2082.decls.find? mvarId\u2082 | throwError\n          \"unknown metavariable '?{mvarId\u2082.name}'\"\n          if let some gctx \u2190 localContextsEqualUpToIdsCore mdecl\u2081 mdecl\u2082 then\n          withTraceNodeBefore `Aesop.Util.EqualUpToIds (return m!\"comparing targets\") do\n            if \u2190 exprsEqualUpToIdsCore mdecl\u2081.type mdecl\u2082.type |>.run gctx then\n              modify \u03bb s =>\n                { s with equalMVarIds := s.equalMVarIds.insert mvarId\u2081 mvarId\u2082 }\n              return true\n            else\n              return false\n        else\n          return false", "start": [231, 3], "end": [264, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.unassignedMVarsEqualUpToIdsCore", "code": "@[implemented_by Unsafe.unassignedMVarsEqualUpToIdsCore]\nopaque unassignedMVarsEqualUpToIdsCore (mvarId\u2081 mvarId\u2082 : MVarId) :\n    EqualUpToIdsM Bool", "start": [269, 1], "end": [271, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.EqualUpToIds.tacticStatesEqualUpToIdsCore", "code": "def tacticStatesEqualUpToIdsCore (goals\u2081 goals\u2082 : Array MVarId) :\n    EqualUpToIdsM Bool := do\n  if goals\u2081.size != goals\u2082.size then\n    return false\n  for g\u2081 in goals\u2081, g\u2082 in goals\u2082 do\n    if ! (\u2190 unassignedMVarsEqualUpToIdsCore g\u2081 g\u2082) then\n      return false\n  return true", "start": [273, 1], "end": [280, 14], "kind": "commanddeclaration"}, {"full_name": "unassignedMVarsEqualUptoIds", "code": "def unassignedMVarsEqualUptoIds (commonMCtx mctx\u2081 mctx\u2082 : MetavarContext)\n    (mvarId\u2081 mvarId\u2082 : MVarId) : MetaM Bool := do\n  EqualUpToIds.unassignedMVarsEqualUpToIdsCore mvarId\u2081 mvarId\u2082\n    |>.run commonMCtx mctx\u2081 mctx\u2082", "start": [284, 1], "end": [287, 34], "kind": "commanddeclaration"}, {"full_name": "tacticStatesEqualUpToIds", "code": "def tacticStatesEqualUpToIds (commonMCtx mctx\u2081 mctx\u2082 : MetavarContext)\n    (goals\u2081 goals\u2082 : Array MVarId) : MetaM Bool := do\n  EqualUpToIds.tacticStatesEqualUpToIdsCore goals\u2081 goals\u2082\n    |>.run commonMCtx mctx\u2081 mctx\u2082", "start": [289, 1], "end": [292, 34], "kind": "commanddeclaration"}, {"full_name": "runTacticMCapturingPostState", "code": "def runTacticMCapturingPostState (t : TacticM Unit) (preState : Meta.SavedState)\n    (preGoals : List MVarId) : MetaM (Meta.SavedState \u00d7 List MVarId) :=\n  withoutModifyingState do\n    let go : TacticM (Meta.SavedState \u00d7 List MVarId) := do\n      preState.restore\n      t\n      pruneSolvedGoals\n      let postState \u2190 show MetaM _ from saveState\n      let postGoals \u2190 getGoals\n      pure (postState, postGoals)\n    go |>.run { elaborator := .anonymous, recover := false }\n       |>.run' { goals := preGoals }\n       |>.run'", "start": [295, 1], "end": [307, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Options/Internal.lean", "imports": ["lake-packages/aesop/Aesop/Check.lean", "lake-packages/aesop/Aesop/Options/Public.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Options'", "code": "structure Options' extends Options where\n  generateScript : Bool\n  deriving Inhabited", "start": [15, 1], "end": [17, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Options.toOptions'", "code": "def Options.toOptions' [Monad m] [MonadOptions m] (opts : Options) :\n    m Options' := do\n  let generateScript \u2190\n    pure opts.traceScript <||>\n    Check.script.isEnabled <||>\n    Check.scriptSteps.isEnabled\n  return { opts with generateScript }", "start": [19, 1], "end": [25, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Char.lean", "imports": ["lake-packages/std/Std/Tactic/RCases.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "String.csize_eq", "code": "private theorem csize_eq (c) :\n    csize c = 1 \u2228 csize c = 2 \u2228 csize c = 3 \u2228\n    csize c = 4", "start": [11, 1], "end": [15, 42], "kind": "commanddeclaration"}, {"full_name": "String.csize_pos", "code": "theorem csize_pos (c) : 0 < csize c", "start": [17, 1], "end": [18, 46], "kind": "commanddeclaration"}, {"full_name": "String.csize_le_4", "code": "theorem csize_le_4 (c) : csize c \u2264 4", "start": [20, 1], "end": [21, 46], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Array/Match.lean", "imports": ["lake-packages/std/Std/Data/Array/Lemmas.lean", "lake-packages/std/Std/Data/Array/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Array.PrefixTable", "code": "structure PrefixTable (\u03b1 : Type _) extends Array (\u03b1 \u00d7 Nat) where\n  \n  valid : (h : i < toArray.size) \u2192 toArray[i].2 \u2264 i", "start": [11, 1], "end": [18, 52], "kind": "commanddeclaration"}, {"full_name": "Array.PrefixTable.size", "code": "abbrev PrefixTable.size (t : PrefixTable \u03b1) := t.toArray.size", "start": [23, 1], "end": [24, 62], "kind": "commanddeclaration"}, {"full_name": "Array.PrefixTable.step", "code": "def PrefixTable.step [BEq \u03b1] (t : PrefixTable \u03b1) (x : \u03b1) : Fin (t.size+1) \u2192 Fin (t.size+1)\n  | \u27e8k, hk\u27e9 =>\n    let cont := fun () =>\n      match k with\n      | 0 => \u27e80, Nat.zero_lt_succ _\u27e9\n      | k + 1 =>\n        have h2 : k < t.size := Nat.lt_of_succ_lt_succ hk\n        let k' := t.toArray[k].2\n        have hk' : k' < k + 1 := Nat.lt_succ_of_le (t.valid h2)\n        step t x \u27e8k', Nat.lt_trans hk' hk\u27e9\n    if hsz : k < t.size then\n      if x == t.toArray[k].1 then\n        \u27e8k+1, Nat.succ_lt_succ hsz\u27e9\n      else cont ()\n    else cont ()\ntermination_by _ k => k.val", "start": [26, 1], "end": [48, 28], "kind": "commanddeclaration"}, {"full_name": "Array.PrefixTable.extend", "code": "def PrefixTable.extend [BEq \u03b1] (t : PrefixTable \u03b1) (x : \u03b1) : PrefixTable \u03b1 where\n  toArray := t.toArray.push (x, t.step x \u27e8t.size, Nat.lt_succ_self _\u27e9)\n  valid _ := by\n    rw [Array.get_push]\n    split\n    \u00b7 exact t.valid ..\n    \u00b7 next h => exact Nat.le_trans (Nat.lt_succ.1 <| Fin.isLt ..) (Nat.not_lt.1 h)", "start": [50, 1], "end": [60, 83], "kind": "commanddeclaration"}, {"full_name": "Array.mkPrefixTable", "code": "def mkPrefixTable [BEq \u03b1] (xs : Array \u03b1) : PrefixTable \u03b1 := xs.foldl (\u00b7.extend) default", "start": [62, 1], "end": [63, 88], "kind": "commanddeclaration"}, {"full_name": "Array.mkPrefixTableOfStream", "code": "partial def mkPrefixTableOfStream [BEq \u03b1] [Stream \u03c3 \u03b1] (stream : \u03c3) : PrefixTable \u03b1 :=\n  loop default stream\nwhere\n  \n  loop (t : PrefixTable \u03b1) (stream : \u03c3) :=\n    match Stream.next? stream with\n    | none => t\n    | some (x, stream) => loop (t.extend x) stream", "start": [65, 1], "end": [73, 51], "kind": "commanddeclaration"}, {"full_name": "Array.Matcher", "code": "structure Matcher (\u03b1) where\n  \n  table : PrefixTable \u03b1\n  \n  state : Fin (table.size + 1) := 0", "start": [75, 1], "end": [80, 36], "kind": "commanddeclaration"}, {"full_name": "Array.Matcher.ofArray", "code": "def Matcher.ofArray [BEq \u03b1] (pat : Array \u03b1) : Matcher \u03b1 where\n  table := mkPrefixTable pat", "start": [82, 1], "end": [84, 29], "kind": "commanddeclaration"}, {"full_name": "Array.Matcher.ofStream", "code": "def Matcher.ofStream [BEq \u03b1] [Stream \u03c3 \u03b1] (pat : \u03c3) : Matcher \u03b1 where\n  table := mkPrefixTableOfStream pat", "start": [86, 1], "end": [88, 37], "kind": "commanddeclaration"}, {"full_name": "Array.Matcher.next?", "code": "partial def Matcher.next? [BEq \u03b1] [Stream \u03c3 \u03b1] (m : Matcher \u03b1) (stream : \u03c3) :\n    Option (\u03c3 \u00d7 Matcher \u03b1) :=\n  match Stream.next? stream with\n  | none => none\n  | some (x, stream) =>\n    let state := m.table.step x m.state\n    if state = m.table.size then\n      some (stream, { m with state })\n    else\n      next? { m with state } stream", "start": [90, 1], "end": [104, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/CodeAction/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/BuiltinNotation.lean", "lake-packages/std/Std/Lean/Name.lean", "lake-packages/std/Std/Lean/InfoTree.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/CodeAction/Attr.lean", "lake-packages/lean4/src/lean/Lean/Elab/BuiltinTerm.lean"], "premises": [{"full_name": "Std.CodeAction.holeCodeActionProvider", "code": "@[code_action_provider] def holeCodeActionProvider : CodeActionProvider := fun params snap => do\n  let doc \u2190 readDoc\n  let startPos := doc.meta.text.lspPosToUtf8Pos params.range.start\n  let endPos := doc.meta.text.lspPosToUtf8Pos params.range.end\n  have holes := snap.infoTree.foldInfo (init := #[]) fun ctx info result => Id.run do\n    let .ofTermInfo info := info | result\n    unless [``elabHole, ``elabSyntheticHole, ``elabSorry].contains info.elaborator do\n      return result\n    let (some head, some tail) := (info.stx.getPos? true, info.stx.getTailPos? true) | result\n    unless head \u2264 endPos && startPos \u2264 tail do return result\n    result.push (ctx, info)\n  let #[(ctx, info)] := holes | return #[]\n  (holeCodeActionExt.getState snap.env).2.concatMapM (\u00b7 params snap ctx info)", "start": [25, 1], "end": [41, 78], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.FindTacticResult", "code": "inductive FindTacticResult\n  \n  | tactic : Syntax.Stack \u2192 FindTacticResult\n  \n  | tacticSeq : (preferred : Bool) \u2192 (insertIdx : Nat) \u2192 Syntax.Stack \u2192 FindTacticResult", "start": [43, 1], "end": [53, 89], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.findTactic?", "code": "partial def findTactic? (preferred : String.Pos \u2192 Bool) (range : String.Range)\n    (root : Syntax) : Option FindTacticResult := do _ \u2190 visit root; \u2190 go [] root\nwhere\n  \n  visit (stx : Syntax) (prev? : Option String.Pos := none) : Option Bool := do\n    let left \u2190 stx.getPos? true\n    guard <| prev?.getD left \u2264 range.start\n    let .original (endPos := right) (trailing := trailing) .. := stx.getTailInfo | none\n    guard <| right.byteIdx + trailing.bsize \u2265 range.stop.byteIdx\n    return left \u2264 range.start && right \u2265 range.stop\n\n  \n  merge : (r\u2081 : Option FindTacticResult) \u2192 (r\u2082 : FindTacticResult) \u2192 FindTacticResult\n  | some r\u2081@(.tacticSeq (preferred := true) ..), .tacticSeq (preferred := false) .. => r\u2081\n  | _, r\u2082 => r\u2082\n\n  \n  go (stack : Syntax.Stack) (stx : Syntax) (prev? : Option String.Pos := none) :\n      Option (Option FindTacticResult) := do\n    if stx.getKind == ``Parser.Tactic.tacticSeq then\n      let bracket := stx[0].getKind == ``Parser.Tactic.tacticSeqBracketed\n      let argIdx := if bracket then 1 else 0\n      let (stack, stx) := ((stx[0], argIdx) :: (stx, 0) :: stack, stx[0][argIdx])\n      let mainRes := stx[0].getPos?.map fun pos =>\n        let i := Id.run do\n          for i in [0:stx.getNumArgs] do\n            if let some pos' := stx[2*i].getPos? then\n              if range.stop < pos' then\n                return i\n          (stx.getNumArgs + 1) / 2\n        .tacticSeq (bracket || preferred pos) i ((stx, 0) :: stack)\n      let mut childRes := none\n      for i in [0:stx.getNumArgs:2] do\n        if let some inner := visit stx[i] then\n          let stack := (stx, i) :: stack\n          if let some child := (\u2190 go stack stx[i]) <|>\n            (if inner then some (.tactic ((stx[i], 0) :: stack)) else none)\n          then\n            if childRes.isSome then failure\n            childRes := merge mainRes child\n      return childRes <|> mainRes\n    else\n      let mut childRes := none\n      let mut prev? := prev?\n      for i in [0:stx.getNumArgs] do\n        if let some _ := visit stx[i] prev? then\n          if let some child \u2190 go ((stx, i) :: stack) stx[i] prev? then\n            if childRes.isSome then failure\n            childRes := child\n        prev? := stx[i].getTailPos? true <|> prev?\n      return childRes", "start": [55, 1], "end": [139, 22], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.findInfoTree?", "code": "partial def findInfoTree? (kind : SyntaxNodeKind) (tgtRange : String.Range)\n  (ctx? : Option ContextInfo) (t : InfoTree)\n  (f : ContextInfo \u2192 Info \u2192 Bool) (canonicalOnly := false) :\n    Option (ContextInfo \u00d7 InfoTree) :=\n  match t with\n  | .context ctx t => findInfoTree? kind tgtRange ctx t f canonicalOnly\n  | node@(.node i ts) => do\n    if let some ctx := ctx? then\n      if let some range := i.stx.getRange? canonicalOnly then\n        if i.stx.getKind == kind && range == tgtRange && f ctx i then\n          return (ctx, node)\n    for t in ts do\n      if let some res := findInfoTree? kind tgtRange (i.updateContext? ctx?) t f canonicalOnly then\n        return res\n    none\n  | _ => none", "start": [141, 1], "end": [163, 14], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.tacticCodeActionProvider", "code": "@[code_action_provider] def tacticCodeActionProvider : CodeActionProvider := fun params snap => do\n  let doc \u2190 readDoc\n  let startPos := doc.meta.text.lspPosToUtf8Pos params.range.start\n  let endPos := doc.meta.text.lspPosToUtf8Pos params.range.end\n  let pointerCol :=\n    if params.range.start.line == params.range.end.line then\n      max params.range.start.character params.range.end.character\n    else 0\n  let some result := findTactic?\n    (fun pos => (doc.meta.text.utf8PosToLspPos pos).character \u2264 pointerCol)\n    \u27e8startPos, endPos\u27e9 snap.stx | return #[]\n  let tgtTac := match result with\n    | .tactic (tac :: _)\n    | .tacticSeq _ _ (_ :: tac :: _) => tac.1\n    | _ => unreachable!\n  let tgtRange := tgtTac.getRange?.get!\n  have info := findInfoTree? tgtTac.getKind tgtRange none snap.infoTree (canonicalOnly := true)\n    fun _ info => info matches .ofTacticInfo _\n  let some (ctx, node@(.node (.ofTacticInfo info) _)) := info | return #[]\n  let mut out := #[]\n  match result with\n  | .tactic stk@((tac, _) :: _) => do\n    let ctx := { ctx with mctx := info.mctxBefore }\n    let actions := (tacticCodeActionExt.getState snap.env).2\n    if let some arr := actions.onTactic.find? tac.getKind then\n      for act in arr do\n        try out := out ++ (\u2190 act params snap ctx stk node) catch _ => pure ()\n    for act in actions.onAnyTactic do\n      try out := out ++ (\u2190 act params snap ctx stk node) catch _ => pure ()\n  | .tacticSeq _ i stk@((seq, _) :: _) =>\n    let (ctx, goals) \u2190 if 2*i < seq.getNumArgs then\n      let stx := seq[2*i]\n      let some stxRange := stx.getRange? | return #[]\n      let some (ctx, .node (.ofTacticInfo info') _) :=\n          findInfoTree? stx.getKind stxRange ctx node fun _ info => (info matches .ofTacticInfo _)\n        | return #[]\n      pure ({ ctx with mctx := info'.mctxBefore }, info'.goalsBefore)\n    else\n      pure ({ ctx with mctx := info.mctxAfter }, info.goalsAfter)\n    for act in (tacticSeqCodeActionExt.getState snap.env).2 do\n      try out := out ++ (\u2190 act params snap ctx i stk goals) catch _ => pure ()\n  | _ => unreachable!\n  pure out", "start": [165, 1], "end": [208, 11], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.cmdCodeActionProvider", "code": "@[code_action_provider] def cmdCodeActionProvider : CodeActionProvider := fun params snap => do\n  let doc \u2190 readDoc\n  let startPos := doc.meta.text.lspPosToUtf8Pos params.range.start\n  let endPos := doc.meta.text.lspPosToUtf8Pos params.range.end\n  have cmds := snap.infoTree.foldInfo' (init := #[]) fun ctx node result => Id.run do\n    let .node (.ofCommandInfo info) _ := node | result\n    let (some head, some tail) := (info.stx.getPos? true, info.stx.getTailPos? true) | result\n    unless head \u2264 endPos && startPos \u2264 tail do return result\n    result.push (ctx, node)\n  let actions := (cmdCodeActionExt.getState snap.env).2\n  let mut out := #[]\n  for (ctx, node) in cmds do\n    let .node (.ofCommandInfo info) _ := node | unreachable!\n    if let some arr := actions.onCmd.find? info.stx.getKind then\n      for act in arr do\n        try out := out ++ (\u2190 act params snap ctx node) catch _ => pure ()\n    for act in actions.onAnyCmd do\n      try out := out ++ (\u2190 act params snap ctx node) catch _ => pure ()\n  pure out", "start": [210, 1], "end": [231, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Classes/Order.lean", "imports": ["lake-packages/std/Std/Data/Ord.lean", "lake-packages/std/Std/Tactic/Simpa.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordering.swap_swap", "code": "@[simp] theorem Ordering.swap_swap {o : Ordering} : o.swap.swap = o", "start": [11, 1], "end": [11, 90], "kind": "commanddeclaration"}, {"full_name": "Ordering.swap_inj", "code": "@[simp] theorem Ordering.swap_inj {o\u2081 o\u2082 : Ordering} : o\u2081.swap = o\u2082.swap \u2194 o\u2081 = o\u2082", "start": [13, 1], "end": [14, 56], "kind": "commanddeclaration"}, {"full_name": "Std.TotalBLE", "code": "class TotalBLE (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : Prop where\n  \n  total : le a b \u2228 le b a", "start": [18, 1], "end": [21, 26], "kind": "commanddeclaration"}, {"full_name": "Std.OrientedCmp", "code": "class OrientedCmp (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : Prop where\n  \n  symm (x y) : (cmp x y).swap = cmp y x", "start": [23, 1], "end": [27, 40], "kind": "commanddeclaration"}, {"full_name": "Std.OrientedCmp.cmp_eq_gt", "code": "theorem cmp_eq_gt [OrientedCmp cmp] : cmp x y = .gt \u2194 cmp y x = .lt", "start": [31, 1], "end": [32, 45], "kind": "commanddeclaration"}, {"full_name": "Std.OrientedCmp.cmp_eq_eq_symm", "code": "theorem cmp_eq_eq_symm [OrientedCmp cmp] : cmp x y = .eq \u2194 cmp y x = .eq", "start": [34, 1], "end": [35, 45], "kind": "commanddeclaration"}, {"full_name": "Std.OrientedCmp.cmp_refl", "code": "theorem cmp_refl [OrientedCmp cmp] : cmp x x = .eq", "start": [37, 1], "end": [41, 48], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp", "code": "class TransCmp (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) extends OrientedCmp cmp : Prop where\n  \n  le_trans : cmp x y \u2260 .gt \u2192 cmp y z \u2260 .gt \u2192 cmp x z \u2260 .gt", "start": [45, 1], "end": [48, 59], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.ge_trans", "code": "theorem ge_trans (h\u2081 : cmp x y \u2260 .lt) (h\u2082 : cmp y z \u2260 .lt) : cmp x z \u2260 .lt", "start": [54, 1], "end": [56, 42], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.lt_asymm", "code": "theorem lt_asymm (h : cmp x y = .lt) : cmp y x \u2260 .lt", "start": [58, 1], "end": [59, 50], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.gt_asymm", "code": "theorem gt_asymm (h : cmp x y = .gt) : cmp y x \u2260 .gt", "start": [61, 1], "end": [62, 46], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.le_lt_trans", "code": "theorem le_lt_trans (h\u2081 : cmp x y \u2260 .gt) (h\u2082 : cmp y z = .lt) : cmp x z = .lt", "start": [64, 1], "end": [65, 63], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.lt_le_trans", "code": "theorem lt_le_trans (h\u2081 : cmp x y = .lt) (h\u2082 : cmp y z \u2260 .gt) : cmp x z = .lt", "start": [67, 1], "end": [68, 63], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.lt_trans", "code": "theorem lt_trans (h\u2081 : cmp x y = .lt) (h\u2082 : cmp y z = .lt) : cmp x z = .lt", "start": [70, 1], "end": [71, 46], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.gt_trans", "code": "theorem gt_trans (h\u2081 : cmp x y = .gt) (h\u2082 : cmp y z = .gt) : cmp x z = .gt", "start": [73, 1], "end": [74, 50], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.cmp_congr_left", "code": "theorem cmp_congr_left (xy : cmp x y = .eq) : cmp x z = cmp y z", "start": [76, 1], "end": [83, 17], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.cmp_congr_left'", "code": "theorem cmp_congr_left' (xy : cmp x y = .eq) : cmp x = cmp y", "start": [85, 1], "end": [86, 36], "kind": "commanddeclaration"}, {"full_name": "Std.TransCmp.cmp_congr_right", "code": "theorem cmp_congr_right [TransCmp cmp] (yz : cmp y z = .eq) : cmp x y = cmp x z", "start": [88, 1], "end": [89, 58], "kind": "commanddeclaration"}, {"full_name": "Std.byKey", "code": "@[inline] def byKey (f : \u03b1 \u2192 \u03b2) (cmp : \u03b2 \u2192 \u03b2 \u2192 Ordering) (a b : \u03b1) : Ordering := cmp (f a) (f b)", "start": [93, 1], "end": [94, 97], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Int/Lemmas.lean", "imports": ["lake-packages/std/Std/Data/Int/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Tactic/RCases.lean", "lake-packages/std/Std/Classes/Cast.lean", "lake-packages/std/Std/Data/Option/Basic.lean", "lake-packages/std/Std/Tactic/NormCast/Lemmas.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean"], "premises": [{"full_name": "Int.ofNat_eq_coe", "code": "@[simp] theorem ofNat_eq_coe : ofNat n = Nat.cast n", "start": [17, 1], "end": [17, 59], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_zero", "code": "@[simp] theorem ofNat_zero : ((0 : Nat) : Int) = 0", "start": [19, 1], "end": [19, 58], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_one", "code": "@[simp] theorem ofNat_one  : ((1 : Nat) : Int) = 1", "start": [21, 1], "end": [21, 58], "kind": "commanddeclaration"}, {"full_name": "Int.default_eq_zero", "code": "@[simp] theorem default_eq_zero : default = (0 : Int)", "start": [23, 1], "end": [23, 61], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_of_sub_eq_zero", "code": "theorem subNatNat_of_sub_eq_zero {m n : Nat} (h : n - m = 0) : subNatNat m n = \u2191(m - n)", "start": [27, 1], "end": [28, 34], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_of_sub_eq_succ", "code": "theorem subNatNat_of_sub_eq_succ {m n k : Nat} (h : n - m = succ k) : subNatNat m n = -[k+1]", "start": [30, 1], "end": [31, 20], "kind": "commanddeclaration"}, {"full_name": "Int.neg_zero", "code": "@[local simp] protected theorem neg_zero : -(0:Int) = 0", "start": [33, 1], "end": [33, 63], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_add", "code": "theorem ofNat_add (n m : Nat) : (\u2191(n + m) : Int) = n + m", "start": [35, 1], "end": [35, 64], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_mul", "code": "theorem ofNat_mul (n m : Nat) : (\u2191(n * m) : Int) = n * m", "start": [36, 1], "end": [36, 64], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_succ", "code": "theorem ofNat_succ (n : Nat) : (succ n : Int) = n + 1", "start": [37, 1], "end": [37, 61], "kind": "commanddeclaration"}, {"full_name": "Int.neg_ofNat_zero", "code": "@[local simp] theorem neg_ofNat_zero : -((0 : Nat) : Int) = 0", "start": [39, 1], "end": [39, 69], "kind": "commanddeclaration"}, {"full_name": "Int.neg_ofNat_succ", "code": "@[local simp] theorem neg_ofNat_succ (n : Nat) : -(succ n : Int) = -[n+1]", "start": [40, 1], "end": [40, 81], "kind": "commanddeclaration"}, {"full_name": "Int.neg_negSucc", "code": "@[local simp] theorem neg_negSucc (n : Nat) : -(-[n+1]) = succ n", "start": [41, 1], "end": [41, 72], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_coe", "code": "theorem negSucc_coe (n : Nat) : -[n+1] = -\u2191(n + 1)", "start": [43, 1], "end": [43, 58], "kind": "commanddeclaration"}, {"full_name": "Int.negOfNat_eq", "code": "theorem negOfNat_eq : negOfNat n = -ofNat n", "start": [45, 1], "end": [45, 51], "kind": "commanddeclaration"}, {"full_name": "Int.add_def", "code": "@[simp] theorem add_def {a b : Int} : Int.add a b = a + b", "start": [49, 1], "end": [49, 65], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_add_ofNat", "code": "@[local simp] theorem ofNat_add_ofNat (m n : Nat) : (\u2191m + \u2191n : Int) = \u2191(m + n)", "start": [51, 1], "end": [51, 86], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_add_negSucc", "code": "@[local simp] theorem ofNat_add_negSucc (m n : Nat) : \u2191m + -[n+1] = subNatNat m (succ n)", "start": [52, 1], "end": [52, 96], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_add_ofNat", "code": "@[local simp] theorem negSucc_add_ofNat (m n : Nat) : -[m+1] + \u2191n = subNatNat n (succ m)", "start": [53, 1], "end": [53, 96], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_add_negSucc", "code": "@[local simp] theorem negSucc_add_negSucc (m n : Nat) : -[m+1] + -[n+1] = -[succ (m + n) +1]", "start": [54, 1], "end": [54, 100], "kind": "commanddeclaration"}, {"full_name": "Int.mul_def", "code": "@[simp] theorem mul_def {a b : Int} : Int.mul a b = a * b", "start": [56, 1], "end": [56, 65], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_mul_ofNat", "code": "@[local simp] theorem ofNat_mul_ofNat (m n : Nat) : (\u2191m * \u2191n : Int) = \u2191(m * n)", "start": [58, 1], "end": [58, 86], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_mul_negSucc'", "code": "@[local simp] theorem ofNat_mul_negSucc' (m n : Nat) : \u2191m * -[n+1] = negOfNat (m * succ n)", "start": [59, 1], "end": [59, 98], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_mul_ofNat'", "code": "@[local simp] theorem negSucc_mul_ofNat' (m n : Nat) : -[m+1] * \u2191n = negOfNat (succ m * n)", "start": [60, 1], "end": [60, 98], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_mul_negSucc'", "code": "@[local simp] theorem negSucc_mul_negSucc' (m n : Nat) :\n    -[m+1] * -[n+1] = ofNat (succ m * succ n)", "start": [61, 1], "end": [62, 53], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_inj", "code": "theorem ofNat_inj : ((m : Nat) : Int) = (n : Nat) \u2194 m = n", "start": [66, 1], "end": [66, 85], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_eq_zero", "code": "theorem ofNat_eq_zero : ((n : Nat) : Int) = 0 \u2194 n = 0", "start": [68, 1], "end": [68, 67], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_ne_zero", "code": "theorem ofNat_ne_zero : ((n : Nat) : Int) \u2260 0 \u2194 n \u2260 0", "start": [70, 1], "end": [70, 81], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_inj", "code": "theorem negSucc_inj : negSucc m = negSucc n \u2194 m = n", "start": [72, 1], "end": [72, 91], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_eq", "code": "theorem negSucc_eq (n : Nat) : -[n+1] = -((n : Int) + 1)", "start": [74, 1], "end": [74, 64], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_ne_zero", "code": "@[simp] theorem negSucc_ne_zero (n : Nat) : -[n+1] \u2260 0", "start": [76, 1], "end": [76, 63], "kind": "commanddeclaration"}, {"full_name": "Int.zero_ne_negSucc", "code": "@[simp] theorem zero_ne_negSucc (n : Nat) : 0 \u2260 -[n+1]", "start": [78, 1], "end": [78, 63], "kind": "commanddeclaration"}, {"full_name": "Int.neg_neg", "code": "@[simp] protected theorem neg_neg : \u2200 a : Int, -(-a) = a", "start": [82, 1], "end": [85, 18], "kind": "commanddeclaration"}, {"full_name": "Int.neg_inj", "code": "protected theorem neg_inj {a b : Int} : -a = -b \u2194 a = b", "start": [87, 1], "end": [88, 69], "kind": "commanddeclaration"}, {"full_name": "Int.neg_eq_zero", "code": "protected theorem neg_eq_zero : -a = 0 \u2194 a = 0", "start": [90, 1], "end": [90, 71], "kind": "commanddeclaration"}, {"full_name": "Int.neg_ne_zero", "code": "protected theorem neg_ne_zero : -a \u2260 0 \u2194 a \u2260 0", "start": [92, 1], "end": [92, 76], "kind": "commanddeclaration"}, {"full_name": "Int.sub_eq_add_neg", "code": "protected theorem sub_eq_add_neg {a b : Int} : a - b = a + -b", "start": [94, 1], "end": [94, 69], "kind": "commanddeclaration"}, {"full_name": "Int.add_neg_one", "code": "theorem add_neg_one (i : Int) : i + -1 = i - 1", "start": [96, 1], "end": [96, 54], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_elim", "code": "theorem subNatNat_elim (m n : Nat) (motive : Nat \u2192 Nat \u2192 Int \u2192 Prop)\n    (hp : \u2200 i n, motive (n + i) n i)\n    (hn : \u2200 i m, motive m (m + i + 1) -[i+1]) :\n    motive m n (subNatNat m n)", "start": [101, 1], "end": [112, 35], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_add_left", "code": "theorem subNatNat_add_left : subNatNat (m + n) m = n", "start": [114, 1], "end": [116, 90], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_add_right", "code": "theorem subNatNat_add_right : subNatNat m (m + n + 1) = negSucc n", "start": [118, 1], "end": [119, 59], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_add_add", "code": "theorem subNatNat_add_add (m n k : Nat) : subNatNat (m + k) (n + k) = subNatNat m n", "start": [121, 1], "end": [128, 30], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_of_le", "code": "theorem subNatNat_of_le {m n : Nat} (h : n \u2264 m) : subNatNat m n = \u2191(m - n)", "start": [130, 1], "end": [131, 53], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_of_lt", "code": "theorem subNatNat_of_lt {m n : Nat} (h : m < n) : subNatNat m n = -[pred (n - m) +1]", "start": [133, 1], "end": [134, 83], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_ofNat", "code": "@[simp] theorem natAbs_ofNat (n : Nat) : natAbs \u2191n = n", "start": [138, 1], "end": [138, 62], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_negSucc", "code": "@[simp] theorem natAbs_negSucc (n : Nat) : natAbs -[n+1] = n.succ", "start": [139, 1], "end": [139, 73], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_zero", "code": "@[simp] theorem natAbs_zero : natAbs (0 : Int) = (0 : Nat)", "start": [140, 1], "end": [140, 66], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_one", "code": "@[simp] theorem natAbs_one : natAbs (1 : Int) = (1 : Nat)", "start": [141, 1], "end": [141, 65], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_eq_zero", "code": "@[simp] theorem natAbs_eq_zero : natAbs a = 0 \u2194 a = 0", "start": [143, 1], "end": [147, 20], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_ne_zero", "code": "theorem natAbs_ne_zero {a : Int} : a.natAbs \u2260 0 \u2194 a \u2260 0", "start": [149, 1], "end": [149, 88], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_pos", "code": "theorem natAbs_pos : 0 < natAbs a \u2194 a \u2260 0", "start": [151, 1], "end": [151, 93], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_mul_self", "code": "theorem natAbs_mul_self : \u2200 {a : Int}, \u2191(natAbs a * natAbs a) = a * a", "start": [153, 1], "end": [155, 19], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_neg", "code": "@[simp] theorem natAbs_neg : \u2200 (a : Int), natAbs (-a) = natAbs a", "start": [157, 1], "end": [160, 18], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_eq", "code": "theorem natAbs_eq : \u2200 (a : Int), a = natAbs a \u2228 a = -\u2191(natAbs a)", "start": [162, 1], "end": [164, 26], "kind": "commanddeclaration"}, {"full_name": "Int.eq_nat_or_neg", "code": "theorem eq_nat_or_neg (a : Int) : \u2203 n : Nat, a = n \u2228 a = -\u2191n", "start": [166, 1], "end": [166, 81], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_negOfNat", "code": "theorem natAbs_negOfNat (n : Nat) : natAbs (negOfNat n) = n", "start": [168, 1], "end": [169, 18], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_mul", "code": "theorem natAbs_mul (a b : Int) : natAbs (a * b) = natAbs a * natAbs b", "start": [171, 1], "end": [173, 79], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_mul_natAbs_eq", "code": "theorem natAbs_mul_natAbs_eq {a b : Int} {c : Nat}\n    (h : a * b = (c : Int)) : a.natAbs * b.natAbs = c", "start": [175, 1], "end": [176, 89], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_mul_self'", "code": "@[simp] theorem natAbs_mul_self' (a : Int) : (natAbs a * natAbs a : Int) = a * a", "start": [178, 1], "end": [179, 40], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_eq_natAbs_iff", "code": "theorem natAbs_eq_natAbs_iff {a b : Int} : a.natAbs = b.natAbs \u2194 a = b \u2228 a = -b", "start": [181, 1], "end": [188, 35], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_eq_iff", "code": "theorem natAbs_eq_iff {a : Int} {n : Nat} : a.natAbs = n \u2194 a = n \u2228 a = -\u2191n", "start": [190, 1], "end": [191, 52], "kind": "commanddeclaration"}, {"full_name": "Int.sign_zero", "code": "@[simp] theorem sign_zero : sign 0 = 0", "start": [195, 1], "end": [195, 46], "kind": "commanddeclaration"}, {"full_name": "Int.sign_one", "code": "@[simp] theorem sign_one : sign 1 = 1", "start": [196, 1], "end": [196, 45], "kind": "commanddeclaration"}, {"full_name": "Int.sign_neg_one", "code": "theorem sign_neg_one : sign (-1) = -1", "start": [197, 1], "end": [197, 45], "kind": "commanddeclaration"}, {"full_name": "Int.sign_of_succ", "code": "theorem sign_of_succ (n : Nat) : sign (Nat.succ n) = 1", "start": [199, 1], "end": [199, 62], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_sign", "code": "theorem natAbs_sign (z : Int) : z.sign.natAbs = if z = 0 then 0 else 1", "start": [201, 1], "end": [202, 44], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_sign_of_nonzero", "code": "theorem natAbs_sign_of_nonzero {z : Int} (hz : z \u2260 0) : z.sign.natAbs = 1", "start": [204, 1], "end": [205, 34], "kind": "commanddeclaration"}, {"full_name": "Int.sign_ofNat_of_nonzero", "code": "theorem sign_ofNat_of_nonzero {n : Nat} (hn : n \u2260 0) : Int.sign n = 1", "start": [207, 1], "end": [209, 38], "kind": "commanddeclaration"}, {"full_name": "Int.sign_neg", "code": "@[simp] theorem sign_neg (z : Int) : Int.sign (-z) = -Int.sign z", "start": [211, 1], "end": [212, 44], "kind": "commanddeclaration"}, {"full_name": "Int.add_comm", "code": "protected theorem add_comm : \u2200 a b : Int, a + b = b + a", "start": [218, 1], "end": [222, 47], "kind": "commanddeclaration"}, {"full_name": "Int.add_zero", "code": "@[local simp] protected theorem add_zero : \u2200 a : Int, a + 0 = a", "start": [224, 1], "end": [226, 19], "kind": "commanddeclaration"}, {"full_name": "Int.zero_add", "code": "@[local simp] protected theorem zero_add (a : Int) : 0 + a = a", "start": [228, 1], "end": [228, 95], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_add_negSucc_of_lt", "code": "theorem ofNat_add_negSucc_of_lt (h : m < n.succ) : ofNat m + -[n+1] = -[n - m+1]", "start": [230, 1], "end": [231, 72], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_sub", "code": "theorem subNatNat_sub (h : n \u2264 m) (k : Nat) : subNatNat (m - n) k = subNatNat m (k + n)", "start": [233, 1], "end": [234, 54], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_add", "code": "theorem subNatNat_add (m n k : Nat) : subNatNat (m + n) k = m + subNatNat n k", "start": [236, 1], "end": [243, 80], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_add_negSucc", "code": "theorem subNatNat_add_negSucc (m n k : Nat) :\n    subNatNat m n + -[k+1] = subNatNat m (n + succ k)", "start": [245, 1], "end": [260, 61], "kind": "commanddeclaration"}, {"full_name": "Int.add_assoc", "code": "protected theorem add_assoc : \u2200 a b c : Int, a + b + c = a + (b + c)", "start": [262, 1], "end": [282, 44], "kind": "commanddeclaration"}, {"full_name": "Int.add_left_comm", "code": "protected theorem add_left_comm (a b c : Int) : a + (b + c) = b + (a + c)", "start": [284, 1], "end": [285, 54], "kind": "commanddeclaration"}, {"full_name": "Int.add_right_comm", "code": "protected theorem add_right_comm (a b c : Int) : a + b + c = a + c + b", "start": [287, 1], "end": [288, 54], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_self", "code": "theorem subNatNat_self : \u2200 n, subNatNat n n = 0", "start": [292, 1], "end": [294, 91], "kind": "commanddeclaration"}, {"full_name": "Int.add_left_neg", "code": "@[local simp] protected theorem add_left_neg : \u2200 a : Int, -a + a = 0", "start": [298, 1], "end": [301, 22], "kind": "commanddeclaration"}, {"full_name": "Int.add_right_neg", "code": "@[local simp] protected theorem add_right_neg (a : Int) : a + -a = 0", "start": [303, 1], "end": [304, 38], "kind": "commanddeclaration"}, {"full_name": "Int.neg_eq_of_add_eq_zero", "code": "@[simp] protected theorem neg_eq_of_add_eq_zero {a b : Int} (h : a + b = 0) : -a = b", "start": [306, 1], "end": [307, 81], "kind": "commanddeclaration"}, {"full_name": "Int.eq_neg_of_eq_neg", "code": "protected theorem eq_neg_of_eq_neg {a b : Int} (h : a = -b) : b = -a", "start": [309, 1], "end": [310, 22], "kind": "commanddeclaration"}, {"full_name": "Int.eq_neg_comm", "code": "protected theorem eq_neg_comm {a b : Int} : a = -b \u2194 b = -a", "start": [312, 1], "end": [313, 47], "kind": "commanddeclaration"}, {"full_name": "Int.neg_eq_comm", "code": "protected theorem neg_eq_comm {a b : Int} : -a = b \u2194 -b = a", "start": [315, 1], "end": [316, 41], "kind": "commanddeclaration"}, {"full_name": "Int.neg_add_cancel_left", "code": "protected theorem neg_add_cancel_left (a b : Int) : -a + (a + b) = b", "start": [318, 1], "end": [319, 55], "kind": "commanddeclaration"}, {"full_name": "Int.add_neg_cancel_left", "code": "protected theorem add_neg_cancel_left (a b : Int) : a + (-a + b) = b", "start": [321, 1], "end": [322, 56], "kind": "commanddeclaration"}, {"full_name": "Int.add_neg_cancel_right", "code": "protected theorem add_neg_cancel_right (a b : Int) : a + b + -b = a", "start": [324, 1], "end": [325, 54], "kind": "commanddeclaration"}, {"full_name": "Int.neg_add_cancel_right", "code": "protected theorem neg_add_cancel_right (a b : Int) : a + -b + b = a", "start": [327, 1], "end": [328, 53], "kind": "commanddeclaration"}, {"full_name": "Int.add_left_cancel", "code": "protected theorem add_left_cancel {a b c : Int} (h : a + b = a + c) : b = c", "start": [330, 1], "end": [332, 73], "kind": "commanddeclaration"}, {"full_name": "Int.neg_add", "code": "@[local simp] protected theorem neg_add {a b : Int} : -(a + b) = -a + -b", "start": [334, 1], "end": [337, 56], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_sub_one", "code": "@[simp] theorem negSucc_sub_one (n : Nat) : -[n+1] - 1 = -[n + 1 +1]", "start": [341, 1], "end": [341, 76], "kind": "commanddeclaration"}, {"full_name": "Int.sub_self", "code": "protected theorem sub_self (a : Int) : a - a = 0", "start": [343, 1], "end": [344, 45], "kind": "commanddeclaration"}, {"full_name": "Int.sub_zero", "code": "protected theorem sub_zero (a : Int) : a - 0 = a", "start": [346, 1], "end": [346, 81], "kind": "commanddeclaration"}, {"full_name": "Int.zero_sub", "code": "protected theorem zero_sub (a : Int) : 0 - a = -a", "start": [348, 1], "end": [348, 82], "kind": "commanddeclaration"}, {"full_name": "Int.sub_eq_zero_of_eq", "code": "protected theorem sub_eq_zero_of_eq {a b : Int} (h : a = b) : a - b = 0", "start": [350, 1], "end": [351, 23], "kind": "commanddeclaration"}, {"full_name": "Int.eq_of_sub_eq_zero", "code": "protected theorem eq_of_sub_eq_zero {a b : Int} (h : a - b = 0) : a = b", "start": [353, 1], "end": [356, 61], "kind": "commanddeclaration"}, {"full_name": "Int.sub_eq_zero", "code": "protected theorem sub_eq_zero {a b : Int} : a - b = 0 \u2194 a = b", "start": [358, 1], "end": [359, 49], "kind": "commanddeclaration"}, {"full_name": "Int.sub_sub", "code": "protected theorem sub_sub (a b c : Int) : a - b - c = a - (b + c)", "start": [361, 1], "end": [362, 43], "kind": "commanddeclaration"}, {"full_name": "Int.neg_sub", "code": "protected theorem neg_sub (a b : Int) : -(a - b) = b - a", "start": [364, 1], "end": [365, 42], "kind": "commanddeclaration"}, {"full_name": "Int.sub_sub_self", "code": "protected theorem sub_sub_self (a b : Int) : a - (a - b) = b", "start": [367, 1], "end": [368, 45], "kind": "commanddeclaration"}, {"full_name": "Int.sub_neg", "code": "protected theorem sub_neg (a b : Int) : a - -b = a + b", "start": [370, 1], "end": [370, 87], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_mul_negSucc", "code": "@[simp] theorem ofNat_mul_negSucc (m n : Nat) : (m : Int) * -[n+1] = -\u2191(m * succ n)", "start": [374, 1], "end": [374, 91], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_mul_ofNat", "code": "@[simp] theorem negSucc_mul_ofNat (m n : Nat) : -[m+1] * n = -\u2191(succ m * n)", "start": [376, 1], "end": [376, 83], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_mul_negSucc", "code": "@[simp] theorem negSucc_mul_negSucc (m n : Nat) : -[m+1] * -[n+1] = succ m * succ n", "start": [378, 1], "end": [378, 91], "kind": "commanddeclaration"}, {"full_name": "Int.mul_comm", "code": "protected theorem mul_comm (a b : Int) : a * b = b * a", "start": [380, 1], "end": [381, 46], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_mul_negOfNat", "code": "theorem ofNat_mul_negOfNat (m n : Nat) : (m : Nat) * negOfNat n = negOfNat (m * n)", "start": [383, 1], "end": [384, 18], "kind": "commanddeclaration"}, {"full_name": "Int.negOfNat_mul_ofNat", "code": "theorem negOfNat_mul_ofNat (m n : Nat) : negOfNat m * (n : Nat) = negOfNat (m * n)", "start": [386, 1], "end": [387, 61], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_mul_negOfNat", "code": "theorem negSucc_mul_negOfNat (m n : Nat) : -[m+1] * negOfNat n = ofNat (succ m * n)", "start": [389, 1], "end": [390, 18], "kind": "commanddeclaration"}, {"full_name": "Int.negOfNat_mul_negSucc", "code": "theorem negOfNat_mul_negSucc (m n : Nat) : negOfNat n * -[m+1] = ofNat (n * succ m)", "start": [392, 1], "end": [393, 56], "kind": "commanddeclaration"}, {"full_name": "Int.mul_assoc", "code": "protected theorem mul_assoc (a b c : Int) : a * b * c = a * (b * c)", "start": [398, 1], "end": [399, 59], "kind": "commanddeclaration"}, {"full_name": "Int.mul_left_comm", "code": "protected theorem mul_left_comm (a b c : Int) : a * (b * c) = b * (a * c)", "start": [401, 1], "end": [402, 56], "kind": "commanddeclaration"}, {"full_name": "Int.mul_right_comm", "code": "protected theorem mul_right_comm (a b c : Int) : a * b * c = a * c * b", "start": [404, 1], "end": [405, 52], "kind": "commanddeclaration"}, {"full_name": "Int.mul_zero", "code": "@[simp] protected theorem mul_zero (a : Int) : a * 0 = 0", "start": [407, 1], "end": [407, 79], "kind": "commanddeclaration"}, {"full_name": "Int.zero_mul", "code": "@[simp] protected theorem zero_mul (a : Int) : 0 * a = 0", "start": [409, 1], "end": [409, 89], "kind": "commanddeclaration"}, {"full_name": "Int.negOfNat_eq_subNatNat_zero", "code": "theorem negOfNat_eq_subNatNat_zero (n) : negOfNat n = subNatNat 0 n", "start": [411, 1], "end": [411, 90], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_mul_subNatNat", "code": "theorem ofNat_mul_subNatNat (m n k : Nat) :\n    m * subNatNat n k = subNatNat (m * n) (m * k)", "start": [413, 1], "end": [425, 77], "kind": "commanddeclaration"}, {"full_name": "Int.negOfNat_add", "code": "theorem negOfNat_add (m n : Nat) : negOfNat m + negOfNat n = negOfNat (m + n)", "start": [427, 1], "end": [428, 54], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_mul_subNatNat", "code": "theorem negSucc_mul_subNatNat (m n k : Nat) :\n    -[m+1] * subNatNat n k = subNatNat (succ m * k) (succ m * n)", "start": [430, 1], "end": [442, 88], "kind": "commanddeclaration"}, {"full_name": "Int.mul_add", "code": "protected theorem mul_add : \u2200 a b c : Int, a * (b + c) = a * b + a * c", "start": [446, 1], "end": [457, 81], "kind": "commanddeclaration"}, {"full_name": "Int.add_mul", "code": "protected theorem add_mul (a b c : Int) : (a + b) * c = a * c + b * c", "start": [459, 1], "end": [460, 35], "kind": "commanddeclaration"}, {"full_name": "Int.neg_mul_eq_neg_mul", "code": "protected theorem neg_mul_eq_neg_mul (a b : Int) : -(a * b) = -a * b", "start": [462, 1], "end": [463, 86], "kind": "commanddeclaration"}, {"full_name": "Int.neg_mul_eq_mul_neg", "code": "protected theorem neg_mul_eq_mul_neg (a b : Int) : -(a * b) = a * -b", "start": [465, 1], "end": [466, 86], "kind": "commanddeclaration"}, {"full_name": "Int.neg_mul", "code": "@[local simp] protected theorem neg_mul (a b : Int) : -a * b = -(a * b)", "start": [468, 1], "end": [469, 36], "kind": "commanddeclaration"}, {"full_name": "Int.mul_neg", "code": "@[local simp] protected theorem mul_neg (a b : Int) : a * -b = -(a * b)", "start": [471, 1], "end": [472, 36], "kind": "commanddeclaration"}, {"full_name": "Int.neg_mul_neg", "code": "protected theorem neg_mul_neg (a b : Int) : -a * -b = a * b", "start": [474, 1], "end": [474, 71], "kind": "commanddeclaration"}, {"full_name": "Int.neg_mul_comm", "code": "protected theorem neg_mul_comm (a b : Int) : -a * b = a * -b", "start": [476, 1], "end": [476, 72], "kind": "commanddeclaration"}, {"full_name": "Int.mul_sub", "code": "protected theorem mul_sub (a b c : Int) : a * (b - c) = a * b - a * c", "start": [478, 1], "end": [479, 41], "kind": "commanddeclaration"}, {"full_name": "Int.sub_mul", "code": "protected theorem sub_mul (a b c : Int) : (a - b) * c = a * c - b * c", "start": [481, 1], "end": [482, 41], "kind": "commanddeclaration"}, {"full_name": "Int.zero_ne_one", "code": "protected theorem zero_ne_one : (0 : Int) \u2260 1", "start": [484, 1], "end": [484, 54], "kind": "commanddeclaration"}, {"full_name": "Int.sub_add_cancel", "code": "@[simp] protected theorem sub_add_cancel (a b : Int) : a - b + b = a", "start": [486, 1], "end": [487, 31], "kind": "commanddeclaration"}, {"full_name": "Int.add_sub_cancel", "code": "@[simp] protected theorem add_sub_cancel (a b : Int) : a + b - b = a", "start": [489, 1], "end": [490, 31], "kind": "commanddeclaration"}, {"full_name": "Int.add_sub_assoc", "code": "protected theorem add_sub_assoc (a b c : Int) : a + b - c = a + (b - c)", "start": [492, 1], "end": [493, 63], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_sub", "code": "theorem ofNat_sub (h : m \u2264 n) : ((n - m : Nat) : Int) = n - m", "start": [495, 1], "end": [500, 44], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_coe'", "code": "theorem negSucc_coe' (n : Nat) : -[n+1] = -\u2191n - 1", "start": [502, 1], "end": [503, 46], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat_eq_coe", "code": "protected theorem subNatNat_eq_coe {m n : Nat} : subNatNat m n = \u2191m - \u2191n", "start": [505, 1], "end": [513, 22], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_sub", "code": "theorem toNat_sub (m n : Nat) : toNat (m - n) = m - n", "start": [515, 1], "end": [519, 80], "kind": "commanddeclaration"}, {"full_name": "Int.one_mul", "code": "@[simp] protected theorem one_mul : \u2200 a : Int, 1 * a = a", "start": [521, 1], "end": [523, 61], "kind": "commanddeclaration"}, {"full_name": "Int.mul_one", "code": "@[simp] protected theorem mul_one (a : Int) : a * 1 = a", "start": [525, 1], "end": [525, 93], "kind": "commanddeclaration"}, {"full_name": "Int.mul_neg_one", "code": "protected theorem mul_neg_one (a : Int) : a * -1 = -a", "start": [527, 1], "end": [527, 90], "kind": "commanddeclaration"}, {"full_name": "Int.neg_eq_neg_one_mul", "code": "protected theorem neg_eq_neg_one_mul : \u2200 a : Int, -a = -1 * a", "start": [529, 1], "end": [532, 56], "kind": "commanddeclaration"}, {"full_name": "Int.sign_mul_natAbs", "code": "theorem sign_mul_natAbs : \u2200 a : Int, sign a * natAbs a = a", "start": [534, 1], "end": [537, 46], "kind": "commanddeclaration"}, {"full_name": "Int.sign_mul", "code": "@[simp] theorem sign_mul : \u2200 a b, sign (a * b) = sign a * sign b", "start": [539, 1], "end": [541, 77], "kind": "commanddeclaration"}, {"full_name": "Int.nonneg_def", "code": "theorem nonneg_def {a : Int} : NonNeg a \u2194 \u2203 n : Nat, a = n", "start": [545, 1], "end": [546, 71], "kind": "commanddeclaration"}, {"full_name": "Int.NonNeg.elim", "code": "theorem NonNeg.elim {a : Int} : NonNeg a \u2192 \u2203 n : Nat, a = n", "start": [548, 1], "end": [548, 76], "kind": "commanddeclaration"}, {"full_name": "Int.nonneg_or_nonneg_neg", "code": "theorem nonneg_or_nonneg_neg : \u2200 (a : Int), NonNeg a \u2228 NonNeg (-a)", "start": [550, 1], "end": [552, 24], "kind": "commanddeclaration"}, {"full_name": "Int.le_def", "code": "theorem le_def (a b : Int) : a \u2264 b \u2194 NonNeg (b - a)", "start": [554, 1], "end": [554, 60], "kind": "commanddeclaration"}, {"full_name": "Int.lt_iff_add_one_le", "code": "theorem lt_iff_add_one_le (a b : Int) : a < b \u2194 a + 1 \u2264 b", "start": [556, 1], "end": [556, 66], "kind": "commanddeclaration"}, {"full_name": "Int.le.intro_sub", "code": "theorem le.intro_sub {a b : Int} (n : Nat) (h : b - a = n) : a \u2264 b", "start": [558, 1], "end": [559, 32], "kind": "commanddeclaration"}, {"full_name": "Int.le.intro", "code": "theorem le.intro {a b : Int} (n : Nat) (h : a + n = b) : a \u2264 b", "start": [561, 1], "end": [562, 88], "kind": "commanddeclaration"}, {"full_name": "Int.le.dest_sub", "code": "theorem le.dest_sub {a b : Int} (h : a \u2264 b) : \u2203 n : Nat, b - a = n", "start": [564, 1], "end": [564, 85], "kind": "commanddeclaration"}, {"full_name": "Int.le.dest", "code": "theorem le.dest {a b : Int} (h : a \u2264 b) : \u2203 n : Nat, a + n = b", "start": [566, 1], "end": [568, 76], "kind": "commanddeclaration"}, {"full_name": "Int.le_total", "code": "protected theorem le_total (a b : Int) : a \u2264 b \u2228 b \u2264 a", "start": [570, 1], "end": [572, 80], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_le", "code": "@[simp, norm_cast] theorem ofNat_le {m n : Nat} : (\u2191m : Int) \u2264 \u2191n \u2194 m \u2264 n", "start": [574, 1], "end": [580, 36], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_zero_le", "code": "theorem ofNat_zero_le (n : Nat) : 0 \u2264 (\u2191n : Int)", "start": [582, 1], "end": [582, 73], "kind": "commanddeclaration"}, {"full_name": "Int.eq_ofNat_of_zero_le", "code": "theorem eq_ofNat_of_zero_le {a : Int} (h : 0 \u2264 a) : \u2203 n : Nat, a = n", "start": [584, 1], "end": [585, 51], "kind": "commanddeclaration"}, {"full_name": "Int.eq_succ_of_zero_lt", "code": "theorem eq_succ_of_zero_lt {a : Int} (h : 0 < a) : \u2203 n : Nat, a = n.succ", "start": [587, 1], "end": [589, 47], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_succ", "code": "theorem lt_add_succ (a : Int) (n : Nat) : a < a + Nat.succ n", "start": [591, 1], "end": [592, 61], "kind": "commanddeclaration"}, {"full_name": "Int.lt.intro", "code": "theorem lt.intro {a b : Int} {n : Nat} (h : a + Nat.succ n = b) : a < b", "start": [594, 1], "end": [595, 22], "kind": "commanddeclaration"}, {"full_name": "Int.lt.dest", "code": "theorem lt.dest {a b : Int} (h : a < b) : \u2203 n : Nat, a + Nat.succ n = b", "start": [597, 1], "end": [598, 78], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_lt", "code": "@[simp, norm_cast] theorem ofNat_lt {n m : Nat} : (\u2191n : Int) < \u2191m \u2194 n < m", "start": [600, 1], "end": [601, 54], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_pos", "code": "@[simp, norm_cast] theorem ofNat_pos {n : Nat} : 0 < (\u2191n : Int) \u2194 0 < n", "start": [603, 1], "end": [603, 84], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_nonneg", "code": "theorem ofNat_nonneg (n : Nat) : 0 \u2264 (n : Int)", "start": [605, 1], "end": [605, 54], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_succ_pos", "code": "theorem ofNat_succ_pos (n : Nat) : 0 < (succ n : Int)", "start": [607, 1], "end": [607, 86], "kind": "commanddeclaration"}, {"full_name": "Int.le_refl", "code": "@[simp] protected theorem le_refl (a : Int) : a \u2264 a", "start": [609, 1], "end": [610, 30], "kind": "commanddeclaration"}, {"full_name": "Int.le_trans", "code": "protected theorem le_trans {a b c : Int} (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 c) : a \u2264 c", "start": [612, 1], "end": [614, 67], "kind": "commanddeclaration"}, {"full_name": "Int.le_antisymm", "code": "protected theorem le_antisymm {a b : Int} (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 a) : a = b", "start": [616, 1], "end": [620, 78], "kind": "commanddeclaration"}, {"full_name": "Int.lt_irrefl", "code": "protected theorem lt_irrefl (a : Int) : \u00aca < a", "start": [622, 1], "end": [627, 42], "kind": "commanddeclaration"}, {"full_name": "Int.ne_of_lt", "code": "protected theorem ne_of_lt {a b : Int} (h : a < b) : a \u2260 b", "start": [629, 1], "end": [630, 35], "kind": "commanddeclaration"}, {"full_name": "Int.ne_of_gt", "code": "protected theorem ne_of_gt {a b : Int} (h : b < a) : a \u2260 b", "start": [632, 1], "end": [632, 84], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_lt", "code": "protected theorem le_of_lt {a b : Int} (h : a < b) : a \u2264 b", "start": [634, 1], "end": [635, 42], "kind": "commanddeclaration"}, {"full_name": "Int.lt_iff_le_and_ne", "code": "protected theorem lt_iff_le_and_ne {a b : Int} : a < b \u2194 a \u2264 b \u2227 a \u2260 b", "start": [637, 1], "end": [641, 82], "kind": "commanddeclaration"}, {"full_name": "Int.lt_succ", "code": "theorem lt_succ (a : Int) : a < a + 1", "start": [643, 1], "end": [643, 55], "kind": "commanddeclaration"}, {"full_name": "Int.mul_nonneg", "code": "protected theorem mul_nonneg {a b : Int} (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 a * b", "start": [645, 1], "end": [648, 47], "kind": "commanddeclaration"}, {"full_name": "Int.mul_pos", "code": "protected theorem mul_pos {a b : Int} (ha : 0 < a) (hb : 0 < b) : 0 < a * b", "start": [650, 1], "end": [653, 49], "kind": "commanddeclaration"}, {"full_name": "Int.zero_lt_one", "code": "protected theorem zero_lt_one : (0 : Int) < 1", "start": [655, 1], "end": [655, 53], "kind": "commanddeclaration"}, {"full_name": "Int.lt_iff_le_not_le", "code": "protected theorem lt_iff_le_not_le {a b : Int} : a < b \u2194 a \u2264 b \u2227 \u00acb \u2264 a", "start": [657, 1], "end": [661, 32], "kind": "commanddeclaration"}, {"full_name": "Int.not_le", "code": "protected theorem not_le {a b : Int} : \u00aca \u2264 b \u2194 b < a", "start": [663, 1], "end": [665, 42], "kind": "commanddeclaration"}, {"full_name": "Int.not_lt", "code": "protected theorem not_lt {a b : Int} : \u00aca < b \u2194 b \u2264 a", "start": [667, 1], "end": [668, 42], "kind": "commanddeclaration"}, {"full_name": "Int.lt_trichotomy", "code": "protected theorem lt_trichotomy (a b : Int) : a < b \u2228 a = b \u2228 b < a", "start": [670, 1], "end": [673, 34], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_le_of_lt", "code": "protected theorem lt_of_le_of_lt {a b c : Int} (h\u2081 : a \u2264 b) (h\u2082 : b < c) : a < c", "start": [675, 1], "end": [676, 60], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_lt_of_le", "code": "protected theorem lt_of_lt_of_le {a b c : Int} (h\u2081 : a < b) (h\u2082 : b \u2264 c) : a < c", "start": [678, 1], "end": [679, 60], "kind": "commanddeclaration"}, {"full_name": "Int.lt_trans", "code": "protected theorem lt_trans {a b c : Int} (h\u2081 : a < b) (h\u2082 : b < c) : a < c", "start": [681, 1], "end": [682, 42], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_not_le", "code": "protected theorem le_of_not_le {a b : Int} : \u00ac a \u2264 b \u2192 b \u2264 a", "start": [684, 1], "end": [684, 96], "kind": "commanddeclaration"}, {"full_name": "Int.min_def", "code": "protected theorem min_def (n m : Int) : min n m = if n \u2264 m then n else m", "start": [686, 1], "end": [686, 80], "kind": "commanddeclaration"}, {"full_name": "Int.max_def", "code": "protected theorem max_def (n m : Int) : max n m = if n \u2264 m then m else n", "start": [688, 1], "end": [688, 80], "kind": "commanddeclaration"}, {"full_name": "Int.min_comm", "code": "protected theorem min_comm (a b : Int) : min a b = min b a", "start": [690, 1], "end": [694, 48], "kind": "commanddeclaration"}, {"full_name": "Int.min_le_right", "code": "protected theorem min_le_right (a b : Int) : min a b \u2264 b", "start": [696, 1], "end": [696, 100], "kind": "commanddeclaration"}, {"full_name": "Int.min_le_left", "code": "protected theorem min_le_left (a b : Int) : min a b \u2264 a", "start": [698, 1], "end": [698, 97], "kind": "commanddeclaration"}, {"full_name": "Int.le_min", "code": "protected theorem le_min {a b c : Int} : a \u2264 min b c \u2194 a \u2264 b \u2227 a \u2264 c", "start": [700, 1], "end": [702, 62], "kind": "commanddeclaration"}, {"full_name": "Int.min_eq_left", "code": "protected theorem min_eq_left {a b : Int} (h : a \u2264 b) : min a b = a", "start": [704, 1], "end": [704, 96], "kind": "commanddeclaration"}, {"full_name": "Int.min_eq_right", "code": "protected theorem min_eq_right {a b : Int} (h : b \u2264 a) : min a b = b", "start": [706, 1], "end": [707, 49], "kind": "commanddeclaration"}, {"full_name": "Int.max_comm", "code": "protected theorem max_comm (a b : Int) : max a b = max b a", "start": [709, 1], "end": [713, 48], "kind": "commanddeclaration"}, {"full_name": "Int.le_max_left", "code": "protected theorem le_max_left (a b : Int) : a \u2264 max a b", "start": [715, 1], "end": [715, 99], "kind": "commanddeclaration"}, {"full_name": "Int.le_max_right", "code": "protected theorem le_max_right (a b : Int) : b \u2264 max a b", "start": [717, 1], "end": [717, 97], "kind": "commanddeclaration"}, {"full_name": "Int.max_le", "code": "protected theorem max_le {a b c : Int} : max a b \u2264 c \u2194 a \u2264 c \u2227 b \u2264 c", "start": [719, 1], "end": [721, 62], "kind": "commanddeclaration"}, {"full_name": "Int.max_eq_right", "code": "protected theorem max_eq_right {a b : Int} (h : a \u2264 b) : max a b = b", "start": [723, 1], "end": [724, 40], "kind": "commanddeclaration"}, {"full_name": "Int.max_eq_left", "code": "protected theorem max_eq_left {a b : Int} (h : b \u2264 a) : max a b = a", "start": [726, 1], "end": [727, 52], "kind": "commanddeclaration"}, {"full_name": "Int.eq_natAbs_of_zero_le", "code": "theorem eq_natAbs_of_zero_le {a : Int} (h : 0 \u2264 a) : a = natAbs a", "start": [729, 1], "end": [731, 14], "kind": "commanddeclaration"}, {"full_name": "Int.le_natAbs", "code": "theorem le_natAbs {a : Int} : a \u2264 natAbs a", "start": [733, 1], "end": [736, 47], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_lt_zero", "code": "theorem negSucc_lt_zero (n : Nat) : -[n+1] < 0", "start": [738, 1], "end": [739, 71], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_not_nonneg", "code": "@[simp] theorem negSucc_not_nonneg (n : Nat) : 0 \u2264 -[n+1] \u2194 False", "start": [741, 1], "end": [742, 65], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_not_pos", "code": "@[simp] theorem negSucc_not_pos (n : Nat) : 0 < -[n+1] \u2194 False", "start": [744, 1], "end": [745, 49], "kind": "commanddeclaration"}, {"full_name": "Int.eq_negSucc_of_lt_zero", "code": "theorem eq_negSucc_of_lt_zero : \u2200 {a : Int}, a < 0 \u2192 \u2203 n : Nat, a = -[n+1]", "start": [747, 1], "end": [749, 27], "kind": "commanddeclaration"}, {"full_name": "Int.add_le_add_left", "code": "protected theorem add_le_add_left {a b : Int} (h : a \u2264 b) (c : Int) : c + a \u2264 c + b", "start": [751, 1], "end": [752, 68], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_add_left", "code": "protected theorem add_lt_add_left {a b : Int} (h : a < b) (c : Int) : c + a < c + b", "start": [754, 1], "end": [756, 58], "kind": "commanddeclaration"}, {"full_name": "Int.add_le_add_right", "code": "protected theorem add_le_add_right {a b : Int} (h : a \u2264 b) (c : Int) : a + c \u2264 b + c", "start": [758, 1], "end": [759, 64], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_add_right", "code": "protected theorem add_lt_add_right {a b : Int} (h : a < b) (c : Int) : a + c < b + c", "start": [761, 1], "end": [762, 64], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_add_le_add_left", "code": "protected theorem le_of_add_le_add_left {a b c : Int} (h : a + b \u2264 a + c) : b \u2264 c", "start": [764, 1], "end": [767, 13], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_add_lt_add_left", "code": "protected theorem lt_of_add_lt_add_left {a b c : Int} (h : a + b < a + c) : b < c", "start": [769, 1], "end": [772, 13], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_add_le_add_right", "code": "protected theorem le_of_add_le_add_right {a b c : Int} (h : a + b \u2264 c + b) : a \u2264 c", "start": [774, 1], "end": [775, 84], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_add_lt_add_right", "code": "protected theorem lt_of_add_lt_add_right {a b c : Int} (h : a + b < c + b) : a < c", "start": [777, 1], "end": [778, 84], "kind": "commanddeclaration"}, {"full_name": "Int.add_le_add_iff_left", "code": "protected theorem add_le_add_iff_left (a : Int) : a + b \u2264 a + c \u2194 b \u2264 c", "start": [780, 1], "end": [781, 57], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_add_iff_left", "code": "protected theorem add_lt_add_iff_left (a : Int) : a + b < a + c \u2194 b < c", "start": [783, 1], "end": [784, 57], "kind": "commanddeclaration"}, {"full_name": "Int.add_le_add_iff_right", "code": "protected theorem add_le_add_iff_right (c : Int) : a + c \u2264 b + c \u2194 a \u2264 b", "start": [786, 1], "end": [787, 59], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_add_iff_right", "code": "protected theorem add_lt_add_iff_right (c : Int) : a + c < b + c \u2194 a < b", "start": [789, 1], "end": [790, 59], "kind": "commanddeclaration"}, {"full_name": "Int.add_le_add", "code": "protected theorem add_le_add {a b c d : Int} (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) : a + c \u2264 b + d", "start": [792, 1], "end": [793, 70], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_of_nonneg_right", "code": "protected theorem le_add_of_nonneg_right {a b : Int} (h : 0 \u2264 b) : a \u2264 a + b", "start": [795, 1], "end": [797, 29], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_of_nonneg_left", "code": "protected theorem le_add_of_nonneg_left {a b : Int} (h : 0 \u2264 b) : a \u2264 b + a", "start": [799, 1], "end": [801, 29], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_add", "code": "protected theorem add_lt_add {a b c d : Int} (h\u2081 : a < b) (h\u2082 : c < d) : a + c < b + d", "start": [803, 1], "end": [804, 70], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_add_of_le_of_lt", "code": "protected theorem add_lt_add_of_le_of_lt {a b c d : Int} (h\u2081 : a \u2264 b) (h\u2082 : c < d) :\n    a + c < b + d", "start": [806, 1], "end": [808, 76], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_add_of_lt_of_le", "code": "protected theorem add_lt_add_of_lt_of_le {a b c d : Int} (h\u2081 : a < b) (h\u2082 : c \u2264 d) :\n    a + c < b + d", "start": [810, 1], "end": [812, 76], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_pos_right", "code": "protected theorem lt_add_of_pos_right (a : Int) {b : Int} (h : 0 < b) : a < a + b", "start": [814, 1], "end": [816, 29], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_pos_left", "code": "protected theorem lt_add_of_pos_left (a : Int) {b : Int} (h : 0 < b) : a < b + a", "start": [818, 1], "end": [820, 29], "kind": "commanddeclaration"}, {"full_name": "Int.add_nonneg", "code": "protected theorem add_nonneg {a b : Int} (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 a + b", "start": [822, 1], "end": [823, 40], "kind": "commanddeclaration"}, {"full_name": "Int.add_pos", "code": "protected theorem add_pos {a b : Int} (ha : 0 < a) (hb : 0 < b) : 0 < a + b", "start": [825, 1], "end": [826, 40], "kind": "commanddeclaration"}, {"full_name": "Int.add_pos_of_pos_of_nonneg", "code": "protected theorem add_pos_of_pos_of_nonneg {a b : Int} (ha : 0 < a) (hb : 0 \u2264 b) : 0 < a + b", "start": [828, 1], "end": [829, 52], "kind": "commanddeclaration"}, {"full_name": "Int.add_pos_of_nonneg_of_pos", "code": "protected theorem add_pos_of_nonneg_of_pos {a b : Int} (ha : 0 \u2264 a) (hb : 0 < b) : 0 < a + b", "start": [831, 1], "end": [832, 52], "kind": "commanddeclaration"}, {"full_name": "Int.add_nonpos", "code": "protected theorem add_nonpos {a b : Int} (ha : a \u2264 0) (hb : b \u2264 0) : a + b \u2264 0", "start": [834, 1], "end": [835, 40], "kind": "commanddeclaration"}, {"full_name": "Int.add_neg", "code": "protected theorem add_neg {a b : Int} (ha : a < 0) (hb : b < 0) : a + b < 0", "start": [837, 1], "end": [838, 40], "kind": "commanddeclaration"}, {"full_name": "Int.add_neg_of_neg_of_nonpos", "code": "protected theorem add_neg_of_neg_of_nonpos {a b : Int} (ha : a < 0) (hb : b \u2264 0) : a + b < 0", "start": [840, 1], "end": [841, 52], "kind": "commanddeclaration"}, {"full_name": "Int.add_neg_of_nonpos_of_neg", "code": "protected theorem add_neg_of_nonpos_of_neg {a b : Int} (ha : a \u2264 0) (hb : b < 0) : a + b < 0", "start": [843, 1], "end": [844, 52], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_le_of_pos", "code": "protected theorem lt_add_of_le_of_pos {a b c : Int} (hbc : b \u2264 c) (ha : 0 < a) : b < c + a", "start": [846, 1], "end": [847, 53], "kind": "commanddeclaration"}, {"full_name": "Int.add_one_le_iff", "code": "theorem add_one_le_iff {a b : Int} : a + 1 \u2264 b \u2194 a < b", "start": [849, 1], "end": [849, 63], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_one_iff", "code": "theorem lt_add_one_iff {a b : Int} : a < b + 1 \u2194 a \u2264 b", "start": [851, 1], "end": [851, 85], "kind": "commanddeclaration"}, {"full_name": "Int.succ_ofNat_pos", "code": "@[simp] theorem succ_ofNat_pos (n : Nat) : 0 < (n : Int) + 1", "start": [853, 1], "end": [854, 37], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_one", "code": "theorem le_add_one {a b : Int} (h : a \u2264 b) : a \u2264 b + 1", "start": [856, 1], "end": [857, 40], "kind": "commanddeclaration"}, {"full_name": "Int.neg_le_neg", "code": "protected theorem neg_le_neg {a b : Int} (h : a \u2264 b) : -b \u2264 -a", "start": [859, 1], "end": [862, 55], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_neg_le_neg", "code": "protected theorem le_of_neg_le_neg {a b : Int} (h : -b \u2264 -a) : a \u2264 b", "start": [864, 1], "end": [866, 19], "kind": "commanddeclaration"}, {"full_name": "Int.nonneg_of_neg_nonpos", "code": "protected theorem nonneg_of_neg_nonpos {a : Int} (h : -a \u2264 0) : 0 \u2264 a", "start": [868, 1], "end": [869, 48], "kind": "commanddeclaration"}, {"full_name": "Int.neg_nonpos_of_nonneg", "code": "protected theorem neg_nonpos_of_nonneg {a : Int} (h : 0 \u2264 a) : -a \u2264 0", "start": [871, 1], "end": [873, 29], "kind": "commanddeclaration"}, {"full_name": "Int.nonpos_of_neg_nonneg", "code": "protected theorem nonpos_of_neg_nonneg {a : Int} (h : 0 \u2264 -a) : a \u2264 0", "start": [875, 1], "end": [876, 48], "kind": "commanddeclaration"}, {"full_name": "Int.neg_nonneg_of_nonpos", "code": "protected theorem neg_nonneg_of_nonpos {a : Int} (h : a \u2264 0) : 0 \u2264 -a", "start": [878, 1], "end": [880, 29], "kind": "commanddeclaration"}, {"full_name": "Int.neg_lt_neg", "code": "protected theorem neg_lt_neg {a b : Int} (h : a < b) : -b < -a", "start": [882, 1], "end": [885, 55], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_neg_lt_neg", "code": "protected theorem lt_of_neg_lt_neg {a b : Int} (h : -b < -a) : a < b", "start": [887, 1], "end": [888, 51], "kind": "commanddeclaration"}, {"full_name": "Int.pos_of_neg_neg", "code": "protected theorem pos_of_neg_neg {a : Int} (h : -a < 0) : 0 < a", "start": [890, 1], "end": [891, 48], "kind": "commanddeclaration"}, {"full_name": "Int.neg_neg_of_pos", "code": "protected theorem neg_neg_of_pos {a : Int} (h : 0 < a) : -a < 0", "start": [893, 1], "end": [895, 29], "kind": "commanddeclaration"}, {"full_name": "Int.neg_of_neg_pos", "code": "protected theorem neg_of_neg_pos {a : Int} (h : 0 < -a) : a < 0", "start": [897, 1], "end": [899, 28], "kind": "commanddeclaration"}, {"full_name": "Int.neg_pos_of_neg", "code": "protected theorem neg_pos_of_neg {a : Int} (h : a < 0) : 0 < -a", "start": [901, 1], "end": [903, 29], "kind": "commanddeclaration"}, {"full_name": "Int.le_neg_of_le_neg", "code": "protected theorem le_neg_of_le_neg {a b : Int} (h : a \u2264 -b) : b \u2264 -a", "start": [905, 1], "end": [907, 25], "kind": "commanddeclaration"}, {"full_name": "Int.neg_le_of_neg_le", "code": "protected theorem neg_le_of_neg_le {a b : Int} (h : -a \u2264 b) : -b \u2264 a", "start": [909, 1], "end": [911, 25], "kind": "commanddeclaration"}, {"full_name": "Int.lt_neg_of_lt_neg", "code": "protected theorem lt_neg_of_lt_neg {a b : Int} (h : a < -b) : b < -a", "start": [913, 1], "end": [915, 25], "kind": "commanddeclaration"}, {"full_name": "Int.neg_lt_of_neg_lt", "code": "protected theorem neg_lt_of_neg_lt {a b : Int} (h : -a < b) : -b < a", "start": [917, 1], "end": [919, 25], "kind": "commanddeclaration"}, {"full_name": "Int.sub_nonneg_of_le", "code": "protected theorem sub_nonneg_of_le {a b : Int} (h : b \u2264 a) : 0 \u2264 a - b", "start": [921, 1], "end": [923, 31], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_sub_nonneg", "code": "protected theorem le_of_sub_nonneg {a b : Int} (h : 0 \u2264 a - b) : b \u2264 a", "start": [925, 1], "end": [927, 46], "kind": "commanddeclaration"}, {"full_name": "Int.sub_nonpos_of_le", "code": "protected theorem sub_nonpos_of_le {a b : Int} (h : a \u2264 b) : a - b \u2264 0", "start": [929, 1], "end": [931, 31], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_sub_nonpos", "code": "protected theorem le_of_sub_nonpos {a b : Int} (h : a - b \u2264 0) : a \u2264 b", "start": [933, 1], "end": [935, 46], "kind": "commanddeclaration"}, {"full_name": "Int.sub_pos_of_lt", "code": "protected theorem sub_pos_of_lt {a b : Int} (h : b < a) : 0 < a - b", "start": [937, 1], "end": [939, 31], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_sub_pos", "code": "protected theorem lt_of_sub_pos {a b : Int} (h : 0 < a - b) : b < a", "start": [941, 1], "end": [943, 46], "kind": "commanddeclaration"}, {"full_name": "Int.sub_neg_of_lt", "code": "protected theorem sub_neg_of_lt {a b : Int} (h : a < b) : a - b < 0", "start": [945, 1], "end": [947, 31], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_sub_neg", "code": "protected theorem lt_of_sub_neg {a b : Int} (h : a - b < 0) : a < b", "start": [949, 1], "end": [951, 46], "kind": "commanddeclaration"}, {"full_name": "Int.add_le_of_le_neg_add", "code": "protected theorem add_le_of_le_neg_add {a b c : Int} (h : b \u2264 -a + c) : a + b \u2264 c", "start": [953, 1], "end": [955, 37], "kind": "commanddeclaration"}, {"full_name": "Int.le_neg_add_of_add_le", "code": "protected theorem le_neg_add_of_add_le {a b c : Int} (h : a + b \u2264 c) : b \u2264 -a + c", "start": [957, 1], "end": [959, 37], "kind": "commanddeclaration"}, {"full_name": "Int.add_le_of_le_sub_left", "code": "protected theorem add_le_of_le_sub_left {a b c : Int} (h : b \u2264 c - a) : a + b \u2264 c", "start": [961, 1], "end": [963, 71], "kind": "commanddeclaration"}, {"full_name": "Int.le_sub_left_of_add_le", "code": "protected theorem le_sub_left_of_add_le {a b c : Int} (h : a + b \u2264 c) : b \u2264 c - a", "start": [965, 1], "end": [967, 56], "kind": "commanddeclaration"}, {"full_name": "Int.add_le_of_le_sub_right", "code": "protected theorem add_le_of_le_sub_right {a b c : Int} (h : a \u2264 c - b) : a + b \u2264 c", "start": [969, 1], "end": [971, 32], "kind": "commanddeclaration"}, {"full_name": "Int.le_sub_right_of_add_le", "code": "protected theorem le_sub_right_of_add_le {a b c : Int} (h : a + b \u2264 c) : a \u2264 c - b", "start": [973, 1], "end": [975, 38], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_of_neg_add_le", "code": "protected theorem le_add_of_neg_add_le {a b c : Int} (h : -b + a \u2264 c) : a \u2264 b + c", "start": [977, 1], "end": [979, 37], "kind": "commanddeclaration"}, {"full_name": "Int.neg_add_le_of_le_add", "code": "protected theorem neg_add_le_of_le_add {a b c : Int} (h : a \u2264 b + c) : -b + a \u2264 c", "start": [981, 1], "end": [983, 37], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_of_sub_left_le", "code": "protected theorem le_add_of_sub_left_le {a b c : Int} (h : a - b \u2264 c) : a \u2264 b + c", "start": [985, 1], "end": [987, 46], "kind": "commanddeclaration"}, {"full_name": "Int.sub_left_le_of_le_add", "code": "protected theorem sub_left_le_of_le_add {a b c : Int} (h : a \u2264 b + c) : a - b \u2264 c", "start": [989, 1], "end": [991, 56], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_of_sub_right_le", "code": "protected theorem le_add_of_sub_right_le {a b c : Int} (h : a - c \u2264 b) : a \u2264 b + c", "start": [993, 1], "end": [995, 32], "kind": "commanddeclaration"}, {"full_name": "Int.sub_right_le_of_le_add", "code": "protected theorem sub_right_le_of_le_add {a b c : Int} (h : a \u2264 b + c) : a - c \u2264 b", "start": [997, 1], "end": [999, 38], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_of_neg_add_le_left", "code": "protected theorem le_add_of_neg_add_le_left {a b c : Int} (h : -b + a \u2264 c) : a \u2264 b + c", "start": [1001, 1], "end": [1003, 36], "kind": "commanddeclaration"}, {"full_name": "Int.neg_add_le_left_of_le_add", "code": "protected theorem neg_add_le_left_of_le_add {a b c : Int} (h : a \u2264 b + c) : -b + a \u2264 c", "start": [1005, 1], "end": [1007, 36], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_of_neg_add_le_right", "code": "protected theorem le_add_of_neg_add_le_right {a b c : Int} (h : -c + a \u2264 b) : a \u2264 b + c", "start": [1009, 1], "end": [1011, 37], "kind": "commanddeclaration"}, {"full_name": "Int.neg_add_le_right_of_le_add", "code": "protected theorem neg_add_le_right_of_le_add {a b c : Int} (h : a \u2264 b + c) : -c + a \u2264 b", "start": [1013, 1], "end": [1015, 40], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_of_neg_le_sub_left", "code": "protected theorem le_add_of_neg_le_sub_left {a b c : Int} (h : -a \u2264 b - c) : c \u2264 a + b", "start": [1017, 1], "end": [1018, 63], "kind": "commanddeclaration"}, {"full_name": "Int.neg_le_sub_left_of_le_add", "code": "protected theorem neg_le_sub_left_of_le_add {a b c : Int} (h : c \u2264 a + b) : -a \u2264 b - c", "start": [1020, 1], "end": [1022, 26], "kind": "commanddeclaration"}, {"full_name": "Int.le_add_of_neg_le_sub_right", "code": "protected theorem le_add_of_neg_le_sub_right {a b c : Int} (h : -b \u2264 a - c) : c \u2264 a + b", "start": [1024, 1], "end": [1025, 59], "kind": "commanddeclaration"}, {"full_name": "Int.neg_le_sub_right_of_le_add", "code": "protected theorem neg_le_sub_right_of_le_add {a b c : Int} (h : c \u2264 a + b) : -b \u2264 a - c", "start": [1027, 1], "end": [1028, 59], "kind": "commanddeclaration"}, {"full_name": "Int.sub_le_of_sub_le", "code": "protected theorem sub_le_of_sub_le {a b c : Int} (h : a - b \u2264 c) : a - c \u2264 b", "start": [1030, 1], "end": [1031, 59], "kind": "commanddeclaration"}, {"full_name": "Int.sub_le_sub_left", "code": "protected theorem sub_le_sub_left {a b : Int} (h : a \u2264 b) (c : Int) : c - b \u2264 c - a", "start": [1033, 1], "end": [1034, 43], "kind": "commanddeclaration"}, {"full_name": "Int.sub_le_sub_right", "code": "protected theorem sub_le_sub_right {a b : Int} (h : a \u2264 b) (c : Int) : a - c \u2264 b - c", "start": [1036, 1], "end": [1037, 30], "kind": "commanddeclaration"}, {"full_name": "Int.sub_le_sub", "code": "protected theorem sub_le_sub {a b c d : Int} (hab : a \u2264 b) (hcd : c \u2264 d) : a - d \u2264 b - c", "start": [1039, 1], "end": [1040, 42], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_of_lt_neg_add", "code": "protected theorem add_lt_of_lt_neg_add {a b c : Int} (h : b < -a + c) : a + b < c", "start": [1042, 1], "end": [1044, 37], "kind": "commanddeclaration"}, {"full_name": "Int.lt_neg_add_of_add_lt", "code": "protected theorem lt_neg_add_of_add_lt {a b c : Int} (h : a + b < c) : b < -a + c", "start": [1046, 1], "end": [1048, 37], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_of_lt_sub_left", "code": "protected theorem add_lt_of_lt_sub_left {a b c : Int} (h : b < c - a) : a + b < c", "start": [1050, 1], "end": [1052, 71], "kind": "commanddeclaration"}, {"full_name": "Int.lt_sub_left_of_add_lt", "code": "protected theorem lt_sub_left_of_add_lt {a b c : Int} (h : a + b < c) : b < c - a", "start": [1054, 1], "end": [1056, 56], "kind": "commanddeclaration"}, {"full_name": "Int.add_lt_of_lt_sub_right", "code": "protected theorem add_lt_of_lt_sub_right {a b c : Int} (h : a < c - b) : a + b < c", "start": [1058, 1], "end": [1060, 32], "kind": "commanddeclaration"}, {"full_name": "Int.lt_sub_right_of_add_lt", "code": "protected theorem lt_sub_right_of_add_lt {a b c : Int} (h : a + b < c) : a < c - b", "start": [1062, 1], "end": [1064, 38], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_neg_add_lt", "code": "protected theorem lt_add_of_neg_add_lt {a b c : Int} (h : -b + a < c) : a < b + c", "start": [1066, 1], "end": [1068, 37], "kind": "commanddeclaration"}, {"full_name": "Int.neg_add_lt_of_lt_add", "code": "protected theorem neg_add_lt_of_lt_add {a b c : Int} (h : a < b + c) : -b + a < c", "start": [1070, 1], "end": [1072, 37], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_sub_left_lt", "code": "protected theorem lt_add_of_sub_left_lt {a b c : Int} (h : a - b < c) : a < b + c", "start": [1074, 1], "end": [1076, 46], "kind": "commanddeclaration"}, {"full_name": "Int.sub_left_lt_of_lt_add", "code": "protected theorem sub_left_lt_of_lt_add {a b c : Int} (h : a < b + c) : a - b < c", "start": [1078, 1], "end": [1080, 56], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_sub_right_lt", "code": "protected theorem lt_add_of_sub_right_lt {a b c : Int} (h : a - c < b) : a < b + c", "start": [1082, 1], "end": [1084, 32], "kind": "commanddeclaration"}, {"full_name": "Int.sub_right_lt_of_lt_add", "code": "protected theorem sub_right_lt_of_lt_add {a b c : Int} (h : a < b + c) : a - c < b", "start": [1086, 1], "end": [1088, 38], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_neg_add_lt_left", "code": "protected theorem lt_add_of_neg_add_lt_left {a b c : Int} (h : -b + a < c) : a < b + c", "start": [1090, 1], "end": [1092, 36], "kind": "commanddeclaration"}, {"full_name": "Int.neg_add_lt_left_of_lt_add", "code": "protected theorem neg_add_lt_left_of_lt_add {a b c : Int} (h : a < b + c) : -b + a < c", "start": [1094, 1], "end": [1096, 36], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_neg_add_lt_right", "code": "protected theorem lt_add_of_neg_add_lt_right {a b c : Int} (h : -c + a < b) : a < b + c", "start": [1098, 1], "end": [1100, 37], "kind": "commanddeclaration"}, {"full_name": "Int.neg_add_lt_right_of_lt_add", "code": "protected theorem neg_add_lt_right_of_lt_add {a b c : Int} (h : a < b + c) : -c + a < b", "start": [1102, 1], "end": [1104, 40], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_neg_lt_sub_left", "code": "protected theorem lt_add_of_neg_lt_sub_left {a b c : Int} (h : -a < b - c) : c < a + b", "start": [1106, 1], "end": [1107, 63], "kind": "commanddeclaration"}, {"full_name": "Int.neg_lt_sub_left_of_lt_add", "code": "protected theorem neg_lt_sub_left_of_lt_add {a b c : Int} (h : c < a + b) : -a < b - c", "start": [1109, 1], "end": [1111, 26], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_of_neg_lt_sub_right", "code": "protected theorem lt_add_of_neg_lt_sub_right {a b c : Int} (h : -b < a - c) : c < a + b", "start": [1113, 1], "end": [1114, 59], "kind": "commanddeclaration"}, {"full_name": "Int.neg_lt_sub_right_of_lt_add", "code": "protected theorem neg_lt_sub_right_of_lt_add {a b c : Int} (h : c < a + b) : -b < a - c", "start": [1116, 1], "end": [1117, 59], "kind": "commanddeclaration"}, {"full_name": "Int.sub_lt_of_sub_lt", "code": "protected theorem sub_lt_of_sub_lt {a b c : Int} (h : a - b < c) : a - c < b", "start": [1119, 1], "end": [1120, 59], "kind": "commanddeclaration"}, {"full_name": "Int.sub_lt_sub_left", "code": "protected theorem sub_lt_sub_left {a b : Int} (h : a < b) (c : Int) : c - b < c - a", "start": [1122, 1], "end": [1123, 43], "kind": "commanddeclaration"}, {"full_name": "Int.sub_lt_sub_right", "code": "protected theorem sub_lt_sub_right {a b : Int} (h : a < b) (c : Int) : a - c < b - c", "start": [1125, 1], "end": [1126, 30], "kind": "commanddeclaration"}, {"full_name": "Int.sub_lt_sub", "code": "protected theorem sub_lt_sub {a b c d : Int} (hab : a < b) (hcd : c < d) : a - d < b - c", "start": [1128, 1], "end": [1129, 42], "kind": "commanddeclaration"}, {"full_name": "Int.sub_lt_sub_of_le_of_lt", "code": "protected theorem sub_lt_sub_of_le_of_lt {a b c d : Int}\n  (hab : a \u2264 b) (hcd : c < d) : a - d < b - c", "start": [1131, 1], "end": [1133, 54], "kind": "commanddeclaration"}, {"full_name": "Int.sub_lt_sub_of_lt_of_le", "code": "protected theorem sub_lt_sub_of_lt_of_le {a b c d : Int}\n  (hab : a < b) (hcd : c \u2264 d) : a - d < b - c", "start": [1135, 1], "end": [1137, 54], "kind": "commanddeclaration"}, {"full_name": "Int.sub_le_self", "code": "protected theorem sub_le_self (a : Int) {b : Int} (h : 0 \u2264 b) : a - b \u2264 a", "start": [1139, 1], "end": [1142, 38], "kind": "commanddeclaration"}, {"full_name": "Int.sub_lt_self", "code": "protected theorem sub_lt_self (a : Int) {b : Int} (h : 0 < b) : a - b < a", "start": [1144, 1], "end": [1147, 38], "kind": "commanddeclaration"}, {"full_name": "Int.add_le_add_three", "code": "protected theorem add_le_add_three {a b c d e f : Int}\n    (h\u2081 : a \u2264 d) (h\u2082 : b \u2264 e) (h\u2083 : c \u2264 f) : a + b + c \u2264 d + e + f", "start": [1149, 1], "end": [1151, 43], "kind": "commanddeclaration"}, {"full_name": "Int.mul_lt_mul_of_pos_left", "code": "protected theorem mul_lt_mul_of_pos_left {a b c : Int}\n  (h\u2081 : a < b) (h\u2082 : 0 < c) : c * a < c * b", "start": [1153, 1], "end": [1157, 31], "kind": "commanddeclaration"}, {"full_name": "Int.mul_lt_mul_of_pos_right", "code": "protected theorem mul_lt_mul_of_pos_right {a b c : Int}\n  (h\u2081 : a < b) (h\u2082 : 0 < c) : a * c < b * c", "start": [1159, 1], "end": [1164, 31], "kind": "commanddeclaration"}, {"full_name": "Int.mul_le_mul_of_nonneg_left", "code": "protected theorem mul_le_mul_of_nonneg_left {a b c : Int}\n    (h\u2081 : a \u2264 b) (h\u2082 : 0 \u2264 c) : c * a \u2264 c * b", "start": [1166, 1], "end": [1171, 74], "kind": "commanddeclaration"}, {"full_name": "Int.mul_le_mul_of_nonneg_right", "code": "protected theorem mul_le_mul_of_nonneg_right {a b c : Int}\n    (h\u2081 : a \u2264 b) (h\u2082 : 0 \u2264 c) : a * c \u2264 b * c", "start": [1173, 1], "end": [1175, 79], "kind": "commanddeclaration"}, {"full_name": "Int.mul_le_mul", "code": "protected theorem mul_le_mul {a b c d : Int}\n    (hac : a \u2264 c) (hbd : b \u2264 d) (nn_b : 0 \u2264 b) (nn_c : 0 \u2264 c) : a * b \u2264 c * d", "start": [1177, 1], "end": [1179, 98], "kind": "commanddeclaration"}, {"full_name": "Int.mul_nonpos_of_nonneg_of_nonpos", "code": "protected theorem mul_nonpos_of_nonneg_of_nonpos {a b : Int}\n  (ha : 0 \u2264 a) (hb : b \u2264 0) : a * b \u2264 0", "start": [1181, 1], "end": [1184, 26], "kind": "commanddeclaration"}, {"full_name": "Int.mul_nonpos_of_nonpos_of_nonneg", "code": "protected theorem mul_nonpos_of_nonpos_of_nonneg {a b : Int}\n  (ha : a \u2264 0) (hb : 0 \u2264 b) : a * b \u2264 0", "start": [1186, 1], "end": [1189, 26], "kind": "commanddeclaration"}, {"full_name": "Int.mul_lt_mul", "code": "protected theorem mul_lt_mul {a b c d : Int}\n    (h\u2081 : a < c) (h\u2082 : b \u2264 d) (h\u2083 : 0 < b) (h\u2084 : 0 \u2264 c) : a * b < c * d", "start": [1191, 1], "end": [1193, 95], "kind": "commanddeclaration"}, {"full_name": "Int.mul_lt_mul'", "code": "protected theorem mul_lt_mul' {a b c d : Int}\n    (h\u2081 : a \u2264 c) (h\u2082 : b < d) (h\u2083 : 0 \u2264 b) (h\u2084 : 0 < c) : a * b < c * d", "start": [1195, 1], "end": [1197, 95], "kind": "commanddeclaration"}, {"full_name": "Int.mul_neg_of_pos_of_neg", "code": "protected theorem mul_neg_of_pos_of_neg {a b : Int} (ha : 0 < a) (hb : b < 0) : a * b < 0", "start": [1199, 1], "end": [1201, 26], "kind": "commanddeclaration"}, {"full_name": "Int.mul_neg_of_neg_of_pos", "code": "protected theorem mul_neg_of_neg_of_pos {a b : Int} (ha : a < 0) (hb : 0 < b) : a * b < 0", "start": [1203, 1], "end": [1205, 26], "kind": "commanddeclaration"}, {"full_name": "Int.mul_le_mul_of_nonpos_right", "code": "protected theorem mul_le_mul_of_nonpos_right {a b c : Int}\n    (h : b \u2264 a) (hc : c \u2264 0) : a * c \u2264 b * c", "start": [1207, 1], "end": [1211, 94], "kind": "commanddeclaration"}, {"full_name": "Int.mul_nonneg_of_nonpos_of_nonpos", "code": "protected theorem mul_nonneg_of_nonpos_of_nonpos {a b : Int}\n  (ha : a \u2264 0) (hb : b \u2264 0) : 0 \u2264 a * b", "start": [1213, 1], "end": [1216, 29], "kind": "commanddeclaration"}, {"full_name": "Int.mul_lt_mul_of_neg_left", "code": "protected theorem mul_lt_mul_of_neg_left {a b c : Int} (h : b < a) (hc : c < 0) : c * a < c * b", "start": [1218, 1], "end": [1223, 28], "kind": "commanddeclaration"}, {"full_name": "Int.mul_lt_mul_of_neg_right", "code": "protected theorem mul_lt_mul_of_neg_right {a b c : Int} (h : b < a) (hc : c < 0) : a * c < b * c", "start": [1225, 1], "end": [1230, 28], "kind": "commanddeclaration"}, {"full_name": "Int.mul_pos_of_neg_of_neg", "code": "protected theorem mul_pos_of_neg_of_neg {a b : Int} (ha : a < 0) (hb : b < 0) : 0 < a * b", "start": [1232, 1], "end": [1234, 29], "kind": "commanddeclaration"}, {"full_name": "Int.mul_self_le_mul_self", "code": "protected theorem mul_self_le_mul_self {a b : Int} (h1 : 0 \u2264 a) (h2 : a \u2264 b) : a * a \u2264 b * b", "start": [1236, 1], "end": [1237, 47], "kind": "commanddeclaration"}, {"full_name": "Int.mul_self_lt_mul_self", "code": "protected theorem mul_self_lt_mul_self {a b : Int} (h1 : 0 \u2264 a) (h2 : a < b) : a * a < b * b", "start": [1239, 1], "end": [1240, 69], "kind": "commanddeclaration"}, {"full_name": "Int.exists_eq_neg_ofNat", "code": "theorem exists_eq_neg_ofNat {a : Int} (H : a \u2264 0) : \u2203 n : Nat, a = -(n : Int)", "start": [1242, 1], "end": [1244, 35], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_of_nonneg", "code": "theorem natAbs_of_nonneg {a : Int} (H : 0 \u2264 a) : (natAbs a : Int) = a", "start": [1246, 1], "end": [1248, 23], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_natAbs_of_nonpos", "code": "theorem ofNat_natAbs_of_nonpos {a : Int} (H : a \u2264 0) : (natAbs a : Int) = -a", "start": [1250, 1], "end": [1251, 67], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_add_one_le", "code": "theorem lt_of_add_one_le {a b : Int} (H : a + 1 \u2264 b) : a < b", "start": [1253, 1], "end": [1253, 66], "kind": "commanddeclaration"}, {"full_name": "Int.add_one_le_of_lt", "code": "theorem add_one_le_of_lt {a b : Int} (H : a < b) : a + 1 \u2264 b", "start": [1255, 1], "end": [1255, 66], "kind": "commanddeclaration"}, {"full_name": "Int.lt_add_one_of_le", "code": "theorem lt_add_one_of_le {a b : Int} (H : a \u2264 b) : a < b + 1", "start": [1257, 1], "end": [1257, 89], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_lt_add_one", "code": "theorem le_of_lt_add_one {a b : Int} (H : a < b + 1) : a \u2264 b", "start": [1259, 1], "end": [1259, 93], "kind": "commanddeclaration"}, {"full_name": "Int.sub_one_lt_of_le", "code": "theorem sub_one_lt_of_le {a b : Int} (H : a \u2264 b) : a - 1 < b", "start": [1261, 1], "end": [1262, 51], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_sub_one_lt", "code": "theorem le_of_sub_one_lt {a b : Int} (H : a - 1 < b) : a \u2264 b", "start": [1264, 1], "end": [1265, 51], "kind": "commanddeclaration"}, {"full_name": "Int.le_sub_one_of_lt", "code": "theorem le_sub_one_of_lt {a b : Int} (H : a < b) : a \u2264 b - 1", "start": [1267, 1], "end": [1267, 93], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_le_sub_one", "code": "theorem lt_of_le_sub_one {a b : Int} (H : a \u2264 b - 1) : a < b", "start": [1269, 1], "end": [1269, 93], "kind": "commanddeclaration"}, {"full_name": "Int.sign_eq_one_of_pos", "code": "theorem sign_eq_one_of_pos {a : Int} (h : 0 < a) : sign a = 1", "start": [1271, 1], "end": [1273, 23], "kind": "commanddeclaration"}, {"full_name": "Int.sign_eq_neg_one_of_neg", "code": "theorem sign_eq_neg_one_of_neg {a : Int} (h : a < 0) : sign a = -1", "start": [1275, 1], "end": [1277, 23], "kind": "commanddeclaration"}, {"full_name": "Int.eq_zero_of_sign_eq_zero", "code": "theorem eq_zero_of_sign_eq_zero : \u2200 {a : Int}, sign a = 0 \u2192 a = 0", "start": [1279, 1], "end": [1280, 16], "kind": "commanddeclaration"}, {"full_name": "Int.pos_of_sign_eq_one", "code": "theorem pos_of_sign_eq_one : \u2200 {a : Int}, sign a = 1 \u2192 0 < a", "start": [1282, 1], "end": [1283, 52], "kind": "commanddeclaration"}, {"full_name": "Int.neg_of_sign_eq_neg_one", "code": "theorem neg_of_sign_eq_neg_one : \u2200 {a : Int}, sign a = -1 \u2192 a < 0", "start": [1285, 1], "end": [1288, 35], "kind": "commanddeclaration"}, {"full_name": "Int.sign_eq_one_iff_pos", "code": "theorem sign_eq_one_iff_pos (a : Int) : sign a = 1 \u2194 0 < a", "start": [1290, 1], "end": [1291, 43], "kind": "commanddeclaration"}, {"full_name": "Int.sign_eq_neg_one_iff_neg", "code": "theorem sign_eq_neg_one_iff_neg (a : Int) : sign a = -1 \u2194 a < 0", "start": [1293, 1], "end": [1294, 51], "kind": "commanddeclaration"}, {"full_name": "Int.sign_eq_zero_iff_zero", "code": "theorem sign_eq_zero_iff_zero (a : Int) : sign a = 0 \u2194 a = 0", "start": [1296, 1], "end": [1297, 59], "kind": "commanddeclaration"}, {"full_name": "Int.mul_eq_zero", "code": "protected theorem mul_eq_zero {a b : Int} : a * b = 0 \u2194 a = 0 \u2228 b = 0", "start": [1299, 1], "end": [1307, 92], "kind": "commanddeclaration"}, {"full_name": "Int.mul_ne_zero", "code": "protected theorem mul_ne_zero {a b : Int} (a0 : a \u2260 0) (b0 : b \u2260 0) : a * b \u2260 0", "start": [1309, 1], "end": [1310, 44], "kind": "commanddeclaration"}, {"full_name": "Int.eq_of_mul_eq_mul_right", "code": "protected theorem eq_of_mul_eq_mul_right {a b c : Int} (ha : a \u2260 0) (h : b * a = c * a) : b = c", "start": [1312, 1], "end": [1314, 65], "kind": "commanddeclaration"}, {"full_name": "Int.eq_of_mul_eq_mul_left", "code": "protected theorem eq_of_mul_eq_mul_left {a b c : Int} (ha : a \u2260 0) (h : a * b = a * c) : b = c", "start": [1316, 1], "end": [1320, 29], "kind": "commanddeclaration"}, {"full_name": "Int.eq_one_of_mul_eq_self_left", "code": "theorem eq_one_of_mul_eq_self_left {a b : Int} (Hpos : a \u2260 0) (H : b * a = a) : b = 1", "start": [1322, 1], "end": [1323, 60], "kind": "commanddeclaration"}, {"full_name": "Int.eq_one_of_mul_eq_self_right", "code": "theorem eq_one_of_mul_eq_self_right {a b : Int} (Hpos : b \u2260 0) (H : b * a = b) : a = 1", "start": [1325, 1], "end": [1326, 59], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_natAbs_eq_of_nonneg", "code": "theorem ofNat_natAbs_eq_of_nonneg : \u2200 a : Int, 0 \u2264 a \u2192 Int.natAbs a = a", "start": [1330, 1], "end": [1332, 62], "kind": "commanddeclaration"}, {"full_name": "Int.eq_natAbs_iff_mul_eq_zero", "code": "theorem eq_natAbs_iff_mul_eq_zero : natAbs a = n \u2194 (a - n) * (a + n) = 0", "start": [1334, 1], "end": [1335, 87], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_add_le", "code": "theorem natAbs_add_le (a b : Int) : natAbs (a + b) \u2264 natAbs a + natAbs b", "start": [1337, 1], "end": [1352, 27], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_sub_le", "code": "theorem natAbs_sub_le (a b : Int) : natAbs (a - b) \u2264 natAbs a + natAbs b", "start": [1354, 1], "end": [1355, 47], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_eq'", "code": "theorem negSucc_eq' (m : Nat) : -[m+1] = -m - 1", "start": [1357, 1], "end": [1357, 95], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_lt_natAbs_of_nonneg_of_lt", "code": "theorem natAbs_lt_natAbs_of_nonneg_of_lt {a b : Int}\n    (w\u2081 : 0 \u2264 a) (w\u2082 : a < b) : a.natAbs < b.natAbs", "start": [1359, 1], "end": [1362, 46], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_eq_max", "code": "theorem toNat_eq_max : \u2200 a : Int, (toNat a : Int) = max a 0", "start": [1366, 1], "end": [1368, 73], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_zero", "code": "@[simp] theorem toNat_zero : (0 : Int).toNat = 0", "start": [1370, 1], "end": [1370, 56], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_one", "code": "@[simp] theorem toNat_one : (1 : Int).toNat = 1", "start": [1372, 1], "end": [1372, 55], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_of_nonneg", "code": "@[simp] theorem toNat_of_nonneg {a : Int} (h : 0 \u2264 a) : (toNat a : Int) = a", "start": [1374, 1], "end": [1375, 39], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_ofNat", "code": "@[simp] theorem toNat_ofNat (n : Nat) : toNat \u2191n = n", "start": [1377, 1], "end": [1377, 60], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_ofNat_add_one", "code": "@[simp] theorem toNat_ofNat_add_one {n : Nat} : ((n : Int) + 1).toNat = n + 1", "start": [1379, 1], "end": [1379, 85], "kind": "commanddeclaration"}, {"full_name": "Int.self_le_toNat", "code": "theorem self_le_toNat (a : Int) : a \u2264 toNat a", "start": [1381, 1], "end": [1381, 93], "kind": "commanddeclaration"}, {"full_name": "Int.le_toNat", "code": "@[simp] theorem le_toNat {n : Nat} {z : Int} (h : 0 \u2264 z) : n \u2264 z.toNat \u2194 (n : Int) \u2264 z", "start": [1383, 1], "end": [1384, 45], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_lt", "code": "@[simp] theorem toNat_lt {n : Nat} {z : Int} (h : 0 \u2264 z) : z.toNat < n \u2194 z < (n : Int)", "start": [1386, 1], "end": [1387, 50], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_add", "code": "theorem toNat_add {a b : Int} (ha : 0 \u2264 a) (hb : 0 \u2264 b) : (a + b).toNat = a.toNat + b.toNat", "start": [1389, 1], "end": [1391, 36], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_add_nat", "code": "theorem toNat_add_nat {a : Int} (ha : 0 \u2264 a) (n : Nat) : (a + n).toNat = a.toNat + n", "start": [1393, 1], "end": [1394, 60], "kind": "commanddeclaration"}, {"full_name": "Int.pred_toNat", "code": "@[simp] theorem pred_toNat : \u2200 i : Int, (i - 1).toNat = i.toNat - 1", "start": [1396, 1], "end": [1399, 18], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_sub_toNat_neg", "code": "@[simp] theorem toNat_sub_toNat_neg : \u2200 n : Int, \u2191n.toNat - \u2191(-n).toNat = n", "start": [1401, 1], "end": [1404, 29], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_add_toNat_neg_eq_natAbs", "code": "@[simp] theorem toNat_add_toNat_neg_eq_natAbs : \u2200 n : Int, n.toNat + (-n).toNat = n.natAbs", "start": [1406, 1], "end": [1409, 29], "kind": "commanddeclaration"}, {"full_name": "Int.mem_toNat'", "code": "theorem mem_toNat' : \u2200 (a : Int) (n : Nat), toNat' a = some n \u2194 a = n", "start": [1411, 1], "end": [1413, 43], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_neg_nat", "code": "@[simp] theorem toNat_neg_nat : \u2200 n : Nat, (-(n : Int)).toNat = 0", "start": [1415, 1], "end": [1417, 15], "kind": "commanddeclaration"}, {"full_name": "Int.natCast_zero", "code": "theorem natCast_zero : ((0 : Nat) : Int) = (0 : Int)", "start": [1424, 1], "end": [1424, 60], "kind": "commanddeclaration"}, {"full_name": "Int.natCast_one", "code": "theorem natCast_one : ((1 : Nat) : Int) = (1 : Int)", "start": [1426, 1], "end": [1426, 59], "kind": "commanddeclaration"}, {"full_name": "Int.natCast_add", "code": "@[simp] theorem natCast_add (a b : Nat) : ((a + b : Nat) : Int) = (a : Int) + (b : Int)", "start": [1428, 1], "end": [1431, 7], "kind": "commanddeclaration"}, {"full_name": "Int.natCast_mul", "code": "@[simp] theorem natCast_mul (a b : Nat) : ((a * b : Nat) : Int) = (a : Int) * (b : Int)", "start": [1433, 1], "end": [1434, 7], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/InlineAttrs.lean", "lake-packages/lean4/src/lean/Lean/Compiler/FFI.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ExternAttr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/AtMostOnce.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ImplementedByAttr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ConstFolding.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ClosedTermCache.lean", "lake-packages/lean4/src/lean/Lean/Compiler/NeverExtractAttr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/Main.lean", "lake-packages/lean4/src/lean/Lean/Compiler/Old.lean", "lake-packages/lean4/src/lean/Lean/Compiler/Specialize.lean", "lake-packages/lean4/src/lean/Lean/Compiler/NoncomputableAttr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/CSimpAttr.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Util.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ReplaceLevel.lean", "lake-packages/lean4/src/lean/Lean/Util/Paths.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectLevelParams.lean", "lake-packages/lean4/src/lean/Lean/Util/ForEachExprWhere.lean", "lake-packages/lean4/src/lean/Lean/Util/HasConstCache.lean", "lake-packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean", "lake-packages/lean4/src/lean/Lean/Util/SCC.lean", "lake-packages/lean4/src/lean/Lean/Util/Sorry.lean", "lake-packages/lean4/src/lean/Lean/Util/MonadCache.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectMVars.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Util/RecDepth.lean", "lake-packages/lean4/src/lean/Lean/Util/FoldConsts.lean", "lake-packages/lean4/src/lean/Lean/Util/ForEachExpr.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectFVars.lean", "lake-packages/lean4/src/lean/Lean/Util/OccursCheck.lean", "lake-packages/lean4/src/lean/Lean/Util/Trace.lean", "lake-packages/lean4/src/lean/Lean/Util/Path.lean", "lake-packages/lean4/src/lean/Lean/Util/FindLevelMVar.lean", "lake-packages/lean4/src/lean/Lean/Util/Profile.lean", "lake-packages/lean4/src/lean/Lean/Util/FindMVar.lean", "lake-packages/lean4/src/lean/Lean/Util/PPExt.lean", "lake-packages/lean4/src/lean/Lean/Util/ShareCommon.lean", "lake-packages/lean4/src/lean/Lean/Util/FindExpr.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Server.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Server/CodeActions.lean", "lake-packages/lean4/src/lean/Lean/Server/Watchdog.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Server/FileWorker.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Linter.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Linter/MissingDocs.lean", "lake-packages/lean4/src/lean/Lean/Linter/UnusedVariables.lean", "lake-packages/lean4/src/lean/Lean/Linter/Builtin.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Linter/Util.lean", "lake-packages/lean4/src/lean/Lean/Linter/Deprecated.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Widget.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Widget/InteractiveCode.lean", "lake-packages/lean4/src/lean/Lean/Widget/UserWidget.lean", "lake-packages/lean4/src/lean/Lean/Widget/TaggedText.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveGoal.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveDiagnostic.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Data.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashSet.lean", "lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Lean/Data/PersistentArray.lean", "lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Lean/Data/KVMap.lean", "lake-packages/lean4/src/lean/Lean/Data/NameTrie.lean", "lake-packages/lean4/src/lean/Lean/Data/PersistentHashSet.lean", "lake-packages/lean4/src/lean/Lean/Data/SMap.lean", "lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "lake-packages/lean4/src/lean/Lean/Data/Xml.lean", "lake-packages/lean4/src/lean/Lean/Data/AssocList.lean", "lake-packages/lean4/src/lean/Lean/Data/JsonRpc.lean", "lake-packages/lean4/src/lean/Lean/Data/LOption.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Trie.lean", "lake-packages/lean4/src/lean/Lean/Data/NameMap.lean", "lake-packages/lean4/src/lean/Lean/Data/OpenDecl.lean", "lake-packages/lean4/src/lean/Lean/Data/Name.lean", "lake-packages/lean4/src/lean/Lean/Data/RBTree.lean", "lake-packages/lean4/src/lean/Lean/Data/LBool.lean", "lake-packages/lean4/src/lean/Lean/Data/Parsec.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Lean/Data/Position.lean", "lake-packages/lean4/src/lean/Lean/Data/Format.lean", "lake-packages/lean4/src/lean/Lean/Data/PersistentHashMap.lean", "lake-packages/lean4/src/lean/Lean/Data/Rat.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp.lean", "lake-packages/lean4/src/lean/Lean/Data/PrefixTree.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Calc.lean", "lake-packages/lean4/src/lean/Lean/Elab/Frontend.lean", "lake-packages/lean4/src/lean/Lean/Elab/StructInst.lean", "lake-packages/lean4/src/lean/Lean/Elab/Binders.lean", "lake-packages/lean4/src/lean/Lean/Elab/Eval.lean", "lake-packages/lean4/src/lean/Lean/Elab/InheritDoc.lean", "lake-packages/lean4/src/lean/Lean/Elab/Config.lean", "lake-packages/lean4/src/lean/Lean/Elab/Exception.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic.lean", "lake-packages/lean4/src/lean/Lean/Elab/LetRec.lean", "lake-packages/lean4/src/lean/Lean/Elab/BuiltinTerm.lean", "lake-packages/lean4/src/lean/Lean/Elab/Arg.lean", "lake-packages/lean4/src/lean/Lean/Elab/App.lean", "lake-packages/lean4/src/lean/Lean/Elab/Inductive.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/lean4/src/lean/Lean/Elab/BuiltinCommand.lean", "lake-packages/lean4/src/lean/Lean/Elab/GenInjective.lean", "lake-packages/lean4/src/lean/Lean/Elab/Syntax.lean", "lake-packages/lean4/src/lean/Lean/Elab/AuxDef.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Lean/Elab/Match.lean", "lake-packages/lean4/src/lean/Lean/Elab/Extra.lean", "lake-packages/lean4/src/lean/Lean/Elab/Notation.lean", "lake-packages/lean4/src/lean/Lean/Elab/BuiltinNotation.lean", "lake-packages/lean4/src/lean/Lean/Elab/RecAppSyntax.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition.lean", "lake-packages/lean4/src/lean/Lean/Elab/Quotation.lean", "lake-packages/lean4/src/lean/Lean/Elab/Import.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/PatternVar.lean", "lake-packages/lean4/src/lean/Lean/Elab/MacroRules.lean", "lake-packages/lean4/src/lean/Lean/Elab/Macro.lean", "lake-packages/lean4/src/lean/Lean/Elab/Mixfix.lean", "lake-packages/lean4/src/lean/Lean/Elab/ParseImportsFast.lean", "lake-packages/lean4/src/lean/Lean/Elab/Do.lean", "lake-packages/lean4/src/lean/Lean/Elab/Declaration.lean", "lake-packages/lean4/src/lean/Lean/Elab/MutualDef.lean", "lake-packages/lean4/src/lean/Lean/Elab/Print.lean", "lake-packages/lean4/src/lean/Lean/Elab/Deriving.lean", "lake-packages/lean4/src/lean/Lean/Elab/Structure.lean"], "premises": []}
{"path": "lake-packages/aesop/Aesop/Script.lean", "imports": ["lake-packages/aesop/Aesop/Util/EqualUpToIds.lean", "lake-packages/std/Std/Lean/Meta/Inaccessible.lean", "lake-packages/aesop/Aesop/Util/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Lean/Meta/Clear.lean", "lake-packages/std/Std/Lean/HashSet.lean", "lake-packages/aesop/Aesop/Util/Basic.lean"], "premises": [{"full_name": "Aesop.mkOneBasedNumLit", "code": "@[inline]\nprivate def mkOneBasedNumLit (n : Nat) : NumLit :=\n  Syntax.mkNumLit $ toString $ n + 1", "start": [37, 1], "end": [39, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalWithMVars", "code": "structure GoalWithMVars where\n  goal : MVarId\n  mvars : HashSet MVarId\n  deriving Inhabited", "start": [41, 1], "end": [44, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalWithMVars.ofMVarId", "code": "def GoalWithMVars.ofMVarId (goal : MVarId) : MetaM GoalWithMVars := do\n  return { goal, mvars := \u2190 goal.getMVarDependencies }", "start": [54, 1], "end": [55, 55], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScriptBuilder", "code": "def UnstructuredScriptBuilder (m : Type _ \u2192 Type _) := m (Array Syntax.Tactic)", "start": [62, 1], "end": [62, 79], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScriptBuilder.run", "code": "@[inline]\ndef run (b : UnstructuredScriptBuilder m) : m (Array Syntax.Tactic) :=\n  b", "start": [67, 1], "end": [69, 4], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScriptBuilder.ofTactics", "code": "@[inline]\ndef ofTactics (ts : m (Array Syntax.Tactic)) : UnstructuredScriptBuilder m :=\n  return (\u2190 ts)", "start": [71, 1], "end": [73, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScriptBuilder.ofTactic", "code": "@[inline]\ndef ofTactic (t : m Syntax.Tactic) : UnstructuredScriptBuilder m :=\n  return #[\u2190 t]", "start": [75, 1], "end": [77, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScriptBuilder.seq", "code": "@[inline]\ndef seq (b\u2081 b\u2082 : UnstructuredScriptBuilder m) : UnstructuredScriptBuilder m :=\n  return (\u2190 b\u2081.run) ++ (\u2190 b\u2082.run)", "start": [79, 1], "end": [81, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScriptBuilder.focusAndDoneEach", "code": "@[inline]\ndef focusAndDoneEach (bs : Array (UnstructuredScriptBuilder m)) :\n    UnstructuredScriptBuilder m := do\n  bs.mapM \u03bb b => do `(tactic| { $(\u2190 b.run):tactic* })", "start": [83, 1], "end": [86, 54], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScriptBuilder.seqFocusAndDone", "code": "@[inline]\ndef seqFocusAndDone (b : UnstructuredScriptBuilder m)\n    (bs : Array (UnstructuredScriptBuilder m)) : UnstructuredScriptBuilder m :=\n  b.seq (.focusAndDoneEach bs)", "start": [88, 1], "end": [91, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScriptBuilder.seqFocus", "code": "@[inline]\ndef seqFocus (b : UnstructuredScriptBuilder m)\n    (bs : Array (UnstructuredScriptBuilder m)) :\n    UnstructuredScriptBuilder m := do\n  let ts \u2190 b.run\n  if bs.size == 0 then\n    return ts\n  let tss \u2190 bs.mapM (\u00b7.run)\n  if tss.all (\u00b7.isEmpty) then\n    return ts\n  if h : tss.size = 1 then\n    let ts\u2082 := tss[0]'(by simp [h])\n    return ts.push (\u2190 `(tactic| focus $ts\u2082:tactic*))\n  else\n    let tss \u2190 tss.mapM \u03bb (ts\u2082 : Array Syntax.Tactic) =>\n      if ts\u2082.isEmpty then\n        `(tactic| skip)\n      else\n        `(tactic| ($ts\u2082:tactic*))\n    if let (some t) := ts[ts.size - 1]? then\n      return ts.pop.push (\u2190 `(tactic| $t:tactic <;> [ $tss;* ]))\n    else\n      return #[\u2190 `(tactic| map_tacs [ $tss;* ])]", "start": [93, 1], "end": [115, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScriptBuilder.id", "code": "@[inline]\nprotected def id : UnstructuredScriptBuilder m :=\n  return #[]", "start": [117, 1], "end": [119, 13], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder", "code": "structure StructuredScriptBuilder (m : Type \u2192 Type) where\n  subgoals : Nat\n  elim : Subarray (UnstructuredScriptBuilder m) \u2192 UnstructuredScriptBuilder m", "start": [127, 1], "end": [129, 78], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder.run", "code": "@[inline]\ndef run (b : StructuredScriptBuilder m) : m (Array Syntax.Tactic) :=\n  b.elim #[].toSubarray", "start": [133, 1], "end": [135, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder.ensureContsSize", "code": "private def ensureContsSize (conts : Subarray \u03b1) (subgoals : Nat) :\n    m (PLift (conts.size = subgoals)) := do\n  if h : conts.size = subgoals then\n    return \u27e8h\u27e9\n  else\n    throwError \"while building tactic syntax: tactic has {subgoals} subgoals but was given {conts.size} continuation tactics\"", "start": [137, 1], "end": [142, 126], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder.id", "code": "protected def id : StructuredScriptBuilder m where\n  subgoals := 1\n  elim conts := do\n    let \u27e8hconts\u27e9 \u2190 ensureContsSize conts 1\n    conts[0]'(by simp [hconts])", "start": [144, 1], "end": [148, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder.ofTactics", "code": "def ofTactics (subgoals : Nat) (ts : m (Array Syntax.Tactic)) :\n    StructuredScriptBuilder m where\n  subgoals := subgoals\n  elim conts := do\n    let \u27e8hconts\u27e9 \u2190 ensureContsSize conts subgoals\n    if subgoals = 0 then\n      UnstructuredScriptBuilder.ofTactics ts\n    else if h : subgoals = 1 then\n      UnstructuredScriptBuilder.ofTactics ts |>.seq (conts[0]'(by simp [*]))\n    else\n      UnstructuredScriptBuilder.ofTactics ts |>.seqFocusAndDone conts", "start": [150, 1], "end": [160, 70], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder.ofUnstructuredScriptBuilder", "code": "@[inline]\ndef ofUnstructuredScriptBuilder (subgoals : Nat)\n    (b : UnstructuredScriptBuilder m) : StructuredScriptBuilder m :=\n  .ofTactics subgoals b", "start": [162, 1], "end": [165, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder.ofTactic", "code": "@[inline]\ndef ofTactic (subgoals : Nat) (t : m Syntax.Tactic) :\n    StructuredScriptBuilder m :=\n  .ofTactics subgoals (return #[\u2190 t])", "start": [167, 1], "end": [170, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder.done", "code": "@[inline]\ndef done : StructuredScriptBuilder m :=\n  .ofTactics 0 (return #[])", "start": [172, 1], "end": [174, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder.error", "code": "def error (msg : MessageData) : StructuredScriptBuilder m where\n  subgoals := 0\n  elim _ := throwError \"Unable to build tactic syntax: {msg}\"", "start": [179, 1], "end": [181, 62], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScriptBuilder.seq", "code": "def seq (b : StructuredScriptBuilder m)\n    (bs : Array (StructuredScriptBuilder m)) : StructuredScriptBuilder m :=\n  let subgoals := bs.foldl (init := 0) \u03bb n b => n + b.subgoals\n  { subgoals\n    elim := \u03bb conts => do\n      discard $ ensureContsSize bs.toSubarray b.subgoals\n      discard $ ensureContsSize conts subgoals\n      let mut bConts := Array.mkEmpty b.subgoals\n      let mut start := 0\n      for b' in bs do\n        let \u00abend\u00bb := start + b'.subgoals\n        let b'Conts := conts[start:\u00abend\u00bb]\n        start := \u00abend\u00bb\n        bConts := bConts.push (b.elim b'Conts)\n      b.elim bConts.toSubarray\n  }", "start": [183, 1], "end": [198, 4], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder", "code": "structure ScriptBuilder (m) where\n  unstructured : UnstructuredScriptBuilder m\n  structured : StructuredScriptBuilder m", "start": [203, 1], "end": [205, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.id", "code": "protected def id : ScriptBuilder m where\n  unstructured := .id\n  structured := .id", "start": [212, 1], "end": [214, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.ofTactics", "code": "def ofTactics (subgoals : Nat) (ts : m (Array Syntax.Tactic)) :\n    ScriptBuilder m where\n  unstructured := .ofTactics ts\n  structured := .ofTactics subgoals ts", "start": [216, 1], "end": [219, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.ofUnstructuredScriptBuilder", "code": "@[inline]\ndef ofUnstructuredScriptBuilder (subgoals : Nat)\n    (b : UnstructuredScriptBuilder m) : ScriptBuilder m :=\n  .ofTactics subgoals b", "start": [221, 1], "end": [224, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.ofTactic", "code": "def ofTactic (subgoals : Nat) (t : m Syntax.Tactic) : ScriptBuilder m where\n  unstructured := .ofTactic t\n  structured := .ofTactic subgoals t", "start": [226, 1], "end": [228, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.seq", "code": "def seq (b : ScriptBuilder m) (bs : Array (ScriptBuilder m)) :\n    ScriptBuilder m where\n  unstructured := b.unstructured.seqFocus $ bs.map (\u00b7.unstructured)\n  structured := b.structured.seq $ bs.map (\u00b7.structured)", "start": [230, 1], "end": [233, 57], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.assertHypotheses", "code": "def assertHypotheses (goal : MVarId) (hs : Array Hypothesis) :\n    ScriptBuilder MetaM :=\n  .ofTactics 1 $ goal.withContext $ hs.mapM \u03bb h => do\n    `(tactic| have $(mkIdent h.userName) : $(\u2190 delab h.type) := $(\u2190 delab h.value))", "start": [235, 1], "end": [238, 84], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.clear", "code": "def clear (goal : MVarId) (fvarIds : Array FVarId) :\n    ScriptBuilder MetaM :=\n  .ofTactic 1 $ goal.withContext do\n    let userNames \u2190 fvarIds.mapM (mkIdent <$> \u00b7.getUserName)\n    `(tactic| clear $userNames*)", "start": [240, 1], "end": [244, 33], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.unhygienicAesopCases", "code": "def unhygienicAesopCases (goal : MVarId) (fvarId : FVarId) (subgoals : Nat) :\n    ScriptBuilder MetaM :=\n  .ofTactic subgoals do\n    let userName \u2190 goal.withContext fvarId.getUserName\n    `(tactic| unhygienic aesop_cases $(mkIdent userName):ident)", "start": [246, 1], "end": [250, 64], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.renameInaccessibleFVars", "code": "def renameInaccessibleFVars (goal : MVarId) (renamedFVars : Array FVarId) :\n    ScriptBuilder MetaM :=\n  if renamedFVars.isEmpty then\n    .id\n  else\n    .ofTactic 1 $ goal.withContext do\n      let ids \u2190 renamedFVars.mapM \u03bb fvarId => do\n        let userName := mkIdent (\u2190 fvarId.getDecl).userName\n        `(binderIdent| $userName:ident)\n      `(tactic| rename_i $ids:binderIdent*)", "start": [252, 1], "end": [261, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.unfoldManyStar", "code": "def unfoldManyStar (usedDecls : HashSet Name) : ScriptBuilder MetaM :=\n  if usedDecls.isEmpty then\n    .id\n  else\n    .ofTactic 1 `(tactic| aesop_unfold [$(usedDecls.toArray.map mkIdent):ident,*])", "start": [263, 1], "end": [267, 83], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.unhygienicExt", "code": "def unhygienicExt (subgoals : Nat) : ScriptBuilder MetaM :=\n  .ofTactic subgoals `(tactic| unhygienic ext)", "start": [269, 1], "end": [270, 47], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.withPrefix", "code": "@[inline, always_inline]\ndef withPrefix (f : TSyntax ``tacticSeq \u2192 m (Array (TSyntax `tactic)))\n    (b : ScriptBuilder m) : ScriptBuilder m where\n  unstructured := do\n    let ts \u2190 b.unstructured\n    f (\u2190 `(tacticSeq| $ts:tactic*))\n  structured := {\n    subgoals := b.structured.subgoals\n    elim := \u03bb ks => do\n      let ts \u2190 b.structured.elim ks\n      f (\u2190 `(tacticSeq| $ts:tactic*))\n  }", "start": [272, 1], "end": [283, 4], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.withTransparency", "code": "protected def withTransparency (md : TransparencyMode) (b : ScriptBuilder m) :\n    ScriptBuilder m :=\n  b.withPrefix \u03bb ts =>\n    return #[\u2190 `(tactic| ($(\u2190 withTransparencySeqSyntax md ts)))]", "start": [285, 1], "end": [288, 66], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScriptBuilder.withAllTransparency", "code": "protected def withAllTransparency (md : TransparencyMode) (b : ScriptBuilder m) :\n    ScriptBuilder m :=\n  b.withPrefix \u03bb ts =>\n    return #[\u2190 `(tactic| ($(\u2190 withAllTransparencySeqSyntax md ts)))]", "start": [290, 1], "end": [293, 69], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTacScriptBuilder", "code": "abbrev RuleTacScriptBuilder := ScriptBuilder MetaM", "start": [297, 1], "end": [297, 51], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkScriptBuilder?", "code": "@[inline, always_inline]\ndef mkScriptBuilder? (generateScript : Bool)\n    (builder : ScriptBuilder MetaM) : Option (ScriptBuilder MetaM) :=\n  if generateScript then\n    some builder\n  else\n    none", "start": [299, 1], "end": [305, 9], "kind": "commanddeclaration"}, {"full_name": "Aesop.assertHypothesesWithScript", "code": "def assertHypothesesWithScript (goal : MVarId)\n    (hs : Array Hypothesis) (generateScript : Bool) :\n    MetaM (Array FVarId \u00d7 MVarId \u00d7 Option (ScriptBuilder MetaM)) := do\n  let (fvarIds, goal') \u2190 goal.assertHypotheses hs\n  let scriptBuilder? := mkScriptBuilder? generateScript $ .assertHypotheses goal hs\n  return (fvarIds, goal', scriptBuilder?)", "start": [307, 1], "end": [312, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.clearWithScript", "code": "def clearWithScript (goal : MVarId) (fvarId : FVarId) (generateScript : Bool) :\n    MetaM (MVarId \u00d7 Option (ScriptBuilder MetaM)) :=\n  let scriptBuilder? := mkScriptBuilder? generateScript $ .clear goal #[fvarId]\n  return (\u2190 goal.clear fvarId, scriptBuilder?)", "start": [314, 1], "end": [317, 47], "kind": "commanddeclaration"}, {"full_name": "Aesop.tryClearWithScript", "code": "def tryClearWithScript (goal : MVarId) (fvarId : FVarId) (generateScript : Bool) :\n    MetaM (MVarId \u00d7 Option (ScriptBuilder MetaM)) := do\n  let goal' \u2190 goal.tryClear fvarId\n  let scriptBuilder? := mkScriptBuilder? generateScript $\n    if goal' == goal then\n      .id\n    else\n      .clear goal #[fvarId]\n  return (goal', scriptBuilder?)", "start": [319, 1], "end": [327, 33], "kind": "commanddeclaration"}, {"full_name": "Aesop.tryClearManyWithScript", "code": "def tryClearManyWithScript (goal : MVarId) (fvarIds : Array FVarId)\n    (generateScript : Bool) :\n    MetaM (MVarId \u00d7 Array FVarId \u00d7 Option (ScriptBuilder MetaM)) := do\n  let (goal', cleared) \u2190 goal.tryClearMany' fvarIds\n  let scriptBuilder? := mkScriptBuilder? generateScript $ .clear goal cleared\n  return (goal', cleared, scriptBuilder?)", "start": [329, 1], "end": [334, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.unhygienicCasesWithScript", "code": "def unhygienicCasesWithScript (goal : MVarId) (fvarId : FVarId)\n    (generateScript : Bool) :\n    MetaM (Array CasesSubgoal \u00d7 Option (ScriptBuilder MetaM)) := do\n  let goals \u2190 unhygienic $ goal.cases fvarId\n  let scriptBuilder? := mkScriptBuilder? generateScript $\n    .unhygienicAesopCases goal fvarId goals.size\n  return (goals, scriptBuilder?)", "start": [336, 1], "end": [342, 33], "kind": "commanddeclaration"}, {"full_name": "Aesop.renameInaccessibleFVarsWithScript", "code": "def renameInaccessibleFVarsWithScript (goal : MVarId) (generateScript : Bool) :\n    MetaM (MVarId \u00d7 Array FVarId \u00d7 Option (ScriptBuilder MetaM)) := do\n  let (goal, renamedFVars) \u2190 goal.renameInaccessibleFVars\n  let scriptBuilder? := mkScriptBuilder? generateScript $\n    .renameInaccessibleFVars goal renamedFVars\n  return (goal, renamedFVars, scriptBuilder?)", "start": [344, 1], "end": [349, 46], "kind": "commanddeclaration"}, {"full_name": "Aesop.unfoldManyStarWithScript", "code": "def unfoldManyStarWithScript (goal : MVarId)\n    (unfold? : Name \u2192 Option (Option Name)) (generateScript : Bool) :\n    MetaM (UnfoldResult \u00d7 Option (ScriptBuilder MetaM)) := do\n  let result \u2190 unfoldManyStar goal unfold?\n  let scriptBuilder? := mkScriptBuilder? generateScript $\n    .unfoldManyStar result.usedDecls\n  return (result, scriptBuilder?)", "start": [351, 1], "end": [357, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.throwUnknownGoalError", "code": "private def throwUnknownGoalError (goal : MVarId) (pre : MessageData) : m \u03b1 :=\n  throwError \"internal error: {pre}: unknown goal '?{goal.name}'\"", "start": [360, 1], "end": [361, 66], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState", "code": "structure TacticState where\n  visibleGoals : Array GoalWithMVars\n  invisibleGoals : HashSet MVarId\n  deriving Inhabited", "start": [364, 1], "end": [367, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.getVisibleGoalIndex?", "code": "def getVisibleGoalIndex? (ts : TacticState) (goal : MVarId) : Option Nat :=\n  ts.visibleGoals.findIdx? (\u00b7.goal == goal)", "start": [373, 1], "end": [374, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.getVisibleGoalIndex", "code": "def getVisibleGoalIndex (ts : TacticState) (goal : MVarId) : m Nat := do\n  if let (some idx) := ts.getVisibleGoalIndex? goal then\n    return idx\n  else\n    throwUnknownGoalError goal \"getVisibleGoalIndex\"", "start": [376, 1], "end": [380, 53], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.getMainGoal?", "code": "def getMainGoal? (ts : TacticState) : Option MVarId :=\n  ts.visibleGoals[0]?.map (\u00b7.goal)", "start": [382, 1], "end": [383, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.hasNoVisibleGoals", "code": "def hasNoVisibleGoals (ts : TacticState) : Bool :=\n  ts.visibleGoals.isEmpty", "start": [385, 1], "end": [386, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.hasSingleVisibleGoal", "code": "def hasSingleVisibleGoal (ts : TacticState) : Bool :=\n  ts.visibleGoals.size == 1", "start": [388, 1], "end": [389, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.visibleGoalsHaveMVars", "code": "def visibleGoalsHaveMVars (ts : TacticState) : Bool :=\n  ts.visibleGoals.any \u03bb g => ! g.mvars.isEmpty", "start": [391, 1], "end": [392, 47], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.replaceWithArray", "code": "private def replaceWithArray [BEq \u03b1] (xs : Array \u03b1) (x : \u03b1) (r : Array \u03b1) :\n    Option (Array \u03b1) := Id.run do\n  let mut found := false\n  let mut ys := Array.mkEmpty (xs.size - 1 + r.size)\n  for x' in xs do\n    if x' == x then\n      ys := ys ++ r\n      found := true\n    else\n      ys := ys.push x'\n  return if found then some ys else none", "start": [394, 1], "end": [404, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.eraseSolvedGoals", "code": "def eraseSolvedGoals (ts : TacticState) (mctx : MetavarContext) :\n    TacticState := {\n  ts with\n  visibleGoals :=\n    ts.visibleGoals.filter (! mctx.isExprMVarAssignedOrDelayedAssigned \u00b7.goal)\n  invisibleGoals :=\n    HashSet.filter ts.invisibleGoals\n      (! mctx.isExprMVarAssignedOrDelayedAssigned \u00b7)\n}", "start": [406, 1], "end": [414, 2], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.applyTactic", "code": "def applyTactic (ts : TacticState) (inGoal : MVarId)\n    (outGoals : Array GoalWithMVars) (postMCtx : MetavarContext) :\n    m TacticState := do\n  let (some visibleGoals) :=\n        replaceWithArray ts.visibleGoals \u27e8inGoal, {}\u27e9 outGoals\n    | throwUnknownGoalError inGoal \"applyTactic\"\n  let ts := { ts with visibleGoals }\n  return eraseSolvedGoals ts postMCtx", "start": [416, 1], "end": [423, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.focus", "code": "def focus (ts : TacticState) (goal : MVarId) : m TacticState := do\n  let (some goalWithMVars) := ts.visibleGoals.find? (\u00b7.goal == goal)\n    | throwUnknownGoalError goal \"focus\"\n  let mut invisibleGoals := ts.invisibleGoals\n  for g in ts.visibleGoals do\n    if g.goal != goal then\n      invisibleGoals := invisibleGoals.insert g.goal\n  return { visibleGoals := #[goalWithMVars], invisibleGoals }", "start": [427, 1], "end": [434, 62], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.onGoalM", "code": "@[inline, always_inline]\ndef onGoalM (ts : TacticState) (g : MVarId)\n    (f : TacticState \u2192 m (\u03b1 \u00d7 TacticState)) : m (\u03b1 \u00d7 TacticState) := do\n  let (a, postTs) \u2190 f (\u2190 ts.focus g)\n  let mut visibleGoals := #[]\n  for preGoal in ts.visibleGoals do\n    if preGoal.goal == g then\n      visibleGoals := visibleGoals ++ postTs.visibleGoals\n    else if postTs.invisibleGoals.contains preGoal.goal then\n      visibleGoals := visibleGoals.push preGoal\n  return (a, { visibleGoals, invisibleGoals := postTs.invisibleGoals })", "start": [436, 1], "end": [446, 72], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticInvocation", "code": "structure TacticInvocation where\n  preState : Meta.SavedState\n  preGoal : MVarId\n  tacticSeq : Array Syntax.Tactic\n  postGoals : Array GoalWithMVars\n  postState : Meta.SavedState\n  deriving Nonempty", "start": [451, 1], "end": [457, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticState.applyTacticInvocation", "code": "def TacticState.applyTacticInvocation (tacticState : TacticState)\n    (ti : TacticInvocation) : m TacticState :=\n  tacticState.applyTactic ti.preGoal ti.postGoals ti.postState.meta.mctx", "start": [459, 1], "end": [461, 73], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticInvocation.noop", "code": "def noop (preGoal : MVarId) (postGoal : GoalWithMVars)\n    (preState postState : Meta.SavedState) : TacticInvocation := {\n  tacticSeq := #[]\n  postGoals := #[postGoal]\n  preGoal, preState, postState\n}", "start": [465, 1], "end": [470, 2], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticInvocation.render", "code": "def render (acc : Array Syntax.Tactic) (ti : TacticInvocation)\n    (tacticState : TacticState) : m (Array Syntax.Tactic \u00d7 TacticState) := do\n  if ti.tacticSeq.size == 0 then\n    let tacticState \u2190 tacticState.applyTacticInvocation ti\n    return (acc, tacticState)\n  else\n    let pos \u2190 tacticState.getVisibleGoalIndex ti.preGoal\n    let tacticState \u2190 tacticState.applyTacticInvocation ti\n    if pos == 0 then\n      return (acc ++ ti.tacticSeq, tacticState)\n    else\n      let posLit := mkOneBasedNumLit pos\n      let t \u2190 `(tactic| on_goal $posLit:num => $(ti.tacticSeq):tactic*)\n      return (acc.push t, tacticState)", "start": [472, 1], "end": [485, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacticInvocation.validate", "code": "def validate (ti : TacticInvocation) : MetaM Unit := do\n  let preMCtx := ti.preState.meta.mctx\n  let expectedPostMCtx := ti.postState.meta.mctx\n  let expectedPostGoals := ti.postGoals |>.map (\u00b7.goal)\n  let tac \u2190 `(Lean.Parser.Tactic.tacticSeq| $ti.tacticSeq*)\n  let (actualPostState, actualPostGoals) \u2190\n    try\n      runTacticMCapturingPostState (evalTactic tac) ti.preState [ti.preGoal]\n    catch e =>\n      throwError \"tactic{indentD tac}\\nfailed with error{indentD e.toMessageData}\"\n  let actualPostGoals := actualPostGoals.toArray\n  unless \u2190 tacticStatesEqualUpToIds preMCtx expectedPostMCtx\n      actualPostState.meta.mctx expectedPostGoals actualPostGoals do\n    throwError \"tactic{indentD tac}\\nsucceeded but did not generate expected state. Initial goal:{indentD $ \u2190 fmtGoals ti.preState #[ti.preGoal]}\\nExpected goals:{indentD $ \u2190 fmtGoals ti.postState $ ti.postGoals.map (\u00b7.goal)}\\nActual goals:{indentD $ \u2190 fmtGoals actualPostState actualPostGoals}\"\nwhere\n  fmtGoals (state : Meta.SavedState) (goals : Array MVarId) :\n      MetaM MessageData :=\n    state.runMetaM' do\n      addMessageContext $\n        MessageData.joinSep (\u2190 goals.mapM (\u03bb g => return m!\"{g}\")).toList \"\\n\"", "start": [487, 1], "end": [506, 79], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScript", "code": "abbrev UnstructuredScript := Array TacticInvocation", "start": [511, 1], "end": [511, 52], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScript.render", "code": "def UnstructuredScript.render (tacticState : TacticState)\n    (s : UnstructuredScript) : m (Array Syntax.Tactic) := do\n  let mut script := Array.mkEmpty s.size\n  let mut tacticState := tacticState\n  for ti in s do\n    let (script', tacticState') \u2190 ti.render script tacticState\n    script := script'\n    tacticState := tacticState'\n  return script", "start": [513, 1], "end": [521, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScript.validate", "code": "def UnstructuredScript.validate (s : UnstructuredScript) : MetaM Unit :=\n  s.forM (\u00b7.validate)", "start": [523, 1], "end": [524, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScript", "code": "inductive StructuredScript\n  | empty\n  | unstructuredStep (ti : TacticInvocation) (tail : StructuredScript)\n  | solve (goal : MVarId) (here tail : StructuredScript)\n  deriving Inhabited", "start": [526, 1], "end": [530, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.StructuredScript.render", "code": "def StructuredScript.render (tacticState : TacticState)\n    (script : StructuredScript) : m (Array Syntax.Tactic) := do\n  (\u00b7.fst) <$> go #[] tacticState script\n  where\n    go (script : Array Syntax.Tactic) (tacticState : TacticState) :\n        StructuredScript \u2192 m (Array Syntax.Tactic \u00d7 TacticState)\n      | empty =>\n        return (script, tacticState)\n      | unstructuredStep ti tail => do\n        let (script, tacticState) \u2190 ti.render script tacticState\n        go script tacticState tail\n      | solve goal here tail => do\n        let pos \u2190 tacticState.getVisibleGoalIndex goal\n        let (nestedScript, tacticState) \u2190\n          tacticState.onGoalM goal \u03bb ts => do\n            let (nestedScript, nestedTacticState) \u2190 go #[] ts here\n            if ! nestedTacticState.hasNoVisibleGoals then\n              throwError \"expected script to solve the goal\"\n            pure (nestedScript, nestedTacticState)\n        let t \u2190\n          if pos == 0 then\n            `(tactic| \u00b7 $[$nestedScript:tactic]*)\n          else\n            let posLit := mkOneBasedNumLit pos\n            `(tactic| on_goal $posLit:num => { $nestedScript:tactic* })\n        go (script.push t) tacticState tail", "start": [532, 1], "end": [557, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnstructuredScript.toStructuredScript", "code": "partial def UnstructuredScript.toStructuredScript (tacticState : TacticState)\n    (script : UnstructuredScript) : m StructuredScript := do\n  let mut steps := {}\n  for h : i in [:script.size] do\n    let step := script[i]'h.2\n    steps := steps.insert step.preGoal (i, step)\n  (\u00b7.fst) <$> go steps tacticState\nwhere\n  go (steps : HashMap MVarId (Nat \u00d7 TacticInvocation))\n      (tacticState : TacticState) : m (StructuredScript \u00d7 TacticState) := do\n    if tacticState.hasNoVisibleGoals then\n      return (.empty, tacticState)\n    else if tacticState.hasSingleVisibleGoal ||\n            tacticState.visibleGoalsHaveMVars then\n      let mut firstStep? := none\n      for g in tacticState.visibleGoals do\n        if let (some (i, step)) := steps[g.goal] then\n          if let some (j, firstStep) := firstStep? then\n            firstStep? := some $ if i < j then (i, step) else (j, firstStep)\n          else\n            firstStep? := some (i, step)\n        else\n          continue\n      let some (_, firstStep) := firstStep?\n        | throwError \"internal error: found no step to solve any visible goal\"\n      let tacticState \u2190 tacticState.applyTacticInvocation firstStep\n      let (tailScript, tacticState) \u2190 go steps tacticState\n      return (.unstructuredStep firstStep tailScript, tacticState)\n    else\n      let mut tacticState := tacticState\n      let mut nestedScripts := Array.mkEmpty tacticState.visibleGoals.size\n      while h : tacticState.visibleGoals.size > 0 do\n        let goal := tacticState.visibleGoals[0]\n        let (nestedScript, nestedTacticState) \u2190\n          tacticState.onGoalM goal.goal \u03bb tacticState => go steps tacticState\n        nestedScripts := nestedScripts.push (goal.goal, nestedScript)\n        tacticState := nestedTacticState\n      let script := nestedScripts.foldr (init := .empty)\n        \u03bb (goal, nestedScript) tail => .solve goal nestedScript tail\n      return (script, tacticState)", "start": [562, 1], "end": [609, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Percent.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Percent", "code": "structure Percent where\n  toFloat : Float\n  deriving Inhabited", "start": [15, 1], "end": [17, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Percent.ofFloat", "code": "protected def ofFloat (f : Float) : Option Percent :=\n  if 0 <= f && f <= 1.0 then some \u27e8f\u27e9 else none", "start": [21, 1], "end": [22, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.Percent.\u03b4", "code": "@[inline]\ndef \u03b4 : Percent :=\n  \u27e80.00001\u27e9", "start": [27, 1], "end": [29, 12], "kind": "commanddeclaration"}, {"full_name": "Aesop.Percent.hundred", "code": "def hundred : Percent :=\n  \u27e81\u27e9", "start": [57, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Aesop.Percent.fifty", "code": "def fifty : Percent :=\n  \u27e80.5\u27e9", "start": [60, 1], "end": [61, 8], "kind": "commanddeclaration"}, {"full_name": "Aesop.Percent.toHumanString", "code": "def toHumanString (p : Percent) : String :=\n  let str := toString (p.toFloat * 100)\n  match str.split \u03bb c => c == '.' with\n  | [beforePoint] => beforePoint ++ \"%\"\n  | [beforePoint, afterPoint] =>\n    beforePoint ++ \".\" ++ afterPoint.take 4 ++ \"%\"\n  | _ => unreachable!", "start": [63, 1], "end": [69, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.Percent.ofNat", "code": "protected def ofNat (n : Nat) : Option Percent :=\n  Percent.ofFloat $ n.toFloat / 100", "start": [71, 1], "end": [72, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Options.lean", "imports": ["lake-packages/aesop/Aesop/Options/Public.lean", "lake-packages/aesop/Aesop/Options/Internal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/aesop/Aesop/Index/Basic.lean", "imports": ["lake-packages/aesop/Aesop/Util/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.simpleReduce", "code": "def simpleReduce := false", "start": [16, 1], "end": [16, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.IndexingMode", "code": "inductive IndexingMode : Type\n  | unindexed\n  | target (keys : Array (DiscrTree.Key simpleReduce))\n  | hyps (keys : Array (DiscrTree.Key simpleReduce))\n  | or (imodes : Array IndexingMode)\n  deriving Inhabited", "start": [18, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.IndexingMode.format", "code": "protected partial def format : IndexingMode \u2192 Format\n  | unindexed => \"unindexed\"\n  | target keys => f!\"target {keys}\"\n  | hyps keys => f!\"hyps {keys}\"\n  | or imodes => f!\"or {imodes.map IndexingMode.format}\"", "start": [27, 1], "end": [31, 57], "kind": "commanddeclaration"}, {"full_name": "Aesop.IndexingMode.targetMatchingConclusion", "code": "def targetMatchingConclusion (type : Expr) : MetaM IndexingMode := do\n  let path \u2190 getConclusionDiscrTreeKeys type\n  return target path", "start": [36, 1], "end": [38, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.IndexingMode.hypsMatchingConst", "code": "def hypsMatchingConst (decl : Name) : MetaM IndexingMode := do\n  let path \u2190 getConstDiscrTreeKeys decl\n  return hyps path", "start": [40, 1], "end": [42, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.IndexMatchLocation", "code": "inductive IndexMatchLocation\n  | target\n  | none\n  | hyp (ldecl : LocalDecl)\n  deriving Inhabited", "start": [47, 1], "end": [51, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.IndexMatchResult", "code": "structure IndexMatchResult (\u03b1 : Type) where\n  rule : \u03b1\n  locations : UnorderedArraySet IndexMatchLocation\n  deriving Inhabited", "start": [83, 1], "end": [86, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/String/Basic.lean", "imports": ["lake-packages/std/Std/Data/Array/Match.lean", "lake-packages/std/Std/Data/Char.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "String.Pos.ne_zero_of_lt", "code": "protected theorem Pos.ne_zero_of_lt : {a b : Pos} \u2192 a < b \u2192 b \u2260 0", "start": [15, 1], "end": [16, 44], "kind": "commanddeclaration"}, {"full_name": "String.Matcher", "code": "structure Matcher extends Array.Matcher Char where\n  \n  pattern : Substring", "start": [18, 1], "end": [39, 22], "kind": "commanddeclaration"}, {"full_name": "String.Matcher.ofSubstring", "code": "@[inline] def Matcher.ofSubstring (pattern : Substring) : Matcher where\n  toMatcher := Array.Matcher.ofStream pattern\n  pattern := pattern", "start": [41, 1], "end": [44, 21], "kind": "commanddeclaration"}, {"full_name": "String.Matcher.ofString", "code": "@[inline] def Matcher.ofString (pattern : String) : Matcher :=\n  Matcher.ofSubstring pattern", "start": [46, 1], "end": [48, 30], "kind": "commanddeclaration"}, {"full_name": "String.Matcher.patternSize", "code": "abbrev Matcher.patternSize (m : Matcher) : Nat := m.pattern.bsize", "start": [50, 1], "end": [51, 66], "kind": "commanddeclaration"}, {"full_name": "String.Matcher.findAll", "code": "partial def Matcher.findAll (m : Matcher) (s : Substring) : Array Substring :=\n  loop s m.toMatcher #[]\nwhere\n  \n  loop (s : Substring) (am : Array.Matcher Char) (occs : Array Substring) : Array Substring :=\n    match am.next? s with\n    | none => occs\n    | some (s, am) =>\n      loop s am <| occs.push { s with\n        startPos := \u27e8s.startPos.byteIdx - m.patternSize\u27e9\n        stopPos := s.startPos }", "start": [53, 1], "end": [64, 32], "kind": "commanddeclaration"}, {"full_name": "String.Matcher.find?", "code": "def Matcher.find? (m : Matcher) (s : Substring) : Option Substring :=\n  match m.next? s with\n  | none => none\n  | some (s, _) =>\n    some { s with\n      startPos := \u27e8s.startPos.byteIdx - m.patternSize\u27e9\n      stopPos := s.startPos }", "start": [66, 1], "end": [73, 30], "kind": "commanddeclaration"}, {"full_name": "Substring.commonPrefix", "code": "def commonPrefix (s t : Substring) : Substring :=\n  { s with stopPos := loop s.startPos t.startPos }\nwhere\n  \n  loop spos tpos :=\n    if h : spos < s.stopPos \u2227 tpos < t.stopPos then\n      if s.str.get spos == t.str.get tpos then\n        have := Nat.sub_lt_sub_left h.1 (s.str.lt_next spos)\n        loop (s.str.next spos) (t.str.next tpos)\n      else\n        spos\n    else\n      spos\ntermination_by loop => s.stopPos.byteIdx - spos.byteIdx", "start": [79, 1], "end": [96, 56], "kind": "commanddeclaration"}, {"full_name": "Substring.commonSuffix", "code": "def commonSuffix (s t : Substring) : Substring :=\n  { s with startPos := loop s.stopPos t.stopPos }\nwhere\n  \n  loop spos tpos :=\n    if h : s.startPos < spos \u2227 t.startPos < tpos then\n      let spos' := s.str.prev spos\n      let tpos' := t.str.prev tpos\n      if s.str.get spos' == t.str.get tpos' then\n        have : spos' < spos := s.str.prev_lt_of_pos spos (String.Pos.ne_zero_of_lt h.1)\n        loop spos' tpos'\n      else\n        spos\n    else\n      spos\ntermination_by loop => spos.byteIdx", "start": [98, 1], "end": [117, 36], "kind": "commanddeclaration"}, {"full_name": "Substring.dropPrefix?", "code": "def dropPrefix? (s : Substring) (pre : Substring) : Option Substring :=\n  let t := s.commonPrefix pre\n  if t.bsize = pre.bsize then\n    some { s with startPos := t.stopPos }\n  else\n    none", "start": [119, 1], "end": [127, 9], "kind": "commanddeclaration"}, {"full_name": "Substring.dropSuffix?", "code": "def dropSuffix? (s : Substring) (suff : Substring) : Option Substring :=\n  let t := s.commonSuffix suff\n  if t.bsize = suff.bsize then\n    some { s with stopPos := t.startPos }\n  else\n    none", "start": [129, 1], "end": [137, 9], "kind": "commanddeclaration"}, {"full_name": "Substring.findAllSubstr", "code": "@[inline] def findAllSubstr (s pattern : Substring) : Array Substring :=\n  (String.Matcher.ofSubstring pattern).findAll s", "start": [139, 1], "end": [143, 49], "kind": "commanddeclaration"}, {"full_name": "Substring.findSubstr?", "code": "@[inline] def findSubstr? (s pattern : Substring) : Option Substring :=\n  (String.Matcher.ofSubstring pattern).find? s", "start": [145, 1], "end": [150, 47], "kind": "commanddeclaration"}, {"full_name": "Substring.containsSubstr", "code": "@[inline] def containsSubstr (s pattern : Substring) : Bool :=\n  s.findSubstr? pattern |>.isSome", "start": [152, 1], "end": [156, 34], "kind": "commanddeclaration"}, {"full_name": "String.findAllSubstr", "code": "@[inherit_doc Substring.findAllSubstr]\nabbrev findAllSubstr (s : String) (pattern : Substring) : Array Substring :=\n  (String.Matcher.ofSubstring pattern).findAll s", "start": [162, 1], "end": [164, 49], "kind": "commanddeclaration"}, {"full_name": "String.findSubstr?", "code": "@[inherit_doc Substring.findSubstr?]\nabbrev findSubstr? (s : String) (pattern : Substring) : Option Substring :=\n  s.toSubstring.findSubstr? pattern", "start": [166, 1], "end": [168, 36], "kind": "commanddeclaration"}, {"full_name": "String.containsSubstr", "code": "@[inherit_doc Substring.containsSubstr]\nabbrev containsSubstr (s : String) (pattern : Substring) : Bool :=\n  s.toSubstring.containsSubstr pattern", "start": [170, 1], "end": [172, 39], "kind": "commanddeclaration"}, {"full_name": "String.dropPrefix?", "code": "def dropPrefix? (s : String) (pre : Substring) : Option Substring :=\n  Substring.dropPrefix? s pre", "start": [174, 1], "end": [178, 30], "kind": "commanddeclaration"}, {"full_name": "String.dropSuffix?", "code": "def dropSuffix? (s : String) (suff : Substring) : Option Substring :=\n  Substring.dropSuffix? s suff", "start": [180, 1], "end": [184, 31], "kind": "commanddeclaration"}, {"full_name": "String.stripPrefix", "code": "def stripPrefix (s : String) (pre : Substring) : String :=\n  s.dropPrefix? pre |>.map Substring.toString |>.getD s", "start": [186, 1], "end": [189, 56], "kind": "commanddeclaration"}, {"full_name": "String.stripSuffix", "code": "def stripSuffix (s : String) (suff : Substring) : String :=\n  s.dropSuffix? suff |>.map Substring.toString |>.getD s", "start": [191, 1], "end": [194, 57], "kind": "commanddeclaration"}, {"full_name": "String.count", "code": "def count (s : String) (c : Char) : Nat :=\n  s.foldl (fun n d => if d = c then n + 1 else n) 0", "start": [196, 1], "end": [198, 52], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/CodeAction/Deprecated.lean", "imports": ["lake-packages/std/Std/Lean/Position.lean", "lake-packages/lean4/src/lean/Lean/Server/CodeActions.lean", "lake-packages/std/Std/CodeAction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.CodeAction.deprecatedCodeActionProvider", "code": "@[code_action_provider]\ndef deprecatedCodeActionProvider : CodeActionProvider := fun params snap => do\n  let mut i := 0\n  let doc \u2190 readDoc\n  let mut msgs := #[]\n  for diag in snap.interactiveDiags do\n    if let some #[.deprecated] := diag.tags? then\n      if h : _ then\n        msgs := msgs.push (snap.cmdState.messages.msgs[i]'h)\n    i := i + 1\n  if msgs.isEmpty then return #[]\n  let start := doc.meta.text.lspPosToUtf8Pos params.range.start\n  let stop := doc.meta.text.lspPosToUtf8Pos params.range.end\n  for msg in msgs do\n    let some endPos := msg.endPos | continue\n    let pos := doc.meta.text.ofPosition msg.pos\n    let endPos' := doc.meta.text.ofPosition endPos\n    unless start \u2264 endPos' && pos \u2264 stop do continue\n    let some (ctx, .node (.ofTermInfo info@{ expr := .const c .., ..}) _) :=\n      findInfoTree? identKind \u27e8pos, endPos'\u27e9 none snap.infoTree fun _ i =>\n        (i matches .ofTermInfo { elaborator := .anonymous, expr := .const .., ..})\n      | continue\n    unless machineApplicableDeprecated.isTagged snap.cmdState.env c do continue\n    let some c' := Linter.getDeprecatedNewName snap.cmdState.env c | continue\n    let eager : CodeAction := {\n      title := s!\"Replace {c} with {c'}\"\n      kind? := \"quickfix\"\n      isPreferred? := true\n    }\n    return #[{\n      eager\n      lazy? := some do\n        let c' \u2190 info.runMetaM ctx (unresolveNameGlobal c')\n        let pos := doc.meta.text.leanPosToLspPos msg.pos\n        let endPos' := doc.meta.text.leanPosToLspPos endPos\n        pure { eager with\n          edit? := some <| .ofTextEdit params.textDocument.uri {\n            range := \u27e8pos, endPos'\u27e9\n            newText := toString c'\n          }\n        }\n    }]\n  return #[]", "start": [26, 1], "end": [69, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/RBMap/Basic.lean", "imports": ["lake-packages/std/Std/Classes/Order.lean", "lake-packages/std/Std/Control/ForInStep/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Logic.lean", "lake-packages/std/Std/Tactic/HaveI.lean"], "premises": [{"full_name": "Std.RBColor", "code": "inductive RBColor where\n  \n  | red\n  \n  | black\n  deriving Repr", "start": [26, 1], "end": [35, 16], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode", "code": "inductive RBNode (\u03b1 : Type u) where\n  \n  | nil\n  \n  | node (c : RBColor) (l : RBNode \u03b1) (v : \u03b1) (r : RBNode \u03b1)\n  deriving Repr", "start": [37, 1], "end": [51, 16], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.min", "code": "protected def min : RBNode \u03b1 \u2192 Option \u03b1\n  | nil            => none\n  | node _ nil v _ => some v\n  | node _ l _ _   => l.min", "start": [58, 1], "end": [62, 28], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.max", "code": "protected def max : RBNode \u03b1 \u2192 Option \u03b1\n  | nil            => none\n  | node _ _ v nil => some v\n  | node _ _ _ r   => r.max", "start": [64, 1], "end": [68, 28], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.fold", "code": "@[specialize] def fold (v\u2080 : \u03c3) (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3 \u2192 \u03c3) : RBNode \u03b1 \u2192 \u03c3\n  | nil          => v\u2080\n  | node _ l v r => f (l.fold v\u2080 f) v (r.fold v\u2080 f)", "start": [70, 1], "end": [76, 52], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.foldl", "code": "@[specialize] def foldl (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3) : (init : \u03c3) \u2192 RBNode \u03b1 \u2192 \u03c3\n  | b, nil          => b\n  | b, node _ l v r => foldl f (f (foldl f b l) v) r", "start": [78, 1], "end": [81, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.foldr", "code": "@[specialize] def foldr (f : \u03b1 \u2192 \u03c3 \u2192 \u03c3) : RBNode \u03b1 \u2192 (init : \u03c3) \u2192 \u03c3\n  | nil,          b => b\n  | node _ l v r, b => l.foldr f <| f v <| r.foldr f b", "start": [83, 1], "end": [86, 55], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.toList", "code": "def toList (t : RBNode \u03b1) : List \u03b1 := t.foldr (\u00b7::\u00b7) []", "start": [88, 1], "end": [89, 56], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.forM", "code": "@[specialize] def forM [Monad m] (f : \u03b1 \u2192 m PUnit) : RBNode \u03b1 \u2192 m PUnit\n  | nil          => pure \u27e8\u27e9\n  | node _ l v r => do forM f l; f v; forM f r", "start": [91, 1], "end": [94, 47], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.foldlM", "code": "@[specialize] def foldlM [Monad m] (f : \u03c3 \u2192 \u03b1 \u2192 m \u03c3) : (init : \u03c3) \u2192 RBNode \u03b1 \u2192 m \u03c3\n  | b, nil          => pure b\n  | b, node _ l v r => do foldlM f (\u2190 f (\u2190 foldlM f b l) v) r", "start": [96, 1], "end": [99, 62], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.forIn", "code": "@[inline] protected def forIn [Monad m]\n    (as : RBNode \u03b1) (init : \u03c3) (f : \u03b1 \u2192 \u03c3 \u2192 m (ForInStep \u03c3)) : m \u03c3 := do\n  ForInStep.run <$> visit as init\nwhere\n  \n  @[specialize] visit : RBNode \u03b1 \u2192 \u03c3 \u2192 m (ForInStep \u03c3)\n    | nil,          b => return ForInStep.yield b\n    | node _ l v r, b => ForInStep.bindM (visit l b) fun b => ForInStep.bindM (f v b) (visit r \u00b7)", "start": [101, 1], "end": [109, 98], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream", "code": "protected inductive Stream (\u03b1 : Type _)\n  | \n    nil\n  | \n    cons (v : \u03b1) (r : RBNode \u03b1) (tail : RBNode.Stream \u03b1)", "start": [114, 1], "end": [123, 57], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.toStream", "code": "def toStream : RBNode \u03b1 \u2192 (_ : RBNode.Stream \u03b1 := .nil) \u2192 RBNode.Stream \u03b1\n  | nil, acc => acc\n  | node _ l v r, acc => toStream l (.cons v r acc)", "start": [125, 1], "end": [128, 52], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.next?", "code": "def next? : RBNode.Stream \u03b1 \u2192 Option (\u03b1 \u00d7 RBNode.Stream \u03b1)\n  | nil => none\n  | cons v r tail => some (v, toStream r tail)", "start": [132, 1], "end": [135, 47], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.foldl", "code": "@[specialize] def foldl (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3) : (init : \u03c3) \u2192 RBNode.Stream \u03b1 \u2192 \u03c3\n  | b, nil           => b\n  | b, cons v r tail => foldl f (r.foldl f (f b v)) tail", "start": [137, 1], "end": [140, 57], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.foldr", "code": "@[specialize] def foldr (f : \u03b1 \u2192 \u03c3 \u2192 \u03c3) : RBNode.Stream \u03b1 \u2192 (init : \u03c3) \u2192 \u03c3\n  | nil,           b => b\n  | cons v r tail, b => f v <| r.foldr f <| tail.foldr f b", "start": [142, 1], "end": [145, 59], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.toList", "code": "def toList (t : RBNode.Stream \u03b1) : List \u03b1 := t.foldr (\u00b7::\u00b7) []", "start": [147, 1], "end": [148, 63], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.all", "code": "@[specialize] def all (p : \u03b1 \u2192 Bool) : RBNode \u03b1 \u2192 Bool\n  | nil          => true\n  | node _ l v r => p v && all p l && all p r", "start": [155, 1], "end": [158, 46], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.any", "code": "@[specialize] def any (p : \u03b1 \u2192 Bool) : RBNode \u03b1 \u2192 Bool\n  | nil          => false\n  | node _ l v r => p v || any p l || any p r", "start": [160, 1], "end": [163, 46], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All", "code": "def All (p : \u03b1 \u2192 Prop) : RBNode \u03b1 \u2192 Prop\n  | nil          => True\n  | node _ l v r => p v \u2227 All p l \u2227 All p r", "start": [165, 1], "end": [168, 44], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.imp", "code": "theorem All.imp (H : \u2200 {x : \u03b1}, p x \u2192 q x) : \u2200 {t : RBNode \u03b1}, t.All p \u2192 t.All q", "start": [170, 1], "end": [172, 60], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.all_iff", "code": "theorem all_iff {t : RBNode \u03b1} : t.all p \u2194 t.All (p \u00b7)", "start": [174, 1], "end": [175, 48], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Any", "code": "def Any (p : \u03b1 \u2192 Prop) : RBNode \u03b1 \u2192 Prop\n  | nil          => False\n  | node _ l v r => p v \u2228 Any p l \u2228 Any p r", "start": [180, 1], "end": [183, 44], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.any_iff", "code": "theorem any_iff {t : RBNode \u03b1} : t.any p \u2194 t.Any (p \u00b7)", "start": [185, 1], "end": [186, 47], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.EMem", "code": "def EMem (x : \u03b1) (t : RBNode \u03b1) : Prop := t.Any (x = \u00b7)", "start": [191, 1], "end": [192, 56], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.MemP", "code": "def MemP (cut : \u03b1 \u2192 Ordering) (t : RBNode \u03b1) : Prop := t.Any (cut \u00b7 = .eq)", "start": [196, 1], "end": [197, 75], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Mem", "code": "@[reducible] def Mem (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (x : \u03b1) (t : RBNode \u03b1) : Prop := MemP (cmp x) t", "start": [199, 1], "end": [200, 94], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Slow.instDecidableEMem", "code": "@[nolint docBlame] scoped instance Slow.instDecidableEMem [DecidableEq \u03b1] {t : RBNode \u03b1} :\n    Decidable (EMem x t) := inferInstanceAs (Decidable (Any ..))", "start": [205, 1], "end": [206, 65], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Slow.instDecidableMemP", "code": "@[nolint docBlame] scoped instance Slow.instDecidableMemP {t : RBNode \u03b1} :\n    Decidable (MemP cut t) := inferInstanceAs (Decidable (Any ..))", "start": [208, 1], "end": [209, 67], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Slow.instDecidableMem", "code": "@[nolint docBlame] scoped instance Slow.instDecidableMem {t : RBNode \u03b1} :\n    Decidable (Mem cmp x t) := inferInstanceAs (Decidable (Any ..))", "start": [211, 1], "end": [212, 68], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.all\u2082", "code": "@[specialize] def all\u2082 (R : \u03b1 \u2192 \u03b2 \u2192 Bool) (t\u2081 : RBNode \u03b1) (t\u2082 : RBNode \u03b2) : Bool :=\n  let result := StateT.run (s := t\u2082.toStream) <| t\u2081.forM fun a s => do\n    let (b, s) \u2190 s.next?\n    bif R a b then pure (\u27e8\u27e9, s) else none\n  result matches some (_, .nil)", "start": [214, 1], "end": [222, 32], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpLT", "code": "def cmpLT (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (x y : \u03b1) : Prop := Nonempty (\u2200 [TransCmp cmp], cmp x y = .lt)", "start": [227, 1], "end": [236, 98], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpLT_iff", "code": "theorem cmpLT_iff [TransCmp cmp] : cmpLT cmp x y \u2194 cmp x y = .lt", "start": [238, 1], "end": [238, 90], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpEq", "code": "def cmpEq (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (x y : \u03b1) : Prop := Nonempty (\u2200 [TransCmp cmp], cmp x y = .eq)", "start": [242, 1], "end": [243, 98], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpEq_iff", "code": "theorem cmpEq_iff [TransCmp cmp] : cmpEq cmp x y \u2194 cmp x y = .eq", "start": [245, 1], "end": [245, 90], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.isOrdered", "code": "def isOrdered (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering)\n    (t : RBNode \u03b1) (l : Option \u03b1 := none) (r : Option \u03b1 := none) : Bool :=\n  match t with\n  | nil =>\n    match l, r with\n    | some l, some r => cmp l r = .lt\n    | _, _ => true\n  | node _ a v b => isOrdered cmp a l v && isOrdered cmp b v r", "start": [249, 1], "end": [257, 63], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balance1", "code": "@[inline] def balance1 : RBNode \u03b1 \u2192 \u03b1 \u2192 RBNode \u03b1 \u2192 RBNode \u03b1\n  | node red (node red a x b) y c, z, d\n  | node red a x (node red b y c), z, d => node red (node black a x b) y (node black c z d)\n  | a,                             x, b => node black a x b", "start": [259, 1], "end": [263, 60], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balance2", "code": "@[inline] def balance2 : RBNode \u03b1 \u2192 \u03b1 \u2192 RBNode \u03b1 \u2192 RBNode \u03b1\n  | a, x, node red (node red b y c) z d\n  | a, x, node red b y (node red c z d) => node red (node black a x b) y (node black c z d)\n  | a, x, b                             => node black a x b", "start": [265, 1], "end": [269, 60], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.isRed", "code": "@[inline] def isRed : RBNode \u03b1 \u2192 RBColor\n  | node c .. => c\n  | _         => black", "start": [271, 1], "end": [274, 23], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.isBlack", "code": "@[inline] def isBlack : RBNode \u03b1 \u2192 RBColor\n  | node c .. => c\n  | _         => red", "start": [276, 1], "end": [282, 21], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.setBlack", "code": "def setBlack : RBNode \u03b1 \u2192 RBNode \u03b1\n  | nil          => nil\n  | node _ l v r => node black l v r", "start": [284, 1], "end": [287, 37], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.ins", "code": "@[specialize] def ins (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (x : \u03b1) : RBNode \u03b1 \u2192 RBNode \u03b1\n  | nil => node red nil x nil\n  | node red a y b =>\n    match cmp x y with\n    | Ordering.lt => node red (ins cmp x a) y b\n    | Ordering.gt => node red a y (ins cmp x b)\n    | Ordering.eq => node red a x b\n  | node black a y b =>\n    match cmp x y with\n    | Ordering.lt => balance1 (ins cmp x a) y b\n    | Ordering.gt => balance2 a y (ins cmp x b)\n    | Ordering.eq => node black a x b", "start": [291, 1], "end": [309, 38], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.insert", "code": "@[specialize] def insert (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (t : RBNode \u03b1) (v : \u03b1) : RBNode \u03b1 :=\n  match isRed t with\n  | red => (ins cmp v t).setBlack\n  | black => ins cmp v t", "start": [311, 1], "end": [318, 25], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.setRed", "code": "def setRed : RBNode \u03b1 \u2192 RBNode \u03b1\n  | node _ a v b => node red a v b\n  | nil          => nil", "start": [322, 1], "end": [325, 24], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balLeft", "code": "def balLeft (l : RBNode \u03b1) (v : \u03b1) (r : RBNode \u03b1) : RBNode \u03b1 :=\n  match l with\n  | node red a x b                    => node red (node black a x b) v r\n  | l => match r with\n    | node black a y b                => balance2 l v (node red a y b)\n    | node red (node black a y b) z c => node red (node black l v a) y (balance2 b z (setRed c))\n    | r                               => node red l v r", "start": [327, 1], "end": [334, 56], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balRight", "code": "def balRight (l : RBNode \u03b1) (v : \u03b1) (r : RBNode \u03b1) : RBNode \u03b1 :=\n  match r with\n  | node red b y c                    => node red l v (node black b y c)\n  | r => match l with\n    | node black a x b                => balance1 (node red a x b) v r\n    | node red a x (node black b y c) => node red (balance1 (setRed a) x b) y (node black c v r)\n    | l                               => node red l v r", "start": [336, 1], "end": [343, 56], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.size", "code": "@[simp] def size : RBNode \u03b1 \u2192 Nat\n  | nil => 0\n  | node _ x _ y => x.size + y.size + 1", "start": [345, 1], "end": [348, 40], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.append", "code": "def append : RBNode \u03b1 \u2192 RBNode \u03b1 \u2192 RBNode \u03b1\n  | nil, x | x, nil => x\n  | node red a x b, node red c y d =>\n    match append b c with\n    | node red b' z c' => node red (node red a x b') z (node red c' y d)\n    | bc               => node red a x (node red bc y d)\n  | node black a x b, node black c y d =>\n    match append b c with\n    | node red b' z c' => node red (node black a x b') z (node black c' y d)\n    | bc               => balLeft a x (node black bc y d)\n  | a@(node black ..), node red b x c => node red (append a b) x c\n  | node red a x b, c@(node black ..) => node red a x (append b c)\ntermination_by _ x y => x.size + y.size", "start": [350, 1], "end": [363, 40], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.del", "code": "@[specialize] def del (cut : \u03b1 \u2192 Ordering) : RBNode \u03b1 \u2192 RBNode \u03b1\n  | nil          => nil\n  | node _ a y b =>\n    match cut y with\n    | .lt => match a.isBlack with\n      | black => balLeft (del cut a) y b\n      | red => node red (del cut a) y b\n    | .gt => match b.isBlack with\n      | black => balRight a y (del cut b)\n      | red => node red a y (del cut b)\n    | .eq => append a b", "start": [367, 1], "end": [381, 24], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.erase", "code": "@[specialize] def erase (cut : \u03b1 \u2192 Ordering) (t : RBNode \u03b1) : RBNode \u03b1 := (del cut t).setBlack", "start": [383, 1], "end": [391, 95], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.find?", "code": "@[specialize] def find? (cut : \u03b1 \u2192 Ordering) : RBNode \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | node _ a y b =>\n    match cut y with\n    | .lt => find? cut a\n    | .gt => find? cut b\n    | .eq => some y", "start": [393, 1], "end": [400, 20], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.lowerBound?", "code": "@[specialize] def lowerBound? (cut : \u03b1 \u2192 Ordering) : RBNode \u03b1 \u2192 Option \u03b1 \u2192 Option \u03b1\n  | nil,          lb => lb\n  | node _ a y b, lb =>\n    match cut y with\n    | .lt => lowerBound? cut a lb\n    | .gt => lowerBound? cut b (some y)\n    | .eq => some y", "start": [402, 1], "end": [409, 20], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.root?", "code": "def root? : RBNode \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | node _ _ v _ => some v", "start": [411, 1], "end": [414, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.map", "code": "@[specialize] def map (f : \u03b1 \u2192 \u03b2) : RBNode \u03b1 \u2192 RBNode \u03b2\n  | nil => nil\n  | node c l v r => node c (l.map f) (f v) (r.map f)", "start": [416, 1], "end": [422, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.toArray", "code": "def toArray (n : RBNode \u03b1) : Array \u03b1 := n.foldl (init := #[]) (\u00b7.push \u00b7)", "start": [424, 1], "end": [425, 73], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path", "code": "inductive Path (\u03b1 : Type u) where\n  \n  | root\n  \n  | left (c : RBColor) (parent : Path \u03b1) (v : \u03b1) (r : RBNode \u03b1)\n  \n  | right (c : RBColor) (l : RBNode \u03b1) (v : \u03b1) (parent : Path \u03b1)", "start": [427, 1], "end": [439, 65], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.fill", "code": "def Path.fill : Path \u03b1 \u2192 RBNode \u03b1 \u2192 RBNode \u03b1\n  | .root, t => t\n  | .left c parent y b, a\n  | .right c a y parent, b => parent.fill (node c a y b)", "start": [441, 1], "end": [445, 57], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.zoom", "code": "@[specialize] def zoom (cut : \u03b1 \u2192 Ordering) : RBNode \u03b1 \u2192 (e : Path \u03b1 := .root) \u2192 RBNode \u03b1 \u00d7 Path \u03b1\n  | nil, path => (nil, path)\n  | n@(node c a y b), path =>\n    match cut y with\n    | .lt => zoom cut a (.left c path y b)\n    | .gt => zoom cut b (.right c a y path)\n    | .eq => (n, path)", "start": [447, 1], "end": [457, 23], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.ins", "code": "def Path.ins : Path \u03b1 \u2192 RBNode \u03b1 \u2192 RBNode \u03b1\n  | .root, t => t.setBlack\n  | .left red parent y b, a\n  | .right red a y parent, b => parent.ins (node red a y b)\n  | .left black parent y b, a => parent.ins (balance1 a y b)\n  | .right black a y parent, b => parent.ins (balance2 a y b)", "start": [459, 1], "end": [468, 62], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.insertNew", "code": "@[inline] def Path.insertNew (path : Path \u03b1) (v : \u03b1) : RBNode \u03b1 :=\n  path.ins (node red nil v nil)", "start": [470, 1], "end": [475, 32], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.insert", "code": "def Path.insert (path : Path \u03b1) (t : RBNode \u03b1) (v : \u03b1) : RBNode \u03b1 :=\n  match t with\n  | nil => path.insertNew v\n  | node c a _ b => path.fill (node c a v b)", "start": [477, 1], "end": [484, 45], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.del", "code": "def Path.del : Path \u03b1 \u2192 RBNode \u03b1 \u2192 RBColor \u2192 RBNode \u03b1\n  | .root, t, _ => t.setBlack\n  | .left c parent y b, a, red\n  | .right c a y parent, b, red => parent.del (node red a y b) c\n  | .left c parent y b, a, black => parent.del (balLeft a y b) c\n  | .right c a y parent, b, black => parent.del (balRight a y b) c", "start": [486, 1], "end": [497, 67], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.erase", "code": "def Path.erase (path : Path \u03b1) (t : RBNode \u03b1) : RBNode \u03b1 :=\n  match t with\n  | nil => path.fill nil\n  | node c a _ b => path.del (a.append b) c", "start": [499, 1], "end": [506, 44], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.modify", "code": "@[specialize] def modify (cut : \u03b1 \u2192 Ordering) (f : \u03b1 \u2192 \u03b1) (t : RBNode \u03b1) : RBNode \u03b1 :=\n  match zoom cut t with\n  | (nil, _) => t | (node c a x b, path) => path.fill (node c a (f x) b)", "start": [508, 1], "end": [520, 57], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.alter", "code": "@[specialize] def alter (cut : \u03b1 \u2192 Ordering) (f : Option \u03b1 \u2192 Option \u03b1) (t : RBNode \u03b1) : RBNode \u03b1 :=\n  match zoom cut t with\n  | (nil, path) =>\n    match f none with\n    | none => t | some y => path.insertNew y\n  | (node c a x b, path) =>\n    match f (some x) with\n    | none => path.del (a.append b) c\n    | some y => path.fill (node c a y b)", "start": [522, 1], "end": [539, 41], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered", "code": "def Ordered (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBNode \u03b1 \u2192 Prop\n  | nil => True\n  | node _ a x b => a.All (cmpLT cmp \u00b7 x) \u2227 b.All (cmpLT cmp x \u00b7) \u2227 a.Ordered cmp \u2227 b.Ordered cmp", "start": [541, 1], "end": [553, 98], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Slow.instDecidableOrdered", "code": "@[nolint docBlame] scoped instance Slow.instDecidableOrdered (cmp) [TransCmp cmp] :\n    \u2200 t : RBNode \u03b1, Decidable (Ordered cmp t)\n  | nil => inferInstanceAs (Decidable True)\n  | node _ a _ b =>\n    haveI := instDecidableOrdered cmp a\n    haveI := instDecidableOrdered cmp b\n    inferInstanceAs (Decidable (And ..))", "start": [557, 1], "end": [563, 41], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced", "code": "inductive Balanced : RBNode \u03b1 \u2192 RBColor \u2192 Nat \u2192 Prop where\n  \n  | protected nil : Balanced nil black 0\n  \n  | protected red : Balanced x black n \u2192 Balanced y black n \u2192 Balanced (node red x v y) red n\n  \n  | protected black : Balanced x c\u2081 n \u2192 Balanced y c\u2082 n \u2192 Balanced (node black x v y) black (n + 1)", "start": [565, 1], "end": [578, 100], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.WF", "code": "inductive WF (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBNode \u03b1 \u2192 Prop\n  \n  | mk : t.Ordered cmp \u2192 t.Balanced c n \u2192 WF cmp t\n  \n  | insert : WF cmp t \u2192 WF cmp (t.insert cmp a)\n  \n  | erase : WF cmp t \u2192 WF cmp (t.erase cut)", "start": [580, 1], "end": [594, 44], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet", "code": "def RBSet (\u03b1 : Type u) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : Type u := {t : RBNode \u03b1 // t.WF cmp}", "start": [600, 1], "end": [605, 87], "kind": "commanddeclaration"}, {"full_name": "Std.mkRBSet", "code": "@[inline] def mkRBSet (\u03b1 : Type u) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBSet \u03b1 cmp := \u27e8.nil, .mk \u27e8\u27e9 .nil\u27e9", "start": [607, 1], "end": [608, 97], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.empty", "code": "@[inline] def empty : RBSet \u03b1 cmp := mkRBSet ..", "start": [612, 1], "end": [613, 48], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.single", "code": "@[inline] def single (v : \u03b1) : RBSet \u03b1 cmp :=\n  \u27e8.node .red .nil v .nil, .mk \u27e8\u27e8\u27e9, \u27e8\u27e9, \u27e8\u27e9, \u27e8\u27e9\u27e9 (.red .nil .nil)\u27e9", "start": [619, 1], "end": [621, 66], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.foldl", "code": "@[inline] def foldl (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3) (init : \u03c3) (t : RBSet \u03b1 cmp) : \u03c3 := t.1.foldl f init", "start": [623, 1], "end": [624, 89], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.foldr", "code": "@[inline] def foldr (f : \u03b1 \u2192 \u03c3 \u2192 \u03c3) (init : \u03c3) (t : RBSet \u03b1 cmp) : \u03c3 := t.1.foldr f init", "start": [626, 1], "end": [627, 89], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.foldlM", "code": "@[inline] def foldlM [Monad m] (f : \u03c3 \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3) (t : RBSet \u03b1 cmp) : m \u03c3 :=\n  t.1.foldlM f init", "start": [629, 1], "end": [631, 20], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.forM", "code": "@[inline] def forM [Monad m] (f : \u03b1 \u2192 m PUnit) (t : RBSet \u03b1 cmp) : m PUnit := t.1.forM f", "start": [633, 1], "end": [634, 89], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.isEmpty", "code": "@[inline] def isEmpty : RBSet \u03b1 cmp \u2192 Bool\n  | \u27e8nil, _\u27e9 => true\n  | _        => false", "start": [641, 1], "end": [644, 22], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.toList", "code": "@[inline] def toList (t : RBSet \u03b1 cmp) : List \u03b1 := t.1.toList", "start": [646, 1], "end": [647, 62], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.min", "code": "@[inline] protected def min (t : RBSet \u03b1 cmp) : Option \u03b1 := t.1.min", "start": [649, 1], "end": [650, 68], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.max", "code": "@[inline] protected def max (t : RBSet \u03b1 cmp) : Option \u03b1 := t.1.max", "start": [652, 1], "end": [653, 68], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.insert", "code": "@[inline] def insert (t : RBSet \u03b1 cmp) (v : \u03b1) : RBSet \u03b1 cmp := \u27e8t.1.insert cmp v, t.2.insert\u27e9", "start": [658, 1], "end": [659, 95], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.erase", "code": "@[inline] def erase (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) : RBSet \u03b1 cmp :=\n  \u27e8t.1.erase cut, t.2.erase\u27e9", "start": [661, 1], "end": [670, 29], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.findP?", "code": "@[inline] def findP? (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) : Option \u03b1 := t.1.find? cut", "start": [672, 1], "end": [673, 88], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find?", "code": "@[inline] def find? (t : RBSet \u03b1 cmp) (x : \u03b1) : Option \u03b1 := t.1.find? (cmp x)", "start": [675, 1], "end": [676, 78], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.findPD", "code": "@[inline] def findPD (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) (v\u2080 : \u03b1) : \u03b1 := (t.findP? cut).getD v\u2080", "start": [678, 1], "end": [679, 99], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.lowerBoundP?", "code": "@[inline] def lowerBoundP? (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) : Option \u03b1 :=\n  t.1.lowerBound? cut none", "start": [681, 1], "end": [686, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.lowerBound?", "code": "@[inline] def lowerBound? (t : RBSet \u03b1 cmp) (k : \u03b1) : Option \u03b1 := t.1.lowerBound? (cmp k) none", "start": [688, 1], "end": [692, 95], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.containsP", "code": "@[inline] def containsP (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) : Bool := (t.findP? cut).isSome", "start": [694, 1], "end": [695, 95], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.contains", "code": "@[inline] def contains (t : RBSet \u03b1 cmp) (a : \u03b1) : Bool := (t.find? a).isSome", "start": [697, 1], "end": [698, 78], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.ofList", "code": "@[inline] def ofList (l : List \u03b1) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBSet \u03b1 cmp :=\n  l.foldl (fun r p => r.insert p) (mkRBSet \u03b1 cmp)", "start": [700, 1], "end": [702, 50], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.ofArray", "code": "@[inline] def ofArray (l : Array \u03b1) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBSet \u03b1 cmp :=\n  l.foldl (fun r p => r.insert p) (mkRBSet \u03b1 cmp)", "start": [704, 1], "end": [706, 50], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.all", "code": "@[inline] def all (t : RBSet \u03b1 cmp) (p : \u03b1 \u2192 Bool) : Bool := t.1.all p", "start": [708, 1], "end": [709, 71], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.any", "code": "@[inline] def any (t : RBSet \u03b1 cmp) (p : \u03b1 \u2192 Bool) : Bool := t.1.any p", "start": [711, 1], "end": [712, 71], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.all\u2082", "code": "@[inline] def all\u2082 (R : \u03b1 \u2192 \u03b2 \u2192 Bool) (t\u2081 : RBSet \u03b1 cmp\u03b1) (t\u2082 : RBSet \u03b2 cmp\u03b2) : Bool :=\n  t\u2081.1.all\u2082 R t\u2082.1", "start": [714, 1], "end": [719, 19], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.EMem", "code": "def EMem (x : \u03b1) (t : RBSet \u03b1 cmp) : Prop := t.1.EMem x", "start": [721, 1], "end": [722, 56], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.MemP", "code": "def MemP (cut : \u03b1 \u2192 Ordering) (t : RBSet \u03b1 cmp) : Prop := t.1.MemP cut", "start": [724, 1], "end": [725, 71], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.Mem", "code": "def Mem (x : \u03b1) (t : RBSet \u03b1 cmp) : Prop := MemP (cmp x) t", "start": [727, 1], "end": [728, 59], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.Slow.instDecidableEMem", "code": "@[nolint docBlame] scoped instance Slow.instDecidableEMem [DecidableEq \u03b1] {t : RBSet \u03b1 cmp} :\n    Decidable (EMem x t) := inferInstanceAs (Decidable (Any ..))", "start": [735, 1], "end": [736, 65], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.Slow.instDecidableMemP", "code": "@[nolint docBlame] scoped instance Slow.instDecidableMemP {t : RBSet \u03b1 cmp} :\n    Decidable (MemP cut t) := inferInstanceAs (Decidable (Any ..))", "start": [738, 1], "end": [739, 67], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.Slow.instDecidableMem", "code": "@[nolint docBlame] scoped instance Slow.instDecidableMem {t : RBSet \u03b1 cmp} :\n    Decidable (Mem x t) := inferInstanceAs (Decidable (Any ..))", "start": [741, 1], "end": [742, 64], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.size", "code": "def size (m : RBSet \u03b1 cmp) : Nat := m.1.size", "start": [751, 1], "end": [752, 45], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.min!", "code": "@[inline] def min! [Inhabited \u03b1] (t : RBSet \u03b1 cmp) : \u03b1 := t.min.getD (panic! \"tree is empty\")", "start": [754, 1], "end": [755, 94], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.max!", "code": "@[inline] def max! [Inhabited \u03b1] (t : RBSet \u03b1 cmp) : \u03b1 := t.max.getD (panic! \"tree is empty\")", "start": [757, 1], "end": [758, 94], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.findP!", "code": "@[inline] def findP! [Inhabited \u03b1] (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) : \u03b1 :=\n  (t.findP? cut).getD (panic! \"key is not in the tree\")", "start": [760, 1], "end": [764, 56], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find!", "code": "@[inline] def find! [Inhabited \u03b1] (t : RBSet \u03b1 cmp) (k : \u03b1) : \u03b1 :=\n  (t.find? k).getD (panic! \"key is not in the tree\")", "start": [766, 1], "end": [770, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.ModifyWF", "code": "class ModifyWF (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) (f : \u03b1 \u2192 \u03b1) : Prop where\n  \n  wf : (t.1.modify cut f).WF cmp", "start": [772, 1], "end": [775, 33], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.modifyP", "code": "def modifyP (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) (f : \u03b1 \u2192 \u03b1)\n    [wf : ModifyWF t cut f] : RBSet \u03b1 cmp := \u27e8t.1.modify cut f, wf.wf\u27e9", "start": [777, 1], "end": [786, 71], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.AlterWF", "code": "class AlterWF (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) (f : Option \u03b1 \u2192 Option \u03b1) : Prop where\n  \n  wf : (t.1.alter cut f).WF cmp", "start": [788, 1], "end": [791, 32], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.alterP", "code": "def alterP (t : RBSet \u03b1 cmp) (cut : \u03b1 \u2192 Ordering) (f : Option \u03b1 \u2192 Option \u03b1)\n    [wf : AlterWF t cut f] : RBSet \u03b1 cmp := \u27e8t.1.alter cut f, wf.wf\u27e9", "start": [793, 1], "end": [805, 69], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.union", "code": "def union (t\u2081 t\u2082 : RBSet \u03b1 cmp) : RBSet \u03b1 cmp :=\n  t\u2082.foldl .insert t\u2081", "start": [807, 1], "end": [812, 22], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mergeWith", "code": "def mergeWith (mergeFn : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (t\u2081 t\u2082 : RBSet \u03b1 cmp) : RBSet \u03b1 cmp :=\n  t\u2082.foldl (init := t\u2081) fun t\u2081 a\u2082 =>\n    t\u2081.insert <| match t\u2081.find? a\u2082 with | some a\u2081 => mergeFn a\u2081 a\u2082 | none => a\u2082", "start": [814, 1], "end": [820, 80], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.intersectWith", "code": "def intersectWith (cmp : \u03b1 \u2192 \u03b2 \u2192 Ordering) (mergeFn : \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n    (t\u2081 : RBSet \u03b1 cmp\u03b1) (t\u2082 : RBSet \u03b2 cmp\u03b2) : RBSet \u03b3 cmp\u03b3 :=\n  t\u2081.foldl (init := \u2205) fun acc a =>\n    match t\u2082.findP? (cmp a) with\n    | some b => acc.insert <| mergeFn a b\n    | none => acc", "start": [822, 1], "end": [831, 18], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.filter", "code": "def filter (t : RBSet \u03b1 cmp) (p : \u03b1 \u2192 Bool) : RBSet \u03b1 cmp :=\n  t.foldl (init := \u2205) fun acc a => bif p a then acc.insert a else acc", "start": [833, 1], "end": [835, 70], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.sdiff", "code": "def sdiff (t\u2081 t\u2082 : RBSet \u03b1 cmp) : RBSet \u03b1 cmp := t\u2081.filter (!t\u2082.contains \u00b7)", "start": [837, 1], "end": [840, 76], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap", "code": "def RBMap (\u03b1 : Type u) (\u03b2 : Type v) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : Type (max u v) :=\n  RBSet (\u03b1 \u00d7 \u03b2) (byKey Prod.fst cmp)", "start": [846, 1], "end": [852, 37], "kind": "commanddeclaration"}, {"full_name": "Std.mkRBMap", "code": "@[inline] def mkRBMap (\u03b1 : Type u) (\u03b2 : Type v) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBMap \u03b1 \u03b2 cmp :=\n  mkRBSet ..", "start": [854, 1], "end": [856, 13], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.empty", "code": "@[inline] def RBMap.empty {\u03b1 : Type u} {\u03b2 : Type v} {cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering} : RBMap \u03b1 \u03b2 cmp :=\n  mkRBMap ..", "start": [858, 1], "end": [860, 13], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.single", "code": "@[inline] def RBMap.single (k : \u03b1) (v : \u03b2) : RBMap \u03b1 \u03b2 cmp := RBSet.single (k, v)", "start": [867, 1], "end": [868, 82], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.foldl", "code": "@[inline] def foldl (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03c3) : (init : \u03c3) \u2192 RBMap \u03b1 \u03b2 cmp \u2192 \u03c3\n  | b, \u27e8t, _\u27e9 => t.foldl (fun s (a, b) => f s a b) b", "start": [873, 1], "end": [875, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.foldr", "code": "@[inline] def foldr (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3) : (init : \u03c3) \u2192 RBMap \u03b1 \u03b2 cmp \u2192 \u03c3\n  | b, \u27e8t, _\u27e9 => t.foldr (fun (a, b) s => f a b s) b", "start": [877, 1], "end": [879, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.foldlM", "code": "@[inline] def foldlM [Monad m] (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03c3) : (init : \u03c3) \u2192 RBMap \u03b1 \u03b2 cmp \u2192 m \u03c3\n  | b, \u27e8t, _\u27e9 => t.foldlM (fun s (a, b) => f s a b) b", "start": [881, 1], "end": [883, 54], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.forM", "code": "@[inline] def forM [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) (t : RBMap \u03b1 \u03b2 cmp) : m PUnit :=\n  t.foldlM (fun _ k v => f k v) \u27e8\u27e9", "start": [885, 1], "end": [887, 35], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.keysArray", "code": "@[inline] def keysArray (t : RBMap \u03b1 \u03b2 cmp) : Array \u03b1 :=\n  t.1.foldl (init := #[]) (\u00b7.push \u00b7.1)", "start": [894, 1], "end": [896, 39], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.keysList", "code": "@[inline] def keysList (t : RBMap \u03b1 \u03b2 cmp) : List \u03b1 :=\n  t.1.foldr (init := []) (\u00b7.1 :: \u00b7)", "start": [898, 1], "end": [900, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Keys", "code": "def Keys (\u03b1 \u03b2 cmp) := RBMap \u03b1 \u03b2 cmp", "start": [902, 1], "end": [906, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.keys", "code": "@[inline] def keys (t : RBMap \u03b1 \u03b2 cmp) : Keys \u03b1 \u03b2 cmp := t", "start": [908, 1], "end": [912, 59], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Keys.toArray", "code": "@[inline, inherit_doc keysArray] def Keys.toArray := @keysArray", "start": [914, 1], "end": [914, 64], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Keys.toList", "code": "@[inline, inherit_doc keysList] def Keys.toList := @keysList", "start": [916, 1], "end": [916, 61], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Keys.Stream", "code": "def Keys.Stream (\u03b1 \u03b2) := RBNode.Stream (\u03b1 \u00d7 \u03b2)", "start": [928, 1], "end": [929, 47], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Keys.toStream", "code": "def Keys.toStream (t : Keys \u03b1 \u03b2 cmp) : Keys.Stream \u03b1 \u03b2 := t.1.toStream", "start": [931, 1], "end": [932, 71], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Keys.Stream.next?", "code": "def Keys.Stream.next? (t : Stream \u03b1 \u03b2) : Option (\u03b1 \u00d7 Stream \u03b1 \u03b2) :=\n  match inline (RBNode.Stream.next? t) with\n  | none => none\n  | some ((a, _), t) => some (a, t)", "start": [934, 1], "end": [938, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.valuesArray", "code": "@[inline] def valuesArray (t : RBMap \u03b1 \u03b2 cmp) : Array \u03b2 :=\n  t.1.foldl (init := #[]) (\u00b7.push \u00b7.2)", "start": [943, 1], "end": [945, 39], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.valuesList", "code": "@[inline] def valuesList (t : RBMap \u03b1 \u03b2 cmp) : List \u03b2 :=\n  t.1.foldr (init := []) (\u00b7.2 :: \u00b7)", "start": [947, 1], "end": [949, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Values", "code": "def Values (\u03b1 \u03b2 cmp) := RBMap \u03b1 \u03b2 cmp", "start": [951, 1], "end": [955, 38], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.values", "code": "@[inline] def values (t : RBMap \u03b1 \u03b2 cmp) : Values \u03b1 \u03b2 cmp := t", "start": [957, 1], "end": [961, 63], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Values.toArray", "code": "@[inline, inherit_doc valuesArray] def Values.toArray := @valuesArray", "start": [963, 1], "end": [963, 70], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Values.toList", "code": "@[inline, inherit_doc valuesList] def Values.toList := @valuesList", "start": [965, 1], "end": [965, 67], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Values.Stream", "code": "def Values.Stream (\u03b1 \u03b2) := RBNode.Stream (\u03b1 \u00d7 \u03b2)", "start": [977, 1], "end": [978, 49], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Values.toStream", "code": "def Values.toStream (t : Values \u03b1 \u03b2 cmp) : Values.Stream \u03b1 \u03b2 := t.1.toStream", "start": [980, 1], "end": [981, 77], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Values.Stream.next?", "code": "def Values.Stream.next? (t : Stream \u03b1 \u03b2) : Option (\u03b2 \u00d7 Stream \u03b1 \u03b2) :=\n  match inline (RBNode.Stream.next? t) with\n  | none => none\n  | some ((_, b), t) => some (b, t)", "start": [983, 1], "end": [987, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.isEmpty", "code": "@[inline] def isEmpty : RBMap \u03b1 \u03b2 cmp \u2192 Bool := RBSet.isEmpty", "start": [992, 1], "end": [993, 62], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.toList", "code": "@[inline] def toList : RBMap \u03b1 \u03b2 cmp \u2192 List (\u03b1 \u00d7 \u03b2) := RBSet.toList", "start": [995, 1], "end": [996, 68], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.min", "code": "@[inline] protected def min : RBMap \u03b1 \u03b2 cmp \u2192 Option (\u03b1 \u00d7 \u03b2) := RBSet.min", "start": [998, 1], "end": [999, 74], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.max", "code": "@[inline] protected def max : RBMap \u03b1 \u03b2 cmp \u2192 Option (\u03b1 \u00d7 \u03b2) := RBSet.max", "start": [1001, 1], "end": [1002, 74], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.insert", "code": "@[inline] def insert (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) (v : \u03b2) : RBMap \u03b1 \u03b2 cmp := RBSet.insert t (k, v)", "start": [1007, 1], "end": [1008, 98], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.erase", "code": "@[inline] def erase (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) : RBMap \u03b1 \u03b2 cmp := RBSet.erase t (cmp k \u00b7.1)", "start": [1010, 1], "end": [1011, 93], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.ofList", "code": "@[inline] def ofList (l : List (\u03b1 \u00d7 \u03b2)) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBMap \u03b1 \u03b2 cmp :=\n  RBSet.ofList l _", "start": [1013, 1], "end": [1015, 19], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.ofArray", "code": "@[inline] def ofArray (l : Array (\u03b1 \u00d7 \u03b2)) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBMap \u03b1 \u03b2 cmp :=\n  RBSet.ofArray l _", "start": [1017, 1], "end": [1019, 20], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.findEntry?", "code": "@[inline] def findEntry? (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) : Option (\u03b1 \u00d7 \u03b2) := t.findP? (cmp k \u00b7.1)", "start": [1021, 1], "end": [1022, 94], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.find?", "code": "@[inline] def find? (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) : Option \u03b2 := t.findEntry? k |>.map (\u00b7.2)", "start": [1024, 1], "end": [1025, 90], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.findD", "code": "@[inline] def findD (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) (v\u2080 : \u03b2) : \u03b2 := (t.find? k).getD v\u2080", "start": [1027, 1], "end": [1028, 84], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.lowerBound?", "code": "@[inline] def lowerBound? (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) : Option (\u03b1 \u00d7 \u03b2) :=\n   RBSet.lowerBoundP? t (cmp k \u00b7.1)", "start": [1030, 1], "end": [1035, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.contains", "code": "@[inline] def contains (t : RBMap \u03b1 \u03b2 cmp) (a : \u03b1) : Bool := (t.findEntry? a).isSome", "start": [1037, 1], "end": [1038, 85], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.all", "code": "@[inline] def all (t : RBMap \u03b1 \u03b2 cmp) (p : \u03b1 \u2192 \u03b2 \u2192 Bool) : Bool := RBSet.all t fun (a, b) => p a b", "start": [1040, 1], "end": [1041, 99], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.any", "code": "@[inline] def any (t : RBMap \u03b1 \u03b2 cmp) (p : \u03b1 \u2192 \u03b2 \u2192 Bool) : Bool := RBSet.any t fun (a, b) => p a b", "start": [1043, 1], "end": [1044, 99], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.all\u2082", "code": "@[inline] def all\u2082 (R : \u03b1 \u00d7 \u03b2 \u2192 \u03b3 \u00d7 \u03b4 \u2192 Bool) (t\u2081 : RBMap \u03b1 \u03b2 cmp\u03b1) (t\u2082 : RBMap \u03b3 \u03b4 cmp\u03b3) : Bool :=\n  RBSet.all\u2082 R t\u2081 t\u2082", "start": [1046, 1], "end": [1051, 21], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.eqKeys", "code": "@[inline] def eqKeys (t\u2081 : RBMap \u03b1 \u03b2 cmp) (t\u2082 : RBMap \u03b1 \u03b3 cmp) : Bool :=\n  t\u2081.all\u2082 (cmp \u00b7.1 \u00b7.1 = .eq) t\u2082", "start": [1053, 1], "end": [1055, 33], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.size", "code": "def size : RBMap \u03b1 \u03b2 cmp \u2192 Nat := RBSet.size", "start": [1063, 1], "end": [1064, 45], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.min!", "code": "@[inline] def min! [Inhabited \u03b1] [Inhabited \u03b2] : RBMap \u03b1 \u03b2 cmp \u2192 \u03b1 \u00d7 \u03b2 := RBSet.min!", "start": [1066, 1], "end": [1067, 85], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.max!", "code": "@[inline] def max! [Inhabited \u03b1] [Inhabited \u03b2] : RBMap \u03b1 \u03b2 cmp \u2192 \u03b1 \u00d7 \u03b2 := RBSet.max!", "start": [1069, 1], "end": [1070, 85], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.find!", "code": "@[inline] def find! [Inhabited \u03b2] (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) : \u03b2 :=\n  (t.find? k).getD (panic! \"key is not in the map\")", "start": [1072, 1], "end": [1074, 52], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.mergeWith", "code": "def mergeWith (mergeFn : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2) (t\u2081 t\u2082 : RBMap \u03b1 \u03b2 cmp) : RBMap \u03b1 \u03b2 cmp :=\n  RBSet.mergeWith (fun (_, b\u2081) (a, b\u2082) => (a, mergeFn a b\u2081 b\u2082)) t\u2081 t\u2082", "start": [1076, 1], "end": [1081, 70], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.intersectWith", "code": "def intersectWith (mergeFn : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4)\n    (t\u2081 : RBMap \u03b1 \u03b2 cmp) (t\u2082 : RBMap \u03b1 \u03b3 cmp) : RBMap \u03b1 \u03b4 cmp :=\n  RBSet.intersectWith (cmp \u00b7.1 \u00b7.1) (fun (a, b\u2081) (_, b\u2082) => (a, mergeFn a b\u2081 b\u2082)) t\u2081 t\u2082", "start": [1083, 1], "end": [1089, 88], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.filter", "code": "def filter (t : RBMap \u03b1 \u03b2 cmp) (p : \u03b1 \u2192 \u03b2 \u2192 Bool) : RBMap \u03b1 \u03b2 cmp :=\n  RBSet.filter t fun (a, b) => p a b", "start": [1091, 1], "end": [1093, 37], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.sdiff", "code": "def sdiff (t\u2081 t\u2082 : RBMap \u03b1 \u03b2 cmp) : RBMap \u03b1 \u03b2 cmp := t\u2081.filter fun a _ => !t\u2082.contains a", "start": [1095, 1], "end": [1098, 89], "kind": "commanddeclaration"}, {"full_name": "List.toRBMap", "code": "@[inherit_doc RBMap.ofList]\nabbrev List.toRBMap (l : List (\u03b1 \u00d7 \u03b2)) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBMap \u03b1 \u03b2 cmp :=\n  RBMap.ofList l cmp", "start": [1104, 1], "end": [1106, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Int/DivMod.lean", "imports": ["lake-packages/std/Std/Data/Int/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.ofNat_div", "code": "theorem ofNat_div (m n : Nat) : \u2191(m / n) = div \u2191m \u2191n", "start": [19, 1], "end": [19, 60], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_fdiv", "code": "theorem ofNat_fdiv : \u2200 m n : Nat, \u2191(m / n) = fdiv \u2191m \u2191n", "start": [21, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_ediv", "code": "@[simp, norm_cast] theorem ofNat_ediv (m n : Nat) : (\u2191(m / n) : Int) = \u2191m / \u2191n", "start": [25, 1], "end": [25, 86], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_ediv", "code": "theorem negSucc_ediv (m : Nat) {b : Int} (H : 0 < b) : -[m+1] / b = -(div m b + 1)", "start": [27, 1], "end": [29, 23], "kind": "commanddeclaration"}, {"full_name": "Int.zero_div", "code": "@[simp] protected theorem zero_div : \u2200 b : Int, div 0 b = 0", "start": [31, 1], "end": [33, 40], "kind": "commanddeclaration"}, {"full_name": "Int.zero_ediv", "code": "@[local simp] theorem zero_ediv : \u2200 b : Int, 0 / b = 0", "start": [35, 1], "end": [37, 40], "kind": "commanddeclaration"}, {"full_name": "Int.zero_fdiv", "code": "@[simp] theorem zero_fdiv (b : Int) : fdiv 0 b = 0", "start": [39, 1], "end": [39, 73], "kind": "commanddeclaration"}, {"full_name": "Int.div_zero", "code": "@[simp] protected theorem div_zero : \u2200 a : Int, div a 0 = 0", "start": [41, 1], "end": [43, 18], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_zero", "code": "@[local simp] protected theorem ediv_zero : \u2200 a : Int, a / 0 = 0", "start": [46, 1], "end": [48, 18], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_zero", "code": "@[simp] protected theorem fdiv_zero : \u2200 a : Int, fdiv a 0 = 0", "start": [50, 1], "end": [53, 18], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_eq_ediv", "code": "theorem fdiv_eq_ediv : \u2200 (a : Int) {b : Int}, 0 \u2264 b \u2192 fdiv a b = a / b", "start": [55, 1], "end": [57, 50], "kind": "commanddeclaration"}, {"full_name": "Int.div_eq_ediv", "code": "theorem div_eq_ediv : \u2200 {a b : Int}, 0 \u2264 a \u2192 0 \u2264 b \u2192 a.div b = a / b", "start": [59, 1], "end": [61, 32], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_eq_div", "code": "theorem fdiv_eq_div {a b : Int} (Ha : 0 \u2264 a) (Hb : 0 \u2264 b) : fdiv a b = div a b", "start": [63, 1], "end": [64, 40], "kind": "commanddeclaration"}, {"full_name": "Int.div_neg", "code": "@[simp] protected theorem div_neg : \u2200 a b : Int, a.div (-b) = -(a.div b)", "start": [66, 1], "end": [69, 56], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_neg", "code": "@[simp] protected theorem ediv_neg : \u2200 a b : Int, a / (-b) = -(a / b)", "start": [71, 1], "end": [74, 73], "kind": "commanddeclaration"}, {"full_name": "Int.div_def", "code": "protected theorem div_def (a b : Int) : a / b = Int.ediv a b", "start": [76, 1], "end": [76, 68], "kind": "commanddeclaration"}, {"full_name": "Int.div_def'", "code": "@[simp] theorem div_def' (a b : Int) :\n    @HDiv.hDiv Int Int Int (@instHDiv Int Int.instDivInt) a b = Int.div a b", "start": [81, 1], "end": [82, 83], "kind": "commanddeclaration"}, {"full_name": "Int.neg_div", "code": "@[simp] protected theorem neg_div : \u2200 a b : Int, (-a).div b = -(a.div b)", "start": [84, 1], "end": [87, 60], "kind": "commanddeclaration"}, {"full_name": "Int.neg_div_neg", "code": "protected theorem neg_div_neg (a b : Int) : (-a).div (-b) = a.div b", "start": [89, 1], "end": [90, 47], "kind": "commanddeclaration"}, {"full_name": "Int.div_nonneg", "code": "protected theorem div_nonneg {a b : Int} (Ha : 0 \u2264 a) (Hb : 0 \u2264 b) : 0 \u2264 a.div b", "start": [92, 1], "end": [94, 48], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_nonneg", "code": "theorem fdiv_nonneg {a b : Int} (Ha : 0 \u2264 a) (Hb : 0 \u2264 b) : 0 \u2264 a.fdiv b", "start": [96, 1], "end": [98, 64], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_nonneg", "code": "theorem ediv_nonneg {a b : Int} (Ha : 0 \u2264 a) (Hb : 0 \u2264 b) : 0 \u2264 a / b", "start": [100, 1], "end": [102, 48], "kind": "commanddeclaration"}, {"full_name": "Int.div_nonpos", "code": "protected theorem div_nonpos {a b : Int} (Ha : 0 \u2264 a) (Hb : b \u2264 0) : a.div b \u2264 0", "start": [104, 1], "end": [105, 95], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_nonpos", "code": "theorem fdiv_nonpos : \u2200 {a b : Int}, 0 \u2264 a \u2192 b \u2264 0 \u2192 a.fdiv b \u2264 0", "start": [107, 1], "end": [108, 81], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_nonpos", "code": "theorem ediv_nonpos {a b : Int} (Ha : 0 \u2264 a) (Hb : b \u2264 0) : a / b \u2264 0", "start": [110, 1], "end": [111, 97], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_neg'", "code": "theorem fdiv_neg' : \u2200 {a b : Int}, a < 0 \u2192 0 < b \u2192 a.fdiv b < 0", "start": [113, 1], "end": [114, 46], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_neg'", "code": "theorem ediv_neg' {a b : Int} (Ha : a < 0) (Hb : 0 < b) : a / b < 0", "start": [116, 1], "end": [118, 50], "kind": "commanddeclaration"}, {"full_name": "Int.div_one", "code": "@[simp] protected theorem div_one : \u2200 a : Int, a.div 1 = a", "start": [120, 1], "end": [122, 48], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_one", "code": "@[simp] theorem fdiv_one : \u2200 a : Int, a.fdiv 1 = a", "start": [124, 1], "end": [127, 47], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_one", "code": "@[simp] theorem ediv_one : \u2200 a : Int, a / 1 = a", "start": [129, 1], "end": [131, 48], "kind": "commanddeclaration"}, {"full_name": "Int.div_eq_zero_of_lt", "code": "theorem div_eq_zero_of_lt {a b : Int} (H1 : 0 \u2264 a) (H2 : a < b) : a.div b = 0", "start": [133, 1], "end": [135, 87], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_eq_zero_of_lt", "code": "theorem ediv_eq_zero_of_lt {a b : Int} (H1 : 0 \u2264 a) (H2 : a < b) : a / b = 0", "start": [137, 1], "end": [139, 87], "kind": "commanddeclaration"}, {"full_name": "Int.add_mul_ediv_right", "code": "theorem add_mul_ediv_right (a b : Int) {c : Int} (H : c \u2260 0) : (a + b * c) / c = a / c + b", "start": [141, 1], "end": [170, 61], "kind": "commanddeclaration"}, {"full_name": "Int.add_mul_ediv_left", "code": "theorem add_mul_ediv_left (a : Int) {b : Int}\n    (c : Int) (H : b \u2260 0) : (a + b * c) / b = a / b + c", "start": [172, 1], "end": [174, 49], "kind": "commanddeclaration"}, {"full_name": "Int.add_ediv_of_dvd_right", "code": "theorem add_ediv_of_dvd_right {a b c : Int} (H : c \u2223 b) : (a + b) / c = a / c + b / c", "start": [176, 1], "end": [180, 89], "kind": "commanddeclaration"}, {"full_name": "Int.add_ediv_of_dvd_left", "code": "theorem add_ediv_of_dvd_left {a b c : Int} (H : c \u2223 a) : (a + b) / c = a / c + b / c", "start": [182, 1], "end": [183, 63], "kind": "commanddeclaration"}, {"full_name": "Int.mul_ediv_cancel", "code": "@[simp] theorem mul_ediv_cancel (a : Int) {b : Int} (H : b \u2260 0) : (a * b) / b = a", "start": [185, 1], "end": [187, 58], "kind": "commanddeclaration"}, {"full_name": "Int.mul_fdiv_cancel", "code": "@[simp] theorem mul_fdiv_cancel (a : Int) {b : Int} (H : b \u2260 0) : fdiv (a * b) b = a", "start": [189, 1], "end": [198, 23], "kind": "commanddeclaration"}, {"full_name": "Int.mul_div_cancel", "code": "@[simp] protected theorem mul_div_cancel (a : Int) {b : Int} (H : b \u2260 0) : (a * b).div b = a", "start": [200, 1], "end": [211, 66], "kind": "commanddeclaration"}, {"full_name": "Int.mul_div_cancel_left", "code": "@[simp] protected theorem mul_div_cancel_left (b : Int) (H : a \u2260 0) : (a * b).div a = b", "start": [213, 1], "end": [214, 43], "kind": "commanddeclaration"}, {"full_name": "Int.mul_fdiv_cancel_left", "code": "@[simp] theorem mul_fdiv_cancel_left (b : Int) (H : a \u2260 0) : fdiv (a * b) a = b", "start": [216, 1], "end": [217, 44], "kind": "commanddeclaration"}, {"full_name": "Int.mul_ediv_cancel_left", "code": "@[simp] theorem mul_ediv_cancel_left (b : Int) (H : a \u2260 0) : (a * b) / a = b", "start": [219, 1], "end": [220, 44], "kind": "commanddeclaration"}, {"full_name": "Int.div_self", "code": "@[simp] protected theorem div_self {a : Int} (H : a \u2260 0) : a.div a = 1", "start": [222, 1], "end": [223, 60], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_self", "code": "@[simp] protected theorem fdiv_self {a : Int} (H : a \u2260 0) : a.fdiv a = 1", "start": [225, 1], "end": [226, 61], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_self", "code": "@[simp] protected theorem ediv_self {a : Int} (H : a \u2260 0) : a / a = 1", "start": [228, 1], "end": [229, 61], "kind": "commanddeclaration"}, {"full_name": "Int.mod_def'", "code": "theorem mod_def' (m n : Int) : m % n = emod m n", "start": [233, 1], "end": [233, 55], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_mod", "code": "theorem ofNat_mod (m n : Nat) : (\u2191(m % n) : Int) = mod m n", "start": [235, 1], "end": [235, 66], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_mod_ofNat", "code": "theorem ofNat_mod_ofNat (m n : Nat) : (m % n : Int) = \u2191(m % n)", "start": [237, 1], "end": [237, 70], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_fmod", "code": "theorem ofNat_fmod (m n : Nat) : \u2191(m % n) = fmod m n", "start": [239, 1], "end": [239, 83], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_emod", "code": "@[simp, norm_cast] theorem ofNat_emod (m n : Nat) : (\u2191(m % n) : Int) = m % n", "start": [241, 1], "end": [241, 84], "kind": "commanddeclaration"}, {"full_name": "Int.negSucc_emod", "code": "theorem negSucc_emod (m : Nat) {b : Int} (bpos : 0 < b) : -[m+1] % b = b - 1 - m % b", "start": [243, 1], "end": [246, 23], "kind": "commanddeclaration"}, {"full_name": "Int.zero_mod", "code": "@[simp] theorem zero_mod (b : Int) : mod 0 b = 0", "start": [248, 1], "end": [248, 78], "kind": "commanddeclaration"}, {"full_name": "Int.zero_fmod", "code": "@[simp] theorem zero_fmod (b : Int) : fmod 0 b = 0", "start": [250, 1], "end": [250, 73], "kind": "commanddeclaration"}, {"full_name": "Int.zero_emod", "code": "@[simp] theorem zero_emod (b : Int) : 0 % b = 0", "start": [252, 1], "end": [252, 76], "kind": "commanddeclaration"}, {"full_name": "Int.mod_zero", "code": "@[simp] theorem mod_zero : \u2200 a : Int, mod a 0 = a", "start": [254, 1], "end": [256, 18], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_zero", "code": "@[simp] theorem fmod_zero : \u2200 a : Int, fmod a 0 = a", "start": [258, 1], "end": [261, 50], "kind": "commanddeclaration"}, {"full_name": "Int.emod_zero", "code": "@[simp] theorem emod_zero : \u2200 a : Int, a % 0 = a", "start": [263, 1], "end": [265, 50], "kind": "commanddeclaration"}, {"full_name": "Int.mod_add_div", "code": "theorem mod_add_div : \u2200 a b : Int, mod a b + b * (a.div b) = a", "start": [267, 1], "end": [280, 51], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_add_fdiv", "code": "theorem fmod_add_fdiv : \u2200 a b : Int, a.fmod b + b * a.fdiv b = a", "start": [282, 1], "end": [297, 72], "kind": "commanddeclaration"}, {"full_name": "Int.emod_add_ediv", "code": "theorem emod_add_ediv : \u2200 a b : Int, a % b + b * (a / b) = a", "start": [299, 1], "end": [311, 66], "kind": "commanddeclaration"}, {"full_name": "Int.div_add_mod", "code": "theorem div_add_mod (a b : Int) : b * a.div b + mod a b = a", "start": [313, 1], "end": [314, 43], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_add_fmod", "code": "theorem fdiv_add_fmod (a b : Int) : b * a.fdiv b + a.fmod b = a", "start": [316, 1], "end": [317, 45], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_add_emod", "code": "theorem ediv_add_emod (a b : Int) : b * (a / b) + a % b = a", "start": [319, 1], "end": [320, 45], "kind": "commanddeclaration"}, {"full_name": "Int.mod_def", "code": "theorem mod_def (a b : Int) : mod a b = a - b * a.div b", "start": [322, 1], "end": [323, 51], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_def", "code": "theorem fmod_def (a b : Int) : a.fmod b = a - b * a.fdiv b", "start": [325, 1], "end": [326, 54], "kind": "commanddeclaration"}, {"full_name": "Int.emod_def", "code": "theorem emod_def (a b : Int) : a % b = a - b * (a / b)", "start": [328, 1], "end": [329, 51], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_eq_emod", "code": "theorem fmod_eq_emod (a : Int) {b : Int} (hb : 0 \u2264 b) : fmod a b = a % b", "start": [331, 1], "end": [332, 47], "kind": "commanddeclaration"}, {"full_name": "Int.mod_eq_emod", "code": "theorem mod_eq_emod {a b : Int} (ha : 0 \u2264 a) (hb : 0 \u2264 b) : mod a b = a % b", "start": [334, 1], "end": [335, 46], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_eq_mod", "code": "theorem fmod_eq_mod {a b : Int} (Ha : 0 \u2264 a) (Hb : 0 \u2264 b) : fmod a b = mod a b", "start": [337, 1], "end": [338, 40], "kind": "commanddeclaration"}, {"full_name": "Int.mod_neg", "code": "@[simp] theorem mod_neg (a b : Int) : mod a (-b) = mod a b", "start": [340, 1], "end": [341, 54], "kind": "commanddeclaration"}, {"full_name": "Int.emod_neg", "code": "@[simp] theorem emod_neg (a b : Int) : a % -b = a % b", "start": [343, 1], "end": [344, 57], "kind": "commanddeclaration"}, {"full_name": "Int.mod_one", "code": "@[simp] theorem mod_one (a : Int) : mod a 1 = 0", "start": [346, 1], "end": [347, 57], "kind": "commanddeclaration"}, {"full_name": "Int.emod_one", "code": "@[local simp] theorem emod_one (a : Int) : a % 1 = 0", "start": [349, 1], "end": [350, 45], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_one", "code": "@[simp] theorem fmod_one (a : Int) : a.fmod 1 = 0", "start": [352, 1], "end": [353, 45], "kind": "commanddeclaration"}, {"full_name": "Int.emod_eq_of_lt", "code": "theorem emod_eq_of_lt {a b : Int} (H1 : 0 \u2264 a) (H2 : a < b) : a % b = a", "start": [355, 1], "end": [358, 87], "kind": "commanddeclaration"}, {"full_name": "Int.mod_eq_of_lt", "code": "theorem mod_eq_of_lt {a b : Int} (H1 : 0 \u2264 a) (H2 : a < b) : mod a b = a", "start": [360, 1], "end": [361, 79], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_eq_of_lt", "code": "theorem fmod_eq_of_lt {a b : Int} (H1 : 0 \u2264 a) (H2 : a < b) : a.fmod b = a", "start": [363, 1], "end": [364, 79], "kind": "commanddeclaration"}, {"full_name": "Int.mod_nonneg", "code": "theorem mod_nonneg : \u2200 {a : Int} (b : Int), 0 \u2264 a \u2192 0 \u2264 mod a b", "start": [366, 1], "end": [367, 63], "kind": "commanddeclaration"}, {"full_name": "Int.emod_nonneg", "code": "theorem emod_nonneg : \u2200 (a : Int) {b : Int}, b \u2260 0 \u2192 0 \u2264 a % b", "start": [369, 1], "end": [371, 88], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_nonneg", "code": "theorem fmod_nonneg {a b : Int} (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 a.fmod b", "start": [373, 1], "end": [374, 38], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_nonneg'", "code": "theorem fmod_nonneg' (a : Int) {b : Int} (hb : 0 < b) : 0 \u2264 a.fmod b", "start": [376, 1], "end": [377, 74], "kind": "commanddeclaration"}, {"full_name": "Int.mod_lt_of_pos", "code": "theorem mod_lt_of_pos (a : Int) {b : Int} (H : 0 < b) : mod a b < b", "start": [379, 1], "end": [383, 78], "kind": "commanddeclaration"}, {"full_name": "Int.emod_lt_of_pos", "code": "theorem emod_lt_of_pos (a : Int) {b : Int} (H : 0 < b) : a % b < b", "start": [385, 1], "end": [388, 76], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_lt_of_pos", "code": "theorem fmod_lt_of_pos (a : Int) {b : Int} (H : 0 < b) : a.fmod b < b", "start": [390, 1], "end": [391, 55], "kind": "commanddeclaration"}, {"full_name": "Int.mod_add_div'", "code": "theorem mod_add_div' (m k : Int) : mod m k + m.div k * k = m", "start": [393, 1], "end": [394, 39], "kind": "commanddeclaration"}, {"full_name": "Int.div_add_mod'", "code": "theorem div_add_mod' (m k : Int) : m.div k * k + mod m k = m", "start": [396, 1], "end": [397, 39], "kind": "commanddeclaration"}, {"full_name": "Int.emod_add_ediv'", "code": "theorem emod_add_ediv' (m k : Int) : m % k + m / k * k = m", "start": [399, 1], "end": [400, 41], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_add_emod'", "code": "theorem ediv_add_emod' (m k : Int) : m / k * k + m % k = m", "start": [402, 1], "end": [403, 41], "kind": "commanddeclaration"}, {"full_name": "Int.add_mul_emod_self", "code": "@[simp] theorem add_mul_emod_self {a b c : Int} : (a + b * c) % c = a % c", "start": [405, 1], "end": [410, 68], "kind": "commanddeclaration"}, {"full_name": "Int.add_mul_emod_self_left", "code": "@[simp] theorem add_mul_emod_self_left (a b c : Int) : (a + b * c) % b = a % b", "start": [412, 1], "end": [413, 43], "kind": "commanddeclaration"}, {"full_name": "Int.add_emod_self", "code": "@[simp] theorem add_emod_self {a b : Int} : (a + b) % b = a % b", "start": [415, 1], "end": [416, 66], "kind": "commanddeclaration"}, {"full_name": "Int.add_emod_self_left", "code": "@[simp] theorem add_emod_self_left {a b : Int} : (a + b) % a = b % a", "start": [418, 1], "end": [419, 39], "kind": "commanddeclaration"}, {"full_name": "Int.emod_add_emod", "code": "@[simp] theorem emod_add_emod (m n k : Int) : (m % n + k) % n = (m + k) % n", "start": [421, 1], "end": [423, 50], "kind": "commanddeclaration"}, {"full_name": "Int.add_emod_emod", "code": "@[simp] theorem add_emod_emod (m n k : Int) : (m + n % k) % k = (m + n) % k", "start": [425, 1], "end": [426, 49], "kind": "commanddeclaration"}, {"full_name": "Int.add_emod", "code": "theorem add_emod (a b n : Int) : (a + b) % n = (a % n + b % n) % n", "start": [428, 1], "end": [429, 36], "kind": "commanddeclaration"}, {"full_name": "Int.add_emod_eq_add_emod_right", "code": "theorem add_emod_eq_add_emod_right {m n k : Int} (i : Int)\n    (H : m % n = k % n) : (m + i) % n = (k + i) % n", "start": [431, 1], "end": [433, 45], "kind": "commanddeclaration"}, {"full_name": "Int.add_emod_eq_add_emod_left", "code": "theorem add_emod_eq_add_emod_left {m n k : Int} (i : Int)\n    (H : m % n = k % n) : (i + m) % n = (i + k) % n", "start": [435, 1], "end": [437, 66], "kind": "commanddeclaration"}, {"full_name": "Int.emod_add_cancel_right", "code": "theorem emod_add_cancel_right {m n k : Int} (i) : (m + i) % n = (k + i) % n \u2194 m % n = k % n", "start": [439, 1], "end": [443, 32], "kind": "commanddeclaration"}, {"full_name": "Int.emod_add_cancel_left", "code": "theorem emod_add_cancel_left {m n k i : Int} : (i + m) % n = (i + k) % n \u2194 m % n = k % n", "start": [445, 1], "end": [446, 59], "kind": "commanddeclaration"}, {"full_name": "Int.emod_sub_cancel_right", "code": "theorem emod_sub_cancel_right {m n k : Int} (i) : (m - i) % n = (k - i) % n \u2194 m % n = k % n", "start": [448, 1], "end": [449, 26], "kind": "commanddeclaration"}, {"full_name": "Int.emod_eq_emod_iff_emod_sub_eq_zero", "code": "theorem emod_eq_emod_iff_emod_sub_eq_zero {m n k : Int} : m % n = k % n \u2194 (m - k) % n = 0", "start": [451, 1], "end": [452, 65], "kind": "commanddeclaration"}, {"full_name": "Int.mul_mod_left", "code": "@[simp] theorem mul_mod_left (a b : Int) : (a * b).mod b = 0", "start": [454, 1], "end": [456, 73], "kind": "commanddeclaration"}, {"full_name": "Int.mul_fmod_left", "code": "@[simp] theorem mul_fmod_left (a b : Int) : (a * b).fmod b = 0", "start": [458, 1], "end": [460, 75], "kind": "commanddeclaration"}, {"full_name": "Int.mul_emod_left", "code": "@[simp] theorem mul_emod_left (a b : Int) : (a * b) % b = 0", "start": [462, 1], "end": [463, 68], "kind": "commanddeclaration"}, {"full_name": "Int.mul_mod_right", "code": "@[simp] theorem mul_mod_right (a b : Int) : (a * b).mod a = 0", "start": [465, 1], "end": [466, 34], "kind": "commanddeclaration"}, {"full_name": "Int.mul_fmod_right", "code": "@[simp] theorem mul_fmod_right (a b : Int) : (a * b).fmod a = 0", "start": [468, 1], "end": [469, 35], "kind": "commanddeclaration"}, {"full_name": "Int.mul_emod_right", "code": "@[simp] theorem mul_emod_right (a b : Int) : (a * b) % a = 0", "start": [471, 1], "end": [472, 35], "kind": "commanddeclaration"}, {"full_name": "Int.mul_emod", "code": "theorem mul_emod (a b n : Int) : (a * b) % n = (a % n) * (b % n) % n", "start": [474, 1], "end": [478, 40], "kind": "commanddeclaration"}, {"full_name": "Int.mod_self", "code": "@[simp] theorem mod_self {a : Int} : a.mod a = 0", "start": [480, 1], "end": [481, 54], "kind": "commanddeclaration"}, {"full_name": "Int.fmod_self", "code": "@[simp] theorem fmod_self {a : Int} : a.fmod a = 0", "start": [483, 1], "end": [484, 55], "kind": "commanddeclaration"}, {"full_name": "Int.emod_self", "code": "@[local simp] theorem emod_self {a : Int} : a % a = 0", "start": [486, 1], "end": [487, 55], "kind": "commanddeclaration"}, {"full_name": "Int.emod_emod_of_dvd", "code": "@[simp] theorem emod_emod_of_dvd (n : Int) {m k : Int}\n    (h : m \u2223 k) : (n % k) % m = n % m", "start": [489, 1], "end": [493, 62], "kind": "commanddeclaration"}, {"full_name": "Int.emod_emod", "code": "@[simp] theorem emod_emod (a b : Int) : (a % b) % b = a % b", "start": [495, 1], "end": [496, 64], "kind": "commanddeclaration"}, {"full_name": "Int.sub_emod", "code": "theorem sub_emod (a b n : Int) : (a - b) % n = (a % n - b % n) % n", "start": [498, 1], "end": [500, 78], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_emod_unique", "code": "protected theorem ediv_emod_unique {a b r q : Int} (h : 0 < b) :\n  a / b = q \u2227 a % b = r \u2194 r + b * q = a \u2227 0 \u2264 r \u2227 r < b", "start": [502, 1], "end": [511, 55], "kind": "commanddeclaration"}, {"full_name": "Int.mul_ediv_mul_of_pos", "code": "@[simp] theorem mul_ediv_mul_of_pos {a : Int}\n    (b c : Int) (H : 0 < a) : (a * b) / (a * c) = b / c", "start": [515, 1], "end": [537, 31], "kind": "commanddeclaration"}, {"full_name": "Int.mul_ediv_mul_of_pos_left", "code": "@[simp] theorem mul_ediv_mul_of_pos_left\n    (a : Int) {b : Int} (c : Int) (H : 0 < b) : (a * b) / (c * b) = a / c", "start": [540, 1], "end": [542, 63], "kind": "commanddeclaration"}, {"full_name": "Int.mul_emod_mul_of_pos", "code": "@[simp] theorem mul_emod_mul_of_pos\n    {a : Int} (b c : Int) (H : 0 < a) : (a * b) % (a * c) = a * (b % c)", "start": [544, 1], "end": [546, 81], "kind": "commanddeclaration"}, {"full_name": "Int.lt_div_add_one_mul_self", "code": "theorem lt_div_add_one_mul_self (a : Int) {b : Int} (H : 0 < b) : a < (a.div b + 1) * b", "start": [548, 1], "end": [550, 72], "kind": "commanddeclaration"}, {"full_name": "Int.lt_ediv_add_one_mul_self", "code": "theorem lt_ediv_add_one_mul_self (a : Int) {b : Int} (H : 0 < b) : a < (a / b + 1) * b", "start": [552, 1], "end": [554, 74], "kind": "commanddeclaration"}, {"full_name": "Int.lt_fdiv_add_one_mul_self", "code": "theorem lt_fdiv_add_one_mul_self (a : Int) {b : Int} (H : 0 < b) : a < (a.fdiv b + 1) * b", "start": [556, 1], "end": [557, 69], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_div", "code": "@[simp] theorem natAbs_div (a b : Int) : natAbs (a.div b) = (natAbs a).div (natAbs b)", "start": [559, 1], "end": [564, 95], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_div_le_natAbs", "code": "theorem natAbs_div_le_natAbs (a b : Int) : natAbs (a / b) \u2264 natAbs a", "start": [566, 1], "end": [574, 61], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_le_self", "code": "theorem ediv_le_self {a : Int} (b : Int) (Ha : 0 \u2264 a) : a / b \u2264 a", "start": [576, 1], "end": [578, 36], "kind": "commanddeclaration"}, {"full_name": "Int.mul_div_cancel_of_mod_eq_zero", "code": "theorem mul_div_cancel_of_mod_eq_zero {a b : Int} (H : a.mod b = 0) : b * (a.div b) = a", "start": [580, 1], "end": [581, 57], "kind": "commanddeclaration"}, {"full_name": "Int.div_mul_cancel_of_mod_eq_zero", "code": "theorem div_mul_cancel_of_mod_eq_zero {a b : Int} (H : a.mod b = 0) : a.div b * b = a", "start": [583, 1], "end": [584, 53], "kind": "commanddeclaration"}, {"full_name": "Int.mul_ediv_cancel_of_emod_eq_zero", "code": "theorem mul_ediv_cancel_of_emod_eq_zero {a b : Int} (H : a % b = 0) : b * (a / b) = a", "start": [586, 1], "end": [587, 59], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_mul_cancel_of_emod_eq_zero", "code": "theorem ediv_mul_cancel_of_emod_eq_zero {a b : Int} (H : a % b = 0) : a / b * b = a", "start": [589, 1], "end": [590, 55], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_zero", "code": "protected theorem dvd_zero (n : Int) : n \u2223 0", "start": [594, 1], "end": [594, 75], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_refl", "code": "protected theorem dvd_refl (n : Int) : n \u2223 n", "start": [596, 1], "end": [596, 74], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_trans", "code": "protected theorem dvd_trans : \u2200 {a b c : Int}, a \u2223 b \u2192 b \u2223 c \u2192 a \u2223 c", "start": [598, 1], "end": [599, 66], "kind": "commanddeclaration"}, {"full_name": "Int.zero_dvd", "code": "protected theorem zero_dvd {n : Int} : 0 \u2223 n \u2194 n = 0", "start": [601, 1], "end": [602, 76], "kind": "commanddeclaration"}, {"full_name": "Int.neg_dvd", "code": "protected theorem neg_dvd {a b : Int} : -a \u2223 b \u2194 a \u2223 b", "start": [604, 1], "end": [606, 61], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_neg", "code": "protected theorem dvd_neg {a b : Int} : a \u2223 -b \u2194 a \u2223 b", "start": [608, 1], "end": [610, 63], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_mul_right", "code": "protected theorem dvd_mul_right (a b : Int) : a \u2223 a * b", "start": [612, 1], "end": [612, 68], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_mul_left", "code": "protected theorem dvd_mul_left (a b : Int) : b \u2223 a * b", "start": [614, 1], "end": [614, 79], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_add", "code": "protected theorem dvd_add : \u2200 {a b c : Int}, a \u2223 b \u2192 a \u2223 c \u2192 a \u2223 b + c", "start": [616, 1], "end": [617, 64], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_sub", "code": "protected theorem dvd_sub : \u2200 {a b c : Int}, a \u2223 b \u2192 a \u2223 c \u2192 a \u2223 b - c", "start": [619, 1], "end": [620, 64], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_add_left", "code": "protected theorem dvd_add_left {a b c : Int} (H : a \u2223 c) : a \u2223 b + c \u2194 a \u2223 b", "start": [622, 1], "end": [623, 93], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_add_right", "code": "protected theorem dvd_add_right {a b c : Int} (H : a \u2223 b) : a \u2223 b + c \u2194 a \u2223 c", "start": [625, 1], "end": [626, 40], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_iff_dvd_of_dvd_sub", "code": "protected theorem dvd_iff_dvd_of_dvd_sub {a b c : Int} (H : a \u2223 b - c) : a \u2223 b \u2194 a \u2223 c", "start": [628, 1], "end": [630, 54], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_iff_dvd_of_dvd_add", "code": "protected theorem dvd_iff_dvd_of_dvd_add {a b c : Int} (H : a \u2223 b + c) : a \u2223 b \u2194 a \u2223 c", "start": [632, 1], "end": [633, 74], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_dvd", "code": "@[norm_cast] theorem ofNat_dvd {m n : Nat} : (\u2191m : Int) \u2223 \u2191n \u2194 m \u2223 n", "start": [635, 1], "end": [643, 49], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_dvd_natAbs", "code": "@[simp] theorem natAbs_dvd_natAbs {a b : Int} : natAbs a \u2223 natAbs b \u2194 a \u2223 b", "start": [645, 1], "end": [650, 48], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_dvd", "code": "theorem natAbs_dvd {a b : Int} : (a.natAbs : Int) \u2223 b \u2194 a \u2223 b", "start": [652, 1], "end": [655, 41], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_natAbs", "code": "theorem dvd_natAbs {a b : Int} : a \u2223 b.natAbs \u2194 a \u2223 b", "start": [657, 1], "end": [660, 41], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_dvd_left", "code": "theorem ofNat_dvd_left {n : Nat} {z : Int} : (\u2191n : Int) \u2223 z \u2194 n \u2223 z.natAbs", "start": [662, 1], "end": [663, 41], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_dvd_right", "code": "theorem ofNat_dvd_right {n : Nat} {z : Int} : z \u2223 (\u2191n : Int) \u2194 z.natAbs \u2223 n", "start": [665, 1], "end": [666, 41], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_antisymm", "code": "theorem dvd_antisymm {a b : Int} (H1 : 0 \u2264 a) (H2 : 0 \u2264 b) : a \u2223 b \u2192 b \u2223 a \u2192 a = b", "start": [668, 1], "end": [671, 25], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_of_mod_eq_zero", "code": "theorem dvd_of_mod_eq_zero {a b : Int} (H : mod b a = 0) : a \u2223 b", "start": [673, 1], "end": [674, 52], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_of_emod_eq_zero", "code": "theorem dvd_of_emod_eq_zero {a b : Int} (H : b % a = 0) : a \u2223 b", "start": [676, 1], "end": [677, 52], "kind": "commanddeclaration"}, {"full_name": "Int.mod_eq_zero_of_dvd", "code": "theorem mod_eq_zero_of_dvd : \u2200 {a b : Int}, a \u2223 b \u2192 mod b a = 0", "start": [679, 1], "end": [680, 39], "kind": "commanddeclaration"}, {"full_name": "Int.emod_eq_zero_of_dvd", "code": "theorem emod_eq_zero_of_dvd : \u2200 {a b : Int}, a \u2223 b \u2192 b % a = 0", "start": [682, 1], "end": [683, 40], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_iff_mod_eq_zero", "code": "theorem dvd_iff_mod_eq_zero (a b : Int) : a \u2223 b \u2194 mod b a = 0", "start": [685, 1], "end": [686, 43], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_iff_emod_eq_zero", "code": "theorem dvd_iff_emod_eq_zero (a b : Int) : a \u2223 b \u2194 b % a = 0", "start": [688, 1], "end": [689, 45], "kind": "commanddeclaration"}, {"full_name": "Int.decidableDvd", "code": "instance decidableDvd : DecidableRel (\u03b1 := Int) (\u00b7 \u2223 \u00b7) := fun _ _ =>\n  decidable_of_decidable_of_iff (dvd_iff_mod_eq_zero ..).symm", "start": [691, 1], "end": [692, 62], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_sub_of_emod_eq", "code": "theorem dvd_sub_of_emod_eq {a b c : Int} (h : a % b = c) : b \u2223 a - c", "start": [694, 1], "end": [699, 31], "kind": "commanddeclaration"}, {"full_name": "Int.div_mul_cancel", "code": "protected theorem div_mul_cancel {a b : Int} (H : b \u2223 a) : a.div b * b = a", "start": [701, 1], "end": [702, 55], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_mul_cancel", "code": "protected theorem ediv_mul_cancel {a b : Int} (H : b \u2223 a) : a / b * b = a", "start": [704, 1], "end": [705, 58], "kind": "commanddeclaration"}, {"full_name": "Int.mul_div_cancel'", "code": "protected theorem mul_div_cancel' {a b : Int} (H : a \u2223 b) : a * b.div a = b", "start": [707, 1], "end": [708, 42], "kind": "commanddeclaration"}, {"full_name": "Int.mul_ediv_cancel'", "code": "protected theorem mul_ediv_cancel' {a b : Int} (H : a \u2223 b) : a * (b / a) = b", "start": [710, 1], "end": [711, 43], "kind": "commanddeclaration"}, {"full_name": "Int.mul_div_assoc", "code": "protected theorem mul_div_assoc (a : Int) : \u2200 {b c : Int}, c \u2223 b \u2192 (a * b).div c = a * (b.div c)", "start": [713, 1], "end": [716, 89], "kind": "commanddeclaration"}, {"full_name": "Int.mul_ediv_assoc", "code": "protected theorem mul_ediv_assoc (a : Int) : \u2200 {b c : Int}, c \u2223 b \u2192 (a * b) / c = a * (b / c)", "start": [718, 1], "end": [721, 91], "kind": "commanddeclaration"}, {"full_name": "Int.mul_div_assoc'", "code": "protected theorem mul_div_assoc' (b : Int) {a c : Int} (h : c \u2223 a) :\n    (a * b).div c = a.div c * b", "start": [723, 1], "end": [725, 57], "kind": "commanddeclaration"}, {"full_name": "Int.mul_ediv_assoc'", "code": "protected theorem mul_ediv_assoc' (b : Int) {a c : Int}\n    (h : c \u2223 a) : (a * b) / c = a / c * b", "start": [727, 1], "end": [729, 58], "kind": "commanddeclaration"}, {"full_name": "Int.div_dvd_div", "code": "theorem div_dvd_div : \u2200 {a b c : Int}, a \u2223 b \u2192 b \u2223 c \u2192 b.div a \u2223 c.div a", "start": [731, 1], "end": [734, 28], "kind": "commanddeclaration"}, {"full_name": "Int.eq_mul_of_div_eq_right", "code": "protected theorem eq_mul_of_div_eq_right {a b c : Int}\n    (H1 : b \u2223 a) (H2 : a.div b = c) : a = b * c", "start": [736, 1], "end": [737, 88], "kind": "commanddeclaration"}, {"full_name": "Int.eq_mul_of_ediv_eq_right", "code": "protected theorem eq_mul_of_ediv_eq_right {a b c : Int}\n    (H1 : b \u2223 a) (H2 : a / b = c) : a = b * c", "start": [739, 1], "end": [740, 87], "kind": "commanddeclaration"}, {"full_name": "Int.div_eq_of_eq_mul_right", "code": "protected theorem div_eq_of_eq_mul_right {a b c : Int}\n    (H1 : b \u2260 0) (H2 : a = b * c) : a.div b = c", "start": [742, 1], "end": [743, 92], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_eq_of_eq_mul_right", "code": "protected theorem ediv_eq_of_eq_mul_right {a b c : Int}\n    (H1 : b \u2260 0) (H2 : a = b * c) : a / b = c", "start": [745, 1], "end": [746, 91], "kind": "commanddeclaration"}, {"full_name": "Int.eq_div_of_mul_eq_right", "code": "protected theorem eq_div_of_mul_eq_right {a b c : Int}\n    (H1 : a \u2260 0) (H2 : a * b = c) : b = c.div a", "start": [748, 1], "end": [750, 47], "kind": "commanddeclaration"}, {"full_name": "Int.eq_ediv_of_mul_eq_right", "code": "protected theorem eq_ediv_of_mul_eq_right {a b c : Int}\n    (H1 : a \u2260 0) (H2 : a * b = c) : b = c / a", "start": [752, 1], "end": [754, 48], "kind": "commanddeclaration"}, {"full_name": "Int.div_eq_iff_eq_mul_right", "code": "protected theorem div_eq_iff_eq_mul_right {a b c : Int}\n    (H : b \u2260 0) (H' : b \u2223 a) : a.div b = c \u2194 a = b * c", "start": [756, 1], "end": [758, 64], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_eq_iff_eq_mul_right", "code": "protected theorem ediv_eq_iff_eq_mul_right {a b c : Int}\n    (H : b \u2260 0) (H' : b \u2223 a) : a / b = c \u2194 a = b * c", "start": [760, 1], "end": [762, 66], "kind": "commanddeclaration"}, {"full_name": "Int.div_eq_iff_eq_mul_left", "code": "protected theorem div_eq_iff_eq_mul_left {a b c : Int}\n    (H : b \u2260 0) (H' : b \u2223 a) : a.div b = c \u2194 a = c * b", "start": [764, 1], "end": [766, 60], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_eq_iff_eq_mul_left", "code": "protected theorem ediv_eq_iff_eq_mul_left {a b c : Int}\n    (H : b \u2260 0) (H' : b \u2223 a) : a / b = c \u2194 a = c * b", "start": [768, 1], "end": [770, 61], "kind": "commanddeclaration"}, {"full_name": "Int.eq_mul_of_div_eq_left", "code": "protected theorem eq_mul_of_div_eq_left {a b c : Int}\n    (H1 : b \u2223 a) (H2 : a.div b = c) : a = c * b", "start": [772, 1], "end": [774, 54], "kind": "commanddeclaration"}, {"full_name": "Int.eq_mul_of_ediv_eq_left", "code": "protected theorem eq_mul_of_ediv_eq_left {a b c : Int}\n    (H1 : b \u2223 a) (H2 : a / b = c) : a = c * b", "start": [776, 1], "end": [778, 55], "kind": "commanddeclaration"}, {"full_name": "Int.div_eq_of_eq_mul_left", "code": "protected theorem div_eq_of_eq_mul_left {a b c : Int}\n    (H1 : b \u2260 0) (H2 : a = c * b) : a.div b = c", "start": [780, 1], "end": [782, 59], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_eq_of_eq_mul_left", "code": "protected theorem ediv_eq_of_eq_mul_left {a b c : Int}\n    (H1 : b \u2260 0) (H2 : a = c * b) : a / b = c", "start": [784, 1], "end": [786, 60], "kind": "commanddeclaration"}, {"full_name": "Int.eq_zero_of_div_eq_zero", "code": "protected theorem eq_zero_of_div_eq_zero {d n : Int} (h : d \u2223 n) (H : n.div d = 0) : n = 0", "start": [788, 1], "end": [789, 48], "kind": "commanddeclaration"}, {"full_name": "Int.eq_zero_of_ediv_eq_zero", "code": "protected theorem eq_zero_of_ediv_eq_zero {d n : Int} (h : d \u2223 n) (H : n / d = 0) : n = 0", "start": [791, 1], "end": [792, 49], "kind": "commanddeclaration"}, {"full_name": "Int.div_eq_ediv_of_dvd", "code": "theorem div_eq_ediv_of_dvd {a b : Int} (h : b \u2223 a) : a.div b = a / b", "start": [794, 1], "end": [796, 80], "kind": "commanddeclaration"}, {"full_name": "Int.fdiv_eq_ediv_of_dvd", "code": "theorem fdiv_eq_ediv_of_dvd : \u2200 {a b : Int}, b \u2223 a \u2192 a.fdiv b = a / b", "start": [798, 1], "end": [800, 62], "kind": "commanddeclaration"}, {"full_name": "Int.neg_ediv_of_dvd", "code": "theorem neg_ediv_of_dvd : \u2200 {a b : Int}, b \u2223 a \u2192 (-a) / b = -(a / b)", "start": [802, 1], "end": [804, 94], "kind": "commanddeclaration"}, {"full_name": "Int.sub_ediv_of_dvd", "code": "theorem sub_ediv_of_dvd (a : Int) {b c : Int}\n    (hcb : c \u2223 b) : (a - b) / c = a / c - b / c", "start": [806, 1], "end": [809, 39], "kind": "commanddeclaration"}, {"full_name": "Int.sub_ediv_of_dvd_sub", "code": "theorem sub_ediv_of_dvd_sub {a b c : Int}\n    (hcab : c \u2223 a - b) : (a - b) / c = a / c - b / c", "start": [811, 1], "end": [813, 93], "kind": "commanddeclaration"}, {"full_name": "Int.div_left_inj", "code": "@[simp] protected theorem div_left_inj {a b d : Int}\n    (hda : d \u2223 a) (hdb : d \u2223 b) : a.div d = b.div d \u2194 a = b", "start": [815, 1], "end": [818, 63], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_left_inj", "code": "@[simp] protected theorem ediv_left_inj {a b d : Int}\n    (hda : d \u2223 a) (hdb : d \u2223 b) : a / d = b / d \u2194 a = b", "start": [820, 1], "end": [823, 65], "kind": "commanddeclaration"}, {"full_name": "Int.div_sign", "code": "theorem div_sign : \u2200 a b, a.div (sign b) = a * sign b", "start": [825, 1], "end": [828, 58], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_sign", "code": "theorem ediv_sign : \u2200 a b, a / sign b = a * sign b", "start": [830, 1], "end": [833, 58], "kind": "commanddeclaration"}, {"full_name": "Int.sign_eq_div_abs", "code": "protected theorem sign_eq_div_abs (a : Int) : sign a = a.div (natAbs a)", "start": [835, 1], "end": [838, 37], "kind": "commanddeclaration"}, {"full_name": "Int.mul_sign", "code": "theorem mul_sign : \u2200 i : Int, i * sign i = natAbs i", "start": [840, 1], "end": [843, 32], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_dvd", "code": "theorem le_of_dvd {a b : Int} (bpos : 0 < b) (H : a \u2223 b) : a \u2264 b", "start": [845, 1], "end": [848, 97], "kind": "commanddeclaration"}, {"full_name": "Int.eq_one_of_dvd_one", "code": "theorem eq_one_of_dvd_one {a : Int} (H : 0 \u2264 a) (H' : a \u2223 1) : a = 1", "start": [850, 1], "end": [852, 81], "kind": "commanddeclaration"}, {"full_name": "Int.eq_one_of_mul_eq_one_right", "code": "theorem eq_one_of_mul_eq_one_right {a b : Int} (H : 0 \u2264 a) (H' : a * b = 1) : a = 1", "start": [854, 1], "end": [855, 35], "kind": "commanddeclaration"}, {"full_name": "Int.eq_one_of_mul_eq_one_left", "code": "theorem eq_one_of_mul_eq_one_left {a b : Int} (H : 0 \u2264 b) (H' : a * b = 1) : b = 1", "start": [857, 1], "end": [858, 59], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Nat/Gcd.lean", "imports": ["lake-packages/std/Std/Tactic/RCases.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.gcd_rec", "code": "theorem gcd_rec (m n : Nat) : gcd m n = gcd (n % m) m", "start": [16, 1], "end": [19, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd.induction", "code": "@[elab_as_elim] theorem gcd.induction {P : Nat \u2192 Nat \u2192 Prop} (m n : Nat)\n    (H0 : \u2200n, P 0 n) (H1 : \u2200 m n, 0 < m \u2192 P (n % m) m \u2192 P m n) : P m n", "start": [21, 1], "end": [27, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm", "code": "def lcm (m n : Nat) : Nat := m * n / gcd m n", "start": [29, 1], "end": [30, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime", "code": "@[reducible] def Coprime (m n : Nat) : Prop := gcd m n = 1", "start": [32, 1], "end": [33, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_dvd", "code": "theorem gcd_dvd (m n : Nat) : (gcd m n \u2223 m) \u2227 (gcd m n \u2223 n)", "start": [37, 1], "end": [40, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_dvd_left", "code": "theorem gcd_dvd_left (m n : Nat) : gcd m n \u2223 m", "start": [42, 1], "end": [42, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_dvd_right", "code": "theorem gcd_dvd_right (m n : Nat) : gcd m n \u2223 n", "start": [44, 1], "end": [44, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_le_left", "code": "theorem gcd_le_left (n) (h : 0 < m) : gcd m n \u2264 m", "start": [46, 1], "end": [46, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_le_right", "code": "theorem gcd_le_right (n) (h : 0 < n) : gcd m n \u2264 n", "start": [48, 1], "end": [48, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_gcd", "code": "theorem dvd_gcd : k \u2223 m \u2192 k \u2223 n \u2192 k \u2223 gcd m n", "start": [50, 1], "end": [53, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_gcd_iff", "code": "theorem dvd_gcd_iff : k \u2223 gcd m n \u2194 k \u2223 m \u2227 k \u2223 n", "start": [55, 1], "end": [57, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_comm", "code": "theorem gcd_comm (m n : Nat) : gcd m n = gcd n m", "start": [59, 1], "end": [62, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_eq_left_iff_dvd", "code": "theorem gcd_eq_left_iff_dvd : m \u2223 n \u2194 gcd m n = m", "start": [64, 1], "end": [66, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_eq_right_iff_dvd", "code": "theorem gcd_eq_right_iff_dvd : m \u2223 n \u2194 gcd n m = m", "start": [68, 1], "end": [69, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_assoc", "code": "theorem gcd_assoc (m n k : Nat) : gcd (gcd m n) k = gcd m (gcd n k)", "start": [71, 1], "end": [80, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_one_right", "code": "@[simp] theorem gcd_one_right (n : Nat) : gcd n 1 = 1", "start": [82, 1], "end": [82, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_left", "code": "theorem gcd_mul_left (m n k : Nat) : gcd (m * n) (m * k) = m * gcd n k", "start": [84, 1], "end": [87, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_right", "code": "theorem gcd_mul_right (m n k : Nat) : gcd (m * n) (k * n) = gcd m k * n", "start": [89, 1], "end": [90, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_pos_of_pos_left", "code": "theorem gcd_pos_of_pos_left {m : Nat} (n : Nat) (mpos : 0 < m) : 0 < gcd m n", "start": [92, 1], "end": [93, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_pos_of_pos_right", "code": "theorem gcd_pos_of_pos_right (m : Nat) {n : Nat} (npos : 0 < n) : 0 < gcd m n", "start": [95, 1], "end": [96, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.div_gcd_pos_of_pos_left", "code": "theorem div_gcd_pos_of_pos_left (b : Nat) (h : 0 < a) : 0 < a / a.gcd b", "start": [98, 1], "end": [99, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.div_gcd_pos_of_pos_right", "code": "theorem div_gcd_pos_of_pos_right (a : Nat) (h : 0 < b) : 0 < b / a.gcd b", "start": [101, 1], "end": [102, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_gcd_eq_zero_left", "code": "theorem eq_zero_of_gcd_eq_zero_left {m n : Nat} (H : gcd m n = 0) : m = 0", "start": [104, 1], "end": [107, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_gcd_eq_zero_right", "code": "theorem eq_zero_of_gcd_eq_zero_right {m n : Nat} (H : gcd m n = 0) : n = 0", "start": [109, 1], "end": [111, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_ne_zero_left", "code": "theorem gcd_ne_zero_left : m \u2260 0 \u2192 gcd m n \u2260 0", "start": [113, 1], "end": [113, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_ne_zero_right", "code": "theorem gcd_ne_zero_right : n \u2260 0 \u2192 gcd m n \u2260 0", "start": [115, 1], "end": [115, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_div", "code": "theorem gcd_div {m n k : Nat} (H1 : k \u2223 m) (H2 : k \u2223 n) :\n    gcd (m / k) (n / k) = gcd m n / k", "start": [117, 1], "end": [124, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_dvd_gcd_of_dvd_left", "code": "theorem gcd_dvd_gcd_of_dvd_left {m k : Nat} (n : Nat) (H : m \u2223 k) : gcd m n \u2223 gcd k n", "start": [126, 1], "end": [127, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_dvd_gcd_of_dvd_right", "code": "theorem gcd_dvd_gcd_of_dvd_right {m k : Nat} (n : Nat) (H : m \u2223 k) : gcd n m \u2223 gcd n k", "start": [129, 1], "end": [130, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_dvd_gcd_mul_left", "code": "theorem gcd_dvd_gcd_mul_left (m n k : Nat) : gcd m n \u2223 gcd (k * m) n", "start": [132, 1], "end": [133, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_dvd_gcd_mul_right", "code": "theorem gcd_dvd_gcd_mul_right (m n k : Nat) : gcd m n \u2223 gcd (m * k) n", "start": [135, 1], "end": [136, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_dvd_gcd_mul_left_right", "code": "theorem gcd_dvd_gcd_mul_left_right (m n k : Nat) : gcd m n \u2223 gcd m (k * n)", "start": [138, 1], "end": [139, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_dvd_gcd_mul_right_right", "code": "theorem gcd_dvd_gcd_mul_right_right (m n k : Nat) : gcd m n \u2223 gcd m (n * k)", "start": [141, 1], "end": [142, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_eq_left", "code": "theorem gcd_eq_left {m n : Nat} (H : m \u2223 n) : gcd m n = m", "start": [144, 1], "end": [145, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_eq_right", "code": "theorem gcd_eq_right {m n : Nat} (H : n \u2223 m) : gcd m n = n", "start": [147, 1], "end": [148, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_left_left", "code": "@[simp] theorem gcd_mul_left_left (m n : Nat) : gcd (m * n) n = n", "start": [150, 1], "end": [151, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_left_right", "code": "@[simp] theorem gcd_mul_left_right (m n : Nat) : gcd n (m * n) = n", "start": [153, 1], "end": [154, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_right_left", "code": "@[simp] theorem gcd_mul_right_left (m n : Nat) : gcd (n * m) n = n", "start": [156, 1], "end": [157, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_right_right", "code": "@[simp] theorem gcd_mul_right_right (m n : Nat) : gcd n (n * m) = n", "start": [159, 1], "end": [160, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_gcd_self_right_left", "code": "@[simp] theorem gcd_gcd_self_right_left (m n : Nat) : gcd m (gcd m n) = gcd m n", "start": [162, 1], "end": [163, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_gcd_self_right_right", "code": "@[simp] theorem gcd_gcd_self_right_right (m n : Nat) : gcd m (gcd n m) = gcd n m", "start": [165, 1], "end": [166, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_gcd_self_left_right", "code": "@[simp] theorem gcd_gcd_self_left_right (m n : Nat) : gcd (gcd n m) m = gcd n m", "start": [168, 1], "end": [169, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_gcd_self_left_left", "code": "@[simp] theorem gcd_gcd_self_left_left (m n : Nat) : gcd (gcd m n) m = gcd m n", "start": [171, 1], "end": [172, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_add_mul_self", "code": "theorem gcd_add_mul_self (m n k : Nat) : gcd m (n + k * m) = gcd m n", "start": [174, 1], "end": [175, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_eq_zero_iff", "code": "theorem gcd_eq_zero_iff {i j : Nat} : gcd i j = 0 \u2194 i = 0 \u2227 j = 0", "start": [177, 1], "end": [179, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_eq_iff", "code": "theorem gcd_eq_iff (a b : Nat) :\n    gcd a b = g \u2194 g \u2223 a \u2227 g \u2223 b \u2227 (\u2200 c, c \u2223 a \u2192 c \u2223 b \u2192 c \u2223 g)", "start": [181, 1], "end": [192, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_comm", "code": "theorem lcm_comm (m n : Nat) : lcm m n = lcm n m", "start": [196, 1], "end": [197, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_zero_left", "code": "@[simp] theorem lcm_zero_left (m : Nat) : lcm 0 m = 0", "start": [199, 1], "end": [199, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_zero_right", "code": "@[simp] theorem lcm_zero_right (m : Nat) : lcm m 0 = 0", "start": [201, 1], "end": [201, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_one_left", "code": "@[simp] theorem lcm_one_left (m : Nat) : lcm 1 m = m", "start": [203, 1], "end": [203, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_one_right", "code": "@[simp] theorem lcm_one_right (m : Nat) : lcm m 1 = m", "start": [205, 1], "end": [205, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_self", "code": "@[simp] theorem lcm_self (m : Nat) : lcm m m = m", "start": [207, 1], "end": [210, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_lcm_left", "code": "theorem dvd_lcm_left (m n : Nat) : m \u2223 lcm m n", "start": [212, 1], "end": [213, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_lcm_right", "code": "theorem dvd_lcm_right (m n : Nat) : n \u2223 lcm m n", "start": [215, 1], "end": [215, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_lcm", "code": "theorem gcd_mul_lcm (m n : Nat) : gcd m n * lcm m n = m * n", "start": [217, 1], "end": [218, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_dvd", "code": "theorem lcm_dvd {m n k : Nat} (H1 : m \u2223 k) (H2 : n \u2223 k) : lcm m n \u2223 k", "start": [220, 1], "end": [226, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_assoc", "code": "theorem lcm_assoc (m n k : Nat) : lcm (lcm m n) k = lcm m (lcm n k)", "start": [228, 1], "end": [237, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_ne_zero", "code": "theorem lcm_ne_zero (hm : m \u2260 0) (hn : n \u2260 0) : lcm m n \u2260 0", "start": [239, 1], "end": [245, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_iff_gcd_eq_one", "code": "theorem coprime_iff_gcd_eq_one : Coprime m n \u2194 gcd m n = 1", "start": [255, 1], "end": [255, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.gcd_eq_one", "code": "theorem Coprime.gcd_eq_one : Coprime m n \u2192 gcd m n = 1", "start": [257, 1], "end": [257, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.symm", "code": "theorem Coprime.symm : Coprime n m \u2192 Coprime m n", "start": [259, 1], "end": [259, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_comm", "code": "theorem coprime_comm : Coprime n m \u2194 Coprime m n", "start": [261, 1], "end": [261, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.dvd_of_dvd_mul_right", "code": "theorem Coprime.dvd_of_dvd_mul_right (H1 : Coprime k n) (H2 : k \u2223 m * n) : k \u2223 m", "start": [263, 1], "end": [265, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.dvd_of_dvd_mul_left", "code": "theorem Coprime.dvd_of_dvd_mul_left (H1 : Coprime k m) (H2 : k \u2223 m * n) : k \u2223 n", "start": [267, 1], "end": [268, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.gcd_mul_left_cancel", "code": "theorem Coprime.gcd_mul_left_cancel (m : Nat) (H : Coprime k n) : gcd (k * m) n = gcd m n", "start": [270, 1], "end": [275, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.gcd_mul_right_cancel", "code": "theorem Coprime.gcd_mul_right_cancel (m : Nat) (H : Coprime k n) : gcd (m * k) n = gcd m n", "start": [277, 1], "end": [278, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.gcd_mul_left_cancel_right", "code": "theorem Coprime.gcd_mul_left_cancel_right (n : Nat)\n    (H : Coprime k m) : gcd m (k * n) = gcd m n", "start": [280, 1], "end": [282, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.gcd_mul_right_cancel_right", "code": "theorem Coprime.gcd_mul_right_cancel_right (n : Nat)\n    (H : Coprime k m) : gcd m (n * k) = gcd m n", "start": [284, 1], "end": [286, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_div_gcd_div_gcd", "code": "theorem coprime_div_gcd_div_gcd\n    (H : 0 < gcd m n) : Coprime (m / gcd m n) (n / gcd m n)", "start": [288, 1], "end": [290, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.not_coprime_of_dvd_of_dvd", "code": "theorem not_coprime_of_dvd_of_dvd (dgt1 : 1 < d) (Hm : d \u2223 m) (Hn : d \u2223 n) : \u00ac Coprime m n", "start": [292, 1], "end": [294, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_coprime", "code": "theorem exists_coprime (H : 0 < gcd m n) :\n    \u2203 m' n', Coprime m' n' \u2227 m = m' * gcd m n \u2227 n = n' * gcd m n", "start": [296, 1], "end": [300, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_coprime'", "code": "theorem exists_coprime' (H : 0 < gcd m n) :\n    \u2203 g m' n', 0 < g \u2227 Coprime m' n' \u2227 m = m' * g \u2227 n = n' * g", "start": [302, 1], "end": [304, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.mul", "code": "theorem Coprime.mul (H1 : Coprime m k) (H2 : Coprime n k) : Coprime (m * n) k", "start": [306, 1], "end": [307, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.mul_right", "code": "theorem Coprime.mul_right (H1 : Coprime k m) (H2 : Coprime k n) : Coprime k (m * n)", "start": [309, 1], "end": [310, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.coprime_dvd_left", "code": "theorem Coprime.coprime_dvd_left (H1 : m \u2223 k) (H2 : Coprime k n) : Coprime m n", "start": [312, 1], "end": [316, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.coprime_dvd_right", "code": "theorem Coprime.coprime_dvd_right (H1 : n \u2223 m) (H2 : Coprime k m) : Coprime k n", "start": [318, 1], "end": [319, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.coprime_mul_left", "code": "theorem Coprime.coprime_mul_left (H : Coprime (k * m) n) : Coprime m n", "start": [321, 1], "end": [322, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.coprime_mul_right", "code": "theorem Coprime.coprime_mul_right (H : Coprime (m * k) n) : Coprime m n", "start": [324, 1], "end": [325, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.coprime_mul_left_right", "code": "theorem Coprime.coprime_mul_left_right (H : Coprime m (k * n)) : Coprime m n", "start": [327, 1], "end": [328, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.coprime_mul_right_right", "code": "theorem Coprime.coprime_mul_right_right (H : Coprime m (n * k)) : Coprime m n", "start": [330, 1], "end": [331, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.coprime_div_left", "code": "theorem Coprime.coprime_div_left (cmn : Coprime m n) (dvd : a \u2223 m) : Coprime (m / a) n", "start": [333, 1], "end": [343, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.coprime_div_right", "code": "theorem Coprime.coprime_div_right (cmn : Coprime m n) (dvd : a \u2223 n) : Coprime m (n / a)", "start": [345, 1], "end": [346, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_mul_iff_left", "code": "theorem coprime_mul_iff_left : Coprime (m * n) k \u2194 Coprime m k \u2227 Coprime n k", "start": [348, 1], "end": [350, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_mul_iff_right", "code": "theorem coprime_mul_iff_right : Coprime k (m * n) \u2194 Coprime k m \u2227 Coprime k n", "start": [352, 1], "end": [353, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.gcd_left", "code": "theorem Coprime.gcd_left (k : Nat) (hmn : Coprime m n) : Coprime (gcd k m) n", "start": [355, 1], "end": [356, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.gcd_right", "code": "theorem Coprime.gcd_right (k : Nat) (hmn : Coprime m n) : Coprime m (gcd k n)", "start": [358, 1], "end": [359, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.gcd_both", "code": "theorem Coprime.gcd_both (k l : Nat) (hmn : Coprime m n) : Coprime (gcd k m) (gcd l n)", "start": [361, 1], "end": [362, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.mul_dvd_of_dvd_of_dvd", "code": "theorem Coprime.mul_dvd_of_dvd_of_dvd (hmn : Coprime m n) (hm : m \u2223 a) (hn : n \u2223 a) : m * n \u2223 a", "start": [364, 1], "end": [366, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_zero_left", "code": "@[simp] theorem coprime_zero_left (n : Nat) : Coprime 0 n \u2194 n = 1", "start": [368, 1], "end": [368, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_zero_right", "code": "@[simp] theorem coprime_zero_right (n : Nat) : Coprime n 0 \u2194 n = 1", "start": [370, 1], "end": [370, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_one_left", "code": "theorem coprime_one_left : \u2200 n, Coprime 1 n", "start": [372, 1], "end": [372, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_one_right", "code": "theorem coprime_one_right : \u2200 n, Coprime n 1", "start": [374, 1], "end": [374, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_one_left_eq_true", "code": "@[simp] theorem coprime_one_left_eq_true (n) : Coprime 1 n = True", "start": [376, 1], "end": [376, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_one_right_eq_true", "code": "@[simp] theorem coprime_one_right_eq_true (n) : Coprime n 1 = True", "start": [378, 1], "end": [378, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_self", "code": "@[simp] theorem coprime_self (n : Nat) : Coprime n n \u2194 n = 1", "start": [380, 1], "end": [380, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.pow_left", "code": "theorem Coprime.pow_left (n : Nat) (H1 : Coprime m k) : Coprime (m ^ n) k", "start": [382, 1], "end": [385, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.pow_right", "code": "theorem Coprime.pow_right (n : Nat) (H1 : Coprime k m) : Coprime k (m ^ n)", "start": [387, 1], "end": [388, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.pow", "code": "theorem Coprime.pow {k l : Nat} (m n : Nat) (H1 : Coprime k l) : Coprime (k ^ m) (l ^ n)", "start": [390, 1], "end": [391, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.eq_one_of_dvd", "code": "theorem Coprime.eq_one_of_dvd {k m : Nat} (H : Coprime k m) (d : k \u2223 m) : k = 1", "start": [393, 1], "end": [394, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_dvd_and_dvd_of_dvd_prod", "code": "def prod_dvd_and_dvd_of_dvd_prod {k m n : Nat} (H : k \u2223 m * n) :\n    {d : {m' // m' \u2223 m} \u00d7 {n' // n' \u2223 n} // k = d.1.val * d.2.val} :=\n  if h0 : gcd k m = 0 then\n    \u27e8\u27e8\u27e80, eq_zero_of_gcd_eq_zero_right h0 \u25b8 Nat.dvd_refl 0\u27e9,\n      \u27e8n, Nat.dvd_refl n\u27e9\u27e9,\n      eq_zero_of_gcd_eq_zero_left h0 \u25b8 (Nat.zero_mul n).symm\u27e9\n  else by\n    have hd : gcd k m * (k / gcd k m) = k := Nat.mul_div_cancel' (gcd_dvd_left k m)\n    refine \u27e8\u27e8\u27e8gcd k m, gcd_dvd_right k m\u27e9, \u27e8k / gcd k m, ?_\u27e9\u27e9, hd.symm\u27e9\n    apply Nat.dvd_of_mul_dvd_mul_left (Nat.pos_of_ne_zero h0)\n    rw [hd, \u2190 gcd_mul_right]\n    exact Nat.dvd_gcd (Nat.dvd_mul_right _ _) H", "start": [396, 1], "end": [408, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_dvd_mul_gcd", "code": "theorem gcd_mul_dvd_mul_gcd (k m n : Nat) : gcd k (m * n) \u2223 gcd k m * gcd k n", "start": [410, 1], "end": [417, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.gcd_mul", "code": "theorem Coprime.gcd_mul (k : Nat) (h : Coprime m n) : gcd k (m * n) = gcd k m * gcd k n", "start": [419, 1], "end": [424, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul", "code": "theorem gcd_mul_gcd_of_coprime_of_mul_eq_mul\n    (cop : Coprime c d) (h : a * b = c * d) : a.gcd c * b.gcd c = c", "start": [426, 1], "end": [434, 56], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab.lean", "lake-packages/lean4/src/lean/Lean/CoreM.lean", "lake-packages/lean4/src/lean/Lean/MetavarContext.lean", "lake-packages/lean4/src/lean/Lean/Data.lean", "lake-packages/lean4/src/lean/Lean/LocalContext.lean", "lake-packages/lean4/src/lean/Lean/Modifiers.lean", "lake-packages/lean4/src/lean/Lean/LoadDynlib.lean", "lake-packages/lean4/src/lean/Lean/InternalExceptionId.lean", "lake-packages/lean4/src/lean/Lean/ResolveName.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Structure.lean", "lake-packages/lean4/src/lean/Lean/Runtime.lean", "lake-packages/lean4/src/lean/Lean/Widget.lean", "lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Lean/Linter.lean", "lake-packages/lean4/src/lean/Lean/Meta.lean", "lake-packages/lean4/src/lean/Lean/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Log.lean", "lake-packages/lean4/src/lean/Lean/Eval.lean", "lake-packages/lean4/src/lean/Lean/DocString.lean", "lake-packages/lean4/src/lean/Lean/LazyInitExtension.lean", "lake-packages/lean4/src/lean/Lean/Parser.lean", "lake-packages/lean4/src/lean/Lean/Class.lean", "lake-packages/lean4/src/lean/Lean/Server.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Lean/SubExpr.lean", "lake-packages/lean4/src/lean/Lean/ReducibilityAttrs.lean", "lake-packages/lean4/src/lean/Lean/Util.lean", "lake-packages/lean4/src/lean/Lean/ProjFns.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Lean/Compiler.lean", "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean", "lake-packages/lean4/src/lean/Lean/AuxRecursor.lean"], "premises": []}
{"path": "lake-packages/aesop/Aesop/Rule/Name.lean", "imports": ["lake-packages/aesop/Aesop/Util/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.PhaseName", "code": "inductive PhaseName\n  | norm\n  | safe\n  | \u00abunsafe\u00bb\n  deriving Inhabited, BEq, Hashable", "start": [14, 1], "end": [18, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.ScopeName", "code": "inductive ScopeName\n  | global\n  | \u00ablocal\u00bb\n  deriving Inhabited, BEq, Hashable", "start": [36, 1], "end": [39, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuilderName", "code": "inductive BuilderName\n  | apply\n  | cases\n  | constructors\n  | destruct\n  | forward\n  | simp\n  | tactic\n  | unfold\n  deriving Inhabited, BEq, Hashable", "start": [56, 1], "end": [65, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleName", "code": "structure RuleName where\n  name : Name\n  builder : BuilderName\n  phase : PhaseName\n  scope : ScopeName\n  protected hash : UInt64 :=\n    mixHash (hash name) $ mixHash (hash builder) $ mixHash (hash phase)\n      (hash scope)\n  deriving Inhabited", "start": [91, 1], "end": [99, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleName.compare", "code": "protected def compare : (_ _ : RuleName) \u2192 Ordering :=\n  compareLex (compareOn (\u00b7.builder)) $\n  compareLex (compareOn (\u00b7.phase)) $\n  compareLex (compareOn (\u00b7.scope)) $\n  (\u03bb n\u2081 n\u2082 => n\u2081.name.cmp n\u2082.name)", "start": [111, 1], "end": [115, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleName.quickCompare", "code": "protected def quickCompare (n\u2081 n\u2082 : RuleName) : Ordering :=\n  match compare n\u2081.hash n\u2082.hash with\n  | Ordering.eq => n\u2081.compare n\u2082\n  | ord => ord", "start": [117, 1], "end": [120, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.DisplayRuleName", "code": "inductive DisplayRuleName\n  | ruleName (n : RuleName)\n  | normSimp\n  | normUnfold\n  deriving Inhabited, BEq, Ord, Hashable", "start": [133, 1], "end": [137, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleIdent", "code": "inductive RuleIdent\n  | const (decl : Name)\n  | fvar (userName : Name)\n  deriving Inhabited, BEq, Hashable", "start": [150, 1], "end": [153, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleIdent.name", "code": "def name : RuleIdent \u2192 Name\n  | const decl => decl\n  | fvar userName => userName", "start": [162, 1], "end": [164, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleIdent.scope", "code": "def scope : RuleIdent \u2192 ScopeName\n  | const .. => ScopeName.global\n  | fvar .. => ScopeName.local", "start": [166, 1], "end": [168, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleIdent.type", "code": "def type : RuleIdent \u2192 MetaM Expr\n  | const c => return (\u2190 getConstInfo c).type\n  | fvar userName => return (\u2190 getLocalDeclFromUserName userName).type", "start": [170, 1], "end": [172, 71], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleIdent.toRuleName", "code": "def toRuleName (phase : PhaseName) (builder : BuilderName)\n    (i : RuleIdent) : RuleName where\n  phase := phase\n  builder := builder\n  scope := i.scope\n  name := i.name", "start": [174, 1], "end": [179, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleName.toRuleIdent", "code": "def toRuleIdent (i : RuleName) : RuleIdent :=\n  match i.scope with\n  | ScopeName.global => RuleIdent.const i.name\n  | ScopeName.local => RuleIdent.fvar i.name", "start": [186, 1], "end": [189, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/RuleTac/Basic.lean", "imports": ["lake-packages/std/Std/Lean/Meta/SavedState.lean", "lake-packages/aesop/Aesop/Index/Basic.lean", "lake-packages/aesop/Aesop/Options.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Percent.lean", "lake-packages/aesop/Aesop/Script.lean"], "premises": [{"full_name": "Aesop.RuleTacInput", "code": "structure RuleTacInput where\n  goal : MVarId\n  mvars : UnorderedArraySet MVarId\n  indexMatchLocations : UnorderedArraySet IndexMatchLocation\n  options : Options'\n  deriving Inhabited", "start": [22, 1], "end": [35, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleApplication", "code": "structure RuleApplication where\n  goals : Array MVarId\n  postState : Meta.SavedState\n  scriptBuilder? : Option RuleTacScriptBuilder\n  successProbability? : Option Percent", "start": [37, 1], "end": [54, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleApplication.check", "code": "def check (r : RuleApplication) : MetaM (Option MessageData) :=\n  r.postState.runMetaM' do\n    for goal in r.goals do\n      if \u2190 goal.isAssignedOrDelayedAssigned then\n        return some m!\"subgoal metavariable {goal.name} is already assigned.\"\n    return none", "start": [58, 1], "end": [63, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTacOutput", "code": "structure RuleTacOutput where\n  applications : Array RuleApplication\n  deriving Inhabited", "start": [67, 1], "end": [72, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac", "code": "def RuleTac := RuleTacInput \u2192 MetaM RuleTacOutput", "start": [74, 1], "end": [77, 50], "kind": "commanddeclaration"}, {"full_name": "Aesop.SingleRuleTac", "code": "def SingleRuleTac :=\n  RuleTacInput \u2192 MetaM (Array MVarId \u00d7 Option RuleTacScriptBuilder \u00d7 Option Percent)", "start": [82, 1], "end": [86, 85], "kind": "commanddeclaration"}, {"full_name": "Aesop.SingleRuleTac.toRuleTac", "code": "@[inline]\ndef SingleRuleTac.toRuleTac (t : SingleRuleTac) : RuleTac := \u03bb input => do\n  let (goals, scriptBuilder?, successProbability?) \u2190 t input\n  let postState \u2190 saveState\n  return \u27e8#[{ postState, goals, scriptBuilder?, successProbability? }]\u27e9", "start": [88, 1], "end": [92, 72], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.ofSingleRuleTac", "code": "@[inline]\ndef RuleTac.ofSingleRuleTac := SingleRuleTac.toRuleTac", "start": [94, 1], "end": [95, 55], "kind": "commanddeclaration"}, {"full_name": "Aesop.TacGen", "code": "abbrev TacGen := MVarId \u2192 MetaM (Array (String \u00d7 Float))", "start": [97, 1], "end": [107, 57], "kind": "commanddeclaration"}, {"full_name": "Aesop.CasesPattern", "code": "def CasesPattern := AbstractMVarsResult\n  deriving Inhabited", "start": [111, 1], "end": [112, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.CasesTarget", "code": "inductive CasesTarget\n  | decl (decl : Name)\n  | patterns (patterns : Array CasesPattern)\n  deriving Inhabited", "start": [114, 1], "end": [117, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTacDescr", "code": "inductive RuleTacDescr\n  | applyConst (decl     : Name) (md : TransparencyMode)\n  | applyFVar  (userName : Name) (md : TransparencyMode)\n  | constructors (constructorNames : Array Name) (md : TransparencyMode)\n  | forwardConst (decl     : Name) (immediate : UnorderedArraySet Nat)\n      (clear : Bool) (md : TransparencyMode)\n  | forwardFVar  (userName : Name) (immediate : UnorderedArraySet Nat)\n      (clear : Bool) (md : TransparencyMode)\n  | cases (target : CasesTarget) (md : TransparencyMode)\n      (isRecursiveType : Bool)\n  | tacticM (decl : Name)\n  | ruleTac (decl : Name)\n  | tacGen (decl : Name)\n  | singleRuleTac (decl : Name)\n  | preprocess\n  deriving Inhabited", "start": [119, 1], "end": [134, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTacDescr.isGlobal", "code": "def isGlobal : RuleTacDescr \u2192 Bool\n  | applyConst .. => true\n  | applyFVar .. => false\n  | constructors .. => true\n  | forwardConst .. => true\n  | forwardFVar .. => false\n  | cases .. => true\n  | tacticM .. => true\n  | ruleTac .. => true\n  | tacGen .. => true\n  | singleRuleTac .. => true\n  | preprocess => true", "start": [138, 1], "end": [149, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tracing.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/aesop/Aesop/Util/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.TraceOption", "code": "structure TraceOption where\n  traceClass : Name\n  option : Lean.Option Bool\n  deriving Inhabited", "start": [15, 1], "end": [18, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.registerTraceOption", "code": "def registerTraceOption (traceName : Name) (descr : String) :\n    IO TraceOption := do\n  let option \u2190 Option.register (`trace.aesop ++ traceName) {\n    defValue := false\n    group := \"trace\"\n    descr\n  }\n  return { traceClass := `aesop ++ traceName, option }", "start": [20, 1], "end": [27, 55], "kind": "commanddeclaration"}, {"full_name": "Aesop.TraceOption.isEnabled", "code": "def isEnabled [Monad m] [MonadOptions m] (opt : TraceOption) : m Bool :=\n  return opt.option.get (\u2190 getOptions)", "start": [31, 1], "end": [32, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.TraceOption.withEnabled", "code": "def withEnabled [Monad m] [MonadWithOptions m] (opt : TraceOption) (k : m \u03b1) :\n    m \u03b1 := do\n  withOptions (\u03bb opts => opt.option.set opts true) k", "start": [34, 1], "end": [36, 53], "kind": "commanddeclaration"}, {"full_name": "Aesop.isFullyQualifiedGlobalName", "code": "private def isFullyQualifiedGlobalName (n : Name) : MacroM Bool :=\n  return (\u2190 Macro.resolveGlobalName n).any (\u00b7.fst == n)", "start": [68, 1], "end": [69, 56], "kind": "commanddeclaration"}, {"full_name": "Aesop.resolveTraceOption", "code": "def resolveTraceOption (stx : Ident) : MacroM Name :=\n  withRef stx do\n    let n := stx.getId\n    let fqn := ``TraceOption ++ n\n    if \u2190 isFullyQualifiedGlobalName fqn then\n      return fqn\n    else\n      return n", "start": [71, 1], "end": [78, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.ruleSuccessEmoji", "code": "def ruleSuccessEmoji    := checkEmoji", "start": [106, 1], "end": [106, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.ruleFailureEmoji", "code": "def ruleFailureEmoji    := crossEmoji", "start": [107, 1], "end": [107, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.ruleProvedEmoji", "code": "def ruleProvedEmoji     := \"\ud83c\udfc1\"", "start": [108, 1], "end": [108, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.ruleErrorEmoji", "code": "def ruleErrorEmoji      := bombEmoji", "start": [109, 1], "end": [109, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.rulePostponedEmoji", "code": "def rulePostponedEmoji  := \"\u23f3\ufe0f\"", "start": [110, 1], "end": [110, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.ruleSkippedEmoji", "code": "def ruleSkippedEmoji    := \"\u23e9\ufe0f\"", "start": [111, 1], "end": [111, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.nodeUnknownEmoji", "code": "def nodeUnknownEmoji    := \"\u2753\ufe0f\"", "start": [112, 1], "end": [112, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.nodeProvedEmoji", "code": "def nodeProvedEmoji     := ruleProvedEmoji", "start": [113, 1], "end": [113, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.nodeUnprovableEmoji", "code": "def nodeUnprovableEmoji := ruleFailureEmoji", "start": [114, 1], "end": [114, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.newNodeEmoji", "code": "def newNodeEmoji        := \"\ud83c\udd95\"", "start": [115, 1], "end": [115, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.exceptRuleResultToEmoji", "code": "def exceptRuleResultToEmoji (toEmoji : \u03b1 \u2192 String) : Except \u03b5 \u03b1 \u2192 String\n  | .error _ => ruleFailureEmoji\n  | .ok r => toEmoji r", "start": [117, 1], "end": [119, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.withAesopTraceNode", "code": "@[inline, always_inline]\ndef withAesopTraceNode (opt : TraceOption)\n    (msg : Except \u03b5 \u03b1 \u2192 m MessageData) (k : m \u03b1) (collapsed := true) : m \u03b1 :=\n  withTraceNode opt.traceClass msg k collapsed", "start": [126, 1], "end": [129, 47], "kind": "commanddeclaration"}, {"full_name": "Aesop.withConstAesopTraceNode", "code": "@[inline, always_inline]\ndef withConstAesopTraceNode (opt : TraceOption) (msg : m MessageData) (k : m \u03b1)\n    (collapsed := true) : m \u03b1 :=\n  withAesopTraceNode opt (\u03bb _ => msg) k collapsed", "start": [131, 1], "end": [134, 50], "kind": "commanddeclaration"}, {"full_name": "Aesop.traceSimpTheoremTreeContents", "code": "def traceSimpTheoremTreeContents (t : SimpTheoremTree) (opt : TraceOption) :\n    CoreM Unit := do\n  if ! (\u2190 opt.isEnabled) then\n    return\n  for e in t.values.map (toString \u00b7.origin.key) |>.qsortOrd do\n    aesop_trace![opt] e", "start": [138, 1], "end": [143, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.traceSimpTheorems", "code": "def traceSimpTheorems (s : SimpTheorems) (opt : TraceOption) : CoreM Unit := do\n  if ! (\u2190 opt.isEnabled) then\n    return\n  withConstAesopTraceNode opt (return \"Erased entries\") do\n    aesop_trace![opt] \"(Note: even if these entries appear in the sections below, they will not be used by simp.)\"\n    for e in PersistentHashSet.toArray s.erased |>.map (toString \u00b7.key) |>.qsortOrd do\n      aesop_trace![opt] e\n  withConstAesopTraceNode opt (return \"Pre lemmas\") do\n    traceSimpTheoremTreeContents s.pre opt\n  withConstAesopTraceNode opt (return \"Post lemmas\") do\n    traceSimpTheoremTreeContents s.post opt\n  withConstAesopTraceNode opt (return \"Constants to unfold\") do\n    for e in PersistentHashSet.toArray s.toUnfold |>.map toString |>.qsortOrd do\n      aesop_trace![opt] e", "start": [145, 1], "end": [158, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Meta/InstantiateMVars.lean", "imports": ["lake-packages/std/Std/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.instantiateMVarsInType", "code": "def instantiateMVarsInType [Monad m] [MonadMCtx m] [MonadError m]\n    (mvarId : MVarId) : m Expr := do\n  let mdecl \u2190 (\u2190 getMCtx).getExprMVarDecl mvarId\n  let type := mdecl.type\n  if type.hasMVar then\n    let type \u2190 instantiateMVars type\n    let mdecl := { mdecl with type }\n    modifyMCtx (\u00b7.declareExprMVar mvarId mdecl)\n    return type\n  else\n    return type", "start": [12, 1], "end": [26, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.instantiateMVarsInLocalDecl", "code": "def instantiateMVarsInLocalDecl [Monad m] [MonadMCtx m] [MonadError m]\n    (mvarId : MVarId) (fvarId : FVarId) : m LocalDecl := do\n  let mdecl \u2190 (\u2190 getMCtx).getExprMVarDecl mvarId\n  let (some ldecl) := mdecl.lctx.find? fvarId | throwError\n    \"unknown fvar '{fvarId.name}' (in local context of mvar '?{mvarId.name}')\"\n  let ldecl \u2190 Lean.instantiateLocalDeclMVars ldecl\n  let mdecl :=\n    { mdecl with lctx := mdecl.lctx.modifyLocalDecl fvarId \u03bb _ => ldecl }\n  modifyMCtx (\u00b7.declareExprMVar mvarId mdecl)\n  return ldecl", "start": [28, 1], "end": [41, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.instantiateMVarsInLocalContext", "code": "def instantiateMVarsInLocalContext [Monad m] [MonadMCtx m] [MonadError m]\n    (mvarId : MVarId) : m LocalContext := do\n  let mdecl \u2190 (\u2190 getMCtx).getExprMVarDecl mvarId\n  let lctx \u2190 instantiateLCtxMVars mdecl.lctx\n  modifyMCtx (\u00b7.declareExprMVar mvarId { mdecl with lctx })\n  return lctx", "start": [43, 1], "end": [52, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.instantiateMVars", "code": "def instantiateMVars [Monad m] [MonadMCtx m] [MonadError m] (mvarId : MVarId) :\n    m Unit := do\n  discard $ (\u2190 getMCtx).getExprMVarDecl mvarId\n    instantiateMVarDeclMVars mvarId", "start": [54, 1], "end": [63, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Sum/Basic.lean", "imports": ["lake-packages/std/Std/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sum.isLeft", "code": "def isLeft : \u03b1 \u2295 \u03b2 \u2192 Bool\n  | inl _ => true\n  | inr _ => false", "start": [50, 1], "end": [53, 19], "kind": "commanddeclaration"}, {"full_name": "Sum.isRight", "code": "def isRight : \u03b1 \u2295 \u03b2 \u2192 Bool\n  | inl _ => false\n  | inr _ => true", "start": [55, 1], "end": [58, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft", "code": "def getLeft : (ab : \u03b1 \u2295 \u03b2) \u2192 ab.isLeft \u2192 \u03b1\n  | inl a, _ => a", "start": [60, 1], "end": [62, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight", "code": "def getRight : (ab : \u03b1 \u2295 \u03b2) \u2192 ab.isRight \u2192 \u03b2\n  | inr b, _ => b", "start": [64, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft?", "code": "def getLeft? : \u03b1 \u2295 \u03b2 \u2192 Option \u03b1\n  | inl a => some a\n  | inr _ => none", "start": [68, 1], "end": [71, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight?", "code": "def getRight? : \u03b1 \u2295 \u03b2 \u2192 Option \u03b2\n  | inr b => some b\n  | inl _ => none", "start": [73, 1], "end": [76, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.isLeft_inl", "code": "@[simp] theorem isLeft_inl : (inl x : \u03b1 \u2295 \u03b2).isLeft = true", "start": [78, 1], "end": [78, 66], "kind": "commanddeclaration"}, {"full_name": "Sum.isLeft_inr", "code": "@[simp] theorem isLeft_inr : (inr x : \u03b1 \u2295 \u03b2).isLeft = false", "start": [79, 1], "end": [79, 67], "kind": "commanddeclaration"}, {"full_name": "Sum.isRight_inl", "code": "@[simp] theorem isRight_inl : (inl x : \u03b1 \u2295 \u03b2).isRight = false", "start": [80, 1], "end": [80, 69], "kind": "commanddeclaration"}, {"full_name": "Sum.isRight_inr", "code": "@[simp] theorem isRight_inr : (inr x : \u03b1 \u2295 \u03b2).isRight = true", "start": [81, 1], "end": [81, 68], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft_inl", "code": "@[simp] theorem getLeft_inl (h : (inl x : \u03b1 \u2295 \u03b2).isLeft) : (inl x).getLeft h = x", "start": [83, 1], "end": [83, 88], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight_inr", "code": "@[simp] theorem getRight_inr (h : (inr x : \u03b1 \u2295 \u03b2).isRight) : (inr x).getRight h = x", "start": [84, 1], "end": [84, 91], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft?_inl", "code": "@[simp] theorem getLeft?_inl : (inl x : \u03b1 \u2295 \u03b2).getLeft? = some x", "start": [86, 1], "end": [86, 72], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft?_inr", "code": "@[simp] theorem getLeft?_inr : (inr x : \u03b1 \u2295 \u03b2).getLeft? = none", "start": [87, 1], "end": [87, 70], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight?_inl", "code": "@[simp] theorem getRight?_inl : (inl x : \u03b1 \u2295 \u03b2).getRight? = none", "start": [88, 1], "end": [88, 72], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight?_inr", "code": "@[simp] theorem getRight?_inr : (inr x : \u03b1 \u2295 \u03b2).getRight? = some x", "start": [89, 1], "end": [89, 74], "kind": "commanddeclaration"}, {"full_name": "Sum.elim", "code": "protected def elim {\u03b1 \u03b2 \u03b3} (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) : \u03b1 \u2295 \u03b2 \u2192 \u03b3 :=\n  fun x => Sum.casesOn x f g", "start": [93, 1], "end": [95, 29], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_inl", "code": "@[simp] theorem elim_inl (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) (x : \u03b1) :\n    Sum.elim f g (inl x) = f x", "start": [97, 1], "end": [98, 38], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_inr", "code": "@[simp] theorem elim_inr (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) (x : \u03b2) :\n    Sum.elim f g (inr x) = g x", "start": [100, 1], "end": [101, 38], "kind": "commanddeclaration"}, {"full_name": "Sum.map", "code": "protected def map (f : \u03b1 \u2192 \u03b1') (g : \u03b2 \u2192 \u03b2') : \u03b1 \u2295 \u03b2 \u2192 \u03b1' \u2295 \u03b2' :=\n  Sum.elim (inl \u2218 f) (inr \u2218 g)", "start": [103, 1], "end": [105, 31], "kind": "commanddeclaration"}, {"full_name": "Sum.map_inl", "code": "@[simp] theorem map_inl (f : \u03b1 \u2192 \u03b1') (g : \u03b2 \u2192 \u03b2') (x : \u03b1) : (inl x).map f g = inl (f x)", "start": [107, 1], "end": [107, 95], "kind": "commanddeclaration"}, {"full_name": "Sum.map_inr", "code": "@[simp] theorem map_inr (f : \u03b1 \u2192 \u03b1') (g : \u03b2 \u2192 \u03b2') (x : \u03b2) : (inr x).map f g = inr (g x)", "start": [109, 1], "end": [109, 95], "kind": "commanddeclaration"}, {"full_name": "Sum.swap", "code": "def swap : \u03b1 \u2295 \u03b2 \u2192 \u03b2 \u2295 \u03b1 := Sum.elim inr inl", "start": [111, 1], "end": [112, 45], "kind": "commanddeclaration"}, {"full_name": "Sum.swap_inl", "code": "@[simp] theorem swap_inl : swap (inl x : \u03b1 \u2295 \u03b2) = inr x", "start": [114, 1], "end": [114, 63], "kind": "commanddeclaration"}, {"full_name": "Sum.swap_inr", "code": "@[simp] theorem swap_inr : swap (inr x : \u03b1 \u2295 \u03b2) = inl x", "start": [116, 1], "end": [116, 63], "kind": "commanddeclaration"}, {"full_name": "Sum.LiftRel", "code": "inductive LiftRel (r : \u03b1 \u2192 \u03b3 \u2192 Prop) (s : \u03b2 \u2192 \u03b4 \u2192 Prop) : \u03b1 \u2295 \u03b2 \u2192 \u03b3 \u2295 \u03b4 \u2192 Prop\n  \n  | protected inl {a c} : r a c \u2192 LiftRel r s (inl a) (inl c)\n  \n  | protected inr {b d} : s b d \u2192 LiftRel r s (inr b) (inr d)", "start": [120, 1], "end": [126, 62], "kind": "commanddeclaration"}, {"full_name": "Sum.liftRel_inl_inl", "code": "@[simp] theorem liftRel_inl_inl : LiftRel r s (inl a) (inl c) \u2194 r a c", "start": [128, 1], "end": [129, 49], "kind": "commanddeclaration"}, {"full_name": "Sum.not_liftRel_inl_inr", "code": "@[simp] theorem not_liftRel_inl_inr : \u00acLiftRel r s (inl a) (inr d)", "start": [131, 1], "end": [131, 75], "kind": "commanddeclaration"}, {"full_name": "Sum.not_liftRel_inr_inl", "code": "@[simp] theorem not_liftRel_inr_inl : \u00acLiftRel r s (inr b) (inl c)", "start": [133, 1], "end": [133, 75], "kind": "commanddeclaration"}, {"full_name": "Sum.liftRel_inr_inr", "code": "@[simp] theorem liftRel_inr_inr : LiftRel r s (inr b) (inr d) \u2194 s b d", "start": [135, 1], "end": [136, 49], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex", "code": "inductive Lex (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : \u03b1 \u2295 \u03b2 \u2192 \u03b1 \u2295 \u03b2 \u2192 Prop\n  \n  | protected inl {a\u2081 a\u2082} (h : r a\u2081 a\u2082) : Lex r s (inl a\u2081) (inl a\u2082)\n  \n  | protected inr {b\u2081 b\u2082} (h : s b\u2081 b\u2082) : Lex r s (inr b\u2081) (inr b\u2082)\n  \n  | sep (a b) : Lex r s (inl a) (inr b)", "start": [150, 1], "end": [158, 40], "kind": "commanddeclaration"}, {"full_name": "Sum.lex_inl_inl", "code": "@[simp] theorem lex_inl_inl : Lex r s (inl a\u2081) (inl a\u2082) \u2194 r a\u2081 a\u2082", "start": [162, 1], "end": [163, 45], "kind": "commanddeclaration"}, {"full_name": "Sum.lex_inr_inr", "code": "@[simp] theorem lex_inr_inr : Lex r s (inr b\u2081) (inr b\u2082) \u2194 s b\u2081 b\u2082", "start": [165, 1], "end": [166, 45], "kind": "commanddeclaration"}, {"full_name": "Sum.lex_inr_inl", "code": "@[simp] theorem lex_inr_inl : \u00acLex r s (inr b) (inl a)", "start": [168, 1], "end": [168, 63], "kind": "commanddeclaration"}, {"full_name": "Sum.instDecidableRelSumLex", "code": "instance instDecidableRelSumLex [DecidableRel r] [DecidableRel s] : DecidableRel (Lex r s)\n  | inl _, inl _ => decidable_of_iff' _ lex_inl_inl\n  | inl _, inr _ => Decidable.isTrue (Lex.sep _ _)\n  | inr _, inl _ => Decidable.isFalse lex_inr_inl\n  | inr _, inr _ => decidable_of_iff' _ lex_inr_inr", "start": [170, 1], "end": [174, 52], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/String/Lemmas.lean", "imports": ["lake-packages/std/Std/Data/String/Basic.lean", "lake-packages/std/Std/Tactic/Simpa.lean", "lake-packages/std/Std/Tactic/Ext/Attr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/List/Lemmas.lean", "lake-packages/std/Std/Data/Char.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean"], "premises": [{"full_name": "Char.length_toString", "code": "@[simp] theorem Char.length_toString (c : Char) : c.toString.length = 1", "start": [13, 1], "end": [13, 79], "kind": "commanddeclaration"}, {"full_name": "String.ext", "code": "@[ext] theorem ext {s\u2081 s\u2082 : String} (h : s\u2081.data = s\u2082.data) : s\u2081 = s\u2082", "start": [17, 1], "end": [18, 53], "kind": "commanddeclaration"}, {"full_name": "String.ext_iff", "code": "theorem ext_iff {s\u2081 s\u2082 : String} : s\u2081 = s\u2082 \u2194 s\u2081.data = s\u2082.data", "start": [20, 1], "end": [20, 90], "kind": "commanddeclaration"}, {"full_name": "String.default_eq", "code": "@[simp] theorem default_eq : default = \"\"", "start": [22, 1], "end": [22, 49], "kind": "commanddeclaration"}, {"full_name": "String.str_eq", "code": "@[simp] theorem str_eq : str = push", "start": [24, 1], "end": [24, 43], "kind": "commanddeclaration"}, {"full_name": "String.mk_length", "code": "@[simp] theorem mk_length (s : List Char) : (String.mk s).length = s.length", "start": [26, 1], "end": [26, 83], "kind": "commanddeclaration"}, {"full_name": "String.length_empty", "code": "@[simp] theorem length_empty : \"\".length = 0", "start": [28, 1], "end": [28, 52], "kind": "commanddeclaration"}, {"full_name": "String.length_singleton", "code": "@[simp] theorem length_singleton (c : Char) : (String.singleton c).length = 1", "start": [30, 1], "end": [30, 85], "kind": "commanddeclaration"}, {"full_name": "String.length_push", "code": "@[simp] theorem length_push (c : Char) : (String.push s c).length = s.length + 1", "start": [32, 1], "end": [34, 6], "kind": "commanddeclaration"}, {"full_name": "String.data_push", "code": "@[simp] theorem data_push (s : String) (c : Char) : (s.push c).1 = s.1 ++ [c]", "start": [36, 1], "end": [36, 85], "kind": "commanddeclaration"}, {"full_name": "String.data_append", "code": "@[simp] theorem data_append (s t : String) : (s ++ t).1 = s.1 ++ t.1", "start": [38, 1], "end": [38, 76], "kind": "commanddeclaration"}, {"full_name": "String.lt_iff", "code": "theorem lt_iff (s t : String) : s < t \u2194 s.1 < t.1", "start": [42, 1], "end": [42, 58], "kind": "commanddeclaration"}, {"full_name": "String.add_csize_pos", "code": "private theorem add_csize_pos : 0 < i + csize c", "start": [44, 1], "end": [45, 36], "kind": "commanddeclaration"}, {"full_name": "String.ne_add_csize_add_self", "code": "private theorem ne_add_csize_add_self : i \u2260 n + csize c + i", "start": [47, 1], "end": [48, 54], "kind": "commanddeclaration"}, {"full_name": "String.ne_self_add_add_csize", "code": "private theorem ne_self_add_add_csize : i \u2260 i + (n + csize c)", "start": [50, 1], "end": [51, 55], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len", "code": "@[inline] def utf8Len : List Char \u2192 Nat := utf8ByteSize.go", "start": [53, 1], "end": [54, 59], "kind": "commanddeclaration"}, {"full_name": "String.utf8ByteSize.go_eq", "code": "@[simp] theorem utf8ByteSize.go_eq : utf8ByteSize.go = utf8Len", "start": [56, 1], "end": [56, 70], "kind": "commanddeclaration"}, {"full_name": "String.utf8ByteSize_mk", "code": "@[simp] theorem utf8ByteSize_mk (cs) : utf8ByteSize \u27e8cs\u27e9 = utf8Len cs", "start": [58, 1], "end": [58, 77], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_nil", "code": "@[simp] theorem utf8Len_nil : utf8Len [] = 0", "start": [60, 1], "end": [60, 52], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_cons", "code": "@[simp] theorem utf8Len_cons (c cs) : utf8Len (c :: cs) = utf8Len cs + csize c", "start": [62, 1], "end": [62, 86], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_append", "code": "@[simp] theorem utf8Len_append (cs\u2081 cs\u2082) : utf8Len (cs\u2081 ++ cs\u2082) = utf8Len cs\u2081 + utf8Len cs\u2082", "start": [64, 1], "end": [65, 49], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_reverseAux", "code": "@[simp] theorem utf8Len_reverseAux (cs\u2081 cs\u2082) :\n    utf8Len (cs\u2081.reverseAux cs\u2082) = utf8Len cs\u2081 + utf8Len cs\u2082", "start": [67, 1], "end": [69, 83], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_reverse", "code": "@[simp] theorem utf8Len_reverse (cs) : utf8Len cs.reverse = utf8Len cs", "start": [71, 1], "end": [71, 96], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_eq_zero", "code": "@[simp] theorem utf8Len_eq_zero : utf8Len l = 0 \u2194 l = []", "start": [73, 1], "end": [74, 48], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_le_of_sublist", "code": "theorem utf8Len_le_of_sublist : \u2200 {cs\u2081 cs\u2082}, cs\u2081 <+ cs\u2082 \u2192 utf8Len cs\u2081 \u2264 utf8Len cs\u2082", "start": [78, 1], "end": [81, 73], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_le_of_infix", "code": "theorem utf8Len_le_of_infix (h : cs\u2081 <:+: cs\u2082) : utf8Len cs\u2081 \u2264 utf8Len cs\u2082", "start": [83, 1], "end": [84, 34], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_le_of_suffix", "code": "theorem utf8Len_le_of_suffix (h : cs\u2081 <:+ cs\u2082) : utf8Len cs\u2081 \u2264 utf8Len cs\u2082", "start": [86, 1], "end": [87, 34], "kind": "commanddeclaration"}, {"full_name": "String.utf8Len_le_of_prefix", "code": "theorem utf8Len_le_of_prefix (h : cs\u2081 <+: cs\u2082) : utf8Len cs\u2081 \u2264 utf8Len cs\u2082", "start": [89, 1], "end": [90, 34], "kind": "commanddeclaration"}, {"full_name": "String.endPos_eq", "code": "@[simp] theorem endPos_eq (cs : List Char) : endPos \u27e8cs\u27e9 = \u27e8utf8Len cs\u27e9", "start": [93, 1], "end": [93, 79], "kind": "commanddeclaration"}, {"full_name": "String.Pos.byteIdx_zero", "code": "@[simp] theorem byteIdx_zero : (0 : Pos).byteIdx = 0", "start": [97, 1], "end": [97, 60], "kind": "commanddeclaration"}, {"full_name": "String.Pos.byteIdx_mk", "code": "theorem byteIdx_mk (n : Nat) : byteIdx \u27e8n\u27e9 = n", "start": [99, 1], "end": [99, 54], "kind": "commanddeclaration"}, {"full_name": "String.Pos.mk_zero", "code": "@[simp] theorem mk_zero : \u27e80\u27e9 = (0 : Pos)", "start": [101, 1], "end": [101, 49], "kind": "commanddeclaration"}, {"full_name": "String.Pos.mk_byteIdx", "code": "@[simp] theorem mk_byteIdx (p : Pos) : \u27e8p.byteIdx\u27e9 = p", "start": [103, 1], "end": [103, 62], "kind": "commanddeclaration"}, {"full_name": "String.Pos.ext", "code": "@[ext] theorem ext {i\u2081 i\u2082 : Pos} (h : i\u2081.byteIdx = i\u2082.byteIdx) : i\u2081 = i\u2082", "start": [105, 1], "end": [106, 56], "kind": "commanddeclaration"}, {"full_name": "String.Pos.ext_iff", "code": "theorem ext_iff {i\u2081 i\u2082 : Pos} : i\u2081 = i\u2082 \u2194 i\u2081.byteIdx = i\u2082.byteIdx", "start": [108, 1], "end": [108, 93], "kind": "commanddeclaration"}, {"full_name": "String.Pos.add_byteIdx", "code": "@[simp] theorem add_byteIdx (p\u2081 p\u2082 : Pos) : (p\u2081 + p\u2082).byteIdx = p\u2081.byteIdx + p\u2082.byteIdx", "start": [110, 1], "end": [110, 95], "kind": "commanddeclaration"}, {"full_name": "String.Pos.add_eq", "code": "theorem add_eq (p\u2081 p\u2082 : Pos) : p\u2081 + p\u2082 = \u27e8p\u2081.byteIdx + p\u2082.byteIdx\u27e9", "start": [112, 1], "end": [112, 74], "kind": "commanddeclaration"}, {"full_name": "String.Pos.sub_byteIdx", "code": "@[simp] theorem sub_byteIdx (p\u2081 p\u2082 : Pos) : (p\u2081 - p\u2082).byteIdx = p\u2081.byteIdx - p\u2082.byteIdx", "start": [114, 1], "end": [114, 95], "kind": "commanddeclaration"}, {"full_name": "String.Pos.sub_eq", "code": "theorem sub_eq (p\u2081 p\u2082 : Pos) : p\u2081 - p\u2082 = \u27e8p\u2081.byteIdx - p\u2082.byteIdx\u27e9", "start": [116, 1], "end": [116, 74], "kind": "commanddeclaration"}, {"full_name": "String.Pos.addChar_byteIdx", "code": "@[simp] theorem addChar_byteIdx (p : Pos) (c : Char) : (p + c).byteIdx = p.byteIdx + csize c", "start": [118, 1], "end": [118, 100], "kind": "commanddeclaration"}, {"full_name": "String.Pos.addChar_eq", "code": "theorem addChar_eq (p : Pos) (c : Char) : p + c = \u27e8p.byteIdx + csize c\u27e9", "start": [120, 1], "end": [120, 79], "kind": "commanddeclaration"}, {"full_name": "String.Pos.zero_addChar_byteIdx", "code": "theorem zero_addChar_byteIdx (c : Char) : ((0 : Pos) + c).byteIdx = csize c", "start": [122, 1], "end": [123, 58], "kind": "commanddeclaration"}, {"full_name": "String.Pos.zero_addChar_eq", "code": "theorem zero_addChar_eq (c : Char) : (0 : Pos) + c = \u27e8csize c\u27e9", "start": [125, 1], "end": [125, 97], "kind": "commanddeclaration"}, {"full_name": "String.Pos.addChar_right_comm", "code": "theorem addChar_right_comm (p : Pos) (c\u2081 c\u2082 : Char) : p + c\u2081 + c\u2082 = p + c\u2082 + c\u2081", "start": [127, 1], "end": [130, 27], "kind": "commanddeclaration"}, {"full_name": "String.Pos.lt_addChar", "code": "theorem lt_addChar (p : Pos) (c : Char) : p < p + c", "start": [132, 1], "end": [132, 93], "kind": "commanddeclaration"}, {"full_name": "String.Pos.ne_of_lt", "code": "theorem ne_of_lt {i\u2081 i\u2082 : Pos} (h : i\u2081 < i\u2082) : i\u2081 \u2260 i\u2082", "start": [134, 1], "end": [134, 88], "kind": "commanddeclaration"}, {"full_name": "String.Pos.ne_of_gt", "code": "theorem ne_of_gt {i\u2081 i\u2082 : Pos} (h : i\u2081 < i\u2082) : i\u2082 \u2260 i\u2081", "start": [136, 1], "end": [136, 76], "kind": "commanddeclaration"}, {"full_name": "String.Pos.addString_byteIdx", "code": "@[simp] theorem addString_byteIdx (p : Pos) (s : String) :\n    (p + s).byteIdx = p.byteIdx + s.utf8ByteSize", "start": [138, 1], "end": [139, 56], "kind": "commanddeclaration"}, {"full_name": "String.Pos.addString_eq", "code": "theorem addString_eq (p : Pos) (s : String) : p + s = \u27e8p.byteIdx + s.utf8ByteSize\u27e9", "start": [141, 1], "end": [141, 90], "kind": "commanddeclaration"}, {"full_name": "String.Pos.zero_addString_byteIdx", "code": "theorem zero_addString_byteIdx (s : String) : ((0 : Pos) + s).byteIdx = s.utf8ByteSize", "start": [143, 1], "end": [144, 60], "kind": "commanddeclaration"}, {"full_name": "String.Pos.zero_ne_addChar", "code": "private theorem zero_ne_addChar {i : Pos} {c : Char} : 0 \u2260 i + c", "start": [146, 1], "end": [147, 25], "kind": "commanddeclaration"}, {"full_name": "String.Pos.zero_addString_eq", "code": "theorem zero_addString_eq (s : String) : (0 : Pos) + s = \u27e8s.utf8ByteSize\u27e9", "start": [149, 1], "end": [150, 32], "kind": "commanddeclaration"}, {"full_name": "String.Pos.le_iff", "code": "theorem le_iff {i\u2081 i\u2082 : Pos} : i\u2081 \u2264 i\u2082 \u2194 i\u2081.byteIdx \u2264 i\u2082.byteIdx", "start": [152, 1], "end": [152, 73], "kind": "commanddeclaration"}, {"full_name": "String.Pos.mk_le_mk", "code": "@[simp] theorem mk_le_mk {i\u2081 i\u2082 : Nat} : Pos.mk i\u2081 \u2264 Pos.mk i\u2082 \u2194 i\u2081 \u2264 i\u2082", "start": [154, 1], "end": [154, 81], "kind": "commanddeclaration"}, {"full_name": "String.Pos.lt_iff", "code": "theorem lt_iff {i\u2081 i\u2082 : Pos} : i\u2081 < i\u2082 \u2194 i\u2081.byteIdx < i\u2082.byteIdx", "start": [156, 1], "end": [156, 73], "kind": "commanddeclaration"}, {"full_name": "String.Pos.mk_lt_mk", "code": "@[simp] theorem mk_lt_mk {i\u2081 i\u2082 : Nat} : Pos.mk i\u2081 < Pos.mk i\u2082 \u2194 i\u2081 < i\u2082", "start": [158, 1], "end": [158, 81], "kind": "commanddeclaration"}, {"full_name": "String.Pos.Valid", "code": "def Valid (s : String) (p : Pos) : Prop :=\n  \u2203 cs cs', cs ++ cs' = s.1 \u2227 p.1 = utf8Len cs", "start": [160, 1], "end": [162, 47], "kind": "commanddeclaration"}, {"full_name": "String.Pos.valid_zero", "code": "@[simp] theorem valid_zero : Valid s 0", "start": [164, 1], "end": [164, 62], "kind": "commanddeclaration"}, {"full_name": "String.Pos.valid_endPos", "code": "@[simp] theorem valid_endPos : Valid s (endPos s)", "start": [166, 1], "end": [166, 77], "kind": "commanddeclaration"}, {"full_name": "String.Pos.Valid.mk", "code": "theorem Valid.mk (cs cs' : List Char) : Valid \u27e8cs ++ cs'\u27e9 \u27e8utf8Len cs\u27e9", "start": [168, 1], "end": [168, 94], "kind": "commanddeclaration"}, {"full_name": "String.Pos.Valid.le_endPos", "code": "theorem Valid.le_endPos : \u2200 {s p}, Valid s p \u2192 p \u2264 endPos s", "start": [170, 1], "end": [171, 64], "kind": "commanddeclaration"}, {"full_name": "String.endPos_eq_zero", "code": "theorem endPos_eq_zero : \u2200 (s : String), endPos s = 0 \u2194 s = \"\"", "start": [175, 1], "end": [176, 67], "kind": "commanddeclaration"}, {"full_name": "String.isEmpty_iff", "code": "theorem isEmpty_iff (s : String) : isEmpty s \u2194 s = \"\"", "start": [178, 1], "end": [179, 43], "kind": "commanddeclaration"}, {"full_name": "String.utf8InductionOn", "code": "def utf8InductionOn {motive : List Char \u2192 Pos \u2192 Sort u}\n    (s : List Char) (i p : Pos)\n    (nil : \u2200 i, motive [] i)\n    (eq  : \u2200 c cs, motive (c :: cs) p)\n    (ind : \u2200 (c : Char) cs i, i \u2260 p \u2192 motive cs (i + c) \u2192 motive (c :: cs) i) :\n    motive s i :=\n  match s with\n  | [] => nil i\n  | c::cs =>\n    if h : i = p then\n      h \u25b8 eq c cs\n    else ind c cs i h (utf8InductionOn cs (i + c) p nil eq ind)", "start": [181, 1], "end": [196, 64], "kind": "commanddeclaration"}, {"full_name": "String.utf8GetAux_add_right_cancel", "code": "theorem utf8GetAux_add_right_cancel (s : List Char) (i p n : Nat) :\n    utf8GetAux s \u27e8i + n\u27e9 \u27e8p + n\u27e9 = utf8GetAux s \u27e8i\u27e9 \u27e8p\u27e9", "start": [198, 1], "end": [207, 11], "kind": "commanddeclaration"}, {"full_name": "String.utf8GetAux_addChar_right_cancel", "code": "theorem utf8GetAux_addChar_right_cancel (s : List Char) (i p : Pos) (c : Char) :\n    utf8GetAux s (i + c) (p + c) = utf8GetAux s i p", "start": [209, 1], "end": [210, 86], "kind": "commanddeclaration"}, {"full_name": "String.utf8GetAux_of_valid", "code": "theorem utf8GetAux_of_valid (cs cs' : List Char) {i p : Nat} (hp : i + utf8Len cs = p) :\n    utf8GetAux (cs ++ cs') \u27e8i\u27e9 \u27e8p\u27e9 = cs'.headD default", "start": [212, 1], "end": [221, 49], "kind": "commanddeclaration"}, {"full_name": "String.get_of_valid", "code": "theorem get_of_valid (cs cs' : List Char) : get \u27e8cs ++ cs'\u27e9 \u27e8utf8Len cs\u27e9 = cs'.headD default", "start": [223, 1], "end": [224, 43], "kind": "commanddeclaration"}, {"full_name": "String.get_cons_addChar", "code": "theorem get_cons_addChar (c : Char) (cs : List Char) (i : Pos) :\n    get \u27e8c :: cs\u27e9 (i + c) = get \u27e8cs\u27e9 i", "start": [226, 1], "end": [228, 79], "kind": "commanddeclaration"}, {"full_name": "String.utf8GetAux?_of_valid", "code": "theorem utf8GetAux?_of_valid (cs cs' : List Char) {i p : Nat} (hp : i + utf8Len cs = p) :\n    utf8GetAux? (cs ++ cs') \u27e8i\u27e9 \u27e8p\u27e9 = cs'.head?", "start": [230, 1], "end": [239, 49], "kind": "commanddeclaration"}, {"full_name": "String.get?_of_valid", "code": "theorem get?_of_valid (cs cs' : List Char) : get? \u27e8cs ++ cs'\u27e9 \u27e8utf8Len cs\u27e9 = cs'.head?", "start": [241, 1], "end": [242, 44], "kind": "commanddeclaration"}, {"full_name": "String.get!_eq_get", "code": "@[simp] theorem get!_eq_get (s : String) (p : Pos) : get! s p = get s p", "start": [244, 1], "end": [244, 79], "kind": "commanddeclaration"}, {"full_name": "String.utf8SetAux_of_valid", "code": "theorem utf8SetAux_of_valid (c' : Char) (cs cs' : List Char) {i p : Nat} (hp : i + utf8Len cs = p) :\n    utf8SetAux c' (cs ++ cs') \u27e8i\u27e9 \u27e8p\u27e9 = cs ++ cs'.modifyHead fun _ => c'", "start": [246, 1], "end": [255, 49], "kind": "commanddeclaration"}, {"full_name": "String.set_of_valid", "code": "theorem set_of_valid (cs cs' : List Char) (c' : Char) :\n    set \u27e8cs ++ cs'\u27e9 \u27e8utf8Len cs\u27e9 c' = \u27e8cs ++ cs'.modifyHead fun _ => c'\u27e9", "start": [257, 1], "end": [259, 51], "kind": "commanddeclaration"}, {"full_name": "String.modify_of_valid", "code": "theorem modify_of_valid (cs cs' : List Char) :\n    modify \u27e8cs ++ cs'\u27e9 \u27e8utf8Len cs\u27e9 f = \u27e8cs ++ cs'.modifyHead f\u27e9", "start": [261, 1], "end": [263, 61], "kind": "commanddeclaration"}, {"full_name": "String.next_of_valid'", "code": "theorem next_of_valid' (cs cs' : List Char) :\n    next \u27e8cs ++ cs'\u27e9 \u27e8utf8Len cs\u27e9 = \u27e8utf8Len cs + csize (cs'.headD default)\u27e9", "start": [265, 1], "end": [267, 38], "kind": "commanddeclaration"}, {"full_name": "String.next_of_valid", "code": "theorem next_of_valid (cs : List Char) (c : Char) (cs' : List Char) :\n    next \u27e8cs ++ c :: cs'\u27e9 \u27e8utf8Len cs\u27e9 = \u27e8utf8Len cs + csize c\u27e9", "start": [269, 1], "end": [270, 85], "kind": "commanddeclaration"}, {"full_name": "String.lt_next'", "code": "theorem lt_next' (s : String) (p : Pos) : p < next s p", "start": [272, 1], "end": [272, 69], "kind": "commanddeclaration"}, {"full_name": "String.atEnd_iff", "code": "@[simp] theorem atEnd_iff (s : String) (p : Pos) : atEnd s p \u2194 s.endPos \u2264 p", "start": [274, 1], "end": [275, 23], "kind": "commanddeclaration"}, {"full_name": "String.valid_next", "code": "theorem valid_next {p : Pos} (h : p.Valid s) (h\u2082 : p < s.endPos) : (next s p).Valid s", "start": [277, 1], "end": [282, 45], "kind": "commanddeclaration"}, {"full_name": "String.utf8PrevAux_of_valid", "code": "theorem utf8PrevAux_of_valid {cs cs' : List Char} {c : Char} {i p : Nat}\n    (hp : i + (utf8Len cs + csize c) = p) :\n    utf8PrevAux (cs ++ c :: cs') \u27e8i\u27e9 \u27e8p\u27e9 = \u27e8i + utf8Len cs\u27e9", "start": [284, 1], "end": [294, 39], "kind": "commanddeclaration"}, {"full_name": "String.prev_of_valid", "code": "theorem prev_of_valid (cs : List Char) (c : Char) (cs' : List Char) :\n    prev \u27e8cs ++ c :: cs'\u27e9 \u27e8utf8Len cs + csize c\u27e9 = \u27e8utf8Len cs\u27e9", "start": [296, 1], "end": [299, 37], "kind": "commanddeclaration"}, {"full_name": "String.prev_of_valid'", "code": "theorem prev_of_valid' (cs cs' : List Char) :\n    prev \u27e8cs ++ cs'\u27e9 \u27e8utf8Len cs\u27e9 = \u27e8utf8Len cs.dropLast\u27e9", "start": [301, 1], "end": [305, 49], "kind": "commanddeclaration"}, {"full_name": "String.prev_zero", "code": "@[simp] theorem prev_zero (s : String) : prev s 0 = 0", "start": [307, 1], "end": [307, 61], "kind": "commanddeclaration"}, {"full_name": "String.front_eq", "code": "theorem front_eq (s : String) : front s = s.1.headD default", "start": [309, 1], "end": [310, 42], "kind": "commanddeclaration"}, {"full_name": "String.back_eq", "code": "theorem back_eq (s : String) : back s = s.1.getLastD default", "start": [312, 1], "end": [315, 71], "kind": "commanddeclaration"}, {"full_name": "String.atEnd_of_valid", "code": "theorem atEnd_of_valid (cs : List Char) (cs' : List Char) :\n    atEnd \u27e8cs ++ cs'\u27e9 \u27e8utf8Len cs\u27e9 \u2194 cs' = []", "start": [317, 1], "end": [320, 61], "kind": "commanddeclaration"}, {"full_name": "String.get'_eq", "code": "@[simp] theorem get'_eq (s : String) (p : Pos) (h) : get' s p h = get s p", "start": [322, 1], "end": [322, 81], "kind": "commanddeclaration"}, {"full_name": "String.next'_eq", "code": "@[simp] theorem next'_eq (s : String) (p : Pos) (h) : next' s p h = next s p", "start": [324, 1], "end": [324, 84], "kind": "commanddeclaration"}, {"full_name": "String.posOfAux_eq", "code": "theorem posOfAux_eq (s c) : posOfAux s c = findAux s (\u00b7 == c)", "start": [326, 1], "end": [326, 69], "kind": "commanddeclaration"}, {"full_name": "String.posOf_eq", "code": "theorem posOf_eq (s c) : posOf s c = find s (\u00b7 == c)", "start": [328, 1], "end": [328, 60], "kind": "commanddeclaration"}, {"full_name": "String.revPosOfAux_eq", "code": "theorem revPosOfAux_eq (s c) : revPosOfAux s c = revFindAux s (\u00b7 == c)", "start": [330, 1], "end": [330, 78], "kind": "commanddeclaration"}, {"full_name": "String.revPosOf_eq", "code": "theorem revPosOf_eq (s c) : revPosOf s c = revFind s (\u00b7 == c)", "start": [332, 1], "end": [332, 69], "kind": "commanddeclaration"}, {"full_name": "String.findAux_of_valid", "code": "@[nolint unusedHavesSuffices] theorem findAux_of_valid (p) : \u2200 l m r,\n    findAux \u27e8l ++ m ++ r\u27e9 p \u27e8utf8Len l + utf8Len m\u27e9 \u27e8utf8Len l\u27e9 =\n    \u27e8utf8Len l + utf8Len (m.takeWhile (!p \u00b7))\u27e9", "start": [334, 1], "end": [347, 48], "kind": "commanddeclaration"}, {"full_name": "String.find_of_valid", "code": "theorem find_of_valid (p s) : find s p = \u27e8utf8Len (s.1.takeWhile (!p \u00b7))\u27e9", "start": [349, 1], "end": [350, 43], "kind": "commanddeclaration"}, {"full_name": "String.revFindAux_of_valid", "code": "@[nolint unusedHavesSuffices] theorem revFindAux_of_valid (p) : \u2200 l r,\n    revFindAux \u27e8l.reverse ++ r\u27e9 p \u27e8utf8Len l\u27e9 = (l.dropWhile (!p \u00b7)).tail?.map (\u27e8utf8Len \u00b7\u27e9)", "start": [352, 1], "end": [362, 41], "kind": "commanddeclaration"}, {"full_name": "String.revFind_of_valid", "code": "theorem revFind_of_valid (p s) :\n    revFind s p = (s.1.reverse.dropWhile (!p \u00b7)).tail?.map (\u27e8utf8Len \u00b7\u27e9)", "start": [364, 1], "end": [366, 51], "kind": "commanddeclaration"}, {"full_name": "String.firstDiffPos_loop_eq", "code": "theorem firstDiffPos_loop_eq (l\u2081 l\u2082 r\u2081 r\u2082 stop p)\n    (hl\u2081 : p = utf8Len l\u2081) (hl\u2082 : p = utf8Len l\u2082)\n    (hstop : stop = min (utf8Len l\u2081 + utf8Len r\u2081) (utf8Len l\u2082 + utf8Len r\u2082)) :\n    firstDiffPos.loop \u27e8l\u2081 ++ r\u2081\u27e9 \u27e8l\u2082 ++ r\u2082\u27e9 \u27e8stop\u27e9 \u27e8p\u27e9 =\n      \u27e8p + utf8Len (List.takeWhile\u2082 (\u00b7 = \u00b7) r\u2081 r\u2082).1\u27e9", "start": [368, 1], "end": [393, 26], "kind": "commanddeclaration"}, {"full_name": "String.firstDiffPos_eq", "code": "theorem firstDiffPos_eq (a b : String) :\n    firstDiffPos a b = \u27e8utf8Len (List.takeWhile\u2082 (\u00b7 = \u00b7) a.1 b.1).1\u27e9", "start": [395, 1], "end": [398, 93], "kind": "commanddeclaration"}, {"full_name": "String.extract.go\u2082_add_right_cancel", "code": "theorem extract.go\u2082_add_right_cancel (s : List Char) (i e n : Nat) :\n    go\u2082 s \u27e8i + n\u27e9 \u27e8e + n\u27e9 = go\u2082 s \u27e8i\u27e9 \u27e8e\u27e9", "start": [400, 1], "end": [408, 11], "kind": "commanddeclaration"}, {"full_name": "String.extract.go\u2082_append_left", "code": "theorem extract.go\u2082_append_left : \u2200 (s t : List Char) (i e : Nat),\n    e = utf8Len s + i \u2192 go\u2082 (s ++ t) \u27e8i\u27e9 \u27e8e\u27e9 = s", "start": [410, 1], "end": [415, 64], "kind": "commanddeclaration"}, {"full_name": "String.extract.go\u2081_add_right_cancel", "code": "theorem extract.go\u2081_add_right_cancel (s : List Char) (i b e n : Nat) :\n    go\u2081 s \u27e8i + n\u27e9 \u27e8b + n\u27e9 \u27e8e + n\u27e9 = go\u2081 s \u27e8i\u27e9 \u27e8b\u27e9 \u27e8e\u27e9", "start": [417, 1], "end": [428, 13], "kind": "commanddeclaration"}, {"full_name": "String.extract.go\u2081_cons_addChar", "code": "theorem extract.go\u2081_cons_addChar (c : Char) (cs : List Char) (b e : Pos) :\n    go\u2081 (c :: cs) 0 (b + c) (e + c) = go\u2081 cs 0 b e", "start": [430, 1], "end": [433, 29], "kind": "commanddeclaration"}, {"full_name": "String.extract.go\u2081_append_right", "code": "theorem extract.go\u2081_append_right : \u2200 (s t : List Char) (i b : Nat) (e : Pos),\n    b = utf8Len s + i \u2192 go\u2081 (s ++ t) \u27e8i\u27e9 \u27e8b\u27e9 e = go\u2082 t \u27e8b\u27e9 e", "start": [435, 1], "end": [440, 65], "kind": "commanddeclaration"}, {"full_name": "String.extract.go\u2081_zero_utf8Len", "code": "theorem extract.go\u2081_zero_utf8Len (s : List Char) : go\u2081 s 0 0 \u27e8utf8Len s\u27e9 = s", "start": [442, 1], "end": [444, 55], "kind": "commanddeclaration"}, {"full_name": "String.extract_cons_addChar", "code": "theorem extract_cons_addChar (c : Char) (cs : List Char) (b e : Pos) :\n    extract \u27e8c :: cs\u27e9 (b + c) (e + c) = extract \u27e8cs\u27e9 b e", "start": [446, 1], "end": [449, 49], "kind": "commanddeclaration"}, {"full_name": "String.extract_zero_endPos", "code": "theorem extract_zero_endPos : \u2200 (s : String), s.extract 0 (endPos s) = s", "start": [451, 1], "end": [455, 35], "kind": "commanddeclaration"}, {"full_name": "String.extract_of_valid", "code": "theorem extract_of_valid (l m r : List Char) :\n    extract \u27e8l ++ m ++ r\u27e9 \u27e8utf8Len l\u27e9 \u27e8utf8Len l + utf8Len m\u27e9 = \u27e8m\u27e9", "start": [457, 1], "end": [463, 54], "kind": "commanddeclaration"}, {"full_name": "String.splitAux_of_valid", "code": "theorem splitAux_of_valid (p l m r acc) :\n    splitAux \u27e8l ++ m ++ r\u27e9 p \u27e8utf8Len l\u27e9 \u27e8utf8Len l + utf8Len m\u27e9 acc =\n      acc.reverse ++ (List.splitOnP.go p r m.reverse).map mk", "start": [465, 1], "end": [476, 71], "kind": "commanddeclaration"}, {"full_name": "String.split_of_valid", "code": "theorem split_of_valid (s p) : split s p = (List.splitOnP p s.1).map mk", "start": [478, 1], "end": [479, 55], "kind": "commanddeclaration"}, {"full_name": "String.toString_toSubstring", "code": "@[simp] theorem toString_toSubstring (s : String) : s.toSubstring.toString = s", "start": [483, 1], "end": [484, 24], "kind": "commanddeclaration"}, {"full_name": "String.join_eq", "code": "theorem join_eq (ss : List String) : join ss = \u27e8(ss.map data).join\u27e9", "start": [488, 1], "end": [491, 46], "kind": "commanddeclaration"}, {"full_name": "String.data_join", "code": "@[simp] theorem data_join (ss : List String) : (join ss).data = (ss.map data).join", "start": [493, 1], "end": [494, 15], "kind": "commanddeclaration"}, {"full_name": "String.singleton_eq", "code": "theorem singleton_eq (c : Char) : singleton c = \u27e8[c]\u27e9", "start": [496, 1], "end": [496, 61], "kind": "commanddeclaration"}, {"full_name": "String.data_singleton", "code": "@[simp] theorem data_singleton (c : Char) : (singleton c).data = [c]", "start": [498, 1], "end": [498, 76], "kind": "commanddeclaration"}, {"full_name": "String.append_nil", "code": "@[simp] theorem append_nil (s : String) : s ++ \"\" = s", "start": [500, 1], "end": [500, 81], "kind": "commanddeclaration"}, {"full_name": "String.nil_append", "code": "@[simp] theorem nil_append (s : String) : \"\" ++ s = s", "start": [502, 1], "end": [502, 61], "kind": "commanddeclaration"}, {"full_name": "String.append_assoc", "code": "theorem append_assoc (s\u2081 s\u2082 s\u2083 : String) : (s\u2081 ++ s\u2082) ++ s\u2083 = s\u2081 ++ (s\u2082 ++ s\u2083)", "start": [504, 1], "end": [505, 29], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.forward_eq_nextn", "code": "@[simp] theorem forward_eq_nextn : forward = nextn", "start": [509, 1], "end": [510, 72], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.hasNext_cons_addChar", "code": "theorem hasNext_cons_addChar (c : Char) (cs : List Char) (i : Pos) :\n    hasNext \u27e8\u27e8c :: cs\u27e9, i + c\u27e9 = hasNext \u27e8\u27e8cs\u27e9, i\u27e9", "start": [512, 1], "end": [514, 43], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.Valid", "code": "def Valid (it : Iterator) : Prop := it.pos.Valid it.s", "start": [516, 1], "end": [517, 54], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor", "code": "inductive ValidFor (l r : List Char) : Iterator \u2192 Prop\n  \n  | mk : ValidFor l r \u27e8\u27e8l.reverseAux r\u27e9, \u27e8utf8Len l\u27e9\u27e9", "start": [519, 1], "end": [523, 54], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.valid", "code": "theorem valid : \u2200 {it}, ValidFor l r it \u2192 Valid it", "start": [529, 1], "end": [530, 74], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.out", "code": "theorem out : \u2200 {it}, ValidFor l r it \u2192 it = \u27e8\u27e8l.reverseAux r\u27e9, \u27e8utf8Len l\u27e9\u27e9", "start": [532, 1], "end": [533, 17], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.out'", "code": "theorem out' : \u2200 {it}, ValidFor l r it \u2192 it = \u27e8\u27e8l.reverse ++ r\u27e9, \u27e8utf8Len l.reverse\u27e9\u27e9", "start": [535, 1], "end": [536, 42], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.mk'", "code": "theorem mk' : ValidFor l r \u27e8\u27e8l.reverse ++ r\u27e9, \u27e8utf8Len l.reverse\u27e9\u27e9", "start": [538, 1], "end": [539, 38], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.of_eq", "code": "theorem of_eq : \u2200 it, it.1.1 = l.reverseAux r \u2192 it.2.1 = utf8Len l \u2192 ValidFor l r it", "start": [541, 1], "end": [542, 31], "kind": "commanddeclaration"}, {"full_name": "String.validFor_mkIterator", "code": "theorem _root_.String.validFor_mkIterator (s) : (mkIterator s).ValidFor [] s.1", "start": [544, 1], "end": [544, 85], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.remainingBytes", "code": "theorem remainingBytes : \u2200 {it}, ValidFor l r it \u2192 it.remainingBytes = utf8Len r", "start": [546, 1], "end": [547, 72], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.toString", "code": "theorem toString : \u2200 {it}, ValidFor l r it \u2192 it.1 = \u27e8l.reverseAux r\u27e9", "start": [549, 1], "end": [550, 17], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.pos", "code": "theorem pos : \u2200 {it}, ValidFor l r it \u2192 it.2 = \u27e8utf8Len l\u27e9", "start": [552, 1], "end": [553, 17], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.pos_eq_zero", "code": "theorem pos_eq_zero {l r it} (h : ValidFor l r it) : it.2 = 0 \u2194 l = []", "start": [555, 1], "end": [556, 28], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.pos_eq_endPos", "code": "theorem pos_eq_endPos {l r it} (h : ValidFor l r it) : it.2 = it.1.endPos \u2194 r = []", "start": [558, 1], "end": [560, 82], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.curr", "code": "theorem curr : \u2200 {it}, ValidFor l r it \u2192 it.curr = r.headD default", "start": [562, 1], "end": [563, 49], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.next", "code": "theorem next : \u2200 {it}, ValidFor l (c :: r) it \u2192 ValidFor (c :: l) r it.next", "start": [565, 1], "end": [569, 60], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.prev", "code": "theorem prev : \u2200 {it}, ValidFor (c :: l) r it \u2192 ValidFor l (c :: r) it.prev", "start": [571, 1], "end": [576, 60], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.prev_nil", "code": "theorem prev_nil : \u2200 {it}, ValidFor [] r it \u2192 ValidFor [] r it.prev", "start": [578, 1], "end": [579, 69], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.atEnd", "code": "theorem atEnd : \u2200 {it}, ValidFor l r it \u2192 (it.atEnd \u2194 r = [])", "start": [581, 1], "end": [584, 85], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.hasNext", "code": "theorem hasNext : \u2200 {it}, ValidFor l r it \u2192 (it.hasNext \u2194 r \u2260 [])", "start": [586, 1], "end": [587, 67], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.hasPrev", "code": "theorem hasPrev : \u2200 {it}, ValidFor l r it \u2192 (it.hasPrev \u2194 l \u2260 [])", "start": [589, 1], "end": [590, 68], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.setCurr'", "code": "theorem setCurr' : \u2200 {it}, ValidFor l r it \u2192\n    ValidFor l (r.modifyHead fun _ => c) (it.setCurr c)", "start": [592, 1], "end": [599, 50], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.setCurr", "code": "theorem setCurr (h : ValidFor l (c :: r) it) :\n    ValidFor l (c :: r) (it.setCurr c)", "start": [601, 1], "end": [602, 53], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.toEnd", "code": "theorem toEnd (h : ValidFor l r it) : ValidFor (r.reverse ++ l) [] it.toEnd", "start": [604, 1], "end": [606, 73], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.toEnd'", "code": "theorem toEnd' (it : Iterator) : ValidFor it.s.1.reverse [] it.toEnd", "start": [608, 1], "end": [610, 81], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.extract", "code": "theorem extract (h\u2081 : ValidFor l (m ++ r) it\u2081) (h\u2082 : ValidFor (m.reverse ++ l) r it\u2082) :\n    it\u2081.extract it\u2082 = \u27e8m\u27e9", "start": [612, 1], "end": [616, 60], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.remainingToString", "code": "theorem remainingToString {it} (h : ValidFor l r it) : it.remainingToString = \u27e8r\u27e9", "start": [618, 1], "end": [620, 95], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.nextn", "code": "theorem nextn : \u2200 {it}, ValidFor l r it \u2192\n      \u2200 n, n \u2264 r.length \u2192 ValidFor ((r.take n).reverse ++ l) (r.drop n) (it.nextn n)", "start": [622, 1], "end": [628, 59], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.ValidFor.prevn", "code": "theorem prevn : \u2200 {it}, ValidFor l r it \u2192\n      \u2200 n, n \u2264 l.length \u2192 ValidFor (l.drop n) ((l.take n).reverse ++ r) (it.prevn n)", "start": [630, 1], "end": [636, 59], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.Valid.validFor", "code": "theorem validFor : \u2200 {it}, Valid it \u2192 \u2203 l r, ValidFor l r it", "start": [642, 1], "end": [644, 81], "kind": "commanddeclaration"}, {"full_name": "String.valid_mkIterator", "code": "theorem _root_.String.valid_mkIterator (s) : (mkIterator s).Valid", "start": [646, 1], "end": [646, 97], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.Valid.remainingBytes_le", "code": "theorem remainingBytes_le : \u2200 {it}, Valid it \u2192 it.remainingBytes \u2264 utf8ByteSize it.s", "start": [648, 1], "end": [649, 97], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.Valid.next", "code": "theorem next : \u2200 {it}, Valid it \u2192 it.hasNext \u2192 Valid it.next", "start": [651, 1], "end": [655, 23], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.Valid.prev", "code": "theorem prev : \u2200 {it}, Valid it \u2192 Valid it.prev", "start": [657, 1], "end": [661, 35], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.Valid.setCurr", "code": "theorem setCurr : \u2200 {it}, Valid it \u2192 Valid (it.setCurr c)", "start": [663, 1], "end": [666, 27], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.Valid.toEnd", "code": "theorem toEnd (it : String.Iterator) : Valid it.toEnd", "start": [668, 1], "end": [668, 83], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.Valid.remainingToString", "code": "theorem remainingToString {it} (h : ValidFor l r it) : it.remainingToString = \u27e8r\u27e9", "start": [670, 1], "end": [672, 95], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.Valid.prevn", "code": "theorem prevn (h : Valid it) : \u2200 n, Valid (it.prevn n)", "start": [674, 1], "end": [676, 26], "kind": "commanddeclaration"}, {"full_name": "String.offsetOfPosAux_of_valid", "code": "@[nolint unusedHavesSuffices] theorem offsetOfPosAux_of_valid : \u2200 l m r n,\n    offsetOfPosAux \u27e8l ++ m ++ r\u27e9 \u27e8utf8Len l + utf8Len m\u27e9 \u27e8utf8Len l\u27e9 n = n + m.length", "start": [681, 1], "end": [691, 51], "kind": "commanddeclaration"}, {"full_name": "String.offsetOfPos_of_valid", "code": "theorem offsetOfPos_of_valid (l r) : offsetOfPos \u27e8l ++ r\u27e9 \u27e8utf8Len l\u27e9 = l.length", "start": [693, 1], "end": [694, 47], "kind": "commanddeclaration"}, {"full_name": "String.foldlAux_of_valid", "code": "@[nolint unusedHavesSuffices] theorem foldlAux_of_valid (f : \u03b1 \u2192 Char \u2192 \u03b1) : \u2200 l m r a,\n    foldlAux f \u27e8l ++ m ++ r\u27e9 \u27e8utf8Len l + utf8Len m\u27e9 \u27e8utf8Len l\u27e9 a = m.foldl f a", "start": [696, 1], "end": [704, 95], "kind": "commanddeclaration"}, {"full_name": "String.foldl_eq", "code": "theorem foldl_eq (f : \u03b1 \u2192 Char \u2192 \u03b1) (s a) : foldl f a s = s.1.foldl f a", "start": [706, 1], "end": [707, 46], "kind": "commanddeclaration"}, {"full_name": "String.foldrAux_of_valid", "code": "@[nolint unusedHavesSuffices] theorem foldrAux_of_valid (f : Char \u2192 \u03b1 \u2192 \u03b1) (l m r a) :\n    foldrAux f a \u27e8l ++ m ++ r\u27e9 \u27e8utf8Len l + utf8Len m\u27e9 \u27e8utf8Len l\u27e9 = m.foldr f a", "start": [709, 1], "end": [718, 34], "kind": "commanddeclaration"}, {"full_name": "String.foldr_eq", "code": "theorem foldr_eq (f : Char \u2192 \u03b1 \u2192 \u03b1) (s a) : foldr f a s = s.1.foldr f a", "start": [720, 1], "end": [721, 46], "kind": "commanddeclaration"}, {"full_name": "String.anyAux_of_valid", "code": "@[nolint unusedHavesSuffices] theorem anyAux_of_valid (p : Char \u2192 Bool) : \u2200 l m r,\n    anyAux \u27e8l ++ m ++ r\u27e9 \u27e8utf8Len l + utf8Len m\u27e9 p \u27e8utf8Len l\u27e9 = m.any p", "start": [723, 1], "end": [732, 85], "kind": "commanddeclaration"}, {"full_name": "String.any_eq", "code": "theorem any_eq (s : String) (p : Char \u2192 Bool) : any s p = s.1.any p", "start": [734, 1], "end": [735, 42], "kind": "commanddeclaration"}, {"full_name": "String.any_iff", "code": "theorem any_iff (s : String) (p : Char \u2192 Bool) : any s p \u2194 \u2203 c \u2208 s.1, p c", "start": [737, 1], "end": [737, 94], "kind": "commanddeclaration"}, {"full_name": "String.all_eq", "code": "theorem all_eq (s : String) (p : Char \u2192 Bool) : all s p = s.1.all p", "start": [739, 1], "end": [740, 44], "kind": "commanddeclaration"}, {"full_name": "String.all_iff", "code": "theorem all_iff (s : String) (p : Char \u2192 Bool) : all s p \u2194 \u2200 c \u2208 s.1, p c", "start": [742, 1], "end": [742, 94], "kind": "commanddeclaration"}, {"full_name": "String.contains_iff", "code": "theorem contains_iff (s : String) (c : Char) : contains s c \u2194 c \u2208 s.1", "start": [744, 1], "end": [745, 27], "kind": "commanddeclaration"}, {"full_name": "String.mapAux_of_valid", "code": "@[nolint unusedHavesSuffices] theorem mapAux_of_valid (f : Char \u2192 Char) : \u2200 l r, mapAux f \u27e8utf8Len l\u27e9 \u27e8l ++ r\u27e9 = \u27e8l ++ r.map f\u27e9", "start": [747, 1], "end": [754, 47], "kind": "commanddeclaration"}, {"full_name": "String.map_eq", "code": "theorem map_eq (f : Char \u2192 Char) (s) : map f s = \u27e8s.1.map f\u27e9", "start": [756, 1], "end": [757, 39], "kind": "commanddeclaration"}, {"full_name": "String.takeWhileAux_of_valid", "code": "@[nolint unusedHavesSuffices] theorem takeWhileAux_of_valid (p : Char \u2192 Bool) : \u2200 l m r,\n    Substring.takeWhileAux \u27e8l ++ m ++ r\u27e9 \u27e8utf8Len l + utf8Len m\u27e9 p \u27e8utf8Len l\u27e9 =\n      \u27e8utf8Len l + utf8Len (m.takeWhile p)\u27e9", "start": [763, 1], "end": [773, 91], "kind": "commanddeclaration"}, {"full_name": "Substring.prev_zero", "code": "@[simp] theorem prev_zero (s : Substring) : s.prev 0 = 0", "start": [781, 1], "end": [781, 87], "kind": "commanddeclaration"}, {"full_name": "Substring.prevn_zero", "code": "@[simp] theorem prevn_zero (s : Substring) : \u2200 n, s.prevn n 0 = 0", "start": [783, 1], "end": [785, 43], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid", "code": "structure Valid (s : Substring) : Prop where\n  \n  startValid : s.startPos.Valid s.str\n  \n  stopValid : s.stopPos.Valid s.str\n  \n  le : s.startPos \u2264 s.stopPos", "start": [787, 1], "end": [794, 30], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid_default", "code": "theorem Valid_default : Valid default", "start": [796, 1], "end": [796, 89], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor", "code": "inductive ValidFor (l m r : List Char) : Substring \u2192 Prop\n  \n  | mk : ValidFor l m r \u27e8\u27e8l ++ m ++ r\u27e9, \u27e8utf8Len l\u27e9, \u27e8utf8Len l + utf8Len m\u27e9\u27e9", "start": [798, 1], "end": [802, 78], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.valid", "code": "theorem valid : \u2200 {s}, ValidFor l m r s \u2192 Valid s", "start": [806, 1], "end": [807, 79], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.of_eq", "code": "theorem of_eq : \u2200 s,\n    s.str.1 = l ++ m ++ r \u2192\n    s.startPos.1 = utf8Len l \u2192\n    s.stopPos.1 = utf8Len l + utf8Len m \u2192\n    ValidFor l m r s", "start": [809, 1], "end": [814, 41], "kind": "commanddeclaration"}, {"full_name": "String.validFor_toSubstring", "code": "theorem _root_.String.validFor_toSubstring (s : String) : ValidFor [] s.1 [] s", "start": [816, 1], "end": [817, 85], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.str", "code": "theorem str : \u2200 {s}, ValidFor l m r s \u2192 s.str = \u27e8l ++ m ++ r\u27e9", "start": [819, 1], "end": [820, 17], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.startPos", "code": "theorem startPos : \u2200 {s}, ValidFor l m r s \u2192 s.startPos = \u27e8utf8Len l\u27e9", "start": [822, 1], "end": [823, 17], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.stopPos", "code": "theorem stopPos : \u2200 {s}, ValidFor l m r s \u2192 s.stopPos = \u27e8utf8Len l + utf8Len m\u27e9", "start": [825, 1], "end": [826, 17], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.bsize", "code": "theorem bsize : \u2200 {s}, ValidFor l m r s \u2192 s.bsize = utf8Len m", "start": [828, 1], "end": [829, 64], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.isEmpty", "code": "theorem isEmpty : \u2200 {s}, ValidFor l m r s \u2192 (s.isEmpty \u2194 m = [])", "start": [831, 1], "end": [832, 49], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.toString", "code": "theorem toString : \u2200 {s}, ValidFor l m r s \u2192 s.toString = \u27e8m\u27e9", "start": [834, 1], "end": [835, 36], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.toIterator", "code": "theorem toIterator : \u2200 {s}, ValidFor l m r s \u2192 s.toIterator.ValidFor l.reverse (m ++ r)", "start": [837, 1], "end": [840, 80], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.get", "code": "theorem get : \u2200 {s}, ValidFor l (m\u2081 ++ c :: m\u2082) r s \u2192 s.get \u27e8utf8Len m\u2081\u27e9 = c", "start": [842, 1], "end": [843, 66], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.next", "code": "theorem next : \u2200 {s}, ValidFor l (m\u2081 ++ c :: m\u2082) r s \u2192 s.next \u27e8utf8Len m\u2081\u27e9 = \u27e8utf8Len m\u2081 + csize c\u27e9", "start": [845, 1], "end": [854, 50], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.next_stop", "code": "theorem next_stop : \u2200 {s}, ValidFor l m r s \u2192 s.next \u27e8utf8Len m\u27e9 = \u27e8utf8Len m\u27e9", "start": [856, 1], "end": [857, 50], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.prev", "code": "theorem prev : \u2200 {s}, ValidFor l (m\u2081 ++ c :: m\u2082) r s \u2192 s.prev \u27e8utf8Len m\u2081 + csize c\u27e9 = \u27e8utf8Len m\u2081\u27e9", "start": [859, 1], "end": [866, 35], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.nextn_stop", "code": "theorem nextn_stop : \u2200 {s}, ValidFor l m r s \u2192 \u2200 n, s.nextn n \u27e8utf8Len m\u27e9 = \u27e8utf8Len m\u27e9", "start": [868, 1], "end": [870, 72], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.nextn", "code": "theorem nextn : \u2200 {s}, ValidFor l (m\u2081 ++ m\u2082) r s \u2192\n    \u2200 n, s.nextn n \u27e8utf8Len m\u2081\u27e9 = \u27e8utf8Len m\u2081 + utf8Len (m\u2082.take n)\u27e9", "start": [872, 1], "end": [882, 85], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.prevn", "code": "theorem prevn : \u2200 {s}, ValidFor l (m\u2081.reverse ++ m\u2082) r s \u2192\n    \u2200 n, s.prevn n \u27e8utf8Len m\u2081\u27e9 = \u27e8utf8Len (m\u2081.drop n)\u27e9", "start": [884, 1], "end": [893, 59], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.front", "code": "theorem front : \u2200 {s}, ValidFor l (c :: m) r s \u2192 s.front = c", "start": [895, 1], "end": [896, 29], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.drop", "code": "theorem drop : \u2200 {s}, ValidFor l m r s \u2192 \u2200 n, ValidFor (l ++ m.take n) (m.drop n) r (s.drop n)", "start": [898, 1], "end": [906, 49], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.take", "code": "theorem take : \u2200 {s}, ValidFor l m r s \u2192 \u2200 n, ValidFor l (m.take n) (m.drop n ++ r) (s.take n)", "start": [908, 1], "end": [916, 49], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.atEnd", "code": "theorem atEnd : \u2200 {s}, ValidFor l m r s \u2192 (s.atEnd \u27e8p\u27e9 \u2194 p = utf8Len m)", "start": [920, 1], "end": [921, 77], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.extract", "code": "theorem extract : \u2200 {s}, ValidFor l m r s \u2192 ValidFor ml mm mr \u27e8\u27e8m\u27e9, b, e\u27e9 \u2192\n    \u2203 l' r', ValidFor l' mm r' (s.extract b e)", "start": [923, 1], "end": [934, 25], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.foldl", "code": "theorem foldl (f) (init : \u03b1) : \u2200 {s}, ValidFor l m r s \u2192 s.foldl f init = m.foldl f init", "start": [938, 1], "end": [939, 78], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.foldr", "code": "theorem foldr (f) (init : \u03b1) : \u2200 {s}, ValidFor l m r s \u2192 s.foldr f init = m.foldr f init", "start": [941, 1], "end": [942, 78], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.any", "code": "theorem any (f) : \u2200 {s}, ValidFor l m r s \u2192 s.any f = m.any f", "start": [944, 1], "end": [945, 74], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.all", "code": "theorem all (f) : \u2200 {s}, ValidFor l m r s \u2192 s.all f = m.all f", "start": [947, 1], "end": [948, 68], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.contains", "code": "theorem contains (c) : \u2200 {s}, ValidFor l m r s \u2192 (s.contains c \u2194 c \u2208 m)", "start": [950, 1], "end": [951, 65], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.takeWhile", "code": "theorem takeWhile (p : Char \u2192 Bool) : \u2200 {s}, ValidFor l m r s \u2192\n    ValidFor l (m.takeWhile p) (m.dropWhile p ++ r) (s.takeWhile p)", "start": [953, 1], "end": [958, 62], "kind": "commanddeclaration"}, {"full_name": "Substring.ValidFor.dropWhile", "code": "theorem dropWhile (p : Char \u2192 Bool) : \u2200 {s}, ValidFor l m r s \u2192\n    ValidFor (l ++ m.takeWhile p) (m.dropWhile p) r (s.dropWhile p)", "start": [960, 1], "end": [965, 90], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.validFor", "code": "theorem validFor : \u2200 {s}, Valid s \u2192 \u2203 l m r, ValidFor l m r s", "start": [973, 1], "end": [983, 73], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.valid", "code": "theorem valid : \u2200 {s}, ValidFor l m r s \u2192 Valid s", "start": [985, 1], "end": [986, 79], "kind": "commanddeclaration"}, {"full_name": "String.valid_toSubstring", "code": "theorem _root_.String.valid_toSubstring (s : String) : Valid s", "start": [988, 1], "end": [989, 31], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.bsize", "code": "theorem bsize : \u2200 {s}, Valid s \u2192 s.bsize = utf8Len s.toString.1", "start": [991, 1], "end": [992, 74], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.isEmpty", "code": "theorem isEmpty : \u2200 {s}, Valid s \u2192 (s.isEmpty \u2194 s.toString = \"\")", "start": [994, 1], "end": [995, 85], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.get", "code": "theorem get : \u2200 {s}, Valid s \u2192 s.toString.1 = m\u2081 ++ c :: m\u2082 \u2192 s.get \u27e8utf8Len m\u2081\u27e9 = c", "start": [997, 1], "end": [1000, 50], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.next", "code": "theorem next : \u2200 {s}, Valid s \u2192 s.toString.1 = m\u2081 ++ c :: m\u2082 \u2192\n    s.next \u27e8utf8Len m\u2081\u27e9 = \u27e8utf8Len m\u2081 + csize c\u27e9", "start": [1002, 1], "end": [1006, 51], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.next_stop", "code": "theorem next_stop : \u2200 {s}, Valid s \u2192 s.next \u27e8s.bsize\u27e9 = \u27e8s.bsize\u27e9", "start": [1008, 1], "end": [1009, 75], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.prev", "code": "theorem prev : \u2200 {s}, Valid s \u2192 s.toString.1 = m\u2081 ++ c :: m\u2082 \u2192\n    s.prev \u27e8utf8Len m\u2081 + csize c\u27e9 = \u27e8utf8Len m\u2081\u27e9", "start": [1011, 1], "end": [1015, 51], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.nextn_stop", "code": "theorem nextn_stop : \u2200 {s}, Valid s \u2192 \u2200 n, s.nextn n \u27e8s.bsize\u27e9 = \u27e8s.bsize\u27e9", "start": [1017, 1], "end": [1018, 79], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.nextn", "code": "theorem nextn : \u2200 {s}, Valid s \u2192 s.toString.1 = m\u2081 ++ m\u2082 \u2192\n    \u2200 n, s.nextn n \u27e8utf8Len m\u2081\u27e9 = \u27e8utf8Len m\u2081 + utf8Len (m\u2082.take n)\u27e9", "start": [1020, 1], "end": [1024, 52], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.prevn", "code": "theorem prevn : \u2200 {s}, Valid s \u2192 s.toString.1 = m\u2081.reverse ++ m\u2082 \u2192\n    \u2200 n, s.prevn n \u27e8utf8Len m\u2081\u27e9 = \u27e8utf8Len (m\u2081.drop n)\u27e9", "start": [1026, 1], "end": [1030, 52], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.front", "code": "theorem front : \u2200 {s}, Valid s \u2192 s.toString.1 = c :: m \u2192 s.front = c", "start": [1032, 1], "end": [1033, 29], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.drop", "code": "theorem drop : \u2200 {s}, Valid s \u2192 \u2200 n, Valid (s.drop n)", "start": [1035, 1], "end": [1036, 64], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.data_drop", "code": "theorem data_drop : \u2200 {s}, Valid s \u2192 \u2200 n, (s.drop n).toString.1 = s.toString.1.drop n", "start": [1038, 1], "end": [1039, 89], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.take", "code": "theorem take : \u2200 {s}, Valid s \u2192 \u2200 n, Valid (s.take n)", "start": [1041, 1], "end": [1042, 64], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.data_take", "code": "theorem data_take : \u2200 {s}, Valid s \u2192 \u2200 n, (s.take n).toString.1 = s.toString.1.take n", "start": [1044, 1], "end": [1045, 89], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.atEnd", "code": "theorem atEnd : \u2200 {s}, Valid s \u2192 (s.atEnd \u27e8p\u27e9 \u2194 p = utf8ByteSize s.toString)", "start": [1049, 1], "end": [1050, 74], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.extract", "code": "theorem extract : \u2200 {s}, Valid s \u2192 Valid \u27e8s.toString, b, e\u27e9 \u2192 Valid (s.extract b e)", "start": [1052, 1], "end": [1058, 19], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.toString_extract", "code": "theorem toString_extract : \u2200 {s}, Valid s \u2192 Valid \u27e8s.toString, b, e\u27e9 \u2192\n    (s.extract b e).toString = s.toString.extract b e", "start": [1060, 1], "end": [1067, 59], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.foldl", "code": "theorem foldl (f) (init : \u03b1) : \u2200 {s}, Valid s \u2192 s.foldl f init = s.toString.1.foldl f init", "start": [1069, 1], "end": [1070, 74], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.foldr", "code": "theorem foldr (f) (init : \u03b1) : \u2200 {s}, Valid s \u2192 s.foldr f init = s.toString.1.foldr f init", "start": [1072, 1], "end": [1073, 74], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.any", "code": "theorem any (f) : \u2200 {s}, Valid s \u2192 s.any f = s.toString.1.any f", "start": [1075, 1], "end": [1076, 72], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.all", "code": "theorem all (f) : \u2200 {s}, Valid s \u2192 s.all f = s.toString.1.all f", "start": [1078, 1], "end": [1079, 72], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.contains", "code": "theorem contains (c) : \u2200 {s}, Valid s \u2192 (s.contains c \u2194 c \u2208 s.toString.1)", "start": [1081, 1], "end": [1082, 77], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.takeWhile", "code": "theorem takeWhile (p : Char \u2192 Bool) : \u2200 {s}, Valid s \u2192 Valid (s.takeWhile p)", "start": [1084, 1], "end": [1085, 66], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.data_takeWhile", "code": "theorem data_takeWhile (p) : \u2200 {s}, Valid s \u2192\n    (s.takeWhile p).toString.1 = s.toString.1.takeWhile p", "start": [1087, 1], "end": [1089, 91], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.dropWhile", "code": "theorem dropWhile (p : Char \u2192 Bool) : \u2200 {s}, Valid s \u2192 Valid (s.dropWhile p)", "start": [1091, 1], "end": [1092, 66], "kind": "commanddeclaration"}, {"full_name": "Substring.Valid.data_dropWhile", "code": "theorem data_dropWhile (p) : \u2200 {s}, Valid s \u2192\n    (s.dropWhile p).toString.1 = s.toString.1.dropWhile p", "start": [1094, 1], "end": [1096, 91], "kind": "commanddeclaration"}, {"full_name": "String.drop_eq", "code": "theorem drop_eq (s : String) (n : Nat) : s.drop n = \u27e8s.1.drop n\u27e9", "start": [1105, 1], "end": [1106, 43], "kind": "commanddeclaration"}, {"full_name": "String.data_drop", "code": "@[simp] theorem data_drop (s : String) (n : Nat) : (s.drop n).1 = s.1.drop n", "start": [1108, 1], "end": [1108, 96], "kind": "commanddeclaration"}, {"full_name": "String.drop_empty", "code": "@[simp] theorem drop_empty {n : Nat} : \"\".drop n = \"\"", "start": [1110, 1], "end": [1110, 88], "kind": "commanddeclaration"}, {"full_name": "String.take_eq", "code": "theorem take_eq (s : String) (n : Nat) : s.take n = \u27e8s.1.take n\u27e9", "start": [1112, 1], "end": [1113, 43], "kind": "commanddeclaration"}, {"full_name": "String.data_take", "code": "@[simp] theorem data_take (s : String) (n : Nat) : (s.take n).1 = s.1.take n", "start": [1115, 1], "end": [1115, 96], "kind": "commanddeclaration"}, {"full_name": "String.takeWhile_eq", "code": "theorem takeWhile_eq (p : Char \u2192 Bool) (s : String) : s.takeWhile p = \u27e8s.1.takeWhile p\u27e9", "start": [1117, 1], "end": [1118, 48], "kind": "commanddeclaration"}, {"full_name": "String.data_takeWhile", "code": "@[simp] theorem data_takeWhile (p : Char \u2192 Bool) (s : String) :\n    (s.takeWhile p).1 = s.1.takeWhile p", "start": [1120, 1], "end": [1121, 64], "kind": "commanddeclaration"}, {"full_name": "String.dropWhile_eq", "code": "theorem dropWhile_eq (p : Char \u2192 Bool) (s : String) : s.dropWhile p = \u27e8s.1.dropWhile p\u27e9", "start": [1123, 1], "end": [1124, 48], "kind": "commanddeclaration"}, {"full_name": "String.data_dropWhile", "code": "@[simp] theorem data_dropWhile (p : Char \u2192 Bool) (s : String) :\n    (s.dropWhile p).1 = s.1.dropWhile p", "start": [1126, 1], "end": [1127, 64], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Fin/Basic.lean", "imports": ["lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fin.pos", "code": "protected theorem pos (i : Fin n) : 0 < n", "start": [10, 1], "end": [11, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.last", "code": "@[inline] def last (n : Nat) : Fin (n + 1) := \u27e8n, n.lt_succ_self\u27e9", "start": [13, 1], "end": [14, 66], "kind": "commanddeclaration"}, {"full_name": "Fin.castLT", "code": "@[inline] def castLT (i : Fin m) (h : i.1 < n) : Fin n := \u27e8i.1, h\u27e9", "start": [16, 1], "end": [17, 67], "kind": "commanddeclaration"}, {"full_name": "Fin.castLE", "code": "@[inline] def castLE (h : n \u2264 m) (i : Fin n) : Fin m := \u27e8i, Nat.lt_of_lt_of_le i.2 h\u27e9", "start": [19, 1], "end": [20, 86], "kind": "commanddeclaration"}, {"full_name": "Fin.cast", "code": "@[inline] def cast (eq : n = m) (i : Fin n) : Fin m := \u27e8i, eq \u25b8 i.2\u27e9", "start": [22, 1], "end": [23, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.castAdd", "code": "@[inline] def castAdd (m) : Fin n \u2192 Fin (n + m) :=\n  castLE <| Nat.le_add_right n m", "start": [25, 1], "end": [27, 33], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc", "code": "@[inline] def castSucc : Fin n \u2192 Fin (n + 1) := castAdd 1", "start": [29, 1], "end": [30, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.addNat", "code": "def addNat (i : Fin n) (m) : Fin (n + m) := \u27e8i + m, Nat.add_lt_add_right i.2 _\u27e9", "start": [32, 1], "end": [33, 80], "kind": "commanddeclaration"}, {"full_name": "Fin.natAdd", "code": "def natAdd (n) (i : Fin m) : Fin (n + m) := \u27e8n + i, Nat.add_lt_add_left i.2 _\u27e9", "start": [35, 1], "end": [36, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.rev", "code": "@[inline] def rev (i : Fin n) : Fin n := \u27e8n - (i + 1), Nat.sub_lt i.pos (Nat.succ_pos _)\u27e9", "start": [38, 1], "end": [39, 90], "kind": "commanddeclaration"}, {"full_name": "Fin.subNat", "code": "@[inline] def subNat (m) (i : Fin (n + m)) (h : m \u2264 i) : Fin n :=\n  \u27e8i - m, Nat.sub_lt_right_of_lt_add h i.2\u27e9", "start": [41, 1], "end": [43, 44], "kind": "commanddeclaration"}, {"full_name": "Fin.pred", "code": "@[inline] def pred {n : Nat} (i : Fin (n + 1)) (h : i \u2260 0) : Fin n :=\n  subNat 1 i <| Nat.pos_of_ne_zero <| mt (Fin.eq_of_val_eq (j := 0)) h", "start": [45, 1], "end": [47, 71], "kind": "commanddeclaration"}, {"full_name": "Fin.clamp", "code": "def clamp (n m : Nat) : Fin (m + 1) := \u27e8min n m, Nat.lt_succ_of_le (Nat.min_le_right ..)\u27e9", "start": [49, 1], "end": [50, 90], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Alias.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Compiler/NoncomputableAttr.lean", "lake-packages/std/Std/CodeAction/Deprecated.lean"], "premises": [{"full_name": "Std.Tactic.Alias.AliasInfo", "code": "inductive AliasInfo where\n  \n  | plain (n : Name)\n  \n  | forward (n : Name)\n  \n  | reverse (n : Name)\nderiving Inhabited", "start": [23, 1], "end": [31, 19], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Alias.AliasInfo.name", "code": "def AliasInfo.name : AliasInfo \u2192 Name\n  | plain n => n\n  | forward n => n\n  | reverse n => n", "start": [33, 1], "end": [37, 19], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Alias.AliasInfo.toString", "code": "def AliasInfo.toString : AliasInfo \u2192 String\n  | plain n => s!\"**Alias** of `{n}`.\"\n  | forward n => s!\"**Alias** of the forward direction of `{n}`.\"\n  | reverse n => s!\"**Alias** of the reverse direction of `{n}`.\"", "start": [39, 1], "end": [43, 66], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Alias.getAliasInfo", "code": "def getAliasInfo [Monad m] [MonadEnv m] (name : Name) : m (Option AliasInfo) := do\n  return aliasExt.getState (\u2190 getEnv) |>.find? name", "start": [53, 1], "end": [55, 52], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Alias.setAliasInfo", "code": "def setAliasInfo [MonadEnv m] (info : AliasInfo) (declName : Name) : m Unit :=\n  modifyEnv (aliasExt.addEntry \u00b7 (declName, info))", "start": [57, 1], "end": [59, 51], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Alias.setDeprecatedTarget", "code": "def setDeprecatedTarget (target : Name) (arr : Array Attribute) : Array Attribute \u00d7 Bool :=\n  StateT.run (m := Id) (s := false) do\n    arr.mapM fun s => do\n      if s.name == `deprecated then\n        if let `(deprecated| deprecated%$tk) := s.stx then\n          set true\n          pure { s with stx := Unhygienic.run `(deprecated| deprecated%$tk $(mkCIdent target)) }\n        else pure s\n      else pure s", "start": [61, 1], "end": [70, 18], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Alias.mkIffMpApp", "code": "def mkIffMpApp (mp : Bool) (ty prf : Expr) : MetaM Expr := do\n  Meta.forallTelescope ty fun xs ty => do\n    let some (lhs, rhs) := ty.iff?\n      | throwError \"Target theorem must have the form `\u2200 x y z, a \u2194 b`\"\n    Meta.mkLambdaFVars xs <|\n      mkApp3 (mkConst (if mp then ``Iff.mp else ``Iff.mpr)) lhs rhs (mkAppN prf xs)", "start": [128, 1], "end": [137, 84], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Alias.addSide", "code": "private def addSide (mp : Bool) (declName : Name) (declMods : Modifiers) (thm : TheoremVal) :\n    TermElabM Unit := do\n  checkNotAlreadyDeclared declName\n  let value \u2190 mkIffMpApp mp thm.type thm.value\n  let type \u2190 Meta.inferType value\n  addDecl <| Declaration.thmDecl { thm with\n    name := declName\n    value := value\n    type := type\n  }\n  addDocString' declName declMods.docString?\n  Term.applyAttributes declName declMods.attrs\n  let info := match \u2190 getAliasInfo thm.name with\n    | some (.plain name) => if mp then AliasInfo.forward name else AliasInfo.reverse name\n    | _ => if mp then AliasInfo.forward thm.name else AliasInfo.reverse thm.name\n  setAliasInfo info declName\n  \n  if (\u2190 findDocString? (\u2190 getEnv) declName).isNone then\n    let mut doc := info.toString\n    if let some origDoc \u2190 findDocString? (\u2190 getEnv) thm.name then\n      doc := s!\"{doc}\\n\\n    addDocString declName doc", "start": [139, 1], "end": [161, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/RBMap/WF.lean", "imports": ["lake-packages/std/Std/Data/RBMap/Basic.lean", "lake-packages/std/Std/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.RBNode.All.trivial", "code": "theorem All.trivial (H : \u2200 {x : \u03b1}, p x) : \u2200 {t : RBNode \u03b1}, t.All p", "start": [23, 1], "end": [25, 49], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All_and", "code": "theorem All_and {t : RBNode \u03b1} : t.All (fun a => p a \u2227 q a) \u2194 t.All p \u2227 t.All q", "start": [27, 1], "end": [28, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpLT.trans", "code": "theorem cmpLT.trans (h\u2081 : cmpLT cmp x y) (h\u2082 : cmpLT cmp y z) : cmpLT cmp x z", "start": [30, 1], "end": [31, 32], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpLT.trans_l", "code": "theorem cmpLT.trans_l {cmp x y} (H : cmpLT cmp x y) {t : RBNode \u03b1}\n    (h : t.All (cmpLT cmp y \u00b7)) : t.All (cmpLT cmp x \u00b7)", "start": [33, 1], "end": [34, 84], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpLT.trans_r", "code": "theorem cmpLT.trans_r {cmp x y} (H : cmpLT cmp x y) {a : RBNode \u03b1}\n    (h : a.All (cmpLT cmp \u00b7 x)) : a.All (cmpLT cmp \u00b7 y)", "start": [36, 1], "end": [37, 84], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpEq.lt_congr_left", "code": "theorem cmpEq.lt_congr_left (H : cmpEq cmp x y) : cmpLT cmp x z \u2194 cmpLT cmp y z", "start": [39, 1], "end": [40, 95], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpEq.lt_congr_right", "code": "theorem cmpEq.lt_congr_right (H : cmpEq cmp y z) : cmpLT cmp x y \u2194 cmpLT cmp x z", "start": [42, 1], "end": [43, 97], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.balance1", "code": "protected theorem Ordered.balance1 {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1}\n    (lv : l.All (cmpLT cmp \u00b7 v)) (vr : r.All (cmpLT cmp v \u00b7))\n    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (balance1 l v r).Ordered cmp", "start": [45, 1], "end": [56, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balance1_All", "code": "@[simp] theorem balance1_All {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1} :\n    (balance1 l v r).All p \u2194 p v \u2227 l.All p \u2227 r.All p", "start": [58, 1], "end": [60, 61], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.balance2", "code": "protected theorem Ordered.balance2 {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1}\n    (lv : l.All (cmpLT cmp \u00b7 v)) (vr : r.All (cmpLT cmp v \u00b7))\n    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (balance2 l v r).Ordered cmp", "start": [62, 1], "end": [73, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balance2_All", "code": "@[simp] theorem balance2_All {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1} :\n    (balance2 l v r).All p \u2194 p v \u2227 l.All p \u2227 r.All p", "start": [75, 1], "end": [77, 61], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.setBlack", "code": "protected theorem Ordered.setBlack {t : RBNode \u03b1} : (setBlack t).Ordered cmp \u2194 t.Ordered cmp", "start": [79, 1], "end": [80, 44], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.setBlack", "code": "protected theorem Balanced.setBlack : t.Balanced c n \u2192 \u2203 n', (setBlack t).Balanced black n'", "start": [82, 1], "end": [84, 50], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.setBlack_idem", "code": "theorem setBlack_idem {t : RBNode \u03b1} : t.setBlack.setBlack = t.setBlack", "start": [86, 1], "end": [86, 94], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.insert_setBlack", "code": "theorem insert_setBlack {t : RBNode \u03b1} :\n    (t.insert cmp v).setBlack = (t.ins cmp v).setBlack", "start": [88, 1], "end": [90, 48], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.ins", "code": "protected theorem All.ins {x : \u03b1} {t : RBNode \u03b1}\n  (h\u2081 : p x) (h\u2082 : t.All p) : (ins cmp x t).All p", "start": [92, 1], "end": [95, 62], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.ins", "code": "protected theorem Ordered.ins : \u2200 {t : RBNode \u03b1}, t.Ordered cmp \u2192 (ins cmp x t).Ordered cmp", "start": [97, 1], "end": [113, 76], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.insert", "code": "protected theorem Ordered.insert (h : t.Ordered cmp) : (insert cmp t v).Ordered cmp", "start": [115, 1], "end": [117, 74], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.RedRed", "code": "inductive RedRed (p : Prop) : RBNode \u03b1 \u2192 Nat \u2192 Prop where\n  \n  | balanced : Balanced t c n \u2192 RedRed p t n\n  \n  | redred : p \u2192 Balanced a c\u2081 n \u2192 Balanced b c\u2082 n \u2192 RedRed p (node red a x b) n", "start": [119, 1], "end": [131, 81], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.RedRed.of_false", "code": "protected theorem RedRed.of_false (h : \u00acp) : RedRed p t n \u2192 \u2203 c, Balanced t c n", "start": [133, 1], "end": [136, 34], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.RedRed.of_red", "code": "protected theorem RedRed.of_red : RedRed p (node red a x b) n \u2192\n    \u2203 c\u2081 c\u2082, Balanced a c\u2081 n \u2227 Balanced b c\u2082 n", "start": [138, 1], "end": [141, 63], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.RedRed.imp", "code": "protected theorem RedRed.imp (h : p \u2192 q) : RedRed p t n \u2192 RedRed q t n", "start": [143, 1], "end": [146, 45], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.RedRed.setBlack", "code": "protected theorem RedRed.setBlack : t.RedRed p n \u2192 \u2203 n', (setBlack t).Balanced black n'", "start": [148, 1], "end": [151, 40], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.RedRed.balance1", "code": "protected theorem RedRed.balance1 {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1}\n    (hl : l.RedRed p n) (hr : r.Balanced c n) : \u2203 c, (balance1 l v r).Balanced c (n + 1)", "start": [153, 1], "end": [163, 66], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.RedRed.balance2", "code": "protected theorem RedRed.balance2 {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1}\n    (hl : l.Balanced c n) (hr : r.RedRed p n) : \u2203 c, (balance2 l v r).Balanced c (n + 1)", "start": [165, 1], "end": [175, 66], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balance1_eq", "code": "theorem balance1_eq {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1}\n    (hl : l.Balanced c n) : balance1 l v r = node black l v r", "start": [177, 1], "end": [180, 58], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balance2_eq", "code": "theorem balance2_eq {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1}\n    (hr : r.Balanced c n) : balance2 l v r = node black l v r", "start": [182, 1], "end": [185, 58], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.ins", "code": "protected theorem Balanced.ins (cmp v) {t : RBNode \u03b1}\n    (h : t.Balanced c n) : (ins cmp v t).RedRed (t.isRed = red) n", "start": [189, 1], "end": [215, 37], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.insert", "code": "theorem Balanced.insert {t : RBNode \u03b1} (h : t.Balanced c n) :\n    \u2203 c' n', (insert cmp t v).Balanced c' n'", "start": [217, 1], "end": [226, 77], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.setRed", "code": "protected theorem All.setRed {t : RBNode \u03b1} (h : t.All p) : (setRed t).All p", "start": [228, 1], "end": [229, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.setRed", "code": "protected theorem Ordered.setRed {t : RBNode \u03b1} : (setRed t).Ordered cmp \u2194 t.Ordered cmp", "start": [231, 1], "end": [233, 42], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.balLeft", "code": "protected theorem All.balLeft\n    (hl : l.All p) (hv : p v) (hr : r.All p) : (balLeft l v r).All p", "start": [235, 1], "end": [237, 76], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.balLeft", "code": "protected theorem Ordered.balLeft {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1}\n    (lv : l.All (cmpLT cmp \u00b7 v)) (vr : r.All (cmpLT cmp v \u00b7))\n    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (balLeft l v r).Ordered cmp", "start": [239, 1], "end": [250, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.balLeft", "code": "protected theorem Balanced.balLeft (hl : l.RedRed True n) (hr : r.Balanced cr (n + 1)) :\n    (balLeft l v r).RedRed (cr = red) (n + 1)", "start": [252, 1], "end": [267, 95], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.balRight", "code": "protected theorem All.balRight\n    (hl : l.All p) (hv : p v) (hr : r.All p) : (balRight l v r).All p", "start": [269, 1], "end": [271, 77], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.balRight", "code": "protected theorem Ordered.balRight {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1}\n    (lv : l.All (cmpLT cmp \u00b7 v)) (vr : r.All (cmpLT cmp v \u00b7))\n    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (balRight l v r).Ordered cmp", "start": [273, 1], "end": [284, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.balRight", "code": "protected theorem Balanced.balRight (hl : l.Balanced cl (n + 1)) (hr : r.RedRed True n) :\n    (balRight l v r).RedRed (cl = red) (n + 1)", "start": [286, 1], "end": [301, 95], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.append", "code": "protected theorem All.append (hl : l.All p) (hr : r.All p) : (append l r).All p", "start": [303, 1], "end": [311, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.append", "code": "protected theorem Ordered.append {l : RBNode \u03b1} {v : \u03b1} {r : RBNode \u03b1}\n    (lv : l.All (cmpLT cmp \u00b7 v)) (vr : r.All (cmpLT cmp v \u00b7))\n    (hl : l.Ordered cmp) (hr : r.Ordered cmp) : (append l r).Ordered cmp", "start": [313, 1], "end": [344, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.append", "code": "protected theorem Balanced.append {l r : RBNode \u03b1}\n    (hl : l.Balanced c\u2081 n) (hr : r.Balanced c\u2082 n) :\n    (l.append r).RedRed (c\u2081 = black \u2192 c\u2082 \u2260 black) n", "start": [346, 1], "end": [383, 36], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.DelProp", "code": "def DelProp (p : RBColor) (t : RBNode \u03b1) (n : Nat) : Prop :=\n  match p with\n  | black => \u2203 n', n = n' + 1 \u2227 RedRed True t n'\n  | red => \u2203 c, Balanced t c n", "start": [387, 1], "end": [397, 31], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.DelProp.redred", "code": "theorem DelProp.redred (h : DelProp c t n) : \u2203 n', RedRed (c = black) t n'", "start": [399, 1], "end": [404, 48], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.del", "code": "protected theorem All.del : \u2200 {t : RBNode \u03b1}, t.All p \u2192 (del cut t).All p", "start": [406, 1], "end": [416, 25], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.del", "code": "protected theorem Ordered.del : \u2200 {t : RBNode \u03b1}, t.Ordered cmp \u2192 (del cut t).Ordered cmp", "start": [418, 1], "end": [429, 31], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.del", "code": "protected theorem Balanced.del {t : RBNode \u03b1} (h : t.Balanced c n) :\n    (t.del cut).DelProp t.isBlack n", "start": [431, 1], "end": [454, 48], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.erase", "code": "protected theorem Ordered.erase {t : RBNode \u03b1} (h : t.Ordered cmp) : (erase cut t).Ordered cmp", "start": [456, 1], "end": [458, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.erase", "code": "protected theorem Balanced.erase {t : RBNode \u03b1}\n    (h : t.Balanced c n) : \u2203 n, (t.erase cut).Balanced black n", "start": [460, 1], "end": [463, 42], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.WF.out", "code": "theorem WF.out {t : RBNode \u03b1} (h : t.WF cmp) : t.Ordered cmp \u2227 \u2203 c n, t.Balanced c n", "start": [465, 1], "end": [470, 71], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.WF_iff", "code": "@[simp] theorem WF_iff {t : RBNode \u03b1} : t.WF cmp \u2194 t.Ordered cmp \u2227 \u2203 c n, t.Balanced c n", "start": [472, 1], "end": [477, 48], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.map", "code": "protected theorem Balanced.map {t : RBNode \u03b1} : t.Balanced c n \u2192 (t.map f).Balanced c n", "start": [479, 1], "end": [483, 41], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.IsMonotone", "code": "class IsMonotone (cmp\u03b1 cmp\u03b2) (f : \u03b1 \u2192 \u03b2) : Prop where\n  \n  lt_mono : cmpLT cmp\u03b1 x y \u2192 cmpLT cmp\u03b2 (f x) (f y)", "start": [485, 1], "end": [488, 52], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.map", "code": "protected theorem All.map {f : \u03b1 \u2192 \u03b2} (H : \u2200 {x}, p x \u2192 q (f x)) :\n    \u2200 {t : RBNode \u03b1}, t.All p \u2192 (t.map f).All q", "start": [490, 1], "end": [494, 56], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.map", "code": "protected theorem Ordered.map (f : \u03b1 \u2192 \u03b2) [IsMonotone cmp\u03b1 cmp\u03b2 f] :\n    \u2200 {t : RBNode \u03b1}, t.Ordered cmp\u03b1 \u2192 (t.map f).Ordered cmp\u03b2", "start": [496, 1], "end": [501, 83], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.map", "code": "@[inline] def map (f : \u03b1 \u2192 \u03b2) [IsMonotone cmp\u03b1 cmp\u03b2 f] (t : RBSet \u03b1 cmp\u03b1) : RBSet \u03b2 cmp\u03b2 :=\n  \u27e8t.1.map f, have \u27e8h\u2081, _, _, h\u2082\u27e9 := t.2.out; .mk (h\u2081.map _) h\u2082.map\u27e9", "start": [508, 1], "end": [513, 69], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.Imp.mapSnd", "code": "@[inline] def mapSnd (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) := fun (a, b) => (a, f a b)", "start": [522, 1], "end": [526, 65], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.mapVal", "code": "def mapVal (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (t : RBMap \u03b1 \u03b2 cmp) : RBMap \u03b1 \u03b3 cmp := t.map (Imp.mapSnd f)", "start": [540, 1], "end": [541, 87], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Rat/Basic.lean", "imports": ["lake-packages/std/Std/Data/Nat/Gcd.lean", "lake-packages/std/Std/Data/Int/DivMod.lean", "lake-packages/std/Std/Tactic/Ext.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat", "code": "@[ext] structure Rat where\n  \n  mk' ::\n  \n  num : Int\n  \n  den : Nat := 1\n  \n  den_nz : den \u2260 0 := by decide\n  \n  reduced : num.natAbs.Coprime den := by decide\n  deriving DecidableEq", "start": [12, 1], "end": [28, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.den_pos", "code": "theorem Rat.den_pos (self : Rat) : 0 < self.den", "start": [38, 1], "end": [38, 82], "kind": "commanddeclaration"}, {"full_name": "Rat.maybeNormalize", "code": "@[inline] def Rat.maybeNormalize (num : Int) (den g : Nat)\n    (den_nz : den / g \u2260 0) (reduced : (num.div g).natAbs.Coprime (den / g)) : Rat :=\n  if hg : g = 1 then\n    { num, den\n      den_nz := by simp [hg] at den_nz; exact den_nz\n      reduced := by simp [hg, Int.natAbs_ofNat] at reduced; exact reduced }\n  else { num := num.div g, den := den / g, den_nz, reduced }", "start": [43, 1], "end": [53, 61], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize.den_nz", "code": "theorem Rat.normalize.den_nz {num : Int} {den g : Nat} (den_nz : den \u2260 0)\n    (e : g = num.natAbs.gcd den) : den / g \u2260 0", "start": [55, 1], "end": [57, 80], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize.reduced", "code": "theorem Rat.normalize.reduced {num : Int} {den g : Nat} (den_nz : den \u2260 0)\n    (e : g = num.natAbs.gcd den) : (num.div g).natAbs.Coprime (den / g)", "start": [59, 1], "end": [65, 98], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize", "code": "@[inline] def Rat.normalize (num : Int) (den : Nat := 1) (den_nz : den \u2260 0 := by decide) : Rat :=\n  Rat.maybeNormalize num den (num.natAbs.gcd den)\n    (normalize.den_nz den_nz rfl) (normalize.reduced den_nz rfl)", "start": [67, 1], "end": [74, 65], "kind": "commanddeclaration"}, {"full_name": "mkRat", "code": "def mkRat (num : Int) (den : Nat) : Rat :=\n  if den_nz : den = 0 then { num := 0 } else Rat.normalize num den den_nz", "start": [76, 1], "end": [83, 74], "kind": "commanddeclaration"}, {"full_name": "Rat.ofInt", "code": "def ofInt (num : Int) : Rat := { num, reduced := Nat.coprime_one_right _ }", "start": [87, 1], "end": [88, 75], "kind": "commanddeclaration"}, {"full_name": "Rat.isInt", "code": "@[inline] protected def isInt (a : Rat) : Bool := a.den == 1", "start": [94, 1], "end": [95, 61], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt", "code": "def divInt : Int \u2192 Int \u2192 Rat\n  | n, .ofNat d => inline (mkRat n d)\n  | n, .negSucc d => normalize (-n) d.succ (fun.)", "start": [97, 1], "end": [100, 50], "kind": "commanddeclaration"}, {"full_name": "Rat.ofScientific", "code": "@[irreducible] protected def ofScientific (m : Nat) (s : Bool) (e : Nat) : Rat :=\n  if s then\n    Rat.normalize m (10 ^ e) <| Nat.ne_of_gt <| Nat.pos_pow_of_pos _ (by decide)\n  else\n    (m * 10 ^ e : Nat)", "start": [104, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.blt", "code": "protected def blt (a b : Rat) : Bool :=\n  if a.num < 0 && 0 \u2264 b.num then\n    true\n  else if a.num = 0 then\n    0 < b.num\n  else if 0 < a.num && b.num \u2264 0 then\n    false\n  else\n    a.num * b.den < b.num * a.den", "start": [115, 1], "end": [125, 33], "kind": "commanddeclaration"}, {"full_name": "Rat.mul", "code": "@[irreducible] protected def mul (a b : Rat) : Rat :=\n  let g1 := Nat.gcd a.num.natAbs b.den\n  let g2 := Nat.gcd b.num.natAbs a.den\n  { num := (a.num.div g1) * (b.num.div g2)\n    den := (a.den / g2) * (b.den / g1)\n    den_nz := Nat.ne_of_gt <| Nat.mul_pos\n      (Nat.div_gcd_pos_of_pos_right _ a.den_pos) (Nat.div_gcd_pos_of_pos_right _ b.den_pos)\n    reduced := by\n      simp only [Int.natAbs_mul, Int.natAbs_div, Nat.coprime_mul_iff_left]\n      refine \u27e8Nat.coprime_mul_iff_right.2 \u27e8?_, ?_\u27e9, Nat.coprime_mul_iff_right.2 \u27e8?_, ?_\u27e9\u27e9\n      \u00b7 exact a.reduced.coprime_div_left (Nat.gcd_dvd_left ..)\n          |>.coprime_div_right (Nat.gcd_dvd_right ..)\n      \u00b7 exact Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_right _ b.den_pos)\n      \u00b7 exact Nat.coprime_div_gcd_div_gcd (Nat.gcd_pos_of_pos_right _ a.den_pos)\n      \u00b7 exact b.reduced.coprime_div_left (Nat.gcd_dvd_left ..)\n          |>.coprime_div_right (Nat.gcd_dvd_right ..) }", "start": [137, 1], "end": [154, 56], "kind": "commanddeclaration"}, {"full_name": "Rat.inv", "code": "@[irreducible] protected def inv (a : Rat) : Rat :=\n  if h : a.num < 0 then\n    { num := -a.den, den := a.num.natAbs\n      den_nz := Nat.ne_of_gt (Int.natAbs_pos.2 (Int.ne_of_lt h))\n      reduced := Int.natAbs_neg a.den \u25b8 a.reduced.symm }\n  else if h : a.num > 0 then\n    { num := a.den, den := a.num.natAbs\n      den_nz := Nat.ne_of_gt (Int.natAbs_pos.2 (Int.ne_of_gt h))\n      reduced := a.reduced.symm }\n  else\n    a", "start": [158, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.div", "code": "protected def div : Rat \u2192 Rat \u2192 Rat := (\u00b7 * \u00b7.inv)", "start": [174, 1], "end": [175, 51], "kind": "commanddeclaration"}, {"full_name": "Rat.add.aux", "code": "theorem add.aux (a b : Rat) {g ad bd} (hg : g = a.den.gcd b.den)\n    (had : ad = a.den / g) (hbd : bd = b.den / g) :\n    let den := ad * b.den; let num := a.num * bd + b.num * ad\n    num.natAbs.gcd g = num.natAbs.gcd den", "start": [181, 1], "end": [207, 70], "kind": "commanddeclaration"}, {"full_name": "Rat.add", "code": "@[irreducible] protected def add (a b : Rat) : Rat :=\n  let g := a.den.gcd b.den\n  if hg : g = 1 then\n    have den_nz := Nat.ne_of_gt <| Nat.mul_pos a.den_pos b.den_pos\n    have reduced := add.aux a b hg.symm (Nat.div_one _).symm (Nat.div_one _).symm\n      |>.symm.trans (Nat.gcd_one_right _)\n    { num := a.num * b.den + b.num * a.den, den := a.den * b.den, den_nz, reduced }\n  else\n    let den := (a.den / g) * b.den\n    let num := a.num * \u2191(b.den / g) + b.num * \u2191(a.den / g)\n    let g1  := num.natAbs.gcd g\n    have den_nz := Nat.ne_of_gt <| Nat.mul_pos (Nat.div_gcd_pos_of_pos_left _ a.den_pos) b.den_pos\n    have e : g1 = num.natAbs.gcd den := add.aux a b rfl rfl rfl\n    Rat.maybeNormalize num den g1 (normalize.den_nz den_nz e) (normalize.reduced den_nz e)", "start": [209, 1], "end": [226, 91], "kind": "commanddeclaration"}, {"full_name": "Rat.neg", "code": "protected def neg (a : Rat) : Rat :=\n  { a with num := -a.num, reduced := by rw [Int.natAbs_neg]; exact a.reduced }", "start": [230, 1], "end": [232, 79], "kind": "commanddeclaration"}, {"full_name": "Rat.sub.aux", "code": "theorem sub.aux (a b : Rat) {g ad bd} (hg : g = a.den.gcd b.den)\n    (had : ad = a.den / g) (hbd : bd = b.den / g) :\n    let den := ad * b.den; let num := a.num * bd - b.num * ad\n    num.natAbs.gcd g = num.natAbs.gcd den", "start": [236, 1], "end": [242, 13], "kind": "commanddeclaration"}, {"full_name": "Rat.sub", "code": "@[irreducible] protected def sub (a b : Rat) : Rat :=\n  let g := a.den.gcd b.den\n  if hg : g = 1 then\n    have den_nz := Nat.ne_of_gt <| Nat.mul_pos a.den_pos b.den_pos\n    have reduced := sub.aux a b hg.symm (Nat.div_one _).symm (Nat.div_one _).symm\n      |>.symm.trans (Nat.gcd_one_right _)\n    { num := a.num * b.den - b.num * a.den, den := a.den * b.den, den_nz, reduced }\n  else\n    let den := (a.den / g) * b.den\n    let num := a.num * \u2191(b.den / g) - b.num * \u2191(a.den / g)\n    let g1  := num.natAbs.gcd g\n    have den_nz := Nat.ne_of_gt <| Nat.mul_pos (Nat.div_gcd_pos_of_pos_left _ a.den_pos) b.den_pos\n    have e : g1 = num.natAbs.gcd den := sub.aux a b rfl rfl rfl\n    Rat.maybeNormalize num den g1 (normalize.den_nz den_nz e) (normalize.reduced den_nz e)", "start": [244, 1], "end": [260, 91], "kind": "commanddeclaration"}, {"full_name": "Rat.floor", "code": "protected def floor (a : Rat) : Int :=\n  if a.den = 1 then\n    a.num\n  else\n    a.num / a.den", "start": [264, 1], "end": [269, 18], "kind": "commanddeclaration"}, {"full_name": "Rat.ceil", "code": "protected def ceil (a : Rat) : Int :=\n  if a.den = 1 then\n    a.num\n  else\n    a.num / a.den + 1", "start": [271, 1], "end": [276, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "imports": ["lake-packages/std/Std/Control/ForInStep/Basic.lean", "lake-packages/std/Std/Classes/Order.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.BinomialHeap.Imp.HeapNode", "code": "inductive HeapNode (\u03b1 : Type u) where\n  \n  | nil : HeapNode \u03b1\n  \n  | node (a : \u03b1) (child sibling : HeapNode \u03b1) : HeapNode \u03b1\n  deriving Repr", "start": [14, 1], "end": [32, 16], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.realSize", "code": "@[simp] def HeapNode.realSize : HeapNode \u03b1 \u2192 Nat\n  | .nil => 0\n  | .node _ c s => c.realSize + 1 + s.realSize", "start": [34, 1], "end": [41, 47], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.singleton", "code": "def HeapNode.singleton (a : \u03b1) : HeapNode \u03b1 := .node a .nil .nil", "start": [43, 1], "end": [44, 65], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.rank", "code": "def HeapNode.rank : HeapNode \u03b1 \u2192 Nat\n  | .nil => 0\n  | .node _ _ s => s.rank + 1", "start": [46, 1], "end": [52, 30], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.rankTR", "code": "@[inline] private def HeapNode.rankTR (s : HeapNode \u03b1) : Nat := go s 0 where\n  \n  go : HeapNode \u03b1 \u2192 Nat \u2192 Nat\n  | .nil, r => r\n  | .node _ _ s, r => go s (r + 1)", "start": [54, 1], "end": [59, 35], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.rankTR_eq", "code": "@[csimp] private theorem HeapNode.rankTR_eq : @rankTR = @rank", "start": [61, 1], "end": [66, 60], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap", "code": "inductive Heap (\u03b1 : Type u) where\n  \n  | nil : Heap \u03b1\n  \n  | cons (rank : Nat) (val : \u03b1) (node : HeapNode \u03b1) (next : Heap \u03b1) : Heap \u03b1\n  deriving Repr", "start": [68, 1], "end": [78, 16], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.realSize", "code": "@[simp] def Heap.realSize : Heap \u03b1 \u2192 Nat\n  | .nil => 0\n  | .cons _ _ c s => c.realSize + 1 + s.realSize", "start": [80, 1], "end": [87, 49], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.size", "code": "def Heap.size : Heap \u03b1 \u2192 Nat\n  | .nil => 0\n  | .cons r _ _ s => 1 <<< r + s.size", "start": [89, 1], "end": [92, 38], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.isEmpty", "code": "@[inline] def Heap.isEmpty : Heap \u03b1 \u2192 Bool\n  | .nil => true\n  | _    => false", "start": [94, 1], "end": [97, 18], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.singleton", "code": "@[inline] def Heap.singleton (a : \u03b1) : Heap \u03b1 := .cons 0 a .nil .nil", "start": [99, 1], "end": [100, 69], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.rankGT", "code": "def Heap.rankGT : Heap \u03b1 \u2192 Nat \u2192 Prop\n  | .nil, _ => True\n  | .cons r .., n => n < r", "start": [102, 1], "end": [105, 27], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.length", "code": "@[simp] def Heap.length : Heap \u03b1 \u2192 Nat\n  | .nil => 0\n  | .cons _ _ _ r => r.length + 1", "start": [112, 1], "end": [115, 34], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.combine", "code": "@[inline] def combine (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (a\u2081 a\u2082 : \u03b1) (n\u2081 n\u2082 : HeapNode \u03b1) : \u03b1 \u00d7 HeapNode \u03b1 :=\n  if le a\u2081 a\u2082 then (a\u2081, .node a\u2082 n\u2082 n\u2081) else (a\u2082, .node a\u2081 n\u2081 n\u2082)", "start": [117, 1], "end": [122, 66], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.merge", "code": "@[specialize] def Heap.merge (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : Heap \u03b1 \u2192 Heap \u03b1 \u2192 Heap \u03b1\n  | .nil, h  => h\n  | h,  .nil => h\n  | s\u2081@(.cons r\u2081 a\u2081 n\u2081 t\u2081), s\u2082@(.cons r\u2082 a\u2082 n\u2082 t\u2082) =>\n    if r\u2081 < r\u2082 then .cons r\u2081 a\u2081 n\u2081 (merge le t\u2081 s\u2082)\n    else if r\u2082 < r\u2081 then .cons r\u2082 a\u2082 n\u2082 (merge le s\u2081 t\u2082)\n    else\n      let (a, n) := combine le a\u2081 a\u2082 n\u2081 n\u2082\n      let r := r\u2081 + 1\n      if t\u2081.rankGT r then if t\u2082.rankGT r\n        then .cons r a n (merge le t\u2081 t\u2082)\n        else merge le (.cons r a n t\u2081) t\u2082\n      else if t\u2082.rankGT r\n        then merge le t\u2081 (.cons r a n t\u2082)\n        else .cons r a n (merge le t\u2081 t\u2082)\ntermination_by _ s\u2081 s\u2082 => s\u2081.length + s\u2082.length", "start": [124, 1], "end": [143, 48], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.toHeap", "code": "def HeapNode.toHeap (s : HeapNode \u03b1) : Heap \u03b1 := go s s.rank .nil where\n  \n  go : HeapNode \u03b1 \u2192 Nat \u2192 Heap \u03b1 \u2192 Heap \u03b1\n  | .nil, _, res => res\n  | .node a c s, n, res => go s (n - 1) (.cons (n - 1) a c res)", "start": [145, 1], "end": [153, 64], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.headD", "code": "@[specialize] def Heap.headD (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : \u03b1) : Heap \u03b1 \u2192 \u03b1\n  | .nil => a\n  | .cons _ b _ hs => headD le (if le a b then a else b) hs", "start": [155, 1], "end": [158, 60], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.head?", "code": "@[inline] def Heap.head? (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : Heap \u03b1 \u2192 Option \u03b1\n  | .nil => none\n  | .cons _ h _ hs => some <| headD le h hs", "start": [160, 1], "end": [163, 44], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.FindMin", "code": "structure FindMin (\u03b1) where\n  \n  before : Heap \u03b1 \u2192 Heap \u03b1 := id\n  \n  val : \u03b1\n  \n  node : HeapNode \u03b1\n  \n  next : Heap \u03b1", "start": [165, 1], "end": [177, 16], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.findMin", "code": "@[specialize] def Heap.findMin (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (k : Heap \u03b1 \u2192 Heap \u03b1) :\n    Heap \u03b1 \u2192 FindMin \u03b1 \u2192 FindMin \u03b1\n  | .nil, res => res\n  | .cons r a c s, res =>\n    findMin le (k \u2218 .cons r a c) s <| if le res.val a then res else \u27e8k, a, c, s\u27e9", "start": [179, 1], "end": [190, 81], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.deleteMin", "code": "def Heap.deleteMin (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : Heap \u03b1 \u2192 Option (\u03b1 \u00d7 Heap \u03b1)\n  | .nil => none\n  | .cons r a c s =>\n    let { before, val, node, next } := findMin le (.cons r a c) s \u27e8id, a, c, s\u27e9\n    some (val, node.toHeap.merge le (before next))", "start": [192, 1], "end": [197, 51], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.tail?", "code": "@[inline] def Heap.tail? (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (h : Heap \u03b1) : Option (Heap \u03b1) :=\n  deleteMin le h |>.map (\u00b7.snd)", "start": [199, 1], "end": [201, 32], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.tail", "code": "@[inline] def Heap.tail (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (h : Heap \u03b1) : Heap \u03b1 := tail? le h |>.getD .nil", "start": [203, 1], "end": [204, 93], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.realSize_merge", "code": "theorem Heap.realSize_merge (le) (s\u2081 s\u2082 : Heap \u03b1) :\n    (s\u2081.merge le s\u2082).realSize = s\u2081.realSize + s\u2082.realSize", "start": [206, 1], "end": [222, 42], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.FindMin.HasSize", "code": "private def FindMin.HasSize (res : FindMin \u03b1) (n : Nat) : Prop :=\n  \u2203 m,\n    (\u2200 s, (res.before s).realSize = m + s.realSize) \u2227\n    n = m + res.node.realSize + res.next.realSize + 1", "start": [224, 1], "end": [227, 54], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.realSize_findMin", "code": "private theorem Heap.realSize_findMin {s : Heap \u03b1}\n    (m) (hk : \u2200 s, (k s).realSize = m + s.realSize)\n    (eq : n = m + s.realSize) (hres : res.HasSize n) :\n    (s.findMin le k res).HasSize n", "start": [229, 1], "end": [241, 82], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.realSize_toHeap", "code": "theorem HeapNode.realSize_toHeap (s : HeapNode \u03b1) : s.toHeap.realSize = s.realSize", "start": [243, 1], "end": [246, 77], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.realSize_deleteMin", "code": "theorem Heap.realSize_deleteMin {s : Heap \u03b1} (eq : s.deleteMin le = some (a, s')) :\n    s.realSize = s'.realSize + 1", "start": [248, 1], "end": [258, 96], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.realSize_tail?", "code": "theorem Heap.realSize_tail? {s : Heap \u03b1} : s.tail? le = some s' \u2192\n    s.realSize = s'.realSize + 1", "start": [260, 1], "end": [264, 54], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.realSize_tail", "code": "theorem Heap.realSize_tail (le) (s : Heap \u03b1) : (s.tail le).realSize = s.realSize - 1", "start": [266, 1], "end": [270, 50], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.foldM", "code": "@[specialize] def Heap.foldM [Monad m] (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (s : Heap \u03b1)\n    (init : \u03b2) (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) : m \u03b2 :=\n  match eq : s.deleteMin le with\n  | none => pure init\n  | some (hd, tl) => do\n    have : tl.realSize < s.realSize := by simp_arith [Heap.realSize_deleteMin eq]\n    foldM le tl (\u2190 f init hd) f\ntermination_by _ => s.realSize", "start": [272, 1], "end": [283, 31], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.fold", "code": "@[inline] def Heap.fold (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (s : Heap \u03b1) (init : \u03b2) (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) : \u03b2 :=\n  Id.run <| s.foldM le init f", "start": [285, 1], "end": [290, 30], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.toArray", "code": "@[inline] def Heap.toArray (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (s : Heap \u03b1) : Array \u03b1 := fold le s #[] Array.push", "start": [292, 1], "end": [293, 98], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.toList", "code": "@[inline] def Heap.toList (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (s : Heap \u03b1) : List \u03b1 := (s.toArray le).toList", "start": [295, 1], "end": [296, 93], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.foldTreeM", "code": "@[specialize] def HeapNode.foldTreeM : HeapNode \u03b1 \u2192 m \u03b2\n  | .nil => pure nil\n  | .node a c s => do join a (\u2190 c.foldTreeM) (\u2190 s.foldTreeM)", "start": [301, 1], "end": [304, 61], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.foldTreeM", "code": "@[specialize] def Heap.foldTreeM : Heap \u03b1 \u2192 m \u03b2\n  | .nil => pure nil\n  | .cons _ a c s => do join a (\u2190 c.foldTreeM nil join) (\u2190 s.foldTreeM)", "start": [306, 1], "end": [309, 72], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.foldTree", "code": "@[inline] def Heap.foldTree (nil : \u03b2) (join : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2) (s : Heap \u03b1) : \u03b2 :=\n  Id.run <| s.foldTreeM nil join", "start": [313, 1], "end": [315, 33], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.toListUnordered", "code": "def Heap.toListUnordered (s : Heap \u03b1) : List \u03b1 :=\n  s.foldTree id (fun a c s l => a :: c (s l)) []", "start": [317, 1], "end": [319, 49], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.toArrayUnordered", "code": "def Heap.toArrayUnordered (s : Heap \u03b1) : Array \u03b1 :=\n  s.foldTree id (fun a c s r => s (c (r.push a))) #[]", "start": [321, 1], "end": [323, 54], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.WF", "code": "def HeapNode.WF (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : \u03b1) : HeapNode \u03b1 \u2192 Nat \u2192 Prop\n  | .nil, r => r = 0\n  | .node b c s, r => \u2203 r', r = r' + 1 \u2227 (\u2200 [TotalBLE le], le a b) \u2227 c.WF le b r' \u2227 s.WF le a r'", "start": [325, 1], "end": [335, 97], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF", "code": "def Heap.WF (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (n : Nat) : Heap \u03b1 \u2192 Prop\n  | .nil => True\n  | .cons r a c s => n \u2264 r \u2227 c.WF le a r \u2227 s.WF le (r+1)", "start": [337, 1], "end": [345, 57], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.nil", "code": "theorem Heap.WF.nil : Heap.nil.WF le n", "start": [347, 1], "end": [347, 50], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.singleton", "code": "theorem Heap.WF.singleton : (Heap.singleton a).WF le 0", "start": [349, 1], "end": [349, 79], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.of_rankGT", "code": "theorem Heap.WF.of_rankGT (hlt : s.rankGT n) (h : Heap.WF le n' s) : s.WF le (n+1)", "start": [351, 1], "end": [354, 52], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.of_le", "code": "theorem Heap.WF.of_le (hle : n \u2264 n') (h : Heap.WF le n' s) : s.WF le n", "start": [356, 1], "end": [359, 69], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.rankGT.of_le", "code": "theorem Heap.rankGT.of_le (h : Heap.rankGT s n) (h' : n' \u2264 n) : s.rankGT n'", "start": [361, 1], "end": [364, 40], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.rankGT", "code": "theorem Heap.WF.rankGT (h : Heap.WF lt (n+1) s) : s.rankGT n", "start": [366, 1], "end": [369, 38], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.merge'", "code": "theorem Heap.WF.merge' (h\u2081 : s\u2081.WF le n) (h\u2082 : s\u2082.WF le n) :\n    (merge le s\u2081 s\u2082).WF le n \u2227 ((s\u2081.rankGT n \u2194 s\u2082.rankGT n) \u2192 (merge le s\u2081 s\u2082).rankGT n)", "start": [371, 1], "end": [405, 42], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.merge", "code": "theorem Heap.WF.merge (h\u2081 : s\u2081.WF le n) (h\u2082 : s\u2082.WF le n) : (merge le s\u2081 s\u2082).WF le n", "start": [407, 1], "end": [408, 19], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.WF.rank_eq", "code": "theorem HeapNode.WF.rank_eq : \u2200 {n} {s : HeapNode \u03b1}, s.WF le a n \u2192 s.rank = n", "start": [410, 1], "end": [412, 68], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.WF.toHeap", "code": "theorem HeapNode.WF.toHeap {s : HeapNode \u03b1} (h : s.WF le a n) : s.toHeap.WF le 0", "start": [414, 1], "end": [420, 75], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.FindMin.WF", "code": "structure FindMin.WF (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (res : FindMin \u03b1) where\n  \n  rank : Nat\n  \n  before : \u2200 {s}, s.WF le rank \u2192 (res.before s).WF le 0\n  \n  node : res.node.WF le res.val rank\n  \n  next : res.next.WF le (rank + 1)", "start": [422, 1], "end": [436, 35], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.findMin", "code": "def Heap.WF.findMin {s : Heap \u03b1} (h : s.WF le n) (hr : res.WF le)\n    (hk : \u2200 {s}, s.WF le n \u2192 (k s).WF le 0) : ((s : Heap \u03b1).findMin le k res).WF le :=\n  match s with\n  | .nil => hr\n  | .cons r a c s => by\n    let \u27e8h\u2081, h\u2082, h\u2083\u27e9 := h\n    simp [Heap.findMin]\n    cases le res.val a with\n    | true  => exact findMin h\u2083 hr (fun h => hk \u27e8h\u2081, h\u2082, h\u27e9)\n    | false => exact findMin h\u2083 \u27e8_, fun h => hk (h.of_le h\u2081), h\u2082, h\u2083\u27e9 (fun h => hk \u27e8h\u2081, h\u2082, h\u27e9)", "start": [438, 1], "end": [448, 96], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.deleteMin", "code": "theorem Heap.WF.deleteMin {s : Heap \u03b1}\n    (h : s.WF le n) (eq : s.deleteMin le = some (a, s')) : s'.WF le 0", "start": [450, 1], "end": [460, 59], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.tail?", "code": "theorem Heap.WF.tail? (hwf : (s : Heap \u03b1).WF le n) : s.tail? le = some tl \u2192 tl.WF le 0", "start": [462, 1], "end": [465, 49], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.tail", "code": "theorem Heap.WF.tail (hwf : (s : Heap \u03b1).WF le n) : (s.tail le).WF le 0", "start": [467, 1], "end": [471, 34], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap", "code": "def BinomialHeap (\u03b1 : Type u) (le : \u03b1 \u2192 \u03b1 \u2192 Bool) :=\n  { h : Heap \u03b1 // h.WF le 0 }", "start": [478, 1], "end": [493, 30], "kind": "commanddeclaration"}, {"full_name": "Std.mkBinomialHeap", "code": "@[inline] def mkBinomialHeap (\u03b1 : Type u) (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : BinomialHeap \u03b1 le :=\n  \u27e8.nil, Heap.WF.nil\u27e9", "start": [495, 1], "end": [497, 22], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.empty", "code": "@[inline] def empty : BinomialHeap \u03b1 le := mkBinomialHeap \u03b1 le", "start": [502, 1], "end": [503, 63], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.isEmpty", "code": "@[inline] def isEmpty (b : BinomialHeap \u03b1 le) : Bool := b.1.isEmpty", "start": [507, 1], "end": [508, 68], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.size", "code": "@[inline] def size (b : BinomialHeap \u03b1 le) : Nat := b.1.size", "start": [510, 1], "end": [511, 61], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.singleton", "code": "@[inline] def singleton (a : \u03b1) : BinomialHeap \u03b1 le := \u27e8Heap.singleton a, Heap.WF.singleton\u27e9", "start": [513, 1], "end": [514, 93], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.merge", "code": "@[inline] def merge : BinomialHeap \u03b1 le \u2192 BinomialHeap \u03b1 le \u2192 BinomialHeap \u03b1 le\n  | \u27e8b\u2081, h\u2081\u27e9, \u27e8b\u2082, h\u2082\u27e9 => \u27e8b\u2081.merge le b\u2082, h\u2081.merge h\u2082\u27e9", "start": [516, 1], "end": [518, 56], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.insert", "code": "@[inline] def insert (a : \u03b1) (h : BinomialHeap \u03b1 le) : BinomialHeap \u03b1 le := merge (singleton a) h", "start": [520, 1], "end": [521, 98], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.ofList", "code": "def ofList (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (as : List \u03b1) : BinomialHeap \u03b1 le := as.foldl (flip insert) empty", "start": [523, 1], "end": [524, 97], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.ofArray", "code": "def ofArray (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (as : Array \u03b1) : BinomialHeap \u03b1 le := as.foldl (flip insert) empty", "start": [526, 1], "end": [527, 99], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.deleteMin", "code": "@[inline] def deleteMin (b : BinomialHeap \u03b1 le) : Option (\u03b1 \u00d7 BinomialHeap \u03b1 le) :=\n  match eq : b.1.deleteMin le with\n  | none => none\n  | some (a, tl) => some (a, \u27e8tl, b.2.deleteMin eq\u27e9)", "start": [529, 1], "end": [533, 53], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.forIn", "code": "protected def forIn [Monad m] (b : BinomialHeap \u03b1 le) (x : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  ForInStep.run <$> b.1.foldM le (.yield x) fun x a => x.bind (f a)", "start": [537, 1], "end": [542, 68], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.head?", "code": "@[inline] def head? (b : BinomialHeap \u03b1 le) : Option \u03b1 := b.1.head? le", "start": [546, 1], "end": [547, 71], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.head!", "code": "@[inline] def head! [Inhabited \u03b1] (b : BinomialHeap \u03b1 le) : \u03b1 := b.head?.get!", "start": [549, 1], "end": [550, 78], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.headI", "code": "@[inline] def headI [Inhabited \u03b1] (b : BinomialHeap \u03b1 le) : \u03b1 := b.head?.getD default", "start": [552, 1], "end": [553, 86], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.tail?", "code": "@[inline] def tail? (b : BinomialHeap \u03b1 le) : Option (BinomialHeap \u03b1 le) :=\n  match eq : b.1.tail? le with\n  | none => none\n  | some tl => some \u27e8tl, b.2.tail? eq\u27e9", "start": [555, 1], "end": [559, 39], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.tail", "code": "@[inline] def tail (b : BinomialHeap \u03b1 le) : BinomialHeap \u03b1 le := \u27e8b.1.tail le, b.2.tail\u27e9", "start": [561, 1], "end": [562, 90], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.foldM", "code": "@[inline] def foldM [Monad m] (b : BinomialHeap \u03b1 le) (init : \u03b2) (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) : m \u03b2 :=\n  b.1.foldM le init f", "start": [564, 1], "end": [569, 22], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.fold", "code": "@[inline] def fold (b : BinomialHeap \u03b1 le) (init : \u03b2) (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) : \u03b2 := b.1.fold le init f", "start": [571, 1], "end": [575, 96], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.toList", "code": "@[inline] def toList (b : BinomialHeap \u03b1 le) : List \u03b1 := b.1.toList le", "start": [577, 1], "end": [578, 71], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.toArray", "code": "@[inline] def toArray (b : BinomialHeap \u03b1 le) : Array \u03b1 := b.1.toArray le", "start": [580, 1], "end": [581, 74], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.toListUnordered", "code": "@[inline] def toListUnordered (b : BinomialHeap \u03b1 le) : List \u03b1 := b.1.toListUnordered", "start": [583, 1], "end": [584, 86], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.toArrayUnordered", "code": "@[inline] def toArrayUnordered (b : BinomialHeap \u03b1 le) : Array \u03b1 := b.1.toArrayUnordered", "start": [586, 1], "end": [587, 89], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/Typ.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Qq.Quoted", "code": "def Quoted (\u03b1 : Expr) := Expr", "start": [8, 1], "end": [13, 30], "kind": "commanddeclaration"}, {"full_name": "Qq.Quoted.unsafeMk", "code": "protected def Quoted.unsafeMk (e : Expr) : Quoted \u03b1 := e", "start": [15, 1], "end": [20, 57], "kind": "commanddeclaration"}, {"full_name": "Qq.Quoted.ty", "code": "protected abbrev Quoted.ty (t : Quoted \u03b1) : Expr := \u03b1", "start": [32, 1], "end": [33, 54], "kind": "commanddeclaration"}, {"full_name": "Qq.QuotedDefEq", "code": "structure QuotedDefEq {\u03b1 : Quoted (.sort u)} (lhs rhs : Quoted \u03b1) : Prop :=\n  unsafeIntro ::", "start": [35, 1], "end": [41, 17], "kind": "commanddeclaration"}, {"full_name": "Qq.QuotedLevelDefEq", "code": "structure QuotedLevelDefEq (u v : Level) : Prop :=\n  unsafeIntro ::", "start": [43, 1], "end": [49, 17], "kind": "commanddeclaration"}, {"full_name": "Qq.Quoted.check", "code": "protected def Quoted.check (e : Quoted \u03b1) : MetaM Unit := do\n  let \u03b1' \u2190 inferType e\n  unless \u2190 isDefEq \u03b1 \u03b1' do\n    throwError \"type mismatch{indentExpr e}\\n{\u2190 mkHasTypeButIsExpectedMsg \u03b1' \u03b1}\"", "start": [52, 1], "end": [55, 81], "kind": "commanddeclaration"}, {"full_name": "Qq.QuotedDefEq.check", "code": "protected def QuotedDefEq.check (e : @QuotedDefEq u \u03b1 lhs rhs) : MetaM Unit := do\n  \u03b1.check\n  lhs.check\n  rhs.check\n  unless \u2190 isDefEq lhs rhs do\n    throwError \"{lhs} and {rhs} are not defeq\"", "start": [58, 1], "end": [63, 47], "kind": "commanddeclaration"}, {"full_name": "Qq.QuotedLevelDefEq.check", "code": "protected def QuotedLevelDefEq.check (e : QuotedLevelDefEq lhs rhs) : MetaM Unit := do\n  unless \u2190 isLevelDefEq lhs rhs do\n    throwError \"{lhs} and {rhs} are not defeq\"", "start": [66, 1], "end": [68, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/ForLean/ReduceEval.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.throwFailedToEval", "code": "def throwFailedToEval (e : Expr) : MetaM \u03b1 :=\n  throwError \"reduceEval: failed to evaluate argument{indentExpr e}\"", "start": [6, 1], "end": [7, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.evalList", "code": "private partial def evalList [ReduceEval \u03b1] (e : Expr) : MetaM (List \u03b1) := do\n  let e \u2190 whnf e\n  let .const c _ \u2190 pure e.getAppFn | throwFailedToEval e\n  let nargs := e.getAppNumArgs\n  match c, nargs with\n    | ``List.nil, 1 => pure []\n    | ``List.cons, 3 => return (\u2190 reduceEval (e.getArg! 1)) :: (\u2190 evalList (e.getArg! 2))\n    | _, _ => throwFailedToEval e", "start": [9, 1], "end": [16, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/ForLean/ToExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "toExprLevel", "code": "private def toExprLevel : Level \u2192 Expr\n  | zero       => .const ``zero []\n  | succ l     => mkApp (.const ``succ []) (toExprLevel l)\n  | .max l\u2081 l\u2082 => mkApp2 (.const ``Level.max []) (toExprLevel l\u2081) (toExprLevel l\u2082)\n  | imax l\u2081 l\u2082 => mkApp2 (.const ``imax []) (toExprLevel l\u2081) (toExprLevel l\u2082)\n  | param n    => mkApp (.const ``param []) (toExpr n)\n  | mvar n     => mkApp (.const ``mvar []) (toExpr n)", "start": [24, 1], "end": [30, 54], "kind": "commanddeclaration"}, {"full_name": "toExprExpr", "code": "private def toExprExpr : Expr \u2192 Expr\n  | bvar n        => mkApp (.const ``bvar []) (mkNatLit n)\n  | fvar n        => mkApp (.const ``fvar []) (toExpr n)\n  | mvar n        => mkApp (.const ``mvar []) (toExpr n)\n  | sort l        => mkApp (.const ``sort []) (toExpr l)\n  | const n ls    => mkApp2 (.const ``const []) (toExpr n) (toExpr ls)\n  | app f x       => mkApp2 (.const ``app []) (toExprExpr f) (toExprExpr x)\n  | lam x d b c     => mkApp4 (.const ``lam []) (toExpr x) (toExprExpr d) (toExprExpr b) (toExpr c)\n  | forallE x d b c => mkApp4 (.const ``forallE []) (toExpr x) (toExprExpr d) (toExprExpr b) (toExpr c)\n  | letE x t v b c  => mkApp5 (.const ``letE []) (toExpr x) (toExprExpr t) (toExprExpr v) (toExprExpr b) (toExpr c)\n  | lit l         => mkApp (.const ``lit []) (toExpr l)\n  | mdata md e    => mkApp2 (.const ``mdata []) (toExpr md) (toExprExpr e)\n  | proj s i e    => mkApp3 (.const ``proj []) (toExpr s) (mkNatLit i) (toExprExpr e)", "start": [64, 1], "end": [76, 86], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Rule/Basic.lean", "imports": ["lake-packages/aesop/Aesop/Index/Basic.lean", "lake-packages/aesop/Aesop/RuleTac/Basic.lean", "lake-packages/aesop/Aesop/Rule/Name.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Rule", "code": "structure Rule (\u03b1 : Type) where\n  name : RuleName\n  indexingMode : IndexingMode\n  extra : \u03b1\n  tac : RuleTacDescr\n  deriving Inhabited", "start": [15, 1], "end": [20, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rule.compareByPriority", "code": "def compareByPriority [Ord \u03b1] (r s : Rule \u03b1) : Ordering :=\n  compare r.extra s.extra", "start": [33, 1], "end": [34, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rule.compareByName", "code": "def compareByName (r s : Rule \u03b1) : Ordering :=\n  r.name.compare s.name", "start": [36, 1], "end": [37, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rule.compareByPriorityThenName", "code": "def compareByPriorityThenName [Ord \u03b1] (r s : Rule \u03b1) : Ordering :=\n  match compareByPriority r s with\n  | Ordering.eq => compareByName r s\n  | ord => ord", "start": [39, 1], "end": [42, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rule.map", "code": "@[inline]\nprotected def map (f : \u03b1 \u2192 \u03b2) (r : Rule \u03b1) : Rule \u03b2 :=\n  { r with extra := f r.extra }", "start": [44, 1], "end": [46, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rule.mapM", "code": "@[inline]\nprotected def mapM [Monad m] (f : \u03b1 \u2192 m \u03b2) (r : Rule \u03b1) : m (Rule \u03b2) :=\n  return { r with extra := \u2190 f r.extra }", "start": [48, 1], "end": [50, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Index.lean", "imports": ["lake-packages/aesop/Aesop/Index/Basic.lean", "lake-packages/std/Std/Lean/Meta/InstantiateMVars.lean", "lake-packages/aesop/Aesop/Tracing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Index", "code": "structure Index (\u03b1 : Type) [BEq \u03b1] [Hashable \u03b1] where\n  byTarget : DiscrTree \u03b1 simpleReduce\n  byHyp : DiscrTree \u03b1 simpleReduce\n  unindexed : PHashSet \u03b1\n  deriving Inhabited", "start": [16, 1], "end": [20, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.trace", "code": "def trace [ToString \u03b1] (ri : Index \u03b1) (traceOpt : TraceOption) :\n    CoreM Unit := do\n  if ! (\u2190 traceOpt.isEnabled) then\n    return\n  withConstAesopTraceNode traceOpt (return \"Indexed by target\") do\n    traceArray ri.byTarget.values\n  withConstAesopTraceNode traceOpt (return \"Indexed by hypotheses\") do\n    traceArray ri.byHyp.values\n  withConstAesopTraceNode traceOpt (return \"Unindexed\") do\n    traceArray $ PersistentHashSet.toArray ri.unindexed\n  where\n    traceArray (as : Array \u03b1) : CoreM Unit :=\n      as.map toString |>.qsortOrd.forM \u03bb r => do aesop_trace![traceOpt] r", "start": [26, 1], "end": [38, 74], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.merge", "code": "def merge (ri\u2081 ri\u2082 : Index \u03b1) : Index \u03b1 where\n  byTarget := ri\u2081.byTarget.mergePreservingDuplicates ri\u2082.byTarget\n  byHyp := ri\u2081.byHyp.mergePreservingDuplicates ri\u2082.byHyp\n  unindexed := ri\u2081.unindexed.merge ri\u2082.unindexed", "start": [47, 1], "end": [50, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.add", "code": "@[specialize]\npartial def add (r : \u03b1) (imode : IndexingMode) (ri : Index \u03b1) :\n    Index \u03b1 :=\n  match imode with\n  | IndexingMode.unindexed =>\n    { ri with unindexed := ri.unindexed.insert r }\n  | IndexingMode.target keys =>\n    { ri with byTarget := ri.byTarget.insertCore keys r }\n  | IndexingMode.hyps keys =>\n    { ri with byHyp := ri.byHyp.insertCore keys r }\n  | IndexingMode.or imodes =>\n    imodes.foldl (init := ri) \u03bb ri imode =>\n      ri.add r imode", "start": [52, 1], "end": [64, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.unindex", "code": "def unindex (ri : Index \u03b1) (p : \u03b1 \u2192 Bool) : Index \u03b1 :=\n  let (byTarget, unindexed) := filterDiscrTree' ri.unindexed ri.byTarget\n  let (byHyp,    unindexed) := filterDiscrTree' unindexed ri.byHyp\n  { byTarget, byHyp, unindexed }\n  where\n    @[inline, always_inline]\n    filterDiscrTree' {s} (unindexed : PHashSet \u03b1) (t : DiscrTree \u03b1 s) :\n        DiscrTree \u03b1 s \u00d7 PHashSet \u03b1 :=\n      filterDiscrTree (not \u2218 p) (\u03bb unindexed v => unindexed.insert v) unindexed\n        t", "start": [66, 1], "end": [75, 10], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.foldM", "code": "def foldM [Monad m] (ri : Index \u03b1) (f : \u03c3 \u2192 \u03b1 \u2192 m \u03c3) (init : \u03c3) : m \u03c3 :=\n  match ri with\n  | { byHyp, byTarget, unindexed} => do\n    let mut s := init\n    s \u2190 byHyp.foldValuesM (init := s) f\n    s \u2190 byTarget.foldValuesM (init := s) f\n    unindexed.foldM (init := s) f", "start": [77, 1], "end": [83, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.fold", "code": "@[inline]\ndef fold (ri : Index \u03b1) (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3) (init : \u03c3) : \u03c3 :=\n  Id.run $ ri.foldM (init := init) f", "start": [85, 1], "end": [87, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.size", "code": "def size : Index \u03b1 \u2192 Nat\n  | { byHyp, byTarget, unindexed } =>\n    byHyp.size + byTarget.size + unindexed.size", "start": [89, 1], "end": [91, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.applicableByTargetRules", "code": "@[inline]\nprivate def applicableByTargetRules (ri : Index \u03b1) (goal : MVarId)\n    (include? : \u03b1 \u2192 Bool) : MetaM (Array (\u03b1 \u00d7 Array IndexMatchLocation)) :=\n  goal.withContext do\n    let rules \u2190 ri.byTarget.getUnify (\u2190 goal.getType)\n    let mut rs := Array.mkEmpty rules.size\n      for r in rules do\n      if include? r then\n        rs := rs.push (r, #[.target])\n    return rs", "start": [94, 1], "end": [104, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.applicableByHypRules", "code": "@[inline]\nprivate def applicableByHypRules (ri : Index \u03b1) (goal : MVarId)\n    (include? : \u03b1 \u2192 Bool) : MetaM (Array (\u03b1 \u00d7 Array IndexMatchLocation)) :=\n  goal.withContext do\n    let mut rs := #[]\n    for localDecl in \u2190 getLCtx do\n      if localDecl.isImplementationDetail then\n        continue\n      let rules \u2190 ri.byHyp.getUnify localDecl.type\n      for r in rules do\n        if include? r then\n          rs := rs.push (r, #[.hyp localDecl])\n    return rs", "start": [107, 1], "end": [119, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.applicableUnindexedRules", "code": "@[inline]\nprivate def applicableUnindexedRules (ri : Index \u03b1) (include? : \u03b1 \u2192 Bool) :\n    Array (\u03b1 \u00d7 Array IndexMatchLocation) :=\n  ri.unindexed.fold (init := Array.mkEmpty ri.unindexed.size) \u03bb acc r =>\n    if include? r then\n      acc.push (r, #[.none])\n    else\n      acc", "start": [122, 1], "end": [130, 10], "kind": "commanddeclaration"}, {"full_name": "Aesop.Index.applicableRules", "code": "@[specialize]\ndef applicableRules [ord : Ord \u03b1] (ri : Index \u03b1) (goal : MVarId)\n    (include? : \u03b1 \u2192 Bool) : MetaM (Array (IndexMatchResult \u03b1)) := do\n  goal.instantiateMVars\n  let mut result := mkRBMap \u03b1 (Array IndexMatchLocation) compare\n  result := insertIndexMatchResults result\n    (\u2190 applicableByTargetRules ri goal include?)\n  result := insertIndexMatchResults result\n    (\u2190 applicableByHypRules ri goal include?)\n  result := insertIndexMatchResults result\n    (applicableUnindexedRules ri include?)\n  return result.fold (init := Array.mkEmpty result.size) \u03bb rs rule locs =>\n    rs.push { rule := rule, locations := .ofArray locs }\n  where\n    @[inline]\n    insertIndexMatchResults (m : RBMap \u03b1 (Array IndexMatchLocation) compare)\n        (rs : Array (\u03b1 \u00d7 Array IndexMatchLocation)) :\n        RBMap \u03b1 (Array IndexMatchLocation) compare :=\n      rs.foldl (init := m) \u03bb m (rule, locs) =>\n        match m.find? rule with\n        | none => m.insert rule locs\n        | some locs' => m.insert rule (locs' ++ locs)", "start": [134, 1], "end": [155, 54], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/CodeAction/Misc.lean", "imports": ["lake-packages/std/Std/Lean/Position.lean", "lake-packages/std/Std/Lean/Name.lean", "lake-packages/std/Std/CodeAction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.CodeAction.findStack?", "code": "def findStack? (root target : Syntax) : Option Syntax.Stack := do\n  let range \u2190 target.getRange?\n  root.findStack? (\u00b7.getRange?.any (\u00b7.includes range))\n    (fun s => s.getKind == target.getKind && s.getRange? == range)", "start": [19, 1], "end": [23, 67], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.holeKindToHoleString", "code": "def holeKindToHoleString : (elaborator : Name) \u2192 (synthName : String) \u2192 String\n  | ``Elab.Term.elabSyntheticHole, name => \"?\" ++ name\n  | ``Elab.Term.elabSorry, _ => \"sorry\"\n  | _, _ => \"_\"", "start": [25, 1], "end": [29, 16], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.instanceStub", "code": "@[hole_code_action] partial def instanceStub : HoleCodeAction := fun params snap ctx info => do\n  let some ty := info.expectedType? | return #[]\n  let .const name _ := (\u2190 info.runMetaM ctx (whnf ty)).getAppFn | return #[]\n  unless isStructure snap.env name do return #[]\n  let eager := {\n    title := \"Generate a skeleton for the structure under construction.\"\n    kind? := \"quickfix\"\n    isPreferred? := true\n  }\n  let doc \u2190 readDoc\n  pure #[{\n    eager\n    lazy? := some do\n      let useWhere := do\n        let _ :: (stx, _) :: _ \u2190 findStack? snap.stx info.stx | none\n        guard (stx.getKind == ``Parser.Command.declValSimple)\n        stx[0].getPos?\n      let holePos := useWhere.getD info.stx.getPos?.get!\n      let (indent, isStart) := findIndentAndIsStart doc.meta.text.source holePos\n      let indent := \"\\n\".pushn ' ' indent\n      let mut str := if useWhere.isSome then \"where\" else \"{\"\n      let mut first := useWhere.isNone && isStart\n      for field in collectFields snap.env name #[] do\n        if first then\n          str := str ++ \" \"\n          first := false\n        else\n          str := str ++ indent ++ \"  \"\n        let field := toString field\n        str := str ++ s!\"{field} := {holeKindToHoleString info.elaborator field}\"\n      if useWhere.isNone then\n        if isStart then\n          str := str ++ \" }\"\n        else\n          str := str ++ indent ++ \"}\"\n      pure { eager with\n        edit? := some <| .ofTextEdit params.textDocument.uri {\n          range := doc.meta.text.utf8RangeToLspRange \u27e8holePos, info.stx.getTailPos?.get!\u27e9\n          newText := str\n        }\n      }\n  }]\nwhere\n  \n  collectFields (env : Environment) (structName : Name) (fields : Array Name) : Array Name :=\n    (getStructureFields env structName).foldl (init := fields) fun fields field =>\n      match isSubobjectField? env structName field with\n      | some substructName => collectFields env substructName fields\n      | none => fields.push field", "start": [31, 1], "end": [100, 34], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.getExplicitArgs", "code": "def getExplicitArgs : Expr \u2192 Array Name \u2192 Array Name\n  | .forallE n _ body bi, args =>\n    getExplicitArgs body <| if bi.isExplicit then args.push n else args\n  | _, args => args", "start": [102, 1], "end": [106, 20], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.eqnStub", "code": "@[hole_code_action] def eqnStub : HoleCodeAction := fun params snap ctx info => do\n  let some ty := info.expectedType? | return #[]\n  let .forallE _ dom .. \u2190 info.runMetaM ctx (whnf ty) | return #[]\n  let .const name _ := (\u2190 info.runMetaM ctx (whnf dom)).getAppFn | return #[]\n  let some (.inductInfo val) := snap.env.find? name | return #[]\n  let eager := {\n    title := \"Generate a list of equations for a recursive definition.\"\n    kind? := \"quickfix\"\n  }\n  let doc \u2190 readDoc\n  pure #[{\n    eager\n    lazy? := some do\n      let holePos := info.stx.getPos?.get!\n      let (indent, isStart) := findIndentAndIsStart doc.meta.text.source holePos\n      let mut str := \"fun\"\n      let indent := \"\\n\".pushn ' ' (if isStart then indent else indent + 2)\n      for ctor in val.ctors do\n        let some (.ctorInfo ci) := snap.env.find? ctor | panic! \"bad inductive\"\n        let ctor := toString (ctor.updatePrefix .anonymous)\n        str := str ++ indent ++ s!\"| .{ctor}\"\n        for arg in getExplicitArgs ci.type #[] do\n          str := str ++ if arg.hasNum || arg.isInternal then \" _\" else s!\" {arg}\"\n        str := str ++ s!\" => {holeKindToHoleString info.elaborator ctor}\"\n      pure { eager with\n        edit? := some <|.ofTextEdit params.textDocument.uri {\n          range := doc.meta.text.utf8RangeToLspRange \u27e8holePos, info.stx.getTailPos?.get!\u27e9\n          newText := str\n        }\n      }\n  }]", "start": [108, 1], "end": [164, 5], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.startTacticStub", "code": "@[hole_code_action] def startTacticStub : HoleCodeAction := fun params _ _ info => do\n  let holePos := info.stx.getPos?.get!\n  let doc \u2190 readDoc\n  let indent := (findIndentAndIsStart doc.meta.text.source holePos).1\n  pure #[{\n    eager.title := \"Start a tactic proof.\"\n    eager.kind? := \"quickfix\"\n    eager.edit? := some <|.ofTextEdit params.textDocument.uri {\n      range := doc.meta.text.utf8RangeToLspRange \u27e8holePos, info.stx.getTailPos?.get!\u27e9\n      newText := \"by\\n\".pushn ' ' (indent + 2) ++ \"done\"\n    }\n  }]", "start": [166, 1], "end": [178, 5], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.removeAfterDoneAction", "code": "@[tactic_code_action*]\ndef removeAfterDoneAction : TacticCodeAction := fun params _ _ stk node => do\n  let .node (.ofTacticInfo info) _ := node | return #[]\n  unless info.goalsBefore.isEmpty do return #[]\n  let _ :: (seq, i) :: _ := stk | return #[]\n  let some stop := seq.getTailPos? | return #[]\n  let some prev := (seq.setArgs seq.getArgs[:i]).getTailPos? | return #[]\n  let doc \u2190 readDoc\n  let eager := {\n    title := \"Remove tactics after 'no goals'\"\n    kind? := \"quickfix\"\n    isPreferred? := true\n    edit? := some <|.ofTextEdit params.textDocument.uri {\n      range := doc.meta.text.utf8RangeToLspRange \u27e8prev, stop\u27e9\n      newText := \"\"\n    }\n  }\n  pure #[{ eager }]", "start": [180, 1], "end": [211, 20], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.getElimNames", "code": "def getElimNames (inductName declName : Name) : MetaM (Array (Name \u00d7 Array Name)) := do\n  let inductVal \u2190 getConstInfoInduct inductName\n  let decl \u2190 getConstInfo declName\n  forallTelescopeReducing decl.type fun xs type => do\n    let motive  := type.getAppFn\n    let targets := type.getAppArgs\n    let mut altsInfo := #[]\n    for i in [inductVal.numParams:xs.size] do\n      let x := xs[i]!\n      if x != motive && !targets.contains x then\n        let xDecl \u2190 x.fvarId!.getDecl\n        let args \u2190 forallTelescopeReducing xDecl.type fun args _ => do\n          let lctx \u2190 getLCtx\n          pure <| args.filterMap fun y =>\n            let yDecl := (lctx.find? y.fvarId!).get!\n            if yDecl.binderInfo.isExplicit then some yDecl.userName else none\n        altsInfo := altsInfo.push (xDecl.userName, args)\n    pure altsInfo", "start": [213, 1], "end": [234, 18], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.casesExpand", "code": "@[tactic_code_action Parser.Tactic.cases Parser.Tactic.induction]\ndef casesExpand : TacticCodeAction := fun params snap ctx _ node => do\n  let .node (.ofTacticInfo info) _ := node | return #[]\n  let (discr, induction, alts) \u2190 match info.stx with\n    | `(tactic| cases $[$_ :]? $e $[$alts:inductionAlts]?) => pure (e, false, alts)\n    | `(tactic| induction $e $[generalizing $_*]? $[$alts:inductionAlts]?) => pure (e, true, alts)\n    | _ => return #[]\n  if let some alts := alts then\n    unless alts.raw[2][0][0][0][0].isMissing do return #[]\n  let some (.ofTermInfo discrInfo) := node.findInfo? fun i =>\n    i.stx.getKind == discr.raw.getKind && i.stx.getRange? == discr.raw.getRange?\n    | return #[]\n  let .const name _ := (\u2190 discrInfo.runMetaM ctx (do whnf (\u2190 inferType discrInfo.expr))).getAppFn\n    | return #[]\n  let tacName := info.stx.getKind.updatePrefix .anonymous\n  let eager := {\n    title := s!\"Generate an explicit pattern match for '{tacName}'.\"\n    kind? := \"quickfix\"\n  }\n  let doc \u2190 readDoc\n  pure #[{\n    eager\n    lazy? := some do\n      let tacPos := info.stx.getPos?.get!\n      let endPos := doc.meta.text.utf8PosToLspPos info.stx.getTailPos?.get!\n      let startPos := if alts.isSome then\n        let stx' := info.stx.setArg (if induction then 4 else 3) mkNullNode\n        doc.meta.text.utf8PosToLspPos stx'.getTailPos?.get!\n      else endPos\n      let elimName := if induction then mkRecName name else mkCasesOnName name\n      let ctors \u2190 discrInfo.runMetaM ctx (getElimNames name elimName)\n      let newText := if ctors.isEmpty then \"\" else Id.run do\n        let mut str := \" with\"\n        let indent := \"\\n\".pushn ' ' (findIndentAndIsStart doc.meta.text.source tacPos).1\n        for (name, args) in ctors do\n          let mut ctor := toString name\n          if let some _ := (Parser.getTokenTable snap.env).find? ctor then\n            ctor := s!\"{idBeginEscape}{ctor}{idEndEscape}\"\n          str := str ++ indent ++ s!\"| {ctor}\"\n          let args := if induction &&\n            args.foldl (fun c n =>\n              if n.eraseMacroScopes.getString!.endsWith \"_ih\" then c+1 else c) 0 == 1\n          then\n            args.map (fun n => if !n.hasMacroScopes && n.getString!.endsWith \"_ih\" then `ih else n)\n          else args\n          for arg in args do\n            str := str ++ if arg.hasNum || arg.isInternal then \" _\" else s!\" {arg}\"\n          str := str ++ s!\" => sorry\"\n        str\n      pure { eager with\n        edit? := some <|.ofTextEdit params.textDocument.uri { range := \u27e8startPos, endPos\u27e9, newText }\n      }\n  }]", "start": [236, 1], "end": [307, 5], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.addSubgoalsActionCore", "code": "def addSubgoalsActionCore (params : Lsp.CodeActionParams)\n  (i : Nat) (stk : Syntax.Stack) (goals : List MVarId) : RequestM (Array LazyCodeAction) := do\n  unless goals.length > 1 do return #[]\n  let seq := stk.head!.1\n  let nargs := (seq.getNumArgs + 1) / 2\n  unless i == nargs do unless i + 1 == nargs && [\n        ``Parser.Tactic.done, ``Parser.Tactic.tacticSorry, ``Parser.Tactic.tacticAdmit\n      ].contains seq[2*i].getKind do\n      return #[]\n  let some startPos := seq[0].getPos? true | return #[]\n  let doc \u2190 readDoc\n  let eager := { title := \"Add subgoals\", kind? := \"quickfix\" }\n  pure #[{\n    eager\n    lazy? := some do\n      let indent := \"\\n\".pushn ' ' (doc.meta.text.toPosition startPos).column\n      let mut (range, newText) := (default, \"\")\n      if let some tac := seq.getArgs[2*i]? then\n        let some range2 := tac.getRange? true | return eager\n        range := range2\n      else\n        let trimmed := seq.modifyArgs (\u00b7[:2*i])\n        let some tail := trimmed.getTailPos? true | return eager\n        (range, newText) := (\u27e8tail, tail\u27e9, indent)\n        let cursor := doc.meta.text.lspPosToUtf8Pos params.range.end\n        if range.stop \u2264 cursor && cursor.1 \u2264 range.stop.1 + trimmed.getTrailingSize then\n          range := { range with stop := cursor }\n      newText := newText ++ \"\u00b7 done\"\n      for _ in goals.tail! do\n        newText := newText ++ indent ++ \"\u00b7 done\"\n      pure { eager with\n        edit? := some <|.ofTextEdit params.textDocument.uri {\n          range := doc.meta.text.utf8RangeToLspRange range\n          newText\n        }\n      }\n  }]", "start": [309, 1], "end": [364, 5], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.addSubgoalsSeqAction", "code": "@[inherit_doc addSubgoalsActionCore, tactic_code_action]\ndef addSubgoalsSeqAction : TacticSeqCodeAction := fun params _ _ => addSubgoalsActionCore params", "start": [366, 1], "end": [367, 97], "kind": "commanddeclaration"}, {"full_name": "Std.CodeAction.addSubgoalsAction", "code": "@[inherit_doc addSubgoalsActionCore,\n  tactic_code_action Parser.Tactic.done Parser.Tactic.tacticSorry Parser.Tactic.tacticAdmit]\ndef addSubgoalsAction : TacticCodeAction := fun params _ _ stk node => do\n  let (_ :: (seq, i) :: stk@(_ :: t :: _), .node (.ofTacticInfo info) _) := (stk, node) | return #[]\n  unless t.1.getKind == ``Parser.Tactic.tacticSeq do return #[]\n  addSubgoalsActionCore params (i/2) ((seq, 0) :: stk) info.goalsBefore", "start": [371, 1], "end": [376, 72], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Sum/Lemmas.lean", "imports": ["lake-packages/std/Std/Tactic/Ext.lean", "lake-packages/std/Std/Data/Sum/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sum.forall", "code": "@[simp] protected theorem \u00abforall\u00bb {p : \u03b1 \u2295 \u03b2 \u2192 Prop} :\n    (\u2200 x, p x) \u2194 (\u2200 a, p (inl a)) \u2227 \u2200 b, p (inr b)", "start": [20, 1], "end": [22, 73], "kind": "commanddeclaration"}, {"full_name": "Sum.exists", "code": "@[simp] protected theorem \u00abexists\u00bb {p : \u03b1 \u2295 \u03b2 \u2192 Prop} :\n    (\u2203 x, p x) \u2194 (\u2203 a, p (inl a)) \u2228 \u2203 b, p (inr b)", "start": [24, 1], "end": [31, 35], "kind": "commanddeclaration"}, {"full_name": "Sum.forall_sum", "code": "theorem forall_sum {\u03b3 : \u03b1 \u2295 \u03b2 \u2192 Sort _} (p : (\u2200 ab, \u03b3 ab) \u2192 Prop) :\n    (\u2200 fab, p fab) \u2194 (\u2200 fa fb, p (Sum.rec fa fb))", "start": [33, 1], "end": [38, 23], "kind": "commanddeclaration"}, {"full_name": "Sum.inl_getLeft", "code": "@[simp] theorem inl_getLeft : \u2200 (x : \u03b1 \u2295 \u03b2) (h : x.isLeft), inl (x.getLeft h) = x", "start": [42, 1], "end": [43, 20], "kind": "commanddeclaration"}, {"full_name": "Sum.inr_getRight", "code": "@[simp] theorem inr_getRight : \u2200 (x : \u03b1 \u2295 \u03b2) (h : x.isRight), inr (x.getRight h) = x", "start": [44, 1], "end": [45, 20], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft?_eq_none_iff", "code": "@[simp] theorem getLeft?_eq_none_iff {x : \u03b1 \u2295 \u03b2} : x.getLeft? = none \u2194 x.isRight", "start": [47, 1], "end": [48, 62], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight?_eq_none_iff", "code": "@[simp] theorem getRight?_eq_none_iff {x : \u03b1 \u2295 \u03b2} : x.getRight? = none \u2194 x.isLeft", "start": [50, 1], "end": [51, 62], "kind": "commanddeclaration"}, {"full_name": "Sum.eq_left_getLeft_of_isLeft", "code": "theorem eq_left_getLeft_of_isLeft : \u2200 {x : \u03b1 \u2295 \u03b2} (h : x.isLeft), x = inl (x.getLeft h)", "start": [53, 1], "end": [54, 20], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft_eq_iff", "code": "@[simp] theorem getLeft_eq_iff (h : x.isLeft) : x.getLeft h = a \u2194 x = inl a", "start": [56, 1], "end": [57, 26], "kind": "commanddeclaration"}, {"full_name": "Sum.eq_right_getRight_of_isRight", "code": "theorem eq_right_getRight_of_isRight : \u2200 {x : \u03b1 \u2295 \u03b2} (h : x.isRight), x = inr (x.getRight h)", "start": [59, 1], "end": [60, 20], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight_eq_iff", "code": "@[simp] theorem getRight_eq_iff (h : x.isRight) : x.getRight h = b \u2194 x = inr b", "start": [62, 1], "end": [63, 26], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft?_eq_some_iff", "code": "@[simp] theorem getLeft?_eq_some_iff : x.getLeft? = some a \u2194 x = inl a", "start": [65, 1], "end": [66, 65], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight?_eq_some_iff", "code": "@[simp] theorem getRight?_eq_some_iff : x.getRight? = some b \u2194 x = inr b", "start": [68, 1], "end": [69, 66], "kind": "commanddeclaration"}, {"full_name": "Sum.bnot_isLeft", "code": "@[simp] theorem bnot_isLeft (x : \u03b1 \u2295 \u03b2) : !x.isLeft = x.isRight", "start": [71, 1], "end": [71, 86], "kind": "commanddeclaration"}, {"full_name": "Sum.isLeft_eq_false", "code": "@[simp] theorem isLeft_eq_false {x : \u03b1 \u2295 \u03b2} : x.isLeft = false \u2194 x.isRight", "start": [73, 1], "end": [73, 98], "kind": "commanddeclaration"}, {"full_name": "Sum.not_isLeft", "code": "theorem not_isLeft {x : \u03b1 \u2295 \u03b2} : \u00acx.isLeft \u2194 x.isRight", "start": [75, 1], "end": [75, 66], "kind": "commanddeclaration"}, {"full_name": "Sum.bnot_isRight", "code": "@[simp] theorem bnot_isRight (x : \u03b1 \u2295 \u03b2) : !x.isRight = x.isLeft", "start": [77, 1], "end": [77, 87], "kind": "commanddeclaration"}, {"full_name": "Sum.isRight_eq_false", "code": "@[simp] theorem isRight_eq_false {x : \u03b1 \u2295 \u03b2} : x.isRight = false \u2194 x.isLeft", "start": [79, 1], "end": [79, 99], "kind": "commanddeclaration"}, {"full_name": "Sum.not_isRight", "code": "theorem not_isRight {x : \u03b1 \u2295 \u03b2} : \u00acx.isRight \u2194 x.isLeft", "start": [81, 1], "end": [81, 67], "kind": "commanddeclaration"}, {"full_name": "Sum.isLeft_iff", "code": "theorem isLeft_iff : x.isLeft \u2194 \u2203 y, x = Sum.inl y", "start": [83, 1], "end": [83, 74], "kind": "commanddeclaration"}, {"full_name": "Sum.isRight_iff", "code": "theorem isRight_iff : x.isRight \u2194 \u2203 y, x = Sum.inr y", "start": [85, 1], "end": [85, 76], "kind": "commanddeclaration"}, {"full_name": "Sum.inl.inj_iff", "code": "theorem inl.inj_iff : (inl a : \u03b1 \u2295 \u03b2) = inl b \u2194 a = b", "start": [89, 1], "end": [89, 79], "kind": "commanddeclaration"}, {"full_name": "Sum.inr.inj_iff", "code": "theorem inr.inj_iff : (inr a : \u03b1 \u2295 \u03b2) = inr b \u2194 a = b", "start": [91, 1], "end": [91, 79], "kind": "commanddeclaration"}, {"full_name": "Sum.inl_ne_inr", "code": "theorem inl_ne_inr : inl a \u2260 inr b", "start": [93, 1], "end": [93, 43], "kind": "commanddeclaration"}, {"full_name": "Sum.inr_ne_inl", "code": "theorem inr_ne_inl : inr b \u2260 inl a", "start": [95, 1], "end": [95, 43], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_comp_inl", "code": "@[simp] theorem elim_comp_inl (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) : Sum.elim f g \u2218 inl = f", "start": [99, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_comp_inr", "code": "@[simp] theorem elim_comp_inr (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) : Sum.elim f g \u2218 inr = g", "start": [102, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_inl_inr", "code": "@[simp] theorem elim_inl_inr : @Sum.elim \u03b1 \u03b2 _ inl inr = id", "start": [105, 1], "end": [106, 60], "kind": "commanddeclaration"}, {"full_name": "Sum.comp_elim", "code": "theorem comp_elim (f : \u03b3 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b3) (h : \u03b2 \u2192 \u03b3) :\n    f \u2218 Sum.elim g h = Sum.elim (f \u2218 g) (f \u2218 h)", "start": [108, 1], "end": [110, 60], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_comp_inl_inr", "code": "@[simp] theorem elim_comp_inl_inr (f : \u03b1 \u2295 \u03b2 \u2192 \u03b3) :\n    Sum.elim (f \u2218 inl) (f \u2218 inr) = f", "start": [112, 1], "end": [114, 60], "kind": "commanddeclaration"}, {"full_name": "Sum.map_map", "code": "@[simp] theorem map_map (f' : \u03b1' \u2192 \u03b1'') (g' : \u03b2' \u2192 \u03b2'') (f : \u03b1 \u2192 \u03b1') (g : \u03b2 \u2192 \u03b2') :\n    \u2200 x : Sum \u03b1 \u03b2, (x.map f g).map f' g' = x.map (f' \u2218 f) (g' \u2218 g)", "start": [118, 1], "end": [121, 17], "kind": "commanddeclaration"}, {"full_name": "Sum.map_comp_map", "code": "@[simp] theorem map_comp_map (f' : \u03b1' \u2192 \u03b1'') (g' : \u03b2' \u2192 \u03b2'') (f : \u03b1 \u2192 \u03b1') (g : \u03b2 \u2192 \u03b2') :\n    Sum.map f' g' \u2218 Sum.map f g = Sum.map (f' \u2218 f) (g' \u2218 g)", "start": [123, 1], "end": [125, 30], "kind": "commanddeclaration"}, {"full_name": "Sum.map_id_id", "code": "@[simp] theorem map_id_id : Sum.map (@id \u03b1) (@id \u03b2) = id", "start": [127, 1], "end": [128, 58], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_map", "code": "theorem elim_map {f\u2081 : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b2 \u2192 \u03b5} {g\u2081 : \u03b3 \u2192 \u03b4} {g\u2082 : \u03b4 \u2192 \u03b5} {x} :\n    Sum.elim f\u2082 g\u2082 (Sum.map f\u2081 g\u2081 x) = Sum.elim (f\u2082 \u2218 f\u2081) (g\u2082 \u2218 g\u2081) x", "start": [130, 1], "end": [132, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_comp_map", "code": "theorem elim_comp_map {f\u2081 : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b2 \u2192 \u03b5} {g\u2081 : \u03b3 \u2192 \u03b4} {g\u2082 : \u03b4 \u2192 \u03b5} :\n    Sum.elim f\u2082 g\u2082 \u2218 Sum.map f\u2081 g\u2081 = Sum.elim (f\u2082 \u2218 f\u2081) (g\u2082 \u2218 g\u2081)", "start": [134, 1], "end": [136, 27], "kind": "commanddeclaration"}, {"full_name": "Sum.isLeft_map", "code": "@[simp] theorem isLeft_map (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b4) (x : \u03b1 \u2295 \u03b3) :\n    isLeft (x.map f g) = isLeft x", "start": [138, 1], "end": [140, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.isRight_map", "code": "@[simp] theorem isRight_map (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b4) (x : \u03b1 \u2295 \u03b3) :\n    isRight (x.map f g) = isRight x", "start": [142, 1], "end": [144, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft?_map", "code": "@[simp] theorem getLeft?_map (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b4) (x : \u03b1 \u2295 \u03b3) :\n    (x.map f g).getLeft? = x.getLeft?.map f", "start": [146, 1], "end": [148, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight?_map", "code": "@[simp] theorem getRight?_map (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b4) (x : \u03b1 \u2295 \u03b3) :\n    (x.map f g).getRight? = x.getRight?.map g", "start": [150, 1], "end": [151, 68], "kind": "commanddeclaration"}, {"full_name": "Sum.swap_swap", "code": "@[simp] theorem swap_swap (x : \u03b1 \u2295 \u03b2) : swap (swap x) = x", "start": [155, 1], "end": [155, 80], "kind": "commanddeclaration"}, {"full_name": "Sum.swap_swap_eq", "code": "@[simp] theorem swap_swap_eq : swap \u2218 swap = @id (\u03b1 \u2295 \u03b2)", "start": [157, 1], "end": [157, 80], "kind": "commanddeclaration"}, {"full_name": "Sum.isLeft_swap", "code": "@[simp] theorem isLeft_swap (x : \u03b1 \u2295 \u03b2) : x.swap.isLeft = x.isRight", "start": [159, 1], "end": [159, 90], "kind": "commanddeclaration"}, {"full_name": "Sum.isRight_swap", "code": "@[simp] theorem isRight_swap (x : \u03b1 \u2295 \u03b2) : x.swap.isRight = x.isLeft", "start": [161, 1], "end": [161, 91], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft?_swap", "code": "@[simp] theorem getLeft?_swap (x : \u03b1 \u2295 \u03b2) : x.swap.getLeft? = x.getRight?", "start": [163, 1], "end": [163, 96], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight?_swap", "code": "@[simp] theorem getRight?_swap (x : \u03b1 \u2295 \u03b2) : x.swap.getRight? = x.getLeft?", "start": [165, 1], "end": [165, 97], "kind": "commanddeclaration"}, {"full_name": "Sum.LiftRel.mono", "code": "theorem LiftRel.mono (hr : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) (hs : \u2200 a b, s\u2081 a b \u2192 s\u2082 a b)\n  (h : LiftRel r\u2081 s\u2081 x y) : LiftRel r\u2082 s\u2082 x y", "start": [169, 1], "end": [173, 35], "kind": "commanddeclaration"}, {"full_name": "Sum.LiftRel.mono_left", "code": "theorem LiftRel.mono_left (hr : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) (h : LiftRel r\u2081 s x y) :\n    LiftRel r\u2082 s x y", "start": [175, 1], "end": [177, 28], "kind": "commanddeclaration"}, {"full_name": "Sum.LiftRel.mono_right", "code": "theorem LiftRel.mono_right (hs : \u2200 a b, s\u2081 a b \u2192 s\u2082 a b) (h : LiftRel r s\u2081 x y) :\n    LiftRel r s\u2082 x y", "start": [179, 1], "end": [181, 28], "kind": "commanddeclaration"}, {"full_name": "Sum.LiftRel.swap", "code": "protected theorem LiftRel.swap (h : LiftRel r s x y) : LiftRel s r x.swap y.swap", "start": [183, 1], "end": [186, 26], "kind": "commanddeclaration"}, {"full_name": "Sum.liftRel_swap_iff", "code": "@[simp] theorem liftRel_swap_iff : LiftRel s r x.swap y.swap \u2194 LiftRel r s x y", "start": [188, 1], "end": [189, 78], "kind": "commanddeclaration"}, {"full_name": "Sum.LiftRel.lex", "code": "protected theorem LiftRel.lex {a b : \u03b1 \u2295 \u03b2} (h : LiftRel r s a b) : Lex r s a b", "start": [195, 1], "end": [198, 22], "kind": "commanddeclaration"}, {"full_name": "Sum.liftRel_subrelation_lex", "code": "theorem liftRel_subrelation_lex : Subrelation (LiftRel r s) (Lex r s)", "start": [200, 1], "end": [200, 85], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.mono", "code": "theorem Lex.mono (hr : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) (hs : \u2200 a b, s\u2081 a b \u2192 s\u2082 a b) (h : Lex r\u2081 s\u2081 x y) :\n    Lex r\u2082 s\u2082 x y", "start": [202, 1], "end": [207, 22], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.mono_left", "code": "theorem Lex.mono_left (hr : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) (h : Lex r\u2081 s x y) : Lex r\u2082 s x y", "start": [209, 1], "end": [210, 28], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.mono_right", "code": "theorem Lex.mono_right (hs : \u2200 a b, s\u2081 a b \u2192 s\u2082 a b) (h : Lex r s\u2081 x y) : Lex r s\u2082 x y", "start": [212, 1], "end": [213, 28], "kind": "commanddeclaration"}, {"full_name": "Sum.lex_acc_inl", "code": "theorem lex_acc_inl (aca : Acc r a) : Acc (Lex r s) (inl a)", "start": [215, 1], "end": [221, 30], "kind": "commanddeclaration"}, {"full_name": "Sum.lex_acc_inr", "code": "theorem lex_acc_inr (aca : \u2200 a, Acc (Lex r s) (inl a)) {b} (acb : Acc s b) :\n    Acc (Lex r s) (inr b)", "start": [223, 1], "end": [231, 25], "kind": "commanddeclaration"}, {"full_name": "Sum.lex_wf", "code": "theorem lex_wf (ha : WellFounded r) (hb : WellFounded s) : WellFounded (Lex r s)", "start": [233, 1], "end": [235, 67], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_const_const", "code": "theorem elim_const_const (c : \u03b3) :\n    Sum.elim (const _ c : \u03b1 \u2192 \u03b3) (const _ c : \u03b2 \u2192 \u03b3) = const _ c", "start": [239, 1], "end": [242, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_lam_const_lam_const", "code": "@[simp] theorem elim_lam_const_lam_const (c : \u03b3) :\n    Sum.elim (fun _ : \u03b1 => c) (fun _ : \u03b2 => c) = fun _ => c", "start": [244, 1], "end": [246, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Elab/Tactic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.liftMetaFinishingTactic", "code": "def liftMetaFinishingTactic (tac : MVarId \u2192 MetaM Unit) : TacticM Unit :=\n  liftMetaTactic fun g => do tac g; pure []", "start": [14, 1], "end": [16, 44], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Lint/Simp.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Tactic/OpenPrivate.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/std/Std/Util/LibraryNote.lean", "lake-packages/std/Std/Tactic/Lint/Basic.lean"], "premises": [{"full_name": "Std.Tactic.Lint.SimpTheoremInfo", "code": "structure SimpTheoremInfo where\n  \n  hyps : Array Expr\n  \n  isConditional : Bool\n  \n  lhs : Expr\n  \n  rhs : Expr", "start": [24, 1], "end": [33, 13], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.isConditionalHyps", "code": "def isConditionalHyps (lhs : Expr) : List Expr \u2192 MetaM Bool\n  | [] => pure false\n  | h :: hs => do\n    let ldecl \u2190 getFVarLocalDecl h\n    if !ldecl.binderInfo.isInstImplicit\n        && !(\u2190 hs.anyM fun h' =>\n          return (\u2190 inferType h').consumeTypeAnnotations.containsFVar h.fvarId!)\n        && !lhs.containsFVar h.fvarId! then\n      return true\n    isConditionalHyps lhs hs", "start": [35, 1], "end": [45, 29], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.withSimpTheoremInfos", "code": "def withSimpTheoremInfos (ty : Expr) (k : SimpTheoremInfo \u2192 MetaM \u03b1) : MetaM (Array \u03b1) :=\n  withReducible do\n    let e \u2190 preprocess (\u2190 mkSorry ty true) ty (inv := false) (isGlobal := true)\n    e.toArray.mapM fun (_, ty') => do\n      forallTelescopeReducing ty' fun hyps eq => do\n        let some (_, lhs, rhs) := eq.eq? | throwError \"not an equality {eq}\"\n        let isConditional \u2190 isConditionalHyps lhs hyps.toList\n        k { hyps, lhs, rhs, isConditional }", "start": [48, 1], "end": [56, 44], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.isSimpEq", "code": "def isSimpEq (a b : Expr) (whnfFirst := true) : MetaM Bool := withReducible do\n  let a \u2190 if whnfFirst then whnf a else pure a\n  let b \u2190 if whnfFirst then whnf b else pure b\n  if a.getAppFn.constName? != b.getAppFn.constName? then return false\n  isDefEq a b", "start": [58, 1], "end": [64, 14], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.checkAllSimpTheoremInfos", "code": "def checkAllSimpTheoremInfos (ty : Expr) (k : SimpTheoremInfo \u2192 MetaM (Option MessageData)) :\n    MetaM (Option MessageData) := do\n  let errors :=\n    (\u2190 withSimpTheoremInfos ty fun i => do (\u2190 k i).mapM addMessageContextFull).filterMap id\n  if errors.isEmpty then\n    return none\n  return MessageData.joinSep errors.toList Format.line", "start": [66, 1], "end": [73, 55], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.isSimpTheorem", "code": "def isSimpTheorem (declName : Name) : MetaM Bool := do\n  pure $ (\u2190 getSimpTheorems).lemmaNames.contains (.decl declName)", "start": [75, 1], "end": [77, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.elements", "code": "partial def _root_.Lean.Meta.DiscrTree.elements (d : DiscrTree \u03b1 s) : Array \u03b1 :=\n  d.root.foldl (init := #[]) fun arr _ => trieElements arr\nwhere\n  \n  trieElements (arr)\n  | Trie.node vs children =>\n    children.foldl (init := arr ++ vs) fun arr (_, child) => trieElements arr child", "start": [80, 1], "end": [87, 84], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.decorateError", "code": "def decorateError (msg : MessageData) (k : MetaM \u03b1) : MetaM \u03b1 := do\n  try k catch e => throw (.error e.getRef m!\"{msg}\\n{e.toMessageData}\")", "start": [91, 1], "end": [93, 72], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.formatLemmas", "code": "def formatLemmas (usedSimps : Simp.UsedSimps) : MetaM MessageData := do\n  let mut args := #[]\n  let env \u2190 getEnv\n  for (thm, _) in usedSimps.toArray.qsort (\u00b7.2 < \u00b7.2) do\n    if let .decl declName := thm then\n      if env.contains declName && declName != ``eq_self then\n        args := args.push (\u2190 mkConstWithFreshMVarLevels declName)\n  return m!\"simp only {args.toList}\"", "start": [95, 1], "end": [103, 37], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.simpNF", "code": "@[std_linter] def simpNF : Linter where\n  noErrorsFound := \"All left-hand sides of simp lemmas are in simp-normal form.\"\n  errorsFound := \"SOME SIMP LEMMAS ARE NOT IN SIMP-NORMAL FORM.\nsee note [simp-normal form] for tips how to debug this.\nhttps://leanprover-community.github.io/mathlib_docs/notes.html#simp-normal%20form\"\n  test := fun declName => do\n    unless \u2190 isSimpTheorem declName do return none\n    let ctx := { \u2190 Simp.Context.mkDefault with config.decide := false }\n    checkAllSimpTheoremInfos (\u2190 getConstInfo declName).type fun {lhs, rhs, isConditional, ..} => do\n      let (\u27e8lhs', prf1, _\u27e9, prf1Lems) \u2190\n        decorateError \"simplify fails on left-hand side:\" <| simp lhs ctx\n      if prf1Lems.contains (.decl declName) then return none\n      let (\u27e8rhs', _, _\u27e9, used_lemmas) \u2190\n        decorateError \"simplify fails on right-hand side:\" <| simp rhs ctx (usedSimps := prf1Lems)\n      let lhs'EqRhs' \u2190 isSimpEq lhs' rhs' (whnfFirst := false)\n      let lhsInNF \u2190 isSimpEq lhs' lhs\n      if lhs'EqRhs' then\n        if prf1.isNone then return none return m!\"simp can prove this:\n  by {\u2190 formatLemmas used_lemmas}\nOne of the lemmas above could be a duplicate.\nIf that's not the case try reordering lemmas or adding @[priority].\n\"\n      else if \u00ac lhsInNF then\n        return m!\"Left-hand side simplifies from\n  {lhs}\nto\n  {lhs'}\nusing\n  {\u2190 formatLemmas prf1Lems}\nTry to change the left-hand side to the simplified term!\n\"\n      else if !isConditional && lhs == lhs' then\n        return m!\"Left-hand side does not simplify, when using the simp lemma on itself.\nThis usually means that it will never apply.\n\"\n      else\n        return none", "start": [105, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.simpVarHead", "code": "@[std_linter] def simpVarHead : Linter where\n  noErrorsFound :=\n    \"No left-hand sides of a simp lemma has a variable as head symbol.\"\n  errorsFound := \"LEFT-HAND SIDE HAS VARIABLE AS HEAD SYMBOL.\nSome simp lemmas have a variable as head symbol of the left-hand side (after whnfR):\"\n  test := fun declName => do\n    unless \u2190 isSimpTheorem declName do return none\n    checkAllSimpTheoremInfos (\u2190 getConstInfo declName).type fun {lhs, ..} => do\n    let lhs \u2190 whnfR lhs\n    let headSym := lhs.getAppFn\n    unless headSym.isFVar do return none\n    return m!\"Left-hand side has variable as head symbol: {headSym}\"", "start": [193, 1], "end": [208, 69], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.Expr.eqOrIff?", "code": "private def Expr.eqOrIff? : Expr \u2192 Option (Expr \u00d7 Expr)\n  | .app (.app (.app (.const ``Eq _) _) lhs) rhs\n  | .app (.app (.const ``Iff _) lhs) rhs\n    => (lhs, rhs)\n  | _ => none", "start": [210, 1], "end": [214, 14], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.simpComm", "code": "@[std_linter] def simpComm : Linter where\n  noErrorsFound := \"No commutativity lemma is marked simp.\"\n  errorsFound := \"COMMUTATIVITY LEMMA IS SIMP.\nSome commutativity lemmas are simp lemmas:\"\n  test := fun declName => withReducible do\n    unless \u2190 isSimpTheorem declName do return none\n    let ty := (\u2190 getConstInfo declName).type\n    forallTelescopeReducing ty fun _ ty' => do\n    let some (lhs, rhs) := ty'.eqOrIff? | return none\n    unless lhs.getAppFn.constName? == rhs.getAppFn.constName? do return none\n    let (_, _, ty') \u2190 forallMetaTelescopeReducing ty\n    let some (lhs', rhs') := ty'.eqOrIff? | return none\n    unless \u2190 isDefEq rhs lhs' do return none\n    unless \u2190 withNewMCtxDepth (isDefEq rhs lhs') do return none\n    if (\u2190 (\u2190 DiscrTree.empty.insert (s := true) rhs ()).getMatch lhs').isEmpty then return none\n    if \u2190 isDefEq lhs' rhs' then return none\n    pure m!\"should not be marked simp\"", "start": [216, 1], "end": [235, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Lint/Frontend.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Paths.lean", "lake-packages/std/Std/Tactic/Lint/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.Lint.LintVerbosity", "code": "inductive LintVerbosity\n  \n  | low\n  \n  | medium\n  \n  | high\n  deriving Inhabited, DecidableEq, Repr", "start": [55, 1], "end": [63, 40], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.getChecks", "code": "def getChecks (slow : Bool) (useOnly : Bool) : CoreM (Array NamedLinter) := do\n  let mut result := #[]\n  unless useOnly do\n    for (name, declName, dflt) in stdLinterExt.getState (\u2190 getEnv) do\n      if dflt then\n        let linter \u2190 getLinter name declName\n        if slow || linter.isFast then\n          let _ := Inhabited.mk linter\n          result := result.binInsert (\u00b7.name.lt \u00b7.name) linter\n  pure result", "start": [65, 1], "end": [79, 14], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.lintCore", "code": "def lintCore (decls : Array Name) (linters : Array NamedLinter) :\n    CoreM (Array (NamedLinter \u00d7 HashMap Name MessageData)) := do\n  let env \u2190 getEnv\n  let options \u2190 getOptions let tasks : Array (NamedLinter \u00d7 Array (Name \u00d7 Task (Option MessageData))) \u2190\n    linters.mapM fun linter => do\n      let decls \u2190 decls.filterM (shouldBeLinted linter.name)\n      (linter, \u00b7) <$> decls.mapM fun decl => (decl, \u00b7) <$> do\n        BaseIO.asTask do\n          match \u2190 withCurrHeartbeats (linter.test decl)\n              |>.run'.run' {options, fileName := \"\", fileMap := default} {env}\n              |>.toBaseIO with\n          | Except.ok msg? => pure msg?\n          | Except.error err => pure m!\"LINTER FAILED:\\n{err.toMessageData}\"\n\n  tasks.mapM fun (linter, decls) => do\n    let mut msgs : HashMap Name MessageData := {}\n    for (declName, msg?) in decls do\n      if let some msg := msg?.get then\n        msgs := msgs.insert declName msg\n    pure (linter, msgs)", "start": [81, 1], "end": [106, 24], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.sortResults", "code": "def sortResults (results : HashMap Name \u03b1) : CoreM <| Array (Name \u00d7 \u03b1) := do\n  let mut key : HashMap Name Nat := {}\n  for (n, _) in results.toArray do\n    if let some range \u2190 findDeclarationRanges? n then\n      key := key.insert n <| range.range.pos.line\n  pure $ results.toArray.qsort fun (a, _) (b, _) => key.findD a 0 < key.findD b 0", "start": [108, 1], "end": [114, 82], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.printWarning", "code": "def printWarning (declName : Name) (warning : MessageData) (useErrorFormat : Bool := false)\n  (filePath : System.FilePath := default) : CoreM MessageData := do\n  if useErrorFormat then\n    if let some range \u2190 findDeclarationRanges? declName then\n      return m!\"{filePath}:{range.range.pos.line}:{range.range.pos.column + 1}: error: {\n          \u2190 mkConstWithLevelParams declName} {warning}\"\n  pure m!\"#check {\u2190 mkConstWithLevelParams declName} \"", "start": [116, 1], "end": [123, 70], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.printWarnings", "code": "def printWarnings (results : HashMap Name MessageData) (filePath : System.FilePath := default)\n    (useErrorFormat : Bool := false) : CoreM MessageData := do\n  (MessageData.joinSep \u00b7.toList Format.line) <$>\n    (\u2190 sortResults results).mapM fun (declName, warning) =>\n      printWarning declName warning (useErrorFormat := useErrorFormat) (filePath := filePath)", "start": [125, 1], "end": [130, 94], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.groupedByFilename", "code": "def groupedByFilename (results : HashMap Name MessageData) (useErrorFormat : Bool := false) :\n    CoreM MessageData := do\n  let sp \u2190 if useErrorFormat then initSrcSearchPath (\u2190 findSysroot) [\".\"] else pure {}\n  let grouped : HashMap Name (System.FilePath \u00d7 HashMap Name MessageData) \u2190\n    results.foldM (init := {}) fun grouped declName msg => do\n      let mod \u2190 findModuleOf? declName\n      let mod := mod.getD (\u2190 getEnv).mainModule\n      grouped.insert mod <$>\n        match grouped.find? mod with\n        | some (fp, msgs) => pure (fp, msgs.insert declName msg)\n        | none => do\n          let fp \u2190 if useErrorFormat then\n            pure <| (\u2190 sp.findWithExt \"lean\" mod).getD (modToFilePath \".\" mod \"lean\")\n          else pure default\n          pure (fp, .insert {} declName msg)\n  let grouped' := grouped.toArray.qsort fun (a, _) (b, _) => toString a < toString b\n  (MessageData.joinSep \u00b7 (Format.line ++ Format.line)) <$>\n    grouped'.toList.mapM fun (mod, fp, msgs) => do\n      pure m!\"", "start": [132, 1], "end": [154, 100], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.formatLinterResults", "code": "def formatLinterResults\n    (results : Array (NamedLinter \u00d7 HashMap Name MessageData))\n    (decls : Array Name)\n    (groupByFilename : Bool)\n    (whereDesc : String) (runSlowLinters : Bool)\n    (verbose : LintVerbosity) (numLinters : Nat) (useErrorFormat : Bool := false) :\n    CoreM MessageData := do\n  let formattedResults \u2190 results.filterMapM fun (linter, results) => do\n    if !results.isEmpty then\n      let warnings \u2190\n        if groupByFilename || useErrorFormat then\n          groupedByFilename results (useErrorFormat := useErrorFormat)\n        else\n          printWarnings results\n      pure $ some m!\"\\n{warnings}\\n\"\n    else if verbose = LintVerbosity.high then\n      pure $ some m!\"\"\n    else\n      pure none\n  let mut s := MessageData.joinSep formattedResults.toList Format.line\n  let numAutoDecls := (\u2190 decls.filterM isAutoDecl).size\n  let failed := results.map (\u00b7.2.size) |>.foldl (\u00b7+\u00b7) 0\n  unless verbose matches LintVerbosity.low do\n    s := m!\"      } in {decls.size - numAutoDecls} declarations (plus {\n      numAutoDecls} automatically generated ones) {whereDesc\n      } with {numLinters} linters\\n\\n{s}\"\n  unless runSlowLinters do s := m!\"{s}  pure s", "start": [156, 1], "end": [187, 9], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.getDeclsInCurrModule", "code": "def getDeclsInCurrModule : CoreM (Array Name) := do\n  pure $ (\u2190 getEnv).constants.map\u2082.foldl (init := #[]) fun r k _ => r.push k", "start": [189, 1], "end": [191, 77], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.getAllDecls", "code": "def getAllDecls : CoreM (Array Name) := do\n  pure $ (\u2190 getEnv).constants.map\u2081.fold (init := \u2190 getDeclsInCurrModule) fun r k _ => r.push k", "start": [193, 1], "end": [195, 95], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.getDeclsInPackage", "code": "def getDeclsInPackage (pkg : Name) : CoreM (Array Name) := do\n  let env \u2190 getEnv\n  let mut decls \u2190 getDeclsInCurrModule\n  let modules := env.header.moduleNames.map (pkg.isPrefixOf \u00b7)\n  return env.constants.map\u2081.fold (init := decls) fun decls declName _ =>\n    if modules[env.const2ModIdx[declName].get! (\u03b1 := Nat)]! then\n      decls.push declName\n    else decls", "start": [197, 1], "end": [205, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Lint/TypeClass.lean", "imports": ["lake-packages/std/Std/Data/Array/Basic.lean", "lake-packages/std/Std/Tactic/Lint/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.Lint.impossibleInstance", "code": "@[std_linter] def impossibleInstance : Linter where\n  noErrorsFound := \"No instance has arguments that are impossible to infer\"\n  errorsFound := \"SOME INSTANCES HAVE ARGUMENTS THAT ARE IMPOSSIBLE TO INFER\nThese are arguments that are not instance-implicit and do not appear in\nanother instance-implicit argument or the return type.\"\n  test declName := do\n    unless \u2190 isInstance declName do return none\n    forallTelescopeReducing (\u2190 inferType (\u2190 mkConstWithLevelParams declName)) fun args ty => do\n    let argTys \u2190 args.mapM inferType\n    let impossibleArgs \u2190 args.zipWithIndex.filterMapM fun (arg, i) => do\n      let fv := arg.fvarId!\n      if (\u2190 fv.getDecl).binderInfo.isInstImplicit then return none\n      if ty.containsFVar fv then return none\n      if argTys[i+1:].any (\u00b7.containsFVar fv) then return none\n      return some m!\"argument {i+1} {arg} : {\u2190 inferType arg}\"\n    if impossibleArgs.isEmpty then return none\n    addMessageContextFull <| .joinSep impossibleArgs.toList \", \"", "start": [12, 1], "end": [34, 65], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.nonClassInstance", "code": "@[std_linter] def nonClassInstance : Linter where\n  noErrorsFound := \"No instances of non-classes\"\n  errorsFound := \"INSTANCES OF NON-CLASSES\"\n  test declName := do\n    if !(\u2190 isInstance declName) then return none\n    let info \u2190 getConstInfo declName\n    if !(\u2190 isClass? info.type).isSome then return \"should not be an instance\"\n    return none", "start": [36, 1], "end": [46, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/String.lean", "imports": ["lake-packages/std/Std/Data/String/Basic.lean", "lake-packages/std/Std/Data/String/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Lean/CoreM.lean", "imports": ["lake-packages/lean4/src/lean/Lean/CoreM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.withHeartbeats", "code": "def Lean.withHeartbeats [Monad m] [MonadLiftT BaseIO m] (x : m \u03b1) : m (\u03b1 \u00d7 Nat) := do\n  let start \u2190 IO.getNumHeartbeats\n  let r \u2190 x\n  let finish \u2190 IO.getNumHeartbeats\n  return (r, finish - start)", "start": [14, 1], "end": [26, 29], "kind": "commanddeclaration"}, {"full_name": "getMaxHeartbeats", "code": "def getMaxHeartbeats : CoreM Nat := do pure <| (\u2190 read).maxHeartbeats", "start": [28, 1], "end": [29, 70], "kind": "commanddeclaration"}, {"full_name": "getInitHeartbeats", "code": "def getInitHeartbeats : CoreM Nat := do pure <| (\u2190 read).initHeartbeats", "start": [31, 1], "end": [32, 72], "kind": "commanddeclaration"}, {"full_name": "getRemainingHeartbeats", "code": "def getRemainingHeartbeats : CoreM Nat := do\n  pure <| (\u2190 getMaxHeartbeats) - ((\u2190 IO.getNumHeartbeats) - (\u2190 getInitHeartbeats))", "start": [34, 1], "end": [36, 83], "kind": "commanddeclaration"}, {"full_name": "heartbeatsPercent", "code": "def heartbeatsPercent : CoreM Nat := do\n  pure <| ((\u2190 IO.getNumHeartbeats) - (\u2190 getInitHeartbeats)) * 100 / (\u2190 getMaxHeartbeats)", "start": [38, 1], "end": [43, 89], "kind": "commanddeclaration"}, {"full_name": "reportOutOfHeartbeats", "code": "def reportOutOfHeartbeats (tac : Name) (stx : Syntax) (threshold : Nat := 90) : CoreM Unit := do\n  if (\u2190 heartbeatsPercent) \u2265 threshold then\n    logInfoAt stx (s!\"`{tac}` stopped because it was running out of time.\\n\" ++\n      \"You may get better results using `set_option maxHeartbeats 0`.\")", "start": [45, 1], "end": [49, 72], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/MLList/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MLList.Spec", "code": "private structure Spec (m : Type u \u2192 Type u) where\n  listM : Type u \u2192 Type u\n  nil : listM \u03b1\n  cons : \u03b1 \u2192 listM \u03b1 \u2192 listM \u03b1\n  thunk : (Unit \u2192 listM \u03b1) \u2192 listM \u03b1\n  squash : (Unit \u2192 m (listM \u03b1)) \u2192 listM \u03b1\n  uncons : [Monad m] \u2192 listM \u03b1 \u2192 m (Option (\u03b1 \u00d7 listM \u03b1))", "start": [20, 1], "end": [26, 58], "kind": "commanddeclaration"}, {"full_name": "MLList.MLListImpl", "code": "private unsafe inductive MLListImpl (m : Type u \u2192 Type u) (\u03b1 : Type u) : Type u\n  | nil : MLListImpl m \u03b1\n  | cons : \u03b1 \u2192 MLListImpl m \u03b1 \u2192 MLListImpl m \u03b1\n  | thunk : Thunk (MLListImpl m \u03b1) \u2192 MLListImpl m \u03b1\n  | squash : (Unit \u2192 m (MLListImpl m \u03b1)) \u2192 MLListImpl m \u03b1", "start": [36, 1], "end": [40, 58], "kind": "commanddeclaration"}, {"full_name": "MLList.unconsImpl", "code": "private unsafe def unconsImpl {m : Type u \u2192 Type u} [Monad m] :\n    MLListImpl m \u03b1 \u2192 m (Option (\u03b1 \u00d7 MLListImpl m \u03b1))\n  | .nil => pure none\n  | .thunk t => unconsImpl t.get\n  | .squash t => t () >>= unconsImpl\n  | .cons x xs => return (x, xs)", "start": [42, 1], "end": [47, 33], "kind": "commanddeclaration"}, {"full_name": "MLList.specImpl", "code": "@[inline] private unsafe def specImpl (m) : Spec m where\n  listM := MLListImpl m\n  nil := .nil\n  cons := .cons\n  thunk f := .thunk (.mk f)\n  squash := .squash\n  uncons := unconsImpl", "start": [49, 1], "end": [55, 23], "kind": "commanddeclaration"}, {"full_name": "MLList.spec", "code": "@[implemented_by specImpl]\nprivate opaque spec (m) : MLList.Spec m", "start": [57, 1], "end": [58, 40], "kind": "commanddeclaration"}, {"full_name": "MLList", "code": "def MLList (m : Type u \u2192 Type u) (\u03b1 : Type u) : Type u := (MLList.spec m).listM \u03b1", "start": [62, 1], "end": [63, 82], "kind": "commanddeclaration"}, {"full_name": "MLList.nil", "code": "@[inline] def nil : MLList m \u03b1 := (MLList.spec m).nil", "start": [67, 1], "end": [68, 54], "kind": "commanddeclaration"}, {"full_name": "MLList.cons", "code": "@[inline] def cons : \u03b1 \u2192 MLList m \u03b1 \u2192 MLList m \u03b1 := (MLList.spec m).cons", "start": [70, 1], "end": [73, 73], "kind": "commanddeclaration"}, {"full_name": "MLList.thunk", "code": "@[inline] def thunk : (Unit \u2192 MLList m \u03b1) \u2192 MLList m \u03b1 := (MLList.spec m).thunk", "start": [75, 1], "end": [76, 80], "kind": "commanddeclaration"}, {"full_name": "MLList.squash", "code": "def squash : (Unit \u2192 m (MLList m \u03b1)) \u2192 MLList m \u03b1 := (MLList.spec m).squash", "start": [78, 1], "end": [79, 76], "kind": "commanddeclaration"}, {"full_name": "MLList.uncons", "code": "@[inline] def uncons [Monad m] : MLList.{u} m \u03b1 \u2192 m (Option (\u03b1 \u00d7 MLList m \u03b1)) :=\n  (MLList.spec m).uncons", "start": [81, 1], "end": [84, 25], "kind": "commanddeclaration"}, {"full_name": "MLList.forIn", "code": "@[specialize] protected partial def forIn [Monad m] [Monad n] [MonadLiftT m n]\n    (as : MLList m \u03b1) (init : \u03b4) (f : \u03b1 \u2192 \u03b4 \u2192 n (ForInStep \u03b4)) : n \u03b4 := do\n  match \u2190 (as.uncons :) with\n  | none => pure init\n  | some (a, t) => match (\u2190 f a init) with\n      | ForInStep.done d  => pure d\n      | ForInStep.yield d => t.forIn d f", "start": [91, 1], "end": [98, 41], "kind": "commanddeclaration"}, {"full_name": "MLList.fix", "code": "partial def fix [Monad m] (f : \u03b1 \u2192 m \u03b1) (x : \u03b1) : MLList m \u03b1 :=\n  cons x <| squash fun _ => fix f <$> f x", "start": [103, 1], "end": [105, 42], "kind": "commanddeclaration"}, {"full_name": "MLList.fix?", "code": "partial def fix? [Monad m] (f : \u03b1 \u2192 m (Option \u03b1)) (x : \u03b1) : MLList m \u03b1 :=\n  cons x <| squash fun _ => do\n    match \u2190 f x with\n    | none => return nil\n    | some x' => return fix? f x'", "start": [107, 1], "end": [112, 34], "kind": "commanddeclaration"}, {"full_name": "MLList.iterate", "code": "partial def iterate [Monad m] (f : m \u03b1) : MLList m \u03b1 :=\n  squash fun _ => return cons (\u2190 f) (iterate f)", "start": [114, 1], "end": [116, 48], "kind": "commanddeclaration"}, {"full_name": "MLList.fixlWith", "code": "partial def fixlWith [Monad m] {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 m (\u03b1 \u00d7 List \u03b2))\n    (s : \u03b1) (l : List \u03b2) : MLList m \u03b2 :=\n  thunk fun _ =>\n    match l with\n    | b :: rest => cons b (fixlWith f s rest)\n    | [] => squash fun _ => do\n      let (s', l) \u2190 f s\n      match l with\n      | b :: rest => pure <| cons b (fixlWith f s' rest)\n      | [] => pure <| fixlWith f s' []", "start": [118, 1], "end": [131, 39], "kind": "commanddeclaration"}, {"full_name": "MLList.fixl", "code": "def fixl [Monad m] {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 m (\u03b1 \u00d7 List \u03b2)) (s : \u03b1) : MLList m \u03b2 :=\n  fixlWith f s []", "start": [133, 1], "end": [136, 18], "kind": "commanddeclaration"}, {"full_name": "MLList.isEmpty", "code": "def isEmpty [Monad m] (xs : MLList m \u03b1) : m (ULift Bool) :=\n  (ULift.up \u2218 Option.isSome) <$> uncons xs", "start": [138, 1], "end": [140, 43], "kind": "commanddeclaration"}, {"full_name": "MLList.ofList", "code": "def ofList : List \u03b1 \u2192 MLList m \u03b1\n  | [] => nil\n  | h :: t => cons h (thunk fun _ => ofList t)", "start": [142, 1], "end": [145, 47], "kind": "commanddeclaration"}, {"full_name": "MLList.ofListM", "code": "def ofListM [Monad m] : List (m \u03b1) \u2192 MLList m \u03b1\n  | [] => nil\n  | h :: t => squash fun _ => return cons (\u2190 h) (ofListM t)", "start": [147, 1], "end": [150, 60], "kind": "commanddeclaration"}, {"full_name": "MLList.force", "code": "partial def force [Monad m] (L : MLList m \u03b1) : m (List \u03b1) := do\n  match \u2190 L.uncons with\n  | none => pure []\n  | some (x, xs) => return x :: (\u2190 xs.force)", "start": [152, 1], "end": [156, 45], "kind": "commanddeclaration"}, {"full_name": "MLList.asArray", "code": "def asArray [Monad m] (L : MLList m \u03b1) : m (Array \u03b1) := do\n  let mut r := #[]\n  for a in L do\n    r := r.push a\n  return r", "start": [158, 1], "end": [163, 11], "kind": "commanddeclaration"}, {"full_name": "MLList.casesM", "code": "@[specialize]\ndef casesM [Monad m] (xs : MLList m \u03b1)\n    (hnil : Unit \u2192 m (MLList m \u03b2)) (hcons : \u03b1 \u2192 MLList m \u03b1 \u2192 m (MLList m \u03b2)) : MLList m \u03b2 :=\n  squash fun _ => do\n    match \u2190 xs.uncons with\n    | none => hnil ()\n    | some (x, xs) => hcons x xs", "start": [165, 1], "end": [172, 33], "kind": "commanddeclaration"}, {"full_name": "MLList.cases", "code": "@[specialize]\ndef cases [Monad m] (xs : MLList m \u03b1)\n    (hnil : Unit \u2192 MLList m \u03b2) (hcons : \u03b1 \u2192 MLList m \u03b1 \u2192 MLList m \u03b2) : MLList m \u03b2 :=\n  xs.casesM (fun _ => return hnil ()) (fun x xs => return hcons x xs)", "start": [174, 1], "end": [181, 70], "kind": "commanddeclaration"}, {"full_name": "MLList.foldsM", "code": "partial def foldsM [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (init : \u03b2) (L : MLList m \u03b1) : MLList m \u03b2 :=\n  cons init <| squash fun _ => do\n    match \u2190 L.uncons with\n    | none => return nil\n    | some (x, xs) => return foldsM f (\u2190 f init x) xs", "start": [183, 1], "end": [189, 54], "kind": "commanddeclaration"}, {"full_name": "MLList.folds", "code": "def folds [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (init : \u03b2) (L : MLList m \u03b1) : MLList m \u03b2 :=\n  L.foldsM (fun b a => pure (f b a)) init", "start": [191, 1], "end": [194, 42], "kind": "commanddeclaration"}, {"full_name": "MLList.takeAsList", "code": "partial def takeAsList [Monad m] (xs : MLList m \u03b1) (n : Nat) : m (List \u03b1) :=\n  go n [] xs\nwhere\n  \n  go (r : Nat) (acc : List \u03b1) (xs : MLList m \u03b1) : m (List \u03b1) :=\n    match r with\n    | 0 => pure acc.reverse\n    | r+1 => do match \u2190 xs.uncons with\n      | none => pure acc.reverse\n      | some (x, xs) => go r (x :: acc) xs", "start": [196, 1], "end": [206, 43], "kind": "commanddeclaration"}, {"full_name": "MLList.takeAsArray", "code": "partial def takeAsArray [Monad m] (xs : MLList m \u03b1) (n : Nat) : m (Array \u03b1) :=\n  go n #[] xs\nwhere\n  \n  go (r : Nat) (acc : Array \u03b1) (xs : MLList m \u03b1) : m (Array \u03b1) :=\n    match r with\n    | 0 => pure acc\n    | r+1 => do match \u2190 xs.uncons with\n      | none => pure acc\n      | some (x, xs) => go r (acc.push x) xs", "start": [208, 1], "end": [218, 45], "kind": "commanddeclaration"}, {"full_name": "MLList.take", "code": "partial def take [Monad m] (xs : MLList m \u03b1) : Nat \u2192 MLList m \u03b1\n  | 0 => nil\n  | n+1 => xs.cases (fun _ => nil) fun h l => cons h (l.take n)", "start": [220, 1], "end": [223, 64], "kind": "commanddeclaration"}, {"full_name": "MLList.drop", "code": "def drop [Monad m] (xs : MLList m \u03b1) : Nat \u2192 MLList m \u03b1\n  | 0 => xs\n  | n+1 => xs.cases (fun _ => nil) fun _ l => l.drop n", "start": [225, 1], "end": [228, 55], "kind": "commanddeclaration"}, {"full_name": "MLList.mapM", "code": "partial def mapM [Monad m] (f : \u03b1 \u2192 m \u03b2) (xs : MLList m \u03b1) : MLList m \u03b2 :=\n  xs.cases (fun _ => nil) fun x xs => squash fun _ => return cons (\u2190 f x) (xs.mapM f)", "start": [230, 1], "end": [232, 86], "kind": "commanddeclaration"}, {"full_name": "MLList.map", "code": "def map [Monad m] (f : \u03b1 \u2192 \u03b2) (L : MLList m \u03b1) : MLList m \u03b2 :=\n  L.mapM fun a => pure (f a)", "start": [234, 1], "end": [236, 29], "kind": "commanddeclaration"}, {"full_name": "MLList.filterM", "code": "partial def filterM [Monad m] (p : \u03b1 \u2192 m (ULift Bool)) (L : MLList m \u03b1) : MLList m \u03b1 :=\n  L.casesM (fun _ => pure nil) fun x xs =>\n    return if (\u2190 p x).down then cons x (filterM p xs) else filterM p xs", "start": [238, 1], "end": [241, 72], "kind": "commanddeclaration"}, {"full_name": "MLList.filter", "code": "def filter [Monad m] (p : \u03b1 \u2192 Bool) (L : MLList m \u03b1) : MLList m \u03b1 :=\n  L.filterM fun a => pure <| .up (p a)", "start": [243, 1], "end": [245, 39], "kind": "commanddeclaration"}, {"full_name": "MLList.filterMapM", "code": "partial def filterMapM [Monad m] (f : \u03b1 \u2192 m (Option \u03b2)) (xs : MLList m \u03b1) : MLList m \u03b2 :=\n  xs.casesM (fun _ => pure nil) fun x xs => do\n    match \u2190 f x with\n    | none => return xs.filterMapM f\n    | some a => return cons a (xs.filterMapM f)", "start": [247, 1], "end": [254, 48], "kind": "commanddeclaration"}, {"full_name": "MLList.filterMap", "code": "def filterMap [Monad m] (f : \u03b1 \u2192 Option \u03b2) : MLList m \u03b1 \u2192 MLList m \u03b2 :=\n  filterMapM fun a => do pure (f a)", "start": [256, 1], "end": [258, 36], "kind": "commanddeclaration"}, {"full_name": "MLList.takeWhileM", "code": "partial def takeWhileM [Monad m] (f : \u03b1 \u2192 m (ULift Bool)) (L : MLList m \u03b1) : MLList m \u03b1 :=\n  L.casesM (fun _ => pure nil) fun x xs =>\n    return if !(\u2190 f x).down then nil else cons x (xs.takeWhileM f)", "start": [260, 1], "end": [263, 67], "kind": "commanddeclaration"}, {"full_name": "MLList.takeWhile", "code": "def takeWhile [Monad m] (f : \u03b1 \u2192 Bool) : MLList m \u03b1 \u2192 MLList m \u03b1 :=\n  takeWhileM fun a => pure (.up (f a))", "start": [265, 1], "end": [267, 39], "kind": "commanddeclaration"}, {"full_name": "MLList.append", "code": "partial def append [Monad m] (xs : MLList m \u03b1) (ys : Unit \u2192 MLList m \u03b1) : MLList m \u03b1 :=\n  xs.cases ys fun x xs => cons x (append xs ys)", "start": [269, 1], "end": [271, 48], "kind": "commanddeclaration"}, {"full_name": "MLList.join", "code": "partial def join [Monad m] (xs : MLList m (MLList m \u03b1)) : MLList m \u03b1 :=\n  xs.cases (fun _ => nil) fun x xs => append x (fun _ => join xs)", "start": [273, 1], "end": [275, 66], "kind": "commanddeclaration"}, {"full_name": "MLList.enumFrom", "code": "partial def enumFrom [Monad m] (n : Nat) (xs : MLList m \u03b1) : MLList m (Nat \u00d7 \u03b1) :=\n  xs.cases (fun _ => nil) fun x xs => cons (n, x) (xs.enumFrom (n+1))", "start": [277, 1], "end": [279, 70], "kind": "commanddeclaration"}, {"full_name": "MLList.enum", "code": "def enum [Monad m] : MLList m \u03b1 \u2192 MLList m (Nat \u00d7 \u03b1) := enumFrom 0", "start": [281, 1], "end": [282, 67], "kind": "commanddeclaration"}, {"full_name": "MLList.range", "code": "def range [Monad m] : MLList m Nat := MLList.fix (fun n => pure (n + 1)) 0", "start": [284, 1], "end": [285, 75], "kind": "commanddeclaration"}, {"full_name": "MLList.fin", "code": "partial def fin (n : Nat) : MLList m (Fin n) := go 0 where\n  \n  go (i : Nat) : MLList m (Fin n) :=\n    if h : i < n then cons \u27e8i, h\u27e9 (thunk fun _ => go (i+1)) else nil", "start": [287, 1], "end": [291, 69], "kind": "commanddeclaration"}, {"full_name": "MLList.ofArray", "code": "partial def ofArray {\u03b1 : Type} (L : Array \u03b1) : MLList m \u03b1 := go 0 where\n  \n  go (i : Nat) : MLList m \u03b1 :=\n    if h : i < L.size then cons (L.get \u27e8i, h\u27e9) (thunk fun _ => go (i+1)) else nil", "start": [293, 1], "end": [297, 82], "kind": "commanddeclaration"}, {"full_name": "MLList.chunk", "code": "partial def chunk [Monad m] (L : MLList m \u03b1) (n : Nat) : MLList m (Array \u03b1) := go n #[] L where\n  \n  go (r : Nat) (acc : Array \u03b1) (M : MLList m \u03b1) : MLList m (Array \u03b1) :=\n    match r with\n    | 0 => cons acc (thunk fun _ => go n #[] M)\n    | r+1 => squash fun _ => do\n      match \u2190 M.uncons with\n      | none => return cons acc nil\n      | some (a, M') => return go r (acc.push a) M'", "start": [299, 1], "end": [309, 52], "kind": "commanddeclaration"}, {"full_name": "MLList.concat", "code": "def concat [Monad m] (L : MLList m \u03b1) (a : \u03b1) : MLList m \u03b1 := L.append (fun _ => cons a nil)", "start": [311, 1], "end": [312, 93], "kind": "commanddeclaration"}, {"full_name": "MLList.zip", "code": "partial def zip [Monad m] (L : MLList m \u03b1) (M : MLList m \u03b2) : MLList.{u} m (\u03b1 \u00d7 \u03b2) :=\n  L.cases (fun _ => nil) fun a L =>\n  M.cases (fun _ => nil) fun b M =>\n  cons (a, b) (L.zip M)", "start": [314, 1], "end": [318, 24], "kind": "commanddeclaration"}, {"full_name": "MLList.bind", "code": "partial def bind [Monad m] (xs : MLList m \u03b1) (f : \u03b1 \u2192 MLList m \u03b2) : MLList m \u03b2 :=\n  xs.cases (fun _ => nil) fun x xs => append (f x) (fun _ => bind xs f)", "start": [320, 1], "end": [323, 72], "kind": "commanddeclaration"}, {"full_name": "MLList.monadLift", "code": "def monadLift [Monad m] (x : m \u03b1) : MLList m \u03b1 :=\n  squash fun _ => return cons (\u2190 x) nil", "start": [325, 1], "end": [327, 40], "kind": "commanddeclaration"}, {"full_name": "MLList.liftM", "code": "partial def liftM [Monad m] [Monad n] [MonadLiftT m n] (L : MLList m \u03b1) : MLList n \u03b1 :=\n  squash fun _ =>\n    return match \u2190 (uncons L : m _) with\n    | none => nil\n    | some (a, L') => cons a L'.liftM", "start": [329, 1], "end": [334, 38], "kind": "commanddeclaration"}, {"full_name": "MLList.runState", "code": "partial def runState [Monad m] (L : MLList (StateT.{u} \u03c3 m) \u03b1) (s : \u03c3) : MLList m (\u03b1 \u00d7 \u03c3) :=\n  squash fun _ =>\n    return match \u2190 (uncons L).run s with\n    | (none, _) => nil\n    | (some (a, L'), s') => cons (a, s') (L'.runState s')", "start": [336, 1], "end": [341, 58], "kind": "commanddeclaration"}, {"full_name": "MLList.runState'", "code": "def runState' [Monad m] (L : MLList (StateT.{u} \u03c3 m) \u03b1) (s : \u03c3) : MLList m \u03b1 :=\n  L.runState s |>.map (\u00b7.1)", "start": [343, 1], "end": [345, 28], "kind": "commanddeclaration"}, {"full_name": "MLList.runReader", "code": "partial def runReader [Monad m] (L : MLList (ReaderT.{u, u} \u03c1 m) \u03b1) (r : \u03c1) :\n    MLList m \u03b1 :=\n  squash fun _ =>\n    return match \u2190 (uncons L).run r with\n    | none => nil\n    | some (a, L') => cons a (L'.runReader r)", "start": [347, 1], "end": [353, 46], "kind": "commanddeclaration"}, {"full_name": "MLList.runStateRef", "code": "partial def runStateRef [Monad m] [MonadLiftT (ST \u03c9) m] (L : MLList (StateRefT' \u03c9 \u03c3 m) \u03b1) (s : \u03c3) :\n    MLList m \u03b1 :=\n  squash fun _ =>\n    return match \u2190 (uncons L).run s with\n    | (none, _) => nil\n    | (some (a, L'), s') => cons a (L'.runStateRef s')", "start": [355, 1], "end": [361, 55], "kind": "commanddeclaration"}, {"full_name": "MLList.head?", "code": "def head? [Monad m] (L : MLList m \u03b1) : m (Option \u03b1) := return (\u2190 L.uncons).map (\u00b7.1)", "start": [363, 1], "end": [364, 85], "kind": "commanddeclaration"}, {"full_name": "MLList.takeUpToFirstM", "code": "partial def takeUpToFirstM [Monad m] (L : MLList m \u03b1) (f : \u03b1 \u2192 m (ULift Bool)) : MLList m \u03b1 :=\n  L.casesM (fun _ => pure nil) fun x xs =>\n    return cons x <| if (\u2190 (f x)).down then nil else xs.takeUpToFirstM f", "start": [366, 1], "end": [370, 73], "kind": "commanddeclaration"}, {"full_name": "MLList.takeUpToFirst", "code": "def takeUpToFirst [Monad m] (L : MLList m \u03b1) (f : \u03b1 \u2192 Bool) : MLList m \u03b1 :=\n  L.takeUpToFirstM fun a => pure (.up (f a))", "start": [372, 1], "end": [375, 45], "kind": "commanddeclaration"}, {"full_name": "MLList.getLast?", "code": "partial def getLast? [Monad m] (L : MLList m \u03b1) : m (Option \u03b1) := do\n  match \u2190 uncons L with\n  | none => return none\n  | some (x, xs) => aux x xs\nwhere\n  \n  aux (x : \u03b1) (L : MLList m \u03b1) : m (Option \u03b1) := do\n    match \u2190 uncons L with\n    | none => return some x\n    | some (y, ys) => aux y ys", "start": [377, 1], "end": [388, 31], "kind": "commanddeclaration"}, {"full_name": "MLList.getLast!", "code": "partial def getLast! [Monad m] [Inhabited \u03b1] (L : MLList m \u03b1) : m \u03b1 := Option.get! <$> L.getLast?", "start": [390, 1], "end": [392, 98], "kind": "commanddeclaration"}, {"full_name": "MLList.foldM", "code": "partial def foldM [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (init : \u03b2) (L : MLList m \u03b1) : m \u03b2 :=\n  return (\u2190 L.foldsM f init |>.getLast?).getD init", "start": [394, 1], "end": [397, 51], "kind": "commanddeclaration"}, {"full_name": "MLList.fold", "code": "partial def fold [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (init : \u03b2) (L : MLList m \u03b1) : m \u03b2 :=\n  L.foldM (fun b a => pure (f b a)) init", "start": [399, 1], "end": [402, 41], "kind": "commanddeclaration"}, {"full_name": "MLList.head", "code": "def head [Monad m] [Alternative m] (L : MLList m \u03b1) : m \u03b1 := do\n  let some (r, _) \u2190 L.uncons | failure\n  return r", "start": [404, 1], "end": [410, 11], "kind": "commanddeclaration"}, {"full_name": "MLList.firstM", "code": "def firstM [Monad m] [Alternative m] (L : MLList m \u03b1) (f : \u03b1 \u2192 m (Option \u03b2)) : m \u03b2 :=\n  (L.filterMapM f).head", "start": [412, 1], "end": [417, 24], "kind": "commanddeclaration"}, {"full_name": "MLList.first", "code": "def first [Monad m] [Alternative m] (L : MLList m \u03b1) (p : \u03b1 \u2192 Bool) : m \u03b1 := (L.filter p).head", "start": [419, 1], "end": [420, 95], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/BitVec/Basic.lean", "imports": ["lake-packages/std/Std/Tactic/Alias.lean", "lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "lake-packages/std/Std/Data/Int/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/Fin/Basic.lean"], "premises": [{"full_name": "Std.BitVec", "code": "structure BitVec (w : Nat) where\n  \n  ofFin ::\n  \n  toFin : Fin (2^w)\n  deriving DecidableEq", "start": [25, 1], "end": [36, 23], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.cast", "code": "@[inline] def cast (eq : n = m) (i : BitVec n) : BitVec m :=\n  .ofFin (Fin.cast (congrArg _ eq) i.toFin)", "start": [40, 1], "end": [42, 44], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.ofNat", "code": "protected def ofNat (n : Nat) (i : Nat) : BitVec n where\n  toFin := Fin.ofNat' i (Nat.pow_two_pos _)", "start": [44, 1], "end": [47, 44], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.toNat", "code": "protected def toNat (a : BitVec n) : Nat := a.toFin.val", "start": [49, 1], "end": [51, 56], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.getLsb", "code": "@[inline] def getLsb (x : BitVec w) (i : Nat) : Bool := x.toNat &&& (1 <<< i) != 0", "start": [53, 1], "end": [54, 83], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.getMsb", "code": "@[inline] def getMsb (x : BitVec w) (i : Nat) : Bool := i < w && getLsb x (w-1-i)", "start": [56, 1], "end": [57, 82], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.msb", "code": "@[inline] protected def msb (a : BitVec n) : Bool := getMsb a 0", "start": [59, 1], "end": [60, 64], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.ofInt", "code": "protected def ofInt (n : Nat) (i : Int) : BitVec n :=\n  match i with\n  | Int.ofNat a => .ofNat n a\n  | Int.negSucc a => .ofNat n (2^n - 1 - a % 2^n)", "start": [62, 1], "end": [66, 50], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.toInt", "code": "protected def toInt (a : BitVec n) : Int :=\n  if a.msb then Int.ofNat a.toNat - Int.ofNat (2^n) else a.toNat", "start": [68, 1], "end": [70, 65], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.zero", "code": "protected def zero (n : Nat) : BitVec n := .ofNat n 0", "start": [72, 1], "end": [73, 54], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.unexpandBitVecOfNat", "code": "@[app_unexpander BitVec.ofNat] def unexpandBitVecOfNat : Lean.PrettyPrinter.Unexpander\n  | `($(_) $n $i) => `($i#$n)\n  | _ => throw ()", "start": [83, 1], "end": [86, 18], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.toHex", "code": "protected def toHex {n:Nat} (x:BitVec n) : String :=\n  let s := (Nat.toDigits 16 x.toNat).asString\n  let t := (List.replicate ((n+3) / 4 - s.length) '0').asString\n  t ++ s", "start": [88, 1], "end": [92, 9], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.ofNat_eq_ofNat", "code": "@[simp] theorem ofNat_eq_ofNat : @OfNat.ofNat (BitVec n) i _ = BitVec.ofNat n i", "start": [98, 1], "end": [100, 87], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.add", "code": "protected def add (x y : BitVec n) : BitVec n where toFin := x.toFin + y.toFin", "start": [102, 1], "end": [108, 79], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.sub", "code": "protected def sub (x y : BitVec n) : BitVec n where toFin := x.toFin - y.toFin", "start": [111, 1], "end": [115, 79], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.neg", "code": "protected def neg (x : BitVec n) : BitVec n := .sub 0 x", "start": [118, 1], "end": [124, 56], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.allOnes", "code": "def allOnes (n : Nat) : BitVec n := -1", "start": [127, 1], "end": [128, 39], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.abs", "code": "protected def abs (s : BitVec n) : BitVec n := if s.msb then .neg s else s", "start": [130, 1], "end": [133, 75], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.mul", "code": "protected def mul (x y : BitVec n) : BitVec n := ofFin <| x.toFin * y.toFin", "start": [135, 1], "end": [141, 76], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.udiv", "code": "def udiv (x y : BitVec n) : BitVec n := ofFin <| x.toFin / y.toFin", "start": [144, 1], "end": [147, 67], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.umod", "code": "def umod (x y : BitVec n) : BitVec n := ofFin <| x.toFin % y.toFin", "start": [150, 1], "end": [155, 67], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.smtUDiv", "code": "def smtUDiv (x y : BitVec n) : BitVec n := if y = 0 then -1 else .udiv x y", "start": [158, 1], "end": [165, 75], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.sdiv", "code": "def sdiv (s t : BitVec n) : BitVec n :=\n  match s.msb, t.msb with\n  | false, false => udiv s t\n  | false, true  => .neg (udiv s (.neg t))\n  | true,  false => .neg (udiv (.neg s) t)\n  | true,  true  => udiv (.neg s) (.neg t)", "start": [167, 1], "end": [183, 43], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.smtSDiv", "code": "def smtSDiv (s t : BitVec n) : BitVec n :=\n  match s.msb, t.msb with\n  | false, false => smtUDiv s t\n  | false, true  => .neg (smtUDiv s (.neg t))\n  | true,  false => .neg (smtUDiv (.neg s) t)\n  | true,  true  => smtUDiv (.neg s) (.neg t)", "start": [185, 1], "end": [197, 46], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.srem", "code": "def srem (s t : BitVec n) : BitVec n :=\n  match s.msb, t.msb with\n  | false, false => umod s t\n  | false, true  => umod s (.neg t)\n  | true,  false => .neg (umod (.neg s) t)\n  | true,  true  => .neg (umod (.neg s) (.neg t))", "start": [199, 1], "end": [209, 50], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.smod", "code": "def smod (s t : BitVec m) : BitVec m :=\n  match s.msb, t.msb with\n  | false, false => .umod s t\n  | false, true =>\n    let u := .umod s (.neg t)\n    (if u = BitVec.ofNat m 0 then u else .add u t)\n  | true, false =>\n    let u := .umod (.neg s) t\n    (if u = BitVec.ofNat m 0 then u else .sub t u)\n  | true, true => .neg (.umod (.neg s) (.neg t))", "start": [211, 1], "end": [225, 49], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.ult", "code": "protected def ult (x y : BitVec n) : Bool := x.toFin < y.toFin", "start": [227, 1], "end": [232, 63], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.ule", "code": "protected def ule (x y : BitVec n) : Bool := x.toFin \u2264 y.toFin", "start": [235, 1], "end": [240, 63], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.slt", "code": "protected def slt (x y : BitVec n) : Bool := x.toInt < y.toInt", "start": [244, 1], "end": [253, 63], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.sle", "code": "protected def sle (x y : BitVec n) : Bool := x.toInt \u2264 y.toInt", "start": [255, 1], "end": [260, 63], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.and", "code": "protected def and (x y : BitVec n) : BitVec n where toFin := x.toFin &&& y.toFin", "start": [262, 1], "end": [271, 81], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.or", "code": "protected def or (x y : BitVec n) : BitVec n where toFin := x.toFin ||| y.toFin", "start": [274, 1], "end": [283, 80], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.xor", "code": "protected def xor (x y : BitVec n) : BitVec n where toFin := x.toFin ^^^ y.toFin", "start": [286, 1], "end": [295, 81], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.not", "code": "protected def not (x : BitVec n) : BitVec n := -(x + .ofNat n 1)", "start": [298, 1], "end": [306, 65], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.shiftLeft", "code": "protected def shiftLeft (a : BitVec n) (s : Nat) : BitVec n := .ofNat n (a.toNat <<< s)", "start": [309, 1], "end": [315, 88], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.ushiftRight", "code": "def ushiftRight (a : BitVec n) (s : Nat) : BitVec n := .ofNat n (a.toNat >>> s)", "start": [318, 1], "end": [324, 80], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.sshiftRight", "code": "def sshiftRight (a : BitVec n) (s : Nat) : BitVec n := .ofInt n (a.toInt >>> s)", "start": [327, 1], "end": [334, 80], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.rotateLeft", "code": "def rotateLeft (x : BitVec w) (n : Nat) : BitVec w := x <<< n ||| x >>> (w - n)", "start": [339, 1], "end": [348, 80], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.rotateRight", "code": "def rotateRight (x : BitVec w) (n : Nat) : BitVec w := x >>> n ||| x <<< (w - n)", "start": [350, 1], "end": [359, 81], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.append", "code": "def append (msbs : BitVec n) (lsbs : BitVec m) : BitVec (n+m) :=\n  .ofNat (n + m) (msbs.toNat <<< m ||| lsbs.toNat)", "start": [361, 1], "end": [368, 51], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.extractLsb'", "code": "def extractLsb' (start len : Nat) (a : BitVec n) : BitVec len := .ofNat _ (a.toNat >>> start)", "start": [372, 1], "end": [377, 94], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.extractLsb", "code": "def extractLsb (hi lo : Nat) (a : BitVec n) : BitVec (hi - lo + 1) := extractLsb' lo _ a", "start": [379, 1], "end": [385, 89], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.replicate", "code": "def replicate : (i : Nat) \u2192 BitVec w \u2192 BitVec (w*i)\n  | 0,   _ => 0\n  | n+1, x =>\n    have hEq : w + w*n = w*(n + 1) := by\n      rw [Nat.mul_add, Nat.add_comm, Nat.mul_one]\n    hEq \u25b8 (x ++ replicate n x)", "start": [388, 1], "end": [394, 31], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.fill", "code": "def fill (w : Nat) (b : Bool) : BitVec w := bif b then -1 else 0", "start": [396, 1], "end": [397, 65], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.zeroExtend", "code": "def zeroExtend (v : Nat) (x : BitVec w) : BitVec v := .ofNat v x.toNat", "start": [399, 1], "end": [405, 71], "kind": "commanddeclaration"}, {"full_name": "Std.BitVec.truncate", "code": "alias truncate := zeroExtend", "start": [407, 1], "end": [411, 29], "kind": "stdtacticaliasalias"}, {"full_name": "Std.BitVec.signExtend", "code": "def signExtend (i : Nat) (x : BitVec w) : BitVec (w+i) :=\n  Nat.add_comm .. \u25b8 (fill i x.msb ++ x)", "start": [413, 1], "end": [420, 40], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Fin/Lemmas.lean", "imports": ["lake-packages/std/Std/Tactic/Simpa.lean", "lake-packages/std/Std/Tactic/Ext.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/Fin/Basic.lean", "lake-packages/std/Std/Tactic/NormCast/Lemmas.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean"], "premises": [{"full_name": "Fin.size_pos", "code": "theorem size_pos (i : Fin n) : 0 < n", "start": [14, 1], "end": [15, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.mod_def", "code": "theorem mod_def (a m : Fin n) : a % m = Fin.mk ((a % m) % n) (Nat.mod_lt _ a.size_pos)", "start": [17, 1], "end": [17, 94], "kind": "commanddeclaration"}, {"full_name": "Fin.mul_def", "code": "theorem mul_def (a b : Fin n) : a * b = Fin.mk ((a * b) % n) (Nat.mod_lt _ a.size_pos)", "start": [19, 1], "end": [19, 94], "kind": "commanddeclaration"}, {"full_name": "Fin.sub_def", "code": "theorem sub_def (a b : Fin n) : a - b = Fin.mk ((a + (n - b)) % n) (Nat.mod_lt _ a.size_pos)", "start": [21, 1], "end": [21, 100], "kind": "commanddeclaration"}, {"full_name": "Fin.size_pos'", "code": "theorem size_pos' : \u2200 [Nonempty (Fin n)], 0 < n", "start": [23, 1], "end": [23, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.is_lt", "code": "@[simp] theorem is_lt (a : Fin n) : (a : Nat) < n", "start": [25, 1], "end": [25, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.pos_iff_nonempty", "code": "theorem pos_iff_nonempty {n : Nat} : 0 < n \u2194 Nonempty (Fin n)", "start": [27, 1], "end": [28, 40], "kind": "commanddeclaration"}, {"full_name": "Fin.eta", "code": "@[simp] protected theorem eta (a : Fin n) (h : a < n) : (\u27e8a, h\u27e9 : Fin n) = a", "start": [32, 1], "end": [32, 84], "kind": "commanddeclaration"}, {"full_name": "Fin.ext", "code": "@[ext] theorem ext {a b : Fin n} (h : (a : Nat) = b) : a = b", "start": [34, 1], "end": [34, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.val_inj", "code": "theorem val_inj {a b : Fin n} : a.1 = b.1 \u2194 a = b", "start": [36, 1], "end": [36, 90], "kind": "commanddeclaration"}, {"full_name": "Fin.ext_iff", "code": "theorem ext_iff {a b : Fin n} : a = b \u2194 a.1 = b.1", "start": [38, 1], "end": [38, 66], "kind": "commanddeclaration"}, {"full_name": "Fin.val_ne_iff", "code": "theorem val_ne_iff {a b : Fin n} : a.1 \u2260 b.1 \u2194 a \u2260 b", "start": [40, 1], "end": [40, 74], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_iff", "code": "theorem exists_iff {p : Fin n \u2192 Prop} : (\u2203 i, p i) \u2194 \u2203 i h, p \u27e8i, h\u27e9", "start": [42, 1], "end": [43, 75], "kind": "commanddeclaration"}, {"full_name": "Fin.forall_iff", "code": "theorem forall_iff {p : Fin n \u2192 Prop} : (\u2200 i, p i) \u2194 \u2200 i h, p \u27e8i, h\u27e9", "start": [45, 1], "end": [46, 53], "kind": "commanddeclaration"}, {"full_name": "Fin.mk.inj_iff", "code": "protected theorem mk.inj_iff {n a b : Nat} {ha : a < n} {hb : b < n} :\n    (\u27e8a, ha\u27e9 : Fin n) = \u27e8b, hb\u27e9 \u2194 a = b", "start": [48, 1], "end": [49, 51], "kind": "commanddeclaration"}, {"full_name": "Fin.val_mk", "code": "theorem val_mk {m n : Nat} (h : m < n) : (\u27e8m, h\u27e9 : Fin n).val = m", "start": [51, 1], "end": [51, 73], "kind": "commanddeclaration"}, {"full_name": "Fin.eq_mk_iff_val_eq", "code": "theorem eq_mk_iff_val_eq {a : Fin n} {k : Nat} {hk : k < n} :\n    a = \u27e8k, hk\u27e9 \u2194 (a : Nat) = k", "start": [53, 1], "end": [54, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_val", "code": "theorem mk_val (i : Fin n) : (\u27e8i, i.isLt\u27e9 : Fin n) = i", "start": [56, 1], "end": [56, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.ofNat'_zero_val", "code": "@[simp] theorem ofNat'_zero_val : (Fin.ofNat' 0 h).val = 0", "start": [58, 1], "end": [58, 77], "kind": "commanddeclaration"}, {"full_name": "Fin.mod_val", "code": "@[simp] theorem mod_val (a b : Fin n) : (a % b).val = a.val % b.val", "start": [60, 1], "end": [61, 60], "kind": "commanddeclaration"}, {"full_name": "Fin.div_val", "code": "@[simp] theorem div_val (a b : Fin n) : (a / b).val = a.val / b.val", "start": [63, 1], "end": [64, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.modn_val", "code": "@[simp] theorem modn_val (a : Fin n) (b : Nat) : (a.modn b).val = a.val % b", "start": [66, 1], "end": [67, 60], "kind": "commanddeclaration"}, {"full_name": "Fin.ite_val", "code": "theorem ite_val {n : Nat} {c : Prop} [Decidable c] {x : c \u2192 Fin n} (y : \u00acc \u2192 Fin n) :\n    (if h : c then x h else y h).val = if h : c then (x h).val else (y h).val", "start": [69, 1], "end": [71, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.dite_val", "code": "theorem dite_val {n : Nat} {c : Prop} [Decidable c] {x y : Fin n} :\n    (if c then x else y).val = if c then x.val else y.val", "start": [73, 1], "end": [75, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.le_def", "code": "theorem le_def {a b : Fin n} : a \u2264 b \u2194 a.1 \u2264 b.1", "start": [79, 1], "end": [79, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.lt_def", "code": "theorem lt_def {a b : Fin n} : a < b \u2194 a.1 < b.1", "start": [81, 1], "end": [81, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.not_le", "code": "@[simp] protected theorem not_le {a b : Fin n} : \u00ac a \u2264 b \u2194 b < a", "start": [83, 1], "end": [83, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.not_lt", "code": "@[simp] protected theorem not_lt {a b : Fin n} : \u00ac a < b \u2194 b \u2264 a", "start": [85, 1], "end": [85, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.ne_of_lt", "code": "protected theorem ne_of_lt {a b : Fin n} (h : a < b) : a \u2260 b", "start": [87, 1], "end": [87, 98], "kind": "commanddeclaration"}, {"full_name": "Fin.ne_of_gt", "code": "protected theorem ne_of_gt {a b : Fin n} (h : a < b) : b \u2260 a", "start": [89, 1], "end": [89, 98], "kind": "commanddeclaration"}, {"full_name": "Fin.is_le", "code": "theorem is_le (i : Fin (n + 1)) : i \u2264 n", "start": [91, 1], "end": [91, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.is_le'", "code": "@[simp] theorem is_le' {a : Fin n} : a \u2264 n", "start": [93, 1], "end": [93, 67], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_lt_of_lt_val", "code": "theorem mk_lt_of_lt_val {b : Fin n} {a : Nat} (h : a < b) :\n    (\u27e8a, Nat.lt_trans h b.is_lt\u27e9 : Fin n) < b", "start": [95, 1], "end": [96, 51], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_le_of_le_val", "code": "theorem mk_le_of_le_val {b : Fin n} {a : Nat} (h : a \u2264 b) :\n    (\u27e8a, Nat.lt_of_le_of_lt h b.is_lt\u27e9 : Fin n) \u2264 b", "start": [98, 1], "end": [99, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_le_mk", "code": "@[simp] theorem mk_le_mk {x y : Nat} {hx hy} : (\u27e8x, hx\u27e9 : Fin n) \u2264 \u27e8y, hy\u27e9 \u2194 x \u2264 y", "start": [101, 1], "end": [101, 91], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_lt_mk", "code": "@[simp] theorem mk_lt_mk {x y : Nat} {hx hy} : (\u27e8x, hx\u27e9 : Fin n) < \u27e8y, hy\u27e9 \u2194 x < y", "start": [103, 1], "end": [103, 91], "kind": "commanddeclaration"}, {"full_name": "Fin.val_zero", "code": "@[simp] theorem val_zero (n : Nat) : (0 : Fin (n + 1)).1 = 0", "start": [105, 1], "end": [105, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_zero", "code": "@[simp] theorem mk_zero : (\u27e80, Nat.succ_pos n\u27e9 : Fin (n + 1)) = 0", "start": [107, 1], "end": [107, 73], "kind": "commanddeclaration"}, {"full_name": "Fin.zero_le", "code": "@[simp] theorem zero_le (a : Fin (n + 1)) : 0 \u2264 a", "start": [109, 1], "end": [109, 71], "kind": "commanddeclaration"}, {"full_name": "Fin.zero_lt_one", "code": "theorem zero_lt_one : (0 : Fin (n + 2)) < 1", "start": [111, 1], "end": [111, 63], "kind": "commanddeclaration"}, {"full_name": "Fin.not_lt_zero", "code": "@[simp] theorem not_lt_zero (a : Fin (n + 1)) : \u00aca < 0", "start": [113, 1], "end": [113, 63], "kind": "commanddeclaration"}, {"full_name": "Fin.pos_iff_ne_zero", "code": "theorem pos_iff_ne_zero {a : Fin (n + 1)} : 0 < a \u2194 a \u2260 0", "start": [115, 1], "end": [116, 64], "kind": "commanddeclaration"}, {"full_name": "Fin.eq_zero_or_eq_succ", "code": "theorem eq_zero_or_eq_succ {n : Nat} : \u2200 i : Fin (n + 1), i = 0 \u2228 \u2203 j : Fin n, i = j.succ", "start": [118, 1], "end": [120, 60], "kind": "commanddeclaration"}, {"full_name": "Fin.eq_succ_of_ne_zero", "code": "theorem eq_succ_of_ne_zero {n : Nat} {i : Fin (n + 1)} (hi : i \u2260 0) : \u2203 j : Fin n, i = j.succ", "start": [122, 1], "end": [123, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.val_rev", "code": "@[simp] theorem val_rev (i : Fin n) : rev i = n - (i + 1)", "start": [125, 1], "end": [125, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.rev_rev", "code": "@[simp] theorem rev_rev (i : Fin n) : rev (rev i) = i", "start": [127, 1], "end": [128, 92], "kind": "commanddeclaration"}, {"full_name": "Fin.rev_le_rev", "code": "@[simp] theorem rev_le_rev {i j : Fin n} : rev i \u2264 rev j \u2194 j \u2264 i", "start": [130, 1], "end": [132, 29], "kind": "commanddeclaration"}, {"full_name": "Fin.rev_inj", "code": "@[simp] theorem rev_inj {i j : Fin n} : rev i = rev j \u2194 i = j", "start": [134, 1], "end": [135, 55], "kind": "commanddeclaration"}, {"full_name": "Fin.rev_eq", "code": "theorem rev_eq {n a : Nat} (i : Fin (n + 1)) (h : n = a + i) :\n    rev i = \u27e8a, Nat.lt_succ_of_le (h \u25b8 Nat.le_add_right ..)\u27e9", "start": [137, 1], "end": [141, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.rev_lt_rev", "code": "@[simp] theorem rev_lt_rev {i j : Fin n} : rev i < rev j \u2194 j < i", "start": [143, 1], "end": [144, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.val_last", "code": "@[simp, norm_cast] theorem val_last (n : Nat) : last n = n", "start": [146, 1], "end": [146, 66], "kind": "commanddeclaration"}, {"full_name": "Fin.le_last", "code": "theorem le_last (i : Fin (n + 1)) : i \u2264 last n", "start": [148, 1], "end": [148, 76], "kind": "commanddeclaration"}, {"full_name": "Fin.last_pos", "code": "theorem last_pos : (0 : Fin (n + 2)) < last (n + 1)", "start": [150, 1], "end": [150, 70], "kind": "commanddeclaration"}, {"full_name": "Fin.eq_last_of_not_lt", "code": "theorem eq_last_of_not_lt {i : Fin (n + 1)} (h : \u00ac(i : Nat) < n) : i = last n", "start": [152, 1], "end": [153, 54], "kind": "commanddeclaration"}, {"full_name": "Fin.val_lt_last", "code": "theorem val_lt_last {i : Fin (n + 1)} : i \u2260 last n \u2192 (i : Nat) < n", "start": [155, 1], "end": [156, 45], "kind": "commanddeclaration"}, {"full_name": "Fin.val_one", "code": "@[simp] theorem val_one (n : Nat) : (1 : Fin (n + 2)).val = 1", "start": [160, 1], "end": [160, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_one", "code": "@[simp] theorem mk_one : (\u27e81, Nat.succ_lt_succ (Nat.succ_pos n)\u27e9 : Fin (n + 2)) = (1 : Fin _)", "start": [162, 1], "end": [162, 101], "kind": "commanddeclaration"}, {"full_name": "Fin.subsingleton_iff_le_one", "code": "theorem subsingleton_iff_le_one : Subsingleton (Fin n) \u2194 n \u2264 1", "start": [164, 1], "end": [168, 96], "kind": "commanddeclaration"}, {"full_name": "Fin.subsingleton_zero", "code": "instance subsingleton_zero : Subsingleton (Fin 0) := subsingleton_iff_le_one.2 (by decide)", "start": [170, 1], "end": [170, 91], "kind": "commanddeclaration"}, {"full_name": "Fin.subsingleton_one", "code": "instance subsingleton_one : Subsingleton (Fin 1) := subsingleton_iff_le_one.2 (by decide)", "start": [172, 1], "end": [172, 90], "kind": "commanddeclaration"}, {"full_name": "Fin.fin_one_eq_zero", "code": "theorem fin_one_eq_zero (a : Fin 1) : a = 0", "start": [174, 1], "end": [174, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.add_def", "code": "theorem add_def (a b : Fin n) : a + b = Fin.mk ((a + b) % n) (Nat.mod_lt _ a.size_pos)", "start": [176, 1], "end": [176, 94], "kind": "commanddeclaration"}, {"full_name": "Fin.val_add", "code": "theorem val_add (a b : Fin n) : (a + b).val = (a.val + b.val) % n", "start": [178, 1], "end": [178, 73], "kind": "commanddeclaration"}, {"full_name": "Fin.val_add_one_of_lt", "code": "theorem val_add_one_of_lt {n : Nat} {i : Fin n.succ} (h : i < last _) : (i + 1).1 = i + 1", "start": [180, 1], "end": [183, 81], "kind": "commanddeclaration"}, {"full_name": "Fin.last_add_one", "code": "@[simp] theorem last_add_one : \u2200 n, last n + 1 = 0", "start": [185, 1], "end": [187, 77], "kind": "commanddeclaration"}, {"full_name": "Fin.val_add_one", "code": "theorem val_add_one {n : Nat} (i : Fin (n + 1)) :\n    ((i + 1 : Fin (n + 1)) : Nat) = if i = last _ then (0 : Nat) else i + 1", "start": [189, 1], "end": [193, 63], "kind": "commanddeclaration"}, {"full_name": "Fin.val_two", "code": "@[simp] theorem val_two {n : Nat} : (2 : Fin (n + 3)).val = 2", "start": [195, 1], "end": [195, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.add_one_pos", "code": "theorem add_one_pos (i : Fin (n + 1)) (h : i < Fin.last n) : (0 : Fin (n + 1)) < i + 1", "start": [197, 1], "end": [203, 29], "kind": "commanddeclaration"}, {"full_name": "Fin.one_pos", "code": "theorem one_pos : (0 : Fin (n + 2)) < 1", "start": [205, 1], "end": [205, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.zero_ne_one", "code": "theorem zero_ne_one : (0 : Fin (n + 2)) \u2260 1", "start": [207, 1], "end": [207, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.val_succ", "code": "@[simp] theorem val_succ (j : Fin n) : (j.succ : Nat) = j + 1", "start": [211, 1], "end": [211, 93], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_pos", "code": "@[simp] theorem succ_pos (a : Fin n) : (0 : Fin (n + 1)) < a.succ", "start": [213, 1], "end": [214, 34], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_le_succ_iff", "code": "@[simp] theorem succ_le_succ_iff {a b : Fin n} : a.succ \u2264 b.succ \u2194 a \u2264 b", "start": [216, 1], "end": [216, 97], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_lt_succ_iff", "code": "@[simp] theorem succ_lt_succ_iff {a b : Fin n} : a.succ < b.succ \u2194 a < b", "start": [218, 1], "end": [218, 97], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_inj", "code": "@[simp] theorem succ_inj {a b : Fin n} : a.succ = b.succ \u2194 a = b", "start": [220, 1], "end": [222, 73], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_ne_zero", "code": "theorem succ_ne_zero {n} : \u2200 k : Fin n, Fin.succ k \u2260 0", "start": [224, 1], "end": [225, 55], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_zero_eq_one", "code": "@[simp] theorem succ_zero_eq_one : Fin.succ (0 : Fin (n + 1)) = 1", "start": [227, 1], "end": [227, 73], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_one_eq_two", "code": "@[simp] theorem succ_one_eq_two : Fin.succ (1 : Fin (n + 2)) = 2", "start": [229, 1], "end": [230, 72], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_mk", "code": "@[simp] theorem succ_mk (n i : Nat) (h : i < n) :\n    Fin.succ \u27e8i, h\u27e9 = \u27e8i + 1, Nat.succ_lt_succ h\u27e9", "start": [232, 1], "end": [233, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_succ_pos", "code": "theorem mk_succ_pos (i : Nat) (h : i < n) :\n    (0 : Fin (n + 1)) < \u27e8i.succ, Nat.add_lt_add_right h 1\u27e9", "start": [235, 1], "end": [237, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.one_lt_succ_succ", "code": "theorem one_lt_succ_succ (a : Fin n) : (1 : Fin (n + 2)) < a.succ.succ", "start": [239, 1], "end": [241, 62], "kind": "commanddeclaration"}, {"full_name": "Fin.add_one_lt_iff", "code": "@[simp] theorem add_one_lt_iff {n : Nat} {k : Fin (n + 2)} : k + 1 < k \u2194 k = last _", "start": [243, 1], "end": [248, 94], "kind": "commanddeclaration"}, {"full_name": "Fin.add_one_le_iff", "code": "@[simp] theorem add_one_le_iff {n : Nat} : \u2200 {k : Fin (n + 1)}, k + 1 \u2264 k \u2194 k = last _", "start": [250, 1], "end": [259, 85], "kind": "commanddeclaration"}, {"full_name": "Fin.last_le_iff", "code": "@[simp] theorem last_le_iff {n : Nat} {k : Fin (n + 1)} : last n \u2264 k \u2194 k = last n", "start": [261, 1], "end": [262, 78], "kind": "commanddeclaration"}, {"full_name": "Fin.lt_add_one_iff", "code": "@[simp] theorem lt_add_one_iff {n : Nat} {k : Fin (n + 1)} : k < k + 1 \u2194 k < last n", "start": [264, 1], "end": [265, 37], "kind": "commanddeclaration"}, {"full_name": "Fin.le_zero_iff", "code": "@[simp] theorem le_zero_iff {n : Nat} {k : Fin (n + 1)} : k \u2264 0 \u2194 k = 0", "start": [267, 1], "end": [268, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_succ_ne_one", "code": "theorem succ_succ_ne_one (a : Fin n) : Fin.succ (Fin.succ a) \u2260 1", "start": [270, 1], "end": [271, 36], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_castLT", "code": "@[simp] theorem coe_castLT (i : Fin m) (h : i.1 < n) : (castLT i h : Nat) = i", "start": [273, 1], "end": [273, 85], "kind": "commanddeclaration"}, {"full_name": "Fin.castLT_mk", "code": "@[simp] theorem castLT_mk (i n m : Nat) (hn : i < n) (hm : i < m) : castLT \u27e8i, hn\u27e9 hm = \u27e8i, hm\u27e9", "start": [275, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_castLE", "code": "@[simp] theorem coe_castLE (h : n \u2264 m) (i : Fin n) : (castLE h i : Nat) = i", "start": [278, 1], "end": [278, 83], "kind": "commanddeclaration"}, {"full_name": "Fin.castLE_mk", "code": "@[simp] theorem castLE_mk (i n m : Nat) (hn : i < n) (h : n \u2264 m) :\n    castLE h \u27e8i, hn\u27e9 = \u27e8i, Nat.lt_of_lt_of_le hn h\u27e9", "start": [280, 1], "end": [281, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.castLE_zero", "code": "@[simp] theorem castLE_zero {n m : Nat} (h : n.succ \u2264 m.succ) : castLE h 0 = 0", "start": [283, 1], "end": [283, 100], "kind": "commanddeclaration"}, {"full_name": "Fin.castLE_succ", "code": "@[simp] theorem castLE_succ {m n : Nat} (h : m + 1 \u2264 n + 1) (i : Fin m) :\n    castLE h i.succ = (castLE (Nat.succ_le_succ_iff.mp h) i).succ", "start": [285, 1], "end": [286, 87], "kind": "commanddeclaration"}, {"full_name": "Fin.castLE_castLE", "code": "@[simp] theorem castLE_castLE {k m n} (km : k \u2264 m) (mn : m \u2264 n) (i : Fin k) :\n    Fin.castLE mn (Fin.castLE km i) = Fin.castLE (Nat.le_trans km mn) i", "start": [288, 1], "end": [290, 38], "kind": "commanddeclaration"}, {"full_name": "Fin.castLE_comp_castLE", "code": "@[simp] theorem castLE_comp_castLE {k m n} (km : k \u2264 m) (mn : m \u2264 n) :\n    Fin.castLE mn \u2218 Fin.castLE km = Fin.castLE (Nat.le_trans km mn)", "start": [292, 1], "end": [294, 31], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_cast", "code": "@[simp] theorem coe_cast (h : n = m) (i : Fin n) : (cast h i : Nat) = i", "start": [296, 1], "end": [296, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_last", "code": "@[simp] theorem cast_last {n' : Nat} {h : n + 1 = n' + 1} : cast h (last n) = last n'", "start": [298, 1], "end": [299, 61], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_mk", "code": "@[simp] theorem cast_mk (h : n = m) (i : Nat) (hn : i < n) : cast h \u27e8i, hn\u27e9 = \u27e8i, h \u25b8 hn\u27e9", "start": [301, 1], "end": [301, 97], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_trans", "code": "@[simp] theorem cast_trans {k : Nat} (h : n = m) (h' : m = k) {i : Fin n} :\n    cast h' (cast h i) = cast (Eq.trans h h') i", "start": [303, 1], "end": [304, 55], "kind": "commanddeclaration"}, {"full_name": "Fin.castLE_of_eq", "code": "theorem castLE_of_eq {m n : Nat} (h : m = n) {h' : m \u2264 n} : castLE h' = Fin.cast h", "start": [306, 1], "end": [306, 90], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_castAdd", "code": "@[simp] theorem coe_castAdd (m : Nat) (i : Fin n) : (castAdd m i : Nat) = i", "start": [308, 1], "end": [308, 83], "kind": "commanddeclaration"}, {"full_name": "Fin.castAdd_zero", "code": "@[simp] theorem castAdd_zero : (castAdd 0 : Fin n \u2192 Fin (n + 0)) = cast rfl", "start": [310, 1], "end": [310, 83], "kind": "commanddeclaration"}, {"full_name": "Fin.castAdd_lt", "code": "theorem castAdd_lt {m : Nat} (n : Nat) (i : Fin m) : (castAdd n i : Nat) < m", "start": [312, 1], "end": [312, 88], "kind": "commanddeclaration"}, {"full_name": "Fin.castAdd_mk", "code": "@[simp] theorem castAdd_mk (m : Nat) (i : Nat) (h : i < n) :\n    castAdd m \u27e8i, h\u27e9 = \u27e8i, Nat.lt_add_right i n m h\u27e9", "start": [314, 1], "end": [315, 60], "kind": "commanddeclaration"}, {"full_name": "Fin.castAdd_castLT", "code": "@[simp] theorem castAdd_castLT (m : Nat) (i : Fin (n + m)) (hi : i.val < n) :\n    castAdd m (castLT i hi) = i", "start": [317, 1], "end": [318, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.castLT_castAdd", "code": "@[simp] theorem castLT_castAdd (m : Nat) (i : Fin n) :\n    castLT (castAdd m i) (castAdd_lt m i) = i", "start": [320, 1], "end": [321, 53], "kind": "commanddeclaration"}, {"full_name": "Fin.castAdd_cast", "code": "theorem castAdd_cast {n n' : Nat} (m : Nat) (i : Fin n') (h : n' = n) :\n    castAdd m (Fin.cast h i) = Fin.cast (congrArg (. + m) h) (castAdd m i)", "start": [323, 1], "end": [325, 86], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_castAdd_left", "code": "theorem cast_castAdd_left {n n' m : Nat} (i : Fin n') (h : n' + m = n + m) :\n    cast h (castAdd m i) = castAdd m (cast (Nat.add_right_cancel h) i)", "start": [327, 1], "end": [328, 78], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_castAdd_right", "code": "@[simp] theorem cast_castAdd_right {n m m' : Nat} (i : Fin n) (h : n + m' = n + m) :\n    cast h (castAdd m' i) = castAdd m i", "start": [330, 1], "end": [331, 47], "kind": "commanddeclaration"}, {"full_name": "Fin.castAdd_castAdd", "code": "theorem castAdd_castAdd {m n p : Nat} (i : Fin m) :\n    castAdd p (castAdd n i) = cast (Nat.add_assoc ..).symm (castAdd (n + p) i)", "start": [333, 1], "end": [334, 86], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_succ_eq", "code": "@[simp] theorem cast_succ_eq {n' : Nat} (i : Fin n) (h : n.succ = n'.succ) :\n    cast h i.succ = (cast (Nat.succ.inj h) i).succ", "start": [336, 1], "end": [339, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_cast_eq", "code": "theorem succ_cast_eq {n' : Nat} (i : Fin n) (h : n = n') :\n    (cast h i).succ = cast (by rw [h]) i.succ", "start": [341, 1], "end": [342, 53], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_castSucc", "code": "@[simp] theorem coe_castSucc (i : Fin n) : (Fin.castSucc i : Nat) = i", "start": [344, 1], "end": [344, 77], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_mk", "code": "@[simp] theorem castSucc_mk (n i : Nat) (h : i < n) : castSucc \u27e8i, h\u27e9 = \u27e8i, Nat.lt.step h\u27e9", "start": [346, 1], "end": [346, 98], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_castSucc", "code": "@[simp] theorem cast_castSucc {n' : Nat} {h : n + 1 = n' + 1} {i : Fin n} :\n    cast h (castSucc i) = castSucc (cast (Nat.succ.inj h) i)", "start": [348, 1], "end": [349, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_lt_succ", "code": "theorem castSucc_lt_succ (i : Fin n) : Fin.castSucc i < i.succ", "start": [351, 1], "end": [352, 70], "kind": "commanddeclaration"}, {"full_name": "Fin.le_castSucc_iff", "code": "theorem le_castSucc_iff {i : Fin (n + 1)} {j : Fin n} : i \u2264 Fin.castSucc j \u2194 i < j.succ", "start": [354, 1], "end": [355, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_lt_iff_succ_le", "code": "theorem castSucc_lt_iff_succ_le {n : Nat} {i : Fin n} {j : Fin (n + 1)} :\n    Fin.castSucc i < j \u2194 i.succ \u2264 j", "start": [357, 1], "end": [358, 44], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_last", "code": "@[simp] theorem succ_last (n : Nat) : (last n).succ = last n.succ", "start": [360, 1], "end": [360, 73], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_eq_last_succ", "code": "@[simp] theorem succ_eq_last_succ {n : Nat} (i : Fin n.succ) :\n    i.succ = last (n + 1) \u2194 i = last n", "start": [362, 1], "end": [363, 72], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_castLT", "code": "@[simp] theorem castSucc_castLT (i : Fin (n + 1)) (h : (i : Nat) < n) :\n    castSucc (castLT i h) = i", "start": [365, 1], "end": [366, 37], "kind": "commanddeclaration"}, {"full_name": "Fin.castLT_castSucc", "code": "@[simp] theorem castLT_castSucc {n : Nat} (a : Fin n) (h : (a : Nat) < n) :\n    castLT (castSucc a) h = a", "start": [368, 1], "end": [369, 37], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_lt_castSucc_iff", "code": "@[simp] theorem castSucc_lt_castSucc_iff {a b : Fin n} :\n    Fin.castSucc a < Fin.castSucc b \u2194 a < b", "start": [371, 1], "end": [372, 52], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_inj", "code": "theorem castSucc_inj {a b : Fin n} : castSucc a = castSucc b \u2194 a = b", "start": [374, 1], "end": [374, 90], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_lt_last", "code": "theorem castSucc_lt_last (a : Fin n) : castSucc a < last n", "start": [376, 1], "end": [376, 70], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_zero", "code": "@[simp] theorem castSucc_zero : castSucc (0 : Fin (n + 1)) = 0", "start": [378, 1], "end": [378, 70], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_one", "code": "@[simp] theorem castSucc_one {n : Nat} : castSucc (1 : Fin (n + 2)) = 1", "start": [380, 1], "end": [380, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_pos", "code": "theorem castSucc_pos {i : Fin (n + 1)} (h : 0 < i) : 0 < castSucc i", "start": [382, 1], "end": [384, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_eq_zero_iff", "code": "@[simp] theorem castSucc_eq_zero_iff (a : Fin (n + 1)) : castSucc a = 0 \u2194 a = 0", "start": [386, 1], "end": [386, 101], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_ne_zero_iff", "code": "theorem castSucc_ne_zero_iff (a : Fin (n + 1)) : castSucc a \u2260 0 \u2194 a \u2260 0", "start": [388, 1], "end": [389, 38], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_fin_succ", "code": "theorem castSucc_fin_succ (n : Nat) (j : Fin n) :\n    castSucc (Fin.succ j) = Fin.succ (castSucc j)", "start": [391, 1], "end": [392, 75], "kind": "commanddeclaration"}, {"full_name": "Fin.coeSucc_eq_succ", "code": "@[simp]\ntheorem coeSucc_eq_succ {a : Fin n} : castSucc a + 1 = a.succ", "start": [394, 1], "end": [398, 73], "kind": "commanddeclaration"}, {"full_name": "Fin.lt_succ", "code": "theorem lt_succ {a : Fin n} : castSucc a < a.succ", "start": [400, 1], "end": [401, 77], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_castSucc_eq", "code": "theorem exists_castSucc_eq {n : Nat} {i : Fin (n + 1)} : (\u2203 j, castSucc j = i) \u2194 i \u2260 last n", "start": [403, 1], "end": [405, 52], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_castSucc", "code": "theorem succ_castSucc {n : Nat} (i : Fin n) : i.castSucc.succ = castSucc i.succ", "start": [407, 1], "end": [407, 87], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_addNat", "code": "@[simp] theorem coe_addNat (m : Nat) (i : Fin n) : (addNat i m : Nat) = i + m", "start": [409, 1], "end": [409, 85], "kind": "commanddeclaration"}, {"full_name": "Fin.addNat_one", "code": "@[simp] theorem addNat_one {i : Fin n} : addNat i 1 = i.succ", "start": [411, 1], "end": [411, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.le_coe_addNat", "code": "theorem le_coe_addNat (m : Nat) (i : Fin n) : m \u2264 addNat i m", "start": [413, 1], "end": [414, 22], "kind": "commanddeclaration"}, {"full_name": "Fin.addNat_mk", "code": "@[simp] theorem addNat_mk (n i : Nat) (hi : i < m) :\n    addNat \u27e8i, hi\u27e9 n = \u27e8i + n, Nat.add_lt_add_right hi n\u27e9", "start": [416, 1], "end": [417, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_addNat_zero", "code": "@[simp] theorem cast_addNat_zero {n n' : Nat} (i : Fin n) (h : n + 0 = n') :\n    cast h (addNat i 0) = cast ((Nat.add_zero _).symm.trans h) i", "start": [419, 1], "end": [420, 72], "kind": "commanddeclaration"}, {"full_name": "Fin.addNat_cast", "code": "theorem addNat_cast {n n' m : Nat} (i : Fin n') (h : n' = n) :\n    addNat (cast h i) m = cast (congrArg (. + m) h) (addNat i m)", "start": [422, 1], "end": [424, 72], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_addNat_left", "code": "theorem cast_addNat_left {n n' m : Nat} (i : Fin n') (h : n' + m = n + m) :\n    cast h (addNat i m) = addNat (cast (Nat.add_right_cancel h) i) m", "start": [426, 1], "end": [427, 76], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_addNat_right", "code": "@[simp] theorem cast_addNat_right {n m m' : Nat} (i : Fin n) (h : n + m' = n + m) :\n    cast h (addNat i m') = addNat i m", "start": [429, 1], "end": [431, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_natAdd", "code": "@[simp] theorem coe_natAdd (n : Nat) {m : Nat} (i : Fin m) : (natAdd n i : Nat) = n + i", "start": [433, 1], "end": [433, 95], "kind": "commanddeclaration"}, {"full_name": "Fin.natAdd_mk", "code": "@[simp] theorem natAdd_mk (n i : Nat) (hi : i < m) :\n    natAdd n \u27e8i, hi\u27e9 = \u27e8n + i, Nat.add_lt_add_left hi n\u27e9", "start": [435, 1], "end": [436, 64], "kind": "commanddeclaration"}, {"full_name": "Fin.le_coe_natAdd", "code": "theorem le_coe_natAdd (m : Nat) (i : Fin n) : m \u2264 natAdd m i", "start": [438, 1], "end": [438, 84], "kind": "commanddeclaration"}, {"full_name": "Fin.natAdd_zero", "code": "theorem natAdd_zero {n : Nat} : natAdd 0 = cast (Nat.zero_add n).symm", "start": [440, 1], "end": [440, 86], "kind": "commanddeclaration"}, {"full_name": "Fin.natAdd_cast", "code": "theorem natAdd_cast {n n' : Nat} (m : Nat) (i : Fin n') (h : n' = n) :\n    natAdd m (cast h i) = cast (congrArg _ h) (natAdd m i)", "start": [442, 1], "end": [444, 66], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_natAdd_right", "code": "theorem cast_natAdd_right {n n' m : Nat} (i : Fin n') (h : m + n' = m + n) :\n    cast h (natAdd m i) = natAdd m (cast (Nat.add_left_cancel h) i)", "start": [446, 1], "end": [447, 75], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_natAdd_left", "code": "@[simp] theorem cast_natAdd_left {n m m' : Nat} (i : Fin n) (h : m' + n = m + n) :\n    cast h (natAdd m' i) = natAdd m i", "start": [449, 1], "end": [451, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.castAdd_natAdd", "code": "theorem castAdd_natAdd (p m : Nat) {n : Nat} (i : Fin n) :\n    castAdd p (natAdd m i) = cast (Nat.add_assoc ..).symm (natAdd m (castAdd p i))", "start": [453, 1], "end": [454, 90], "kind": "commanddeclaration"}, {"full_name": "Fin.natAdd_castAdd", "code": "theorem natAdd_castAdd (p m : Nat) {n : Nat} (i : Fin n) :\n    natAdd m (castAdd p i) = cast (Nat.add_assoc ..) (castAdd p (natAdd m i))", "start": [456, 1], "end": [457, 85], "kind": "commanddeclaration"}, {"full_name": "Fin.natAdd_natAdd", "code": "theorem natAdd_natAdd (m n : Nat) {p : Nat} (i : Fin p) :\n    natAdd m (natAdd n i) = cast (Nat.add_assoc ..) (natAdd (m + n) i)", "start": [459, 1], "end": [461, 33], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_natAdd_zero", "code": "@[simp]\ntheorem cast_natAdd_zero {n n' : Nat} (i : Fin n) (h : 0 + n = n') :\n    cast h (natAdd 0 i) = cast ((Nat.zero_add _).symm.trans h) i", "start": [463, 1], "end": [466, 24], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_natAdd", "code": "@[simp]\ntheorem cast_natAdd (n : Nat) {m : Nat} (i : Fin m) :\n    cast (Nat.add_comm ..) (natAdd n i) = addNat i n", "start": [468, 1], "end": [470, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_addNat", "code": "@[simp]\ntheorem cast_addNat {n : Nat} (m : Nat) (i : Fin n) :\n    cast (Nat.add_comm ..) (addNat i m) = natAdd m i", "start": [472, 1], "end": [474, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.natAdd_last", "code": "@[simp] theorem natAdd_last {m n : Nat} : natAdd n (last m) = last (n + m)", "start": [476, 1], "end": [476, 82], "kind": "commanddeclaration"}, {"full_name": "Fin.natAdd_castSucc", "code": "theorem natAdd_castSucc {m n : Nat} {i : Fin m} : natAdd n (castSucc i) = castSucc (natAdd n i)", "start": [478, 1], "end": [479, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_pred", "code": "@[simp] theorem coe_pred (j : Fin (n + 1)) (h : j \u2260 0) : (j.pred h : Nat) = j - 1", "start": [483, 1], "end": [483, 89], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_pred", "code": "@[simp] theorem succ_pred : \u2200 (i : Fin (n + 1)) (h : i \u2260 0), (i.pred h).succ = i", "start": [485, 1], "end": [487, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_succ", "code": "@[simp]\ntheorem pred_succ (i : Fin n) {h : i.succ \u2260 0} : i.succ.pred h = i", "start": [489, 1], "end": [492, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_eq_iff_eq_succ", "code": "theorem pred_eq_iff_eq_succ {n : Nat} (i : Fin (n + 1)) (hi : i \u2260 0) (j : Fin n) :\n    i.pred hi = j \u2194 i = j.succ", "start": [494, 1], "end": [496, 89], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_mk_succ", "code": "theorem pred_mk_succ (i : Nat) (h : i < n + 1) :\n    Fin.pred \u27e8i + 1, Nat.add_lt_add_right h 1\u27e9 (ne_of_val_ne (Nat.ne_of_gt (mk_succ_pos i h))) =\n      \u27e8i, h\u27e9", "start": [498, 1], "end": [501, 52], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_mk_succ'", "code": "@[simp] theorem pred_mk_succ' (i : Nat) (h\u2081 : i + 1 < n + 1 + 1) (h\u2082) :\n    Fin.pred \u27e8i + 1, h\u2081\u27e9 h\u2082 = \u27e8i, Nat.lt_of_succ_lt_succ h\u2081\u27e9", "start": [503, 1], "end": [504, 81], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_mk", "code": "theorem pred_mk {n : Nat} (i : Nat) (h : i < n + 1) (w) : Fin.pred \u27e8i, h\u27e9 w =\n    \u27e8i - 1, Nat.sub_lt_right_of_lt_add (Nat.pos_iff_ne_zero.2 (Fin.val_ne_of_ne w)) h\u27e9", "start": [507, 1], "end": [509, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_le_pred_iff", "code": "@[simp] theorem pred_le_pred_iff {n : Nat} {a b : Fin n.succ} {ha : a \u2260 0} {hb : b \u2260 0} :\n    a.pred ha \u2264 b.pred hb \u2194 a \u2264 b", "start": [511, 1], "end": [512, 86], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_lt_pred_iff", "code": "@[simp] theorem pred_lt_pred_iff {n : Nat} {a b : Fin n.succ} {ha : a \u2260 0} {hb : b \u2260 0} :\n    a.pred ha < b.pred hb \u2194 a < b", "start": [514, 1], "end": [515, 86], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_inj", "code": "@[simp] theorem pred_inj :\n    \u2200 {a b : Fin (n + 1)} {ha : a \u2260 0} {hb : b \u2260 0}, a.pred ha = b.pred hb \u2194 a = b", "start": [517, 1], "end": [521, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_one", "code": "@[simp] theorem pred_one {n : Nat} :\n    Fin.pred (1 : Fin (n + 2)) (Ne.symm (Fin.ne_of_lt one_pos)) = 0", "start": [523, 1], "end": [524, 75], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_add_one", "code": "theorem pred_add_one (i : Fin (n + 2)) (h : (i : Nat) < n + 1) :\n    pred (i + 1) (Fin.ne_of_gt (add_one_pos _ (lt_def.2 h))) = castLT i h", "start": [526, 1], "end": [529, 33], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_subNat", "code": "@[simp] theorem coe_subNat (i : Fin (n + m)) (h : m \u2264 i) : (i.subNat m h : Nat) = i - m", "start": [531, 1], "end": [531, 95], "kind": "commanddeclaration"}, {"full_name": "Fin.subNat_mk", "code": "@[simp] theorem subNat_mk {i : Nat} (h\u2081 : i < n + m) (h\u2082 : m \u2264 i) :\n    subNat m \u27e8i, h\u2081\u27e9 h\u2082 = \u27e8i - m, Nat.sub_lt_right_of_lt_add h\u2082 h\u2081\u27e9", "start": [533, 1], "end": [534, 75], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_castSucc_succ", "code": "@[simp] theorem pred_castSucc_succ (i : Fin n) :\n    pred (castSucc i.succ) (Fin.ne_of_gt (castSucc_pos i.succ_pos)) = castSucc i", "start": [536, 1], "end": [537, 88], "kind": "commanddeclaration"}, {"full_name": "Fin.addNat_subNat", "code": "@[simp] theorem addNat_subNat {i : Fin (n + m)} (h : m \u2264 i) : addNat (subNat m i h) m = i", "start": [539, 1], "end": [540, 30], "kind": "commanddeclaration"}, {"full_name": "Fin.subNat_addNat", "code": "@[simp] theorem subNat_addNat (i : Fin n) (m : Nat) (h : m \u2264 addNat i m := le_coe_addNat m i) :\n    subNat m (addNat i m) h = i", "start": [542, 1], "end": [543, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.natAdd_subNat_cast", "code": "@[simp] theorem natAdd_subNat_cast {i : Fin (n + m)} (h : n \u2264 i) :\n    natAdd n (subNat n (cast (Nat.add_comm ..) i) h) = i", "start": [545, 1], "end": [546, 89], "kind": "commanddeclaration"}, {"full_name": "Fin.succRec", "code": "@[elab_as_elim] def succRec {motive : \u2200 n, Fin n \u2192 Sort _}\n    (zero : \u2200 n, motive n.succ (0 : Fin (n + 1)))\n    (succ : \u2200 n i, motive n i \u2192 motive n.succ i.succ) : \u2200 {n : Nat} (i : Fin n), motive n i\n  | 0, i => i.elim0\n  | Nat.succ n, \u27e80, _\u27e9 => by rw [mk_zero]; exact zero n\n  | Nat.succ _, \u27e8Nat.succ i, h\u27e9 => succ _ _ (succRec zero succ \u27e8i, Nat.lt_of_succ_lt_succ h\u27e9)", "start": [550, 1], "end": [560, 94], "kind": "commanddeclaration"}, {"full_name": "Fin.succRecOn", "code": "@[elab_as_elim] def succRecOn {n : Nat} (i : Fin n) {motive : \u2200 n, Fin n \u2192 Sort _}\n    (zero : \u2200 n, motive (n + 1) 0) (succ : \u2200 n i, motive n i \u2192 motive (Nat.succ n) i.succ) :\n    motive n i := i.succRec zero succ", "start": [562, 1], "end": [572, 38], "kind": "commanddeclaration"}, {"full_name": "Fin.succRecOn_zero", "code": "@[simp] theorem succRecOn_zero {motive : \u2200 n, Fin n \u2192 Sort _} {zero succ} (n) :\n    @Fin.succRecOn (n + 1) 0 motive zero succ = zero n", "start": [574, 1], "end": [576, 18], "kind": "commanddeclaration"}, {"full_name": "Fin.succRecOn_succ", "code": "@[simp] theorem succRecOn_succ {motive : \u2200 n, Fin n \u2192 Sort _} {zero succ} {n} (i : Fin n) :\n    @Fin.succRecOn (n + 1) i.succ motive zero succ = succ n i (Fin.succRecOn i zero succ)", "start": [578, 1], "end": [580, 15], "kind": "commanddeclaration"}, {"full_name": "Fin.induction", "code": "@[elab_as_elim] def induction {motive : Fin (n + 1) \u2192 Sort _} (zero : motive 0)\n    (succ : \u2200 i : Fin n, motive (castSucc i) \u2192 motive i.succ) :\n    \u2200 i : Fin (n + 1), motive i\n  | \u27e80, hi\u27e9 => by rwa [Fin.mk_zero]\n  | \u27e8i+1, hi\u27e9 => succ \u27e8i, Nat.lt_of_succ_lt_succ hi\u27e9 (induction zero succ \u27e8i, Nat.lt_of_succ_lt hi\u27e9)", "start": [582, 1], "end": [591, 101], "kind": "commanddeclaration"}, {"full_name": "Fin.induction_zero", "code": "@[simp] theorem induction_zero {motive : Fin (n + 1) \u2192 Sort _} (zero : motive 0)\n    (hs : \u2200 i : Fin n, motive (castSucc i) \u2192 motive i.succ) :\n    (induction zero hs : \u2200 i : Fin (n + 1), motive i) 0 = zero", "start": [593, 1], "end": [595, 70], "kind": "commanddeclaration"}, {"full_name": "Fin.induction_succ", "code": "@[simp] theorem induction_succ {motive : Fin (n + 1) \u2192 Sort _} (zero : motive 0)\n    (succ : \u2200 i : Fin n, motive (castSucc i) \u2192 motive i.succ) (i : Fin n) :\n    induction (motive := motive) zero succ i.succ = succ i (induction zero succ (castSucc i))", "start": [597, 1], "end": [599, 101], "kind": "commanddeclaration"}, {"full_name": "Fin.inductionOn", "code": "@[elab_as_elim] def inductionOn (i : Fin (n + 1)) {motive : Fin (n + 1) \u2192 Sort _} (zero : motive 0)\n    (succ : \u2200 i : Fin n, motive (castSucc i) \u2192 motive i.succ) : motive i := induction zero succ i", "start": [601, 1], "end": [609, 98], "kind": "commanddeclaration"}, {"full_name": "Fin.cases", "code": "@[elab_as_elim] def cases {motive : Fin (n + 1) \u2192 Sort _}\n    (zero : motive 0) (succ : \u2200 i : Fin n, motive i.succ) :\n    \u2200 i : Fin (n + 1), motive i := induction zero fun i _ => succ i", "start": [611, 1], "end": [615, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.cases_zero", "code": "@[simp] theorem cases_zero {n} {motive : Fin (n + 1) \u2192 Sort _} {zero succ} :\n    @Fin.cases n motive zero succ 0 = zero", "start": [617, 1], "end": [618, 50], "kind": "commanddeclaration"}, {"full_name": "Fin.cases_succ", "code": "@[simp] theorem cases_succ {n} {motive : Fin (n + 1) \u2192 Sort _} {zero succ} (i : Fin n) :\n    @Fin.cases n motive zero succ i.succ = succ i", "start": [620, 1], "end": [621, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.cases_succ'", "code": "@[simp] theorem cases_succ' {n} {motive : Fin (n + 1) \u2192 Sort _} {zero succ}\n    {i : Nat} (h : i + 1 < n + 1) :\n    @Fin.cases n motive zero succ \u27e8i.succ, h\u27e9 = succ \u27e8i, Nat.lt_of_succ_lt_succ h\u27e9", "start": [623, 1], "end": [625, 90], "kind": "commanddeclaration"}, {"full_name": "Fin.forall_fin_succ", "code": "theorem forall_fin_succ {P : Fin (n + 1) \u2192 Prop} : (\u2200 i, P i) \u2194 P 0 \u2227 \u2200 i : Fin n, P i.succ", "start": [627, 1], "end": [628, 70], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_fin_succ", "code": "theorem exists_fin_succ {P : Fin (n + 1) \u2192 Prop} : (\u2203 i, P i) \u2194 P 0 \u2228 \u2203 i : Fin n, P i.succ", "start": [630, 1], "end": [632, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.forall_fin_one", "code": "theorem forall_fin_one {p : Fin 1 \u2192 Prop} : (\u2200 i, p i) \u2194 p 0", "start": [634, 1], "end": [635, 55], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_fin_one", "code": "theorem exists_fin_one {p : Fin 1 \u2192 Prop} : (\u2203 i, p i) \u2194 p 0", "start": [637, 1], "end": [638, 61], "kind": "commanddeclaration"}, {"full_name": "Fin.forall_fin_two", "code": "theorem forall_fin_two {p : Fin 2 \u2192 Prop} : (\u2200 i, p i) \u2194 p 0 \u2227 p 1", "start": [640, 1], "end": [641, 67], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_fin_two", "code": "theorem exists_fin_two {p : Fin 2 \u2192 Prop} : (\u2203 i, p i) \u2194 p 0 \u2228 p 1", "start": [643, 1], "end": [644, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.fin_two_eq_of_eq_zero_iff", "code": "theorem fin_two_eq_of_eq_zero_iff : \u2200 {a b : Fin 2}, (a = 0 \u2194 b = 0) \u2192 a = b", "start": [646, 1], "end": [647, 24], "kind": "commanddeclaration"}, {"full_name": "Fin.reverseInduction", "code": "@[elab_as_elim] def reverseInduction {motive : Fin (n + 1) \u2192 Sort _} (last : motive (Fin.last n))\n    (cast : \u2200 i : Fin n, motive i.succ \u2192 motive (castSucc i)) (i : Fin (n + 1)) : motive i :=\n  if hi : i = Fin.last n then _root_.cast (congrArg motive hi.symm) last\n  else\n    let j : Fin n := \u27e8i, Nat.lt_of_le_of_ne (Nat.le_of_lt_succ i.2) fun h => hi (Fin.ext h)\u27e9\n    cast _ (reverseInduction last cast j.succ)\ntermination_by _ => n + 1 - i\ndecreasing_by decreasing_with\n  exact Nat.add_sub_add_right .. \u25b8 Nat.sub_lt_sub_left i.2 (Nat.lt_succ_self i)", "start": [649, 1], "end": [663, 80], "kind": "commanddeclaration"}, {"full_name": "Fin.reverseInduction_last", "code": "@[simp] theorem reverseInduction_last {n : Nat} {motive : Fin (n + 1) \u2192 Sort _} {zero succ} :\n    (reverseInduction zero succ (Fin.last n) : motive (Fin.last n)) = zero", "start": [665, 1], "end": [667, 35], "kind": "commanddeclaration"}, {"full_name": "Fin.reverseInduction_castSucc", "code": "@[simp] theorem reverseInduction_castSucc {n : Nat} {motive : Fin (n + 1) \u2192 Sort _} {zero succ}\n    (i : Fin n) : reverseInduction (motive := motive) zero succ (castSucc i) =\n      succ i (reverseInduction zero succ i.succ)", "start": [669, 1], "end": [672, 78], "kind": "commanddeclaration"}, {"full_name": "Fin.lastCases", "code": "@[elab_as_elim] def lastCases {n : Nat} {motive : Fin (n + 1) \u2192 Sort _} (last : motive (Fin.last n))\n    (cast : \u2200 i : Fin n, motive (castSucc i)) (i : Fin (n + 1)) : motive i :=\n  reverseInduction last (fun i _ => cast i) i", "start": [674, 1], "end": [678, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.lastCases_last", "code": "@[simp] theorem lastCases_last {n : Nat} {motive : Fin (n + 1) \u2192 Sort _} {last cast} :\n    (Fin.lastCases last cast (Fin.last n) : motive (Fin.last n)) = last", "start": [680, 1], "end": [682, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.lastCases_castSucc", "code": "@[simp] theorem lastCases_castSucc {n : Nat} {motive : Fin (n + 1) \u2192 Sort _} {last cast}\n    (i : Fin n) : (Fin.lastCases last cast (Fin.castSucc i) : motive (Fin.castSucc i)) = cast i", "start": [684, 1], "end": [686, 31], "kind": "commanddeclaration"}, {"full_name": "Fin.addCases", "code": "@[elab_as_elim] def addCases {m n : Nat} {motive : Fin (m + n) \u2192 Sort u}\n    (left : \u2200 i, motive (castAdd n i)) (right : \u2200 i, motive (natAdd m i))\n    (i : Fin (m + n)) : motive i :=\n  if hi : (i : Nat) < m then (castAdd_castLT n i hi) \u25b8 (left (castLT i hi))\n  else (natAdd_subNat_cast (Nat.le_of_not_lt hi)) \u25b8 (right _)", "start": [688, 1], "end": [694, 62], "kind": "commanddeclaration"}, {"full_name": "Fin.addCases_left", "code": "@[simp] theorem addCases_left {m n : Nat} {motive : Fin (m + n) \u2192 Sort _} {left right} (i : Fin m) :\n    addCases (motive := motive) left right (Fin.castAdd n i) = left i", "start": [696, 1], "end": [698, 47], "kind": "commanddeclaration"}, {"full_name": "Fin.addCases_right", "code": "@[simp]\ntheorem addCases_right {m n : Nat} {motive : Fin (m + n) \u2192 Sort _} {left right} (i : Fin n) :\n    addCases (motive := motive) left right (natAdd m i) = right i", "start": [700, 1], "end": [704, 91], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_clamp", "code": "@[simp] theorem coe_clamp (n m : Nat) : (clamp n m : Nat) = min n m", "start": [708, 1], "end": [708, 75], "kind": "commanddeclaration"}, {"full_name": "Fin.val_mul", "code": "theorem val_mul {n : Nat} : \u2200 a b : Fin n, (a * b).val = a.val * b.val % n", "start": [712, 1], "end": [713, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_mul", "code": "theorem coe_mul {n : Nat} : \u2200 a b : Fin n, ((a * b : Fin n) : Nat) = a * b % n", "start": [715, 1], "end": [716, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.mul_one", "code": "protected theorem mul_one (k : Fin (n + 1)) : k * 1 = k", "start": [718, 1], "end": [721, 63], "kind": "commanddeclaration"}, {"full_name": "Fin.mul_comm", "code": "protected theorem mul_comm (a b : Fin n) : a * b = b * a", "start": [723, 1], "end": [724, 48], "kind": "commanddeclaration"}, {"full_name": "Fin.one_mul", "code": "protected theorem one_mul (k : Fin (n + 1)) : (1 : Fin (n + 1)) * k = k", "start": [726, 1], "end": [727, 33], "kind": "commanddeclaration"}, {"full_name": "Fin.mul_zero", "code": "protected theorem mul_zero (k : Fin (n + 1)) : k * 0 = 0", "start": [729, 1], "end": [729, 87], "kind": "commanddeclaration"}, {"full_name": "Fin.zero_mul", "code": "protected theorem zero_mul (k : Fin (n + 1)) : (0 : Fin (n + 1)) * k = 0", "start": [731, 1], "end": [732, 26], "kind": "commanddeclaration"}, {"full_name": "USize.lt_def", "code": "@[simp] theorem lt_def {a b : USize} : a < b \u2194 a.toNat < b.toNat", "start": [738, 1], "end": [738, 73], "kind": "commanddeclaration"}, {"full_name": "USize.le_def", "code": "@[simp] theorem le_def {a b : USize} : a \u2264 b \u2194 a.toNat \u2264 b.toNat", "start": [740, 1], "end": [740, 73], "kind": "commanddeclaration"}, {"full_name": "USize.zero_toNat", "code": "@[simp] theorem zero_toNat : (0 : USize).toNat = 0", "start": [742, 1], "end": [742, 69], "kind": "commanddeclaration"}, {"full_name": "USize.mod_toNat", "code": "@[simp] theorem mod_toNat (a b : USize) : (a % b).toNat = a.toNat % b.toNat", "start": [744, 1], "end": [745, 17], "kind": "commanddeclaration"}, {"full_name": "USize.div_toNat", "code": "@[simp] theorem div_toNat (a b : USize) : (a / b).toNat = a.toNat / b.toNat", "start": [747, 1], "end": [748, 17], "kind": "commanddeclaration"}, {"full_name": "USize.modn_toNat", "code": "@[simp] theorem modn_toNat (a : USize) (b : Nat) : (a.modn b).toNat = a.toNat % b", "start": [750, 1], "end": [751, 18], "kind": "commanddeclaration"}, {"full_name": "USize.mod_lt", "code": "theorem mod_lt (a b : USize) (h : 0 < b) : a % b < b", "start": [753, 1], "end": [753, 96], "kind": "commanddeclaration"}, {"full_name": "USize.toNat.inj", "code": "theorem toNat.inj : \u2200 {a b : USize}, a.toNat = b.toNat \u2192 a = b", "start": [755, 1], "end": [756, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/List/Count.lean", "imports": ["lake-packages/std/Std/Data/List/Lemmas.lean", "lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.countP_nil", "code": "@[simp] theorem countP_nil : countP p [] = 0", "start": [26, 1], "end": [26, 52], "kind": "commanddeclaration"}, {"full_name": "List.countP_go_eq_add", "code": "protected theorem countP_go_eq_add (l) : countP.go p l n = n + countP.go p l 0", "start": [28, 1], "end": [34, 61], "kind": "commanddeclaration"}, {"full_name": "List.countP_cons_of_pos", "code": "@[simp] theorem countP_cons_of_pos (l) (pa : p a) : countP p (a :: l) = countP p l + 1", "start": [36, 1], "end": [39, 49], "kind": "commanddeclaration"}, {"full_name": "List.countP_cons_of_neg", "code": "@[simp] theorem countP_cons_of_neg (l) (pa : \u00acp a) : countP p (a :: l) = countP p l", "start": [41, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "List.countP_cons", "code": "theorem countP_cons (a : \u03b1) (l) : countP p (a :: l) = countP p l + if p a then 1 else 0", "start": [44, 1], "end": [45, 32], "kind": "commanddeclaration"}, {"full_name": "List.length_eq_countP_add_countP", "code": "theorem length_eq_countP_add_countP (l) : length l = countP p l + countP (fun a => \u00acp a) l", "start": [47, 1], "end": [58, 22], "kind": "commanddeclaration"}, {"full_name": "List.countP_eq_length_filter", "code": "theorem countP_eq_length_filter (l) : countP p l = length (filter p l)", "start": [60, 1], "end": [66, 67], "kind": "commanddeclaration"}, {"full_name": "List.countP_le_length", "code": "theorem countP_le_length : countP p l \u2264 l.length", "start": [68, 1], "end": [70, 25], "kind": "commanddeclaration"}, {"full_name": "List.countP_append", "code": "@[simp] theorem countP_append (l\u2081 l\u2082) : countP p (l\u2081 ++ l\u2082) = countP p l\u2081 + countP p l\u2082", "start": [72, 1], "end": [73, 68], "kind": "commanddeclaration"}, {"full_name": "List.countP_pos", "code": "theorem countP_pos : 0 < countP p l \u2194 \u2203 a \u2208 l, p a", "start": [75, 1], "end": [76, 90], "kind": "commanddeclaration"}, {"full_name": "List.countP_eq_zero", "code": "theorem countP_eq_zero : countP p l = 0 \u2194 \u2200 a \u2208 l, \u00acp a", "start": [78, 1], "end": [79, 69], "kind": "commanddeclaration"}, {"full_name": "List.countP_eq_length", "code": "theorem countP_eq_length : countP p l = l.length \u2194 \u2200 a \u2208 l, p a", "start": [81, 1], "end": [82, 56], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.countP_le", "code": "theorem Sublist.countP_le (s : l\u2081 <+ l\u2082) : countP p l\u2081 \u2264 countP p l\u2082", "start": [84, 1], "end": [86, 32], "kind": "commanddeclaration"}, {"full_name": "List.countP_filter", "code": "theorem countP_filter (l : List \u03b1) :\n    countP p (filter q l) = countP (fun a => p a \u2227 q a) l", "start": [88, 1], "end": [90, 53], "kind": "commanddeclaration"}, {"full_name": "List.countP_true", "code": "@[simp] theorem countP_true {l : List \u03b1} : (l.countP fun _ => true) = l.length", "start": [92, 1], "end": [94, 7], "kind": "commanddeclaration"}, {"full_name": "List.countP_false", "code": "@[simp] theorem countP_false {l : List \u03b1} : (l.countP fun _ => false) = 0", "start": [96, 1], "end": [98, 7], "kind": "commanddeclaration"}, {"full_name": "List.countP_map", "code": "@[simp] theorem countP_map (p : \u03b2 \u2192 Bool) (f : \u03b1 \u2192 \u03b2) :\n    \u2200 l, countP p (map f l) = countP (p \u2218 f) l", "start": [100, 1], "end": [103, 80], "kind": "commanddeclaration"}, {"full_name": "List.countP_mono_left", "code": "theorem countP_mono_left (h : \u2200 x \u2208 l, p x \u2192 q x) : countP p l \u2264 countP q l", "start": [107, 1], "end": [120, 19], "kind": "commanddeclaration"}, {"full_name": "List.countP_congr", "code": "theorem countP_congr (h : \u2200 x \u2208 l, p x \u2194 q x) : countP p l = countP q l", "start": [122, 1], "end": [125, 46], "kind": "commanddeclaration"}, {"full_name": "List.count_nil", "code": "@[simp] theorem count_nil (a : \u03b1) : count a [] = 0", "start": [135, 1], "end": [135, 58], "kind": "commanddeclaration"}, {"full_name": "List.count_cons", "code": "theorem count_cons (a b : \u03b1) (l : List \u03b1) :\n    count a (b :: l) = count a l + if a = b then 1 else 0", "start": [137, 1], "end": [139, 46], "kind": "commanddeclaration"}, {"full_name": "List.count_cons_self", "code": "@[simp] theorem count_cons_self (a : \u03b1) (l : List \u03b1) : count a (a :: l) = count a l + 1", "start": [141, 1], "end": [142, 20], "kind": "commanddeclaration"}, {"full_name": "List.count_cons_of_ne", "code": "@[simp] theorem count_cons_of_ne (h : a \u2260 b) (l : List \u03b1) : count a (b :: l) = count a l", "start": [144, 1], "end": [145, 23], "kind": "commanddeclaration"}, {"full_name": "List.count_tail", "code": "theorem count_tail : \u2200 (l : List \u03b1) (a : \u03b1) (h : 0 < l.length),\n      l.tail.count a = l.count a - if a = get l \u27e80, h\u27e9 then 1 else 0", "start": [147, 1], "end": [149, 47], "kind": "commanddeclaration"}, {"full_name": "List.count_le_length", "code": "theorem count_le_length (a : \u03b1) (l : List \u03b1) : count a l \u2264 l.length", "start": [151, 1], "end": [151, 90], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.count_le", "code": "theorem Sublist.count_le (h : l\u2081 <+ l\u2082) (a : \u03b1) : count a l\u2081 \u2264 count a l\u2082", "start": [153, 1], "end": [153, 91], "kind": "commanddeclaration"}, {"full_name": "List.count_le_count_cons", "code": "theorem count_le_count_cons (a b : \u03b1) (l : List \u03b1) : count a l \u2264 count a (b :: l)", "start": [155, 1], "end": [156, 32], "kind": "commanddeclaration"}, {"full_name": "List.count_singleton", "code": "theorem count_singleton (a : \u03b1) : count a [a] = 1", "start": [158, 1], "end": [158, 61], "kind": "commanddeclaration"}, {"full_name": "List.count_singleton'", "code": "theorem count_singleton' (a b : \u03b1) : count a [b] = if a = b then 1 else 0", "start": [160, 1], "end": [160, 98], "kind": "commanddeclaration"}, {"full_name": "List.count_append", "code": "@[simp] theorem count_append (a : \u03b1) : \u2200 l\u2081 l\u2082, count a (l\u2081 ++ l\u2082) = count a l\u2081 + count a l\u2082", "start": [162, 1], "end": [163, 18], "kind": "commanddeclaration"}, {"full_name": "List.count_concat", "code": "theorem count_concat (a : \u03b1) (l : List \u03b1) : count a (concat l a) = succ (count a l)", "start": [165, 1], "end": [165, 95], "kind": "commanddeclaration"}, {"full_name": "List.count_pos_iff_mem", "code": "theorem count_pos_iff_mem {a : \u03b1} {l : List \u03b1} : 0 < count a l \u2194 a \u2208 l", "start": [167, 1], "end": [168, 61], "kind": "commanddeclaration"}, {"full_name": "List.count_eq_zero_of_not_mem", "code": "@[simp 900] theorem count_eq_zero_of_not_mem {a : \u03b1} {l : List \u03b1} (h : a \u2209 l) : count a l = 0", "start": [170, 1], "end": [171, 87], "kind": "commanddeclaration"}, {"full_name": "List.not_mem_of_count_eq_zero", "code": "theorem not_mem_of_count_eq_zero {a : \u03b1} {l : List \u03b1} (h : count a l = 0) : a \u2209 l", "start": [173, 1], "end": [174, 57], "kind": "commanddeclaration"}, {"full_name": "List.count_eq_zero", "code": "theorem count_eq_zero {l : List \u03b1} : count a l = 0 \u2194 a \u2209 l", "start": [176, 1], "end": [177, 55], "kind": "commanddeclaration"}, {"full_name": "List.count_eq_length", "code": "theorem count_eq_length {l : List \u03b1} : count a l = l.length \u2194 \u2200 b \u2208 l, a = b", "start": [179, 1], "end": [183, 34], "kind": "commanddeclaration"}, {"full_name": "List.count_replicate_self", "code": "@[simp] theorem count_replicate_self (a : \u03b1) (n : Nat) : count a (replicate n a) = n", "start": [185, 1], "end": [186, 93], "kind": "commanddeclaration"}, {"full_name": "List.count_replicate", "code": "theorem count_replicate (a b : \u03b1) (n : Nat) : count a (replicate n b) = if a = b then n else 0", "start": [188, 1], "end": [190, 96], "kind": "commanddeclaration"}, {"full_name": "List.filter_beq'", "code": "theorem filter_beq' (l : List \u03b1) (a : \u03b1) : l.filter (\u00b7 == a) = replicate (count a l) a", "start": [192, 1], "end": [194, 34], "kind": "commanddeclaration"}, {"full_name": "List.filter_eq'", "code": "theorem filter_eq' (l : List \u03b1) (a : \u03b1) : l.filter (\u00b7 = a) = replicate (count a l) a", "start": [196, 1], "end": [197, 18], "kind": "commanddeclaration"}, {"full_name": "List.filter_eq", "code": "theorem filter_eq (l : List \u03b1) (a : \u03b1) : l.filter (a = \u00b7) = replicate (count a l) a", "start": [199, 1], "end": [200, 44], "kind": "commanddeclaration"}, {"full_name": "List.filter_beq", "code": "theorem filter_beq (l : List \u03b1) (a : \u03b1) : l.filter (a == \u00b7) = replicate (count a l) a", "start": [202, 1], "end": [203, 16], "kind": "commanddeclaration"}, {"full_name": "List.le_count_iff_replicate_sublist", "code": "theorem le_count_iff_replicate_sublist {l : List \u03b1} : n \u2264 count a l \u2194 replicate n a <+ l", "start": [205, 1], "end": [208, 57], "kind": "commanddeclaration"}, {"full_name": "List.replicate_count_eq_of_count_eq_length", "code": "theorem replicate_count_eq_of_count_eq_length {l : List \u03b1} (h : count a l = length l) :\n    replicate (count a l) a = l", "start": [210, 1], "end": [213, 45], "kind": "commanddeclaration"}, {"full_name": "List.count_filter", "code": "@[simp] theorem count_filter {l : List \u03b1} (h : p a) : count a (filter p l) = count a l", "start": [215, 1], "end": [218, 28], "kind": "commanddeclaration"}, {"full_name": "List.count_le_count_map", "code": "theorem count_le_count_map [DecidableEq \u03b2] (l : List \u03b1) (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :\n    count x l \u2264 count (f x) (map f l)", "start": [220, 1], "end": [223, 66], "kind": "commanddeclaration"}, {"full_name": "List.count_erase", "code": "theorem count_erase (a b : \u03b1) :\n    \u2200 l : List \u03b1, count a (l.erase b) = count a l - if a = b then 1 else 0", "start": [225, 1], "end": [238, 51], "kind": "commanddeclaration"}, {"full_name": "List.count_erase_self", "code": "@[simp] theorem count_erase_self (a : \u03b1) (l : List \u03b1) :\n    count a (List.erase l a) = count a l - 1", "start": [240, 1], "end": [241, 80], "kind": "commanddeclaration"}, {"full_name": "List.count_erase_of_ne", "code": "@[simp] theorem count_erase_of_ne (ab : a \u2260 b) (l : List \u03b1) : count a (l.erase b) = count a l", "start": [243, 1], "end": [244, 44], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/LabelAttr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean", "lake-packages/lean4/src/lean/Lean/DocString.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.LabelAttr.LabelExtension", "code": "abbrev LabelExtension := SimpleScopedEnvExtension Name (Array Name)", "start": [31, 1], "end": [32, 68], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.LabelAttr.LabelExtensionMap", "code": "abbrev LabelExtensionMap := HashMap Name LabelExtension", "start": [34, 1], "end": [35, 56], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.LabelAttr.mkLabelExt", "code": "def mkLabelExt (name : Name := by exact decl_name%) : IO LabelExtension :=\n  registerSimpleScopedEnvExtension {\n    name     := name\n    initial  := #[]\n    addEntry := fun d e => if d.contains e then d else d.push e\n  }", "start": [40, 1], "end": [46, 4], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.LabelAttr.mkLabelAttr", "code": "def mkLabelAttr (attrName : Name) (attrDescr : String) (ext : LabelExtension)\n  (ref : Name := by exact decl_name%) : IO Unit :=\nregisterBuiltinAttribute {\n  ref   := ref\n  name  := attrName\n  descr := attrDescr\n  applicationTime := AttributeApplicationTime.afterCompilation\n  add   := fun declName _ _ =>\n    ext.add declName\n  erase := fun declName => do\n    let s := ext.getState (\u2190 getEnv)\n    modifyEnv fun env => ext.modifyState env fun _ => s.erase declName\n}", "start": [48, 1], "end": [61, 2], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.LabelAttr.registerLabelAttr", "code": "def registerLabelAttr (attrName : Name) (attrDescr : String)\n    (ref : Name := by exact decl_name%) : IO LabelExtension := do\n  let ext \u2190 mkLabelExt ref\n  mkLabelAttr attrName attrDescr ext ref\n  labelExtensionMapRef.modify fun map => map.insert attrName ext\n  return ext", "start": [63, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.LabelAttr.labelled", "code": "def labelled (attrName : Name) : CoreM (Array Name) := do\n  match (\u2190 labelExtensionMapRef.get).find? attrName with\n  | none => throwError \"No extension named {attrName}\"\n  | some ext => pure <| ext.getState (\u2190 getEnv)", "start": [90, 1], "end": [95, 48], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/RBMap/Alter.lean", "imports": ["lake-packages/std/Std/Data/RBMap/WF.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.RBNode.OnRoot", "code": "def OnRoot (p : \u03b1 \u2192 Prop) : RBNode \u03b1 \u2192 Prop\n  | nil => True\n  | node _ _ x _ => p x", "start": [24, 1], "end": [27, 24], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.setRoot", "code": "def setRoot (v : \u03b1) : RBNode \u03b1 \u2192 RBNode \u03b1\n  | nil => node red nil v nil\n  | node c a _ b => node c a v b", "start": [29, 1], "end": [34, 33], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.delRoot", "code": "def delRoot : RBNode \u03b1 \u2192 RBNode \u03b1\n  | nil => nil\n  | node _ a _ b => a.append b", "start": [36, 1], "end": [41, 31], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.fill'", "code": "@[inline] def fill' : RBNode \u03b1 \u00d7 Path \u03b1 \u2192 RBNode \u03b1 := fun (t, path) => path.fill t", "start": [45, 1], "end": [46, 83], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.zoom_fill'", "code": "theorem zoom_fill' (cut : \u03b1 \u2192 Ordering) (t : RBNode \u03b1) (path : Path \u03b1) :\n    fill' (zoom cut t path) = path.fill t", "start": [48, 1], "end": [52, 79], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.zoom_fill", "code": "theorem zoom_fill (H : zoom cut t path = (t', path')) : path.fill t = path'.fill t'", "start": [54, 1], "end": [55, 35], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.zoom_ins", "code": "theorem zoom_ins {t : RBNode \u03b1} {cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering} :\n    t.zoom (cmp v) path = (t', path') \u2192\n    path.ins (t.ins cmp v) = path'.ins (t'.setRoot v)", "start": [57, 1], "end": [66, 25], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.insertNew_eq_insert", "code": "theorem insertNew_eq_insert (h : zoom (cmp v) t = (nil, path)) :\n    path.insertNew v = (t.insert cmp v).setBlack", "start": [68, 1], "end": [70, 41], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.zoom_del", "code": "theorem zoom_del {t : RBNode \u03b1} :\n    t.zoom cut path = (t', path') \u2192\n    path.del (t.del cut) (match t with | node c .. => c | _ => red) =\n    path'.del t'.delRoot (match t' with | node c .. => c | _ => red)", "start": [72, 1], "end": [88, 25], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Balanced", "code": "protected inductive Balanced : Path \u03b1 \u2192 RBColor \u2192 Nat \u2192 Prop where\n  \n  | protected root : Path.root.Balanced c\u2080 n\u2080\n  \n  | redL : Balanced y black n \u2192 parent.Balanced red n \u2192\n    (Path.left red parent v y).Balanced black n\n  \n  | redR : Balanced x black n \u2192 parent.Balanced red n \u2192\n    (Path.right red x v parent).Balanced black n\n  \n  | blackL : Balanced y c\u2082 n \u2192 parent.Balanced black (n + 1) \u2192\n    (Path.left black parent v y).Balanced c\u2081 n\n  \n  | blackR : Balanced x c\u2081 n \u2192 parent.Balanced black (n + 1) \u2192\n    (Path.right black x v parent).Balanced c\u2082 n", "start": [91, 1], "end": [111, 48], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Balanced.fill", "code": "protected theorem Balanced.fill {path : Path \u03b1} {t} :\n    path.Balanced c\u2080 n\u2080 c n \u2192 t.Balanced c n \u2192 (path.fill t).Balanced c\u2080 n\u2080", "start": [113, 1], "end": [121, 65], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.zoom", "code": "protected theorem _root_.Std.RBNode.Balanced.zoom : t.Balanced c n \u2192 path.Balanced c\u2080 n\u2080 c n \u2192\n    zoom cut t path = (t', path') \u2192 \u2203 c n, t'.Balanced c n \u2227 path'.Balanced c\u2080 n\u2080 c n", "start": [123, 1], "end": [135, 55], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.ins_eq_fill", "code": "theorem ins_eq_fill {path : Path \u03b1} {t : RBNode \u03b1} :\n    path.Balanced c\u2080 n\u2080 c n \u2192 t.Balanced c n \u2192 path.ins t = (path.fill t).setBlack", "start": [137, 1], "end": [142, 90], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Balanced.ins", "code": "protected theorem Balanced.ins {path : Path \u03b1}\n    (hp : path.Balanced c\u2080 n\u2080 c n) (ht : t.RedRed (c = red) n) :\n    \u2203 n, (path.ins t).Balanced black n", "start": [144, 1], "end": [158, 77], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Balanced.insertNew", "code": "protected theorem Balanced.insertNew {path : Path \u03b1} (H : path.Balanced c n black 0) :\n    \u2203 n, (path.insertNew v).Balanced black n", "start": [160, 1], "end": [161, 83], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Balanced.insert", "code": "protected theorem Balanced.insert {path : Path \u03b1} (hp : path.Balanced c\u2080 n\u2080 c n) :\n    t.Balanced c n \u2192 \u2203 c n, (path.insert t v).Balanced c n", "start": [163, 1], "end": [167, 51], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.zoom_insert", "code": "theorem zoom_insert {path : Path \u03b1} {t : RBNode \u03b1} (ht : t.Balanced c n)\n    (H : zoom (cmp v) t = (t', path)) :\n    (path.insert t' v).setBlack = (t.insert cmp v).setBlack", "start": [169, 1], "end": [176, 99], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Balanced.del", "code": "protected theorem Balanced.del {path : Path \u03b1}\n    (hp : path.Balanced c\u2080 n\u2080 c n) (ht : t.DelProp c' n) (hc : c = black \u2192 c' \u2260 red) :\n    \u2203 n, (path.del t c').Balanced black n", "start": [178, 1], "end": [195, 91], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.AllL", "code": "def AllL (p : \u03b1 \u2192 Prop) : Path \u03b1 \u2192 Prop\n  | .root => True\n  | .left _ parent _ _ => parent.AllL p\n  | .right _ a x parent => a.All p \u2227 p x \u2227 parent.AllL p", "start": [197, 1], "end": [201, 57], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.AllR", "code": "def AllR (p : \u03b1 \u2192 Prop) : Path \u03b1 \u2192 Prop\n  | .root => True\n  | .left _ parent x b => parent.AllR p \u2227 p x \u2227 b.All p\n  | .right _ _ _ parent => parent.AllR p", "start": [203, 1], "end": [207, 41], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Zoomed", "code": "def Zoomed (cut : \u03b1 \u2192 Ordering) : Path \u03b1 \u2192 Prop\n  | .root => True\n  | .left _ parent x _ => cut x = .lt \u2227 parent.Zoomed cut\n  | .right _ _ x parent => cut x = .gt \u2227 parent.Zoomed cut", "start": [209, 1], "end": [216, 59], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.zoom_zoomed\u2081", "code": "theorem zoom_zoomed\u2081 (e : zoom cut t path = (t', path')) : t'.OnRoot (cut \u00b7 = .eq)", "start": [218, 1], "end": [225, 42], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.zoom_zoomed\u2082", "code": "theorem zoom_zoomed\u2082 (e : zoom cut t path = (t', path'))\n    (hp : path.Zoomed cut) : path'.Zoomed cut", "start": [227, 1], "end": [235, 33], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.RootOrdered", "code": "def RootOrdered (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : Path \u03b1 \u2192 \u03b1 \u2192 Prop\n  | .root, _ => True\n  | .left _ parent x _, v => cmpLT cmp v x \u2227 parent.RootOrdered cmp v\n  | .right _ _ x parent, v => cmpLT cmp x v \u2227 parent.RootOrdered cmp v", "start": [237, 1], "end": [244, 71], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.cmpEq.RootOrdered_congr", "code": "theorem _root_.Std.RBNode.cmpEq.RootOrdered_congr {cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering} (h : cmpEq cmp a b) :\n    \u2200 {t : Path \u03b1}, t.RootOrdered cmp a \u2194 t.RootOrdered cmp b", "start": [246, 1], "end": [250, 64], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Zoomed.toRootOrdered", "code": "theorem Zoomed.toRootOrdered {cmp} :\n    \u2200 {path : Path \u03b1}, path.Zoomed (cmp v) \u2192 path.RootOrdered cmp v", "start": [252, 1], "end": [256, 74], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Ordered", "code": "def Ordered (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : Path \u03b1 \u2192 Prop\n  | .root => True\n  | .left _ parent x b => parent.Ordered cmp \u2227\n    b.All (cmpLT cmp x \u00b7) \u2227 parent.RootOrdered cmp x \u2227\n    b.All (parent.RootOrdered cmp) \u2227 b.Ordered cmp\n  | .right _ a x parent => parent.Ordered cmp \u2227\n    a.All (cmpLT cmp \u00b7 x) \u2227 parent.RootOrdered cmp x \u2227\n    a.All (parent.RootOrdered cmp) \u2227 a.Ordered cmp", "start": [258, 1], "end": [266, 51], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Ordered.fill", "code": "protected theorem Ordered.fill : \u2200 {path : Path \u03b1} {t},\n    (path.fill t).Ordered cmp \u2194 path.Ordered cmp \u2227 t.Ordered cmp \u2227 t.All (path.RootOrdered cmp)", "start": [268, 1], "end": [280, 88], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.zoom'", "code": "theorem _root_.Std.RBNode.Ordered.zoom' {t : RBNode \u03b1} {path : Path \u03b1}\n    (ht : t.Ordered cmp) (hp : path.Ordered cmp) (tp : t.All (path.RootOrdered cmp))\n    (pz : path.Zoomed cut) (eq : t.zoom cut path = (t', path')) :\n    t'.Ordered cmp \u2227 path'.Ordered cmp \u2227 t'.All (path'.RootOrdered cmp) \u2227 path'.Zoomed cut", "start": [282, 1], "end": [287, 38], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.zoom", "code": "theorem _root_.Std.RBNode.Ordered.zoom {t : RBNode \u03b1}\n    (ht : t.Ordered cmp) (eq : t.zoom cut = (t', path')) :\n    t'.Ordered cmp \u2227 path'.Ordered cmp \u2227 t'.All (path'.RootOrdered cmp) \u2227 path'.Zoomed cut", "start": [289, 1], "end": [292, 50], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Ordered.ins", "code": "theorem Ordered.ins : \u2200 {path : Path \u03b1} {t : RBNode \u03b1},\n    t.Ordered cmp \u2192 path.Ordered cmp \u2192 t.All (path.RootOrdered cmp) \u2192 (path.ins t).Ordered cmp", "start": [294, 1], "end": [306, 70], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Ordered.insertNew", "code": "theorem Ordered.insertNew {path : Path \u03b1} (hp : path.Ordered cmp) (vp : path.RootOrdered cmp v) :\n    (path.insertNew v).Ordered cmp", "start": [308, 1], "end": [310, 39], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Ordered.insert", "code": "theorem Ordered.insert : \u2200 {path : Path \u03b1} {t : RBNode \u03b1},\n    path.Ordered cmp \u2192 t.Ordered cmp \u2192 t.All (path.RootOrdered cmp) \u2192 path.RootOrdered cmp v \u2192\n    t.OnRoot (cmpEq cmp v) \u2192 (path.insert t v).Ordered cmp", "start": [312, 1], "end": [317, 86], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Ordered.del", "code": "theorem Ordered.del : \u2200 {path : Path \u03b1} {t : RBNode \u03b1} {c},\n    t.Ordered cmp \u2192 path.Ordered cmp \u2192 t.All (path.RootOrdered cmp) \u2192 (path.del t c).Ordered cmp", "start": [319, 1], "end": [331, 60], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.Ordered.erase", "code": "theorem Ordered.erase : \u2200 {path : Path \u03b1} {t : RBNode \u03b1},\n    path.Ordered cmp \u2192 t.Ordered cmp \u2192 t.All (path.RootOrdered cmp) \u2192 (path.erase t).Ordered cmp", "start": [333, 1], "end": [336, 96], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.alter", "code": "protected theorem Ordered.alter {t : RBNode \u03b1}\n    (H : \u2200 {x t' p}, t.zoom cut = (t', p) \u2192 f t'.root? = some x \u2192\n      p.RootOrdered cmp x \u2227 t'.OnRoot (cmpEq cmp x))\n    (h : t.Ordered cmp) : (alter cut f t).Ordered cmp", "start": [342, 1], "end": [358, 94], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.alter", "code": "protected theorem Balanced.alter {t : RBNode \u03b1}\n    (h : t.Balanced c n) : \u2203 c n, (t.alter cut f).Balanced c n", "start": [360, 1], "end": [377, 61], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.modify_eq_alter", "code": "theorem modify_eq_alter (t : RBNode \u03b1) : t.modify cut f = t.alter cut (.map f)", "start": [379, 1], "end": [380, 52], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.modify", "code": "protected theorem Ordered.modify {t : RBNode \u03b1}\n    (H : (t.zoom cut).1.OnRoot fun x => cmpEq cmp (f x) x)\n    (h : t.Ordered cmp) : (modify cut f t).Ordered cmp", "start": [382, 1], "end": [388, 73], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.modify", "code": "protected theorem Balanced.modify {t : RBNode \u03b1}\n    (h : t.Balanced c n) : \u2203 c n, (t.modify cut f).Balanced c n", "start": [390, 1], "end": [392, 95], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.WF.alter", "code": "theorem WF.alter {t : RBNode \u03b1}\n    (H : \u2200 {x t' p}, t.zoom cut = (t', p) \u2192 f t'.root? = some x \u2192\n      p.RootOrdered cmp x \u2227 t'.OnRoot (cmpEq cmp x))\n    (h : WF cmp t) : WF cmp (alter cut f t)", "start": [394, 1], "end": [398, 63], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.WF.modify", "code": "theorem WF.modify {t : RBNode \u03b1}\n    (H : (t.zoom cut).1.OnRoot fun x => cmpEq cmp (f x) x)\n    (h : WF cmp t) : WF cmp (t.modify cut f)", "start": [400, 1], "end": [403, 65], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.find?_eq_zoom", "code": "theorem find?_eq_zoom : \u2200 {t : RBNode \u03b1} (p := .root), t.find? cut = (t.zoom cut p).1.root?", "start": [405, 1], "end": [407, 99], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.ModifyWF.of_eq", "code": "theorem ModifyWF.of_eq {t : RBSet \u03b1 cmp}\n    (H : \u2200 {x}, RBNode.find? cut t.val = some x \u2192 cmpEq cmp (f x) x) : ModifyWF t cut f", "start": [414, 1], "end": [421, 64], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.modify", "code": "def modify (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) (f : \u03b2 \u2192 \u03b2) : RBMap \u03b1 \u03b2 cmp :=\n  @RBSet.modifyP _ _ t (cmp k \u00b7.1) (fun (a, b) => (a, f b))\n    (.of_eq fun _ => \u27e8OrientedCmp.cmp_refl (cmp := byKey Prod.fst cmp)\u27e9)", "start": [427, 1], "end": [434, 73], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.alter.adapt", "code": "def alter.adapt (k : \u03b1) (f : Option \u03b2 \u2192 Option \u03b2) : Option (\u03b1 \u00d7 \u03b2) \u2192 Option (\u03b1 \u00d7 \u03b2)\n  | none =>\n    match f none with\n    | none => none\n    | some v => some (k, v)\n  | some (k', v') =>\n    match f (some v') with\n    | none => none\n    | some v => some (k', v)", "start": [436, 1], "end": [445, 29], "kind": "commanddeclaration"}, {"full_name": "Std.RBMap.alter", "code": "@[specialize] def alter\n    (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) (f : Option \u03b2 \u2192 Option \u03b2) : RBMap \u03b1 \u03b2 cmp := by\n  refine @RBSet.alterP _ _ t (cmp k \u00b7.1) (alter.adapt k f) \u27e8.alter (@fun _ t' p eq => ?_) t.2\u27e9\n  cases t' <;> simp [alter.adapt, RBNode.root?] <;> split <;> intro h <;> cases h\n  \u00b7 exact \u27e8(t.2.out.1.zoom eq).2.2.2.toRootOrdered, \u27e8\u27e9\u27e9\n  \u00b7 refine \u27e8(?a).RootOrdered_congr.2 (t.2.out.1.zoom eq).2.2.1.1, ?a\u27e9\n    exact \u27e8OrientedCmp.cmp_refl (cmp := byKey Prod.fst cmp)\u27e9", "start": [447, 1], "end": [464, 61], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Rat/Lemmas.lean", "imports": ["lake-packages/std/Std/Data/Rat/Basic.lean", "lake-packages/std/Std/Data/Int/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.zero_num", "code": "@[simp] theorem zero_num : (0 : Rat).num = 0", "start": [8, 1], "end": [8, 52], "kind": "commanddeclaration"}, {"full_name": "Rat.zero_den", "code": "@[simp] theorem zero_den : (0 : Rat).den = 1", "start": [9, 1], "end": [9, 52], "kind": "commanddeclaration"}, {"full_name": "Rat.one_num", "code": "@[simp] theorem one_num : (1 : Rat).num = 1", "start": [10, 1], "end": [10, 51], "kind": "commanddeclaration"}, {"full_name": "Rat.one_den", "code": "@[simp] theorem one_den : (1 : Rat).den = 1", "start": [11, 1], "end": [11, 51], "kind": "commanddeclaration"}, {"full_name": "Rat.maybeNormalize_eq", "code": "@[simp] theorem maybeNormalize_eq {num den g} (den_nz reduced) :\n    maybeNormalize num den g den_nz reduced =\n    { num := num.div g, den := den / g, den_nz, reduced }", "start": [13, 1], "end": [18, 8], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize.reduced'", "code": "theorem normalize.reduced' {num : Int} {den g : Nat} (den_nz : den \u2260 0)\n    (e : g = num.natAbs.gcd den) : (num / g).natAbs.Coprime (den / g)", "start": [20, 1], "end": [23, 35], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_eq", "code": "theorem normalize_eq {num den} (den_nz) : normalize num den den_nz =\n    { num := num / num.natAbs.gcd den\n      den := den / num.natAbs.gcd den\n      den_nz := normalize.den_nz den_nz rfl\n      reduced := normalize.reduced' den_nz rfl }", "start": [25, 1], "end": [31, 73], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_zero", "code": "@[simp] theorem normalize_zero (nz) : normalize 0 d nz = 0", "start": [33, 1], "end": [34, 93], "kind": "commanddeclaration"}, {"full_name": "Rat.mk_eq_normalize", "code": "theorem mk_eq_normalize (num den nz c) : \u27e8num, den, nz, c\u27e9 = normalize num den nz", "start": [36, 1], "end": [37, 36], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_self", "code": "theorem normalize_self (r : Rat) : normalize r.num r.den r.den_nz = r", "start": [39, 1], "end": [39, 99], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_mul_left", "code": "theorem normalize_mul_left {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (\u2191a * n) (a * d) (Nat.mul_ne_zero a0 d0) = normalize n d d0", "start": [41, 1], "end": [45, 76], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_mul_right", "code": "theorem normalize_mul_right {a : Nat} (d0 : d \u2260 0) (a0 : a \u2260 0) :\n    normalize (n * a) (d * a) (Nat.mul_ne_zero d0 a0) = normalize n d d0", "start": [47, 1], "end": [49, 96], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_eq_iff", "code": "theorem normalize_eq_iff (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    normalize n\u2081 d\u2081 z\u2081 = normalize n\u2082 d\u2082 z\u2082 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081", "start": [51, 1], "end": [63, 84], "kind": "commanddeclaration"}, {"full_name": "Rat.maybeNormalize_eq_normalize", "code": "theorem maybeNormalize_eq_normalize {num : Int} {den g : Nat} (den_nz reduced)\n    (hn : \u2191g \u2223 num) (hd : g \u2223 den) :\n    maybeNormalize num den g den_nz reduced = normalize num den (mt (by simp [\u00b7]) den_nz)", "start": [65, 1], "end": [71, 39], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_eq_zero", "code": "@[simp] theorem normalize_eq_zero (d0 : d \u2260 0) : normalize n d d0 = 0 \u2194 n = 0", "start": [73, 1], "end": [75, 56], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_num_den'", "code": "theorem normalize_num_den' (num den nz) : \u2203 d : Nat, d \u2260 0 \u2227\n    num = (normalize num den nz).num * d \u2227 den = (normalize num den nz).den * d", "start": [77, 1], "end": [81, 47], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_num_den", "code": "theorem normalize_num_den (h : normalize n d z = \u27e8n', d', z', c\u27e9) :\n    \u2203 m : Nat, m \u2260 0 \u2227 n = n' * m \u2227 d = d' * m", "start": [83, 1], "end": [85, 52], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_eq_mkRat", "code": "theorem normalize_eq_mkRat {num den} (den_nz) : normalize num den den_nz = mkRat num den", "start": [87, 1], "end": [88, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_num_den", "code": "theorem mkRat_num_den (z : d \u2260 0) (h : mkRat n d = \u27e8n', d', z', c\u27e9) :\n    \u2203 m : Nat, m \u2260 0 \u2227 n = n' * m \u2227 d = d' * m", "start": [90, 1], "end": [92, 54], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_def", "code": "theorem mkRat_def (n d) : mkRat n d = if d0 : d = 0 then 0 else normalize n d d0", "start": [94, 1], "end": [94, 88], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_self", "code": "theorem mkRat_self (a : Rat) : mkRat a.num a.den = a", "start": [96, 1], "end": [97, 53], "kind": "commanddeclaration"}, {"full_name": "Rat.mk_eq_mkRat", "code": "theorem mk_eq_mkRat (num den nz c) : \u27e8num, den, nz, c\u27e9 = mkRat num den", "start": [99, 1], "end": [100, 45], "kind": "commanddeclaration"}, {"full_name": "Rat.zero_mkRat", "code": "@[simp] theorem zero_mkRat (n) : mkRat 0 n = 0", "start": [102, 1], "end": [102, 86], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_zero", "code": "@[simp] theorem mkRat_zero (n) : mkRat n 0 = 0", "start": [104, 1], "end": [104, 70], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_eq_zero", "code": "theorem mkRat_eq_zero (d0 : d \u2260 0) : mkRat n d = 0 \u2194 n = 0", "start": [106, 1], "end": [106, 86], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_ne_zero", "code": "theorem mkRat_ne_zero (d0 : d \u2260 0) : mkRat n d \u2260 0 \u2194 n \u2260 0", "start": [108, 1], "end": [108, 91], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_mul_left", "code": "theorem mkRat_mul_left {a : Nat} (a0 : a \u2260 0) : mkRat (\u2191a * n) (a * d) = mkRat n d", "start": [110, 1], "end": [112, 79], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_mul_right", "code": "theorem mkRat_mul_right {a : Nat} (a0 : a \u2260 0) : mkRat (n * a) (d * a) = mkRat n d", "start": [114, 1], "end": [115, 90], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_eq_iff", "code": "theorem mkRat_eq_iff (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    mkRat n\u2081 d\u2081 = mkRat n\u2082 d\u2082 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081", "start": [117, 1], "end": [119, 74], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_ofNat", "code": "@[simp] theorem divInt_ofNat (num den) : num /. (den : Nat) = mkRat num den", "start": [121, 1], "end": [122, 36], "kind": "commanddeclaration"}, {"full_name": "Rat.mk_eq_divInt", "code": "theorem mk_eq_divInt (num den nz c) : \u27e8num, den, nz, c\u27e9 = num /. (den : Nat)", "start": [124, 1], "end": [125, 21], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_self", "code": "theorem divInt_self (a : Rat) : a.num /. a.den = a", "start": [127, 1], "end": [127, 87], "kind": "commanddeclaration"}, {"full_name": "Rat.zero_divInt", "code": "@[simp] theorem zero_divInt (n) : 0 /. n = 0", "start": [129, 1], "end": [129, 77], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_zero", "code": "@[simp] theorem divInt_zero (n) : n /. 0 = 0", "start": [131, 1], "end": [131, 61], "kind": "commanddeclaration"}, {"full_name": "Rat.neg_divInt_neg", "code": "theorem neg_divInt_neg (num den) : -num /. -den = num /. den", "start": [133, 1], "end": [137, 85], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_neg'", "code": "theorem divInt_neg' (num den) : num /. -den = -num /. den", "start": [139, 1], "end": [139, 99], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_eq_iff", "code": "theorem divInt_eq_iff (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    n\u2081 /. d\u2081 = n\u2082 /. d\u2082 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081", "start": [141, 1], "end": [146, 70], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_mul_left", "code": "theorem divInt_mul_left {a : Int} (a0 : a \u2260 0) : (a * n) /. (a * d) = n /. d", "start": [148, 1], "end": [150, 84], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_mul_right", "code": "theorem divInt_mul_right {a : Int} (a0 : a \u2260 0) : (n * a) /. (d * a) = n /. d", "start": [152, 1], "end": [153, 53], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_num_den", "code": "theorem divInt_num_den (z : d \u2260 0) (h : n /. d = \u27e8n', d', z', c\u27e9) :\n    \u2203 m, m \u2260 0 \u2227 n = n' * m \u2227 d = d' * m", "start": [155, 1], "end": [163, 82], "kind": "commanddeclaration"}, {"full_name": "Rat.ofInt_ofNat", "code": "@[simp] theorem ofInt_ofNat : ofInt (OfNat.ofNat n) = OfNat.ofNat n", "start": [165, 1], "end": [165, 75], "kind": "commanddeclaration"}, {"full_name": "Rat.ofInt_num", "code": "@[simp] theorem ofInt_num : (ofInt n : Rat).num = n", "start": [167, 1], "end": [167, 59], "kind": "commanddeclaration"}, {"full_name": "Rat.ofInt_den", "code": "@[simp] theorem ofInt_den : (ofInt n : Rat).den = 1", "start": [168, 1], "end": [168, 59], "kind": "commanddeclaration"}, {"full_name": "Rat.ofNat_num", "code": "@[simp] theorem ofNat_num : (OfNat.ofNat n : Rat).num = OfNat.ofNat n", "start": [170, 1], "end": [170, 77], "kind": "commanddeclaration"}, {"full_name": "Rat.ofNat_den", "code": "@[simp] theorem ofNat_den : (OfNat.ofNat n : Rat).den = 1", "start": [171, 1], "end": [171, 65], "kind": "commanddeclaration"}, {"full_name": "Rat.add_def", "code": "theorem add_def (a b : Rat) :\n    a + b = normalize (a.num * b.den + b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)", "start": [173, 1], "end": [186, 72], "kind": "commanddeclaration"}, {"full_name": "Rat.add_def'", "code": "theorem add_def' (a b : Rat) : a + b = mkRat (a.num * b.den + b.num * a.den) (a.den * b.den)", "start": [188, 1], "end": [189, 35], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_add_normalize", "code": "theorem normalize_add_normalize (n\u2081 n\u2082) {d\u2081 d\u2082} (z\u2081 z\u2082) :\n    normalize n\u2081 d\u2081 z\u2081 + normalize n\u2082 d\u2082 z\u2082 =\n    normalize (n\u2081 * d\u2082 + n\u2082 * d\u2081) (d\u2081 * d\u2082) (Nat.mul_ne_zero z\u2081 z\u2082)", "start": [191, 1], "end": [198, 43], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_add_mkRat", "code": "theorem mkRat_add_mkRat (n\u2081 n\u2082 : Int) {d\u2081 d\u2082} (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    mkRat n\u2081 d\u2081 + mkRat n\u2082 d\u2082 = mkRat (n\u2081 * d\u2082 + n\u2082 * d\u2081) (d\u2081 * d\u2082)", "start": [200, 1], "end": [202, 101], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_add_divInt", "code": "theorem divInt_add_divInt (n\u2081 n\u2082 : Int) {d\u2081 d\u2082} (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    n\u2081 /. d\u2081 + n\u2082 /. d\u2082 = (n\u2081 * d\u2082 + n\u2082 * d\u2081) /. (d\u2081 * d\u2082)", "start": [204, 1], "end": [209, 68], "kind": "commanddeclaration"}, {"full_name": "Rat.neg_num", "code": "@[simp] theorem neg_num (a : Rat) : (-a).num = -a.num", "start": [211, 1], "end": [211, 61], "kind": "commanddeclaration"}, {"full_name": "Rat.neg_den", "code": "@[simp] theorem neg_den (a : Rat) : (-a).den = a.den", "start": [212, 1], "end": [212, 60], "kind": "commanddeclaration"}, {"full_name": "Rat.neg_normalize", "code": "theorem neg_normalize (n d z) : -normalize n d z = normalize (-n) d z", "start": [214, 1], "end": [215, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.neg_mkRat", "code": "theorem neg_mkRat (n d) : -mkRat n d = mkRat (-n) d", "start": [217, 1], "end": [218, 79], "kind": "commanddeclaration"}, {"full_name": "Rat.neg_divInt", "code": "theorem neg_divInt (n d) : -(n /. d) = -n /. d", "start": [220, 1], "end": [221, 83], "kind": "commanddeclaration"}, {"full_name": "Rat.sub_def", "code": "theorem sub_def (a b : Rat) :\n    a - b = normalize (a.num * b.den - b.num * a.den) (a.den * b.den)\n      (Nat.mul_ne_zero a.den_nz b.den_nz)", "start": [223, 1], "end": [236, 72], "kind": "commanddeclaration"}, {"full_name": "Rat.sub_def'", "code": "theorem sub_def' (a b : Rat) : a - b = mkRat (a.num * b.den - b.num * a.den) (a.den * b.den)", "start": [238, 1], "end": [239, 35], "kind": "commanddeclaration"}, {"full_name": "Rat.sub_eq_add_neg", "code": "protected theorem sub_eq_add_neg (a b : Rat) : a - b = a + -b", "start": [241, 1], "end": [242, 59], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_sub_divInt", "code": "theorem divInt_sub_divInt (n\u2081 n\u2082 : Int) {d\u2081 d\u2082} (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    n\u2081 /. d\u2081 - n\u2082 /. d\u2082 = (n\u2081 * d\u2082 - n\u2082 * d\u2081) /. (d\u2081 * d\u2082)", "start": [244, 1], "end": [247, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_def", "code": "theorem mul_def (a b : Rat) :\n    a * b = normalize (a.num * b.num) (a.den * b.den) (Nat.mul_ne_zero a.den_nz b.den_nz)", "start": [249, 1], "end": [260, 49], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_comm", "code": "protected theorem mul_comm (a b : Rat) : a * b = b * a", "start": [262, 1], "end": [263, 65], "kind": "commanddeclaration"}, {"full_name": "Rat.zero_mul", "code": "@[simp] protected theorem zero_mul (a : Rat) : 0 * a = 0", "start": [265, 1], "end": [265, 78], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_zero", "code": "@[simp] protected theorem mul_zero (a : Rat) : a * 0 = 0", "start": [266, 1], "end": [266, 78], "kind": "commanddeclaration"}, {"full_name": "Rat.one_mul", "code": "@[simp] protected theorem one_mul (a : Rat) : 1 * a = a", "start": [267, 1], "end": [267, 93], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_one", "code": "@[simp] protected theorem mul_one (a : Rat) : a * 1 = a", "start": [268, 1], "end": [268, 93], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_mul_normalize", "code": "theorem normalize_mul_normalize (n\u2081 n\u2082) {d\u2081 d\u2082} (z\u2081 z\u2082) :\n    normalize n\u2081 d\u2081 z\u2081 * normalize n\u2082 d\u2082 z\u2082 =\n    normalize (n\u2081 * n\u2082) (d\u2081 * d\u2082) (Nat.mul_ne_zero z\u2081 z\u2082)", "start": [270, 1], "end": [277, 43], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_mul_mkRat", "code": "theorem mkRat_mul_mkRat (n\u2081 n\u2082 : Int) (d\u2081 d\u2082) :\n    mkRat n\u2081 d\u2081 * mkRat n\u2082 d\u2082 = mkRat (n\u2081 * n\u2082) (d\u2081 * d\u2082)", "start": [279, 1], "end": [282, 101], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_mul_divInt", "code": "theorem divInt_mul_divInt (n\u2081 n\u2082 : Int) {d\u2081 d\u2082} (z\u2081 : d\u2081 \u2260 0) (z\u2082 : d\u2082 \u2260 0) :\n    (n\u2081 /. d\u2081) * (n\u2082 /. d\u2082) = (n\u2081 * n\u2082) /. (d\u2081 * d\u2082)", "start": [284, 1], "end": [289, 21], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_def", "code": "theorem inv_def (a : Rat) : a.inv = a.den /. a.num", "start": [291, 1], "end": [299, 63], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_zero", "code": "@[simp] protected theorem inv_zero : (0 : Rat).inv = 0", "start": [301, 1], "end": [303, 7], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_divInt", "code": "@[simp] theorem inv_divInt (n d : Int) : (n /. d).inv = d /. n", "start": [305, 1], "end": [308, 38], "kind": "commanddeclaration"}, {"full_name": "Rat.div_def", "code": "theorem div_def (a b : Rat) : a / b = a * b.inv", "start": [310, 1], "end": [310, 55], "kind": "commanddeclaration"}, {"full_name": "Rat.ofScientific_true_def", "code": "theorem ofScientific_true_def : Rat.ofScientific m true e = mkRat m (10 ^ e)", "start": [312, 1], "end": [313, 56], "kind": "commanddeclaration"}, {"full_name": "Rat.ofScientific_false_def", "code": "theorem ofScientific_false_def : Rat.ofScientific m false e = (m * 10 ^ e : Nat)", "start": [315, 1], "end": [316, 31], "kind": "commanddeclaration"}, {"full_name": "Rat.ofScientific_def", "code": "theorem ofScientific_def : Rat.ofScientific m s e =\n    if s then mkRat m (10 ^ e) else (m * 10 ^ e : Nat)", "start": [318, 1], "end": [320, 69], "kind": "commanddeclaration"}, {"full_name": "Rat.intCast_den", "code": "@[simp] theorem intCast_den (a : Int) : (a : Rat).den = 1", "start": [322, 1], "end": [322, 65], "kind": "commanddeclaration"}, {"full_name": "Rat.intCast_num", "code": "@[simp] theorem intCast_num (a : Int) : (a : Rat).num = a", "start": [324, 1], "end": [324, 65], "kind": "commanddeclaration"}, {"full_name": "Rat.intCast_zero", "code": "theorem intCast_zero : ((0 : Int) : Rat) = (0 : Rat)", "start": [331, 1], "end": [331, 60], "kind": "commanddeclaration"}, {"full_name": "Rat.intCast_one", "code": "theorem intCast_one : ((1 : Int) : Rat) = (1 : Rat)", "start": [333, 1], "end": [333, 59], "kind": "commanddeclaration"}, {"full_name": "Rat.intCast_add", "code": "@[simp] theorem intCast_add (a b : Int) : ((a + b : Int) : Rat) = (a : Rat) + (b : Rat)", "start": [335, 1], "end": [337, 30], "kind": "commanddeclaration"}, {"full_name": "Rat.intCast_neg", "code": "@[simp] theorem intCast_neg (a : Int) : ((-a : Int) : Rat) = -(a : Rat)", "start": [339, 1], "end": [340, 30], "kind": "commanddeclaration"}, {"full_name": "Rat.intCast_sub", "code": "@[simp] theorem intCast_sub (a b : Int) : ((a - b : Int) : Rat) = (a : Rat) - (b : Rat)", "start": [342, 1], "end": [344, 30], "kind": "commanddeclaration"}, {"full_name": "Rat.intCast_mul", "code": "@[simp] theorem intCast_mul (a b : Int) : ((a * b : Int) : Rat) = (a : Rat) * (b : Rat)", "start": [346, 1], "end": [348, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/BinomialHeap/Lemmas.lean", "imports": ["lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.BinomialHeap.Imp.Heap.findMin_val", "code": "theorem Heap.findMin_val : ((s : Heap \u03b1).findMin le k res).val = s.headD le res.val", "start": [11, 1], "end": [14, 73], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.deleteMin_fst", "code": "theorem Heap.deleteMin_fst : ((s : Heap \u03b1).deleteMin le).map (\u00b7.1) = s.head? le", "start": [16, 1], "end": [19, 78], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.HeapNode.WF.realSize_eq", "code": "@[simp] theorem HeapNode.WF.realSize_eq :\n    \u2200 {n} {s : HeapNode \u03b1}, s.WF le a n \u2192 s.realSize + 1 = 2 ^ n", "start": [21, 1], "end": [26, 40], "kind": "commanddeclaration"}, {"full_name": "Std.BinomialHeap.Imp.Heap.WF.size_eq", "code": "@[simp] theorem Heap.WF.size_eq :\n    \u2200 {s : Heap \u03b1}, s.WF le n \u2192 s.size = s.realSize", "start": [28, 1], "end": [33, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Expr/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Lean/Expr.lean", "lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.BinderInfo.brackets", "code": "def brackets : BinderInfo \u2192 String \u00d7 String\n  | BinderInfo.implicit => (\"{\", \"}\")\n  | BinderInfo.strictImplicit => (\"{{\", \"}}\")\n  | BinderInfo.instImplicit => (\"[\", \"]\")\n  | _ => (\"(\", \")\")", "start": [27, 1], "end": [32, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mapPrefix", "code": "def mapPrefix (f : Name \u2192 Option Name) (n : Name) : Name := Id.run do\n  if let some n' := f n then return n'\n  match n with\n  | anonymous => anonymous\n  | str n' s => mkStr (mapPrefix f n') s\n  | num n' i => mkNum (mapPrefix f n') i", "start": [40, 1], "end": [47, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.fromComponents", "code": "def fromComponents : List Name \u2192 Name := go .anonymous where\n  \n  go : Name \u2192 List Name \u2192 Name\n  | n, []        => n\n  | n, s :: rest => go (s.updatePrefix n) rest", "start": [49, 1], "end": [56, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.updateLast", "code": "def updateLast (f : String \u2192 String) : Name \u2192 Name\n  | .str n s => .str n (f s)\n  | n        => n", "start": [58, 1], "end": [61, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.getString", "code": "def getString : Name \u2192 String\n  | .str _ s => s\n  | .num _ n => toString n\n  | .anonymous => \"\"", "start": [63, 1], "end": [68, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.splitAt", "code": "def splitAt (nm : Name) (n : Nat) : Name \u00d7 Name :=\n  let (nm2, nm1) := (nm.componentsRev.splitAt n)\n  (.fromComponents <| nm1.reverse, .fromComponents <| nm2.reverse)", "start": [70, 1], "end": [75, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isPrefixOf?", "code": "def isPrefixOf? (pre nm : Name) : Option Name :=\n  if pre == nm then\n    some anonymous\n  else match nm with\n  | anonymous => none\n  | num p' a => (isPrefixOf? pre p').map (\u00b7.num a)\n  | str p' s => (isPrefixOf? pre p').map (\u00b7.str s)", "start": [77, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isInternal'", "code": "def isInternal' (declName : Name) : Bool :=\n  declName.isInternal ||\n  match declName with\n  | .str _ s => \"match_\".isPrefixOf s || \"proof_\".isPrefixOf s\n  | _        => true", "start": [88, 1], "end": [100, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isBlackListed", "code": "def isBlackListed {m} [Monad m] [MonadEnv m] (declName : Name) : m Bool := do\n  if declName == ``sorryAx then return true\n  if declName matches .str _ \"inj\" then return true\n  if declName matches .str _ \"noConfusionType\" then return true\n  let env \u2190 getEnv\n  pure $ declName.isInternal'\n   || isAuxRecursor env declName\n   || isNoConfusion env declName\n  <||> isRec declName <||> isMatcher declName", "start": [106, 1], "end": [114, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.isDef", "code": "def isDef : ConstantInfo \u2192 Bool\n  | defnInfo _ => true\n  | _          => false", "start": [120, 1], "end": [123, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.isThm", "code": "def isThm : ConstantInfo \u2192 Bool\n  | thmInfo _ => true\n  | _          => false", "start": [125, 1], "end": [128, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.updateConstantVal", "code": "def updateConstantVal : ConstantInfo \u2192 ConstantVal \u2192 ConstantInfo\n  | defnInfo   info, v => defnInfo   {info with toConstantVal := v}\n  | axiomInfo  info, v => axiomInfo  {info with toConstantVal := v}\n  | thmInfo    info, v => thmInfo    {info with toConstantVal := v}\n  | opaqueInfo info, v => opaqueInfo {info with toConstantVal := v}\n  | quotInfo   info, v => quotInfo   {info with toConstantVal := v}\n  | inductInfo info, v => inductInfo {info with toConstantVal := v}\n  | ctorInfo   info, v => ctorInfo   {info with toConstantVal := v}\n  | recInfo    info, v => recInfo    {info with toConstantVal := v}", "start": [130, 1], "end": [140, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.updateName", "code": "def updateName (c : ConstantInfo) (name : Name) : ConstantInfo :=\n  c.updateConstantVal {c.toConstantVal with name}", "start": [142, 1], "end": [144, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.updateType", "code": "def updateType (c : ConstantInfo) (type : Expr) : ConstantInfo :=\n  c.updateConstantVal {c.toConstantVal with type}", "start": [146, 1], "end": [148, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.updateLevelParams", "code": "def updateLevelParams (c : ConstantInfo) (levelParams : List Name) :\n    ConstantInfo :=\n  c.updateConstantVal {c.toConstantVal with levelParams}", "start": [150, 1], "end": [153, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.updateValue", "code": "def updateValue : ConstantInfo \u2192 Expr \u2192 ConstantInfo\n  | defnInfo   info, v => defnInfo   {info with value := v}\n  | thmInfo    info, v => thmInfo    {info with value := v}\n  | opaqueInfo info, v => opaqueInfo {info with value := v}\n  | d, _ => d", "start": [155, 1], "end": [160, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.toDeclaration!", "code": "def toDeclaration! : ConstantInfo \u2192 Declaration\n  | defnInfo   info => Declaration.defnDecl info\n  | thmInfo    info => Declaration.thmDecl     info\n  | axiomInfo  info => Declaration.axiomDecl   info\n  | opaqueInfo info => Declaration.opaqueDecl  info\n  | quotInfo   _ => panic! \"toDeclaration for quotInfo not implemented\"\n  | inductInfo _ => panic! \"toDeclaration for inductInfo not implemented\"\n  | ctorInfo   _ => panic! \"toDeclaration for ctorInfo not implemented\"\n  | recInfo    _ => panic! \"toDeclaration for recInfo not implemented\"", "start": [162, 1], "end": [171, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.mkConst'", "code": "def mkConst' (constName : Name) : MetaM Expr := do\n  return mkConst constName (\u2190 (\u2190 getConstInfo constName).levelParams.mapM fun _ => mkFreshLevelMVar)", "start": [177, 1], "end": [179, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.constName", "code": "def constName (e : Expr) : Name :=\n  e.constName?.getD Name.anonymous", "start": [185, 1], "end": [187, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.bvarIdx?", "code": "def bvarIdx? : Expr \u2192 Option Nat\n  | bvar idx => some idx\n  | _        => none", "start": [189, 1], "end": [191, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppFnArgs", "code": "def getAppFnArgs (e : Expr) : Name \u00d7 Array Expr :=\n  withApp e \u03bb e a => (e.constName, a)", "start": [193, 1], "end": [195, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.natLit!", "code": "def natLit! : Expr \u2192 Nat\n  | lit (Literal.natVal v) => v\n  | _                      => panic! \"nat literal expected\"", "start": [197, 1], "end": [200, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.intLit!", "code": "def intLit! (e : Expr) : Int :=\n  if e.isAppOfArity ``Int.ofNat 1 then\n    e.appArg!.natLit!\n  else if e.isAppOfArity ``Int.negOfNat 1 then\n    .negOfNat e.appArg!.natLit!\n  else\n    panic! \"not a raw integer literal\"", "start": [202, 1], "end": [210, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.nat?", "code": "def nat? (e : Expr) : Option Nat := do\n  guard <| e.isAppOfArity ``OfNat.ofNat 3\n  let lit (.natVal n) := e.appFn!.appArg! | none\n  n", "start": [212, 1], "end": [221, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.int?", "code": "def int? (e : Expr) : Option Int :=\n  if e.isAppOfArity ``Neg.neg 3 then\n    (- \u00b7) <$> e.appArg!.nat?\n  else\n    e.nat?", "start": [224, 1], "end": [233, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.rat?", "code": "def rat? (e : Expr) : Option Rat := do\n  if e.isAppOfArity ``Div.div 4 then\n    let d \u2190 e.appArg!.nat?\n    guard (d \u2260 1)\n    let n \u2190 e.appFn!.appArg!.int?\n    let q := mkRat n d\n    guard (q.den = d)\n    pure q\n  else\n    e.int?", "start": [235, 1], "end": [251, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isExplicitNumber", "code": "def isExplicitNumber : Expr \u2192 Bool\n  | .lit _ => true\n  | .mdata _ e => isExplicitNumber e\n  | e => e.rat?.isSome", "start": [253, 1], "end": [266, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.fvarId?", "code": "def fvarId? : Expr \u2192 Option FVarId\n  | .fvar n => n\n  | _ => none", "start": [268, 1], "end": [271, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isConstantApplication", "code": "def isConstantApplication (e : Expr) :=\n  e.isApp && aux e.getAppNumArgs'.pred e.getAppFn' e.getAppNumArgs'\n  where\n    \n    aux (depth : Nat) : Expr \u2192 Nat \u2192 Bool\n    | .lam _ _ b _, n + 1  => aux depth b n\n    | e, 0  => !e.hasLooseBVar (depth - 1)\n    | _, _ => false", "start": [273, 1], "end": [284, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.letDepth", "code": "def letDepth : Expr \u2192 Nat\n  | .letE _ _ _ b _ => b.letDepth + 1\n  | _ => 0", "start": [286, 1], "end": [289, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ensureHasNoMVars", "code": "def ensureHasNoMVars (e : Expr) : MetaM Unit := do\n  let e \u2190 instantiateMVars e\n  if e.hasExprMVar then\n    throwError \"tactic failed, resulting expression contains metavariables{indentExpr e}\"", "start": [293, 1], "end": [298, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ofNat", "code": "def ofNat (\u03b1 : Expr) (n : Nat) : MetaM Expr := do\n  mkAppOptM ``OfNat.ofNat #[\u03b1, mkRawNatLit n, none]", "start": [300, 1], "end": [303, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ofInt", "code": "def ofInt (\u03b1 : Expr) : Int \u2192 MetaM Expr\n  | Int.ofNat n => Expr.ofNat \u03b1 n\n  | Int.negSucc n => do mkAppM ``Neg.neg #[\u2190 Expr.ofNat \u03b1 (n+1)]", "start": [305, 1], "end": [309, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.numeral?", "code": "partial def numeral? (e : Expr) : Option Nat :=\n  if let some n := e.natLit? then n\n  else\n    let f := e.getAppFn\n    if !f.isConst then none\n    else\n      let fName := f.constName!\n      if fName == ``Nat.succ && e.getAppNumArgs == 1 then (numeral? e.appArg!).map Nat.succ\n      else if fName == ``OfNat.ofNat && e.getAppNumArgs == 3 then numeral? (e.getArg! 1)\n      else if fName == ``Nat.zero && e.getAppNumArgs == 0 then some 0\n      else none", "start": [313, 1], "end": [329, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.zero?", "code": "def zero? (e : Expr) : Bool :=\n  match e.numeral? with\n  | some 0 => true\n  | _ => false", "start": [331, 1], "end": [335, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ne?'", "code": "def ne?' (e : Expr) : Option (Expr \u00d7 Expr \u00d7 Expr) :=\n  e.ne? <|> (e.not? >>= Expr.eq?)", "start": [337, 1], "end": [340, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.le?", "code": "@[inline] def le? (p : Expr) : Option (Expr \u00d7 Expr \u00d7 Expr) := do\n  let (type, _, lhs, rhs) \u2190 p.app4? ``LE.le\n  return (type, lhs, rhs)", "start": [342, 1], "end": [347, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.sides?", "code": "def sides? (ty : Expr) : Option (Expr \u00d7 Expr \u00d7 Expr \u00d7 Expr) :=\n  if let some (lhs, rhs) := ty.iff? then\n    some (.sort .zero, lhs, .sort .zero, rhs)\n  else if let some (ty, lhs, rhs) := ty.eq? then\n    some (ty, lhs, ty, rhs)\n  else\n    ty.heq?", "start": [349, 1], "end": [360, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.modifyAppArgM", "code": "def modifyAppArgM [Functor M] [Pure M] (modifier : Expr \u2192 M Expr) : Expr \u2192 M Expr\n  | app f a => mkApp f <$> modifier a\n  | e => pure e", "start": [364, 1], "end": [366, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.modifyAppArg", "code": "def modifyAppArg (modifier : Expr \u2192 Expr) : Expr \u2192 Expr :=\n  modifyAppArgM (M := Id) modifier", "start": [368, 1], "end": [369, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.modifyRevArg", "code": "def modifyRevArg (modifier : Expr \u2192 Expr) : Nat \u2192 Expr \u2192 Expr\n  | 0 => modifyAppArg modifier\n  | (i+1) => modifyAppArg (modifyRevArg modifier i)", "start": [371, 1], "end": [373, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.modifyArg", "code": "def modifyArg (modifier : Expr \u2192 Expr) (e : Expr) (i : Nat) (n := e.getAppNumArgs) : Expr :=\n  modifyRevArg modifier (n - i - 1) e", "start": [375, 1], "end": [378, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getRevArg?", "code": "def getRevArg? : Expr \u2192 Nat \u2192 Option Expr\n  | app _ a, 0   => a\n  | app f _, i+1 => getRevArg! f i\n  | _,       _   => none", "start": [380, 1], "end": [383, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getArg?", "code": "def getArg? (e : Expr) (i : Nat) (n := e.getAppNumArgs) : Option Expr :=\n  getRevArg? e (n - i - 1)", "start": [385, 1], "end": [387, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.modifyArgM", "code": "def modifyArgM [Monad M] (modifier : Expr \u2192 M Expr) (e : Expr) (i : Nat) (n := e.getAppNumArgs) :\n    M Expr := do\n  let some a := getArg? e i | return e\n  let a \u2190 modifier a\n  return modifyArg (fun _ \u21a6 a) e i n", "start": [389, 1], "end": [395, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.renameBVar", "code": "def renameBVar (e : Expr) (old new : Name) : Expr :=\n  match e with\n  | app fn arg => app (fn.renameBVar old new) (arg.renameBVar old new)\n  | lam n ty bd bi =>\n    lam (if n == old then new else n) (ty.renameBVar old new) (bd.renameBVar old new) bi\n  | forallE n ty bd bi =>\n    forallE (if n == old then new else n) (ty.renameBVar old new) (bd.renameBVar old new) bi\n  | e => e", "start": [397, 1], "end": [405, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getBinderName", "code": "def getBinderName (e : Expr) : MetaM (Option Name) := do\n  match \u2190 withReducible (whnf e) with\n  | .forallE (binderName := n) .. | .lam (binderName := n) .. => pure (some n)\n  | _ => pure none", "start": [408, 1], "end": [413, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.addLocalVarInfoForBinderIdent", "code": "def addLocalVarInfoForBinderIdent (fvar : Expr) (tk : TSyntax ``binderIdent) : MetaM Unit :=\n  discard <| TermElabM.run do\n    match tk with\n    | `(binderIdent| $n:ident) => Elab.Term.addLocalVarInfo n fvar\n    | tk => Elab.Term.addLocalVarInfo (Unhygienic.run `(_%$tk)) fvar", "start": [416, 1], "end": [423, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mkDirectProjection", "code": "def mkDirectProjection (e : Expr) (fieldName : Name) : MetaM Expr := do\n  let type \u2190 whnf (\u2190 inferType e)\n  let .const structName us := type.getAppFn | throwError \"{e} doesn't have a structure as type\"\n  let some projName := getProjFnForField? (\u2190 getEnv) structName fieldName |\n    throwError \"{structName} doesn't have field {fieldName}\"\n  return mkAppN (.const projName us) (type.getAppArgs.push e)", "start": [425, 1], "end": [432, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mkProjection", "code": "def mkProjection (e : Expr) (fieldName : Name) : MetaM Expr := do\n  let .const structName _ := (\u2190 whnf (\u2190inferType e)).getAppFn |\n    throwError \"{e} doesn't have a structure as type\"\n  let some baseStruct := findField? (\u2190 getEnv) structName fieldName |\n    throwError \"No parent of {structName} has field {fieldName}\"\n  let mut e := e\n  for projName in (getPathToBaseStructure? (\u2190 getEnv) baseStruct structName).get! do\n    let type \u2190 whnf (\u2190 inferType e)\n    let .const _structName us := type.getAppFn | throwError \"{e} doesn't have a structure as type\"\n    e := mkAppN (.const projName us) (type.getAppArgs.push e)\n  mkDirectProjection e fieldName", "start": [434, 1], "end": [446, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.containsConst", "code": "def containsConst (e : Expr) (p : Name \u2192 Bool) : Bool :=\n  Option.isSome <| e.find? fun | .const n _ => p n | _ => false", "start": [448, 1], "end": [450, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.rewrite", "code": "def rewrite (e eq : Expr) : MetaM Expr := do\n  let \u27e8_, eq', []\u27e9 \u2190 (\u2190 mkFreshExprMVar none).mvarId!.rewrite e eq\n    | throwError \"Expr.rewrite may not produce subgoals.\"\n  return eq'", "start": [452, 1], "end": [461, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.rewriteType", "code": "def rewriteType (e eq : Expr) : MetaM Expr := do\n  mkEqMP (\u2190 (\u2190 inferType e).rewrite eq) e", "start": [463, 1], "end": [470, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.getFieldsToParents", "code": "def getFieldsToParents (env : Environment) (structName : Name) : Array Name :=\n  getStructureFields env structName |>.filter fun fieldName =>\n    isSubobjectField? env structName fieldName |>.isSome", "start": [474, 1], "end": [479, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.getModuleFor?", "code": "def Environment.getModuleFor? (env : Environment) (declName : Name) : Option Name :=\n  match env.getModuleIdxFor? declName with\n  | none =>\n    if env.constants.map\u2082.contains declName then\n      env.header.mainModule\n    else\n      none\n  | some idx => env.header.moduleNames[idx.toNat]!", "start": [481, 1], "end": [489, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.requiredModules", "code": "def Name.requiredModules (n : Name) : CoreM NameSet := do\n  let env \u2190 getEnv\n  let mut requiredModules : NameSet := {}\n  let ci \u2190 getConstInfo n\n  for n in ci.getUsedConstantsAsSet do\n    match env.getModuleFor? n with\n    | some m =>\n      if \u00ac (`Init).isPrefixOf m then\n        requiredModules := requiredModules.insert m\n    | none => pure ()\n  return requiredModules", "start": [491, 1], "end": [507, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.requiredModules", "code": "def Environment.requiredModules (env : Environment) : NameSet := Id.run do\n  let localConstantInfos := env.constants.map\u2082\n  let mut requiredModules : NameSet := {}\n  for (_, ci) in localConstantInfos do\n    for n in ci.getUsedConstantsAsSet do\n      match env.getModuleFor? n with\n      | some m =>\n        if \u00ac (`Init).isPrefixOf m then\n          requiredModules := requiredModules.insert m\n      | none => pure ()\n  return requiredModules", "start": [509, 1], "end": [525, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/Macro.lean", "imports": ["lake-packages/Qq/Qq/ForLean/ToExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean.lean", "lake-packages/Qq/Qq/ForLean/ReduceEval.lean", "lake-packages/Qq/Qq/Typ.lean"], "premises": [{"full_name": "Qq.Impl.ExprBackSubstResult", "code": "inductive ExprBackSubstResult\n  | quoted (e : Expr)\n  | unquoted (e : Expr)", "start": [11, 1], "end": [13, 24], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.MVarSynth", "code": "inductive MVarSynth\n  | term (quotedType : Expr) (unquotedMVar : MVarId) | type (unquotedMVar : MVarId) | level (unquotedMVar : LMVarId)", "start": [15, 1], "end": [18, 35], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.UnquoteState", "code": "structure UnquoteState where\n  \n  mvars : List (Expr \u00d7 MVarSynth) := []\n\n  \n  levelSubst : HashMap Expr Level := {}\n\n  \n  exprSubst : HashMap Expr Expr := {}\n\n  \n  unquoted := LocalContext.empty\n\n  \n  exprBackSubst : HashMap Expr ExprBackSubstResult := {}\n\n  \n  levelBackSubst : HashMap Level Expr := {}\n\n  \n  abstractedFVars : Array FVarId := #[]\n\n  levelNames : List Name := []\n\n  mayPostpone : Bool", "start": [20, 1], "end": [47, 21], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.UnquoteM", "code": "abbrev UnquoteM := StateT UnquoteState MetaM", "start": [49, 1], "end": [49, 45], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.QuoteM", "code": "abbrev QuoteM := ReaderT UnquoteState MetaM", "start": [51, 1], "end": [51, 44], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.determineLocalInstances", "code": "def determineLocalInstances (lctx : LocalContext) : MetaM LocalInstances := do\n  let mut localInsts : LocalInstances := {}\n  for ldecl in lctx do\n    match (\u2190 isClass? ldecl.type) with\n      | some c => localInsts := localInsts.push { className := c, fvar := ldecl.toExpr }\n      | none => pure ()\n  pure localInsts", "start": [56, 1], "end": [62, 18], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.withUnquotedLCtx", "code": "def withUnquotedLCtx [MonadControlT MetaM m] [Monad m] [MonadLiftT QuoteM m] (k : m \u03b1) : m \u03b1 := do\n  let unquoted := (\u2190 (read : QuoteM _)).unquoted\n  withLCtx unquoted (\u2190 (determineLocalInstances unquoted : QuoteM _)) k", "start": [64, 1], "end": [66, 72], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.addDollar", "code": "def addDollar : Name \u2192 Name\n  | anonymous => str anonymous \"$\"\n  | str anonymous s => str anonymous (\"$\" ++ s)\n  | str n s => str (addDollar n) s\n  | num n i => num (addDollar n) i", "start": [69, 1], "end": [73, 35], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.removeDollar", "code": "def removeDollar : Name \u2192 Option Name\n  | anonymous => none\n  | str anonymous \"$\" => some anonymous\n  | str anonymous s =>\n    if s.startsWith \"$\" then str anonymous (s.drop 1) else none\n  | str n s => (removeDollar n).map (str . s)\n  | num n i => (removeDollar n).map (num . i)", "start": [76, 1], "end": [82, 46], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.stripDollars", "code": "def stripDollars : Name \u2192 Name\n  | anonymous => anonymous\n  | str n \"$\" => stripDollars n\n  | str anonymous s =>\n    let s := s.dropWhile (\u00b7 = '$')\n    if s = \"\" then anonymous else str anonymous s\n  | str n s => str (stripDollars n) s\n  | num n i => num (stripDollars n) i", "start": [85, 1], "end": [92, 38], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.addSyntaxDollar", "code": "def addSyntaxDollar : Syntax \u2192 Syntax\n  | .ident info rawVal            val  preresolved =>\n    .ident info rawVal (addDollar val) preresolved\n  | stx => panic! s!\"addSyntaxDollar {stx}\"", "start": [94, 1], "end": [97, 44], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkAbstractedLevelName", "code": "def mkAbstractedLevelName (e : Expr) : MetaM Name :=\n  return e.getAppFn.constName?.getD `udummy ++ (\u2190 mkFreshId)", "start": [99, 1], "end": [100, 61], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.isAssignablePattern", "code": "def isAssignablePattern (e : Expr) : MetaM Bool := do\n  let e \u2190 instantiateMVars (\u2190 whnf e)\n  let .mvar mvarId := e.getAppFn | return false\n  unless \u2190 mvarId.isAssignable do return false\n  if (\u2190 mvarId.getKind) matches .synthetic then return false\n  return e.getAppArgs.all (\u00b7.isFVar) && e.getAppArgs.allDiff", "start": [102, 1], "end": [107, 61], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.isBad", "code": "def isBad (e : Expr) : Bool := Id.run do\n  if let .const (.str _ \"rec\") _ := e.getAppFn then\n    return true\n  return false", "start": [109, 1], "end": [112, 15], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.whnf", "code": "partial def whnf (e : Expr) (e0 : Expr := e) : MetaM Expr := do\n  let e \u2190 whnfCore e\n  let e0 := if isBad e then e0 else e\n  match \u2190 unfoldDefinition? e with\n    | some e => whnf e (if isBad e then e0 else e)\n    | none => pure e0", "start": [115, 1], "end": [120, 22], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.whnfR", "code": "def whnfR (e : Expr) : MetaM Expr :=\n  withReducible (whnf e)", "start": [122, 1], "end": [123, 25], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteLevel", "code": "partial def unquoteLevel (e : Expr) : UnquoteM Level := do\n  let e \u2190 whnf e\n  if let some l := (\u2190 get).levelSubst.find? e then\n    return l\n  if e.isAppOfArity ``Level.zero 0 then pure .zero\n  else if e.isAppOfArity ``Level.succ 1 then return .succ (\u2190 unquoteLevel (e.getArg! 0))\n  else if e.isAppOfArity ``Level.max 2 then return .max (\u2190 unquoteLevel (e.getArg! 0)) (\u2190 unquoteLevel (e.getArg! 1))\n  else if e.isAppOfArity ``Level.imax 2 then return .imax (\u2190 unquoteLevel (e.getArg! 0)) (\u2190 unquoteLevel (e.getArg! 1))\n  else if e.isAppOfArity ``Level.param 1 then return .param (\u2190 reduceEval (e.getArg! 0))\n  else if e.isAppOfArity ``Level.mvar 1 then return .mvar (\u2190 reduceEval (e.getArg! 0))\n  else\n    if \u2190 isAssignablePattern e then\n      return \u2190 unquoteLevelMVar e\n    if (\u2190 get).mayPostpone && e.getAppFn.isMVar then\n      Elab.throwPostpone\n    let name \u2190 mkAbstractedLevelName e\n    let l := .param name\n    modify fun s => { s with\n      levelSubst := s.levelSubst.insert e l\n      levelBackSubst := s.levelBackSubst.insert l e\n    }\n    pure l", "start": [127, 1], "end": [148, 11], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteLevelMVar", "code": "partial def unquoteLevelMVar (mvar : Expr) : UnquoteM Level := do\n  let newMVar \u2190 mkFreshLevelMVar\n  modify fun s => { s with\n    levelSubst := s.levelSubst.insert mvar newMVar\n    levelBackSubst := s.levelBackSubst.insert newMVar mvar\n    mvars := (mvar, .level newMVar.mvarId!) :: s.mvars\n  }\n  return newMVar", "start": [150, 1], "end": [157, 17], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteLevelList", "code": "partial def unquoteLevelList (e : Expr) : UnquoteM (List Level) := do\n  let e \u2190 whnf e\n  if e.isAppOfArity ``List.nil 1 then\n    pure []\n  else if e.isAppOfArity ``List.cons 3 then\n    return (\u2190 unquoteLevel (e.getArg! 1)) :: (\u2190 unquoteLevelList (e.getArg! 2))\n  else\n    throwFailedToEval e", "start": [161, 1], "end": [168, 24], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkAbstractedName", "code": "def mkAbstractedName (e : Expr) : UnquoteM Name := do\n  have base : Name :=\n    match e.getAppFn.constName? with\n    | some (.str _ s) => s!\"${s}\"\n    | _ => `unknown\n  let mut i := 0\n  repeat\n    i := i + 1\n    let n := base.appendIndexAfter i\n    unless (\u2190 get).unquoted.usesUserName n do\n      return n\n  unreachable!", "start": [170, 1], "end": [181, 15], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.betaRev'", "code": "@[inline] opaque betaRev' (e : Expr) (revArgs : List Expr) : Expr :=\n  e.betaRev revArgs.toArray", "start": [183, 1], "end": [184, 28], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.makeZetaReduce", "code": "def makeZetaReduce (a : FVarId) (b : Expr) : MetaM (Option LocalContext) := do\n  let .cdecl aIdx aFVarId aUserName aType _ aKind \u2190 a.getDecl | return none\n  let bFVars := (\u2190 b.collectFVars.run {}).2\n  let toRevert := (\u2190 collectForwardDeps #[.fvar a] (preserveOrder := true)).map (\u00b7.fvarId!)\n  for y in toRevert do if bFVars.fvarSet.contains y then return none\n  let oldLCtx \u2190 getLCtx\n  let newLCtx := toRevert.foldl (init := oldLCtx) (\u00b7.erase \u00b7)\n  let newLCtx := newLCtx.addDecl <| .ldecl aIdx aFVarId aUserName aType b (nonDep := false) aKind\n  let newLCtx := toRevert.filter (\u00b7 != a) |>.foldl (init := newLCtx) (\u00b7.addDecl <| oldLCtx.get! \u00b7)\n  return newLCtx", "start": [186, 1], "end": [195, 17], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.makeDefEq", "code": "def makeDefEq (a b : Expr) : MetaM (Option LocalContext) := do\n  if let .fvar a \u2190 whnf a then if let some lctx \u2190 makeZetaReduce a b then return lctx\n  if let .fvar b \u2190 whnf b then if let some lctx \u2190 makeZetaReduce b a then return lctx\n  return none", "start": [197, 1], "end": [200, 14], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteExprList", "code": "partial def unquoteExprList (e : Expr) : UnquoteM (List Expr) := do\n  let e \u2190 whnf e\n  if e.isAppOfArity ``List.nil 1 then\n    pure []\n  else if e.isAppOfArity ``List.cons 3 then\n    return (\u2190 unquoteExpr (e.getArg! 1)) :: (\u2190 unquoteExprList (e.getArg! 2))\n  else\n    throwFailedToEval e", "start": [204, 1], "end": [211, 24], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteExprMVar", "code": "partial def unquoteExprMVar (mvar : Expr) : UnquoteM Expr := do\n  let ty \u2190 instantiateMVars (\u2190 whnfR (\u2190 inferType mvar))\n  unless ty.isAppOf ``Quoted do throwError \"not of type Q(_):{indentExpr ty}\"\n  have et := ty.getArg! 0\n  let newET \u2190 unquoteExpr et\n  let newMVar \u2190 withUnquotedLCtx do mkFreshExprMVar newET\n  modify fun s => { s with\n    exprSubst := s.exprSubst.insert mvar newMVar\n    exprBackSubst := s.exprBackSubst.insert newMVar (.quoted mvar)\n    mvars := (mvar, .term et newMVar.mvarId!) :: s.mvars\n  }\n  return newMVar", "start": [213, 1], "end": [224, 17], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteExpr", "code": "partial def unquoteExpr (e : Expr) : UnquoteM Expr := do\n  if e.isAppOfArity ``Quoted.unsafeMk 2 then return \u2190 unquoteExpr (e.getArg! 1)\n  if e.isAppOfArity ``toExpr 3 then return e.getArg! 2\n  let e \u2190 instantiateMVars (\u2190 whnf e)\n  let eTy \u2190 whnfR (\u2190 inferType e)\n  if eTy.isAppOfArity ``Quoted 1 then\n    if let some e' := (\u2190 get).exprSubst.find? e then\n      return e'\n    if \u2190 isAssignablePattern e then\n      return \u2190 unquoteExprMVar e\n    if (\u2190 get).mayPostpone && e.getAppFn.isMVar then\n      Elab.throwPostpone\n    let ty \u2190 unquoteExpr (eTy.getArg! 0)\n    let fvarId := FVarId.mk (\u2190 mkFreshId)\n    let name \u2190 mkAbstractedName e\n    let fv := .fvar fvarId\n    modify fun s => { s with\n      unquoted := s.unquoted.mkLocalDecl fvarId name ty\n      exprSubst := s.exprSubst.insert e fv\n      exprBackSubst := s.exprBackSubst.insert fv (.quoted e)\n      abstractedFVars := s.abstractedFVars.push fvarId\n    }\n    return fv\n  let e \u2190 whnf e\n  let .const c _ \u2190 pure e.getAppFn | throwError \"unquoteExpr: {e} : {eTy}\"\n  let nargs := e.getAppNumArgs\n  match c, nargs with\n    | ``betaRev', 2 => return betaRev' (\u2190 unquoteExpr (e.getArg! 0)) (\u2190 unquoteExprList (e.getArg! 1))\n    | ``Expr.bvar, 1 => return .bvar (\u2190 reduceEval (e.getArg! 0))\n    | ``Expr.sort, 1 => return .sort (\u2190 unquoteLevel (e.getArg! 0))\n    | ``Expr.const, 2 => return .const (\u2190 reduceEval (e.getArg! 0)) (\u2190 unquoteLevelList (e.getArg! 1))\n    | ``Expr.app, 2 => return .app (\u2190 unquoteExpr (e.getArg! 0)) (\u2190 unquoteExpr (e.getArg! 1))\n    | ``Expr.lam, 4 =>\n      return .lam (\u2190 reduceEval (e.getArg! 0))\n        (\u2190 unquoteExpr (e.getArg! 1))\n        (\u2190 unquoteExpr (e.getArg! 2))\n        (\u2190 reduceEval (e.getArg! 3))\n    | ``Expr.forallE, 4 =>\n      return .forallE (\u2190 reduceEval (e.getArg! 0))\n        (\u2190 unquoteExpr (e.getArg! 1))\n        (\u2190 unquoteExpr (e.getArg! 2))\n        (\u2190 reduceEval (e.getArg! 3))\n    | ``Expr.letE, 5 =>\n      return .letE (\u2190 reduceEval (e.getArg! 0)) (\u2190 unquoteExpr (e.getArg! 1)) (\u2190 unquoteExpr (e.getArg! 2))\n        (\u2190 unquoteExpr (e.getArg! 3)) (\u2190 reduceEval (e.getArg! 4))\n    | ``Expr.lit, 1 => return .lit (\u2190 reduceEval (e.getArg! 0))\n    | ``Expr.proj, 3 =>\n      return .proj (\u2190 reduceEval (e.getArg! 0)) (\u2190 reduceEval (e.getArg! 1)) (\u2190 unquoteExpr (e.getArg! 2))\n    | _, _ => throwError \"unquoteExpr: {e} : {eTy}\"", "start": [226, 1], "end": [274, 52], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.substLevel", "code": "def substLevel (a : Name) (b : Level) : UnquoteM Unit :=\n  modify fun s => { s with\n    levelSubst := .ofList <| s.levelSubst.toList\n      |>.map fun (x, u) => (x, u.instantiateParams [a] [b])\n  }", "start": [278, 1], "end": [282, 4], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteLevelLCtx", "code": "def unquoteLevelLCtx (addDefEqs := true) : UnquoteM Unit := do\n  for ldecl in (\u2190 getLCtx) do\n    let fv := ldecl.toExpr\n    let ty := ldecl.type\n    let whnfTy \u2190 withReducible <| whnf ty\n    if whnfTy.isAppOfArity ``Level 0 then\n      modify fun s => { s with\n        levelNames := ldecl.userName :: s.levelNames\n        levelSubst := s.levelSubst.insert fv (.param ldecl.userName)\n      }\n    else if let .app (.app (.const ``QuotedLevelDefEq ..) u) v := whnfTy then\n      let u' \u2190 unquoteLevel u\n      let v' \u2190 unquoteLevel v\n      if addDefEqs then\n        if let .param n := u' then if !u'.occurs v' then substLevel n v'; continue\n        if let .param n := v' then if !v'.occurs u' then substLevel n u'; continue", "start": [284, 1], "end": [299, 83], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteLCtx", "code": "def unquoteLCtx : UnquoteM Unit := do\n  unquoteLevelLCtx\n  for ldecl in (\u2190 getLCtx) do\n    let fv := ldecl.toExpr\n    let ty := ldecl.type\n    let whnfTy \u2190 withReducible <| whnf ty\n    if whnfTy.isAppOfArity ``QuotedLevelDefEq 2 || whnfTy.isAppOfArity ``Level 0 then\n      pure () if whnfTy.isAppOfArity ``Quoted 1 then\n      let qTy := whnfTy.appArg!\n      let newTy \u2190 unquoteExpr qTy\n      modify fun s => { s with\n        unquoted := s.unquoted.addDecl $\n          LocalDecl.cdecl ldecl.index ldecl.fvarId (addDollar ldecl.userName) newTy ldecl.binderInfo ldecl.kind\n        exprBackSubst := s.exprBackSubst.insert fv (.quoted fv)\n        exprSubst := s.exprSubst.insert fv fv\n      }\n    else if whnfTy.isAppOfArity ``QuotedDefEq 4 then\n      let tyLevel \u2190 unquoteLevel (whnfTy.getArg! 0)\n      let ty \u2190 unquoteExpr (whnfTy.getArg! 1)\n      let lhs \u2190 unquoteExpr (whnfTy.getArg! 2)\n      let rhs \u2190 unquoteExpr (whnfTy.getArg! 3)\n      let eqTy := mkApp3 (.const ``Eq [tyLevel]) ty lhs rhs\n      let unquoted := (\u2190 get).unquoted\n      let unquoted := unquoted.addDecl <|\n        .cdecl ldecl.index ldecl.fvarId (addDollar ldecl.userName) eqTy ldecl.binderInfo ldecl.kind\n      let unquoted := (\u2190 withUnquotedLCtx do makeDefEq lhs rhs).getD unquoted\n      modify fun s => { s with\n        unquoted\n        exprBackSubst := s.exprBackSubst.insert fv (.unquoted (mkApp2 (.const ``Eq.refl [tyLevel]) ty lhs))\n        }\n    else\n      let .succ u \u2190 getLevel ty | pure ()\n      let LOption.some inst \u2190 trySynthInstance (mkApp (.const ``ToExpr [u]) ty) | pure ()\n      modify fun s => { s with\n        unquoted := s.unquoted.addDecl (ldecl.setUserName (addDollar ldecl.userName))\n        exprBackSubst := s.exprBackSubst.insert fv (.quoted (mkApp3 (.const ``toExpr [u]) ty inst fv))\n        exprSubst := s.exprSubst.insert fv fv\n      }", "start": [301, 1], "end": [340, 8], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.isLevelFVar", "code": "def isLevelFVar (n : Name) : MetaM (Option Expr) := do\n  match (\u2190 getLCtx).findFromUserName? n with\n    | none => pure none\n    | some decl =>\n      return if \u2190 isDefEq decl.type (.const ``Level []) then\n        some decl.toExpr\n      else\n        none", "start": [342, 1], "end": [349, 13], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.quoteLevel", "code": "def quoteLevel : Level \u2192 QuoteM Expr\n  | .zero => return .const ``Level.zero []\n  | .succ u => return mkApp (.const ``Level.succ []) (\u2190 quoteLevel u)\n  | l@(.mvar ..) => do\n    if let some e := (\u2190 read).levelBackSubst.find? l then\n      return e\n    throwError \"cannot quote level mvar {l}\"\n  | .max a b => return mkApp2 (.const ``Level.max []) (\u2190 quoteLevel a) (\u2190 quoteLevel b)\n  | .imax a b => return mkApp2 (.const ``Level.imax []) (\u2190 quoteLevel a) (\u2190 quoteLevel b)\n  | l@(.param n) => do\n    match (\u2190 read).levelBackSubst.find? l with\n      | some e => return e\n      | none =>\n        match \u2190 isLevelFVar n with\n          | some fv => return fv\n          | none =>\n            throwError \"universe parameter {n} not of type Level\"", "start": [351, 1], "end": [367, 66], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.quoteLevelList", "code": "def quoteLevelList : List Level \u2192 QuoteM Expr\n  | [] => return mkApp (.const ``List.nil [.zero]) (.const ``Level [])\n  | l::ls => do\n    return mkApp3 (.const ``List.cons [.zero]) (.const ``Level [])\n      (\u2190 quoteLevel l) (\u2190 quoteLevelList ls)", "start": [369, 1], "end": [373, 45], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.quoteExpr", "code": "partial def quoteExpr : Expr \u2192 QuoteM Expr\n  | .bvar i => return mkApp (.const ``Expr.bvar []) (toExpr i)\n  | e@(.fvar ..) => do\n    let some r := (\u2190 read).exprBackSubst.find? e | throwError \"unknown free variable {e}\"\n    match r with\n    | .quoted r => return r\n    | .unquoted r => quoteExpr r\n  | e@(.mvar ..) => do\n    if let some (.quoted r) := (\u2190 read).exprBackSubst.find? e then return r\n    throwError \"resulting term contains metavariable {e}\"\n  | .sort u => return mkApp (.const ``Expr.sort []) (\u2190 quoteLevel u)\n  | .const n ls => return mkApp2 (.const ``Expr.const []) (toExpr n) (\u2190 quoteLevelList ls)\n  | e@(.app _ _) => do\n    let fn \u2190 quoteExpr e.getAppFn\n    let args \u2190 e.getAppArgs.mapM quoteExpr\n    if e.getAppFn.isFVar then return mkApp2 (.const ``betaRev' []) fn $\n        args.foldl (flip $ mkApp3 (.const ``List.cons [.zero]) (.const ``Expr []))\n          (mkApp (.const ``List.nil [.zero]) (.const ``Expr []))\n    else\n      pure $ args.foldl (mkApp2 (.const ``Expr.app [])) fn\n  | .lam n t b d => do\n    return mkApp4 (.const ``Expr.lam []) (toExpr n.eraseMacroScopes)\n      (\u2190 quoteExpr t) (\u2190 quoteExpr b) (toExpr d)\n  | .forallE n t b d => do\n    return mkApp4 (.const ``Expr.forallE []) (toExpr $ if b.hasLooseBVar 0 then n.eraseMacroScopes else Name.anonymous)\n      (\u2190 quoteExpr t) (\u2190 quoteExpr b) (toExpr d)\n  | .letE n t v b d => do\n    return mkApp5 (.const ``Expr.letE []) (toExpr n.eraseMacroScopes) (\u2190 quoteExpr t) (\u2190 quoteExpr v) (\u2190 quoteExpr b) (toExpr d)\n  | .lit l => return mkApp (.const ``Expr.lit []) (toExpr l)\n  | .proj n i e => return mkApp3 (.const ``Expr.proj []) (toExpr n) (toExpr i) (\u2190 quoteExpr e)\n  | .mdata _ e => quoteExpr e", "start": [375, 1], "end": [406, 30], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteMVarCore", "code": "def unquoteMVarCore (mvar : Expr) : UnquoteM Unit := do\n  let ty \u2190 instantiateMVars (\u2190 whnfR (\u2190 inferType mvar))\n  if ty.isAppOf ``Quoted then\n    _ \u2190 unquoteExprMVar mvar\n  else if ty.isAppOf ``Level then\n    _ \u2190 unquoteLevelMVar mvar\n  else if ty.isSort then\n    let newMVar \u2190 withUnquotedLCtx do mkFreshTypeMVar\n    modify fun s => { s with\n      exprSubst := s.exprSubst.insert mvar newMVar\n      exprBackSubst := s.exprBackSubst.insert newMVar (.quoted mvar)\n      mvars := (mvar, .type newMVar.mvarId!) :: s.mvars\n    }\n  else\n    throwError \"unsupported expected type for quoted expression{indentExpr ty}\"", "start": [408, 1], "end": [422, 80], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteMVar", "code": "def unquoteMVar (mvar : Expr) : UnquoteM Unit := do\n  unquoteLCtx\n  unquoteMVarCore mvar", "start": [424, 1], "end": [426, 23], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.MVarSynth.isAssigned", "code": "def MVarSynth.isAssigned : MVarSynth \u2192 MetaM Bool\n  | .term _ newMVar => newMVar.isAssigned\n  | .type newMVar => newMVar.isAssigned\n  | .level newMVar => isLevelMVarAssigned newMVar", "start": [428, 1], "end": [431, 50], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.MVarSynth.synth", "code": "def MVarSynth.synth : MVarSynth \u2192 QuoteM Expr\n  | .term et newMVar => return mkApp2 (.const ``Quoted.unsafeMk []) et (\u2190 quoteExpr (\u2190 instantiateMVars (.mvar newMVar)))\n  | .type newMVar => return mkApp (.const ``Quoted []) (\u2190 quoteExpr (\u2190 instantiateMVars (.mvar newMVar)))\n  | .level newMVar => do quoteLevel (\u2190 instantiateLevelMVars (.mvar newMVar))", "start": [433, 1], "end": [436, 78], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.lctxHasMVar", "code": "def lctxHasMVar : MetaM Bool := do\n  (\u2190 getLCtx).anyM fun decl => return (\u2190 instantiateLocalDeclMVars decl).hasExprMVar", "start": [438, 1], "end": [439, 85], "kind": "commanddeclaration"}, {"full_name": "Qq.withProcessPostponed", "code": "@[specialize]\ndef withProcessPostponed [Monad m] [MonadFinally m] [MonadLiftT MetaM m] (k : m \u03b1) : m \u03b1 := do\n  let postponed \u2190 getResetPostponed\n  try\n    k <* discard (processPostponed (mayPostpone := false) (exceptionOnFailure := true))\n  finally\n    setPostponed (postponed ++ (\u2190 getPostponed))", "start": [445, 1], "end": [451, 49], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.UnquoteState.withLevelNames", "code": "def Impl.UnquoteState.withLevelNames (s : UnquoteState) (k : TermElabM (\u03b1 \u00d7 Array Name)) : TermElabM \u03b1 := do\n  Term.withLevelNames s.levelNames do\n    let (res, refdLevels) \u2190 try k catch e =>\n      if let some n := isAutoBoundImplicitLocalException? e then\n        throwError \"unsupported implicit auto-bound: {n} is not a level name\"\n      throw e\n\n    for newLevelName in (\u2190 getLevelNames) do\n      if let some fvar \u2190 isLevelFVar newLevelName then\n        if refdLevels.contains newLevelName then\n          addTermInfo' (\u2190 getRef) fvar\n      else if (\u2190 read).autoBoundImplicit then\n        throwAutoBoundImplicitLocal newLevelName\n      else\n        throwError \"unbound level param {newLevelName}\"\n\n    return res", "start": [453, 1], "end": [469, 15], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.macro", "code": "def Impl.macro (t : Syntax) (expectedType : Expr) : TermElabM Expr := do\n  let mainMVar \u2190 mkFreshExprMVar expectedType\n  let s \u2190 (unquoteMVar mainMVar *> get).run' { mayPostpone := (\u2190 read).mayPostpone }\n\n  have lastId := match s.mvars with\n    | (_, .term _ lastMVar) :: _ | (_, .type lastMVar) :: _ => lastMVar\n    | _ => unreachable!\n  let lastDecl \u2190 lastId.getDecl\n\n  withRef t do s.withLevelNames do\n    withLCtx lastDecl.lctx lastDecl.localInstances do\n      withProcessPostponed do withSynthesize do\n      let t \u2190 Term.elabTerm t lastDecl.type\n      let t \u2190 ensureHasType lastDecl.type t\n      synthesizeSyntheticMVars (mayPostpone := false)\n      if (\u2190 logUnassignedUsingErrorInfos (\u2190 getMVars t)) then\n        throwAbortTerm\n      lastId.assign t\n\n    let refdLevels \u2190 do\n      let mut lvls : CollectLevelParams.State := {}\n      for (_, synth) in s.mvars do\n        match synth with\n        | .term _ exprMVar | .type exprMVar =>\n          lvls := lvls.collect (\u2190 instantiateMVars (.mvar exprMVar))\n        | _ => pure ()\n      pure lvls.params\n\n    return ((), refdLevels)\n\n  for (mvar, synth) in s.mvars.reverse do\n    if \u2190 synth.isAssigned then\n      let t \u2190 synth.synth s\n      unless \u2190 isDefEq mvar t do\n        tryPostpone\n        throwError \"cannot assign metavariable ({mvar} : {\u2190 inferType mvar}) with {t}\"\n\n  instantiateMVars mainMVar", "start": [484, 1], "end": [521, 28], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.push", "code": "private def push [Monad m] (i t l : Syntax) : StateT (Array $ Syntax \u00d7 Syntax \u00d7 Syntax) m Unit :=\n  modify fun s => s.push (i, t, l)", "start": [563, 1], "end": [564, 35], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.floatLevelAntiquot'", "code": "partial def floatLevelAntiquot' [Monad m] [MonadQuotation m] (stx : Syntax) :\n    StateT (Array $ Syntax \u00d7 Syntax \u00d7 Syntax) m Syntax :=\n  if stx.isAntiquot && !stx.isEscapedAntiquot then\n    withFreshMacroScope do\n      push (\u2190 `(u)) (\u2190 `(Level)) (\u2190 floatLevelAntiquot' stx.getAntiquotTerm)\n      `(u)\n  else\n    match stx with\n    | Syntax.node i k args => return Syntax.node i k (\u2190 args.mapM floatLevelAntiquot')\n    | stx => return stx", "start": [566, 1], "end": [575, 24], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.floatExprAntiquot'", "code": "partial def floatExprAntiquot' [Monad m] [MonadQuotation m] (depth : Nat) :\n    Syntax \u2192 StateT (Array $ Syntax \u00d7 Syntax \u00d7 Syntax) m Syntax\n  | `(Q($x)) => do `(Q($(\u2190 floatExprAntiquot' (depth + 1) x)))\n  | `(q($x)) => do `(q($(\u2190 floatExprAntiquot' (depth + 1) x)))\n  | `(Type $term) => do `(Type $(\u2190 floatLevelAntiquot' term))\n  | `(Sort $term) => do `(Sort $(\u2190 floatLevelAntiquot' term))\n  | stx => do\n    if let (some (kind, _pseudo), false) := (stx.antiquotKind?, stx.isEscapedAntiquot) then\n      let term := stx.getAntiquotTerm\n      if depth > 0 then\n        return Syntax.mkAntiquotNode kind (\u2190 floatExprAntiquot' (depth - 1) term)\n      else if term.isIdent && (stripDollars term.getId).isAtomic then\n        return addSyntaxDollar term\n      else\n        withFreshMacroScope do\n          push (\u2190 `(a)) (\u2190 `(Quoted _)) term\n          return addSyntaxDollar <|<- `(a)\n    else\n      match stx with\n      | Syntax.node i k args => return Syntax.node i k (\u2190 args.mapM (floatExprAntiquot' depth))\n      | stx => pure stx", "start": [578, 1], "end": [598, 24], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.floatExprAntiquot", "code": "partial def floatExprAntiquot [Monad m] [MonadQuotation m] (depth : Nat) :\n    Term \u2192 StateT (Array $ Ident \u00d7 Term \u00d7 Term) m Term :=\n  fun t s => do\n    let (t, lifts) \u2190 floatExprAntiquot' depth t (s.map fun (a,t,l) => (a,t,l))\n    return (t, lifts.map fun (a,t,l) => (a,t,l))", "start": [601, 1], "end": [605, 49], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Rule.lean", "imports": ["lake-packages/aesop/Aesop/Index.lean", "lake-packages/aesop/Aesop/Rule/Basic.lean", "lake-packages/aesop/Aesop/Percent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.NormRuleInfo", "code": "structure NormRuleInfo where\n  penalty : Int\n  deriving Inhabited", "start": [18, 1], "end": [20, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormRule", "code": "abbrev NormRule := Rule NormRuleInfo", "start": [31, 1], "end": [31, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.defaultNormPenalty", "code": "def defaultNormPenalty : Int := 1", "start": [36, 1], "end": [36, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.defaultSimpRulePriority", "code": "def defaultSimpRulePriority : Int := eval_prio default", "start": [38, 1], "end": [38, 55], "kind": "commanddeclaration"}, {"full_name": "Aesop.Safety", "code": "inductive Safety\n  | safe\n  | almostSafe\n  deriving Inhabited", "start": [43, 1], "end": [46, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.SafeRuleInfo", "code": "structure SafeRuleInfo where\n  penalty : Int\n  safety : Safety\n  deriving Inhabited", "start": [57, 1], "end": [60, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.SafeRule", "code": "abbrev SafeRule := Rule SafeRuleInfo", "start": [71, 1], "end": [71, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.defaultSafePenalty", "code": "def defaultSafePenalty : Int := 1", "start": [76, 1], "end": [76, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnsafeRuleInfo", "code": "structure UnsafeRuleInfo where\n  successProbability : Percent\n  deriving Inhabited", "start": [81, 1], "end": [83, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnsafeRule", "code": "abbrev UnsafeRule := Rule UnsafeRuleInfo", "start": [96, 1], "end": [96, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.defaultSuccessProbability", "code": "def defaultSuccessProbability : Percent := .fifty", "start": [101, 1], "end": [101, 50], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularRule", "code": "inductive RegularRule\n  | safe (r : SafeRule)\n  | \u00abunsafe\u00bb (r : UnsafeRule)\n  deriving Inhabited, BEq", "start": [106, 1], "end": [109, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularRule.successProbability", "code": "def successProbability : RegularRule \u2192 Percent\n  | safe _ => Percent.hundred\n  | \u00abunsafe\u00bb r => r.extra.successProbability", "start": [118, 1], "end": [120, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularRule.isSafe", "code": "def isSafe : RegularRule \u2192 Bool\n  | safe _ => true\n  | \u00abunsafe\u00bb _ => false", "start": [122, 1], "end": [124, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularRule.isUnsafe", "code": "def isUnsafe : RegularRule \u2192 Bool\n  | safe _ => false\n  | \u00abunsafe\u00bb _ => true", "start": [126, 1], "end": [128, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularRule.withRule", "code": "@[inline]\ndef withRule (f : \u2200 {\u03b1}, Rule \u03b1 \u2192 \u03b2) : RegularRule \u2192 \u03b2\n  | safe r => f r\n  | \u00abunsafe\u00bb r => f r", "start": [130, 1], "end": [133, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularRule.name", "code": "def name (r : RegularRule) : RuleName :=\n  r.withRule (\u00b7.name)", "start": [135, 1], "end": [136, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularRule.indexingMode", "code": "def indexingMode (r : RegularRule) : IndexingMode :=\n  r.withRule (\u00b7.indexingMode)", "start": [138, 1], "end": [139, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularRule.tac", "code": "def tac (r : RegularRule) : RuleTacDescr :=\n  r.withRule (\u00b7.tac)", "start": [141, 1], "end": [142, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormSimpRule", "code": "structure NormSimpRule where\n  name : RuleName\n  entries : Array SimpEntry\n  deriving Inhabited", "start": [152, 1], "end": [155, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.LocalNormSimpRule", "code": "structure LocalNormSimpRule where\n  fvarUserName : Name\n  deriving Inhabited", "start": [172, 1], "end": [174, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.LocalNormSimpRule.name", "code": "def name (r : LocalNormSimpRule) : RuleName :=\n  { name := r.fvarUserName, scope := .local, builder := .simp, phase := .norm }", "start": [184, 1], "end": [185, 80], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnfoldRule", "code": "structure UnfoldRule where\n  decl : Name\n  unfoldThm? : Option Name\n  deriving Inhabited", "start": [190, 1], "end": [193, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnfoldRule.name", "code": "def name (r : UnfoldRule) : RuleName :=\n  { name := r.decl, builder := .unfold, phase := .norm, scope := .global }", "start": [203, 1], "end": [204, 75], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Constants.lean", "imports": ["lake-packages/aesop/Aesop/Percent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.unificationGoalPenalty", "code": "def unificationGoalPenalty : Percent :=\n  \u27e80.8\u27e9", "start": [11, 1], "end": [12, 8], "kind": "commanddeclaration"}, {"full_name": "Aesop.postponedSafeRuleSuccessProbability", "code": "def postponedSafeRuleSuccessProbability : Percent :=\n  \u27e80.9\u27e9", "start": [14, 1], "end": [15, 8], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Relation/Symm.lean", "imports": ["lake-packages/std/Std/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.applySymm", "code": "def applySymm (e : Expr) : MetaM Expr := do\n  go (\u2190 instantiateMVars (\u2190 inferType e)) fun lem args body => do\n    let .true \u2190 isDefEq args.back e | failure\n    mkExpectedTypeHint (mkAppN lem args) (\u2190 instantiateMVars body)\nwhere\n  \n  go (tgt : Expr) {\u03b1} (k : Expr \u2192 Array Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n    let .app (.app rel _) _ := tgt\n      | throwError \"symmetry lemmas only apply to binary relations, not{indentExpr tgt}\"\n    for lem in \u2190 (symmExt.getState (\u2190 getEnv)).getMatch rel do\n      try\n        let lem \u2190 mkConstWithFreshMVarLevels lem\n        let (args, _, body) \u2190 withReducible <| forallMetaTelescopeReducing (\u2190 inferType lem)\n        return (\u2190 k lem args body)\n      catch _ => pure ()\n    throwError \"no applicable symmetry lemma found for{indentExpr tgt}\"", "start": [50, 1], "end": [79, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.applySymm", "code": "def applySymm (g : MVarId) : MetaM MVarId := do\n  go (\u2190 g.getTypeCleanup) g fun lem args body g => do\n    let .true \u2190 isDefEq (\u2190 g.getType) body | failure\n    g.assign (mkAppN lem args)\n    return args.back.mvarId!\nwhere\n  \n  go (tgt : Expr) (g : MVarId) (k : Expr \u2192 Array Expr \u2192 Expr \u2192 MVarId \u2192 MetaM MVarId) :\n    MetaM MVarId := do\n  Expr.applySymm.go tgt fun lem args body => do\n    let g' \u2190 k lem args body g\n    g'.setTag (\u2190 g.getTag)\n    return g'", "start": [85, 1], "end": [107, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.applySymmAt", "code": "def applySymmAt (h : FVarId) (g : MVarId) : MetaM MVarId := do\n  let h' \u2190 (Expr.fvar h).applySymm\n  pure (\u2190 g.replace h h').mvarId", "start": [109, 1], "end": [112, 33], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/CodeAction.lean", "imports": ["lake-packages/std/Std/CodeAction/Attr.lean", "lake-packages/std/Std/CodeAction/Basic.lean", "lake-packages/std/Std/CodeAction/Misc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Tactic/Where.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.Where.describeOpenDecls", "code": "private def describeOpenDecls (ds : List OpenDecl) : MessageData := Id.run do\n  let mut lines := #[]\n  let mut simple := #[]\n  let flush (lines simple : Array MessageData) : Array MessageData \u00d7 Array MessageData :=\n    if simple.isEmpty then\n      (lines, simple)\n    else\n      (lines.push (\"open \" ++ MessageData.joinSep simple.toList \" \"), #[])\n  for d in ds do\n    match d with\n    | .explicit id decl =>\n      (lines, simple) := flush lines simple\n      lines := lines.push m!\"open {id} \u2192 {decl}\"\n    | .simple ns ex =>\n      if ex == [] then\n        simple := simple.push ns\n      else\n        (lines, simple) := flush lines simple\n        let ex' := ex.map toMessageData\n        lines := lines.push m!\"open {ns} hiding {MessageData.joinSep ex' \", \"}\"\n  (lines, simple) := flush lines simple\n  return MessageData.joinSep lines.toList \"\\n\"", "start": [18, 1], "end": [39, 47], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Where.describeOptions", "code": "private def describeOptions (opts : Options) : CommandElabM (Option MessageData) := do\n  let mut lines := #[]\n  for (name, val) in opts do\n    let dval \u2190 getOptionDefaultValue name\n    if val != dval then\n      lines := lines.push m!\"set_option {name} {val}\"\n  if lines.isEmpty then\n    return none\n  else\n    return MessageData.joinSep lines.toList \"\\n\"", "start": [41, 1], "end": [50, 49], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/SqueezeScope.lean", "imports": ["lake-packages/std/Std/Tactic/SimpTrace.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Simp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Control/ForInStep.lean", "imports": ["lake-packages/std/Std/Control/ForInStep/Lemmas.lean", "lake-packages/std/Std/Control/ForInStep/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Data/Sum.lean", "imports": ["lake-packages/std/Std/Data/Sum/Lemmas.lean", "lake-packages/std/Std/Data/Sum/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Data/Range/Lemmas.lean", "imports": ["lake-packages/std/Std/Data/List/Lemmas.lean", "lake-packages/std/Std/Tactic/ByCases.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Range.numElems", "code": "def numElems (r : Range) : Nat :=\n  if r.step = 0 then\n    if r.stop \u2264 r.start then 0 else r.stop\n  else\n    (r.stop - r.start + r.step - 1) / r.step", "start": [6, 1], "end": [12, 45], "kind": "commanddeclaration"}, {"full_name": "Std.Range.numElems_stop_le_start", "code": "theorem numElems_stop_le_start : \u2200 r : Range, r.stop \u2264 r.start \u2192 r.numElems = 0", "start": [14, 1], "end": [18, 26], "kind": "commanddeclaration"}, {"full_name": "Std.Range.numElems_step_1", "code": "theorem numElems_step_1 (start stop) : numElems \u27e8start, stop, 1\u27e9 = stop - start", "start": [20, 1], "end": [21, 18], "kind": "commanddeclaration"}, {"full_name": "Std.Range.numElems_le_iff", "code": "private theorem numElems_le_iff {start stop step i} (hstep : 0 < step) :\n    (stop - start + step - 1) / step \u2264 i \u2194 stop \u2264 start + step * i", "start": [23, 1], "end": [32, 32], "kind": "commanddeclaration"}, {"full_name": "Std.Range.mem_range'_elems", "code": "theorem mem_range'_elems (r : Range) (h : x \u2208 List.range' r.start r.numElems r.step) : x \u2208 r", "start": [34, 1], "end": [41, 74], "kind": "commanddeclaration"}, {"full_name": "Std.Range.forIn'_eq_forIn_range'", "code": "theorem forIn'_eq_forIn_range' [Monad m] (r : Std.Range)\n    (init : \u03b2) (f : (a : Nat) \u2192 a \u2208 r \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) :\n    forIn' r init f =\n    forIn\n      ((List.range' r.start r.numElems r.step).pmap Subtype.mk fun _ => mem_range'_elems r)\n      init (fun \u27e8a, h\u27e9 => f a h)", "start": [43, 1], "end": [86, 64], "kind": "commanddeclaration"}, {"full_name": "Std.Range.forIn_eq_forIn_range'", "code": "theorem forIn_eq_forIn_range' [Monad m] (r : Std.Range)\n    (init : \u03b2) (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) :\n    forIn r init f = forIn (List.range' r.start r.numElems r.step) init f", "start": [88, 1], "end": [100, 68], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Relation/Rfl.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/std/Std/Lean/Elab/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.applyRfl", "code": "def _root_.Lean.MVarId.applyRfl (goal : MVarId) : MetaM Unit := do\n  let .app (.app rel _) _ \u2190 whnfR <|\u2190 instantiateMVars <|\u2190 goal.getType\n    | throwError \"reflexivity lemmas only apply to binary relations, not{\n        indentExpr (\u2190 goal.getType)}\"\n  let s \u2190 saveState\n  let mut ex? := none\n  for lem in \u2190 (reflExt.getState (\u2190 getEnv)).getMatch rel do\n    try\n      let gs \u2190 goal.apply (\u2190 mkConstWithFreshMVarLevels lem)\n      if gs.isEmpty then return () else\n        logError <| MessageData.tagged `Tactic.unsolvedGoals <| m!\"unsolved goals\\n{\n          goalsToMessageData gs}\"\n    catch e =>\n      ex? := ex? <|> (some (\u2190 saveState, e)) s.restore\n  if let some (sErr, e) := ex? then\n    sErr.restore\n    throw e\n  else\n    throwError \"rfl failed, no lemma with @[refl] applies\"", "start": [44, 1], "end": [68, 59], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Case.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.filterTag", "code": "private def filterTag (mvarIds : List MVarId) (tag : Name) : TacticM (List MVarId) := do\n  let gs \u2190 mvarIds.toArray.filterMapM fun mvarId => do\n    let userName := (\u2190 mvarId.getDecl).userName\n    if tag == userName then\n      return some (0, mvarId)\n    else if tag.isSuffixOf userName then\n      return some (1, mvarId)\n    else if tag.isPrefixOf userName then\n      return some (2, mvarId)\n    else\n      return none\n  let gs := gs.insertionSort (\u00b7.1 < \u00b7.1)\n  return gs |>.map (\u00b7.2) |>.toList", "start": [75, 1], "end": [92, 35], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.findGoalOfPatt", "code": "def findGoalOfPatt (gs : List MVarId)\n    (tag : TSyntax ``binderIdent) (patt? : Option Term) (renameI : TSyntaxArray `Lean.binderIdent) :\n    TacticM (MVarId \u00d7 List MVarId \u00d7 List MVarId) :=\n  Term.withoutErrToSorry do\n    let fgs \u2190 match tag with\n      | `(binderIdent|$tag:ident) => filterTag gs tag.getId\n      | _ => pure gs\n    for g in fgs do\n      let gs := gs.erase g\n      if let some patt := patt? then\n        let s \u2190 saveState\n        try\n          let g \u2190 renameInaccessibles g renameI\n          let gCopy \u2190 g.withContext <| mkFreshExprSyntheticOpaqueMVar (\u2190 g.getType) (\u2190 g.getTag)\n          let g' :: gs' \u2190 run gCopy.mvarId! <| withoutRecover <|\n                            evalTactic (\u2190 `(tactic| refine_lift show $patt from ?_))\n            | throwNoGoalsToBeSolved if \u2190 g.withContext <| withReducible <| isDefEq (\u2190 g.getType) (\u2190 g'.getType) then\n            g.assign (.mvar g')\n          else\n            g.assign gCopy\n          return (g', gs', gs)\n        catch _ =>\n          restoreState s\n      else\n        let g \u2190 renameInaccessibles g renameI\n        return (g, [], gs)\n    throwError \"No goals with tag {tag} unify with the term {patt?.getD (\u2190 `(_))}, {\n                \"\"}or too many names provided for renaming {\n                \"\"}inaccessible variables.\"", "start": [94, 1], "end": [131, 44], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.processCasePattBody", "code": "def processCasePattBody (stx : TSyntax ``casePattTac) :\n    TacticM (Term \u2295 (Syntax \u00d7 TSyntax ``Parser.Tactic.tacticSeq)) := do\n  match stx with\n  | `(casePattTac| => $t:hole) => return Sum.inl \u27e8\u2190 withRef t `(?_)\u27e9\n  | `(casePattTac| => $t:syntheticHole) => return Sum.inl \u27e8t\u27e9\n  | `(casePattTac| =>%$arr $tac:tacticSeq) => return Sum.inr (arr, tac)\n  | _ => throwUnsupportedSyntax", "start": [133, 1], "end": [142, 32], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.evalCase", "code": "def evalCase (close : Bool) (stx : Syntax)\n    (tags : Array (TSyntax `Lean.binderIdent))\n    (hss : Array (TSyntaxArray `Lean.binderIdent))\n    (patts? : Array (Option Term))\n    (caseBody : TSyntax `Std.Tactic.casePattTac) :\n    TacticM Unit := do\n  let body \u2190 processCasePattBody caseBody\n  let mut acc : List MVarId := []\n  let mut pattref : List MVarId := []\n  for tag in tags, hs in hss, patt? in patts? do\n    let (g, gs', gs) \u2190 findGoalOfPatt (\u2190 getUnsolvedGoals) tag patt? hs\n    setGoals gs\n    pattref := pattref ++ gs'\n    match body with\n    | Sum.inl hole =>\n      let gs' \u2190 run g <| withRef hole do\n        let (val, gs') \u2190 elabTermWithHoles hole (\u2190 getMainTarget) `case\n        unless \u2190 occursCheck g val do\n          throwError \"'case' tactic failed, value{indentExpr val}\\n{\n            \"\"}depends on the main goal metavariable '{Expr.mvar g}'\"\n        g.assign val\n        setGoals gs'\n      acc := acc ++ gs'\n    | Sum.inr (arr, tac) =>\n      if close then\n        if tag matches `(binderIdent|$_:ident) then\n          g.setTag .anonymous\n        discard <| run g do\n          withCaseRef arr tac do\n            closeUsingOrAdmit (withTacticInfoContext stx (evalTactic tac))\n      else\n        let mvarTag \u2190 g.getTag\n        let gs' \u2190 run g <| withCaseRef arr tac (evalTactic tac)\n        if let [g'] := gs' then\n          g'.setTag mvarTag\n        acc := acc ++ gs'\n  setGoals (acc ++ pattref ++ (\u2190 getUnsolvedGoals))", "start": [144, 1], "end": [185, 52], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/GuardMsgs.lean", "imports": ["lake-packages/std/Std/Lean/Position.lean", "lake-packages/std/Std/CodeAction/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.GuardMsgs.messageToStringWithoutPos", "code": "private def messageToStringWithoutPos (msg : Message) : IO String := do\n  let mut str \u2190 msg.data.toString\n  unless msg.caption == \"\" do\n    str := msg.caption ++ \":\\n\" ++ str\n  match msg.severity with\n  | MessageSeverity.information => str := \"info: \" ++ str\n  | MessageSeverity.warning     => str := \"warning: \" ++ str\n  | MessageSeverity.error       => str := \"error: \" ++ str\n  if str.isEmpty || str.back != '\\n' then\n    str := str ++ \"\\n\"\n  return str", "start": [82, 1], "end": [94, 13], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardMsgs.SpecResult", "code": "inductive SpecResult\n  \n  | check\n  \n  | drop\n  \n  | passthrough", "start": [96, 1], "end": [103, 16], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardMsgs.parseGuardMsgsSpec", "code": "def parseGuardMsgsSpec (spec? : Option (TSyntax ``guardMsgsSpec)) :\n    CommandElabM (Message \u2192 SpecResult) := do\n  if let some spec := spec? then\n    match spec with\n    | `(guardMsgsSpec| ($[$elts:guardMsgsSpecElt],*)) => do\n      let mut p : Message \u2192 SpecResult := fun _ => .passthrough\n      let pushP (s : MessageSeverity) (drop : Bool) (p : Message \u2192 SpecResult)\n          (msg : Message) : SpecResult :=\n        if msg.severity == s then if drop then .drop else .check\n        else p msg\n      for elt in elts.reverse do\n        match elt with\n        | `(guardMsgsSpecElt| $[drop%$drop?]? info)    => p := pushP .information drop?.isSome p\n        | `(guardMsgsSpecElt| $[drop%$drop?]? warning) => p := pushP .warning drop?.isSome p\n        | `(guardMsgsSpecElt| $[drop%$drop?]? error)   => p := pushP .error drop?.isSome p\n        | `(guardMsgsSpecElt| $[drop%$drop?]? all) =>\n          p := fun _ => if drop?.isSome then .drop else .check\n        | _ => throwErrorAt elt \"Invalid #guard_msgs specification element\"\n      return p\n    | _ => throwErrorAt spec \"Invalid #guard_msgs specification\"\n  else\n    return fun _ => .check", "start": [105, 1], "end": [129, 27], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardMsgs.GuardMsgFailure", "code": "structure GuardMsgFailure where\n  \n  res : String\n  deriving TypeName", "start": [131, 1], "end": [136, 20], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardMsgs.guardMsgsCodeAction", "code": "@[command_code_action guardMsgsCmd]\ndef guardMsgsCodeAction : CommandCodeAction := fun params _ _ node => do\n  let .node _ ts := node | return #[]\n  let res := ts.findSome? fun\n    | .node (.ofCustomInfo { stx, value }) _ => return (stx, (\u2190 value.get? GuardMsgFailure).res)\n    | _ => none\n  let some (stx, res) := res | return #[]\n  let doc \u2190 readDoc\n  let eager := {\n    title := \"Update #guard_msgs with tactic output\"\n    kind? := \"quickfix\"\n    isPreferred? := true\n  }\n  pure #[{\n    eager\n    lazy? := some do\n      let some start := stx.getPos? true | return eager\n      let some tail := stx.setArg 0 mkNullNode |>.getPos? true | return eager\n      let newText := if res.isEmpty then\n        \"\"\n      else if res.length \u2264 100-7 && !res.contains '\\n' then s!\"\\n\"\n      else\n        s!\"\\n\"\n      pure { eager with\n        edit? := some <|.ofTextEdit params.textDocument.uri {\n          range := doc.meta.text.utf8RangeToLspRange \u27e8start, tail\u27e9\n          newText\n        }\n      }\n  }]", "start": [164, 1], "end": [195, 5], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Util/Pickle.lean", "imports": ["lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "pickle", "code": "def pickle {\u03b1 : Type} (path : FilePath) (x : \u03b1) (key : Name := by exact decl_name%) : IO Unit :=\n  saveModuleData path key (unsafe unsafeCast x)", "start": [16, 1], "end": [22, 48], "kind": "commanddeclaration"}, {"full_name": "unpickle", "code": "unsafe def unpickle (\u03b1 : Type) (path : FilePath) : IO (\u03b1 \u00d7 CompactedRegion) := do\n  let (x, region) \u2190 readModuleData path\n  pure (unsafeCast x, region)", "start": [24, 1], "end": [36, 30], "kind": "commanddeclaration"}, {"full_name": "withUnpickle", "code": "unsafe def withUnpickle [Monad m] [MonadLiftT IO m] {\u03b1 \u03b2 : Type}\n    (path : FilePath) (f : \u03b1 \u2192 m \u03b2) : m \u03b2 := do\n  let (x, region) \u2190 unpickle \u03b1 path\n  let r \u2190 f x\n  region.free\n  pure r", "start": [38, 1], "end": [44, 9], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Lint.lean", "imports": ["lake-packages/std/Std/Tactic/Lint/TypeClass.lean", "lake-packages/std/Std/Tactic/Lint/Frontend.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Tactic/Lint/Misc.lean", "lake-packages/std/Std/Tactic/Lint/Simp.lean"], "premises": []}
{"path": "lake-packages/std/Std/Lean/Meta/UnusedNames.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta.lean", "lake-packages/std/Std/Data/String.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Name.parseIndexSuffix", "code": "private def parseIndexSuffix (s : Substring) : Option Nat :=\n  if s.isEmpty then\n    none\n  else if s.front == '_' then\n    s.drop 1 |>.toNat?\n  else\n    none", "start": [14, 1], "end": [20, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.MatchUpToIndexSuffix", "code": "inductive MatchUpToIndexSuffix\n  \n  |  exactMatch\n  \n  | noMatch\n  \n  | suffixMatch (i : Nat)", "start": [22, 1], "end": [31, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.matchUpToIndexSuffix", "code": "def matchUpToIndexSuffix (n : Name) (query : Name) :\n    MatchUpToIndexSuffix :=\n  match n, query with\n  | .str pre\u2081 s\u2081, .str pre\u2082 s\u2082 =>\n    if pre\u2081 != pre\u2082 then\n      .noMatch\n    else\n      if let some suffix := s\u2081.dropPrefix? s\u2082 then\n        if suffix.isEmpty then\n          .exactMatch\n        else\n          if let some i := parseIndexSuffix suffix then\n            .suffixMatch i\n          else\n            .noMatch\n      else\n        .noMatch\n  | n, query => if n == query then .exactMatch else .noMatch", "start": [33, 1], "end": [59, 61], "kind": "commanddeclaration"}, {"full_name": "LocalContext.getUnusedUserNameIndex", "code": "def getUnusedUserNameIndex (lctx : LocalContext) (suggestion : Name) :\n    Option Nat := Id.run do\n  let mut minSuffix := none\n  for ldecl in lctx do\n    let hypName := ldecl.userName\n    if hypName.hasMacroScopes then\n      continue\n    match ldecl.userName.matchUpToIndexSuffix suggestion with\n    | .exactMatch => minSuffix := updateMinSuffix minSuffix 1\n    | .noMatch => continue\n    | .suffixMatch i => minSuffix := updateMinSuffix minSuffix (i + 1)\n  minSuffix\nwhere\n  \n  @[inline]\n  updateMinSuffix : Option Nat \u2192 Nat \u2192 Option Nat\n    | none, j => some j\n    | some i, j => some $ i.max j", "start": [66, 1], "end": [88, 34], "kind": "commanddeclaration"}, {"full_name": "LocalContext.getUnusedUserName", "code": "def getUnusedUserName (lctx : LocalContext) (suggestion : Name) : Name :=\n  let suggestion := suggestion.eraseMacroScopes\n  match lctx.getUnusedUserNameIndex suggestion with\n  | none => suggestion\n  | some i => suggestion.appendIndexAfter i", "start": [90, 1], "end": [99, 44], "kind": "commanddeclaration"}, {"full_name": "LocalContext.getUnusedUserNames", "code": "def getUnusedUserNames (lctx : LocalContext) (n : Nat) (suggestion : Name) :\n    Array Name :=\n  if n == 0 then\n    #[]\n  else\n    let suggestion := suggestion.eraseMacroScopes\n    let acc := Array.mkEmpty n\n    match lctx.getUnusedUserNameIndex suggestion with\n    | none => loop (acc.push suggestion) (n - 1) 1\n    | some i => loop acc n i\nwhere\n  \n  loop (acc : Array Name) (n i : Nat) : Array Name :=\n    match n with\n    | 0 => acc\n    | n + 1 => loop (acc.push $ suggestion.appendIndexAfter i) n (i + 1)", "start": [101, 1], "end": [120, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getUnusedUserName", "code": "def getUnusedUserName [Monad m] [MonadLCtx m] (suggestion : Name) : m Name :=\n  return (\u2190 getLCtx).getUnusedUserName suggestion", "start": [127, 1], "end": [132, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getUnusedUserNames", "code": "def getUnusedUserNames [Monad m] [MonadLCtx m] (n : Nat) (suggestion : Name) :\n    m (Array Name) :=\n  return (\u2190 getLCtx).getUnusedUserNames n suggestion", "start": [134, 1], "end": [140, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Prod/Lex.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Lean/Meta/AssertHypotheses.lean", "imports": ["lake-packages/std/Std/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.Hypothesis'", "code": "structure Hypothesis' extends Hypothesis where\n  \n  binderInfo : BinderInfo\n  \n  kind : LocalDeclKind", "start": [13, 1], "end": [20, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.assertHypotheses'", "code": "def _root_.Lean.MVarId.assertHypotheses' (mvarId : MVarId)\n    (hs : Array Hypothesis') : MetaM (Array FVarId \u00d7 MVarId) := do\n  let (fvarIds, mvarId) \u2190 mvarId.assertHypotheses $ hs.map (\u00b7.toHypothesis)\n  mvarId.modifyLCtx \u03bb lctx => Id.run do\n    let mut lctx := lctx\n    for h : i in [:hs.size] do\n      let h := hs[i]'h.2\n      if h.kind != .default then\n        lctx := lctx.setKind fvarIds[i]! h.kind\n      if h.binderInfo != .default then\n        lctx := lctx.setBinderInfo fvarIds[i]! h.binderInfo\n    pure lctx\n  return (fvarIds, mvarId)", "start": [22, 1], "end": [38, 27], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/MLList/Heartbeats.lean", "imports": ["lake-packages/std/Std/Data/MLList/Basic.lean", "lake-packages/std/Std/Lean/CoreM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MLList.whileAtLeastHeartbeatsPercent", "code": "def MLList.whileAtLeastHeartbeatsPercent [Monad m] [MonadLiftT CoreM m]\n    (L : MLList m \u03b1) (percent : Nat := 10) : MLList m \u03b1 :=\n  MLList.squash fun _ => do\n    if (\u2190 getMaxHeartbeats) = 0 then do\n      return L\n    let initialHeartbeats \u2190 getRemainingHeartbeats\n    return L.takeUpToFirstM fun _ => do\n      pure <| .up <| (\u2190 getRemainingHeartbeats) * 100 / initialHeartbeats < percent", "start": [15, 1], "end": [32, 84], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/BitVec.lean", "imports": ["lake-packages/std/Std/Data/BitVec/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Lean/Float.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Float.toRatParts", "code": "def toRatParts (f : Float) : Option (Int \u00d7 Int) :=\n  if f.isFinite then\n    let (f', exp) := f.frExp\n    let x := (2^53:Nat).toFloat * f'\n    let v := if x < 0 then\n      (-(-x).floor.toUInt64.toNat : Int)\n    else\n      (x.floor.toUInt64.toNat : Int)\n    some (v, exp - 53)\n  else none", "start": [9, 1], "end": [21, 12], "kind": "commanddeclaration"}, {"full_name": "Float.toRatParts'", "code": "partial def toRatParts' (f : Float) : Option (Int \u00d7 Int) :=\n  f.toRatParts.map fun (n, e) =>\n    if n == 0 then (0, 0) else\n      let neg : Bool := n < 0\n      let v := n.natAbs.toUInt64\n      let c := trailingZeros v 0\n      let v := (v >>> c.toUInt64).toNat\n      (if neg then -v else v, e + c.toNat)\nwhere\n  \n  trailingZeros (v : UInt64) (c : UInt8) :=\n    if v &&& 1 == 0 then trailingZeros (v >>> 1) (c + 1) else c", "start": [23, 1], "end": [41, 64], "kind": "commanddeclaration"}, {"full_name": "Float.toStringFull", "code": "def toStringFull (f : Float) : String :=\n  if let some (v, exp) := toRatParts f then\n    let v' := v.natAbs\n    let s := if exp \u2265 0 then\n      Nat.repr (v' * (2^exp.toNat:Nat))\n    else\n      let e := (-exp).toNat\n      let intPart := v' / 2^e\n      let rem := v' % 2^e\n      if rem == 0 then\n        Nat.repr intPart\n      else\n        let rem := Nat.repr ((2^e + v' % 2^e) * 5^e)\n        let rem := rem.dropRightWhile (\u00b7 == '0')\n        s!\"{intPart}.{rem.extract \u27e81\u27e9 rem.endPos}\"\n    if v < 0 then s!\"-{s}\" else s\n  else f.toString", "start": [43, 1], "end": [60, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Exact.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.assignIfDefeq", "code": "def Lean.MVarId.assignIfDefeq (g : MVarId) (e : Expr) : MetaM Unit := do\n  guard <| \u2190 isDefEq (\u2190 g.getType) (\u2190 inferType e)\n  g.checkNotAssigned `assignIfDefeq\n  g.assign e", "start": [12, 1], "end": [19, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Instances.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Data/PairingHeap.lean", "imports": ["lake-packages/std/Std/Logic.lean", "lake-packages/std/Std/Classes/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.PairingHeapImp.Heap", "code": "inductive Heap (\u03b1 : Type u) where\n  \n  | nil : Heap \u03b1\n  \n  | node (a : \u03b1) (child sibling : Heap \u03b1) : Heap \u03b1\n  deriving Repr", "start": [11, 1], "end": [27, 16], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.size", "code": "def Heap.size : Heap \u03b1 \u2192 Nat\n  | .nil => 0\n  | .node _ c s => c.size + 1 + s.size", "start": [29, 1], "end": [32, 39], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.singleton", "code": "def Heap.singleton (a : \u03b1) : Heap \u03b1 := .node a .nil .nil", "start": [34, 1], "end": [35, 57], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.isEmpty", "code": "def Heap.isEmpty : Heap \u03b1 \u2192 Bool\n  | .nil => true\n  | _    => false", "start": [37, 1], "end": [40, 18], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.merge", "code": "@[specialize] def Heap.merge (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : Heap \u03b1 \u2192 Heap \u03b1 \u2192 Heap \u03b1\n  | .nil, .nil => .nil\n  | .nil, .node a\u2082 c\u2082 _ => .node a\u2082 c\u2082 .nil\n  | .node a\u2081 c\u2081 _, .nil => .node a\u2081 c\u2081 .nil\n  | .node a\u2081 c\u2081 _, .node a\u2082 c\u2082 _ =>\n    if le a\u2081 a\u2082 then .node a\u2081 (.node a\u2082 c\u2082 c\u2081) .nil else .node a\u2082 (.node a\u2081 c\u2081 c\u2082) .nil", "start": [42, 1], "end": [48, 88], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.combine", "code": "@[specialize] def Heap.combine (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : Heap \u03b1 \u2192 Heap \u03b1\n  | h\u2081@(.node _ _ h\u2082@(.node _ _ s)) => merge le (merge le h\u2081 h\u2082) (s.combine le)\n  | h => h", "start": [50, 1], "end": [53, 11], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.headD", "code": "@[inline] def Heap.headD (a : \u03b1) : Heap \u03b1 \u2192 \u03b1\n  | .nil => a\n  | .node a _ _ => a", "start": [55, 1], "end": [58, 21], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.head?", "code": "@[inline] def Heap.head? : Heap \u03b1 \u2192 Option \u03b1\n  | .nil => none\n  | .node a _ _ => some a", "start": [60, 1], "end": [63, 26], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.deleteMin", "code": "@[inline] def Heap.deleteMin (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : Heap \u03b1 \u2192 Option (\u03b1 \u00d7 Heap \u03b1)\n  | .nil => none\n  | .node a c _ => (a, combine le c)", "start": [65, 1], "end": [68, 37], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.tail?", "code": "@[inline] def Heap.tail? (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (h : Heap \u03b1) : Option (Heap \u03b1) :=\n  deleteMin le h |>.map (\u00b7.snd)", "start": [70, 1], "end": [72, 32], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.tail", "code": "@[inline] def Heap.tail (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (h : Heap \u03b1) : Heap \u03b1 :=\n  tail? le h |>.getD .nil", "start": [74, 1], "end": [76, 26], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.NoSibling", "code": "inductive Heap.NoSibling : Heap \u03b1 \u2192 Prop\n  \n  | nil : NoSibling .nil\n  \n  | node (a c) : NoSibling (.node a c .nil)", "start": [78, 1], "end": [83, 44], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.noSibling_merge", "code": "theorem Heap.noSibling_merge (le) (s\u2081 s\u2082 : Heap \u03b1) :\n    (s\u2081.merge le s\u2082).NoSibling", "start": [91, 1], "end": [94, 40], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.noSibling_combine", "code": "theorem Heap.noSibling_combine (le) (s : Heap \u03b1) :\n    (s.combine le).NoSibling", "start": [96, 1], "end": [102, 72], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.noSibling_deleteMin", "code": "theorem Heap.noSibling_deleteMin {s : Heap \u03b1} (eq : s.deleteMin le = some (a, s')) :\n    s'.NoSibling", "start": [104, 1], "end": [106, 66], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.noSibling_tail?", "code": "theorem Heap.noSibling_tail? {s : Heap \u03b1} : s.tail? le = some s' \u2192\n    s'.NoSibling", "start": [108, 1], "end": [112, 55], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.noSibling_tail", "code": "theorem Heap.noSibling_tail (le) (s : Heap \u03b1) : (s.tail le).NoSibling", "start": [114, 1], "end": [118, 45], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.size_merge_node", "code": "theorem Heap.size_merge_node (le) (a\u2081 : \u03b1) (c\u2081 s\u2081 : Heap \u03b1) (a\u2082 : \u03b1) (c\u2082 s\u2082 : Heap \u03b1) :\n    (merge le (.node a\u2081 c\u2081 s\u2081) (.node a\u2082 c\u2082 s\u2082)).size = c\u2081.size + c\u2082.size + 2", "start": [120, 1], "end": [122, 51], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.size_merge", "code": "theorem Heap.size_merge (le) {s\u2081 s\u2082 : Heap \u03b1} (h\u2081 : s\u2081.NoSibling) (h\u2082 : s\u2082.NoSibling) :\n    (merge le s\u2081 s\u2082).size = s\u2081.size + s\u2082.size", "start": [124, 1], "end": [128, 77], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.size_combine", "code": "theorem Heap.size_combine (le) (s : Heap \u03b1) :\n    (s.combine le).size = s.size", "start": [130, 1], "end": [137, 8], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.size_deleteMin", "code": "theorem Heap.size_deleteMin {s : Heap \u03b1} (h : s.NoSibling) (eq : s.deleteMin le = some (a, s')) :\n    s.size = s'.size + 1", "start": [139, 1], "end": [141, 68], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.size_tail?", "code": "theorem Heap.size_tail? {s : Heap \u03b1} (h : s.NoSibling) : s.tail? le = some s' \u2192\n    s.size = s'.size + 1", "start": [143, 1], "end": [147, 52], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.size_tail", "code": "theorem Heap.size_tail (le) {s : Heap \u03b1} (h : s.NoSibling) : (s.tail le).size = s.size - 1", "start": [149, 1], "end": [153, 48], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.size_deleteMin_lt", "code": "theorem Heap.size_deleteMin_lt {s : Heap \u03b1} (eq : s.deleteMin le = some (a, s')) :\n    s'.size < s.size", "start": [155, 1], "end": [157, 70], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.size_tail?_lt", "code": "theorem Heap.size_tail?_lt {s : Heap \u03b1} : s.tail? le = some s' \u2192\n    s'.size < s.size", "start": [159, 1], "end": [163, 53], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.foldM", "code": "@[specialize] def Heap.foldM [Monad m] (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (s : Heap \u03b1)\n    (init : \u03b2) (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) : m \u03b2 :=\n  match eq : s.deleteMin le with\n  | none => pure init\n  | some (hd, tl) =>\n    have : tl.size < s.size := by simp_arith [Heap.size_deleteMin_lt eq]\n    do foldM le tl (\u2190 f init hd) f\ntermination_by _ => s.size", "start": [165, 1], "end": [176, 27], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.fold", "code": "@[inline] def Heap.fold (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (s : Heap \u03b1) (init : \u03b2) (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) : \u03b2 :=\n  Id.run <| s.foldM le init f", "start": [178, 1], "end": [183, 30], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.toArray", "code": "@[inline] def Heap.toArray (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (s : Heap \u03b1) : Array \u03b1 := fold le s #[] Array.push", "start": [185, 1], "end": [186, 98], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.toList", "code": "@[inline] def Heap.toList (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (s : Heap \u03b1) : List \u03b1 := (s.toArray le).toList", "start": [188, 1], "end": [189, 93], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.foldTreeM", "code": "@[specialize] def Heap.foldTreeM [Monad m] (nil : \u03b2) (join : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 m \u03b2) : Heap \u03b1 \u2192 m \u03b2\n  | .nil => pure nil\n  | .node a c s => do join a (\u2190 c.foldTreeM nil join) (\u2190 s.foldTreeM nil join)", "start": [191, 1], "end": [194, 79], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.foldTree", "code": "@[inline] def Heap.foldTree (nil : \u03b2) (join : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2) (s : Heap \u03b1) : \u03b2 :=\n  Id.run <| s.foldTreeM nil join", "start": [196, 1], "end": [198, 33], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.toListUnordered", "code": "def Heap.toListUnordered (s : Heap \u03b1) : List \u03b1 :=\n  s.foldTree id (fun a c s l => a :: c (s l)) []", "start": [200, 1], "end": [202, 49], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.toArrayUnordered", "code": "def Heap.toArrayUnordered (s : Heap \u03b1) : Array \u03b1 :=\n  s.foldTree id (fun a c s r => s (c (r.push a))) #[]", "start": [204, 1], "end": [206, 54], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.NodeWF", "code": "def Heap.NodeWF (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : \u03b1) : Heap \u03b1 \u2192 Prop\n  | .nil => True\n  | .node b c s => (\u2200 [TotalBLE le], le a b) \u2227 c.NodeWF le b \u2227 s.NodeWF le a", "start": [208, 1], "end": [216, 77], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.WF", "code": "inductive Heap.WF (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : Heap \u03b1 \u2192 Prop\n  \n  | nil : WF le .nil\n  \n  | node (h : c.NodeWF le a) : WF le (.node a c .nil)", "start": [218, 1], "end": [228, 54], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.WF.singleton", "code": "theorem Heap.WF.singleton : (Heap.singleton a).WF le", "start": [230, 1], "end": [230, 69], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.WF.merge_node", "code": "theorem Heap.WF.merge_node (h\u2081 : NodeWF le a\u2081 c\u2081) (h\u2082 : NodeWF le a\u2082 c\u2082) :\n    (merge le (.node a\u2081 c\u2081 s\u2081) (.node a\u2082 c\u2082 s\u2082)).WF le", "start": [232, 1], "end": [237, 66], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.WF.merge", "code": "theorem Heap.WF.merge (h\u2081 : s\u2081.WF le) (h\u2082 : s\u2082.WF le) :\n    (merge le s\u2081 s\u2082).WF le", "start": [239, 1], "end": [245, 43], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.WF.combine", "code": "theorem Heap.WF.combine (h : s.NodeWF le a) : (combine le s).WF le", "start": [247, 1], "end": [251, 90], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.WF.deleteMin", "code": "theorem Heap.WF.deleteMin {s : Heap \u03b1} (h : s.WF le)\n    (eq : s.deleteMin le = some (a, s')) : s'.WF le", "start": [253, 1], "end": [255, 60], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.WF.tail?", "code": "theorem Heap.WF.tail? (hwf : (s : Heap \u03b1).WF le) : s.tail? le = some tl \u2192\n  tl.WF le", "start": [257, 1], "end": [261, 49], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.WF.tail", "code": "theorem Heap.WF.tail (hwf : (s : Heap \u03b1).WF le) : (s.tail le).WF le", "start": [263, 1], "end": [267, 34], "kind": "commanddeclaration"}, {"full_name": "Std.PairingHeapImp.Heap.deleteMin_fst", "code": "theorem Heap.deleteMin_fst : ((s : Heap \u03b1).deleteMin le).map (\u00b7.1) = s.head?", "start": [269, 1], "end": [272, 23], "kind": "commanddeclaration"}, {"full_name": "PairingHeap", "code": "def PairingHeap (\u03b1 : Type u) (le : \u03b1 \u2192 \u03b1 \u2192 Bool) :=\n  { h : Heap \u03b1 // h.WF le }", "start": [278, 1], "end": [296, 28], "kind": "commanddeclaration"}, {"full_name": "mkPairingHeap", "code": "@[inline] def mkPairingHeap (\u03b1 : Type u) (le : \u03b1 \u2192 \u03b1 \u2192 Bool) : PairingHeap \u03b1 le :=\n  \u27e8.nil, Heap.WF.nil\u27e9", "start": [298, 1], "end": [300, 22], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.empty", "code": "@[inline] def empty : PairingHeap \u03b1 le := mkPairingHeap \u03b1 le", "start": [305, 1], "end": [306, 61], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.isEmpty", "code": "@[inline] def isEmpty (b : PairingHeap \u03b1 le) : Bool := b.1.isEmpty", "start": [310, 1], "end": [311, 67], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.size", "code": "@[inline] def size (b : PairingHeap \u03b1 le) : Nat := b.1.size", "start": [313, 1], "end": [314, 60], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.singleton", "code": "@[inline] def singleton (a : \u03b1) : PairingHeap \u03b1 le :=\n  \u27e8Heap.singleton a, Heap.WF.singleton\u27e9", "start": [316, 1], "end": [318, 40], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.merge", "code": "@[inline] def merge : PairingHeap \u03b1 le \u2192 PairingHeap \u03b1 le \u2192 PairingHeap \u03b1 le\n  | \u27e8b\u2081, h\u2081\u27e9, \u27e8b\u2082, h\u2082\u27e9 => \u27e8b\u2081.merge le b\u2082, h\u2081.merge h\u2082\u27e9", "start": [320, 1], "end": [322, 56], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.insert", "code": "@[inline] def insert (a : \u03b1) (h : PairingHeap \u03b1 le) : PairingHeap \u03b1 le :=\n  merge (singleton a) h", "start": [324, 1], "end": [326, 24], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.ofList", "code": "def ofList (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (as : List \u03b1) : PairingHeap \u03b1 le :=\n  as.foldl (flip insert) empty", "start": [328, 1], "end": [330, 31], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.ofArray", "code": "def ofArray (le : \u03b1 \u2192 \u03b1 \u2192 Bool) (as : Array \u03b1) : PairingHeap \u03b1 le :=\n  as.foldl (flip insert) empty", "start": [332, 1], "end": [334, 31], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.deleteMin", "code": "@[inline] def deleteMin (b : PairingHeap \u03b1 le) : Option (\u03b1 \u00d7 PairingHeap \u03b1 le) :=\n  match eq : b.1.deleteMin le with\n  | none => none\n  | some (a, tl) => some (a, \u27e8tl, b.2.deleteMin eq\u27e9)", "start": [336, 1], "end": [340, 53], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.head?", "code": "@[inline] def head? (b : PairingHeap \u03b1 le) : Option \u03b1 := b.1.head?", "start": [342, 1], "end": [343, 67], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.head!", "code": "@[inline] def head! [Inhabited \u03b1] (b : PairingHeap \u03b1 le) : \u03b1 := b.head?.get!", "start": [345, 1], "end": [346, 77], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.headI", "code": "@[inline] def headI [Inhabited \u03b1] (b : PairingHeap \u03b1 le) : \u03b1 := b.head?.getD default", "start": [348, 1], "end": [349, 85], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.tail?", "code": "@[inline] def tail? (b : PairingHeap \u03b1 le) : Option (PairingHeap \u03b1 le) :=\n  match eq : b.1.tail? le with\n  | none => none\n  | some tl => some \u27e8tl, b.2.tail? eq\u27e9", "start": [351, 1], "end": [357, 39], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.tail", "code": "@[inline] def tail (b : PairingHeap \u03b1 le) : PairingHeap \u03b1 le := \u27e8b.1.tail le, b.2.tail\u27e9", "start": [359, 1], "end": [360, 88], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.toList", "code": "@[inline] def toList (b : PairingHeap \u03b1 le) : List \u03b1 := b.1.toList le", "start": [362, 1], "end": [363, 70], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.toArray", "code": "@[inline] def toArray (b : PairingHeap \u03b1 le) : Array \u03b1 := b.1.toArray le", "start": [365, 1], "end": [366, 73], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.toListUnordered", "code": "@[inline] def toListUnordered (b : PairingHeap \u03b1 le) : List \u03b1 := b.1.toListUnordered", "start": [368, 1], "end": [369, 85], "kind": "commanddeclaration"}, {"full_name": "PairingHeap.toArrayUnordered", "code": "@[inline] def toArrayUnordered (b : PairingHeap \u03b1 le) : Array \u03b1 := b.1.toArrayUnordered", "start": [371, 1], "end": [372, 88], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/List/Pairwise.lean", "imports": ["lake-packages/std/Std/Data/List/Count.lean", "lake-packages/std/Std/Data/Fin/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.rel_of_pairwise_cons", "code": "theorem rel_of_pairwise_cons (p : (a :: l).Pairwise R) : \u2200 {a'}, a' \u2208 l \u2192 R a a'", "start": [33, 1], "end": [34, 26], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.of_cons", "code": "theorem Pairwise.of_cons (p : (a :: l).Pairwise R) : Pairwise R l", "start": [36, 1], "end": [37, 24], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.tail", "code": "theorem Pairwise.tail : \u2200 {l : List \u03b1} (_p : Pairwise R l), Pairwise R l.tail", "start": [39, 1], "end": [41, 27], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.drop", "code": "theorem Pairwise.drop : \u2200 {l : List \u03b1} {n : Nat}, List.Pairwise R l \u2192 List.Pairwise R (l.drop n)", "start": [43, 1], "end": [46, 74], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.imp_of_mem", "code": "theorem Pairwise.imp_of_mem {S : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (H : \u2200 {a b}, a \u2208 l \u2192 b \u2208 l \u2192 R a b \u2192 S a b) (p : Pairwise R l) : Pairwise S l", "start": [48, 1], "end": [55, 74], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.and", "code": "theorem Pairwise.and (hR : Pairwise R l) (hS : Pairwise S l) :\n    l.Pairwise fun a b => R a b \u2227 S a b", "start": [57, 1], "end": [63, 54], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_and_iff", "code": "theorem pairwise_and_iff : l.Pairwise (fun a b => R a b \u2227 S a b) \u2194 Pairwise R l \u2227 Pairwise S l", "start": [65, 1], "end": [66, 81], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.imp\u2082", "code": "theorem Pairwise.imp\u2082 (H : \u2200 a b, R a b \u2192 S a b \u2192 T a b)\n    (hR : Pairwise R l) (hS : l.Pairwise S) : l.Pairwise T", "start": [68, 1], "end": [70, 46], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.iff_of_mem", "code": "theorem Pairwise.iff_of_mem {S : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : List \u03b1}\n    (H : \u2200 {a b}, a \u2208 l \u2192 b \u2208 l \u2192 (R a b \u2194 S a b)) : Pairwise R l \u2194 Pairwise S l", "start": [72, 1], "end": [74, 91], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.iff", "code": "theorem Pairwise.iff {S : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : \u2200 a b, R a b \u2194 S a b) {l : List \u03b1} :\n    Pairwise R l \u2194 Pairwise S l", "start": [76, 1], "end": [78, 38], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_of_forall", "code": "theorem pairwise_of_forall {l : List \u03b1} (H : \u2200 x y, R x y) : Pairwise R l", "start": [80, 1], "end": [81, 27], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.and_mem", "code": "theorem Pairwise.and_mem {l : List \u03b1} :\n    Pairwise R l \u2194 Pairwise (fun x y => x \u2208 l \u2227 y \u2208 l \u2227 R x y) l", "start": [83, 1], "end": [85, 68], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.imp_mem", "code": "theorem Pairwise.imp_mem {l : List \u03b1} :\n    Pairwise R l \u2194 Pairwise (fun x y => x \u2208 l \u2192 y \u2208 l \u2192 R x y) l", "start": [87, 1], "end": [89, 68], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.forall_of_forall_of_flip", "code": "theorem Pairwise.forall_of_forall_of_flip (h\u2081 : \u2200 x \u2208 l, R x x) (h\u2082 : Pairwise R l)\n    (h\u2083 : l.Pairwise (flip R)) : \u2200 \u2983x\u2984, x \u2208 l \u2192 \u2200 \u2983y\u2984, y \u2208 l \u2192 R x y", "start": [91, 1], "end": [102, 74], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_singleton", "code": "theorem pairwise_singleton (R) (a : \u03b1) : Pairwise R [a]", "start": [104, 1], "end": [104, 67], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_pair", "code": "theorem pairwise_pair {a b : \u03b1} : Pairwise R [a, b] \u2194 R a b", "start": [106, 1], "end": [106, 71], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_append_comm", "code": "theorem pairwise_append_comm {R : \u03b1 \u2192 \u03b1 \u2192 Prop} (s : \u2200 {x y}, R x y \u2192 R y x) {l\u2081 l\u2082 : List \u03b1} :\n    Pairwise R (l\u2081 ++ l\u2082) \u2194 Pairwise R (l\u2082 ++ l\u2081)", "start": [108, 1], "end": [112, 87], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_middle", "code": "theorem pairwise_middle {R : \u03b1 \u2192 \u03b1 \u2192 Prop} (s : \u2200 {x y}, R x y \u2192 R y x) {a : \u03b1} {l\u2081 l\u2082 : List \u03b1} :\n    Pairwise R (l\u2081 ++ a :: l\u2082) \u2194 Pairwise R (a :: (l\u2081 ++ l\u2082))", "start": [114, 1], "end": [118, 34], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.of_map", "code": "theorem Pairwise.of_map {S : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (H : \u2200 a b : \u03b1, S (f a) (f b) \u2192 R a b)\n    (p : Pairwise S (map f l)) : Pairwise R l", "start": [120, 1], "end": [122, 33], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.map", "code": "theorem Pairwise.map {S : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (H : \u2200 a b : \u03b1, R a b \u2192 S (f a) (f b))\n    (p : Pairwise R l) : Pairwise S (map f l)", "start": [124, 1], "end": [126, 34], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_filterMap", "code": "theorem pairwise_filterMap (f : \u03b2 \u2192 Option \u03b1) {l : List \u03b2} :\n    Pairwise R (filterMap f l) \u2194 Pairwise (fun a a' : \u03b2 => \u2200 b \u2208 f a, \u2200 b' \u2208 f a', R b b') l", "start": [128, 1], "end": [142, 75], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.filter_map", "code": "theorem Pairwise.filter_map {S : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 Option \u03b2)\n    (H : \u2200 a a' : \u03b1, R a a' \u2192 \u2200 b \u2208 f a, \u2200 b' \u2208 f a', S b b') {l : List \u03b1} (p : Pairwise R l) :\n    Pairwise S (filterMap f l)", "start": [144, 1], "end": [147, 44], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_filter", "code": "theorem pairwise_filter (p : \u03b1 \u2192 Prop) [DecidablePred p] {l : List \u03b1} :\n    Pairwise R (filter p l) \u2194 Pairwise (fun x y => p x \u2192 p y \u2192 R x y) l", "start": [149, 1], "end": [151, 51], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.filter", "code": "theorem Pairwise.filter (p : \u03b1 \u2192 Bool) : Pairwise R l \u2192 Pairwise R (filter p l)", "start": [153, 1], "end": [154, 38], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_join", "code": "theorem pairwise_join {L : List (List \u03b1)} :\n    Pairwise R (join L) \u2194\n      (\u2200 l \u2208 L, Pairwise R l) \u2227 Pairwise (fun l\u2081 l\u2082 => \u2200 x \u2208 l\u2081, \u2200 y \u2208 l\u2082, R x y) L", "start": [156, 1], "end": [165, 83], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_bind", "code": "theorem pairwise_bind {R : \u03b2 \u2192 \u03b2 \u2192 Prop} {l : List \u03b1} {f : \u03b1 \u2192 List \u03b2} :\n    List.Pairwise R (l.bind f) \u2194\n      (\u2200 a \u2208 l, Pairwise R (f a)) \u2227 Pairwise (fun a\u2081 a\u2082 => \u2200 x \u2208 f a\u2081, \u2200 y \u2208 f a\u2082, R x y) l", "start": [167, 1], "end": [170, 48], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_iff_forall_sublist", "code": "theorem pairwise_iff_forall_sublist : l.Pairwise R \u2194 (\u2200 {a b}, [a,b] <+ l \u2192 R a b)", "start": [172, 1], "end": [188, 34], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_of_reflexive_on_dupl_of_forall_ne", "code": "@[deprecated pairwise_iff_forall_sublist]\ntheorem pairwise_of_reflexive_on_dupl_of_forall_ne [DecidableEq \u03b1] {l : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (hr : \u2200 a, 1 < count a l \u2192 r a a) (h : \u2200 a \u2208 l, \u2200 b \u2208 l, a \u2260 b \u2192 r a b) : l.Pairwise r", "start": [190, 1], "end": [200, 14], "kind": "commanddeclaration"}, {"full_name": "List.map_get_sublist", "code": "theorem map_get_sublist {l : List \u03b1} {is : List (Fin l.length)} (h : is.Pairwise (\u00b7.val < \u00b7.val)) :\n    is.map (get l) <+ l", "start": [202, 1], "end": [218, 55], "kind": "commanddeclaration"}, {"full_name": "List.sublist_eq_map_get", "code": "theorem sublist_eq_map_get (h : l' <+ l) : \u2203 is : List (Fin l.length),\n    l' = map (get l) is \u2227 is.Pairwise (\u00b7 < \u00b7)", "start": [220, 1], "end": [234, 34], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_iff_get", "code": "theorem pairwise_iff_get : Pairwise R l \u2194 \u2200 (i j) (_hij : i < j), R (get l i) (get l j)", "start": [236, 1], "end": [247, 29], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_replicate", "code": "theorem pairwise_replicate {\u03b1 : Type _} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {x : \u03b1} (hx : r x x) :\n    \u2200 n : Nat, Pairwise r (List.replicate n x)", "start": [249, 1], "end": [252, 66], "kind": "commanddeclaration"}, {"full_name": "List.pwFilter_nil", "code": "@[simp] theorem pwFilter_nil [DecidableRel R] : pwFilter R [] = []", "start": [256, 1], "end": [256, 74], "kind": "commanddeclaration"}, {"full_name": "List.pwFilter_cons_of_pos", "code": "@[simp] theorem pwFilter_cons_of_pos [DecidableRel (\u03b1 := \u03b1) R] {a : \u03b1} {l : List \u03b1}\n    (h : \u2200 b \u2208 pwFilter R l, R a b) : pwFilter R (a :: l) = a :: pwFilter R l", "start": [258, 1], "end": [259, 90], "kind": "commanddeclaration"}, {"full_name": "List.pwFilter_cons_of_neg", "code": "@[simp] theorem pwFilter_cons_of_neg [DecidableRel (\u03b1 := \u03b1) R] {a : \u03b1} {l : List \u03b1}\n    (h : \u00ac\u2200 b \u2208 pwFilter R l, R a b) : pwFilter R (a :: l) = pwFilter R l", "start": [261, 1], "end": [262, 86], "kind": "commanddeclaration"}, {"full_name": "List.pwFilter_map", "code": "theorem pwFilter_map [DecidableRel (\u03b1 := \u03b1) R] (f : \u03b2 \u2192 \u03b1) :\n    \u2200 l : List \u03b2, pwFilter R (map f l) = map f (pwFilter (fun x y => R (f x) (f y)) l)", "start": [264, 1], "end": [276, 52], "kind": "commanddeclaration"}, {"full_name": "List.pwFilter_sublist", "code": "theorem pwFilter_sublist [DecidableRel (\u03b1 := \u03b1) R] : \u2200 l : List \u03b1, pwFilter R l <+ l", "start": [278, 1], "end": [284, 67], "kind": "commanddeclaration"}, {"full_name": "List.pwFilter_subset", "code": "theorem pwFilter_subset [DecidableRel (\u03b1 := \u03b1) R] (l : List \u03b1) : pwFilter R l \u2286 l", "start": [286, 1], "end": [287, 30], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_pwFilter", "code": "theorem pairwise_pwFilter [DecidableRel (\u03b1 := \u03b1) R] : \u2200 l : List \u03b1, Pairwise R (pwFilter R l)", "start": [289, 1], "end": [295, 51], "kind": "commanddeclaration"}, {"full_name": "List.pwFilter_eq_self", "code": "theorem pwFilter_eq_self [DecidableRel (\u03b1 := \u03b1) R] {l : List \u03b1} :\n    pwFilter R l = l \u2194 Pairwise R l", "start": [297, 1], "end": [306, 18], "kind": "commanddeclaration"}, {"full_name": "List.pwFilter_idem", "code": "@[simp] theorem pwFilter_idem [DecidableRel (\u03b1 := \u03b1) R] :\n    pwFilter R (pwFilter R l) = pwFilter R l", "start": [308, 1], "end": [309, 90], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_pwFilter", "code": "theorem forall_mem_pwFilter [DecidableRel (\u03b1 := \u03b1) R]\n    (neg_trans : \u2200 {x y z}, R x z \u2192 R x y \u2228 R y z) (a : \u03b1) (l : List \u03b1) :\n    (\u2200 b \u2208 pwFilter R l, R a b) \u2194 \u2200 b \u2208 l, R a b", "start": [311, 1], "end": [328, 52], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Classes/RatCast.lean", "imports": ["lake-packages/std/Std/Data/Rat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RatCast", "code": "class RatCast (K : Type u) where\n  \n  protected ratCast : Rat \u2192 K", "start": [8, 1], "end": [11, 30], "kind": "commanddeclaration"}, {"full_name": "Rat.cast", "code": "@[coe, reducible, match_pattern] protected def Rat.cast {K : Type u} [RatCast K] : Rat \u2192 K :=\n  RatCast.ratCast", "start": [15, 1], "end": [18, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Congr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Congr.lean", "lake-packages/std/Std/Tactic/RCases.lean", "lake-packages/std/Std/Tactic/Ext.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.Congr.Config", "code": "structure Congr.Config where\n  \n  closePre : Bool := true\n  \n  closePost : Bool := true", "start": [15, 1], "end": [22, 27], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.rcongrCore", "code": "partial def rcongrCore (g : MVarId) (config : Congr.Config) (pats : List (TSyntax `rcasesPat))\n    (acc : Array MVarId) : TermElabM (Array MVarId) := do\n  let mut acc := acc\n  for (g, qs) in (\u2190 Ext.extCore g pats (failIfUnchanged := false)).2 do\n    let s \u2190 saveState\n    let gs \u2190 g.congrN 1000000 (closePre := config.closePre) (closePost := config.closePost)\n    if \u2190 not <$> g.isAssigned <||> gs.anyM fun g' => return (\u2190 g'.getType).eqv (\u2190 g.getType) then\n      s.restore\n      acc := acc.push g\n    else\n      for g in gs do\n        acc \u2190 rcongrCore g config qs acc\n  pure acc", "start": [59, 1], "end": [75, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/WF.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Acc.wfRel", "code": "private local instance wfRel {r : \u03b1 \u2192 \u03b1 \u2192 Prop} : WellFoundedRelation { val // Acc r val } where\n  rel := InvImage r (\u00b7.1)\n  wf  := \u27e8fun ac => InvImage.accessible _ ac.2\u27e9", "start": [44, 1], "end": [46, 48], "kind": "commanddeclaration"}, {"full_name": "Acc.recC", "code": "@[elab_as_elim] private def recC {motive : (a : \u03b1) \u2192 Acc r a \u2192 Sort v}\n    (intro : (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192\n     ((y : \u03b1) \u2192 (hr : r y x) \u2192 motive y (h y hr)) \u2192 motive x (intro x h))\n    {a : \u03b1} (t : Acc r a) : motive a t :=\n  intro a (fun x h => t.inv h) (fun y hr => recC intro (t.inv hr))\ntermination_by _ a h => Subtype.mk a h", "start": [48, 1], "end": [54, 39], "kind": "commanddeclaration"}, {"full_name": "Acc.recC_intro", "code": "private theorem recC_intro {motive : (a : \u03b1) \u2192 Acc r a \u2192 Sort v}\n    (intro : (x : \u03b1) \u2192 (h : \u2200 (y : \u03b1), r y x \u2192 Acc r y) \u2192\n     ((y : \u03b1) \u2192 (hr : r y x) \u2192 motive y (h y hr)) \u2192 motive x (intro x h))\n    {a : \u03b1} (h : \u2200 (y : \u03b1), r y a \u2192 Acc r y) :\n    recC intro (Acc.intro _ h) = intro a h (fun y hr => recC intro (h y hr))", "start": [56, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Acc.rec_eq_recC", "code": "@[csimp] private theorem rec_eq_recC : @Acc.rec = @Acc.recC", "start": [63, 1], "end": [68, 38], "kind": "commanddeclaration"}, {"full_name": "Acc.ndrecC", "code": "private abbrev ndrecC {C : \u03b1 \u2192 Sort v}\n    (m : (x : \u03b1) \u2192 ((y : \u03b1) \u2192 r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 C y) \u2192 C x)\n    {a : \u03b1} (n : Acc r a) : C a :=\n  n.recC m", "start": [70, 1], "end": [74, 11], "kind": "commanddeclaration"}, {"full_name": "Acc.ndrec_eq_ndrecC", "code": "@[csimp] private theorem ndrec_eq_ndrecC : @Acc.ndrec = @Acc.ndrecC", "start": [76, 1], "end": [78, 42], "kind": "commanddeclaration"}, {"full_name": "Acc.ndrecOnC", "code": "private abbrev ndrecOnC {C : \u03b1 \u2192 Sort v} {a : \u03b1} (n : Acc r a)\n    (m : (x : \u03b1) \u2192 ((y : \u03b1) \u2192 r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 r y x \u2192 C y) \u2192 C x) : C a :=\n  n.recC m", "start": [80, 1], "end": [83, 11], "kind": "commanddeclaration"}, {"full_name": "Acc.ndrecOn_eq_ndrecOnC", "code": "@[csimp] private theorem ndrecOn_eq_ndrecOnC : @Acc.ndrecOn = @Acc.ndrecOnC", "start": [85, 1], "end": [87, 46], "kind": "commanddeclaration"}, {"full_name": "WellFounded.fixFC", "code": "private def fixFC {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    {C : \u03b1 \u2192 Sort v} (F : \u2200 x, (\u2200 y, r y x \u2192 C y) \u2192 C x) (x : \u03b1) (a : Acc r x) : C x := by\n  induction a using Acc.recC with\n  | intro x\u2081 _ ih => exact F x\u2081 ih", "start": [93, 1], "end": [98, 35], "kind": "commanddeclaration"}, {"full_name": "WellFounded.fixF_eq_fixFC", "code": "@[csimp] private theorem fixF_eq_fixFC : @fixF = @fixFC", "start": [100, 1], "end": [102, 36], "kind": "commanddeclaration"}, {"full_name": "WellFounded.fixC", "code": "private def fixC {\u03b1 : Sort u} {C : \u03b1 \u2192 Sort v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hwf : WellFounded r)\n    (F : \u2200 x, (\u2200 y, r y x \u2192 C y) \u2192 C x) (x : \u03b1) : C x :=\n  fixFC F x (apply hwf x)", "start": [104, 1], "end": [107, 26], "kind": "commanddeclaration"}, {"full_name": "WellFounded.fix_eq_fixC", "code": "@[csimp] private theorem fix_eq_fixC : @fix = @fixC", "start": [109, 1], "end": [111, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Replace.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Test/Internal/DummyLabelAttr.lean", "imports": ["lake-packages/std/Std/Tactic/LabelAttr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Data/RBMap/Lemmas.lean", "imports": ["lake-packages/std/Std/Data/List/Lemmas.lean", "lake-packages/std/Std/Data/RBMap/Alter.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.RBNode.depth", "code": "def depth : RBNode \u03b1 \u2192 Nat\n  | nil => 0\n  | node _ a _ b => max a.depth b.depth + 1", "start": [22, 1], "end": [28, 44], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.size_lt_depth", "code": "theorem size_lt_depth : \u2200 t : RBNode \u03b1, t.size < 2 ^ t.depth", "start": [30, 1], "end": [37, 73], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.depthLB", "code": "def depthLB : RBColor \u2192 Nat \u2192 Nat\n  | red, n => n + 1\n  | black, n => n", "start": [39, 1], "end": [45, 18], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.depthLB_le", "code": "theorem depthLB_le : \u2200 c n, n \u2264 depthLB c n", "start": [47, 1], "end": [49, 30], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.depthUB", "code": "def depthUB : RBColor \u2192 Nat \u2192 Nat\n  | red, n => 2 * n + 1\n  | black, n => 2 * n", "start": [51, 1], "end": [57, 22], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.depthUB_le", "code": "theorem depthUB_le : \u2200 c n, depthUB c n \u2264 2 * n + 1", "start": [59, 1], "end": [61, 30], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.depthUB_le_two_depthLB", "code": "theorem depthUB_le_two_depthLB : \u2200 c n, depthUB c n \u2264 2 * depthLB c n", "start": [63, 1], "end": [65, 30], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.depth_le", "code": "theorem Balanced.depth_le : @Balanced \u03b1 t c n \u2192 t.depth \u2264 depthUB c n", "start": [67, 1], "end": [71, 89], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.le_size", "code": "theorem Balanced.le_size : @Balanced \u03b1 t c n \u2192 2 ^ depthLB c n \u2264 t.size + 1", "start": [73, 1], "end": [81, 67], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Balanced.depth_bound", "code": "theorem Balanced.depth_bound (h : @Balanced \u03b1 t c n) : t.depth \u2264 2 * (t.size + 1).log2", "start": [83, 1], "end": [85, 76], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.WF.depth_bound", "code": "theorem WF.depth_bound {t : RBNode \u03b1} (h : t.WF cmp) : t.depth \u2264 2 * (t.size + 1).log2", "start": [87, 1], "end": [92, 42], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.mem_nil", "code": "@[simp] theorem mem_nil {x} : \u00acx \u2208 (.nil : RBNode \u03b1)", "start": [96, 1], "end": [96, 78], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.mem_node", "code": "@[simp] theorem mem_node {y c a x b} :\n    y \u2208 (.node c a x b : RBNode \u03b1) \u2194 y = x \u2228 y \u2208 a \u2228 y \u2208 b", "start": [97, 1], "end": [98, 84], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All_def", "code": "theorem All_def {t : RBNode \u03b1} : t.All p \u2194 \u2200 x \u2208 t, p x", "start": [100, 1], "end": [101, 47], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Any_def", "code": "theorem Any_def {t : RBNode \u03b1} : t.Any p \u2194 \u2203 x \u2208 t, p x", "start": [103, 1], "end": [104, 52], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.memP_def", "code": "theorem memP_def : MemP cut t \u2194 \u2203 x \u2208 t, cut x = .eq", "start": [106, 1], "end": [106, 64], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.mem_def", "code": "theorem mem_def : Mem cmp x t \u2194 \u2203 y \u2208 t, cmp x y = .eq", "start": [108, 1], "end": [108, 66], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.mem_congr", "code": "theorem mem_congr [@TransCmp \u03b1 cmp] {t : RBNode \u03b1} (h : cmp x y = .eq) :\n    Mem cmp x t \u2194 Mem cmp y t", "start": [110, 1], "end": [111, 75], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.isOrdered_iff'", "code": "theorem isOrdered_iff' [@TransCmp \u03b1 cmp] {t : RBNode \u03b1} :\n    isOrdered cmp t L R \u2194\n    (\u2200 a \u2208 L, t.All (cmpLT cmp a \u00b7)) \u2227\n    (\u2200 a \u2208 R, t.All (cmpLT cmp \u00b7 a)) \u2227\n    (\u2200 a \u2208 L, \u2200 b \u2208 R, cmpLT cmp a b) \u2227\n    Ordered cmp t", "start": [113, 1], "end": [133, 67], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.isOrdered_iff", "code": "theorem isOrdered_iff [@TransCmp \u03b1 cmp] {t : RBNode \u03b1} :\n    isOrdered cmp t \u2194 Ordered cmp t", "start": [135, 1], "end": [136, 64], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.IsCut", "code": "class IsCut (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (cut : \u03b1 \u2192 Ordering) : Prop where\n  \n  le_lt_trans [TransCmp cmp] : cmp x y \u2260 .gt \u2192 cut x = .lt \u2192 cut y = .lt\n  \n  le_gt_trans [TransCmp cmp] : cmp x y \u2260 .gt \u2192 cut y = .gt \u2192 cut x = .gt", "start": [140, 1], "end": [150, 73], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.IsCut.lt_trans", "code": "theorem IsCut.lt_trans [IsCut cmp cut] [TransCmp cmp]\n    (H : cmp x y = .lt) : cut x = .lt \u2192 cut y = .lt", "start": [152, 1], "end": [154, 70], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.IsCut.gt_trans", "code": "theorem IsCut.gt_trans [IsCut cmp cut] [TransCmp cmp]\n    (H : cmp x y = .lt) : cut y = .gt \u2192 cut x = .gt", "start": [156, 1], "end": [158, 70], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.IsCut.congr", "code": "theorem IsCut.congr [IsCut cmp cut] [TransCmp cmp] (H : cmp x y = .eq) : cut x = cut y", "start": [160, 1], "end": [168, 65], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.IsStrictCut", "code": "class IsStrictCut (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (cut : \u03b1 \u2192 Ordering) extends IsCut cmp cut : Prop where\n  \n  exact [TransCmp cmp] : cut x = .eq \u2192 cmp x y = cut y", "start": [170, 1], "end": [176, 55], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.find?_some_eq_eq", "code": "theorem find?_some_eq_eq {t : RBNode \u03b1} : x \u2208 t.find? cut \u2192 cut x = .eq", "start": [186, 1], "end": [188, 28], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.find?_some_mem", "code": "theorem find?_some_mem {t : RBNode \u03b1} : x \u2208 t.find? cut \u2192 x \u2208 t", "start": [190, 1], "end": [191, 84], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.find?_some_memP", "code": "theorem find?_some_memP {t : RBNode \u03b1} (h : x \u2208 t.find? cut) : MemP cut t", "start": [193, 1], "end": [194, 55], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.memP_iff_find?", "code": "theorem Ordered.memP_iff_find? [@TransCmp \u03b1 cmp] [IsCut cmp cut] (ht : Ordered cmp t) :\n    MemP cut t \u2194 \u2203 x, t.find? cut = some x", "start": [196, 1], "end": [218, 21], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.unique", "code": "theorem Ordered.unique [@TransCmp \u03b1 cmp] (ht : Ordered cmp t)\n    (hx : x \u2208 t) (hy : y \u2208 t) (e : cmp x y = .eq) : x = y", "start": [220, 1], "end": [236, 25], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.find?_some", "code": "theorem Ordered.find?_some [@TransCmp \u03b1 cmp] [IsStrictCut cmp cut] (ht : Ordered cmp t) :\n    t.find? cut = some x \u2194 x \u2208 t \u2227 cut x = .eq", "start": [238, 1], "end": [242, 98], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.lowerBound?_le'", "code": "theorem lowerBound?_le' {t : RBNode \u03b1} (H : \u2200 {x}, x \u2208 lb \u2192 cut x \u2260 .lt) :\n    t.lowerBound? cut lb = some x \u2192 cut x \u2260 .lt", "start": [248, 1], "end": [257, 57], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.lowerBound?_le", "code": "theorem lowerBound?_le {t : RBNode \u03b1} : t.lowerBound? cut none = some x \u2192 cut x \u2260 .lt", "start": [259, 1], "end": [261, 25], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.lowerBound?_lb", "code": "theorem All.lowerBound?_lb {t : RBNode \u03b1} (hp : t.All p) (H : \u2200 {x}, x \u2208 lb \u2192 p x) :\n    t.lowerBound? cut lb = some x \u2192 p x", "start": [263, 1], "end": [271, 30], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.All.lowerBound?", "code": "theorem All.lowerBound? {t : RBNode \u03b1} (hp : t.All p) : t.lowerBound? cut none = some x \u2192 p x", "start": [273, 1], "end": [274, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.lowerBound?_mem_lb", "code": "theorem lowerBound?_mem_lb {t : RBNode \u03b1}\n    (h : t.lowerBound? cut lb = some x) : x \u2208 t \u2228 x \u2208 lb", "start": [276, 1], "end": [278, 87], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.lowerBound?_mem", "code": "theorem lowerBound?_mem {t : RBNode \u03b1} (h : t.lowerBound? cut none = some x) : x \u2208 t", "start": [280, 1], "end": [281, 46], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.lowerBound?_of_some", "code": "theorem lowerBound?_of_some {t : RBNode \u03b1} : \u2203 x, t.lowerBound? cut (some y) = some x", "start": [283, 1], "end": [284, 72], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.lowerBound?_exists", "code": "theorem Ordered.lowerBound?_exists [@TransCmp \u03b1 cmp] [IsCut cmp cut] (h : Ordered cmp t) :\n    (\u2203 x, t.lowerBound? cut none = some x) \u2194 \u2203 x \u2208 t, cut x \u2260 .lt", "start": [286, 1], "end": [299, 21], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.lowerBound?_least_lb", "code": "theorem Ordered.lowerBound?_least_lb [@TransCmp \u03b1 cmp] [IsCut cmp cut] (h : Ordered cmp t)\n    (hlb : \u2200 {x}, lb = some x \u2192 t.All (cmpLT cmp x \u00b7)) :\n    t.lowerBound? cut lb = some x \u2192 y \u2208 t \u2192 cut x = .gt \u2192 cmp x y = .lt \u2192 cut y = .lt", "start": [301, 1], "end": [321, 39], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.lowerBound?_least", "code": "theorem Ordered.lowerBound?_least [@TransCmp \u03b1 cmp] [IsCut cmp cut] (ht : Ordered cmp t)\n    (H : t.lowerBound? cut none = some x) (hy : y \u2208 t)\n    (xy : cmp x y = .lt) (hx : cut x = .gt) : cut y = .lt", "start": [323, 1], "end": [331, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.memP_iff_lowerBound?", "code": "theorem Ordered.memP_iff_lowerBound? [@TransCmp \u03b1 cmp] [IsCut cmp cut] (ht : Ordered cmp t) :\n    t.MemP cut \u2194 \u2203 x, t.lowerBound? cut none = some x \u2227 cut x = .eq", "start": [333, 1], "end": [343, 75], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.lowerBound?_lt", "code": "theorem Ordered.lowerBound?_lt [@TransCmp \u03b1 cmp] [IsStrictCut cmp cut] (ht : Ordered cmp t)\n    (H : t.lowerBound? cut none = some x) (hy : y \u2208 t) : cmp x y = .lt \u2194 cut y = .lt", "start": [345, 1], "end": [353, 93], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.foldr_cons", "code": "theorem foldr_cons (t : RBNode \u03b1) (l) : t.foldr (\u00b7::\u00b7) l = t.toList ++ l", "start": [359, 1], "end": [363, 74], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.toList_nil", "code": "@[simp] theorem toList_nil : (.nil : RBNode \u03b1).toList = []", "start": [365, 1], "end": [365, 66], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.toList_node", "code": "@[simp] theorem toList_node : (.node c a x b : RBNode \u03b1).toList = a.toList ++ x :: b.toList", "start": [367, 1], "end": [368, 38], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.mem_toList", "code": "@[simp] theorem mem_toList {t : RBNode \u03b1} : x \u2208 t.toList \u2194 x \u2208 t", "start": [370, 1], "end": [371, 41], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.foldr_eq_foldr_toList", "code": "theorem foldr_eq_foldr_toList {t : RBNode \u03b1} : t.foldr f init = t.toList.foldr f init", "start": [373, 1], "end": [374, 45], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.foldl_eq_foldl_toList", "code": "theorem foldl_eq_foldl_toList {t : RBNode \u03b1} : t.foldl f init = t.toList.foldl f init", "start": [376, 1], "end": [377, 45], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.forM_eq_forM_toList", "code": "theorem forM_eq_forM_toList [Monad m] [LawfulMonad m] {t : RBNode \u03b1} :\n    t.forM (m := m) f = t.toList.forM f", "start": [379, 1], "end": [380, 71], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.foldlM_eq_foldlM_toList", "code": "theorem foldlM_eq_foldlM_toList [Monad m] [LawfulMonad m] {t : RBNode \u03b1} :\n    t.foldlM (m := m) f init = t.toList.foldlM f init", "start": [382, 1], "end": [384, 45], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.forIn_visit_eq_bindList", "code": "theorem forIn_visit_eq_bindList [Monad m] [LawfulMonad m] {t : RBNode \u03b1} :\n    forIn.visit (m := m) f t init = (ForInStep.yield init).bindList f t.toList", "start": [386, 1], "end": [388, 58], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.forIn_eq_forIn_toList", "code": "theorem forIn_eq_forIn_toList [Monad m] [LawfulMonad m] {t : RBNode \u03b1} :\n    forIn (m := m) t init f = forIn t.toList init f", "start": [390, 1], "end": [392, 83], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.foldr_cons", "code": "theorem foldr_cons (t : RBNode.Stream \u03b1) (l) : t.foldr (\u00b7::\u00b7) l = t.toList ++ l", "start": [400, 1], "end": [401, 83], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.toList_nil", "code": "@[simp] theorem toList_nil : (.nil : RBNode.Stream \u03b1).toList = []", "start": [403, 1], "end": [403, 73], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.toList_cons", "code": "@[simp] theorem toList_cons :\n    (.cons x r s : RBNode.Stream \u03b1).toList = x :: r.toList ++ s.toList", "start": [405, 1], "end": [407, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.foldr_eq_foldr_toList", "code": "theorem foldr_eq_foldr_toList {s : RBNode.Stream \u03b1} : s.foldr f init = s.toList.foldr f init", "start": [409, 1], "end": [410, 57], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.foldl_eq_foldl_toList", "code": "theorem foldl_eq_foldl_toList {t : RBNode.Stream \u03b1} : t.foldl f init = t.toList.foldl f init", "start": [412, 1], "end": [413, 75], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.forIn_eq_forIn_toList", "code": "theorem forIn_eq_forIn_toList [Monad m] [LawfulMonad m] {t : RBNode \u03b1} :\n    forIn (m := m) t init f = forIn t.toList init f", "start": [415, 1], "end": [417, 83], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.toStream_toList'", "code": "theorem toStream_toList' {t : RBNode \u03b1} {s} : (t.toStream s).toList = t.toList ++ s.toList", "start": [421, 1], "end": [422, 52], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.toStream_toList", "code": "@[simp] theorem toStream_toList {t : RBNode \u03b1} : t.toStream.toList = t.toList", "start": [424, 1], "end": [425, 26], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Stream.next?_toList", "code": "theorem Stream.next?_toList {s : RBNode.Stream \u03b1} :\n    (s.next?.map fun (a, b) => (a, b.toList)) = s.toList.next?", "start": [427, 1], "end": [429, 45], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.ordered_iff", "code": "theorem ordered_iff {t : RBNode \u03b1} :\n    t.Ordered cmp \u2194 t.toList.Pairwise (cmpLT cmp)", "start": [431, 1], "end": [438, 63], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Ordered.toList_sorted", "code": "theorem Ordered.toList_sorted {t : RBNode \u03b1} : t.Ordered cmp \u2192 t.toList.Pairwise (cmpLT cmp)", "start": [440, 1], "end": [441, 16], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.setBlack_toList", "code": "@[simp] theorem setBlack_toList {t : RBNode \u03b1} : t.setBlack.toList = t.toList", "start": [443, 1], "end": [444, 30], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.setRed_toList", "code": "@[simp] theorem setRed_toList {t : RBNode \u03b1} : t.setRed.toList = t.toList", "start": [446, 1], "end": [447, 28], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balance1_toList", "code": "@[simp] theorem balance1_toList {l : RBNode \u03b1} {v r} :\n    (l.balance1 v r).toList = l.toList ++ v :: r.toList", "start": [449, 1], "end": [451, 34], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balance2_toList", "code": "@[simp] theorem balance2_toList {l : RBNode \u03b1} {v r} :\n    (l.balance2 v r).toList = l.toList ++ v :: r.toList", "start": [453, 1], "end": [455, 34], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balLeft_toList", "code": "@[simp] theorem balLeft_toList {l : RBNode \u03b1} {v r} :\n    (l.balLeft v r).toList = l.toList ++ v :: r.toList", "start": [457, 1], "end": [459, 55], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.balRight_toList", "code": "@[simp] theorem balRight_toList {l : RBNode \u03b1} {v r} :\n    (l.balRight v r).toList = l.toList ++ v :: r.toList", "start": [461, 1], "end": [463, 56], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.size_eq", "code": "theorem size_eq {t : RBNode \u03b1} : t.size = t.toList.length", "start": [465, 1], "end": [466, 38], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.listL", "code": "@[simp] def listL : Path \u03b1 \u2192 List \u03b1\n  | .root => []\n  | .left _ parent _ _ => parent.listL\n  | .right _ l v parent => parent.listL ++ (l.toList ++ [v])", "start": [472, 1], "end": [477, 61], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.listR", "code": "@[simp] def listR : Path \u03b1 \u2192 List \u03b1\n  | .root => []\n  | .left _ parent v r => v :: r.toList ++ parent.listR\n  | .right _ _ _ parent => parent.listR", "start": [479, 1], "end": [484, 40], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.withList", "code": "abbrev withList (p : Path \u03b1) (l : List \u03b1) : List \u03b1 := p.listL ++ l ++ p.listR", "start": [486, 1], "end": [487, 78], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.rootOrdered_iff", "code": "theorem rootOrdered_iff {p : Path \u03b1} (hp : p.Ordered cmp) :\n    p.RootOrdered cmp v \u2194 (\u2200 a \u2208 p.listL, cmpLT cmp a v) \u2227 (\u2200 a \u2208 p.listR, cmpLT cmp v a)", "start": [489, 1], "end": [494, 72], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.ordered_iff", "code": "theorem ordered_iff {p : Path \u03b1} :\n    p.Ordered cmp \u2194 p.listL.Pairwise (cmpLT cmp) \u2227 p.listR.Pairwise (cmpLT cmp) \u2227\n      \u2200 x \u2208 p.listL, \u2200 y \u2208 p.listR, cmpLT cmp x y", "start": [496, 1], "end": [515, 78], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.fill_toList", "code": "@[simp] theorem fill_toList {p : Path \u03b1} : (p.fill t).toList = p.withList t.toList", "start": [517, 1], "end": [518, 42], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.zoom_toList", "code": "theorem _root_.Std.RBNode.zoom_toList {t : RBNode \u03b1} (eq : t.zoom cut = (t', p')) :\n    p'.withList t'.toList = t.toList", "start": [520, 1], "end": [521, 83], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.ins_toList", "code": "@[simp] theorem ins_toList {p : Path \u03b1} : (p.ins t).toList = p.withList t.toList", "start": [523, 1], "end": [526, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.insertNew_toList", "code": "@[simp] theorem insertNew_toList {p : Path \u03b1} : (p.insertNew v).toList = p.withList [v]", "start": [528, 1], "end": [529, 19], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.Path.insert_toList", "code": "theorem insert_toList {p : Path \u03b1} :\n    (p.insert t v).toList = p.withList (t.setRoot v).toList", "start": [531, 1], "end": [533, 42], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.insert_toList_zoom", "code": "theorem insert_toList_zoom {t : RBNode \u03b1} (ht : Balanced t c n)\n    (e : zoom (cmp v) t = (t', p)) :\n    (t.insert cmp v).toList = p.withList (t'.setRoot v).toList", "start": [537, 1], "end": [540, 87], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.insert_toList_zoom_nil", "code": "theorem insert_toList_zoom_nil {t : RBNode \u03b1} (ht : Balanced t c n)\n    (e : zoom (cmp v) t = (nil, p)) :\n    (t.insert cmp v).toList = p.withList [v]", "start": [542, 1], "end": [544, 72], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.exists_insert_toList_zoom_nil", "code": "theorem exists_insert_toList_zoom_nil {t : RBNode \u03b1} (ht : Balanced t c n)\n    (e : zoom (cmp v) t = (nil, p)) :\n    \u2203 L R, t.toList = L ++ R \u2227 (t.insert cmp v).toList = L ++ v :: R", "start": [546, 1], "end": [549, 77], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.insert_toList_zoom_node", "code": "theorem insert_toList_zoom_node {t : RBNode \u03b1} (ht : Balanced t c n)\n    (e : zoom (cmp v) t = (node c' l v' r, p)) :\n    (t.insert cmp v).toList = p.withList (node c l v r).toList", "start": [551, 1], "end": [553, 90], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.exists_insert_toList_zoom_node", "code": "theorem exists_insert_toList_zoom_node {t : RBNode \u03b1} (ht : Balanced t c n)\n    (e : zoom (cmp v) t = (node c' l v' r, p)) :\n    \u2203 L R, t.toList = L ++ v' :: R \u2227 (t.insert cmp v).toList = L ++ v :: R", "start": [555, 1], "end": [559, 55], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.mem_insert_self", "code": "theorem mem_insert_self {t : RBNode \u03b1} (ht : Balanced t c n) : v \u2208 t.insert cmp v", "start": [561, 1], "end": [565, 87], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.mem_insert_of_mem", "code": "theorem mem_insert_of_mem {t : RBNode \u03b1} (ht : Balanced t c n) (h : v' \u2208 t) :\n    v' \u2208 t.insert cmp v \u2228 cmp v v' = .eq", "start": [567, 1], "end": [578, 37], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.exists_find?_insert_self", "code": "theorem exists_find?_insert_self [@TransCmp \u03b1 cmp] [IsCut cmp cut]\n    {t : RBNode \u03b1} (ht : Balanced t c n) (ht\u2082 : Ordered cmp t) (hv : cut v = .eq) :\n    \u2203 x, (t.insert cmp v).find? cut = some x", "start": [580, 1], "end": [583, 72], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.find?_insert_self", "code": "theorem find?_insert_self [@TransCmp \u03b1 cmp] [IsStrictCut cmp cut]\n    {t : RBNode \u03b1} (ht : Balanced t c n) (ht\u2082 : Ordered cmp t) (hv : cut v = .eq) :\n    (t.insert cmp v).find? cut = some v", "start": [585, 1], "end": [588, 51], "kind": "commanddeclaration"}, {"full_name": "Std.RBNode.mem_insert", "code": "theorem mem_insert [@TransCmp \u03b1 cmp] {t : RBNode \u03b1} (ht : Balanced t c n) (ht\u2082 : Ordered cmp t) :\n    v' \u2208 t.insert cmp v \u2194 (v' \u2208 t \u2227 t.find? (cmp v) \u2260 some v') \u2228 v' = v", "start": [590, 1], "end": [610, 33], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.val_toList", "code": "@[simp] theorem val_toList {t : RBSet \u03b1 cmp} : t.1.toList = t.toList", "start": [616, 1], "end": [616, 76], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mkRBSet_eq", "code": "@[simp] theorem mkRBSet_eq : mkRBSet \u03b1 cmp = \u2205", "start": [618, 1], "end": [618, 54], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.empty_eq", "code": "@[simp] theorem empty_eq : @RBSet.empty \u03b1 cmp = \u2205", "start": [619, 1], "end": [619, 57], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.default_eq", "code": "@[simp] theorem default_eq : (default : RBSet \u03b1 cmp) = \u2205", "start": [620, 1], "end": [620, 64], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.empty_toList", "code": "@[simp] theorem empty_toList : toList (\u2205 : RBSet \u03b1 cmp) = []", "start": [621, 1], "end": [621, 68], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.single_toList", "code": "@[simp] theorem single_toList : toList (single a : RBSet \u03b1 cmp) = [a]", "start": [622, 1], "end": [622, 77], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_toList", "code": "theorem mem_toList {t : RBSet \u03b1 cmp} : x \u2208 toList t \u2194 x \u2208 t.1", "start": [624, 1], "end": [624, 83], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_congr", "code": "theorem mem_congr [@TransCmp \u03b1 cmp] {t : RBSet \u03b1 cmp} (h : cmp x y = .eq) : x \u2208 t \u2194 y \u2208 t", "start": [626, 1], "end": [627, 21], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_iff_mem_toList", "code": "theorem mem_iff_mem_toList {t : RBSet \u03b1 cmp} : x \u2208 t \u2194 \u2203 y \u2208 toList t, cmp x y = .eq", "start": [629, 1], "end": [630, 47], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_of_mem_toList", "code": "theorem mem_of_mem_toList [@OrientedCmp \u03b1 cmp] {t : RBSet \u03b1 cmp} (h : x \u2208 toList t) : x \u2208 t", "start": [632, 1], "end": [633, 52], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.foldl_eq_foldl_toList", "code": "theorem foldl_eq_foldl_toList {t : RBSet \u03b1 cmp} : t.foldl f init = t.toList.foldl f init", "start": [635, 1], "end": [636, 31], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.foldr_eq_foldr_toList", "code": "theorem foldr_eq_foldr_toList {t : RBSet \u03b1 cmp} : t.foldr f init = t.toList.foldr f init", "start": [638, 1], "end": [639, 31], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.foldlM_eq_foldlM_toList", "code": "theorem foldlM_eq_foldlM_toList [Monad m] [LawfulMonad m] {t : RBSet \u03b1 cmp} :\n    t.foldlM (m := m) f init = t.toList.foldlM f init", "start": [641, 1], "end": [642, 88], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.forIn_eq_forIn_toList", "code": "theorem forIn_eq_forIn_toList [Monad m] [LawfulMonad m] {t : RBSet \u03b1 cmp} :\n    forIn (m := m) t init f = forIn t.toList init f", "start": [644, 1], "end": [645, 84], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.toStream_eq", "code": "theorem toStream_eq {t : RBSet \u03b1 cmp} : toStream t = t.1.toStream .nil", "start": [647, 1], "end": [647, 78], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.toStream_toList", "code": "@[simp] theorem toStream_toList {t : RBSet \u03b1 cmp} : (toStream t).toList = t.toList", "start": [649, 1], "end": [650, 21], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.toList_sorted", "code": "theorem toList_sorted {t : RBSet \u03b1 cmp} : t.toList.Pairwise (RBNode.cmpLT cmp)", "start": [652, 1], "end": [653, 26], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find?_some_eq_eq", "code": "theorem find?_some_eq_eq {t : RBSet \u03b1 cmp} : t.find? x = some y \u2192 cmp x y = .eq", "start": [655, 1], "end": [656, 26], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find?_some_mem_toList", "code": "theorem find?_some_mem_toList {t : RBSet \u03b1 cmp} (h : t.find? x = some y) : y \u2208 toList t", "start": [658, 1], "end": [659, 42], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find?_some_mem", "code": "theorem find?_some_mem {t : RBSet \u03b1 cmp} (h : t.find? x = some y) : x \u2208 t", "start": [661, 1], "end": [662, 27], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_toList_unique", "code": "theorem mem_toList_unique [@TransCmp \u03b1 cmp] {t : RBSet \u03b1 cmp}\n    (hx : x \u2208 toList t) (hy : y \u2208 toList t) (e : cmp x y = .eq) : x = y", "start": [664, 1], "end": [666, 57], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find?_some", "code": "theorem find?_some [@TransCmp \u03b1 cmp] {t : RBSet \u03b1 cmp} :\n    t.find? x = some y \u2194 y \u2208 toList t \u2227 cmp x y = .eq", "start": [668, 1], "end": [670, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_iff_find?", "code": "theorem mem_iff_find? [@TransCmp \u03b1 cmp] {t : RBSet \u03b1 cmp} :\n    x \u2208 t \u2194 \u2203 y, t.find? x = some y", "start": [672, 1], "end": [673, 64], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.contains_iff", "code": "@[simp] theorem contains_iff [@TransCmp \u03b1 cmp] {t : RBSet \u03b1 cmp} :\n    t.contains x \u2194 x \u2208 t", "start": [675, 1], "end": [676, 78], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.size_eq", "code": "theorem size_eq (t : RBSet \u03b1 cmp) : t.size = t.toList.length", "start": [680, 1], "end": [680, 79], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_toList_insert_self", "code": "theorem mem_toList_insert_self (v) (t : RBSet \u03b1 cmp) : v \u2208 toList (t.insert v)", "start": [682, 1], "end": [683, 70], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_insert_self", "code": "theorem mem_insert_self [@OrientedCmp \u03b1 cmp] (v) (t : RBSet \u03b1 cmp) : v \u2208 t.insert v", "start": [685, 1], "end": [686, 50], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_insert_of_eq", "code": "theorem mem_insert_of_eq [@TransCmp \u03b1 cmp] (t : RBSet \u03b1 cmp) (h : cmp v v' = .eq) :\n    v' \u2208 t.insert v", "start": [688, 1], "end": [689, 60], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_toList_insert_of_mem", "code": "theorem mem_toList_insert_of_mem (v) {t : RBSet \u03b1 cmp} (h : v' \u2208 toList t) :\n    v' \u2208 toList (t.insert v) \u2228 cmp v v' = .eq", "start": [691, 1], "end": [694, 74], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_insert_of_mem_toList", "code": "theorem mem_insert_of_mem_toList [@OrientedCmp \u03b1 cmp] (v) {t : RBSet \u03b1 cmp} (h : v' \u2208 toList t) :\n    v' \u2208 t.insert v", "start": [696, 1], "end": [700, 100], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_insert_of_mem", "code": "theorem mem_insert_of_mem [@TransCmp \u03b1 cmp] (v) {t : RBSet \u03b1 cmp} (h : v' \u2208 t) : v' \u2208 t.insert v", "start": [702, 1], "end": [704, 51], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_toList_insert", "code": "theorem mem_toList_insert [@TransCmp \u03b1 cmp] {t : RBSet \u03b1 cmp} :\n    v' \u2208 toList (t.insert v) \u2194 (v' \u2208 toList t \u2227 t.find? v \u2260 some v') \u2228 v' = v", "start": [706, 1], "end": [709, 53], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.mem_insert", "code": "theorem mem_insert [@TransCmp \u03b1 cmp] {t : RBSet \u03b1 cmp} :\n    v' \u2208 t.insert v \u2194 v' \u2208 t \u2228 cmp v v' = .eq", "start": [711, 1], "end": [717, 62], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find?_congr", "code": "theorem find?_congr [@TransCmp \u03b1 cmp] (t : RBSet \u03b1 cmp) (h : cmp v\u2081 v\u2082 = .eq) :\n    t.find? v\u2081 = t.find? v\u2082", "start": [719, 1], "end": [720, 75], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find?_insert_of_eq", "code": "theorem find?_insert_of_eq [@TransCmp \u03b1 cmp] (t : RBSet \u03b1 cmp) (h : cmp v' v = .eq) :\n    (t.insert v).find? v' = some v", "start": [722, 1], "end": [724, 46], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find?_insert_of_ne", "code": "theorem find?_insert_of_ne [@TransCmp \u03b1 cmp] (t : RBSet \u03b1 cmp) (h : cmp v' v \u2260 .eq) :\n    (t.insert v).find? v' = t.find? v'", "start": [726, 1], "end": [732, 30], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.find?_insert", "code": "theorem find?_insert [@TransCmp \u03b1 cmp] (t : RBSet \u03b1 cmp) (v v') :\n    (t.insert v).find? v' = if cmp v' v = .eq then some v else t.find? v'", "start": [734, 1], "end": [736, 77], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/RBMap.lean", "imports": ["lake-packages/std/Std/Data/RBMap/Basic.lean", "lake-packages/std/Std/Data/RBMap/WF.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Data/DList.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.DList", "code": "structure DList (\u03b1 : Type u) where\n  \n  apply     : List \u03b1 \u2192 List \u03b1\n  \n  invariant : \u2200 l, apply l = apply [] ++ l", "start": [7, 1], "end": [17, 43], "kind": "commanddeclaration"}, {"full_name": "Std.DList.ofList", "code": "def ofList (l : List \u03b1) : DList \u03b1 :=\n  \u27e8(l ++ \u00b7), fun t => by simp\u27e9", "start": [23, 1], "end": [25, 31], "kind": "commanddeclaration"}, {"full_name": "Std.DList.empty", "code": "def empty : DList \u03b1 :=\n  \u27e8id, fun _ => rfl\u27e9", "start": [27, 1], "end": [29, 21], "kind": "commanddeclaration"}, {"full_name": "Std.DList.toList", "code": "def toList : DList \u03b1 \u2192 List \u03b1\n  | \u27e8f, _\u27e9 => f []", "start": [33, 1], "end": [35, 19], "kind": "commanddeclaration"}, {"full_name": "Std.DList.singleton", "code": "def singleton (a : \u03b1) : DList \u03b1 where\n  apply     := fun t => a :: t\n  invariant := fun _ => rfl", "start": [37, 1], "end": [40, 28], "kind": "commanddeclaration"}, {"full_name": "Std.DList.cons", "code": "def cons : \u03b1 \u2192 DList \u03b1 \u2192 DList \u03b1\n  | a, \u27e8f, h\u27e9 => {\n    apply     := fun t => a :: f t\n    invariant := by intro t; simp; rw [h]\n  }", "start": [42, 1], "end": [47, 4], "kind": "commanddeclaration"}, {"full_name": "Std.DList.append", "code": "def append : DList \u03b1 \u2192 DList \u03b1 \u2192 DList \u03b1\n  | \u27e8f, h\u2081\u27e9, \u27e8g, h\u2082\u27e9 => {\n    apply     := f \u2218 g\n    invariant := by\n      intro t\n      show f (g t) = (f (g [])) ++ t\n      rw [h\u2081 (g t), h\u2082 t, \u2190 append_assoc (f []) (g []) t, \u2190 h\u2081 (g [])]\n    }", "start": [49, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "Std.DList.push", "code": "def push : DList \u03b1 \u2192 \u03b1 \u2192 DList \u03b1\n  | \u27e8f, h\u27e9, a => {\n    apply     := fun t => f (a :: t)\n    invariant := by\n      intro t\n      show f (a :: t) = f (a :: nil) ++ t\n      rw [h [a], h (a::t), append_assoc (f []) [a] t]\n      rfl\n  }", "start": [59, 1], "end": [68, 4], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/HashMap.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.HashMap.mergeWithM", "code": "@[specialize]\ndef mergeWithM {m \u03b1 \u03b2} [BEq \u03b1] [Hashable \u03b1] [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 m \u03b2)\n    (self other : HashMap \u03b1 \u03b2) : m (HashMap \u03b1 \u03b2) :=\n  other.foldM (init := self) fun map k v\u2082 =>\n    match map.find? k with\n    | none => return map.insert k v\u2082\n    | some v\u2081 => return map.insert k (\u2190 f k v\u2081 v\u2082)", "start": [23, 1], "end": [33, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.mergeWith", "code": "@[inline]\ndef mergeWith (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2) (self other : HashMap \u03b1 \u03b2) : HashMap \u03b1 \u03b2 :=\n  other.fold (init := self) fun map k v\u2082 =>\n    match map.find? k with\n    | none => map.insert k v\u2082\n    | some v\u2081 => map.insert k <| f k v\u2081 v\u2082", "start": [35, 1], "end": [46, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Util/Path.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Tactic/PrintDependents.lean", "imports": ["lake-packages/std/Std/Lean/Delaborator.lean", "lake-packages/lean4/src/lean/Lean/Util/FoldConsts.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.CollectDependents.State", "code": "structure State where\n  \n  otherAxiom : Bool := true\n  \n  result : NameMap Bool := {}", "start": [23, 1], "end": [28, 30], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.CollectDependents.M", "code": "abbrev M := ReaderT Environment $ StateM State", "start": [30, 1], "end": [31, 47], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.CollectDependents.mkState", "code": "def mkState (cs : Array (Name \u00d7 Bool)) (otherAxiom := true) : State :=\n  { otherAxiom, result := cs.foldl (fun r (c, b) => r.insert c b) {} }", "start": [33, 1], "end": [40, 71], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.CollectDependents.collect", "code": "partial def collect (c : Name) : M Bool := do\n  let collectExpr (e : Expr) : M Bool := e.getUsedConstants.anyM collect\n  let s \u2190 get\n  if let some b := s.result.find? c then return b\n  modify fun s => { s with result := s.result.insert c false }\n  let env \u2190 read\n  let r \u2190 match env.find? c with\n    | some (ConstantInfo.axiomInfo _)  => pure s.otherAxiom\n    | some (ConstantInfo.defnInfo v)   => collectExpr v.type <||> collectExpr v.value\n    | some (ConstantInfo.thmInfo v)    => collectExpr v.type <||> collectExpr v.value\n    | some (ConstantInfo.opaqueInfo v) => collectExpr v.type <||> collectExpr v.value\n    | some (ConstantInfo.quotInfo _)   => pure false\n    | some (ConstantInfo.ctorInfo v)   => collectExpr v.type\n    | some (ConstantInfo.recInfo v)    => collectExpr v.type\n    | some (ConstantInfo.inductInfo v) => collectExpr v.type <||> v.ctors.anyM collect\n    | none                             => pure false\n  modify fun s => { s with result := s.result.insert c r }\n  pure r", "start": [42, 1], "end": [60, 9], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Rat.lean", "imports": ["lake-packages/std/Std/Data/Rat/Basic.lean", "lake-packages/std/Std/Data/Rat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Data/BinomialHeap.lean", "imports": ["lake-packages/std/Std/Data/BinomialHeap/Lemmas.lean", "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Lean/Meta.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/List/Count.lean", "lake-packages/std/Std/Data/Option/Basic.lean"], "premises": [{"full_name": "Lean.MVarId.synthInstance", "code": "def synthInstance (g : MVarId) : MetaM Unit := do\n  g.assign (\u2190 Lean.Meta.synthInstance (\u2190 g.getType))", "start": [20, 1], "end": [23, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.note", "code": "def note (g : MVarId) (h : Name) (v : Expr) (t : Option Expr := .none) :\n    MetaM (FVarId \u00d7 MVarId) := do\n  (\u2190 g.assert h (\u2190 t.getDM (inferType v)) v).intro1P", "start": [25, 1], "end": [28, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.let", "code": "def \u00ablet\u00bb (g : MVarId) (h : Name) (v : Expr) (t : Option Expr := .none) :\n    MetaM (FVarId \u00d7 MVarId) := do\n  (\u2190 g.define h (\u2190 t.getDM (inferType v)) v).intro1P", "start": [30, 1], "end": [33, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.applyConst", "code": "def applyConst (mvar : MVarId) (c : Name) (cfg : ApplyConfig := {}) : MetaM (List MVarId) := do\n  mvar.apply (\u2190 mkConstWithFreshMVarLevels c) cfg", "start": [35, 1], "end": [37, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.existsi", "code": "def existsi (mvar : MVarId) (es : List Expr) : MetaM MVarId := do\n  es.foldlM (\u03bb mv e => do\n      let (subgoals,_) \u2190 Elab.Term.TermElabM.run $ Elab.Tactic.run mv do\n        Elab.Tactic.evalTactic (\u2190`(tactic| refine \u27e8?_,?_\u27e9))\n      let [sg1, sg2] := subgoals | throwError \"expected two subgoals\"\n      sg1.assign e\n      pure sg2)\n    mvar", "start": [39, 1], "end": [48, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.intros!", "code": "partial def intros! (mvarId : MVarId) : MetaM (Array FVarId \u00d7 MVarId) :=\n  run #[] mvarId\n  where\n  \n  run (acc : Array FVarId) (g : MVarId) :=\n  try\n    let \u27e8f, g\u27e9 \u2190 mvarId.intro1\n    run (acc.push f) g\n  catch _ =>\n    pure (acc, g)", "start": [50, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.subsingleton?", "code": "def subsingleton? (g : MVarId) : MetaM Bool := do\n  try\n    _ \u2190 Lean.Meta.synthInstance (\u2190 mkAppM `Subsingleton #[\u2190 g.getType])\n    return true\n  catch _ =>\n    return false", "start": [65, 1], "end": [71, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.independent?", "code": "def independent? (L : List MVarId) (g : MVarId) : MetaM Bool := do\n  let t \u2190 instantiateMVars (\u2190 g.getType)\n  if t.hasExprMVar then\n    return false\n  if t.isProp then\n    return true\n  if \u2190 g.subsingleton? then\n    return true\n  L.allM fun g' => do\n    let mvars \u2190 Meta.getMVars (\u2190 g'.getType)\n    pure <| !(mvars.contains g)", "start": [73, 1], "end": [96, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.iffOfEq", "code": "def iffOfEq (mvarId : MVarId) : MetaM MVarId := do\n  let res \u2190 observing? do\n    let [mvarId] \u2190 mvarId.apply (mkConst ``iff_of_eq []) | failure\n    return mvarId\n  return res.getD mvarId", "start": [98, 1], "end": [108, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.propext", "code": "def propext (mvarId : MVarId) : MetaM MVarId := do\n  let res \u2190 observing? do\n    let tgt \u2190 withReducible mvarId.getType'\n    let some (ty, _, _) := tgt.eq? | failure\n    guard ty.isProp\n    let [mvarId] \u2190 mvarId.apply (mkConst ``propext []) | failure\n    return mvarId\n  return res.getD mvarId", "start": [110, 1], "end": [123, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.proofIrrelHeq", "code": "def proofIrrelHeq (mvarId : MVarId) : MetaM Bool :=\n  mvarId.withContext do\n    let res \u2190 observing? do\n      mvarId.checkNotAssigned `proofIrrelHeq\n      let tgt \u2190 withReducible mvarId.getType'\n      let some (_, lhs, _, rhs) := tgt.heq? | failure\n      let pf \u2190 mkAppM ``proof_irrel_heq #[lhs, rhs]\n      mvarId.assign pf\n      return true\n    return res.getD false", "start": [125, 1], "end": [141, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.subsingletonElim", "code": "def subsingletonElim (mvarId : MVarId) : MetaM Bool :=\n  mvarId.withContext do\n    let res \u2190 observing? do\n      mvarId.checkNotAssigned `subsingletonElim\n      let tgt \u2190 withReducible mvarId.getType'\n      let some (_, lhs, rhs) := tgt.eq? | failure\n      let pf \u2190 mkAppM ``Subsingleton.elim #[lhs, rhs]\n      mvarId.assign pf\n      return true\n    return res.getD false", "start": [143, 1], "end": [160, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getLocalHyps", "code": "def getLocalHyps [Monad m] [MonadLCtx m] : m (Array Expr) := do\n  let mut hs := #[]\n  for d in \u2190 getLCtx do\n    if !d.isImplementationDetail then hs := hs.push d.toExpr\n  return hs", "start": [166, 1], "end": [171, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.countLocalHypsUsed", "code": "def countLocalHypsUsed [Monad m] [MonadLCtx m] [MonadMCtx m] (e : Expr) : m Nat := do\n  let e' \u2190 instantiateMVars e\n  return (\u2190 getLocalHyps).toList.countP fun h => h.occurs e'", "start": [173, 1], "end": [176, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mapForallTelescope'", "code": "def mapForallTelescope' (F : Expr \u2192 Expr \u2192 MetaM Expr) (forallTerm : Expr) : MetaM Expr := do\n  forallTelescope (\u2190 Meta.inferType forallTerm) fun xs ty => do\n    Meta.mkLambdaFVars xs (\u2190 F ty (mkAppN forallTerm xs))", "start": [178, 1], "end": [185, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mapForallTelescope", "code": "def mapForallTelescope (F : Expr \u2192 MetaM Expr) (forallTerm : Expr) : MetaM Expr := do\n  mapForallTelescope' (fun _ e => F e) forallTerm", "start": [187, 1], "end": [193, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.getType''", "code": "def _root_.Lean.MVarId.getType'' (mvarId : MVarId) : MetaM Expr :=\n  return (\u2190 instantiateMVars (\u2190 mvarId.getType)).cleanupAnnotations", "start": [196, 1], "end": [199, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.liftMetaTactic'", "code": "def liftMetaTactic' (tac : MVarId \u2192 MetaM MVarId) : TacticM Unit :=\n  liftMetaTactic fun g => do pure [\u2190 tac g]", "start": [205, 1], "end": [209, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.TacticM.runCore", "code": "@[inline] private def TacticM.runCore (x : TacticM \u03b1) (ctx : Context) (s : State) :\n    TermElabM (\u03b1 \u00d7 State) :=\n  x ctx |>.run s", "start": [211, 1], "end": [213, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.TacticM.runCore'", "code": "@[inline] private def TacticM.runCore' (x : TacticM \u03b1) (ctx : Context) (s : State) : TermElabM \u03b1 :=\n  Prod.fst <$> x.runCore ctx s", "start": [215, 1], "end": [216, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.run_for", "code": "def run_for (mvarId : MVarId) (x : TacticM \u03b1) : TermElabM (Option \u03b1 \u00d7 List MVarId) :=\n  mvarId.withContext do\n   let pendingMVarsSaved := (\u2190 get).pendingMVars\n   modify fun s => { s with pendingMVars := [] }\n   let aux : TacticM (Option \u03b1 \u00d7 List MVarId) :=\n     \n     try\n       let a \u2190 x\n       pure (a, \u2190 getUnsolvedGoals)\n     catch ex =>\n       if isAbortTacticException ex then\n         pure (none, \u2190 getUnsolvedGoals)\n       else\n         throw ex\n   try\n     aux.runCore' { elaborator := .anonymous } { goals := [mvarId] }\n   finally\n     modify fun s => { s with pendingMVars := pendingMVarsSaved }", "start": [218, 1], "end": [241, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Expr/Traverse.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.traverseChildren", "code": "def traverseChildren [Applicative M] (f : Expr \u2192 M Expr) : Expr \u2192 M Expr\n  | e@(forallE _ d b _) => pure e.updateForallE! <*> f d <*> f b\n  | e@(lam _ d b _)     => pure e.updateLambdaE! <*> f d <*> f b\n  | e@(mdata _ b)       => e.updateMData! <$> f b\n  | e@(letE _ t v b _)  => pure e.updateLet! <*> f t <*> f v <*> f b\n  | e@(app l r)         => pure e.updateApp! <*> f l <*> f r\n  | e@(proj _ _ b)      => e.updateProj! <$> f b\n  | e                   => pure e", "start": [18, 1], "end": [26, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.foldlM", "code": "def foldlM {\u03b1 : Type} {m} [Monad m] (f : \u03b1 \u2192 Expr \u2192 m \u03b1) (x : \u03b1) (e : Expr) : m \u03b1 :=\n  Prod.snd <$> (StateT.run (e.traverseChildren $ fun e' =>\n      Functor.mapConst e' (get >>= monadLift \u2218 flip f e' >>= set)) x : m _)", "start": [28, 1], "end": [32, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/MemoFix.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ObjectMap", "code": "private unsafe abbrev ObjectMap := @Lean.HashMap Object Object \u27e8Object.ptrEq\u27e9 \u27e8Object.hash\u27e9", "start": [17, 1], "end": [17, 92], "kind": "commanddeclaration"}, {"full_name": "memoFixImplObj", "code": "private unsafe def memoFixImplObj (f : (Object \u2192 Object) \u2192 (Object \u2192 Object)) (a : Object) :\n    Object := unsafeBaseIO do\n  let cache : IO.Ref ObjectMap \u2190 ST.mkRef \u2205\n  let rec fix (a) := unsafeBaseIO do\n    if let some b := (\u2190 cache.get).find? a then\n      return b\n    let b := f fix a\n    cache.modify (\u00b7.insert a b)\n    pure b\n  pure $ fix a", "start": [19, 1], "end": [28, 15], "kind": "commanddeclaration"}, {"full_name": "memoFixImpl", "code": "private unsafe def memoFixImpl {\u03b1 : Type u} {\u03b2 : Type v} [Nonempty \u03b2] :\n    (f : (\u03b1 \u2192 \u03b2) \u2192 (\u03b1 \u2192 \u03b2)) \u2192 (a : \u03b1) \u2192 \u03b2 :=\n  unsafeCast memoFixImplObj", "start": [30, 1], "end": [32, 28], "kind": "commanddeclaration"}, {"full_name": "memoFix", "code": "@[implemented_by memoFixImpl]\nopaque memoFix {\u03b1 : Type u} {\u03b2 : Type v} [Nonempty \u03b2] (f : (\u03b1 \u2192 \u03b2) \u2192 (\u03b1 \u2192 \u03b2)) : \u03b1 \u2192 \u03b2", "start": [34, 1], "end": [41, 86], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/Delab.lean", "imports": ["lake-packages/Qq/Qq/Macro.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Qq.Impl.failureOnError", "code": "private def failureOnError (x : MetaM \u03b1) : DelabM \u03b1 := do\n  let y : MetaM (Option \u03b1) := do try return some (\u2190 x) catch _ => return none\n  match \u2190 y with\n    | some a => return a\n    | none => failure", "start": [15, 1], "end": [19, 22], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquote", "code": "private def unquote (e : Expr) : UnquoteM (Expr \u00d7 LocalContext) := do\n  unquoteLCtx\n  let newE \u2190 unquoteExpr e\n  return (newE, (\u2190 get).unquoted)", "start": [21, 1], "end": [24, 34], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.checkQqDelabOptions", "code": "def checkQqDelabOptions : DelabM Unit := do\n  unless \u2190 getPPOption (\u00b7.getBool `pp.qq true) do failure\n  if \u2190 getPPOption getPPExplicit then failure", "start": [26, 1], "end": [28, 46], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.delabQuoted", "code": "def delabQuoted : StateT UnquoteState DelabM Term := do\n  let e \u2190 getExpr\n  let some newE \u2190 (try some <$> unquoteExpr e catch _ => failure : UnquoteM _) | failure\n  let newLCtx := (\u2190 get).unquoted\n  withLCtx newLCtx (\u2190 determineLocalInstances newLCtx) do\n    withTheReader SubExpr (fun s => { s with expr := newE }) delab", "start": [33, 1], "end": [39, 67], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.withDelabQuoted", "code": "def withDelabQuoted (k : StateT UnquoteState DelabM Term) : Delab :=\n  withIncRecDepth do\n  StateT.run' (s := { mayPostpone := false }) <|\n  show StateT UnquoteState DelabM Term from do\n  unquoteLCtx\n  let mut res \u2190 k\n  let showNested := `pp.qq._nested\n  if (\u2190 getOptions).get showNested true then\n    for fv in (\u2190 get).abstractedFVars.reverse do\n      if let some (.quoted expr) := (\u2190 get).exprBackSubst.find? (.fvar fv) then\n      if let some decl := (\u2190 get).unquoted.find? fv then\n      if (res.1.find? (\u00b7.getId == decl.userName)).isSome then\n      if let some name := removeDollar decl.userName then\n      let pos \u2190 nextExtraPos\n      res \u2190 withTheReader SubExpr (fun _ => { expr, pos }) do\n      withOptions (\u00b7.set showNested false) do\n      `(let $(mkIdent name) := $(\u2190 delab); $res)\n  return res", "start": [41, 1], "end": [58, 13], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.delabQuotedLevel", "code": "def delabQuotedLevel : DelabM Syntax.Level := do\n  let e \u2190 getExpr\n  let (newE, _) \u2190 failureOnError do\n    StateT.run (s := { mayPostpone := false }) do\n      unquoteLevelLCtx (addDefEqs := false)\n      unquoteLevel e\n  return newE.quote max_prec", "start": [60, 1], "end": [66, 29], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.delabQ", "code": "@[delab app.Qq.Quoted]\ndef delabQ : Delab := do\n  guard $ (\u2190 getExpr).getAppNumArgs == 1\n  checkQqDelabOptions\n  withDelabQuoted do\n  let stx \u2190 withAppArg delabQuoted\n  `(Q($stx))", "start": [68, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.delabq", "code": "@[delab app.Qq.Quoted.unsafeMk]\ndef delabq : Delab := do\n  guard $ (\u2190 getExpr).getAppNumArgs == 2\n  checkQqDelabOptions\n  withDelabQuoted do\n  let stx \u2190 withAppArg delabQuoted\n  `(q($stx))", "start": [76, 1], "end": [82, 13], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.delabQuotedDefEq", "code": "@[delab app.Qq.QuotedDefEq]\ndef delabQuotedDefEq : Delab := do\n  guard $ (\u2190 getExpr).getAppNumArgs == 4\n  checkQqDelabOptions\n  withDelabQuoted do\n  let lhs \u2190 withAppFn do withAppArg delabQuoted\n  let rhs \u2190 withAppArg delabQuoted\n  `($lhs =Q $rhs)", "start": [84, 1], "end": [91, 18], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.delabQuotedLevelDefEq", "code": "@[delab app.Qq.QuotedLevelDefEq]\ndef delabQuotedLevelDefEq : Delab := do\n  guard $ (\u2190 getExpr).getAppNumArgs == 2\n  checkQqDelabOptions\n  let lhs \u2190 withAppFn do withAppArg delabQuotedLevel\n  let rhs \u2190 withAppArg delabQuotedLevel\n  `($lhs:level =QL $rhs:level)", "start": [93, 1], "end": [99, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/UnsafeQueue.lean", "imports": ["lake-packages/aesop/Aesop/Constants.lean", "lake-packages/std/Std/Data/Array/Merge.lean", "lake-packages/aesop/Aesop/Rule.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.PostponedSafeRule", "code": "structure PostponedSafeRule where\n  rule : SafeRule\n  output : RuleTacOutput\n  deriving Inhabited", "start": [15, 1], "end": [18, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.PostponedSafeRule.toUnsafeRule", "code": "def toUnsafeRule (r : PostponedSafeRule) : UnsafeRule :=\n  { r.rule with extra := \u27e8postponedSafeRuleSuccessProbability\u27e9 }", "start": [22, 1], "end": [23, 65], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnsafeQueueEntry", "code": "inductive UnsafeQueueEntry\n  | unsafeRule (r : IndexMatchResult UnsafeRule)\n  | postponedSafeRule (r : PostponedSafeRule)\n  deriving Inhabited", "start": [28, 1], "end": [31, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnsafeQueueEntry.successProbability", "code": "def successProbability : UnsafeQueueEntry \u2192 Percent\n  | unsafeRule r => r.rule.extra.successProbability\n  | postponedSafeRule .. => postponedSafeRuleSuccessProbability", "start": [40, 1], "end": [42, 64], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnsafeQueueEntry.name", "code": "def name : UnsafeQueueEntry \u2192 RuleName\n  | unsafeRule r => r.rule.name\n  | postponedSafeRule r => r.rule.name", "start": [44, 1], "end": [46, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnsafeQueue", "code": "def UnsafeQueue := Subarray UnsafeQueueEntry", "start": [56, 1], "end": [56, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnsafeQueue.initial", "code": "def initial (postponedSafeRules : Array PostponedSafeRule)\n    (unsafeRules : Array (IndexMatchResult UnsafeRule)) : UnsafeQueue :=\n  let unsafeRules := unsafeRules.map .unsafeRule\n  let postponedSafeRules :=\n    postponedSafeRules.map .postponedSafeRule\n      |>.qsort (\u03bb x y => compare x y |>.isLT)\n  postponedSafeRules.mergeSortedDeduplicating unsafeRules |>.toSubarray", "start": [68, 1], "end": [74, 72], "kind": "commanddeclaration"}, {"full_name": "Aesop.UnsafeQueue.entriesToMessageData", "code": "def entriesToMessageData (q : UnsafeQueue) : Array MessageData :=\n  q.toArray.map toMessageData", "start": [76, 1], "end": [77, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder/Basic.lean", "imports": ["lake-packages/aesop/Aesop/Rule.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleBuilderKind", "code": "inductive RuleBuilderKind\n  | global (decl : Name)\n  | \u00ablocal\u00bb (fvarUserName : Name) (goal : MVarId)", "start": [14, 1], "end": [16, 50], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilderKind.toRuleIdent", "code": "def RuleBuilderKind.toRuleIdent : RuleBuilderKind \u2192 RuleIdent\n  | global decl => RuleIdent.const decl\n  | \u00ablocal\u00bb fvarUserName .. => RuleIdent.fvar fvarUserName", "start": [18, 1], "end": [20, 59], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilderInput", "code": "structure RuleBuilderInput where\n  phase : PhaseName\n  kind : RuleBuilderKind", "start": [22, 1], "end": [24, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularRuleBuilderResult", "code": "structure RegularRuleBuilderResult where\n  builder : BuilderName\n  tac : RuleTacDescr\n  indexingMode : IndexingMode\n  deriving Inhabited", "start": [26, 1], "end": [30, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilderResult", "code": "inductive RuleBuilderResult\n  | regular (r : RegularRuleBuilderResult)\n  | globalSimp (entries : Array SimpEntry)\n  | localSimp (userName : Name)\n  | unfold (r : UnfoldRule)\n  deriving Inhabited", "start": [32, 1], "end": [37, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilderOutput", "code": "inductive RuleBuilderOutput\n  | global (r : RuleBuilderResult)\n  | \u00ablocal\u00bb (goal : MVarId) (r : RuleBuilderResult)", "start": [39, 1], "end": [41, 52], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder", "code": "abbrev RuleBuilder := RuleBuilderInput \u2192 MetaM RuleBuilderOutput", "start": [43, 1], "end": [48, 65], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.checkConstIsInductive", "code": "def checkConstIsInductive (builderName : BuilderName) (decl : Name) :\n    MetaM InductiveVal := do\n  let info \u2190 getConstInfo decl\n    <|> throwError \"aesop: {builderName} builder: unknown constant '{decl}'\"\n  let (ConstantInfo.inductInfo info) \u2190 pure info\n    | throwError \"aesop: {builderName} builder: expected '{decl}' to be an inductive type\"\n  return info", "start": [52, 1], "end": [58, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.ofGlobalRuleBuilder", "code": "def ofGlobalRuleBuilder (name : BuilderName)\n    (globalBuilder : PhaseName \u2192 Name \u2192 MetaM RuleBuilderResult) :\n    RuleBuilder := \u03bb input =>\n  match input.kind with\n  | RuleBuilderKind.local .. =>\n    throwError \"aesop: {name} builder does not support local hypotheses\"\n  | RuleBuilderKind.global decl =>\n    RuleBuilderOutput.global <$> globalBuilder input.phase decl", "start": [60, 1], "end": [67, 64], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularBuilderOptions", "code": "structure RegularBuilderOptions where\n  indexingMode? : Option IndexingMode\n  deriving Inhabited", "start": [72, 1], "end": [74, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularBuilderOptions.default", "code": "protected def default : RegularBuilderOptions where\n  indexingMode? := none", "start": [78, 1], "end": [79, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.RegularBuilderOptions.getIndexingModeM", "code": "def getIndexingModeM [Monad m] (dflt : m IndexingMode)\n    (opts : RegularBuilderOptions) : m IndexingMode :=\n  match opts.indexingMode? with\n  | none => dflt\n  | some imode => return imode", "start": [81, 1], "end": [85, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std.lean", "imports": ["lake-packages/std/Std/Lean/MonadBacktrack.lean", "lake-packages/std/Std/Lean/PersistentHashSet.lean", "lake-packages/std/Std/Tactic/Lint/Frontend.lean", "lake-packages/std/Std/Data/BinomialHeap.lean", "lake-packages/std/Std/Classes/BEq.lean", "lake-packages/std/Std/Data/Array/Init/Basic.lean", "lake-packages/std/Std/Data/Rat.lean", "lake-packages/std/Std/Control/ForInStep/Lemmas.lean", "lake-packages/std/Std/Data/Option/Init/Lemmas.lean", "lake-packages/std/Std/Lean/Meta/Inaccessible.lean", "lake-packages/std/Std/Tactic/PrintDependents.lean", "lake-packages/std/Std/Data/Array/Merge.lean", "lake-packages/std/Std/Lean/InfoTree.lean", "lake-packages/std/Std/Data/List/Lemmas.lean", "lake-packages/std/Std/Lean/Util/Path.lean", "lake-packages/std/Std/Data/String/Basic.lean", "lake-packages/std/Std/Data/RBMap/Alter.lean", "lake-packages/std/Std/Lean/AttributeExtra.lean", "lake-packages/std/Std/Lean/Delaborator.lean", "lake-packages/std/Std/Lean/HashMap.lean", "lake-packages/std/Std/Lean/Meta/SavedState.lean", "lake-packages/std/Std/Tactic/OpenPrivate.lean", "lake-packages/std/Std/Data/Array/Lemmas.lean", "lake-packages/std/Std/Classes/Cast.lean", "lake-packages/std/Std/Data/Option/Basic.lean", "lake-packages/std/Std/Data/Array/Basic.lean", "lake-packages/std/Std/Data/AssocList.lean", "lake-packages/std/Std/Tactic/Ext.lean", "lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/std/Std/Lean/TagAttribute.lean", "lake-packages/std/Std/Data/BinomialHeap/Lemmas.lean", "lake-packages/std/Std/Lean/Expr.lean", "lake-packages/std/Std/Lean/Tactic.lean", "lake-packages/std/Std/Tactic/CoeExt.lean", "lake-packages/std/Std/Data/DList.lean", "lake-packages/std/Std/CodeAction/Attr.lean", "lake-packages/std/Std/Data/RBMap.lean", "lake-packages/std/Std/Classes/SetNotation.lean", "lake-packages/std/Std/Data/RBMap/Lemmas.lean", "lake-packages/std/Std/Data/Fin/Init/Lemmas.lean", "lake-packages/std/Std/Data/Array/Match.lean", "lake-packages/std/Std/Linter/UnreachableTactic.lean", "lake-packages/std/Std/Lean/Meta/Basic.lean", "lake-packages/std/Std/Test/Internal/DummyLabelAttr.lean", "lake-packages/std/Std/Lean/PersistentHashMap.lean", "lake-packages/std/Std/Tactic/Alias.lean", "lake-packages/std/Std/Lean/Meta/Expr.lean", "lake-packages/std/Std/Tactic/Replace.lean", "lake-packages/std/Std/Classes/Dvd.lean", "lake-packages/std/Std/Tactic/Lint/Simp.lean", "lake-packages/std/Std/Tactic/HaveI.lean", "lake-packages/std/Std/WF.lean", "lake-packages/std/Std/Tactic/NormCast/Ext.lean", "lake-packages/std/Std/Tactic/LabelAttr.lean", "lake-packages/std/Std/Data/Ord.lean", "lake-packages/std/Std/Data/BitVec/Basic.lean", "lake-packages/std/Std/Data/Nat/Basic.lean", "lake-packages/std/Std/Tactic/Congr.lean", "lake-packages/std/Std/Lean/Position.lean", "lake-packages/std/Std/Tactic/Lint/Basic.lean", "lake-packages/std/Std/Data/HashMap/WF.lean", "lake-packages/std/Std/Linter.lean", "lake-packages/std/Std/Tactic/NormCast/Lemmas.lean", "lake-packages/std/Std/Data/Sum/Lemmas.lean", "lake-packages/std/Std/Data/String.lean", "lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/std/Std/Data/Int/Basic.lean", "lake-packages/std/Std/CodeAction/Basic.lean", "lake-packages/std/Std/Data/Sum/Basic.lean", "lake-packages/std/Std/Tactic/Lint/Misc.lean", "lake-packages/std/Std/Classes/RatCast.lean", "lake-packages/std/Std/Data/Char.lean", "lake-packages/std/Std/Data/List/Pairwise.lean", "lake-packages/std/Std/Lean/Meta/Clear.lean", "lake-packages/std/Std/Data/PairingHeap.lean", "lake-packages/std/Std/CodeAction/Deprecated.lean", "lake-packages/std/Std/Data/Array/Init/Lemmas.lean", "lake-packages/std/Std/Data/RBMap/WF.lean", "lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "lake-packages/std/Std/Lean/CoreM.lean", "lake-packages/std/Std/CodeAction/Misc.lean", "lake-packages/std/Std/Lean/Name.lean", "lake-packages/std/Std/Lean/Parser.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Tactic/Basic.lean", "lake-packages/std/Std/Tactic/Instances.lean", "lake-packages/std/Std/Tactic/Exact.lean", "lake-packages/std/Std/Lean/Float.lean", "lake-packages/std/Std/Data/BitVec.lean", "lake-packages/std/Std/Lean/Meta/InstantiateMVars.lean", "lake-packages/std/Std/Data/MLList/Heartbeats.lean", "lake-packages/std/Std/Lean/Meta/AssertHypotheses.lean", "lake-packages/std/Std/Data/Prod/Lex.lean", "lake-packages/std/Std/Lean/Format.lean", "lake-packages/std/Std/Lean/Meta/LCtx.lean", "lake-packages/std/Std/Tactic/Lint/TypeClass.lean", "lake-packages/std/Std/Data/BinomialHeap/Basic.lean", "lake-packages/std/Std/Tactic/SeqFocus.lean", "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "lake-packages/std/Std/Data/Rat/Lemmas.lean", "lake-packages/std/Std/Lean/Meta/DiscrTree.lean", "lake-packages/std/Std/Lean/Meta/UnusedNames.lean", "lake-packages/std/Std/Tactic/Lint.lean", "lake-packages/std/Std/Logic.lean", "lake-packages/std/Std/Util/Pickle.lean", "lake-packages/std/Std/Data/MLList/Basic.lean", "lake-packages/std/Std/Data/HashMap.lean", "lake-packages/std/Std/Data/Rat/Basic.lean", "lake-packages/std/Std/Tactic/GuardMsgs.lean", "lake-packages/std/Std/Data/Option/Lemmas.lean", "lake-packages/std/Std/Tactic/Case.lean", "lake-packages/std/Std/Tactic/NoMatch.lean", "lake-packages/std/Std/Tactic/TryThis.lean", "lake-packages/std/Std/Linter/UnnecessarySeqFocus.lean", "lake-packages/std/Std/Util/LibraryNote.lean", "lake-packages/std/Std/Data/RBMap/Basic.lean", "lake-packages/std/Std/Data/Int/DivMod.lean", "lake-packages/std/Std/Data/Int/Lemmas.lean", "lake-packages/std/Std/Classes/LawfulMonad.lean", "lake-packages/std/Std/Classes/Order.lean", "lake-packages/std/Std/Data/String/Lemmas.lean", "lake-packages/std/Std/Tactic/ShowTerm.lean", "lake-packages/std/Std/Tactic/Relation/Rfl.lean", "lake-packages/std/Std/Lean/NameMapAttribute.lean", "lake-packages/std/Std/Tactic/ByCases.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean", "lake-packages/std/Std/Data/Nat/Gcd.lean", "lake-packages/std/Std/Tactic/SimpTrace.lean", "lake-packages/std/Std/Tactic/Simpa.lean", "lake-packages/std/Std/Data/HashMap/Basic.lean", "lake-packages/std/Std/Data/Range/Lemmas.lean", "lake-packages/std/Std/Data/Sum.lean", "lake-packages/std/Std/Lean/Command.lean", "lake-packages/std/Std/Util/ExtendedBinder.lean", "lake-packages/std/Std/Tactic/GuardExpr.lean", "lake-packages/std/Std/Control/ForInStep.lean", "lake-packages/std/Std/Tactic/SqueezeScope.lean", "lake-packages/std/Std/Tactic/Unreachable.lean", "lake-packages/std/Std/Lean/Elab/Tactic.lean", "lake-packages/std/Std/Control/ForInStep/Basic.lean", "lake-packages/std/Std/Tactic/Ext/Attr.lean", "lake-packages/std/Std/Tactic/Where.lean", "lake-packages/std/Std/Tactic/RCases.lean", "lake-packages/std/Std/CodeAction.lean", "lake-packages/std/Std/Data/Fin/Basic.lean", "lake-packages/std/Std/Data/List/Count.lean", "lake-packages/std/Std/Tactic/Relation/Symm.lean", "lake-packages/std/Std/Data/Fin/Lemmas.lean", "lake-packages/std/Std/Lean/HashSet.lean"], "premises": []}
{"path": "Mathlib/Tactic/PPWithUniv.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Lean/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.PPWithUniv.delabWithUniv", "code": "def delabWithUniv : Delab :=\n  whenPPOption (\u00b7.get pp.universes.name true) <|\n  let enablePPUnivOnHead subExpr :=\n    let expr := subExpr.expr\n    let expr := mkAppN (expr.getAppFn.setOption pp.universes.name true) expr.getAppArgs\n    { subExpr with expr }\n  withTheReader SubExpr enablePPUnivOnHead <|\n    delabAppImplicit <|> delabAppExplicit", "start": [21, 1], "end": [32, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Data/NameMap.lean", "imports": ["lake-packages/std/Std/Data/RBMap.lean", "lake-packages/lean4/src/lean/Lean/Data/NameMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.NameMap.filter", "code": "def filter (f : Name \u2192 \u03b1 \u2192 Bool) (m : NameMap \u03b1) : NameMap \u03b1 :=\n  m.fold process {}\nwhere\n  process (r : NameMap \u03b1) (n : Name) (i : \u03b1) :=\n    if f n i then r.insert n i else r", "start": [22, 1], "end": [30, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.filterMap", "code": "def filterMap (f : Name \u2192 \u03b1 \u2192 Option \u03b2) (m : NameMap \u03b1) : NameMap \u03b2 :=\n  m.fold process {}\nwhere\n  process (r : NameMap \u03b2) (n : Name) (i : \u03b1) :=\n    match f n i with\n    | none => r\n    | some b => r.insert n b", "start": [32, 1], "end": [44, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Elab/Tactic/Basic.lean", "imports": ["Mathlib/Lean/Meta.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.getMainTarget''", "code": "def getMainTarget'' : TacticM Expr := do\n  (\u2190 getMainGoal).getType''", "start": [17, 1], "end": [21, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.doneWithScope", "code": "def doneWithScope (scope : MessageData) : TacticM Unit := do\n  let gs \u2190 getUnsolvedGoals\n  unless gs.isEmpty do\n    logError m!\"{scope} failed to solve some goals.\\n\"\n    Term.reportUnsolvedGoals gs\n    throwAbortTactic", "start": [23, 1], "end": [32, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.focusAndDoneWithScope", "code": "def focusAndDoneWithScope (scope : MessageData) (tactic : TacticM \u03b1) : TacticM \u03b1 :=\n  focus do\n    let a \u2190 try tactic catch e =>\n      if isAbortTacticException e then throw e\n      else throwError \"{scope} failed.\\n{\u2190 nestedExceptionToMessageData e}\"\n    doneWithScope scope\n    pure a", "start": [34, 1], "end": [44, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Expr/ReplaceRec.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Util/TermUnsafe.lean", "Mathlib/Util/MemoFix.lean", "Mathlib/Lean/Expr/Traverse.lean"], "premises": [{"full_name": "Lean.Expr.replaceRec", "code": "def replaceRec (f? : (Expr \u2192 Expr) \u2192 Expr \u2192 Option Expr) : Expr \u2192 Expr :=\n  memoFix fun r e \u21a6\n    match f? r e with\n    | some x => x\n    | none   => traverseChildren (M := Id) r e", "start": [19, 1], "end": [32, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/MetaM.lean", "imports": ["lake-packages/Qq/Qq/Delab.lean", "lake-packages/Qq/Qq/Macro.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Qq.mkFreshExprMVarQ", "code": "def mkFreshExprMVarQ (ty : Q(Sort u)) (kind := MetavarKind.natural) (userName := Name.anonymous) : MetaM Q($ty) := do\n  mkFreshExprMVar (some ty) kind userName", "start": [8, 1], "end": [9, 42], "kind": "commanddeclaration"}, {"full_name": "Qq.withLocalDeclDQ", "code": "def withLocalDeclDQ [Monad n] [MonadControlT MetaM n] (name : Name) (\u03b2 : Q(Sort u)) (k : Q($\u03b2) \u2192 n \u03b1) : n \u03b1 :=\n  withLocalDeclD name \u03b2 k", "start": [11, 1], "end": [12, 26], "kind": "commanddeclaration"}, {"full_name": "Qq.withLocalDeclQ", "code": "def withLocalDeclQ [Monad n] [MonadControlT MetaM n] (name : Name) (bi : BinderInfo) (\u03b2 : Q(Sort u)) (k : Q($\u03b2) \u2192 n \u03b1) : n \u03b1 :=\n  withLocalDecl name bi \u03b2 k", "start": [14, 1], "end": [15, 28], "kind": "commanddeclaration"}, {"full_name": "Qq.trySynthInstanceQ", "code": "def trySynthInstanceQ (\u03b1 : Q(Sort u)) : MetaM (LOption Q($\u03b1)) := do\n  trySynthInstance \u03b1", "start": [17, 1], "end": [18, 21], "kind": "commanddeclaration"}, {"full_name": "Qq.synthInstanceQ", "code": "def synthInstanceQ (\u03b1 : Q(Sort u)) : MetaM Q($\u03b1) := do\n  synthInstance \u03b1", "start": [20, 1], "end": [21, 18], "kind": "commanddeclaration"}, {"full_name": "Qq.instantiateMVarsQ", "code": "def instantiateMVarsQ {\u03b1 : Q(Sort u)} (e : Q($\u03b1)) : MetaM Q($\u03b1) := do\n  instantiateMVars e", "start": [23, 1], "end": [24, 21], "kind": "commanddeclaration"}, {"full_name": "Qq.elabTermEnsuringTypeQ", "code": "def elabTermEnsuringTypeQ (stx : Syntax) (expectedType : Q(Sort u))\n    (catchExPostpone := true) (implicitLambda := true) (errorMsgHeader? : Option String := none) :\n    TermElabM Q($expectedType) := do\n  elabTermEnsuringType stx (some expectedType) catchExPostpone implicitLambda errorMsgHeader?", "start": [26, 1], "end": [29, 94], "kind": "commanddeclaration"}, {"full_name": "Qq.inferTypeQ", "code": "def inferTypeQ (e : Expr) : MetaM ((u : Level) \u00d7 (\u03b1 : Q(Sort $u)) \u00d7 Q($\u03b1)) := do\n  let \u03b1 \u2190 inferType e\n  let .sort u \u2190 whnf (\u2190 inferType \u03b1) | throwError \"not a type{indentExpr \u03b1}\"\n  pure \u27e8u, \u03b1, e\u27e9", "start": [31, 1], "end": [34, 17], "kind": "commanddeclaration"}, {"full_name": "Qq.checkTypeQ", "code": "def checkTypeQ (e : Expr) (ty : Q(Sort $u)) : MetaM (Option Q($ty)) := do\n  if \u2190 isDefEq (\u2190 inferType e) ty then\n    return some e\n  else\n    return none", "start": [36, 1], "end": [40, 16], "kind": "commanddeclaration"}, {"full_name": "Qq.MaybeDefEq", "code": "inductive MaybeDefEq {\u03b1 : Q(Sort $u)} (a b : Q($\u03b1)) where\n  | defEq : QuotedDefEq a b \u2192 MaybeDefEq a b\n  | notDefEq : MaybeDefEq a b", "start": [42, 1], "end": [44, 30], "kind": "commanddeclaration"}, {"full_name": "Qq.isDefEqQ", "code": "def isDefEqQ {\u03b1 : Q(Sort $u)} (a b : Q($\u03b1)) : MetaM (MaybeDefEq a b) := do\n  if \u2190 isDefEq a b then\n    return .defEq \u27e8\u27e9\n  else\n    return .notDefEq", "start": [51, 1], "end": [55, 21], "kind": "commanddeclaration"}, {"full_name": "Qq.assertDefEqQ", "code": "def assertDefEqQ {\u03b1 : Q(Sort $u)} (a b : Q($\u03b1)) : MetaM (PLift (QuotedDefEq a b)) := do\n  match \u2190 isDefEqQ a b with\n  | .defEq witness => return \u27e8witness\u27e9\n  | .notDefEq => throwError \"{a} is not definitionally equal to{indentExpr b}\"", "start": [57, 1], "end": [60, 79], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/Data.lean", "imports": ["lake-packages/aesop/Aesop/Tree/UnsafeQueue.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Constants.lean", "lake-packages/aesop/Aesop/Tracing.lean", "lake-packages/aesop/Aesop/Script.lean"], "premises": [{"full_name": "Bool.toYesNo", "code": "private def Bool.toYesNo : Bool \u2192 Format\n  | true => \"yes\"\n  | false => \"no \"", "start": [16, 1], "end": [18, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalId", "code": "structure GoalId where\n  toNat : Nat\n  deriving Inhabited, DecidableEq", "start": [25, 1], "end": [27, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalId.zero", "code": "protected def zero : GoalId :=\n  \u27e80\u27e9", "start": [31, 1], "end": [32, 6], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalId.one", "code": "protected def one : GoalId :=\n  \u27e81\u27e9", "start": [34, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalId.succ", "code": "protected def succ : GoalId \u2192 GoalId\n  | \u27e8n\u27e9 => \u27e8n + 1\u27e9", "start": [37, 1], "end": [38, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalId.dummy", "code": "def dummy : GoalId :=\n  \u27e81000000000000000\u27e9", "start": [40, 1], "end": [41, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappId", "code": "structure RappId where\n  toNat : Nat\n  deriving Inhabited, DecidableEq", "start": [60, 1], "end": [62, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappId.zero", "code": "protected def zero : RappId :=\n  \u27e80\u27e9", "start": [66, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappId.succ", "code": "protected def succ : RappId \u2192 RappId\n  | \u27e8n\u27e9 => \u27e8n + 1\u27e9", "start": [69, 1], "end": [70, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappId.one", "code": "protected def one : RappId :=\n  \u27e81\u27e9", "start": [72, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappId.dummy", "code": "def dummy : RappId :=\n  \u27e81000000000000000\u27e9", "start": [75, 1], "end": [76, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Iteration", "code": "def Iteration := Nat\n  deriving Inhabited", "start": [95, 1], "end": [96, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Iteration.toNat", "code": "@[inline]\nprivate def toNat : Iteration \u2192 Nat :=\n  id", "start": [100, 1], "end": [102, 5], "kind": "commanddeclaration"}, {"full_name": "Aesop.Iteration.ofNat", "code": "@[inline]\nprivate def ofNat : Nat \u2192 Iteration :=\n  id", "start": [104, 1], "end": [106, 5], "kind": "commanddeclaration"}, {"full_name": "Aesop.Iteration.one", "code": "@[inline]\nprotected def one : Iteration :=\n  ofNat 1", "start": [108, 1], "end": [110, 10], "kind": "commanddeclaration"}, {"full_name": "Aesop.Iteration.succ", "code": "@[inline]\nprotected def succ (i : Iteration) : Iteration :=\n  ofNat $ i.toNat + 1", "start": [112, 1], "end": [114, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.Iteration.none", "code": "protected def none : Iteration :=\n  ofNat 0", "start": [116, 1], "end": [117, 10], "kind": "commanddeclaration"}, {"full_name": "Aesop.NodeState", "code": "inductive NodeState\n  | unknown\n  | proven\n  | unprovable\n  deriving Inhabited, BEq", "start": [142, 1], "end": [158, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.NodeState.isUnknown", "code": "def isUnknown : NodeState \u2192 Bool\n  | unknown => true\n  | _ => false", "start": [168, 1], "end": [170, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.NodeState.isProven", "code": "def isProven : NodeState \u2192 Bool\n  | proven => true\n  | _ => false", "start": [172, 1], "end": [174, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.NodeState.isUnprovable", "code": "def isUnprovable : NodeState \u2192 Bool\n  | unprovable => true\n  | _ => false", "start": [176, 1], "end": [178, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.NodeState.isIrrelevant", "code": "def isIrrelevant : NodeState \u2192 Bool\n  | proven => true\n  | unprovable => true\n  | unknown => false", "start": [180, 1], "end": [183, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.NodeState.toEmoji", "code": "def toEmoji : NodeState \u2192 String\n  | proven => nodeProvedEmoji\n  | unprovable => nodeUnprovableEmoji\n  | unknown => nodeUnknownEmoji", "start": [185, 1], "end": [188, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalState", "code": "inductive GoalState\n  | unknown\n  | provenByRuleApplication\n  | provenByNormalization\n  | unprovable\n  deriving Inhabited, BEq", "start": [193, 1], "end": [202, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalState.isProvenByRuleApplication", "code": "def isProvenByRuleApplication : GoalState \u2192 Bool\n  | provenByRuleApplication => true\n  | _ => false", "start": [213, 1], "end": [215, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalState.isProvenByNormalization", "code": "def isProvenByNormalization : GoalState \u2192 Bool\n  | provenByNormalization => true\n  | _ => false", "start": [217, 1], "end": [219, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalState.isProven", "code": "def isProven : GoalState \u2192 Bool\n  | provenByRuleApplication => true\n  | provenByNormalization => true\n  | _ => false", "start": [221, 1], "end": [224, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalState.isUnprovable", "code": "def isUnprovable : GoalState \u2192 Bool\n  | unprovable => true\n  | _ => false", "start": [226, 1], "end": [228, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalState.isUnknown", "code": "def isUnknown : GoalState \u2192 Bool\n  | unknown => true\n  | _ => false", "start": [230, 1], "end": [232, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalState.toNodeState", "code": "def toNodeState : GoalState \u2192 NodeState\n  | unknown => NodeState.unknown\n  | provenByRuleApplication => NodeState.proven\n  | provenByNormalization => NodeState.proven\n  | unprovable => NodeState.unprovable", "start": [234, 1], "end": [238, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalState.isIrrelevant", "code": "def isIrrelevant (s : GoalState) : Bool :=\n  s.toNodeState.isIrrelevant", "start": [240, 1], "end": [241, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalState.toEmoji", "code": "def toEmoji : GoalState \u2192 String\n  | unknown => nodeUnknownEmoji\n  | provenByRuleApplication | provenByNormalization => nodeProvedEmoji\n  | unprovable => nodeUnprovableEmoji", "start": [243, 1], "end": [246, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormalizationState", "code": "inductive NormalizationState\n  | notNormal\n  | normal (postGoal : MVarId) (postState : Meta.SavedState)\n      (script? : Except DisplayRuleName UnstructuredScript)\n      | provenByNormalization (postState : Meta.SavedState)\n      (script? : Except DisplayRuleName UnstructuredScript)\n  deriving Inhabited", "start": [251, 1], "end": [260, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormalizationState.isNormal", "code": "def isNormal : NormalizationState \u2192 Bool\n  | notNormal => false\n  | normal .. => true\n  | provenByNormalization .. => true", "start": [264, 1], "end": [267, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormalizationState.isProvenByNormalization", "code": "def isProvenByNormalization : NormalizationState \u2192 Bool\n  | notNormal .. => false\n  | normal .. => false\n  | provenByNormalization .. => true", "start": [269, 1], "end": [272, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalOrigin", "code": "inductive GoalOrigin\n  | subgoal\n  | copied (\u00abfrom\u00bb : GoalId) (rep : GoalId)\n  | droppedMVar\n  deriving Inhabited", "start": [277, 1], "end": [293, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalOrigin.originalGoalId?", "code": "def originalGoalId? : GoalOrigin \u2192 Option GoalId\n  | copied _ rep => some rep\n  | _ => none", "start": [297, 1], "end": [299, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalOrigin.toString", "code": "protected def toString : GoalOrigin \u2192 String\n  | subgoal => \"subgoal\"\n  | copied \u00abfrom\u00bb rep => s!\"copy of {\u00abfrom\u00bb}, originally {\u00abrep\u00bb}\"\n  | droppedMVar => \"dropped mvar\"", "start": [301, 1], "end": [304, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalData", "code": "structure GoalData (Rapp MVarCluster : Type) : Type where\n  id : GoalId\n  parent : IO.Ref MVarCluster\n  children : Array (IO.Ref Rapp)\n  origin : GoalOrigin\n  depth : Nat\n  state : GoalState\n  isIrrelevant : Bool\n  isForcedUnprovable : Bool\n    preNormGoal : MVarId\n    normalizationState : NormalizationState\n  mvars : UnorderedArraySet MVarId\n    successProbability : Percent\n  addedInIteration : Iteration\n  lastExpandedInIteration : Iteration\n    unsafeRulesSelected : Bool\n  unsafeQueue : UnsafeQueue\n  failedRapps : Array RegularRule\n  deriving Nonempty", "start": [309, 1], "end": [337, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterData", "code": "structure MVarClusterData (Goal Rapp : Type) : Type where\n  parent? : Option (IO.Ref Rapp)\n  goals : Array (IO.Ref Goal)\n  isIrrelevant : Bool\n  state : NodeState\n  deriving Inhabited", "start": [339, 1], "end": [344, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappData", "code": "structure RappData (Goal MVarCluster : Type) : Type where\n  id : RappId\n  parent : IO.Ref Goal\n  children : Array (IO.Ref MVarCluster)\n  state : NodeState\n  isIrrelevant : Bool\n  appliedRule : RegularRule\n  scriptBuilder? : Option RuleTacScriptBuilder\n  originalSubgoals : Array MVarId\n  successProbability : Percent\n  metaState : Meta.SavedState\n    introducedMVars : UnorderedArraySet MVarId\n    assignedMVars : UnorderedArraySet MVarId\n    deriving Nonempty", "start": [347, 1], "end": [369, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalUnsafe", "code": "unsafe inductive GoalUnsafe\n    | mk (d : GoalData RappUnsafe MVarClusterUnsafe)", "start": [372, 3], "end": [373, 53], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterUnsafe", "code": "unsafe inductive MVarClusterUnsafe\n    | mk (d : MVarClusterData GoalUnsafe RappUnsafe)", "start": [375, 3], "end": [376, 53], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappUnsafe", "code": "unsafe inductive RappUnsafe\n    | mk (d : RappData GoalUnsafe MVarClusterUnsafe)", "start": [378, 3], "end": [379, 53], "kind": "commanddeclaration"}, {"full_name": "Aesop.TreeSpec", "code": "structure TreeSpec where\n  Goal : Type\n  Rapp : Type\n  MVarCluster : Type\n  introGoal : GoalData Rapp MVarCluster \u2192 Goal\n  elimGoal : Goal \u2192 GoalData Rapp MVarCluster\n  introRapp : RappData Goal MVarCluster \u2192 Rapp\n  elimRapp : Rapp \u2192 RappData Goal MVarCluster\n  introMVarCluster : MVarClusterData Goal Rapp \u2192 MVarCluster\n  elimMVarCluster : MVarCluster \u2192 MVarClusterData Goal Rapp", "start": [382, 1], "end": [391, 60], "kind": "commanddeclaration"}, {"full_name": "Aesop.treeImpl", "code": "unsafe def treeImpl : TreeSpec where\n  Goal := GoalUnsafe\n  Rapp := RappUnsafe\n  MVarCluster := MVarClusterUnsafe\n  introGoal := GoalUnsafe.mk\n  elimGoal | GoalUnsafe.mk x => x\n  introRapp := RappUnsafe.mk\n  elimRapp | RappUnsafe.mk x => x\n  introMVarCluster := MVarClusterUnsafe.mk\n  elimMVarCluster | MVarClusterUnsafe.mk x => x", "start": [397, 1], "end": [406, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.tree", "code": "@[implemented_by treeImpl]\nopaque tree : TreeSpec", "start": [408, 1], "end": [409, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal", "code": "def Goal        := tree.Goal", "start": [411, 1], "end": [411, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp", "code": "def Rapp        := tree.Rapp", "start": [412, 1], "end": [412, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster", "code": "def MVarCluster := tree.MVarCluster", "start": [413, 1], "end": [413, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalRef", "code": "abbrev GoalRef        := IO.Ref Goal", "start": [415, 1], "end": [415, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappRef", "code": "abbrev RappRef        := IO.Ref Rapp", "start": [416, 1], "end": [416, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef", "code": "abbrev MVarClusterRef := IO.Ref MVarCluster", "start": [417, 1], "end": [417, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.mk", "code": "@[inline]\nprotected def mk : MVarClusterData Goal Rapp \u2192 MVarCluster :=\n  tree.introMVarCluster", "start": [422, 1], "end": [424, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.elim", "code": "@[inline]\nprotected def elim : MVarCluster \u2192 MVarClusterData Goal Rapp :=\n  tree.elimMVarCluster", "start": [429, 1], "end": [431, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.modify", "code": "@[inline]\nprotected def modify (f : MVarClusterData Goal Rapp \u2192 MVarClusterData Goal Rapp)\n    (c : MVarCluster) : MVarCluster :=\n  MVarCluster.mk $ f $ c.elim", "start": [433, 1], "end": [436, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.parent?", "code": "@[inline]\ndef parent? (c : MVarCluster) : Option RappRef :=\n  c.elim.parent?", "start": [438, 1], "end": [440, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.setParent", "code": "@[inline]\ndef setParent (parent? : Option RappRef) (c : MVarCluster) : MVarCluster :=\n  c.modify \u03bb c => { c with parent? }", "start": [442, 1], "end": [444, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.goals", "code": "@[inline]\ndef goals (c : MVarCluster) : Array GoalRef :=\n  c.elim.goals", "start": [446, 1], "end": [448, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.setGoals", "code": "@[inline]\ndef setGoals (goals : Array GoalRef) (c : MVarCluster) : MVarCluster :=\n  c.modify \u03bb c => { c with goals }", "start": [450, 1], "end": [452, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.isIrrelevant", "code": "@[inline]\ndef isIrrelevant (c : MVarCluster) : Bool :=\n  c.elim.isIrrelevant", "start": [454, 1], "end": [456, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.setIsIrrelevant", "code": "@[inline]\ndef setIsIrrelevant (isIrrelevant : Bool) (c : MVarCluster) : MVarCluster :=\n  c.modify \u03bb c => { c with isIrrelevant }", "start": [458, 1], "end": [460, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.state", "code": "@[inline]\ndef state (c : MVarCluster) : NodeState :=\n  c.elim.state", "start": [462, 1], "end": [464, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.setState", "code": "@[inline]\ndef setState (state : NodeState) (c : MVarCluster) : MVarCluster :=\n  c.modify \u03bb c => { c with state }", "start": [466, 1], "end": [468, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.mk", "code": "@[inline]\nprotected def mk : GoalData Rapp MVarCluster \u2192 Goal :=\n  tree.introGoal", "start": [475, 1], "end": [477, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.elim", "code": "@[inline]\nprotected def elim : Goal \u2192 GoalData Rapp MVarCluster :=\n  tree.elimGoal", "start": [479, 1], "end": [481, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.modify", "code": "@[inline]\nprotected def modify (f : GoalData Rapp MVarCluster \u2192 GoalData Rapp MVarCluster)\n    (g : Goal) : Goal :=\n  Goal.mk $ f $ g.elim", "start": [483, 1], "end": [486, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.id", "code": "@[inline]\ndef id (g : Goal) : GoalId :=\n  g.elim.id", "start": [488, 1], "end": [490, 12], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.parent", "code": "@[inline]\ndef parent (g : Goal) : MVarClusterRef :=\n  g.elim.parent", "start": [492, 1], "end": [494, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.children", "code": "@[inline]\ndef children (g : Goal) : Array RappRef :=\n  g.elim.children", "start": [496, 1], "end": [498, 18], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.origin", "code": "@[inline]\ndef origin (g : Goal) : GoalOrigin :=\n  g.elim.origin", "start": [500, 1], "end": [502, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.depth", "code": "@[inline]\ndef depth (g : Goal) : Nat :=\n  g.elim.depth", "start": [504, 1], "end": [506, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.state", "code": "@[inline]\ndef state (g : Goal) : GoalState :=\n  g.elim.state", "start": [508, 1], "end": [510, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isIrrelevant", "code": "@[inline]\ndef isIrrelevant (g : Goal) : Bool :=\n  g.elim.isIrrelevant", "start": [512, 1], "end": [514, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isForcedUnprovable", "code": "@[inline]\ndef isForcedUnprovable (g : Goal) : Bool :=\n  g.elim.isForcedUnprovable", "start": [516, 1], "end": [518, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.preNormGoal", "code": "@[inline]\ndef preNormGoal (g : Goal) : MVarId :=\n  g.elim.preNormGoal", "start": [520, 1], "end": [522, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.normalizationState", "code": "@[inline]\ndef normalizationState (g : Goal) : NormalizationState :=\n  g.elim.normalizationState", "start": [524, 1], "end": [526, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.mvars", "code": "@[inline]\ndef mvars (g : Goal) : UnorderedArraySet MVarId :=\n  g.elim.mvars", "start": [528, 1], "end": [530, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.successProbability", "code": "@[inline]\ndef successProbability (g : Goal) : Percent :=\n  g.elim.successProbability", "start": [532, 1], "end": [534, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.addedInIteration", "code": "@[inline]\ndef addedInIteration (g : Goal) : Iteration :=\n  g.elim.addedInIteration", "start": [536, 1], "end": [538, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.lastExpandedInIteration", "code": "@[inline]\ndef lastExpandedInIteration (g : Goal) : Iteration :=\n  g.elim.lastExpandedInIteration", "start": [540, 1], "end": [542, 33], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.failedRapps", "code": "@[inline]\ndef failedRapps (g : Goal) : Array RegularRule :=\n  g.elim.failedRapps", "start": [544, 1], "end": [546, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.unsafeRulesSelected", "code": "@[inline]\ndef unsafeRulesSelected (g : Goal) : Bool :=\n  g.elim.unsafeRulesSelected", "start": [548, 1], "end": [550, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.unsafeQueue", "code": "@[inline]\ndef unsafeQueue (g : Goal) : UnsafeQueue :=\n  g.elim.unsafeQueue", "start": [552, 1], "end": [554, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.unsafeQueue?", "code": "@[inline]\ndef unsafeQueue? (g : Goal) : Option UnsafeQueue :=\n  if g.unsafeRulesSelected then some g.unsafeQueue else none", "start": [556, 1], "end": [558, 61], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setId", "code": "@[inline]\ndef setId (id : GoalId) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with id }", "start": [560, 1], "end": [562, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setParent", "code": "@[inline]\ndef setParent (parent : MVarClusterRef) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with parent }", "start": [564, 1], "end": [566, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setChildren", "code": "@[inline]\ndef setChildren (children : Array RappRef) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with children }", "start": [568, 1], "end": [570, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setOrigin", "code": "@[inline]\ndef setOrigin (origin : GoalOrigin) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with origin }", "start": [572, 1], "end": [574, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setDepth", "code": "@[inline]\ndef setDepth (depth : Nat) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with depth }", "start": [576, 1], "end": [578, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setIsIrrelevant", "code": "@[inline]\ndef setIsIrrelevant (isIrrelevant : Bool) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with isIrrelevant }", "start": [580, 1], "end": [582, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setIsForcedUnprovable", "code": "@[inline]\ndef setIsForcedUnprovable (isForcedUnprovable : Bool) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with isForcedUnprovable }", "start": [584, 1], "end": [586, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setPreNormGoal", "code": "@[inline]\ndef setPreNormGoal (preNormGoal : MVarId) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with preNormGoal }", "start": [588, 1], "end": [590, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setNormalizationState", "code": "@[inline]\ndef setNormalizationState (normalizationState : NormalizationState) (g : Goal) :\n    Goal :=\n  g.modify \u03bb g => { g with normalizationState }", "start": [592, 1], "end": [595, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setMVars", "code": "@[inline]\ndef setMVars (mvars : UnorderedArraySet MVarId) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with mvars }", "start": [597, 1], "end": [599, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setSuccessProbability", "code": "@[inline]\ndef setSuccessProbability (successProbability : Percent) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with successProbability }", "start": [601, 1], "end": [603, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setAddedInIteration", "code": "@[inline]\ndef setAddedInIteration (addedInIteration : Iteration) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with addedInIteration }", "start": [605, 1], "end": [607, 46], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setLastExpandedInIteration", "code": "@[inline]\ndef setLastExpandedInIteration (lastExpandedInIteration : Iteration) (g : Goal) :\n    Goal :=\n  g.modify \u03bb g => { g with lastExpandedInIteration }", "start": [609, 1], "end": [612, 53], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setUnsafeRulesSelected", "code": "@[inline]\ndef setUnsafeRulesSelected (unsafeRulesSelected : Bool) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with unsafeRulesSelected }", "start": [614, 1], "end": [616, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setUnsafeQueue", "code": "@[inline]\ndef setUnsafeQueue (unsafeQueue : UnsafeQueue) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with unsafeQueue }", "start": [618, 1], "end": [620, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setState", "code": "@[inline]\ndef setState (state : GoalState) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with state }", "start": [622, 1], "end": [624, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.setFailedRapps", "code": "@[inline]\ndef setFailedRapps (failedRapps : Array RegularRule) (g : Goal) : Goal :=\n  g.modify \u03bb g => { g with failedRapps }", "start": [626, 1], "end": [628, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.mk", "code": "@[inline]\nprotected def mk : RappData Goal MVarCluster \u2192 Rapp :=\n  tree.introRapp", "start": [644, 1], "end": [646, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.elim", "code": "@[inline]\nprotected def elim : Rapp \u2192 RappData Goal MVarCluster :=\n  tree.elimRapp", "start": [648, 1], "end": [650, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.modify", "code": "@[inline]\nprotected def modify (f : RappData Goal MVarCluster \u2192 RappData Goal MVarCluster)\n    (r : Rapp) : Rapp :=\n  Rapp.mk $ f $ r.elim", "start": [652, 1], "end": [655, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.id", "code": "@[inline]\ndef id (r : Rapp) : RappId :=\n  r.elim.id", "start": [657, 1], "end": [659, 12], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.parent", "code": "@[inline]\ndef parent (r : Rapp) : GoalRef :=\n  r.elim.parent", "start": [661, 1], "end": [663, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.children", "code": "@[inline]\ndef children (r : Rapp) : Array MVarClusterRef :=\n  r.elim.children", "start": [665, 1], "end": [667, 18], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.state", "code": "@[inline]\ndef state (r : Rapp) : NodeState :=\n  r.elim.state", "start": [669, 1], "end": [671, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.isIrrelevant", "code": "@[inline]\ndef isIrrelevant (r : Rapp) : Bool :=\n  r.elim.isIrrelevant", "start": [673, 1], "end": [675, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.appliedRule", "code": "@[inline]\ndef appliedRule (r : Rapp) : RegularRule :=\n  r.elim.appliedRule", "start": [677, 1], "end": [679, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.scriptBuilder?", "code": "@[inline]\ndef scriptBuilder? (r : Rapp) : Option RuleTacScriptBuilder :=\n  r.elim.scriptBuilder?", "start": [681, 1], "end": [683, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.originalSubgoals", "code": "@[inline]\ndef originalSubgoals (r : Rapp) : Array MVarId :=\n  r.elim.originalSubgoals", "start": [685, 1], "end": [687, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.successProbability", "code": "@[inline]\ndef successProbability (r : Rapp) : Percent :=\n  r.elim.successProbability", "start": [689, 1], "end": [691, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.metaState", "code": "@[inline]\ndef metaState (r : Rapp) : Meta.SavedState :=\n  r.elim.metaState", "start": [693, 1], "end": [695, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.introducedMVars", "code": "@[inline]\ndef introducedMVars (r : Rapp) : UnorderedArraySet MVarId :=\n  r.elim.introducedMVars", "start": [697, 1], "end": [699, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.assignedMVars", "code": "@[inline]\ndef assignedMVars (r : Rapp) : UnorderedArraySet MVarId :=\n  r.elim.assignedMVars", "start": [701, 1], "end": [703, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setId", "code": "@[inline]\ndef setId (id : RappId) (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with id }", "start": [705, 1], "end": [707, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setParent", "code": "@[inline]\ndef setParent (parent : GoalRef) (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with parent }", "start": [709, 1], "end": [711, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setChildren", "code": "@[inline]\ndef setChildren (children : Array MVarClusterRef) (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with children }", "start": [713, 1], "end": [715, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setState", "code": "@[inline]\ndef setState (state : NodeState) (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with state }", "start": [717, 1], "end": [719, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setIsIrrelevant", "code": "@[inline]\ndef setIsIrrelevant (isIrrelevant : Bool) (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with isIrrelevant }", "start": [721, 1], "end": [723, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setAppliedRule", "code": "@[inline]\ndef setAppliedRule (appliedRule : RegularRule) (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with appliedRule }", "start": [725, 1], "end": [727, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setScriptBuilder?", "code": "@[inline]\ndef setScriptBuilder? (scriptBuilder? : Option RuleTacScriptBuilder)\n    (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with scriptBuilder? }", "start": [729, 1], "end": [732, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setOriginalSubgoals", "code": "@[inline]\ndef setOriginalSubgoals (originalSubgoals : Array MVarId)\n    (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with originalSubgoals }", "start": [734, 1], "end": [737, 46], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setSuccessProbability", "code": "@[inline]\ndef setSuccessProbability (successProbability : Percent) (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with successProbability }", "start": [739, 1], "end": [741, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setMetaState", "code": "@[inline]\ndef setMetaState (metaState : Meta.SavedState) (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with metaState }", "start": [743, 1], "end": [745, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setIntroducedMVars", "code": "@[inline]\ndef setIntroducedMVars (introducedMVars : UnorderedArraySet MVarId)\n    (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with introducedMVars }", "start": [747, 1], "end": [750, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.setAssignedMVars", "code": "@[inline]\ndef setAssignedMVars (assignedMVars : UnorderedArraySet MVarId) (r : Rapp) : Rapp :=\n  r.modify \u03bb r => { r with assignedMVars }", "start": [752, 1], "end": [754, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.postNormGoalAndMetaState?", "code": "@[inline]\ndef postNormGoalAndMetaState? (g : Goal) : Option (MVarId \u00d7 Meta.SavedState) :=\n  match g.normalizationState with\n  | .normal postGoal postState _ => some (postGoal, postState)\n  | _ => none", "start": [772, 1], "end": [776, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.postNormGoal?", "code": "def postNormGoal? (g : Goal) : Option MVarId :=\n  g.postNormGoalAndMetaState?.map (\u00b7.fst)", "start": [778, 1], "end": [779, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.currentGoal", "code": "def currentGoal (g : Goal) : MVarId :=\n  g.postNormGoal?.getD g.preNormGoal", "start": [781, 1], "end": [782, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.parentRapp?", "code": "def parentRapp? (g : Goal) : BaseIO (Option RappRef) :=\n  return (\u2190 g.parent.get).parent?", "start": [784, 1], "end": [785, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.parentMetaState", "code": "def parentMetaState (g : Goal) (rootMetaState : Meta.SavedState) :\n    BaseIO Meta.SavedState := do\n  match \u2190 g.parentRapp? with\n  | none => return rootMetaState\n  | some parent => return (\u2190 parent.get).metaState", "start": [787, 1], "end": [791, 51], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.currentGoalAndMetaState", "code": "def currentGoalAndMetaState (g : Goal) (rootMetaState : Meta.SavedState) :\n    MetaM (MVarId \u00d7 Meta.SavedState) :=\n  match g.postNormGoalAndMetaState? with\n  | some x => return x\n  | none => return (g.preNormGoal, \u2190 g.parentMetaState rootMetaState)", "start": [793, 1], "end": [797, 70], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isUnsafeExhausted", "code": "def isUnsafeExhausted (g : Goal) : Bool :=\n  g.unsafeRulesSelected && g.unsafeQueue.isEmpty", "start": [799, 1], "end": [800, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isExhausted", "code": "def isExhausted (g : Goal) : BaseIO Bool :=\n  pure g.isUnsafeExhausted <||>\n  g.children.anyM \u03bb rref =>\n    return (\u2190 rref.get).appliedRule.isSafe", "start": [802, 1], "end": [805, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isActive", "code": "def isActive (g : Goal) : BaseIO Bool :=\n  return ! (\u2190 pure g.isIrrelevant <||> g.isExhausted)", "start": [807, 1], "end": [808, 54], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.hasProvableRapp", "code": "def hasProvableRapp (g : Goal) : BaseIO Bool :=\n  g.children.anyM \u03bb r => return ! (\u2190 r.get).state.isUnprovable", "start": [810, 1], "end": [811, 63], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.firstProvenRapp?", "code": "def firstProvenRapp? (g : Goal) : BaseIO (Option RappRef) :=\n  g.children.findSomeM? \u03bb rref =>\n    return if (\u2190 rref.get).state.isProven then some rref else none", "start": [813, 1], "end": [815, 67], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.safeRapps", "code": "def safeRapps (g : Goal) : BaseIO (Array RappRef) :=\n  g.children.filterM \u03bb rref =>\n    return (\u2190 rref.get).appliedRule.isSafe", "start": [817, 1], "end": [819, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.hasSafeRapp", "code": "def hasSafeRapp (g : Goal) : BaseIO Bool :=\n  g.children.anyM \u03bb rref =>\n    return (\u2190 rref.get).appliedRule.isSafe", "start": [821, 1], "end": [823, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.hasMVar", "code": "def hasMVar (g : Goal) : Bool :=\n  ! g.mvars.isEmpty", "start": [825, 1], "end": [826, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.priority", "code": "def priority (g : Goal) : Percent :=\n  g.successProbability * unificationGoalPenalty ^ g.mvars.size", "start": [828, 1], "end": [829, 63], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isNormal", "code": "def isNormal (g : Goal) : Bool :=\n  g.normalizationState.isNormal", "start": [831, 1], "end": [832, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.originalGoalId", "code": "def originalGoalId (g : Goal) : GoalId :=\n  g.origin.originalGoalId?.getD g.id", "start": [834, 1], "end": [835, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isRoot", "code": "def isRoot (g : Goal) : BaseIO Bool :=\n  return (\u2190 g.parentRapp?).isNone", "start": [837, 1], "end": [838, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.introducesMVar", "code": "def introducesMVar (r : Rapp) : Bool :=\n  ! r.introducedMVars.isEmpty", "start": [845, 1], "end": [846, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.parentPostNormMetaState", "code": "def parentPostNormMetaState (r : Rapp) (rootMetaState : Meta.SavedState) :\n    BaseIO Meta.SavedState := do\n  (\u2190 r.parent.get).parentMetaState rootMetaState", "start": [848, 1], "end": [850, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.foldSubgoalsM", "code": "def foldSubgoalsM [Monad m] [MonadLiftT (ST IO.RealWorld) m] (init : \u03c3)\n    (f : \u03c3 \u2192 GoalRef \u2192 m \u03c3) (r : Rapp) : m \u03c3 :=\n  r.children.foldlM (init := init) \u03bb s cref => do\n    (\u2190 cref.get).goals.foldlM (init := s) f", "start": [852, 1], "end": [855, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.forSubgoalsM", "code": "def forSubgoalsM [Monad m] [MonadLiftT (ST IO.RealWorld) m]\n    (f : GoalRef \u2192 m Unit) (r : Rapp) : m Unit :=\n  r.children.forM \u03bb cref => do (\u2190 cref.get).goals.forM f", "start": [857, 1], "end": [859, 57], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.subgoals", "code": "def subgoals [Monad m] [MonadLiftT (ST IO.RealWorld) m] (r : Rapp) :\n    m (Array GoalRef) :=\n  r.foldSubgoalsM (init := #[]) \u03bb subgoals gref => return subgoals.push gref", "start": [861, 1], "end": [863, 77], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.depth", "code": "def depth (r : Rapp) : BaseIO Nat :=\n  return (\u2190 r.parent.get).depth", "start": [865, 1], "end": [866, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.provenGoal?", "code": "def provenGoal? (c : MVarCluster) : BaseIO (Option GoalRef) :=\n  c.goals.findM? \u03bb gref => return (\u2190 gref.get).state.isProven", "start": [873, 1], "end": [874, 62], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder/Apply.lean", "imports": ["lake-packages/aesop/Aesop/Builder/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.ApplyBuilderOptions", "code": "structure ApplyBuilderOptions extends RegularBuilderOptions where\n  \n  transparency : TransparencyMode\n  \n  indexTransparency : TransparencyMode", "start": [14, 1], "end": [19, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.apply", "code": "def RuleBuilder.apply (opts : ApplyBuilderOptions) : RuleBuilder := \u03bb input =>\n  match input.kind with\n  | RuleBuilderKind.global decl => do\n    let tac := .applyConst decl opts.transparency\n    let type := (\u2190 getConstInfo decl).type\n    RuleBuilderOutput.global <$> mkResult tac type\n  | RuleBuilderKind.local fvarUserName goal =>\n    goal.withContext do\n      let tac := RuleTacDescr.applyFVar fvarUserName opts.transparency\n      let type \u2190 instantiateMVars (\u2190 getLocalDeclFromUserName fvarUserName).type\n      let result \u2190 mkResult tac type\n      return RuleBuilderOutput.local goal result\n  where\n    mkResult (tac : RuleTacDescr) (type : Expr) : MetaM RuleBuilderResult :=\n      return RuleBuilderResult.regular {\n        builder := BuilderName.apply\n        tac := tac\n        indexingMode := \u2190 opts.getIndexingModeM do\n          if opts.indexTransparency != .reducible then\n            return .unindexed\n          else\n            IndexingMode.targetMatchingConclusion type\n      }", "start": [28, 1], "end": [50, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/PPWithUniv.lean", "lake-packages/std/Std.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.elabVariables", "code": "@[command_elab \u00abvariables\u00bb] def elabVariables : CommandElab\n  | `(variables%$pos $binders*) => do\n    logWarningAt pos \"'variables' has been replaced by 'variable' in lean 4\"\n    elabVariable (\u2190 `(variable%$pos $binders*))\n  | _ => throwUnsupportedSyntax", "start": [17, 1], "end": [21, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.expandLemma", "code": "@[macro \u00ablemma\u00bb] def expandLemma : Macro := fun stx =>\n  let stx := stx.modifyArg 1 fun stx =>\n    let stx := stx.modifyArg 0 (mkAtomFrom \u00b7 \"theorem\" (canonical := true))\n    stx.setKind ``Parser.Command.theorem\n  pure <| stx.setKind ``Parser.Command.declaration", "start": [27, 1], "end": [34, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.pushFVarAliasInfo", "code": "def pushFVarAliasInfo [Monad m] [MonadInfoTree m]\n    (oldFVars newFVars : Array FVarId) (newLCtx : LocalContext) : m Unit := do\n  for old in oldFVars, new in newFVars do\n    if old != new then\n      let decl := newLCtx.get! new\n      pushInfoLeaf (.ofFVarAliasInfo { id := new, baseId := old, userName := decl.userName })", "start": [48, 1], "end": [59, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.withReverted", "code": "def _root_.Lean.MVarId.withReverted (mvarId : MVarId) (fvarIds : Array FVarId)\n    (k : MVarId \u2192 Array FVarId \u2192 MetaM (\u03b1 \u00d7 Array (Option FVarId) \u00d7 MVarId))\n    (clearAuxDeclsInsteadOfRevert := false) : MetaM (\u03b1 \u00d7 MVarId) := do\n  let (xs, mvarId) \u2190 mvarId.revert fvarIds true clearAuxDeclsInsteadOfRevert\n  let (r, xs', mvarId) \u2190 k mvarId xs\n  let (ys, mvarId) \u2190 mvarId.introNP xs'.size\n  mvarId.withContext do\n    for x? in xs', y in ys do\n      if let some x := x? then\n        pushInfoLeaf (.ofFVarAliasInfo { id := y, baseId := x, userName := \u2190 y.getUserName })\n  return (r, mvarId)", "start": [61, 1], "end": [91, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.changeLocalDecl'", "code": "def _root_.Lean.MVarId.changeLocalDecl' (mvarId : MVarId) (fvarId : FVarId) (typeNew : Expr)\n    (checkDefEq := true) : MetaM MVarId := do\n  mvarId.checkNotAssigned `changeLocalDecl\n  let (_, mvarId) \u2190 mvarId.withReverted #[fvarId] fun mvarId fvars => mvarId.withContext do\n    let check (typeOld : Expr) : MetaM Unit := do\n      if checkDefEq then\n        unless \u2190 isDefEq typeNew typeOld do\n          throwTacticEx `changeLocalDecl mvarId\n            m!\"given type{indentExpr typeNew}\\nis not definitionally equal to{indentExpr typeOld}\"\n    let finalize (targetNew : Expr) := do\n      return ((), fvars.map .some, \u2190 mvarId.replaceTargetDefEq targetNew)\n    match \u2190 mvarId.getType with\n    | .forallE n d b bi => do check d; finalize (.forallE n typeNew b bi)\n    | .letE n t v b ndep => do check t; finalize (.letE n typeNew v b ndep)\n    | _ => throwTacticEx `changeLocalDecl mvarId \"unexpected auxiliary target\"\n  return mvarId", "start": [93, 1], "end": [118, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.evalIntrov", "code": "@[tactic introv] partial def evalIntrov : Tactic := fun stx \u21a6 do\n  match stx with\n  | `(tactic| introv)                     => introsDep\n  | `(tactic| introv $h:ident $hs:binderIdent*) =>\n    evalTactic (\u2190 `(tactic| introv; intro $h:ident; introv $hs:binderIdent*))\n  | `(tactic| introv _%$tk $hs:binderIdent*) =>\n    evalTactic (\u2190 `(tactic| introv; intro _%$tk; introv $hs:binderIdent*))\n  | _ => throwUnsupportedSyntax\nwhere\n  introsDep : TacticM Unit := do\n    let t \u2190 getMainTarget\n    match t with\n    | Expr.forallE _ _ e _ =>\n      if e.hasLooseBVars then\n        intro1PStep\n        introsDep\n    | _ => pure ()\n  intro1PStep : TacticM Unit :=\n    liftMetaTactic fun goal \u21a6 do\n      let (_, goal) \u2190 goal.intro1P\n      pure [goal]", "start": [204, 1], "end": [224, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.clearValue", "code": "def _root_.Lean.MVarId.clearValue (mvarId : MVarId) (fvarId : FVarId) : MetaM MVarId := do\n  mvarId.checkNotAssigned `clear_value\n  let tag \u2190 mvarId.getTag\n  let (_, mvarId) \u2190 mvarId.withReverted #[fvarId] fun mvarId' fvars => mvarId'.withContext do\n    let tgt \u2190 mvarId'.getType\n    unless tgt.isLet do\n      mvarId.withContext <|\n        throwTacticEx `clear_value mvarId m!\"{Expr.fvar fvarId} is not a local definition\"\n    let tgt' := Expr.forallE tgt.letName! tgt.letType! tgt.letBody! .default\n    unless \u2190 isTypeCorrect tgt' do\n      mvarId.withContext <|\n        throwTacticEx `clear_value mvarId\n          m!\"cannot clear {Expr.fvar fvarId}, the resulting context is not type correct\"\n    let mvarId'' \u2190 mkFreshExprSyntheticOpaqueMVar tgt' tag\n    mvarId'.assign <| .app mvarId'' tgt.letValue!\n    return ((), fvars.map .some, mvarId''.mvarId!)\n  return mvarId", "start": [243, 1], "end": [261, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ProjectionNotation.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Lean/Elab/AuxDef.lean", "lake-packages/std/Std/Lean/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.ProjectionNotation.getPPCollapseStructureProjections", "code": "def getPPCollapseStructureProjections (o : Options) : Bool :=\n  o.get pp.structureProjections.name (!getPPAll o)", "start": [33, 1], "end": [34, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.ProjectionNotation.delabProjectionApp'", "code": "@[delab app]\npartial def delabProjectionApp' : Delab := whenPPOption getPPCollapseStructureProjections $ do\n  let e@(Expr.app fn _) \u2190 getExpr | failure\n  let .const c@(.str _ f) _ := fn.getAppFn | failure\n  let env \u2190 getEnv\n  let some info := env.getProjectionFnInfo? c | failure\n  guard <| !info.fromClass\n  guard <| e.getAppNumArgs == info.numParams + 1\n  let expl \u2190 getPPOption getPPExplicit\n  guard <| !expl || info.numParams == 0\n\n  \n  let rec walkUp {\u03b1} (done : DelabM \u03b1) : DelabM \u03b1 := withAppArg do\n    let (Expr.app fn _) \u2190 getExpr | done\n    let .const c@(.str _ field) _ := fn.getAppFn | done\n    let some structName := env.getProjectionStructureName? c | failure\n    let some _ := isSubobjectField? env structName field | done\n    walkUp done\n\n  walkUp do\n    let appStx \u2190 delab\n    `($(appStx).$(mkIdent f):ident)", "start": [36, 1], "end": [67, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.ProjectionNotation.mkExtendedFieldNotationUnexpander", "code": "def mkExtendedFieldNotationUnexpander (f : Name) : CommandElabM Unit := do\n  let .str A projName := f | throwError \"Projection name must end in a string component.\"\n  if let some _ := getStructureInfo? (\u2190 getEnv) A then\n    let .str _ A' := A | throwError \"{A} must end in a string component\"\n    let toA : Name := .str .anonymous (\"to\" ++ A')\n    elabCommand <| \u2190 `(command|\n      @[app_unexpander $(mkIdent f)]\n      aux_def $(mkIdent <| Name.str f \"unexpander\") : Lean.PrettyPrinter.Unexpander := fun\n        | `($$_ $$(x).$(mkIdent toA))\n        | `($$_ $$x) => set_option hygiene false in `($$(x).$(mkIdent projName))\n        | `($$_ $$(x).$(mkIdent toA) $$args*)\n        | `($$_ $$x $$args*) => set_option hygiene false in `($$(x).$(mkIdent projName) $$args*)\n        | _ => throw ())\n  else\n    elabCommand <| \u2190 `(command|\n      @[app_unexpander $(mkIdent f)]\n      aux_def $(mkIdent <| Name.str f \"unexpander\") : Lean.PrettyPrinter.Unexpander := fun\n        | `($$_ $$x) => set_option hygiene false in `($$(x).$(mkIdent projName))\n        | `($$_ $$x $$args*) => set_option hygiene false in `($$(x).$(mkIdent projName) $$args*)\n        | _ => throw ())", "start": [70, 1], "end": [98, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/Imports.lean", "imports": ["Mathlib/Lean/Data/NameMap.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Environment.importsOf", "code": "def importsOf (env : Environment) (n : Name) : Array Name :=\n  if n = env.header.mainModule then\n    env.header.imports.map Import.module\n  else match env.getModuleIdx? n with\n    | .some idx => env.header.moduleData[idx.toNat]!.imports.map Import.module |>.erase `Init\n    | .none => #[]", "start": [26, 1], "end": [34, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.importGraph", "code": "partial def importGraph (env : Environment) : NameMap (Array Name) :=\n  let main := env.header.mainModule\n  let imports := env.header.imports.map Import.module\n  imports.foldl (fun m i => process env i m) (({} : NameMap _).insert main imports)\n    |>.erase Name.anonymous\nwhere\n  process (env) (i) (m) : NameMap (Array Name) :=\n    if m.contains i then\n      m\n    else\n      let imports := env.importsOf i\n      imports.foldr (fun i m => process env i m) (m.insert i imports)", "start": [36, 1], "end": [50, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.findRedundantImports", "code": "partial def findRedundantImports (env : Environment) (imports : Array Name) : NameSet :=\n  let run := visit env.importGraph imports\n  let (_, seen) := imports.foldl (fun \u27e8v, s\u27e9 n => run v s n) ({}, {})\n  seen\nwhere\n  visit (\u0393) (targets) (visited) (seen) (n) : NameSet \u00d7 NameSet :=\n    if visited.contains n then\n      (visited, seen)\n    else\n      let imports := (\u0393.find? n).getD #[]\n      let (visited', seen') := imports.foldl (fun \u27e8v, s\u27e9 t => visit \u0393 targets v s t) (visited, seen)\n      (visited'.insert n,\n        imports.foldl (fun s t => if targets.contains t then s.insert t else s) seen')", "start": [52, 1], "end": [68, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.transitiveClosure", "code": "partial def transitiveClosure (m : NameMap (Array Name)) : NameMap NameSet :=\n  m.fold (fun r n i => process r n i) {}\nwhere\n  process (r : NameMap NameSet) (n : Name) (i : Array Name) : NameMap NameSet :=\n    if r.contains n then\n      r\n    else\n      let r' := i.foldr (fun i r => process r i ((m.find? i).getD #[])) r\n      let t := i.foldr\n        (fun j s => ((r'.find? j).getD {}).fold NameSet.insert s)\n        (RBTree.ofList i.toList)\n      r'.insert n t", "start": [74, 1], "end": [88, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.transitiveReduction", "code": "def transitiveReduction (m : NameMap (Array Name)) : NameMap (Array Name) :=\n  let c := transitiveClosure m\n  m.fold (fun r n a =>\n    r.insert n (a.foldr (fun i b => b.filter (fun j => ! ((c.find? i).getD {}).contains j)) a)) {}", "start": [90, 1], "end": [98, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.downstreamOf", "code": "def downstreamOf (m : NameMap (Array Name)) (targets : NameSet) : NameMap (Array Name) :=\n  let tc := transitiveClosure m\n  let P (n : Name) := targets.contains n || ((tc.find? n).getD {}).any fun j => targets.contains j\n  m.fold (init := {}) fun r n i =>\n    if P n then\n      r.insert n (i.filter P)\n    else\n      r", "start": [100, 1], "end": [108, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.upstreamOf", "code": "def upstreamOf (m : NameMap (Array Name)) (targets : NameSet) : NameMap (Array Name) :=\n  let tc := transitiveClosure m\n  let P (n : Name) := targets.contains n || targets.any fun t => ((tc.find? t).getD {}).contains n\n  m.fold (init := {}) fun r n i =>\n    if P n then\n      r.insert n (i.filter P)\n    else\n      r", "start": [110, 1], "end": [118, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.transitiveFilteredUpstream", "code": "partial\ndef transitiveFilteredUpstream (node : Name) (graph : NameMap (Array Name))\n    (filter : Name \u2192 Bool) (replacement : Option Name := none):\n    List Name :=\n  (graph.find! node).toList.bind fun source =>\n    ( if filter source then\n        match replacement with\n        | none => transitiveFilteredUpstream source graph filter\n        | some repl => .cons repl <| transitiveFilteredUpstream source graph filter\n      else [source]).eraseDup", "start": [120, 1], "end": [142, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.filterGraph", "code": "def filterGraph (graph : NameMap (Array Name)) (filter : Name \u2192 Bool)\n    (replacement : Option Name := none) : NameMap (Array Name) :=\n  let replImports := graph.toList.bind\n    (fun \u27e8n, i\u27e9 => if filter n then i.toList else [])\n    |>.eraseDup |>.filter (\u00ac Name.isPrefixOf `Mathlib \u00b7) |>.toArray\n  let graph := graph.filterMap (fun node edges => if filter node then none else some <|\n    edges.toList.bind (fun source =>\n      if filter source then\n        transitiveFilteredUpstream source graph filter (replacement := replacement)\n      else [source]) |>.eraseDup.toArray)\n  match replacement with\n  | none => graph\n  | some repl => graph.insert repl replImports", "start": [144, 1], "end": [171, 47], "kind": "commanddeclaration"}, {"full_name": "redundantImports", "code": "def redundantImports (n? : Option Name := none) : CoreM NameSet := do\n  let env \u2190 getEnv\n  let imports := env.importsOf (n?.getD (env.header.mainModule))\n  return env.findRedundantImports imports", "start": [175, 1], "end": [182, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.minimalRequiredModules", "code": "def Lean.Environment.minimalRequiredModules (env : Environment) : Array Name :=\n  let required := env.requiredModules.toArray.erase env.header.mainModule\n  let redundant := findRedundantImports env required\n  required.filter fun n => \u00ac redundant.contains n", "start": [196, 1], "end": [206, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.findHome", "code": "def Lean.Name.findHome (n : Name) (env : Option Environment) : CoreM NameSet := do\n  let current? := match env with | some env => env.header.mainModule | _ => default\n  let required := (\u2190 n.requiredModules).toArray.erase current?\n  let imports := (\u2190 getEnv).importGraph.transitiveClosure\n  let mut candidates : NameSet := {}\n  for (n, i) in imports do\n    if required.all fun r => n == r || i.contains r then\n      candidates := candidates.insert n\n  for c in candidates do\n    for i in candidates do\n      if imports.find? i |>.getD {} |>.contains c then\n        candidates := candidates.erase i\n  return candidates", "start": [221, 1], "end": [237, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Mathport/Attributes.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Relation/Trans.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "Mathlib/Lean/Meta.lean", "Mathlib/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Trans.simple", "code": "def _root_.Trans.simple {a b c : \u03b1} [Trans r r r] : r a b \u2192 r b c \u2192 r a c := trans", "start": [50, 1], "end": [51, 83], "kind": "commanddeclaration"}, {"full_name": "Trans.het", "code": "def _root_.Trans.het {a : \u03b1} {b : \u03b2} {c : \u03b3}\n    {r : \u03b1 \u2192 \u03b2 \u2192 Sort u} {s : \u03b2 \u2192 \u03b3 \u2192 Sort v} {t : outParam (\u03b1 \u2192 \u03b3 \u2192 Sort w)}\n    [Trans r s t] : r a b \u2192 s b c \u2192 t a c := trans", "start": [53, 1], "end": [56, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getExplicitFuncArg?", "code": "def getExplicitFuncArg? (e : Expr) : MetaM (Option <| Expr \u00d7 Expr) := do\n  match e with\n  | Expr.app f a => do\n    if \u2190 isDefEq (\u2190 mkAppM' f #[a]) e then\n      return some (f, a)\n    else\n      getExplicitFuncArg? f\n  | _ => return none", "start": [61, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getExplicitRelArg?", "code": "def getExplicitRelArg? (tgt f z : Expr) : MetaM (Option <| Expr \u00d7 Expr) := do\n  match f with\n  | Expr.app rel x => do\n    let check: Bool \u2190 do\n      try\n        let folded \u2190 mkAppM' rel #[x, z]\n        isDefEq folded tgt\n      catch _ =>\n        pure false\n    if check then\n      return some (rel, x)\n    else\n      getExplicitRelArg? tgt rel z\n  | _ => return none", "start": [71, 1], "end": [85, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getExplicitRelArgCore", "code": "def getExplicitRelArgCore (tgt rel x z : Expr) : MetaM (Expr \u00d7 Expr) := do\n  match rel with\n  | Expr.app rel' _ => do\n    let check: Bool \u2190 do\n      try\n        let folded \u2190 mkAppM' rel' #[x, z]\n        isDefEq folded tgt\n      catch _ =>\n        pure false\n    if !check then\n      return (rel, x)\n    else\n      getExplicitRelArgCore tgt rel' x z\n  | _ => return (rel ,x)", "start": [87, 1], "end": [101, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Mathport/Rename.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Prelude.Rename.RenameMap", "code": "structure RenameMap where\n  \n  toLean4 : NameMap (String \u00d7 Name) := {}\n  \n  toLean3 : NameMap (Name \u00d7 List Name) := {}\n  deriving Inhabited", "start": [16, 1], "end": [27, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.NameEntry", "code": "structure NameEntry where\n  \n  n3 : Name\n  \n  n4 : Name\n  \n  synthetic := false\n  \n  dubious := \"\"", "start": [29, 1], "end": [42, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.RenameMap.insert", "code": "def RenameMap.insert (m : RenameMap) (e : NameEntry) : RenameMap :=\n  let \u27e8to4, to3\u27e9 := m\n  let to4 := to4.insert e.n3 (e.dubious, e.n4)\n  let to3 := if e.synthetic || e.n4.isAnonymous then to3 else\n    match to3.find? e.n4 with\n    | none => to3.insert e.n4 (e.n3, [])\n    | some (a, l) => if (a::l).contains e.n3 then to3 else to3.insert e.n4 (a, e.n3 :: l)\n  \u27e8to4, to3\u27e9", "start": [44, 1], "end": [52, 13], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.RenameMap.find?", "code": "def RenameMap.find? (m : RenameMap) : Name \u2192 Option (String \u00d7 Name) := m.toLean4.find?", "start": [54, 1], "end": [55, 87], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.addNameAlignment", "code": "def addNameAlignment (n3 : Name) (n4 : Name) (synthetic := false) (dubious := \"\") : CoreM Unit := do\n  modifyEnv fun env => renameExtension.addEntry env { n3, n4, synthetic, dubious }", "start": [64, 1], "end": [66, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.removeX", "code": "def removeX : Name \u2192 Name\n  | .anonymous => .anonymous\n  | .str p s =>\n    let s := if s.contains '\u2093' then\n      s.foldl (fun acc c => if c = '\u2093' then acc else acc.push c) \"\"\n    else s\n    .str (removeX p) s\n  | .num p n => .num (removeX p) n", "start": [74, 1], "end": [86, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.ensureUnused", "code": "def ensureUnused [Monad m] [MonadEnv m] [MonadError m] (id : Name) : m Unit := do\n  if let some (_, n) := (renameExtension.getState (\u2190 getEnv)).toLean4.find? id then\n    if n.isAnonymous then\n      throwError \"{id} has already been no-aligned\"\n    else\n      throwError \"{id} has already been aligned (to {n})\"", "start": [122, 1], "end": [128, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.suspiciousLean3Name", "code": "def suspiciousLean3Name (s : String) : Bool := Id.run do\n  let allowed : List String :=\n    [\"Prop\", \"Type\", \"Pi\", \"Exists\", \"End\",\n     \"Inf\", \"Sup\", \"Union\", \"Inter\",\n     \"Hausdorff\", \"is_R_or_C\",\n     \"Ioo\", \"Ico\", \"Iio\", \"Icc\", \"Iic\", \"Ioc\", \"Ici\", \"Ioi\", \"Ixx\"]\n  let mut s := s\n  for a in allowed do\n    s := s.replace a \"\"\n  return s.any (\u00b7.isUpper)", "start": [130, 1], "end": [143, 27], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.elabAlign", "code": "@[command_elab align] def elabAlign : CommandElab\n  | `(#align $id3:ident $id4:ident) => do\n    if (\u2190 getInfoState).enabled then\n      addCompletionInfo <| CompletionInfo.id id4 id4.getId (danglingDot := false) {} none\n      let c := removeX id4.getId\n      if (\u2190 getEnv).contains c then\n        addConstInfo id4 c none\n      else if align.precheck.get (\u2190 getOptions) then\n        let note := \"(add `set_option align.precheck false` to suppress this message)\"\n        let inner := match \u2190 try some <$> resolveGlobalConstWithInfos id4 catch _ => pure none with\n        | none => m!\"\"\n        | some cs => m!\" Did you mean:\\n\\n{\n            (\"\\n\":MessageData).joinSep (cs.map fun c' => m!\"  #align {id3} {c'}\")\n          }\\n\\n#align inputs have to be fully qualified.{\"\"\n          } (Double check the lean 3 name too, we can't check that!)\"\n        throwErrorAt id4 \"Declaration {c} not found.{inner}\\n{note}\"\n      if Linter.getLinterValue linter.uppercaseLean3 (\u2190 getOptions) then\n        if id3.getId.anyS suspiciousLean3Name then\n          Linter.logLint linter.uppercaseLean3 id3 $\n            \"Lean 3 names are usually lowercase. This might be a typo.\\n\" ++\n            \"If the Lean 3 name is correct, then above this line, add:\\n\" ++\n            \"set_option linter.uppercaseLean3 false in\\n\"\n    withRef id3 <| ensureUnused id3.getId\n    liftCoreM <| addNameAlignment id3.getId id4.getId\n  | _ => throwUnsupportedSyntax", "start": [145, 1], "end": [170, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.elabNoAlign", "code": "@[command_elab noalign] def elabNoAlign : CommandElab\n  | `(#noalign $id3:ident) => do\n    withRef id3 <| ensureUnused id3.getId\n    liftCoreM $ addNameAlignment id3.getId .anonymous\n  | _ => throwUnsupportedSyntax", "start": [180, 1], "end": [185, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.elabLookup3", "code": "@[command_elab lookup3] def elabLookup3 : CommandElab\n  | `(#lookup3%$tk $id3:ident) => do\n    let n3 := id3.getId\n    let m := renameExtension.getState (\u2190 getEnv)\n    match m.find? n3 with\n    | none    => logInfoAt tk s!\"name `{n3} not found\"\n    | some (dubious, n4) => do\n      if n4.isAnonymous then\n        logInfoAt tk m!\"{n3} has been no-aligned\"\n      else\n        let mut msg := m!\"{n4}\"\n        if !dubious.isEmpty then\n          msg := msg ++ s!\" (dubious: {dubious})\"\n        logInfoAt tk <|\n          match m.toLean3.find? n4 with\n          | none | some (_, []) => msg\n          | some (n, l) => m!\"{msg} (aliases {n :: l})\"\n  | _ => throwUnsupportedSyntax", "start": [190, 1], "end": [208, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.ImportEntry", "code": "structure ImportEntry where\n  \n  mod3 : Name\n  \n  origin : Option (String \u00d7 String)", "start": [212, 1], "end": [217, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.ImportState", "code": "structure ImportState where\n  \n  mod4 : Name := .anonymous\n  \n  extern : Array (Array (Name \u00d7 ImportEntry)) := #[]\n  \n  entries : List ImportEntry := []\n  deriving Inhabited", "start": [219, 1], "end": [229, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Prelude.Rename.elabAlignImport", "code": "@[command_elab alignImport] def elabAlignImport : CommandElab\n  | `(#align_import $mod3 $[from $repo @ $sha]?) => do\n    let origin \u2190 repo.mapM fun repo => do\n      let sha := sha.get!\n      let shaStr := sha.getString\n      if !shaStr.all (\"abcdef0123456789\".contains) then\n        throwErrorAt sha \"not a valid hex sha, bad digits\"\n      else if shaStr.length \u2260 40 then\n        throwErrorAt sha \"must be a full sha\"\n      else\n        pure (repo.getString, shaStr)\n    modifyEnv fun env =>\n      renameImportExtension.addEntry env (env.header.mainModule, { mod3 := mod3.getId, origin })\n  | _ => throwUnsupportedSyntax", "start": [244, 1], "end": [258, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Relation/Symm.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "lake-packages/std/Std/Tactic/Relation/Symm.lean", "Mathlib/Lean/Meta.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.symmSaturate", "code": "def symmSaturate (g : MVarId) : MetaM MVarId := g.withContext do\n  let mut g' := g\n  let hyps \u2190 getLocalHyps\n  let types \u2190 hyps.mapM inferType\n  for h in hyps do try\n    let symm \u2190 h.applySymm\n    let symmType \u2190 inferType symm\n    if \u00ac (\u2190 types.anyM (isDefEq symmType)) then\n      (_, g') \u2190 g'.note ((\u2190 h.fvarId!.getUserName).appendAfter \"_symm\") symm\n  catch _ => g' \u2190 pure g'\n  return g'", "start": [23, 1], "end": [35, 12], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Expr.lean", "imports": ["Mathlib/Lean/Expr/Traverse.lean", "Mathlib/Lean/Expr/ReplaceRec.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Lean/Message.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Message.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/KVMap.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/KVMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.KVMap.eraseCore", "code": "def eraseCore : List (Name \u00d7 DataValue) \u2192 Name \u2192 List (Name \u00d7 DataValue)\n  | l, n => List.filter (fun a \u21a6 a.1 \u2260 n) l", "start": [14, 1], "end": [17, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.erase", "code": "def erase : KVMap \u2192 Name \u2192 KVMap\n  | \u27e8m\u27e9, k => \u27e8eraseCore m k\u27e9", "start": [19, 1], "end": [21, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.updateBool", "code": "def updateBool (m : KVMap) (k : Name) (f : Bool \u2192 Bool) : KVMap :=\n  m.insert k <| DataValue.ofBool <| f <| m.getBool k", "start": [23, 1], "end": [25, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Nat/Notation.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Simps/NotationClass.lean", "imports": ["lake-packages/Qq/Qq/MetaM.lean", "lake-packages/std/Std/Tactic/Lint.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Exception.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/std/Std/Lean/NameMapAttribute.lean"], "premises": [{"full_name": "Simps.findArgType", "code": "def findArgType : Type := Name \u2192 Name \u2192 Array Expr \u2192 MetaM (Array (Option Expr))", "start": [43, 1], "end": [46, 81], "kind": "commanddeclaration"}, {"full_name": "Simps.defaultfindArgs", "code": "def defaultfindArgs : findArgType := \u03bb _ className args => do\n  let some classExpr := (\u2190 getEnv).find? className | throwError \"no such class {className}\"\n  let arity := classExpr.type.forallArity\n  if arity == args.size then\n    return args.map some\n  else if args.size == 1 then\n    return mkArray arity args[0]!\n  else\n    throwError \"initialize_simps_projections cannot automatically find arguments for class {\n      className}\"", "start": [48, 1], "end": [58, 18], "kind": "commanddeclaration"}, {"full_name": "Simps.copyFirst", "code": "def copyFirst : findArgType := \u03bb _ _ args => return (args.push <| args[0]?.getD default).map some", "start": [60, 1], "end": [61, 98], "kind": "commanddeclaration"}, {"full_name": "Simps.copySecond", "code": "def copySecond : findArgType := \u03bb _ _ args => return (args.push <| args[1]?.getD default).map some", "start": [63, 1], "end": [64, 99], "kind": "commanddeclaration"}, {"full_name": "Simps.nsmulArgs", "code": "def nsmulArgs : findArgType := \u03bb _ _ args =>\n  return #[Expr.const `Nat [], args[0]?.getD default] ++ args |>.map some", "start": [66, 1], "end": [68, 74], "kind": "commanddeclaration"}, {"full_name": "Simps.zsmulArgs", "code": "def zsmulArgs : findArgType := \u03bb _ _ args =>\n  return #[Expr.const `Int [], args[0]?.getD default] ++ args |>.map some", "start": [70, 1], "end": [72, 74], "kind": "commanddeclaration"}, {"full_name": "Simps.findZeroArgs", "code": "def findZeroArgs : findArgType := \u03bb _ _ args =>\n  return #[some <| args[0]?.getD default, some <| mkRawNatLit 0]", "start": [74, 1], "end": [76, 65], "kind": "commanddeclaration"}, {"full_name": "Simps.findOneArgs", "code": "def findOneArgs : findArgType := \u03bb _ _ args =>\n  return #[some <| args[0]?.getD default, some <| mkRawNatLit 1]", "start": [78, 1], "end": [80, 65], "kind": "commanddeclaration"}, {"full_name": "Simps.findCoercionArgs", "code": "def findCoercionArgs : findArgType := \u03bb str className args => do\n  let some classExpr := (\u2190 getEnv).find? className | throwError \"no such class {className}\"\n  let arity := classExpr.type.forallArity\n  let eStr := mkAppN (\u2190 mkConstWithLevelParams str) args\n  let classArgs := mkArray (arity - 1) none\n  return #[some eStr] ++ classArgs", "start": [82, 1], "end": [88, 35], "kind": "commanddeclaration"}, {"full_name": "Simps.AutomaticProjectionData", "code": "structure AutomaticProjectionData where\n  \n  className : Name\n  \n  isNotation := true\n  \n  findArgs : Name := `Simps.defaultfindArgs\nderiving Inhabited", "start": [90, 1], "end": [101, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/RunCmd.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Eval.lean", "lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.RunCmd.elabRunElab", "code": "@[term_elab byElab] def elabRunElab : TermElab := fun\n| `(by_elab $cmds:doSeq), expectedType? => do\n  if let `(Lean.Parser.Term.doSeq| $e:term) := cmds then\n    if e matches `(Lean.Parser.Term.doSeq| fun $[$_args]* \u21a6 $_) then\n      let tac \u2190 unsafe evalTerm\n        (Option Expr \u2192 TermElabM Expr)\n        (Lean.mkForall `x .default\n          (mkApp (mkConst ``Option) (mkConst ``Expr))\n          (mkApp (mkConst ``TermElabM) (mkConst ``Expr))) e\n      return \u2190 tac expectedType?\n  (\u2190 unsafe evalTerm (TermElabM Expr) (mkApp (mkConst ``TermElabM) (mkConst ``Expr))\n    (\u2190 `(do $cmds)))\n| _, _ => throwUnsupportedSyntax", "start": [48, 1], "end": [61, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Linter.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Linter.logLintIf", "code": "def logLintIf [Monad m] [MonadLog m] [AddMessageContext m] [MonadOptions m]\n    (linterOption : Lean.Option Bool) (stx : Syntax) (msg : MessageData) : m Unit := do\n  if linterOption.get (\u2190 getOptions) then logLint linterOption stx msg", "start": [18, 1], "end": [22, 71], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/RunMetaM.lean", "imports": ["lake-packages/aesop/Aesop/Tree/Data.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Rapp.runMetaM", "code": "def Rapp.runMetaM (x : MetaM \u03b1) (r : Rapp) : MetaM (\u03b1 \u00d7 Meta.SavedState) :=\n  r.metaState.runMetaM x", "start": [33, 1], "end": [34, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.runMetaM'", "code": "def Rapp.runMetaM' (x : MetaM \u03b1) (r : Rapp) : MetaM \u03b1 :=\n  Prod.fst <$> r.runMetaM x", "start": [36, 1], "end": [37, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.runMetaMModifying", "code": "def Rapp.runMetaMModifying (x : MetaM \u03b1) (r : Rapp) : MetaM (\u03b1 \u00d7 Rapp) := do\n  let (result, finalState) \u2190 r.runMetaM x\n  return (result, r |>.setMetaState finalState)", "start": [39, 1], "end": [41, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappRef.runMetaMModifying", "code": "def RappRef.runMetaMModifying (x : MetaM \u03b1) (rref : RappRef) : MetaM \u03b1 := do\n  let (result, r) \u2190 (\u2190 rref.get).runMetaMModifying x\n  rref.set r\n  return result", "start": [43, 1], "end": [46, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.runMetaMInPostNormState", "code": "def Goal.runMetaMInPostNormState (x : MVarId \u2192 MetaM \u03b1) (g : Goal) :\n    MetaM (\u03b1 \u00d7 Meta.SavedState) := do\n  let some (postGoal, postState) := g.postNormGoalAndMetaState? | throwError\n    \"aesop: internal error: expected goal {g.id} to be normalised (but not proven by normalisation).\"\n  postState.runMetaM $ x postGoal", "start": [48, 1], "end": [52, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.runMetaMInPostNormState'", "code": "def Goal.runMetaMInPostNormState' (x : MVarId \u2192 MetaM \u03b1) (g : Goal) : MetaM \u03b1 :=\n  Prod.fst <$> g.runMetaMInPostNormState x", "start": [54, 1], "end": [55, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.runMetaMInParentState", "code": "def Goal.runMetaMInParentState (x : MetaM \u03b1) (g : Goal) :\n    MetaM (\u03b1 \u00d7 Meta.SavedState) := do\n  match \u2190 g.parentRapp? with\n  | none => withoutModifyingState' x\n  | some rref => (\u2190 rref.get).runMetaM x", "start": [57, 1], "end": [61, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.runMetaMInParentState'", "code": "def Goal.runMetaMInParentState' (x : MetaM \u03b1) (g : Goal) :\n    MetaM \u03b1 :=\n  Prod.fst <$> g.runMetaMInParentState x", "start": [63, 1], "end": [65, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.runMetaMModifyingParentState", "code": "def Goal.runMetaMModifyingParentState (x : MetaM \u03b1) (g : Goal) :\n    MetaM \u03b1 := do\n  match \u2190 g.parentRapp? with\n  | none => x\n  | some rref => rref.runMetaMModifying x", "start": [67, 1], "end": [71, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.runMetaMInParentState", "code": "def Rapp.runMetaMInParentState (x : MetaM \u03b1) (r : Rapp) :\n    MetaM (\u03b1 \u00d7 Meta.SavedState) := do\n  (\u2190 r.parent.get).runMetaMInParentState x", "start": [73, 1], "end": [75, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.runMetaMInParentState'", "code": "def Rapp.runMetaMInParentState' (x : MetaM \u03b1) (r : Rapp) :\n    MetaM \u03b1 := do\n  (\u2190 r.parent.get).runMetaMInParentState' x", "start": [77, 1], "end": [79, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.runMetaMModifyingParentState", "code": "def Rapp.runMetaMModifyingParentState (x : MetaM \u03b1) (r : Rapp) :\n    MetaM \u03b1 := do\n  (\u2190 r.parent.get).runMetaMModifyingParentState x", "start": [81, 1], "end": [83, 50], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/Traversal.lean", "imports": ["lake-packages/aesop/Aesop/Tree/Data.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.TreeRef", "code": "inductive TreeRef\n  | goal (gref : GoalRef)\n  | rapp (rref : RappRef)\n  | mvarCluster (cref : MVarClusterRef)", "start": [11, 1], "end": [14, 40], "kind": "commanddeclaration"}, {"full_name": "Aesop.traverseDown", "code": "@[specialize]\npartial def traverseDown : TreeRef \u2192 m Unit\n  | goal gref => do\n    if \u2190 visitGoalPre gref then\n      (\u2190 gref.get).children.forM (traverseDown \u2218 rapp)\n      visitGoalPost gref\n  | rapp rref => do\n    if \u2190 visitRappPre rref then\n      (\u2190 rref.get).children.forM (traverseDown \u2218 mvarCluster)\n      visitRappPost rref\n  | mvarCluster cref => do\n    if \u2190 visitMVarClusterPre cref then\n      (\u2190 cref.get).goals.forM (traverseDown \u2218 goal)\n      visitMVarClusterPost cref", "start": [29, 1], "end": [42, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.traverseUp", "code": "@[specialize]\npartial def traverseUp : TreeRef \u2192 m Unit\n  | goal gref => do\n    if \u2190 visitGoalPre gref then\n      traverseUp $ mvarCluster (\u2190 gref.get).parent\n      visitGoalPost gref\n  | rapp rref => do\n    if \u2190 visitRappPre rref then\n      traverseUp $ goal (\u2190 rref.get).parent\n      visitRappPost rref\n  | mvarCluster cref => do\n    if \u2190 visitMVarClusterPre cref then\n      if let (some parent) := (\u2190 cref.get).parent? then\n        traverseUp $ rapp parent\n      visitMVarClusterPost cref", "start": [44, 1], "end": [58, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.preTraverseDown", "code": "@[inline]\ndef preTraverseDown [Monad m] [MonadLiftT (ST IO.RealWorld) m]\n  (visitGoal : GoalRef \u2192 m Bool) (visitRapp : RappRef \u2192 m Bool)\n  (visitMVarCluster : MVarClusterRef \u2192 m Bool) : TreeRef \u2192 m Unit :=\n  traverseDown\n    visitGoal\n    (\u03bb _ => pure ())\n    visitRapp\n    (\u03bb _ => pure ())\n    visitMVarCluster\n    (\u03bb _ => pure ())", "start": [62, 1], "end": [72, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.preTraverseUp", "code": "@[inline]\ndef preTraverseUp [Monad m] [MonadLiftT (ST IO.RealWorld) m]\n  (visitGoal : GoalRef \u2192 m Bool) (visitRapp : RappRef \u2192 m Bool)\n  (visitMVarCluster : MVarClusterRef \u2192 m Bool) : TreeRef \u2192 m Unit :=\n  traverseUp\n    visitGoal\n    (\u03bb _ => pure ())\n    visitRapp\n    (\u03bb _ => pure ())\n    visitMVarCluster\n    (\u03bb _ => pure ())", "start": [74, 1], "end": [84, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.postTraverseDown", "code": "@[inline]\ndef postTraverseDown [Monad m] [MonadLiftT (ST IO.RealWorld) m]\n  (visitGoal : GoalRef \u2192 m Unit) (visitRapp : RappRef \u2192 m Unit)\n  (visitMVarCluster : MVarClusterRef \u2192 m Unit) : TreeRef \u2192 m Unit :=\n  traverseDown\n    (\u03bb _ => pure true)\n    visitGoal\n    (\u03bb _ => pure true)\n    visitRapp\n    (\u03bb _ => pure true)\n    visitMVarCluster", "start": [86, 1], "end": [96, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.postTraverseUp", "code": "@[inline]\ndef postTraverseUp [Monad m] [MonadLiftT (ST IO.RealWorld) m]\n  (visitGoal : GoalRef \u2192 m Unit) (visitRapp : RappRef \u2192 m Unit)\n  (visitMVarCluster : MVarClusterRef \u2192 m Unit) : TreeRef \u2192 m Unit :=\n  traverseUp\n    (\u03bb _ => pure true)\n    visitGoal\n    (\u03bb _ => pure true)\n    visitRapp\n    (\u03bb _ => pure true)\n    visitMVarCluster", "start": [98, 1], "end": [108, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder/Tactic.lean", "imports": ["lake-packages/aesop/Aesop/Builder/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleBuilder.tactic", "code": "def RuleBuilder.tactic (opts : RegularBuilderOptions) : RuleBuilder :=\n  ofGlobalRuleBuilder builderName \u03bb _ decl => do\n    let type := (\u2190 getConstInfo decl).type\n    if \u2190 isDefEq (mkApp (mkConst ``TacticM) (mkConst ``Unit)) type then\n      mkResult $ .tacticM decl\n    else if \u2190 isDefEq (mkConst ``SingleRuleTac) type then\n      mkResult $ .singleRuleTac decl\n    else if \u2190 isDefEq (mkConst ``RuleTac) type then\n      mkResult $ .ruleTac decl\n    else if \u2190 isDefEq (mkConst ``TacGen) type then\n      mkResult $ .tacGen decl\n    else\n      throwError \"aesop: {decl} was expected to be a tactic, i.e. to have one of these types:\\n  TacticM Unit\\n  SimpleRuleTac\\n  RuleTac\\n  TacGen\\nHowever, it has type{indentExpr type}\"\n  where\n    builderName : BuilderName :=\n      .tactic\n\n    mkResult (tac : RuleTacDescr) : MetaM RuleBuilderResult :=\n      return .regular {\n        builder := builderName\n        indexingMode := \u2190 opts.getIndexingModeM $ pure IndexingMode.unindexed\n        tac\n      }", "start": [15, 1], "end": [37, 8], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder/Constructors.lean", "imports": ["lake-packages/aesop/Aesop/Builder/Apply.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.ConstructorsBuilderOptions", "code": "structure ConstructorsBuilderOptions extends RegularBuilderOptions where\n  \n  transparency : TransparencyMode\n  \n  indexTransparency : TransparencyMode", "start": [14, 1], "end": [19, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.constructors", "code": "def RuleBuilder.constructors (opts : ConstructorsBuilderOptions) :\n    RuleBuilder :=\n  ofGlobalRuleBuilder name \u03bb _ decl => do\n    let info \u2190 RuleBuilder.checkConstIsInductive name decl\n    return RuleBuilderResult.regular {\n      builder := name\n      tac := .constructors info.ctors.toArray opts.transparency\n      indexingMode := \u2190 opts.getIndexingModeM $ getIndexingMode info\n    }\n  where\n    name := BuilderName.constructors\n\n    getIndexingMode (info : InductiveVal) : MetaM IndexingMode :=\n      opts.getIndexingModeM do\n        if opts.indexTransparency != .reducible then\n          return .unindexed\n        else\n          let mut imodes := Array.mkEmpty info.numCtors\n          for ctor in info.ctors do\n            let ctorInfo \u2190 getConstInfo ctor\n            let imode \u2190 IndexingMode.targetMatchingConclusion ctorInfo.type\n            imodes := imodes.push imode\n          return .or imodes", "start": [28, 1], "end": [50, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder/NormSimp.lean", "imports": ["lake-packages/aesop/Aesop/Builder/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleBuilder.getSimpEntriesFromPropConst", "code": "private def getSimpEntriesFromPropConst (decl : Name) :\n    MetaM (Array SimpEntry) := do\n  let thms \u2190 ({} : SimpTheorems).addConst decl\n  return SimpTheorems.simpEntries thms", "start": [14, 1], "end": [17, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.getSimpEntriesForConst", "code": "private def getSimpEntriesForConst (decl : Name) : MetaM (Array SimpEntry) := do\n  let info \u2190 getConstInfo decl\n  let mut thms : SimpTheorems := {}\n  if (\u2190 isProp info.type) then\n    thms \u2190 thms.addConst decl\n  else if info.hasValue then\n    thms \u2190 thms.addDeclToUnfold decl\n  return SimpTheorems.simpEntries thms", "start": [19, 1], "end": [26, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.simp", "code": "def simp : RuleBuilder := \u03bb input => do\n  match input.kind with\n  | .global decl =>\n    try {\n      let entries \u2190 getSimpEntriesForConst decl\n      return .global $ .globalSimp entries\n    } catch e => {\n      throwError \"aesop: simp builder: exception while trying to add {decl} as a simp theorem:{indentD e.toMessageData}\"\n    }\n  | .\u00ablocal\u00bb fvarUserName goal =>\n    goal.withContext do\n      let type \u2190 instantiateMVars (\u2190 getLocalDeclFromUserName fvarUserName).type\n      unless \u2190 isProp type do\n        throwError \"aesop: simp builder: simp rules must be propositions but {fvarUserName} has type{indentExpr type}\"\n      return .\u00ablocal\u00bb goal (.localSimp fvarUserName)", "start": [28, 1], "end": [42, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/RuleTac/Cases.lean", "imports": ["lake-packages/aesop/Aesop/RuleTac/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.CasesPattern.toExpr", "code": "def CasesPattern.toExpr (p : CasesPattern) : MetaM Expr := do\n  let (_, _, p) \u2190 openAbstractMVarsResult p\n  return p", "start": [15, 1], "end": [17, 11], "kind": "commanddeclaration"}, {"full_name": "Aesop.CasesTarget'", "code": "inductive CasesTarget' where\n  | decl (decl : Name)\n  | patterns (ps : Array (Expr \u00d7 Meta.SavedState))", "start": [19, 1], "end": [21, 51], "kind": "commanddeclaration"}, {"full_name": "Aesop.CasesTarget.toCasesTarget'", "code": "def CasesTarget.toCasesTarget' : CasesTarget \u2192 MetaM CasesTarget'\n  | decl d => return .decl d\n  | patterns ps => withoutModifyingState do\n    let initialState \u2190 saveState\n    .patterns <$> ps.mapM \u03bb p => do\n      initialState.restore\n      let e \u2190 p.toExpr\n      let s \u2190 saveState\n      return (e, s)", "start": [23, 1], "end": [31, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.cases", "code": "partial def cases (target : CasesTarget) (md : TransparencyMode) (isRecursiveType : Bool) : RuleTac :=\n  SingleRuleTac.toRuleTac \u03bb input => do\n    match \u2190 go #[] #[] input.goal input.options.generateScript with\n    | none => throwError \"No matching hypothesis found.\"\n    | some (goals, scriptBuilder?) => return (goals, scriptBuilder?, none)\n  where\n    findFirstApplicableHyp (excluded : Array FVarId) (goal : MVarId) :\n        MetaM (Option FVarId) :=\n      withTransparency md do goal.withContext do\n        let target \u2190 target.toCasesTarget'\n        let \u00abmatch\u00bb ldecl : MetaM Bool :=\n          match target with\n          | .decl d => do\n            isAppOfUpToDefeq (\u2190 mkConstWithFreshMVarLevels d) ldecl.type\n          | .patterns ps => withoutModifyingState do\n            ps.anyM \u03bb (e, state) => do state.restore; isDefEq e ldecl.type\n        return \u2190 (\u2190 getLCtx).findDeclM? \u03bb ldecl => do\n          if ldecl.isImplementationDetail || excluded.contains ldecl.fvarId then\n            return none\n          else if \u2190 \u00abmatch\u00bb ldecl then\n            return some ldecl.fvarId\n          else\n            return none\n\n    go (newGoals : Array MVarId) (excluded : Array FVarId)\n        (goal : MVarId) (generateScript : Bool) :\n        MetaM (Option (Array MVarId \u00d7 Option RuleTacScriptBuilder)) := do\n      let (some hyp) \u2190 findFirstApplicableHyp excluded goal\n        | return none\n      let (goals, scriptBuilder?) \u2190\n        try\n          commitIfNoEx $ unhygienicCasesWithScript goal hyp generateScript\n        catch _ =>\n          return none\n      let mut newGoals := newGoals\n      let mut newScriptBuilders := #[]\n      for g in goals do\n        let excluded :=\n          if ! isRecursiveType then\n            excluded\n          else\n            let excluded := excluded.map \u03bb fvarId =>\n              match g.subst.find? fvarId with\n              | some (.fvar fvarId' ..) => fvarId'\n              | _ => fvarId\n            let fields := g.fields.filterMap \u03bb\n              | (.fvar fvarId' ..) => some fvarId'\n              | _ => none\n            excluded ++ fields\n        match \u2190 go newGoals excluded g.mvarId generateScript with\n        | some (newGoals', newScriptBuilder?) =>\n          newGoals := newGoals'\n          if let some newScriptBuilder := newScriptBuilder? then\n            newScriptBuilders := newScriptBuilders.push newScriptBuilder\n        | none =>\n          newGoals := newGoals.push g.mvarId\n          if generateScript then\n            newScriptBuilders := newScriptBuilders.push .id\n      return some (newGoals, scriptBuilder?.bind (\u00b7.seq newScriptBuilders))", "start": [35, 1], "end": [93, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Logic.lean", "imports": ["Mathlib/Tactic/Relation/Symm.lean", "Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/Relation/Trans.lean", "lake-packages/std/Std/Tactic/Ext.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Mathport/Attributes.lean", "lake-packages/std/Std/Logic.lean", "Mathlib/Util/Imports.lean", "lake-packages/std/Std/Tactic/Relation/Rfl.lean", "lake-packages/std/Std/Tactic/Lint/Basic.lean", "Mathlib/Tactic/ProjectionNotation.lean", "Mathlib/Tactic/Basic.lean", "lake-packages/std/Std/WF.lean"], "premises": [{"full_name": "Implies", "code": "@[deprecated] def Implies (a b : Prop) := a \u2192 b", "start": [25, 1], "end": [25, 48], "kind": "commanddeclaration"}, {"full_name": "Implies.trans", "code": "@[deprecated] theorem Implies.trans {p q r : Prop} (h\u2081 : p \u2192 q) (h\u2082 : q \u2192 r) :\n    p \u2192 r", "start": [27, 1], "end": [31, 33], "kind": "commanddeclaration"}, {"full_name": "NonContradictory", "code": "@[deprecated] def NonContradictory (a : Prop) : Prop := \u00ac\u00aca", "start": [35, 1], "end": [35, 60], "kind": "commanddeclaration"}, {"full_name": "proof_irrel", "code": "alias proof_irrel := proofIrrel", "start": [41, 1], "end": [41, 32], "kind": "stdtacticaliasalias"}, {"full_name": "congr_fun", "code": "alias congr_fun := congrFun", "start": [42, 1], "end": [42, 28], "kind": "stdtacticaliasalias"}, {"full_name": "congr_arg", "code": "alias congr_arg := congrArg", "start": [43, 1], "end": [43, 28], "kind": "stdtacticaliasalias"}, {"full_name": "trans_rel_left", "code": "@[deprecated] theorem trans_rel_left {\u03b1 : Sort u} {a b c : \u03b1}\n    (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : r a b) (h\u2082 : b = c) : r a c", "start": [45, 1], "end": [46, 68], "kind": "commanddeclaration"}, {"full_name": "trans_rel_right", "code": "@[deprecated] theorem trans_rel_right {\u03b1 : Sort u} {a b c : \u03b1}\n    (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : a = b) (h\u2082 : r b c) : r a c", "start": [48, 1], "end": [49, 68], "kind": "commanddeclaration"}, {"full_name": "not_of_eq_false", "code": "theorem not_of_eq_false {p : Prop} (h : p = False) : \u00acp", "start": [51, 1], "end": [51, 75], "kind": "commanddeclaration"}, {"full_name": "cast_proof_irrel", "code": "theorem cast_proof_irrel (h\u2081 h\u2082 : \u03b1 = \u03b2) (a : \u03b1) : cast h\u2081 a = cast h\u2082 a", "start": [53, 1], "end": [53, 80], "kind": "commanddeclaration"}, {"full_name": "Ne.def", "code": "theorem Ne.def {\u03b1 : Sort u} (a b : \u03b1) : (a \u2260 b) = \u00ac (a = b)", "start": [59, 1], "end": [59, 67], "kind": "commanddeclaration"}, {"full_name": "eq_rec_heq", "code": "alias eq_rec_heq := eqRec_heq", "start": [65, 1], "end": [65, 30], "kind": "stdtacticaliasalias"}, {"full_name": "heq_of_eq_rec_left", "code": "theorem heq_of_eq_rec_left {\u03c6 : \u03b1 \u2192 Sort v} {a a' : \u03b1} {p\u2081 : \u03c6 a} {p\u2082 : \u03c6 a'} :\n    (e : a = a') \u2192 (h\u2082 : Eq.rec (motive := fun a _ \u21a6 \u03c6 a) p\u2081 e = p\u2082) \u2192 HEq p\u2081 p\u2082", "start": [73, 1], "end": [75, 24], "kind": "commanddeclaration"}, {"full_name": "heq_of_eq_rec_right", "code": "theorem heq_of_eq_rec_right {\u03c6 : \u03b1 \u2192 Sort v} {a a' : \u03b1} {p\u2081 : \u03c6 a} {p\u2082 : \u03c6 a'} :\n    (e : a' = a) \u2192 (h\u2082 : p\u2081 = Eq.rec (motive := fun a _ \u21a6 \u03c6 a) p\u2082 e) \u2192 HEq p\u2081 p\u2082", "start": [77, 1], "end": [79, 24], "kind": "commanddeclaration"}, {"full_name": "of_heq_true", "code": "theorem of_heq_true {a : Prop} (h : HEq a True) : a", "start": [81, 1], "end": [81, 80], "kind": "commanddeclaration"}, {"full_name": "eq_rec_compose", "code": "theorem eq_rec_compose {\u03b1 \u03b2 \u03c6 : Sort u} :\n    \u2200 (p\u2081 : \u03b2 = \u03c6) (p\u2082 : \u03b1 = \u03b2) (a : \u03b1),\n      (Eq.recOn p\u2081 (Eq.recOn p\u2082 a : \u03b2) : \u03c6) = Eq.recOn (Eq.trans p\u2082 p\u2081) a", "start": [83, 1], "end": [86, 23], "kind": "commanddeclaration"}, {"full_name": "Xor'", "code": "def Xor' (a b : Prop) := (a \u2227 \u00ac b) \u2228 (b \u2227 \u00ac a)", "start": [103, 1], "end": [103, 47], "kind": "commanddeclaration"}, {"full_name": "not_of_not_not_not", "code": "alias \u27e8not_of_not_not_not, _\u27e9 := not_not_not", "start": [125, 1], "end": [125, 45], "kind": "stdtacticaliasaliaslr"}, {"full_name": "and_comm'", "code": "@[deprecated and_comm] theorem and_comm' (a b) : a \u2227 b \u2194 b \u2227 a", "start": [130, 1], "end": [130, 75], "kind": "commanddeclaration"}, {"full_name": "and_assoc'", "code": "@[deprecated and_assoc] theorem and_assoc' (a b) : (a \u2227 b) \u2227 c \u2194 a \u2227 (b \u2227 c)", "start": [134, 1], "end": [134, 90], "kind": "commanddeclaration"}, {"full_name": "and_true_iff", "code": "theorem and_true_iff : p \u2227 True \u2194 p", "start": [145, 1], "end": [145, 62], "kind": "commanddeclaration"}, {"full_name": "true_and_iff", "code": "theorem true_and_iff : True \u2227 p \u2194 p", "start": [147, 1], "end": [147, 62], "kind": "commanddeclaration"}, {"full_name": "and_false_iff", "code": "theorem and_false_iff : p \u2227 False \u2194 False", "start": [149, 1], "end": [149, 69], "kind": "commanddeclaration"}, {"full_name": "false_and_iff", "code": "theorem false_and_iff : False \u2227 p \u2194 False", "start": [151, 1], "end": [151, 69], "kind": "commanddeclaration"}, {"full_name": "and_self_iff", "code": "theorem and_self_iff : p \u2227 p \u2194 p", "start": [155, 1], "end": [155, 59], "kind": "commanddeclaration"}, {"full_name": "or_comm'", "code": "@[deprecated or_comm] theorem or_comm' (a b) : a \u2228 b \u2194 b \u2228 a", "start": [169, 1], "end": [169, 72], "kind": "commanddeclaration"}, {"full_name": "or_assoc'", "code": "@[deprecated or_assoc] theorem or_assoc' (a b) : (a \u2228 b) \u2228 c \u2194 a \u2228 (b \u2228 c)", "start": [173, 1], "end": [173, 87], "kind": "commanddeclaration"}, {"full_name": "true_or_iff", "code": "theorem true_or_iff : True \u2228 p \u2194 True", "start": [182, 1], "end": [182, 63], "kind": "commanddeclaration"}, {"full_name": "or_true_iff", "code": "theorem or_true_iff : p \u2228 True \u2194 True", "start": [184, 1], "end": [184, 63], "kind": "commanddeclaration"}, {"full_name": "false_or_iff", "code": "theorem false_or_iff : False \u2228 p \u2194 p", "start": [186, 1], "end": [186, 63], "kind": "commanddeclaration"}, {"full_name": "or_false_iff", "code": "theorem or_false_iff : p \u2228 False \u2194 p", "start": [188, 1], "end": [188, 63], "kind": "commanddeclaration"}, {"full_name": "or_self_iff", "code": "theorem or_self_iff : p \u2228 p \u2194 p", "start": [190, 1], "end": [190, 57], "kind": "commanddeclaration"}, {"full_name": "not_or_of_not", "code": "theorem not_or_of_not : \u00aca \u2192 \u00acb \u2192 \u00ac(a \u2228 b)", "start": [193, 1], "end": [193, 76], "kind": "commanddeclaration"}, {"full_name": "iff_true_iff", "code": "theorem iff_true_iff : (a \u2194 True) \u2194 a", "start": [196, 1], "end": [196, 64], "kind": "commanddeclaration"}, {"full_name": "true_iff_iff", "code": "theorem true_iff_iff : (True \u2194 a) \u2194 a", "start": [198, 1], "end": [198, 64], "kind": "commanddeclaration"}, {"full_name": "iff_false_iff", "code": "theorem iff_false_iff : (a \u2194 False) \u2194 \u00aca", "start": [201, 1], "end": [201, 68], "kind": "commanddeclaration"}, {"full_name": "false_iff_iff", "code": "theorem false_iff_iff : (False \u2194 a) \u2194 \u00aca", "start": [204, 1], "end": [204, 68], "kind": "commanddeclaration"}, {"full_name": "iff_self_iff", "code": "theorem iff_self_iff (a : Prop) : (a \u2194 a) \u2194 True", "start": [207, 1], "end": [207, 75], "kind": "commanddeclaration"}, {"full_name": "ExistsUnique", "code": "def ExistsUnique (p : \u03b1 \u2192 Prop) := \u2203 x, p x \u2227 \u2200 y, p y \u2192 y = x", "start": [223, 1], "end": [223, 63], "kind": "commanddeclaration"}, {"full_name": "unexpandExistsUnique", "code": "@[app_unexpander ExistsUnique] def unexpandExistsUnique : Lean.PrettyPrinter.Unexpander\n  | `($(_) fun $x:ident \u21a6 \u2203! $xs:binderIdent*, $b) => `(\u2203! $x:ident $xs:binderIdent*, $b)\n  | `($(_) fun $x:ident \u21a6 $b)                      => `(\u2203! $x:ident, $b)\n  | `($(_) fun ($x:ident : $t) \u21a6 $b)               => `(\u2203! ($x:ident : $t), $b)\n  | _                                               => throw ()", "start": [228, 1], "end": [234, 64], "kind": "commanddeclaration"}, {"full_name": "ExistsUnique.intro", "code": "theorem ExistsUnique.intro {p : \u03b1 \u2192 Prop} (w : \u03b1)\n    (h\u2081 : p w) (h\u2082 : \u2200 y, p y \u2192 y = w) : \u2203! x, p x", "start": [237, 1], "end": [238, 66], "kind": "commanddeclaration"}, {"full_name": "ExistsUnique.elim", "code": "theorem ExistsUnique.elim {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} {b : Prop}\n    (h\u2082 : \u2203! x, p x) (h\u2081 : \u2200 x, p x \u2192 (\u2200 y, p y \u2192 y = x) \u2192 b) : b", "start": [240, 1], "end": [242, 63], "kind": "commanddeclaration"}, {"full_name": "exists_unique_of_exists_of_unique", "code": "theorem exists_unique_of_exists_of_unique {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop}\n    (hex : \u2203 x, p x) (hunique : \u2200 y\u2081 y\u2082, p y\u2081 \u2192 p y\u2082 \u2192 y\u2081 = y\u2082) : \u2203! x, p x", "start": [244, 1], "end": [246, 90], "kind": "commanddeclaration"}, {"full_name": "ExistsUnique.exists", "code": "theorem ExistsUnique.exists {p : \u03b1 \u2192 Prop} : (\u2203! x, p x) \u2192 \u2203 x, p x", "start": [248, 1], "end": [248, 90], "kind": "commanddeclaration"}, {"full_name": "ExistsUnique.unique", "code": "theorem ExistsUnique.unique {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop}\n    (h : \u2203! x, p x) {y\u2081 y\u2082 : \u03b1} (py\u2081 : p y\u2081) (py\u2082 : p y\u2082) : y\u2081 = y\u2082", "start": [252, 1], "end": [254, 56], "kind": "commanddeclaration"}, {"full_name": "exists_unique_congr", "code": "theorem exists_unique_congr {p q : \u03b1 \u2192 Prop} (h : \u2200 a, p a \u2194 q a) : (\u2203! a, p a) \u2194 \u2203! a, q a", "start": [269, 1], "end": [270, 84], "kind": "commanddeclaration"}, {"full_name": "decide_True'", "code": "theorem decide_True' (h : Decidable True) : decide True = true", "start": [276, 1], "end": [276, 74], "kind": "commanddeclaration"}, {"full_name": "decide_False'", "code": "theorem decide_False' (h : Decidable False) : decide False = false", "start": [279, 1], "end": [279, 78], "kind": "commanddeclaration"}, {"full_name": "Decidable.recOn_true", "code": "def recOn_true [h : Decidable p] {h\u2081 : p \u2192 Sort u} {h\u2082 : \u00acp \u2192 Sort u}\n    (h\u2083 : p) (h\u2084 : h\u2081 h\u2083) : Decidable.recOn h h\u2082 h\u2081 :=\n  cast (by match h with | .isTrue _ => rfl) h\u2084", "start": [284, 1], "end": [286, 47], "kind": "commanddeclaration"}, {"full_name": "Decidable.recOn_false", "code": "def recOn_false [h : Decidable p] {h\u2081 : p \u2192 Sort u} {h\u2082 : \u00acp \u2192 Sort u} (h\u2083 : \u00acp) (h\u2084 : h\u2082 h\u2083) :\n    Decidable.recOn h h\u2082 h\u2081 :=\n  cast (by match h with | .isFalse _ => rfl) h\u2084", "start": [289, 1], "end": [291, 48], "kind": "commanddeclaration"}, {"full_name": "Decidable.by_cases", "code": "alias by_cases := byCases", "start": [294, 1], "end": [294, 26], "kind": "stdtacticaliasalias"}, {"full_name": "Decidable.by_contradiction", "code": "alias by_contradiction := byContradiction", "start": [295, 1], "end": [295, 42], "kind": "stdtacticaliasalias"}, {"full_name": "Decidable.not_not_iff", "code": "alias not_not_iff := not_not", "start": [296, 1], "end": [296, 29], "kind": "stdtacticaliasalias"}, {"full_name": "Decidable.not_or_iff_and_not", "code": "@[deprecated not_or] theorem not_or_iff_and_not (p q) [Decidable p] [Decidable q] :\n    \u00ac(p \u2228 q) \u2194 \u00acp \u2227 \u00acq", "start": [298, 1], "end": [299, 33], "kind": "commanddeclaration"}, {"full_name": "Or.decidable", "code": "alias Or.decidable := instDecidableOr", "start": [307, 1], "end": [307, 38], "kind": "stdtacticaliasalias"}, {"full_name": "And.decidable", "code": "alias And.decidable := instDecidableAnd", "start": [308, 1], "end": [308, 40], "kind": "stdtacticaliasalias"}, {"full_name": "Not.decidable", "code": "alias Not.decidable := instDecidableNot", "start": [309, 1], "end": [309, 40], "kind": "stdtacticaliasalias"}, {"full_name": "Iff.decidable", "code": "alias Iff.decidable := instDecidableIff", "start": [310, 1], "end": [310, 40], "kind": "stdtacticaliasalias"}, {"full_name": "decidableTrue", "code": "alias decidableTrue := instDecidableTrue", "start": [311, 1], "end": [311, 41], "kind": "stdtacticaliasalias"}, {"full_name": "decidableFalse", "code": "alias decidableFalse := instDecidableFalse", "start": [312, 1], "end": [312, 43], "kind": "stdtacticaliasalias"}, {"full_name": "IsDecEq", "code": "def IsDecEq {\u03b1 : Sort u} (p : \u03b1 \u2192 \u03b1 \u2192 Bool) : Prop := \u2200 \u2983x y : \u03b1\u2984, p x y = true \u2192 x = y", "start": [323, 1], "end": [323, 88], "kind": "commanddeclaration"}, {"full_name": "IsDecRefl", "code": "def IsDecRefl {\u03b1 : Sort u} (p : \u03b1 \u2192 \u03b1 \u2192 Bool) : Prop := \u2200 x, p x x = true", "start": [324, 1], "end": [324, 74], "kind": "commanddeclaration"}, {"full_name": "decidableEq_of_bool_pred", "code": "def decidableEq_of_bool_pred {\u03b1 : Sort u} {p : \u03b1 \u2192 \u03b1 \u2192 Bool} (h\u2081 : IsDecEq p)\n    (h\u2082 : IsDecRefl p) : DecidableEq \u03b1\n  | x, y =>\n    if hp : p x y = true then isTrue (h\u2081 hp)\n    else isFalse (\u03bb hxy : x = y => absurd (h\u2082 y) (by rwa [hxy] at hp))", "start": [326, 1], "end": [330, 71], "kind": "commanddeclaration"}, {"full_name": "decidableEq_inl_refl", "code": "theorem decidableEq_inl_refl {\u03b1 : Sort u} [h : DecidableEq \u03b1] (a : \u03b1) :\n    h a a = isTrue (Eq.refl a)", "start": [333, 1], "end": [336, 20], "kind": "commanddeclaration"}, {"full_name": "decidableEq_inr_neg", "code": "theorem decidableEq_inr_neg {\u03b1 : Sort u} [h : DecidableEq \u03b1] {a b : \u03b1}\n    (n : a \u2260 b) : h a b = isFalse n", "start": [338, 1], "end": [341, 21], "kind": "commanddeclaration"}, {"full_name": "rec_subsingleton", "code": "theorem rec_subsingleton {p : Prop} [h : Decidable p] {h\u2081 : p \u2192 Sort u} {h\u2082 : \u00acp \u2192 Sort u}\n    [h\u2083 : \u2200 h : p, Subsingleton (h\u2081 h)] [h\u2084 : \u2200 h : \u00acp, Subsingleton (h\u2082 h)] :\n    Subsingleton (Decidable.recOn h h\u2082 h\u2081)", "start": [349, 1], "end": [354, 22], "kind": "commanddeclaration"}, {"full_name": "if_t_t", "code": "@[deprecated ite_self]\ntheorem if_t_t (c : Prop) [Decidable c] {\u03b1 : Sort u} (t : \u03b1) : ite c t t = t", "start": [356, 1], "end": [357, 91], "kind": "commanddeclaration"}, {"full_name": "imp_of_if_pos", "code": "theorem imp_of_if_pos {c t e : Prop} [Decidable c] (h : ite c t e) (hc : c) : t", "start": [359, 1], "end": [360, 39], "kind": "commanddeclaration"}, {"full_name": "imp_of_if_neg", "code": "theorem imp_of_if_neg {c t e : Prop} [Decidable c] (h : ite c t e) (hnc : \u00acc) : e", "start": [363, 1], "end": [364, 40], "kind": "commanddeclaration"}, {"full_name": "if_ctx_congr", "code": "theorem if_ctx_congr {\u03b1 : Sort u} {b c : Prop} [dec_b : Decidable b] [dec_c : Decidable c]\n    {x y u v : \u03b1} (h_c : b \u2194 c) (h_t : c \u2192 x = u) (h_e : \u00acc \u2192 y = v) : ite b x y = ite c u v", "start": [367, 1], "end": [373, 69], "kind": "commanddeclaration"}, {"full_name": "if_congr", "code": "theorem if_congr {\u03b1 : Sort u} {b c : Prop} [Decidable b] [Decidable c]\n    {x y u v : \u03b1} (h_c : b \u2194 c) (h_t : x = u) (h_e : y = v) : ite b x y = ite c u v", "start": [375, 1], "end": [377, 45], "kind": "commanddeclaration"}, {"full_name": "if_ctx_congr_prop", "code": "theorem if_ctx_congr_prop {b c x y u v : Prop} [dec_b : Decidable b] [dec_c : Decidable c]\n    (h_c : b \u2194 c) (h_t : c \u2192 (x \u2194 u)) (h_e : \u00acc \u2192 (y \u2194 v)) : ite b x y \u2194 ite c u v", "start": [379, 1], "end": [385, 69], "kind": "commanddeclaration"}, {"full_name": "if_congr_prop", "code": "theorem if_congr_prop {b c x y u v : Prop} [Decidable b] [Decidable c] (h_c : b \u2194 c) (h_t : x \u2194 u)\n    (h_e : y \u2194 v) : ite b x y \u2194 ite c u v", "start": [388, 1], "end": [390, 50], "kind": "commanddeclaration"}, {"full_name": "if_ctx_simp_congr_prop", "code": "theorem if_ctx_simp_congr_prop {b c x y u v : Prop} [Decidable b] (h_c : b \u2194 c) (h_t : c \u2192 (x \u2194 u))\n    (h_e : \u00acc \u2192 (y \u2194 v)) : ite b x y \u2194 @ite _ c (decidable_of_decidable_of_iff h_c) u v", "start": [392, 1], "end": [397, 77], "kind": "commanddeclaration"}, {"full_name": "if_simp_congr_prop", "code": "theorem if_simp_congr_prop {b c x y u v : Prop} [Decidable b] (h_c : b \u2194 c) (h_t : x \u2194 u)\n    (h_e : y \u2194 v) : ite b x y \u2194 (@ite _ c (decidable_of_decidable_of_iff h_c) u v)", "start": [399, 1], "end": [404, 55], "kind": "commanddeclaration"}, {"full_name": "dif_ctx_congr", "code": "theorem dif_ctx_congr {\u03b1 : Sort u} {b c : Prop} [dec_b : Decidable b] [dec_c : Decidable c]\n    {x : b \u2192 \u03b1} {u : c \u2192 \u03b1} {y : \u00acb \u2192 \u03b1} {v : \u00acc \u2192 \u03b1}\n    (h_c : b \u2194 c) (h_t : \u2200 h : c, x (Iff.mpr h_c h) = u h)\n    (h_e : \u2200 h : \u00acc, y (Iff.mpr (not_congr h_c) h) = v h) :\n    @dite \u03b1 b dec_b x y = @dite \u03b1 c dec_c u v", "start": [407, 1], "end": [416, 68], "kind": "commanddeclaration"}, {"full_name": "dif_ctx_simp_congr", "code": "theorem dif_ctx_simp_congr {\u03b1 : Sort u} {b c : Prop} [Decidable b]\n    {x : b \u2192 \u03b1} {u : c \u2192 \u03b1} {y : \u00acb \u2192 \u03b1} {v : \u00acc \u2192 \u03b1}\n    (h_c : b \u2194 c) (h_t : \u2200 h : c, x (Iff.mpr h_c h) = u h)\n    (h_e : \u2200 h : \u00acc, y (Iff.mpr (not_congr h_c) h) = v h) :\n    dite b x y = @dite _ c (decidable_of_decidable_of_iff h_c) u v", "start": [418, 1], "end": [426, 73], "kind": "commanddeclaration"}, {"full_name": "AsTrue", "code": "def AsTrue (c : Prop) [Decidable c] : Prop := if c then True else False", "start": [428, 1], "end": [428, 72], "kind": "commanddeclaration"}, {"full_name": "AsFalse", "code": "def AsFalse (c : Prop) [Decidable c] : Prop := if c then False else True", "start": [430, 1], "end": [430, 73], "kind": "commanddeclaration"}, {"full_name": "AsTrue.get", "code": "theorem AsTrue.get {c : Prop} [h\u2081 : Decidable c] (_ : AsTrue c) : c", "start": [432, 1], "end": [434, 22], "kind": "commanddeclaration"}, {"full_name": "let_value_eq", "code": "theorem let_value_eq {\u03b1 : Sort u} {\u03b2 : Sort v} {a\u2081 a\u2082 : \u03b1} (b : \u03b1 \u2192 \u03b2)\n    (h : a\u2081 = a\u2082) : (let x : \u03b1 := a\u2081; b x) = (let x : \u03b1 := a\u2082; b x)", "start": [445, 1], "end": [446, 84], "kind": "commanddeclaration"}, {"full_name": "let_value_heq", "code": "theorem let_value_heq {\u03b1 : Sort v} {\u03b2 : \u03b1 \u2192 Sort u} {a\u2081 a\u2082 : \u03b1} (b : \u2200 x : \u03b1, \u03b2 x)\n    (h : a\u2081 = a\u2082) : HEq (let x : \u03b1 := a\u2081; b x) (let x : \u03b1 := a\u2082; b x)", "start": [448, 1], "end": [449, 89], "kind": "commanddeclaration"}, {"full_name": "let_body_eq", "code": "theorem let_body_eq {\u03b1 : Sort v} {\u03b2 : \u03b1 \u2192 Sort u} (a : \u03b1) {b\u2081 b\u2082 : \u2200 x : \u03b1, \u03b2 x}\n    (h : \u2200 x, b\u2081 x = b\u2082 x) : (let x : \u03b1 := a; b\u2081 x) = (let x : \u03b1 := a; b\u2082 x)", "start": [452, 1], "end": [453, 99], "kind": "commanddeclaration"}, {"full_name": "let_eq", "code": "theorem let_eq {\u03b1 : Sort v} {\u03b2 : Sort u} {a\u2081 a\u2082 : \u03b1} {b\u2081 b\u2082 : \u03b1 \u2192 \u03b2}\n    (h\u2081 : a\u2081 = a\u2082) (h\u2082 : \u2200 x, b\u2081 x = b\u2082 x) :\n    (let x : \u03b1 := a\u2081; b\u2081 x) = (let x : \u03b1 := a\u2082; b\u2082 x)", "start": [456, 1], "end": [458, 74], "kind": "commanddeclaration"}, {"full_name": "Reflexive", "code": "def Reflexive := \u2200 x, x \u227a x", "start": [468, 1], "end": [469, 28], "kind": "commanddeclaration"}, {"full_name": "Symmetric", "code": "def Symmetric := \u2200 \u2983x y\u2984, x \u227a y \u2192 y \u227a x", "start": [471, 1], "end": [472, 40], "kind": "commanddeclaration"}, {"full_name": "Transitive", "code": "def Transitive := \u2200 \u2983x y z\u2984, x \u227a y \u2192 y \u227a z \u2192 x \u227a z", "start": [474, 1], "end": [475, 51], "kind": "commanddeclaration"}, {"full_name": "Equivalence.reflexive", "code": "lemma Equivalence.reflexive {r : \u03b2 \u2192 \u03b2 \u2192 Prop} (h : Equivalence r) : Reflexive r := h.refl", "start": [477, 1], "end": [477, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Equivalence.symmetric", "code": "lemma Equivalence.symmetric {r : \u03b2 \u2192 \u03b2 \u2192 Prop} (h : Equivalence r) : Symmetric r := \u03bb _ _ => h.symm", "start": [479, 1], "end": [479, 100], "kind": "mathlibtacticlemma"}, {"full_name": "Equivalence.transitive", "code": "lemma Equivalence.transitive {r : \u03b2 \u2192 \u03b2 \u2192 Prop}(h : Equivalence r) : Transitive r :=\n  \u03bb _ _ _ => h.trans", "start": [481, 1], "end": [482, 21], "kind": "mathlibtacticlemma"}, {"full_name": "Total", "code": "def Total := \u2200 x y, x \u227a y \u2228 y \u227a x", "start": [484, 1], "end": [485, 34], "kind": "commanddeclaration"}, {"full_name": "Irreflexive", "code": "def Irreflexive := \u2200 x, \u00ac x \u227a x", "start": [489, 1], "end": [490, 32], "kind": "commanddeclaration"}, {"full_name": "AntiSymmetric", "code": "def AntiSymmetric := \u2200 \u2983x y\u2984, x \u227a y \u2192 y \u227a x \u2192 x = y", "start": [492, 1], "end": [493, 52], "kind": "commanddeclaration"}, {"full_name": "EmptyRelation", "code": "@[nolint unusedArguments]\ndef EmptyRelation := \u03bb _ _ : \u03b1 => False", "start": [495, 1], "end": [497, 40], "kind": "commanddeclaration"}, {"full_name": "InvImage.trans", "code": "theorem InvImage.trans (f : \u03b1 \u2192 \u03b2) (h : Transitive r) : Transitive (InvImage r f)", "start": [499, 1], "end": [500, 83], "kind": "commanddeclaration"}, {"full_name": "InvImage.irreflexive", "code": "theorem InvImage.irreflexive (f : \u03b1 \u2192 \u03b2) (h : Irreflexive r) : Irreflexive (InvImage r f)", "start": [502, 1], "end": [503, 51], "kind": "commanddeclaration"}, {"full_name": "Commutative", "code": "def Commutative       := \u2200 a b, a * b = b * a", "start": [522, 1], "end": [522, 46], "kind": "commanddeclaration"}, {"full_name": "Associative", "code": "def Associative       := \u2200 a b c, (a * b) * c = a * (b * c)", "start": [523, 1], "end": [523, 60], "kind": "commanddeclaration"}, {"full_name": "LeftIdentity", "code": "def LeftIdentity      := \u2200 a, one * a = a", "start": [524, 1], "end": [524, 42], "kind": "commanddeclaration"}, {"full_name": "RightIdentity", "code": "def RightIdentity     := \u2200 a, a * one = a", "start": [525, 1], "end": [525, 42], "kind": "commanddeclaration"}, {"full_name": "RightInverse", "code": "def RightInverse      := \u2200 a, a * a\u207b\u00b9 = one", "start": [526, 1], "end": [526, 44], "kind": "commanddeclaration"}, {"full_name": "LeftCancelative", "code": "def LeftCancelative   := \u2200 a b c, a * b = a * c \u2192 b = c", "start": [527, 1], "end": [527, 56], "kind": "commanddeclaration"}, {"full_name": "RightCancelative", "code": "def RightCancelative  := \u2200 a b c, a * b = c * b \u2192 a = c", "start": [528, 1], "end": [528, 56], "kind": "commanddeclaration"}, {"full_name": "LeftDistributive", "code": "def LeftDistributive  := \u2200 a b c, a * (b + c) = a * b + a * c", "start": [529, 1], "end": [529, 62], "kind": "commanddeclaration"}, {"full_name": "RightDistributive", "code": "def RightDistributive := \u2200 a b c, (a + b) * c = a * c + b * c", "start": [530, 1], "end": [530, 62], "kind": "commanddeclaration"}, {"full_name": "RightCommutative", "code": "def RightCommutative (h : \u03b2 \u2192 \u03b1 \u2192 \u03b2) := \u2200 b a\u2081 a\u2082, h (h b a\u2081) a\u2082 = h (h b a\u2082) a\u2081", "start": [531, 1], "end": [531, 81], "kind": "commanddeclaration"}, {"full_name": "LeftCommutative", "code": "def LeftCommutative  (h : \u03b1 \u2192 \u03b2 \u2192 \u03b2) := \u2200 a\u2081 a\u2082 b, h a\u2081 (h a\u2082 b) = h a\u2082 (h a\u2081 b)", "start": [532, 1], "end": [532, 81], "kind": "commanddeclaration"}, {"full_name": "left_comm", "code": "theorem left_comm : Commutative f \u2192 Associative f \u2192 LeftCommutative f", "start": [534, 1], "end": [539, 34], "kind": "commanddeclaration"}, {"full_name": "right_comm", "code": "theorem right_comm : Commutative f \u2192 Associative f \u2192 RightCommutative f", "start": [541, 1], "end": [546, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Attr/Register.lean", "imports": ["lake-packages/std/Std/Tactic/LabelAttr.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Eqns.lean", "imports": ["lake-packages/std/Std/Lean/NameMapAttribute.lean", "Mathlib/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eqns.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Simps/Basic.lean", "imports": ["lake-packages/std/Std/Data/String/Basic.lean", "Mathlib/Lean/Linter.lean", "Mathlib/Tactic/RunCmd.lean", "Mathlib/Tactic/Simps/NotationClass.lean", "Mathlib/Init/Data/Nat/Notation.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/KVMap.lean", "lake-packages/std/Std/Data/List/Count.lean", "lake-packages/std/Std/Util/LibraryNote.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/std/Std/Classes/Dvd.lean", "Mathlib/Lean/Message.lean"], "premises": [{"full_name": "updateName", "code": "def updateName (nm : Name) (s : String) (isPrefix : Bool) : Name :=\n  nm.updateLast fun s' \u21a6 if isPrefix then s ++ \"_\" ++ s' else s' ++ \"_\" ++ s", "start": [65, 1], "end": [69, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSimpContextResult", "code": "def mkSimpContextResult (cfg : Meta.Simp.Config := {}) (simpOnly := false) (kind := SimpKind.simp)\n    (dischargeWrapper := DischargeWrapper.default) (hasStar := false) :\n    MetaM MkSimpContextResult := do\n  match dischargeWrapper with\n  | .default => pure ()\n  | _ =>\n    if kind == SimpKind.simpAll then\n      throwError \"'simp_all' tactic does not support 'discharger' option\"\n    if kind == SimpKind.dsimp then\n      throwError \"'dsimp' tactic does not support 'discharger' option\"\n  let simpTheorems \u2190 if simpOnly then\n    simpOnlyBuiltins.foldlM (\u00b7.addConst \u00b7) ({} : SimpTheorems)\n  else\n    getSimpTheorems\n  let congrTheorems \u2190 getSimpCongrTheorems\n  let ctx : Simp.Context := {\n    config       := cfg\n    simpTheorems := #[simpTheorems], congrTheorems\n  }\n  if !hasStar then\n    return { ctx, dischargeWrapper }\n  else\n    let mut simpTheorems := ctx.simpTheorems\n    let hs \u2190 getPropHyps\n    for h in hs do\n      unless simpTheorems.isErased (.fvar h) do\n        simpTheorems \u2190 simpTheorems.addTheorem (.fvar h) (\u2190 h.getDecl).toExpr\n    let ctx := { ctx with simpTheorems }\n    return { ctx, dischargeWrapper }", "start": [74, 1], "end": [105, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSimpContext", "code": "def mkSimpContext (cfg : Meta.Simp.Config := {}) (simpOnly := false) (kind := SimpKind.simp)\n    (dischargeWrapper := DischargeWrapper.default) (hasStar := false) :\n    MetaM Simp.Context := do\n  let data \u2190 mkSimpContextResult cfg simpOnly kind dischargeWrapper hasStar\n  return data.ctx", "start": [107, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "hasSimpAttribute", "code": "def hasSimpAttribute (env : Environment) (declName : Name) : Bool :=\n  simpExtension.getState env |>.lemmaNames.contains <| .decl declName", "start": [118, 1], "end": [120, 70], "kind": "commanddeclaration"}, {"full_name": "Simps.ProjectionData", "code": "structure ProjectionData where\n  \n  name : Name\n  \n  expr : Expr\n  \n  projNrs : List \u2115\n  \n  isDefault : Bool\n  \n  isPrefix : Bool\n  deriving Inhabited", "start": [357, 1], "end": [377, 21], "kind": "commanddeclaration"}, {"full_name": "Simps.ParsedProjectionData", "code": "structure ParsedProjectionData where\n  \n  strName : Name\n  \n  strStx : Syntax := .missing\n  \n  newName : Name\n  \n  newStx : Syntax := .missing\n  \n  isDefault : Bool := true\n  \n  isPrefix : Bool := false\n  \n  expr? : Option Expr := none\n  \n  projNrs : Array Nat := #[]\n  \n  isCustom : Bool := false", "start": [396, 1], "end": [415, 27], "kind": "commanddeclaration"}, {"full_name": "Simps.ParsedProjectionData.toProjectionData", "code": "def ParsedProjectionData.toProjectionData (p : ParsedProjectionData) : ProjectionData :=\n  { p with name := p.newName, expr := p.expr?.getD default, projNrs := p.projNrs.toList }", "start": [417, 1], "end": [419, 90], "kind": "commanddeclaration"}, {"full_name": "Simps.ProjectionRule", "code": "inductive ProjectionRule where\n  \n  | rename (oldName : Name) (oldStx : Syntax) (newName : Name) (newStx : Syntax) :\n      ProjectionRule\n  \n  | add : Name \u2192 Syntax \u2192 ProjectionRule\n  \n  | erase : Name \u2192 Syntax \u2192 ProjectionRule\n  \n  | prefix : Name \u2192 Syntax \u2192 ProjectionRule", "start": [427, 1], "end": [440, 44], "kind": "commanddeclaration"}, {"full_name": "Simps.projectionsInfo", "code": "def projectionsInfo (l : List ProjectionData) (pref : String) (str : Name) : MessageData :=\n  let \u27e8defaults, nondefaults\u27e9 := l.partition (\u00b7.isDefault)\n  let toPrint : List MessageData :=\n    defaults.map fun s \u21a6\n      let prefixStr := if s.isPrefix then \"(prefix) \" else \"\"\n      m!\"Projection {prefixStr}{s.name}: {s.expr}\"\n  let print2 : MessageData :=\n    String.join <| (nondefaults.map fun nm : ProjectionData \u21a6 toString nm.1).intersperse \", \"\n  let toPrint :=\n    toPrint ++\n      if nondefaults.isEmpty then [] else\n      [(\"No lemmas are generated for the projections: \" : MessageData) ++ print2 ++ \".\"]\n  let toPrint := MessageData.joinSep toPrint (\"\\n\" : MessageData)\n  m!\"{pref} {str}:\\n{toPrint}\"", "start": [453, 1], "end": [467, 31], "kind": "commanddeclaration"}, {"full_name": "Simps.findProjectionIndices", "code": "def findProjectionIndices (strName projName : Name) : MetaM (List \u2115) := do\n  let env \u2190 getEnv\n  let .some baseStr := findField? env strName projName |\n    throwError \"{strName} has no field {projName} in parent structure\"\n  let .some fullProjName := getProjFnForField? env baseStr projName |\n    throwError \"no such field {projName}\"\n  let .some pathToField := getPathToBaseStructure? env baseStr strName |\n    throwError \"no such field {projName}\"\n  let allProjs := pathToField ++ [fullProjName]\n  return allProjs.map (env.getProjectionFnInfo? \u00b7 |>.get!.i)", "start": [469, 1], "end": [481, 61], "kind": "commanddeclaration"}, {"full_name": "Simps.getCompositeOfProjectionsAux", "code": "partial def getCompositeOfProjectionsAux\n    (proj : String) (e : Expr) (pos : Array \u2115) (args : Array Expr) : MetaM (Expr \u00d7 Array \u2115) := do\n  let env \u2190 getEnv\n  let .const structName _ := (\u2190 whnf (\u2190inferType e)).getAppFn |\n    throwError \"{e} doesn't have a structure as type\"\n  let projs := getStructureFieldsFlattened env structName\n  let projInfo := projs.toList.map fun p \u21a6 do\n    ((\u2190 proj.dropPrefix? (p.getString ++ \"_\")).toString, p)\n  let some (projRest, projName) := projInfo.reduceOption.getLast? |\n    throwError \"Failed to find constructor {proj.dropRight 1} in structure {structName}.\"\n  let newE \u2190 mkProjection e projName\n  let newPos := pos ++ (\u2190 findProjectionIndices structName projName)\n  if projRest.isEmpty then\n    let newE \u2190 mkLambdaFVars args newE\n    return (newE, newPos)\n  let type \u2190 inferType newE\n  forallTelescopeReducing type fun typeArgs _tgt \u21a6 do\n    getCompositeOfProjectionsAux projRest (mkAppN newE typeArgs) newPos (args ++ typeArgs)", "start": [483, 1], "end": [502, 91], "kind": "commanddeclaration"}, {"full_name": "Simps.getCompositeOfProjections", "code": "def getCompositeOfProjections (structName : Name) (proj : String) : MetaM (Expr \u00d7 Array \u2115) := do\n  let strExpr \u2190 mkConstWithLevelParams structName\n  let type \u2190 inferType strExpr\n  forallTelescopeReducing type fun typeArgs _ \u21a6\n  withLocalDeclD `x (mkAppN strExpr typeArgs) fun e \u21a6\n  getCompositeOfProjectionsAux (proj ++ \"_\") e #[] <| typeArgs.push e", "start": [504, 1], "end": [523, 70], "kind": "commanddeclaration"}, {"full_name": "Simps.mkParsedProjectionData", "code": "def mkParsedProjectionData (structName : Name) : CoreM (Array ParsedProjectionData) := do\n  let env \u2190 getEnv\n  let projs := getStructureFields env structName\n  if projs.size == 0 then\n    throwError \"Declaration {structName} is not a structure.\"\n  let projData := projs.map fun fieldName \u21a6 {\n    strName := fieldName, newName := fieldName,\n    isDefault := isSubobjectField? env structName fieldName |>.isNone }\n  let parentProjs := getStructureFieldsFlattened env structName false\n  let parentProjs := parentProjs.filter (!projs.contains \u00b7)\n  let parentProjData := parentProjs.map fun nm \u21a6\n    {strName := nm, newName := nm}\n  return projData ++ parentProjData", "start": [525, 1], "end": [541, 36], "kind": "commanddeclaration"}, {"full_name": "Simps.applyProjectionRules", "code": "def applyProjectionRules (projs : Array ParsedProjectionData) (rules : Array ProjectionRule) :\n    CoreM (Array ParsedProjectionData) := do\n  let projs : Array ParsedProjectionData := rules.foldl (init := projs) fun projs rule \u21a6\n    match rule with\n    | .rename strName strStx newName newStx =>\n      if (projs.map (\u00b7.newName)).contains strName then\n        projs.map fun proj \u21a6 if proj.newName == strName then\n          { proj with\n            newName,\n            newStx,\n            strStx := if proj.strStx.isMissing then strStx else proj.strStx } else\n          proj else\n        projs.push {strName, strStx, newName, newStx}\n    | .erase nm stx =>\n      if (projs.map (\u00b7.newName)).contains nm then\n        projs.map fun proj \u21a6 if proj.newName = nm then\n          { proj with\n            isDefault := false,\n            strStx := if proj.strStx.isMissing then stx else proj.strStx } else\n          proj else\n        projs.push {strName := nm, newName := nm, strStx := stx, newStx := stx, isDefault := false}\n    | .add nm stx =>\n      if (projs.map (\u00b7.newName)).contains nm then\n        projs.map fun proj \u21a6 if proj.newName = nm then\n          { proj with\n            isDefault := true,\n            strStx := if proj.strStx.isMissing then stx else proj.strStx } else\n          proj else\n        projs.push {strName := nm, newName := nm, strStx := stx, newStx := stx}\n    | .prefix nm stx =>\n      if (projs.map (\u00b7.newName)).contains nm then\n        projs.map fun proj \u21a6 if proj.newName = nm then\n          { proj with\n            isPrefix := true,\n            strStx := if proj.strStx.isMissing then stx else proj.strStx } else\n          proj else\n        projs.push {strName := nm, newName := nm, strStx := stx, newStx := stx, isPrefix := true}\n  trace[simps.debug] \"Projection info after applying the rules: {projs}.\"\n  unless (projs.map (\u00b7.newName)).toList.Nodup do throwError\n    \"Invalid projection names. Two projections have the same name.\\n{\"\"\n    }This is likely because a custom composition of projections was given the same name as an {\"\"\n    }existing projection. Solution: rename the existing projection (before naming the {\"\"\n    }custom projection).\"\n  pure projs", "start": [543, 1], "end": [587, 13], "kind": "commanddeclaration"}, {"full_name": "Simps.findProjection", "code": "def findProjection (str : Name) (proj : ParsedProjectionData)\n    (rawUnivs : List Level) : CoreM ParsedProjectionData := do\n  let env \u2190 getEnv\n  let (rawExpr, nrs) \u2190 MetaM.run' <|\n    getCompositeOfProjections str proj.strName.getString\n  if !proj.strStx.isMissing then\n    _ \u2190 MetaM.run' <| TermElabM.run' <| addTermInfo proj.strStx rawExpr\n  trace[simps.debug] \"Projection {proj.newName} has default projection {rawExpr} and\n    uses projection indices {nrs}\"\n  let customName := str ++ `Simps ++ proj.newName\n  match env.find? customName with\n  | some d@(.defnInfo _) =>\n    let customProj := d.instantiateValueLevelParams! rawUnivs\n    trace[simps.verbose] \"found custom projection for {proj.newName}:{indentExpr customProj}\"\n    match (\u2190 MetaM.run' <| isDefEq customProj rawExpr) with\n    | true =>\n      _ \u2190 MetaM.run' <| TermElabM.run' <| addTermInfo proj.newStx <|\n        \u2190 mkConstWithLevelParams customName\n      pure { proj with expr? := some customProj, projNrs := nrs, isCustom := true }\n    | false =>\n      let customProjType \u2190 MetaM.run' (inferType customProj)\n      let rawExprType \u2190 MetaM.run' (inferType rawExpr)\n      if (\u2190 MetaM.run' (isDefEq customProjType rawExprType)) then\n        throwError \"Invalid custom projection:{indentExpr customProj}\\n{\"\"\n          }Expression is not definitionally equal to {indentExpr rawExpr}\" else\n        throwError \"Invalid custom projection:\\n  {customProj}\\n{\"\"\n          }Expression has different type than {str ++ proj.strName}. Given type:{\n          indentExpr customProjType}\\nExpected type:{indentExpr rawExprType\n          }\\nNote: make sure order of implicit arguments is exactly the same.\"\n  | _ =>\n    _ \u2190 MetaM.run' <| TermElabM.run' <| addTermInfo proj.newStx rawExpr\n    pure {proj with expr? := some rawExpr, projNrs := nrs}", "start": [589, 1], "end": [625, 59], "kind": "commanddeclaration"}, {"full_name": "Simps.checkForUnusedCustomProjs", "code": "def checkForUnusedCustomProjs (stx : Syntax) (str : Name) (projs : Array ParsedProjectionData) :\n    CoreM Unit := do\n  let nrCustomProjections := projs.toList.countP (\u00b7.isCustom)\n  let env \u2190 getEnv\n  let customDeclarations := env.constants.map\u2082.foldl (init := #[]) fun xs nm _ =>\n    if (str ++ `Simps).isPrefixOf nm && !nm.isInternal' then xs.push nm else xs\n  if nrCustomProjections < customDeclarations.size then\n    Linter.logLintIf linter.simpsUnusedCustomDeclarations stx\n      m!\"Not all of the custom declarations {customDeclarations} are used. Double check the {\n        \"\"}spelling, and use `?` to get more information.\"", "start": [627, 1], "end": [638, 59], "kind": "commanddeclaration"}, {"full_name": "Simps.findAutomaticProjectionsAux", "code": "def findAutomaticProjectionsAux (str : Name) (proj : ParsedProjectionData) (args : Array Expr) :\n    TermElabM <| Option (Expr \u00d7 Name) := do\n  if let some \u27e8className, isNotation, findArgs\u27e9 :=\n    notationClassAttr.find? (\u2190 getEnv) proj.strName then\n    let findArgs \u2190 unsafe evalConst findArgType findArgs\n    let classArgs \u2190 try findArgs str className args\n    catch ex =>\n      trace[simps.debug] \"Projection {proj.strName} is likely unrelated to the projection of {\n        className}:\\n{ex.toMessageData}\"\n      return none\n    let classArgs \u2190 classArgs.mapM fun e => match e with\n      | none => mkFreshExprMVar none\n      | some e => pure e\n    let classArgs := classArgs.map Arg.expr\n    let projName := (getStructureFields (\u2190 getEnv) className)[0]!\n    let projName := className ++ projName\n    let eStr := mkAppN (\u2190 mkConstWithLevelParams str) args\n    let eInstType \u2190\n      try withoutErrToSorry (elabAppArgs (\u2190 Term.mkConst className) #[] classArgs none true false)\n      catch ex =>\n        trace[simps.debug] \"Projection doesn't have the right type for the automatic projection:\\n{\n          ex.toMessageData}\"\n        return none\n    return \u2190 withLocalDeclD `self eStr fun instStr \u21a6 do\n      trace[simps.debug] \"found projection {proj.strName}. Trying to synthesize {eInstType}.\"\n      let eInst \u2190 try synthInstance eInstType\n      catch ex =>\n        trace[simps.debug] \"Didn't find instance:\\n{ex.toMessageData}\"\n        return none\n      let projExpr \u2190 elabAppArgs (\u2190 Term.mkConst projName) #[] (classArgs.push <| .expr eInst)\n        none true false\n      let projExpr \u2190 mkLambdaFVars (if isNotation then args.push instStr else args) projExpr\n      let projExpr \u2190 instantiateMVars projExpr\n      return (projExpr, projName)\n  return none", "start": [640, 1], "end": [683, 14], "kind": "commanddeclaration"}, {"full_name": "Simps.findAutomaticProjections", "code": "def findAutomaticProjections (str : Name) (projs : Array ParsedProjectionData) :\n    CoreM (Array ParsedProjectionData) := do\n  let strDecl \u2190 getConstInfo str\n  trace[simps.debug] \"debug: {projs}\"\n  MetaM.run' <| TermElabM.run' (s := {levelNames := strDecl.levelParams}) <|\n  forallTelescope strDecl.type fun args _ \u21a6 do\n  let projs \u2190 projs.mapM fun proj => do\n    if let some (projExpr, projName) := \u2190 findAutomaticProjectionsAux str proj args then\n      unless \u2190 isDefEq projExpr proj.expr?.get! do\n        throwError \"The projection {proj.newName} is not definitionally equal to an application {\n          \"\"}of {projName}:{indentExpr proj.expr?.get!}\\nvs{indentExpr projExpr}\"\n      if proj.isCustom then\n        trace[simps.verbose] \"Warning: Projection {proj.newName} is given manually by the user, {\n          \"\"}but it can be generated automatically.\"\n        return proj\n      trace[simps.verbose] \"Using {indentExpr projExpr}\\n for projection {proj.newName}.\"\n      return { proj with expr? := some projExpr }\n    return proj\n  return projs", "start": [685, 1], "end": [706, 15], "kind": "commanddeclaration"}, {"full_name": "Simps.getRawProjections", "code": "def getRawProjections (stx : Syntax) (str : Name) (traceIfExists : Bool := false)\n  (rules : Array ProjectionRule := #[]) (trc := false) :\n  CoreM (List Name \u00d7 Array ProjectionData) := do\n  withOptions (\u00b7 |>.updateBool `trace.simps.verbose (trc || \u00b7)) <| do\n  let env \u2190 getEnv\n  if let some data := (structureExt.getState env).find? str then\n    withOptions (\u00b7 |>.updateBool `trace.simps.verbose (traceIfExists || \u00b7)) <| do\n      trace[simps.debug]\n        projectionsInfo data.2.toList \"Already found projection information for structure\" str\n    return data\n  trace[simps.verbose] \"generating projection information for structure {str}.\"\n  trace[simps.debug] \"Applying the rules {rules}.\"\n  let strDecl \u2190 getConstInfo str\n  let rawLevels := strDecl.levelParams\n  let rawUnivs := rawLevels.map Level.param\n  let projs \u2190 mkParsedProjectionData str\n  let projs \u2190 applyProjectionRules projs rules\n  let projs \u2190 projs.mapM fun proj \u21a6 findProjection str proj rawUnivs\n  checkForUnusedCustomProjs stx str projs\n  let projs \u2190 findAutomaticProjections str projs\n  let projs := projs.map (\u00b7.toProjectionData)\n  let projs \u2190 projs.mapM fun proj \u21a6 do\n    match (\u2190 MetaM.run' <| isProof proj.expr) with\n    | true => pure { proj with isDefault := false }\n    | false => pure proj\n  trace[simps.verbose] projectionsInfo projs.toList \"generated projections for\" str\n  structureExt.add str (rawLevels, projs)\n  trace[simps.debug] \"Generated raw projection data:{indentD <| toMessageData (rawLevels, projs)}\"\n  pure (rawLevels, projs)", "start": [708, 1], "end": [778, 26], "kind": "commanddeclaration"}, {"full_name": "Simps.elabSimpsRule", "code": "def elabSimpsRule : Syntax \u2192 CommandElabM ProjectionRule\n  | `(simpsRule| $id1 \u2192 $id2)   => return .rename id1.getId id1.raw id2.getId id2.raw\n  | `(simpsRule| - $id)         => return .erase id.getId id.raw\n  | `(simpsRule| + $id)         => return .add id.getId id.raw\n  | `(simpsRule| as_prefix $id) => return .prefix id.getId id.raw\n  | _                           => Elab.throwUnsupportedSyntax", "start": [799, 1], "end": [806, 63], "kind": "commanddeclaration"}, {"full_name": "Simps.elabInitializeSimpsProjections", "code": "@[command_elab \u00abinitialize_simps_projections\u00bb] def elabInitializeSimpsProjections : CommandElab\n  | stx@`(initialize_simps_projections $[?%$trc]? $id $[($stxs,*)]?) => do\n    let stxs := stxs.getD <| .mk #[]\n    let rules \u2190 stxs.getElems.raw.mapM elabSimpsRule\n    let nm \u2190 resolveGlobalConstNoOverload id\n    _ \u2190 liftTermElabM <| addTermInfo id.raw <| \u2190 mkConstWithLevelParams nm\n    _ \u2190 liftCoreM <| getRawProjections stx nm true rules trc.isSome\n  | _ => throwUnsupportedSyntax", "start": [808, 1], "end": [816, 32], "kind": "commanddeclaration"}, {"full_name": "Simps.Config", "code": "structure Config where\n  \n  isSimp := true\n  \n  attrs : List Name := []\n  \n  simpRhs := false\n  \n  typeMd := TransparencyMode.instances\n  \n  rhsMd := TransparencyMode.reducible\n  \n  fullyApplied := true\n  \n  notRecursive := [`Prod, `PProd, `Opposite, `PreOpposite]\n  \n  debug := false\n  deriving Inhabited", "start": [818, 1], "end": [841, 21], "kind": "commanddeclaration"}, {"full_name": "Simps.Config.asFn", "code": "def Config.asFn : Simps.Config where\n  fullyApplied := false", "start": [846, 1], "end": [849, 24], "kind": "commanddeclaration"}, {"full_name": "Simps.Config.lemmasOnly", "code": "def Config.lemmasOnly : Config where\n  isSimp := false", "start": [851, 1], "end": [854, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.instantiateLambdasOrApps", "code": "partial def _root_.Lean.Expr.instantiateLambdasOrApps (es : Array Expr) (e : Expr) : Expr :=\n  e.betaRev es.reverse true", "start": [856, 1], "end": [863, 28], "kind": "commanddeclaration"}, {"full_name": "Simps.getProjectionExprs", "code": "def getProjectionExprs (stx : Syntax) (tgt : Expr) (rhs : Expr) (cfg : Config) :\n    MetaM <| Array <| Expr \u00d7 ProjectionData := do\n  let params := tgt.getAppArgs\n  if cfg.debug && !(\u2190 (params.zip rhs.getAppArgs).allM fun \u27e8a, b\u27e9 \u21a6 isDefEq a b) then\n    throwError \"unreachable code: parameters are not definitionally equal\"\n  let str := tgt.getAppFn.constName?.getD default\n  let rhsArgs := rhs.getAppArgs.toList.drop params.size\n  let (rawUnivs, projDeclata) \u2190 getRawProjections stx str\n  return projDeclata.map fun proj \u21a6\n    (rhsArgs.getD (a\u2080 := default) proj.projNrs.head!,\n      { proj with\n        expr := (proj.expr.instantiateLevelParams rawUnivs\n          tgt.getAppFn.constLevels!).instantiateLambdasOrApps params\n        projNrs := proj.projNrs.tail })", "start": [865, 1], "end": [905, 40], "kind": "commanddeclaration"}, {"full_name": "Simps.addProjection", "code": "def addProjection (declName : Name) (type lhs rhs : Expr) (args : Array Expr)\n    (cfg : Config) : MetaM Unit := do\n  trace[simps.debug] \"Planning to add the equality{indentD m!\"{lhs} = ({rhs} : {type})\"}\"\n  let env \u2190 getEnv\n  if (env.find? declName).isSome then throwError \"simps tried to add lemma {declName} to the environment, but it already exists.\"\n  let lvl \u2190 getLevel type\n  let mut (rhs, prf) := (rhs, mkAppN (mkConst `Eq.refl [lvl]) #[type, lhs])\n  if cfg.simpRhs then\n    let ctx \u2190 mkSimpContext\n    let (rhs2, _) \u2190 dsimp rhs ctx\n    if rhs != rhs2 then\n      trace[simps.debug] \"`dsimp` simplified rhs to{indentExpr rhs2}\"\n    else\n      trace[simps.debug] \"`dsimp` failed to simplify rhs\"\n    let (result, _) \u2190 simp rhs2 ctx\n    if rhs2 != result.expr then\n      trace[simps.debug] \"`simp` simplified rhs to{indentExpr result.expr}\"\n    else\n      trace[simps.debug] \"`simp` failed to simplify rhs\"\n    rhs := result.expr\n    prf := result.proof?.getD prf\n  let eqAp := mkApp3 (mkConst `Eq [lvl]) type lhs rhs\n  let declType \u2190 mkForallFVars args eqAp\n  let declValue \u2190 mkLambdaFVars args prf\n  trace[simps.verbose] \"adding projection {declName}:{indentExpr declType}\"\n  try\n    addDecl <| .thmDecl {\n      name := declName\n      levelParams := univs\n      type := declType\n      value := declValue }\n  catch ex =>\n    throwError \"Failed to add projection lemma {declName}. Nested error:\\n{ex.toMessageData}\"\n  addDeclarationRanges declName {\n    range := \u2190 getDeclarationRange (\u2190 getRef)\n    selectionRange := \u2190 getDeclarationRange ref }\n  _ \u2190 MetaM.run' <| TermElabM.run' <| addTermInfo (isBinder := true) ref <|\n    \u2190 mkConstWithLevelParams declName\n  if cfg.isSimp then\n    addSimpTheorem simpExtension declName true false .global <| eval_prio default\n  _ \u2190 cfg.attrs.mapM fun simpAttr \u21a6 do\n    let .some simpDecl \u2190 getSimpExtension? simpAttr |\n      throwError \"{simpAttr} is not a simp-attribute.\"\n    addSimpTheorem simpDecl declName true false .global <| eval_prio default", "start": [909, 1], "end": [956, 77], "kind": "commanddeclaration"}, {"full_name": "Simps.headStructureEtaReduce", "code": "partial def headStructureEtaReduce (e : Expr) : MetaM Expr := do\n  let env \u2190 getEnv\n  let (ctor, args) := e.getAppFnArgs\n  let some (.ctorInfo { induct := struct, numParams, ..}) := env.find? ctor | pure e\n  let some { fieldNames, .. } := getStructureInfo? env struct | pure e\n  let (params, fields) := args.toList.splitAt numParams trace[simps.debug]\n    \"rhs is constructor application with params{indentD params}\\nand fields {indentD fields}\"\n  let field0 :: fieldsTail := fields | return e\n  let fieldName0 :: fieldNamesTail := fieldNames.toList | return e\n  let (fn0, fieldArgs0) := field0.getAppFnArgs\n  unless fn0 == struct ++ fieldName0 do\n    trace[simps.debug] \"{fn0} \u2260 {struct ++ fieldName0}\"\n    return e\n  let (params', reduct :: _) := fieldArgs0.toList.splitAt numParams | unreachable!\n  unless params' == params do\n    trace[simps.debug] \"{params'} \u2260 {params}\"\n    return e\n  trace[simps.debug] \"Potential structure-eta-reduct:{indentExpr e}\\nto{indentExpr reduct}\"\n  let allArgs := params.toArray.push reduct\n  let isEta \u2190 (fieldsTail.zip fieldNamesTail).allM fun (field, fieldName) \u21a6\n    if field.getAppFnArgs == (struct ++ fieldName, allArgs) then pure true else isProof field\n  unless isEta do return e\n  trace[simps.debug] \"Structure-eta-reduce:{indentExpr e}\\nto{indentExpr reduct}\"\n  headStructureEtaReduce reduct", "start": [958, 1], "end": [987, 32], "kind": "commanddeclaration"}, {"full_name": "Simps.addProjections", "code": "partial def addProjections (nm : Name) (type lhs rhs : Expr)\n  (args : Array Expr) (mustBeStr : Bool) (cfg : Config)\n  (todo : List (String \u00d7 Syntax)) (toApply : List \u2115) : MetaM (Array Name) := do\n  trace[simps.debug] \"Type of the Expression before normalizing: {type}\"\n  withTransparency cfg.typeMd <| forallTelescopeReducing type fun typeArgs tgt \u21a6 withDefault do\n  trace[simps.debug] \"Type after removing pi's: {tgt}\"\n  let tgt \u2190 whnfD tgt\n  trace[simps.debug] \"Type after reduction: {tgt}\"\n  let newArgs := args ++ typeArgs\n  let lhsAp := lhs.instantiateLambdasOrApps typeArgs\n  let rhsAp := rhs.instantiateLambdasOrApps typeArgs\n  let str := tgt.getAppFn.constName\n  trace[simps.debug] \"todo: {todo}, toApply: {toApply}\"\n  let todoNext := todo.filter (\u00b7.1 \u2260 \"\")\n  let env \u2190 getEnv\n  let stx? := todo.find? (\u00b7.1 == \"\") |>.map (\u00b7.2)\n  \n  let stxProj := stx?.getD ref[0]\n  let strInfo? := getStructureInfo? env str\n  \n  if strInfo?.isNone ||\n    (todo.isEmpty && str \u2208 cfg.notRecursive && !mustBeStr && toApply.isEmpty) then\n    if mustBeStr then\n      throwError \"Invalid `simps` attribute. Target {str} is not a structure\"\n    if !todoNext.isEmpty && str \u2209 cfg.notRecursive then\n      let firstTodo := todoNext.head!.1\n      throwError \"Invalid simp lemma {nm.appendAfter firstTodo}.\\nProjection {\n        (firstTodo.splitOn \"_\")[1]!} doesn't exist, because target {str} is not a structure.\"\n    if cfg.fullyApplied then\n      addProjection stxProj univs nm tgt lhsAp rhsAp newArgs cfg\n    else\n      addProjection stxProj univs nm type lhs rhs args cfg\n    return #[nm]\n  let some (.inductInfo { isRec := false, ctors := [ctor], .. }) := env.find? str | unreachable!\n  trace[simps.debug] \"{str} is a structure with constructor {ctor}.\"\n  let rhsEta \u2190 headStructureEtaReduce rhsAp\n  let addThisProjection := stx?.isSome && toApply.isEmpty\n  if addThisProjection then\n    if cfg.fullyApplied then\n      addProjection stxProj univs nm tgt lhsAp rhsEta newArgs cfg\n    else\n      addProjection stxProj univs nm type lhs rhs args cfg\n  let rhsWhnf \u2190 withTransparency cfg.rhsMd <| whnf rhsEta\n  trace[simps.debug] \"The right-hand-side {indentExpr rhsAp}\\n reduces to {indentExpr rhsWhnf}\"\n  if !rhsWhnf.getAppFn.isConstOf ctor then\n    if cfg.rhsMd == .reducible && (mustBeStr || !todoNext.isEmpty || !toApply.isEmpty) then\n      trace[simps.debug] \"Using relaxed reducibility.\"\n      Linter.logLintIf linter.simpsNoConstructor ref\n        m!\"The definition {nm} is not a constructor application. Please use `@[simps!]` instead.{\n        \"\"}\\n\\nExplanation: `@[simps]` uses the definition to find what the simp lemmas should {\n        \"\"}be. If the definition is a constructor, then this is easy, since the values of the {\n        \"\"}projections are just the arguments to the constructor. If the definition is not a {\n        \"\"}constructor, then `@[simps]` will unfold the right-hand side until it has found a {\n        \"\"}constructor application, and uses those values.\\n\\n{\n        \"\"}This might not always result in the simp-lemmas you want, so you are advised to use {\n        \"\"}`@[simps?]` to double-check whether `@[simps]` generated satisfactory lemmas.\\n{\n        \"\"}Note 1: `@[simps!]` also calls the `simp` tactic, and this can be expensive in certain {\n        \"\"}cases.\\n{\n        \"\"}Note 2: `@[simps!]` is equivalent to `@[simps (config := \\{rhsMd := .default, {\n        \"\"}simpRhs := true})]`. You can also try `@[simps (config := \\{rhsMd := .default})]` {\n        \"\"}to still unfold the definitions, but avoid calling `simp` on the resulting statement.\\n{\n        \"\"}Note 3: You need `simps!` if not all fields are given explicitly in this definition, {\n        \"\"}even if the definition is a constructor application. For example, if you give a {\n        \"\"}`MulEquiv` by giving the corresponding `Equiv` and the proof that it respects {\n        \"\"}multiplication, then you need to mark it as `@[simps!]`, since the attribute needs to {\n        \"\"}unfold the corresponding `Equiv` to get to the `toFun` field.\"\n      let nms \u2190 addProjections nm type lhs rhs args mustBeStr\n        { cfg with rhsMd := .default, simpRhs := true } todo toApply\n      return if addThisProjection then nms.push nm else nms\n    if !toApply.isEmpty then\n      throwError \"Invalid simp lemma {nm}.\\nThe given definition is not a constructor {\"\"\n        }application:{indentExpr rhsWhnf}\"\n    if mustBeStr then\n      throwError \"Invalid `simps` attribute. The body is not a constructor application:{\n        indentExpr rhsWhnf}\"\n    if !todoNext.isEmpty then\n      throwError \"Invalid simp lemma {nm.appendAfter todoNext.head!.1}.\\n{\"\"\n        }The given definition is not a constructor application:{indentExpr rhsWhnf}\"\n    if !addThisProjection then\n      if cfg.fullyApplied then\n        addProjection stxProj univs nm tgt lhsAp rhsEta newArgs cfg\n      else\n        addProjection stxProj univs nm type lhs rhs args cfg\n    return #[nm]\n  trace[simps.debug] \"Generating raw projection information...\"\n  let projInfo \u2190 getProjectionExprs ref tgt rhsWhnf cfg\n  trace[simps.debug] \"Raw projection information:{indentD m!\"{projInfo}\"}\"\n  if let idx :: rest := toApply then\n    let some \u27e8newRhs, _\u27e9 := projInfo[idx]?\n      | throwError \"unreachable: index of composite projection is out of bounds.\"\n    let newType \u2190 inferType newRhs\n    trace[simps.debug] \"Applying a custom composite projection. Todo: {toApply}. Current lhs:{\n      indentExpr lhsAp}\"\n    return \u2190 addProjections nm newType lhsAp newRhs newArgs false cfg todo rest\n  trace[simps.debug] \"Not in the middle of applying a custom composite projection\"\n  \n  if todo.length == 1 && todo.head!.1 == \"\" then return #[nm]\n  let projs : Array Name := projInfo.map fun x \u21a6 x.2.name\n  let todo := todoNext\n  trace[simps.debug] \"Next todo: {todoNext}\"\n  if let some (x, _) := todo.find? fun (x, _) \u21a6 projs.all\n    fun proj \u21a6 !(proj.getString ++ \"_\").isPrefixOf x then\n    let simpLemma := nm.appendAfter x\n    let neededProj := (x.splitOn \"_\")[0]!\n    throwError \"Invalid simp lemma {simpLemma}. Structure {str} does not have projection {\"\"\n      }{neededProj}.\\nThe known projections are:\\n  {projs}\\nYou can also see this information {\"\"\n      }by running\\n  `initialize_simps_projections? {str}`.\\nNote: these projection names might {\"\"\n      }be customly defined for `simps`, and could differ from the projection names of the {\"\"\n      }structure.\"\n  let nms \u2190 projInfo.concatMapM fun \u27e8newRhs, proj, projExpr, projNrs, isDefault, isPrefix\u27e9 \u21a6 do\n    let newType \u2190 inferType newRhs\n    let newTodo := todo.filterMap\n      fun (x, stx) \u21a6 (x.dropPrefix? (proj.getString ++ \"_\")).map (\u00b7.toString, stx)\n    if !(isDefault && todo.isEmpty) && newTodo.isEmpty then return #[]\n    let newLhs := projExpr.instantiateLambdasOrApps #[lhsAp]\n    let newName := updateName nm proj.getString isPrefix\n    trace[simps.debug] \"Recursively add projections for:{indentExpr newLhs}\"\n    addProjections newName newType newLhs newRhs newArgs false cfg newTodo projNrs\n  return if addThisProjection then nms.push nm else nms", "start": [989, 1], "end": [1128, 56], "kind": "commanddeclaration"}, {"full_name": "simpsTac", "code": "def simpsTac (ref : Syntax) (nm : Name) (cfg : Config := {})\n    (todo : List (String \u00d7 Syntax) := []) (trc := false) : AttrM (Array Name) :=\n  withOptions (\u00b7 |>.updateBool `trace.simps.verbose (trc || \u00b7)) <| do\n  let env \u2190 getEnv\n  let some d := env.find? nm | throwError \"Declaration {nm} doesn't exist.\"\n  let lhs : Expr := mkConst d.name <| d.levelParams.map Level.param\n  let todo := todo.pwFilter (\u00b7.1 \u2260 \u00b7.1) |>.map fun (proj, stx) \u21a6 (proj ++ \"_\", stx)\n  let mut cfg := cfg\n  MetaM.run' <| addProjections ref d.levelParams\n    nm d.type lhs (d.value?.getD default) #[] (mustBeStr := true) cfg todo []", "start": [1133, 1], "end": [1146, 78], "kind": "commanddeclaration"}, {"full_name": "simpsTacFromSyntax", "code": "def simpsTacFromSyntax (nm : Name) (stx : Syntax) : AttrM (Array Name) :=\n  match stx with\n  | `(attr| simps $[!%$bang]? $[?%$trc]? $[(config := $c)]? $[$ids]*) => do\n    let cfg \u2190 MetaM.run' <| TermElabM.run' <| withSaveInfoContext <| elabSimpsConfig stx[3][0]\n    let cfg := if bang.isNone then cfg else { cfg with rhsMd := .default, simpRhs := true }\n    let ids := ids.map fun x => (x.getId.eraseMacroScopes.getString, x.raw)\n    simpsTac stx nm cfg ids.toList trc.isSome\n  | _ => throwUnsupportedSyntax", "start": [1148, 1], "end": [1156, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Array/Defs.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Array.cyclicPermute!", "code": "def cyclicPermute! [Inhabited \u03b1] : Array \u03b1 \u2192 List Nat \u2192 Array \u03b1\n  | a, []      => a\n  | a, i :: is => cyclicPermuteAux a is a[i]! i\nwhere cyclicPermuteAux : Array \u03b1 \u2192 List Nat \u2192 \u03b1 \u2192 Nat \u2192 Array \u03b1\n| a, [], x, i0 => a.set! i0 x\n| a, i :: is, x, i0 =>\n  let (y, a) := a.swapAt! i x\n  cyclicPermuteAux a is y i0", "start": [20, 1], "end": [30, 29], "kind": "commanddeclaration"}, {"full_name": "Array.permute!", "code": "def permute! [Inhabited \u03b1] (a : Array \u03b1) (ls : List (List Nat)) : Array \u03b1 :=\nls.foldl (init := a) (\u00b7.cyclicPermute! \u00b7)", "start": [32, 1], "end": [34, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Meta/Simp.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Tactic/OpenPrivate.lean", "lake-packages/std/Std/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PHashSet.toList", "code": "def Lean.PHashSet.toList [BEq \u03b1] [Hashable \u03b1] (s : Lean.PHashSet \u03b1) : List \u03b1 :=\n  s.1.toList.map (\u00b7.1)", "start": [20, 1], "end": [21, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.mkEqSymm", "code": "def mkEqSymm (e : Expr) (r : Simp.Result) : MetaM Simp.Result :=\n  ({ expr := e, proof? := \u00b7 }) <$>\n  match r.proof? with\n  | none => pure none\n  | some p => some <$> Meta.mkEqSymm p", "start": [40, 1], "end": [44, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.mkCast", "code": "def mkCast (r : Simp.Result) (e : Expr) : MetaM Expr := do\n  mkAppM ``cast #[\u2190 r.getProof, e]", "start": [46, 1], "end": [47, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Result.ofTrue", "code": "def Result.ofTrue (r : Simp.Result) : MetaM (Option Expr) :=\n  if r.expr.isConstOf ``True then\n    some <$> match r.proof? with\n    | some proof => mkOfEqTrue proof\n    | none => pure (mkConst ``True.intro)\n  else\n    pure none", "start": [49, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.getPropHyps", "code": "def getPropHyps : MetaM (Array FVarId) := do\n  let mut result := #[]\n  for localDecl in (\u2190 getLCtx) do\n    unless localDecl.isAuxDecl do\n      if (\u2190 isProp localDecl.type) then\n        result := result.push localDecl.fvarId\n  return result", "start": [61, 1], "end": [68, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.mkSimpContext'", "code": "def mkSimpContext' (simpTheorems : SimpTheorems) (stx : Syntax) (eraseLocal : Bool)\n    (kind := SimpKind.simp) (ctx := false) (ignoreStarArg : Bool := false) :\n    TacticM MkSimpContextResult := do\n  if ctx && !stx[2].isNone then\n    if kind == SimpKind.simpAll then\n      throwError \"'simp_all' tactic does not support 'discharger' option\"\n    if kind == SimpKind.dsimp then\n      throwError \"'dsimp' tactic does not support 'discharger' option\"\n  let dischargeWrapper \u2190 mkDischargeWrapper stx[2]\n  let simpOnly := !stx[3].isNone\n  let simpTheorems \u2190 if simpOnly then\n    simpOnlyBuiltins.foldlM (\u00b7.addConst \u00b7) {}\n  else\n    pure simpTheorems\n  let congrTheorems \u2190 Meta.getSimpCongrTheorems\n  let r \u2190 elabSimpArgs stx[4] (eraseLocal := eraseLocal) (kind := kind) {\n    config       := (\u2190 elabSimpConfig stx[1] (kind := kind))\n    simpTheorems := #[simpTheorems], congrTheorems\n  }\n  if !r.starArg || ignoreStarArg then\n    return { r with dischargeWrapper }\n  else\n    let mut simpTheorems := r.ctx.simpTheorems\n    let hs \u2190 getPropHyps\n    for h in hs do\n      unless simpTheorems.isErased (.fvar h) do\n        simpTheorems \u2190 simpTheorems.addTheorem (.fvar h) (\u2190 h.getDecl).toExpr\n    return { ctx := { r.ctx with simpTheorems }, dischargeWrapper }", "start": [73, 1], "end": [105, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.mkSimpTheoremsFromConst'", "code": "def mkSimpTheoremsFromConst' (declName : Name) (post : Bool) (inv : Bool) (prio : Nat) :\n    MetaM (Array Name \u00d7 Array SimpTheorem) := do\n  let cinfo \u2190 getConstInfo declName\n  let val := mkConst declName (cinfo.levelParams.map mkLevelParam)\n  withReducible do\n    let type \u2190 inferType val\n    checkTypeIsProp type\n    if inv || (\u2190 shouldPreprocess type) then\n      let mut r := #[]\n      let mut auxNames := #[]\n      for (val, type) in (\u2190 preprocess val type inv (isGlobal := true)) do\n        let auxName \u2190 mkAuxLemma cinfo.levelParams type val\n        auxNames := auxNames.push auxName\n        r := r.push <| \u2190 mkSimpTheoremCore (.decl declName)\n          (mkConst auxName (cinfo.levelParams.map mkLevelParam)) #[] (mkConst auxName) post prio\n      return (auxNames, r)\n    else\n      return (#[], #[\u2190 mkSimpTheoremCore (.decl declName) (mkConst declName <|\n        cinfo.levelParams.map mkLevelParam) #[] (mkConst declName) post prio])", "start": [110, 1], "end": [132, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.addSimpTheorem'", "code": "def addSimpTheorem' (ext : SimpExtension) (declName : Name) (post : Bool) (inv : Bool)\n    (attrKind : AttributeKind) (prio : Nat) : MetaM (Array Name) := do\n  let (auxNames, simpThms) \u2190 mkSimpTheoremsFromConst' declName post inv prio\n  for simpThm in simpThms do\n    ext.add (SimpEntry.thm simpThm) attrKind\n  return auxNames", "start": [134, 1], "end": [141, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.addSimpAttr", "code": "def addSimpAttr (declName : Name) (ext : SimpExtension) (attrKind : AttributeKind)\n    (post : Bool) (prio : Nat) :\n    MetaM (Array Name) := do\n  let info \u2190 getConstInfo declName\n  if (\u2190 isProp info.type) then\n    addSimpTheorem' ext declName post (inv := false) attrKind prio\n  else if info.hasValue then\n    if let some eqns \u2190 getEqnsFor? declName then\n      let mut auxNames := #[]\n      for eqn in eqns do\n        let newAuxNames \u2190 addSimpTheorem' ext eqn post (inv := false) attrKind prio\n        auxNames := auxNames ++ newAuxNames\n      ext.add (SimpEntry.toUnfoldThms declName eqns) attrKind\n      if hasSmartUnfoldingDecl (\u2190 getEnv) declName then\n        ext.add (SimpEntry.toUnfold declName) attrKind\n      return auxNames\n    else\n      ext.add (SimpEntry.toUnfold declName) attrKind\n      return #[]\n  else\n    throwError \"invalid 'simp', it is not a proposition nor a definition (to unfold)\"", "start": [143, 1], "end": [166, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.addSimpAttrFromSyntax", "code": "def addSimpAttrFromSyntax (declName : Name) (ext : SimpExtension) (attrKind : AttributeKind)\n    (stx : Syntax) : MetaM (Array Name) := do\n  let post := if stx[1].isNone then true else stx[1][0].getKind == ``Lean.Parser.Tactic.simpPost\n  let prio \u2190 getAttrParamOptPrio stx[2]\n  addSimpAttr declName ext attrKind post prio", "start": [168, 1], "end": [174, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.simpTheoremsOfNames", "code": "def simpTheoremsOfNames (lemmas : List Name := []) (simpOnly : Bool := false) :\n    MetaM SimpTheorems := do\n  lemmas.foldlM (\u00b7.addConst \u00b7)\n    (if simpOnly then\n      \u2190 simpOnlyBuiltins.foldlM (\u00b7.addConst \u00b7) {}\n    else\n      \u2190 getSimpTheorems)", "start": [178, 1], "end": [185, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Simp.Context.ofNames", "code": "def Simp.Context.ofNames (lemmas : List Name := []) (simpOnly : Bool := false)\n    (config : Simp.Config := {}) : MetaM Simp.Context := do pure <|\n  { simpTheorems := #[\u2190 simpTheoremsOfNames lemmas simpOnly],\n    congrTheorems := \u2190 Lean.Meta.getSimpCongrTheorems,\n    config := config }", "start": [191, 1], "end": [196, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.simpOnlyNames", "code": "def simpOnlyNames (lemmas : List Name) (e : Expr) (config : Simp.Config := {}) :\n    MetaM Simp.Result := do\n  (\u00b7.1) <$> simp e (\u2190 Simp.Context.ofNames lemmas true config)", "start": [198, 1], "end": [201, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.simpType", "code": "def simpType (S : Expr \u2192 MetaM Simp.Result) (e : Expr) : MetaM Expr := do\n  match (\u2190 S (\u2190 inferType e)) with\n  | \u27e8ty', none, _\u27e9 => mkExpectedTypeHint e ty'\n  | \u27e8ty', some prf, _\u27e9 => mkExpectedTypeHint (\u2190 mkEqMP prf e) ty'", "start": [203, 1], "end": [212, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.simpEq", "code": "def simpEq (S : Expr \u2192 MetaM Simp.Result) (type pf : Expr) : MetaM (Expr \u00d7 Expr) := do\n  forallTelescope type fun fvars type => do\n    let .app (.app (.app (.const `Eq [u]) \u03b1) lhs) rhs := type | throwError \"simpEq expecting Eq\"\n    let \u27e8lhs', lhspf?, _\u27e9 \u2190 S lhs\n    let \u27e8rhs', rhspf?, _\u27e9 \u2190 S rhs\n    let mut pf' := mkAppN pf fvars\n    if let some lhspf := lhspf? then\n      pf' \u2190 mkEqTrans (\u2190 mkEqSymm lhspf) pf'\n    if let some rhspf := rhspf? then\n      pf' \u2190 mkEqTrans pf' rhspf\n    let type' := mkApp3 (mkConst ``Eq [u]) \u03b1 lhs' rhs'\n    return (\u2190 mkForallFVars fvars type', \u2190 mkLambdaFVars fvars pf')", "start": [214, 1], "end": [228, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.SimpTheorems.contains", "code": "def SimpTheorems.contains (d : SimpTheorems) (declName : Name) :=\n  d.isLemma (.decl declName) || d.isDeclToUnfold declName", "start": [230, 1], "end": [232, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.isInSimpSet", "code": "def isInSimpSet (simpAttr decl : Name) : CoreM Bool := do\n  let .some simpDecl \u2190 getSimpExtension? simpAttr | return false\n  return (\u2190 simpDecl.getTheorems).contains decl", "start": [234, 1], "end": [238, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.getAllSimpDecls", "code": "def getAllSimpDecls (simpAttr : Name) : CoreM (List Name) := do\n  let .some simpDecl \u2190 getSimpExtension? simpAttr | return []\n  let thms \u2190 simpDecl.getTheorems\n  return thms.toUnfold.toList ++ thms.lemmaNames.toList.filterMap fun\n    | .decl decl => some decl\n    | _ => none", "start": [240, 1], "end": [247, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.getAllSimpAttrs", "code": "def getAllSimpAttrs (decl : Name) : CoreM (Array Name) := do\n  let mut simpAttrs := #[]\n  for (simpAttr, simpDecl) in (\u2190 simpExtensionMapRef.get).toList do\n    if (\u2190 simpDecl.getTheorems).contains decl then\n      simpAttrs := simpAttrs.push simpAttr\n  return simpAttrs", "start": [249, 1], "end": [255, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/String/Defs.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "String.leftpad", "code": "def leftpad (n : Nat) (c : Char) (s : String) : String :=\n  \u27e8List.leftpad n c s.data\u27e9", "start": [25, 1], "end": [28, 28], "kind": "commanddeclaration"}, {"full_name": "String.replicate", "code": "def replicate (n : Nat) (c : Char) : String :=\n  \u27e8List.replicate n c\u27e9", "start": [30, 1], "end": [32, 23], "kind": "commanddeclaration"}, {"full_name": "String.IsPrefix", "code": "def IsPrefix : String \u2192 String \u2192 Prop\n  | \u27e8d1\u27e9, \u27e8d2\u27e9 => List.IsPrefix d1 d2", "start": [34, 1], "end": [36, 38], "kind": "commanddeclaration"}, {"full_name": "String.IsSuffix", "code": "def IsSuffix : String \u2192 String \u2192 Prop\n  | \u27e8d1\u27e9, \u27e8d2\u27e9 => List.IsSuffix d1 d2", "start": [38, 1], "end": [40, 38], "kind": "commanddeclaration"}, {"full_name": "String.mapTokens", "code": "def mapTokens (c : Char) (f : String \u2192 String) : String \u2192 String :=\n  intercalate (singleton c) \u2218 List.map f \u2218 (\u00b7.split (\u00b7 = c))", "start": [42, 1], "end": [45, 61], "kind": "commanddeclaration"}, {"full_name": "String.getRest", "code": "def getRest (s t : String) : Option String :=\n  List.asString <$> s.toList.getRest t.toList", "start": [48, 1], "end": [51, 46], "kind": "commanddeclaration"}, {"full_name": "String.head", "code": "def head (s : String) : Char :=\n  s.iter.curr", "start": [56, 1], "end": [58, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/EnvExtension.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/aesop/Aesop/Tree/TreeM.lean", "imports": ["lake-packages/aesop/Aesop/Tree/RunMetaM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Tree", "code": "structure Tree where\n  root : MVarClusterRef\n  rootMetaState : Meta.SavedState\n  numGoals : Nat\n  numRapps : Nat\n  nextGoalId : GoalId\n  nextRappId : RappId", "start": [14, 1], "end": [20, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkInitialTree", "code": "def mkInitialTree (goal : MVarId) : MetaM Tree := do\n  let rootClusterRef \u2190 IO.mkRef $ MVarCluster.mk {\n    parent? := none\n    goals := #[] isIrrelevant := false\n    state := NodeState.unknown\n  }\n  let rootGoalRef \u2190 IO.mkRef $ Goal.mk {\n    id := GoalId.zero\n    parent := rootClusterRef\n    children := #[]\n    origin := .subgoal\n    depth := 0\n    state := GoalState.unknown\n    isIrrelevant := false\n    isForcedUnprovable := false\n    preNormGoal := goal\n    normalizationState := NormalizationState.notNormal\n    mvars := .ofHashSet (\u2190 goal.getMVarDependencies)\n    successProbability := Percent.hundred\n    addedInIteration := Iteration.one\n    lastExpandedInIteration := Iteration.none\n    unsafeRulesSelected := false\n    unsafeQueue := {}\n    failedRapps := #[]\n  }\n  rootClusterRef.modify \u03bb c => c.setGoals #[rootGoalRef]\n  return {\n    root := rootClusterRef\n    rootMetaState := \u2190 saveState\n    numGoals := 1\n    numRapps := 0\n    nextGoalId := GoalId.one\n    nextRappId := RappId.zero\n  }", "start": [22, 1], "end": [56, 4], "kind": "commanddeclaration"}, {"full_name": "Aesop.TreeM.Context", "code": "structure TreeM.Context where\n  currentIteration : Iteration", "start": [58, 1], "end": [59, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.TreeM", "code": "abbrev TreeM := ReaderT TreeM.Context $ StateRefT Tree MetaM", "start": [61, 1], "end": [61, 61], "kind": "commanddeclaration"}, {"full_name": "Aesop.TreeM.run'", "code": "def run' (ctx : TreeM.Context) (t : Tree) (x : TreeM \u03b1) :\n    MetaM (\u03b1 \u00d7 Tree) :=\n  ReaderT.run x ctx |>.run t", "start": [73, 1], "end": [75, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.getRootMVarCluster", "code": "def getRootMVarCluster : TreeM MVarClusterRef :=\n  return (\u2190 get).root", "start": [80, 1], "end": [81, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.getRootMetaState", "code": "def getRootMetaState : TreeM Meta.SavedState :=\n  return (\u2190 get).rootMetaState", "start": [83, 1], "end": [84, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.getRootGoal", "code": "def getRootGoal : TreeM GoalRef := do\n  let cref \u2190 getRootMVarCluster\n  let grefs := (\u2190 cref.get).goals\n  if h : grefs.size = 1 then\n    return grefs.get \u27e80, by simp [h]\u27e9\n  else\n    throwError \"aesop: internal error: unexpected number of goals in root mvar cluster: {grefs.size}\"", "start": [86, 1], "end": [92, 102], "kind": "commanddeclaration"}, {"full_name": "Aesop.getRootMVarId", "code": "def getRootMVarId : TreeM MVarId := do\n  let gref \u2190 getRootGoal\n  return (\u2190 gref.get).preNormGoal", "start": [94, 1], "end": [96, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.incrementNumGoals", "code": "def incrementNumGoals (increment := 1) : TreeM Unit := do\n  modify \u03bb s => { s with numGoals := s.numGoals + increment }", "start": [98, 1], "end": [99, 62], "kind": "commanddeclaration"}, {"full_name": "Aesop.incrementNumRapps", "code": "def incrementNumRapps (increment := 1) : TreeM Unit := do\n  modify \u03bb s => { s with numRapps := s.numRapps + increment }", "start": [101, 1], "end": [102, 62], "kind": "commanddeclaration"}, {"full_name": "Aesop.getAndIncrementNextGoalId", "code": "def getAndIncrementNextGoalId : TreeM GoalId := do\n  let t \u2190 get\n  let curr := t.nextGoalId\n  set { t with nextGoalId := curr.succ }\n  return curr", "start": [104, 1], "end": [108, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.getAndIncrementNextRappId", "code": "def getAndIncrementNextRappId : TreeM RappId := do\n  let t \u2190 get\n  let curr := t.nextRappId\n  set { t with nextRappId := curr.succ }\n  return curr", "start": [110, 1], "end": [114, 14], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/RuleTac/RuleApplicationWithMVarInfo.lean", "imports": ["lake-packages/aesop/Aesop/RuleTac/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleApplicationWithMVarInfo", "code": "structure RuleApplicationWithMVarInfo where\n  postState : Meta.SavedState\n  originalSubgoals : Array MVarId\n  goals : Array (MVarId \u00d7 UnorderedArraySet MVarId)\n  mvars : UnorderedArraySet MVarId\n  introducedMVars : UnorderedArraySet MVarId\n  assignedMVars : UnorderedArraySet MVarId\n  successProbability? : Option Percent\n  scriptBuilder? : Option (ScriptBuilder MetaM)", "start": [34, 1], "end": [42, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleApplicationWithMVarInfo.check", "code": "protected def check (preState : Meta.SavedState) (parentGoal : MVarId)\n    (r : RuleApplicationWithMVarInfo) : MetaM (Option MessageData) := do\n  let mut actualIntroducedMVars : HashSet MVarId := {}\n  for (_, mvars) in r.goals do\n    for mvarId in mvars do\n      unless \u2190 preState.runMetaM' mvarId.isDeclared do\n        actualIntroducedMVars := actualIntroducedMVars.insert mvarId\n  let unreportedIntroducedMVars :=\n    actualIntroducedMVars.toArray.filter (! r.introducedMVars.contains \u00b7)\n  unless unreportedIntroducedMVars.isEmpty do\n    return m!\"the following mvars were introduced but not reported: {unreportedIntroducedMVars.map (\u00b7.name)}\"\n  let overreportedIntroducedMVars :=\n    r.introducedMVars.toArray.filter (! actualIntroducedMVars.contains \u00b7)\n  unless overreportedIntroducedMVars.isEmpty do\n    return m!\"the following mvars were reported as introduced but do not exist or were already present before the rule was applied: {overreportedIntroducedMVars.map (\u00b7.name)}\"\n\n  let actualAssignedMVars :=\n    (\u2190 getAssignedExprMVars preState r.postState).erase parentGoal\n  unless actualAssignedMVars.equalSet r.assignedMVars.toArray do\n    return m!\"rule reported wrong assigned mvars.\\n  reported: {r.assignedMVars.toArray.map (\u00b7.name)}\\n  actual: {actualAssignedMVars.map (\u00b7.name)}\"\n  return none", "start": [46, 1], "end": [68, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleApplication.toRuleApplicationWithMVarInfo", "code": "def RuleApplication.toRuleApplicationWithMVarInfo\n    (parentMVars : UnorderedArraySet MVarId) (r : RuleApplication) :\n    MetaM RuleApplicationWithMVarInfo :=\n  let originalSubgoals := r.goals\n  r.postState.runMetaM' do\n    r.postState.runMetaM' do\n    let assignedMVars \u2190 parentMVars.filterM (\u00b7.isAssignedOrDelayedAssigned)\n    let (goals, mvars) \u2190 partitionGoalsAndMVars r.goals\n    let introducedMVars := mvars.filter (! parentMVars.contains \u00b7)\n    return {\n      r with\n      originalSubgoals, goals, mvars, introducedMVars, assignedMVars\n    }", "start": [72, 1], "end": [85, 6], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/State.lean", "imports": ["lake-packages/aesop/Aesop/Tree/Traversal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Goal.isIrrelevantNoCache", "code": "def Goal.isIrrelevantNoCache (g : Goal) : BaseIO Bool :=\n  (return g.state.isIrrelevant) <||>\n  (return (\u2190 g.parent.get).isIrrelevant)", "start": [24, 1], "end": [26, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.isIrrelevantNoCache", "code": "def Rapp.isIrrelevantNoCache (r : Rapp) : BaseIO Bool :=\n  (return r.state.isIrrelevant) <||>\n  (return (\u2190 r.parent.get).isIrrelevant)", "start": [28, 1], "end": [30, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.isIrrelevantNoCache", "code": "def MVarCluster.isIrrelevantNoCache (c : MVarCluster) : BaseIO Bool := do\n  (return c.state.isIrrelevant) <||> do\n    match c.parent? with\n    | none => return false\n    | some parentRef => return (\u2190 parentRef.get).isIrrelevant", "start": [32, 1], "end": [36, 62], "kind": "commanddeclaration"}, {"full_name": "Aesop.TreeRef.markSubtreeIrrelevant", "code": "def TreeRef.markSubtreeIrrelevant : TreeRef \u2192 BaseIO Unit :=\n  preTraverseDown\n    (\u03bb gref => do\n      if (\u2190 gref.get).isIrrelevant then\n        return false gref.modify \u03bb g => g.setIsIrrelevant true\n      return true)\n    (\u03bb rref => do\n      if (\u2190 rref.get).isIrrelevant then\n        return false rref.modify \u03bb r => r.setIsIrrelevant true\n      return true)\n    (\u03bb cref => do\n      if (\u2190 cref.get).isIrrelevant then\n        return false cref.modify \u03bb c => c.setIsIrrelevant true\n      return true)", "start": [38, 1], "end": [54, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalRef.markSubtreeIrrelevant", "code": "def GoalRef.markSubtreeIrrelevant (gref : GoalRef) : BaseIO Unit :=\n  (TreeRef.goal gref).markSubtreeIrrelevant", "start": [56, 1], "end": [57, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappRef.markSubtreeIrrelevant", "code": "def RappRef.markSubtreeIrrelevant (rref : RappRef) : BaseIO Unit :=\n  (TreeRef.rapp rref).markSubtreeIrrelevant", "start": [59, 1], "end": [60, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.markSubtreeIrrelevant", "code": "def MVarClusterRef.markSubtreeIrrelevant (cref : MVarClusterRef) : BaseIO Unit :=\n  (TreeRef.mvarCluster cref).markSubtreeIrrelevant", "start": [62, 1], "end": [63, 51], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isProvenByNormalizationNoCache", "code": "def Goal.isProvenByNormalizationNoCache (g : Goal) : Bool :=\n  g.normalizationState.isProvenByNormalization", "start": [70, 1], "end": [71, 47], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isProvenByRuleApplicationNoCache", "code": "def Goal.isProvenByRuleApplicationNoCache (g : Goal) : BaseIO Bool :=\n  g.children.anyM \u03bb rref => return (\u2190 rref.get).state.isProven", "start": [73, 1], "end": [74, 63], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isProvenNoCache", "code": "def Goal.isProvenNoCache (g : Goal) : BaseIO Bool :=\n  (return g.isProvenByNormalizationNoCache) <||>\n  g.isProvenByRuleApplicationNoCache", "start": [76, 1], "end": [78, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.isProvenNoCache", "code": "def Rapp.isProvenNoCache (r : Rapp) : BaseIO Bool :=\n  r.children.allM \u03bb cref => return (\u2190 cref.get).state.isProven", "start": [81, 1], "end": [82, 63], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.isProvenNoCache", "code": "def MVarCluster.isProvenNoCache (c : MVarCluster) : BaseIO Bool :=\n  c.goals.anyM \u03bb cref => return (\u2190 cref.get).state.isProven", "start": [85, 1], "end": [86, 60], "kind": "commanddeclaration"}, {"full_name": "Aesop.markProvenCore", "code": "private def markProvenCore (root : TreeRef) : BaseIO Unit := do\n  \n  preTraverseUp\n    (\u03bb gref => do\n      let g \u2190 gref.get\n      gref.set $\n        g.setState GoalState.provenByRuleApplication |>.setIsIrrelevant true\n      g.children.forM \u03bb rref => rref.markSubtreeIrrelevant\n      return true)\n    (\u03bb rref => do\n      let r \u2190 rref.get\n      if ! (\u2190 r.isProvenNoCache) then\n        return false\n      rref.set $ r.setState NodeState.proven |>.setIsIrrelevant true\n      return true)\n    (\u03bb cref => do\n      let c \u2190 cref.get\n      cref.set $ c.setState NodeState.proven |>.setIsIrrelevant true\n      c.goals.forM \u03bb gref => gref.markSubtreeIrrelevant\n      return true)\n    root", "start": [88, 1], "end": [126, 9], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalRef.markProvenByNormalization", "code": "def GoalRef.markProvenByNormalization (gref : GoalRef) : BaseIO Unit := do\n  let g \u2190 gref.get\n  gref.set $ g.setState GoalState.provenByNormalization |>.setIsIrrelevant true\n  g.children.forM \u03bb rref => rref.markSubtreeIrrelevant\n    markProvenCore (TreeRef.mvarCluster g.parent)", "start": [128, 1], "end": [133, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappRef.markProven", "code": "def RappRef.markProven (rref : RappRef) : BaseIO Unit :=\n  markProvenCore (TreeRef.rapp rref)", "start": [135, 1], "end": [136, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.isUnprovableNoCache", "code": "def Goal.isUnprovableNoCache (g : Goal) : BaseIO Bool :=\n  pure g.isForcedUnprovable <||> (\n    g.isExhausted <&&>\n    g.children.allM \u03bb rref => return (\u2190 rref.get).state.isUnprovable)", "start": [142, 1], "end": [145, 70], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.isUnprovableNoCache", "code": "def Rapp.isUnprovableNoCache (r : Rapp) : BaseIO Bool :=\n  r.children.anyM \u03bb cref => return (\u2190 cref.get).state.isUnprovable", "start": [148, 1], "end": [149, 67], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.isUnprovableNoCache", "code": "def MVarCluster.isUnprovableNoCache (c : MVarCluster) : BaseIO Bool := do\n  c.goals.allM \u03bb cref => return (\u2190 cref.get).state.isUnprovable", "start": [152, 1], "end": [153, 64], "kind": "commanddeclaration"}, {"full_name": "Aesop.markUnprovableCore", "code": "private def markUnprovableCore : TreeRef \u2192 BaseIO Unit :=\n  \n  preTraverseUp\n    (\u03bb gref => do\n      let g \u2190 gref.get\n      if ! (\u2190 g.isUnprovableNoCache) then\n        return false\n      gref.set $ g.setState GoalState.unprovable |>.setIsIrrelevant true\n      return true)\n    (\u03bb rref => do\n      let r \u2190 rref.get\n      rref.set $ r.setState NodeState.unprovable |>.setIsIrrelevant true\n      r.children.forM \u03bb cref => cref.markSubtreeIrrelevant\n      return true)\n    (\u03bb cref => do\n      let c \u2190 cref.get\n      if ! (\u2190 c.isUnprovableNoCache) then\n        return false\n      cref.set $ c.setState NodeState.unprovable |>.setIsIrrelevant true\n      return true)", "start": [155, 1], "end": [189, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalRef.markUnprovable", "code": "def GoalRef.markUnprovable (gref : GoalRef) : BaseIO Unit := do\n  let g \u2190 gref.get\n  gref.set $ g.setState GoalState.unprovable |>.setIsIrrelevant true\n  g.children.forM \u03bb rref => rref.markSubtreeIrrelevant\n  markUnprovableCore (TreeRef.mvarCluster g.parent)", "start": [191, 1], "end": [195, 52], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalRef.markForcedUnprovable", "code": "def GoalRef.markForcedUnprovable (gref : GoalRef) : BaseIO Unit := do\n  gref.modify (\u00b7.setIsForcedUnprovable true)\n  gref.markUnprovable", "start": [197, 1], "end": [199, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalRef.checkAndMarkUnprovable", "code": "def GoalRef.checkAndMarkUnprovable (gref : GoalRef) : BaseIO Unit :=\n  markUnprovableCore (TreeRef.goal gref)", "start": [201, 1], "end": [202, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.stateNoCache", "code": "def Goal.stateNoCache (g : Goal) : BaseIO GoalState := do\n  if g.isProvenByNormalizationNoCache then\n    return GoalState.provenByNormalization\n  else if \u2190 g.isProvenByRuleApplicationNoCache then\n    return GoalState.provenByRuleApplication\n  else if \u2190 g.isUnprovableNoCache then\n    return GoalState.unprovable\n  else\n    return GoalState.unknown", "start": [213, 1], "end": [221, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.stateNoCache", "code": "def Rapp.stateNoCache (r : Rapp) : BaseIO NodeState := do\n  if \u2190 r.isProvenNoCache then\n    return NodeState.proven\n  else if \u2190 r.isUnprovableNoCache then\n    return NodeState.unprovable\n  else\n    return NodeState.unknown", "start": [223, 1], "end": [229, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarCluster.stateNoCache", "code": "def MVarCluster.stateNoCache (c : MVarCluster) : BaseIO NodeState := do\n  if \u2190 c.isProvenNoCache then\n    return NodeState.proven\n  else if \u2190 c.isUnprovableNoCache then\n    return NodeState.unprovable\n  else\n    return NodeState.unknown", "start": [231, 1], "end": [237, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/Tracing.lean", "imports": ["lake-packages/aesop/Aesop/Tree/RunMetaM.lean", "lake-packages/aesop/Aesop/Tracing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.toYesNo", "code": "private def toYesNo : Bool \u2192 String\n  | true => \"yes\"\n  | false => \"no\"", "start": [9, 1], "end": [11, 18], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.withHeadlineTraceNode", "code": "def Goal.withHeadlineTraceNode (g : Goal) (traceOpt : TraceOption) (k : MetaM \u03b1)\n    (collapsed := true) (transform : MessageData \u2192 MetaM MessageData := pure) :\n    MetaM \u03b1 := do\n  withConstAesopTraceNode traceOpt fmt k collapsed\n  where\n    fmt : MetaM MessageData := do\n      g.runMetaMInParentState' do\n        g.preNormGoal.withContext do\n          addMessageContext $ \u2190 transform\n            m!\"{g.state.toEmoji} G{g.id} [{g.priority.toHumanString}] \u22ef \u22a2 {\u2190 g.preNormGoal.getType}\"", "start": [13, 1], "end": [22, 101], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.traceMetadata", "code": "def Goal.traceMetadata (g : Goal) (traceOpt : TraceOption) : MetaM Unit := do\n  if ! (\u2190 traceOpt.isEnabled) then\n    return\n  trc m!\"ID: {g.id}\"\n  trcNode m!\"Pre-normalisation goal ({g.preNormGoal.name}):\" do\n    g.runMetaMInParentState' do\n      trc m!\"{g.preNormGoal}\"\n  match g.postNormGoalAndMetaState? with\n  | none =>\n    trc m!\"Post-normalisation goal: <goal not normalised>\"\n  | some (goal, state) =>\n    state.runMetaM' do\n      trcNode m!\"Post-normalisation goal ({goal.name}):\" do\n        trc m!\"{goal}\"\n  trc m!\"Metavariables: {g.mvars.toArray.map (\u00b7.name)}\"\n  trc m!\"Parent rapp:  {\u2190 (\u2190 g.parentRapp?).mapM \u03bb rref => (\u00b7.id) <$> rref.get}\"\n  trc m!\"Child rapps:  {\u2190 g.children.mapM \u03bb rref => (\u00b7.id) <$> rref.get}\"\n  trc m!\"Origin: {g.origin.toString}\" trc m!\"Depth: {g.depth}\"\n  trc m!\"State: {g.state.toEmoji} {g.state}\"\n  trc m!\"Irrelevant: {toYesNo g.isIrrelevant}\"\n  trc m!\"Forced unprovable: {toYesNo g.isForcedUnprovable}\"\n  trc m!\"Added in iteration: {g.addedInIteration}\"\n  trc m!\"Last expanded in iteration: {if g.lastExpandedInIteration == .none then \"never\" else toString $ g.lastExpandedInIteration}\"\n  if g.unsafeRulesSelected then\n    if g.unsafeQueue.isEmpty then\n      trc m!\"Unsafe rule queue: <empty>\"\n    else\n      trcNode m!\"Unsafe rule queue:\" do\n        for r in g.unsafeQueue.toArray do\n          trc m!\"[{r.successProbability.toHumanString}] {r.name}\"\n  else\n    trc m!\"Unsafe rule queue: <not selected>\"\n  if g.failedRapps.isEmpty then\n    trc m!\"Failed rules: <none>\"\n  else\n    trcNode m!\"Failed rules:\" do\n      for r in g.failedRapps do\n        trc m!\"[{r.successProbability.toHumanString}] {r.name}\"\n  where\n    trc msg : MetaM Unit := do aesop_trace![traceOpt] msg\n\n    trcNode msg (k : MetaM Unit) : MetaM Unit :=\n      withConstAesopTraceNode traceOpt (return msg) k", "start": [24, 1], "end": [67, 54], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.withHeadlineTraceNode", "code": "def Rapp.withHeadlineTraceNode (r : Rapp) (traceOpt : TraceOption) (k : MetaM \u03b1)\n    (collapsed := true) (transform : MessageData \u2192 MetaM MessageData := pure) :\n    MetaM \u03b1 :=\n  withConstAesopTraceNode traceOpt\n    (transform m!\"{r.state.toEmoji} R{r.id} [{r.successProbability.toHumanString}] {r.appliedRule.name}\")\n    k collapsed", "start": [69, 1], "end": [74, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.traceMetadata", "code": "def Rapp.traceMetadata (r : Rapp) (traceOpt : TraceOption) : MetaM Unit := do\n  if ! (\u2190 traceOpt.isEnabled) then\n    return\n  trc m!\"ID: {r.id}\"\n  trc m!\"Rule: {r.appliedRule}\"\n  trc m!\"Success probability: {r.successProbability.toHumanString}\"\n  trc m!\"Parent goal: {(\u2190 r.parent.get).id}\"\n  trc m!\"Child goals: {\u2190 (\u2190 r.subgoals).mapM \u03bb gref => (\u00b7.id) <$> gref.get}\"\n  trc m!\"State: {r.state}\"\n  trc m!\"Irrelevant: {r.isIrrelevant}\"\n  trc m!\"Introduced metavariables: {r.introducedMVars.toArray.map (\u00b7.name)}\"\n  trc m!\"Assigned   metavariables: {r.assignedMVars.toArray.map (\u00b7.name)}\"\n  where\n    trc m : MetaM Unit := do aesop_trace![traceOpt] m", "start": [76, 1], "end": [89, 54], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.traceTreeCore", "code": "partial def Goal.traceTreeCore (g : Goal) (traceOpt : TraceOption) :\n      MetaM Unit :=\n    g.withHeadlineTraceNode traceOpt (collapsed := false) do\n      g.runMetaMInParentState' do\n        aesop_trace![traceOpt] g.preNormGoal\n      withConstAesopTraceNode traceOpt (return \"Metadata\") do\n        g.traceMetadata traceOpt\n      for rref in g.children do\n        (\u2190 rref.get).traceTreeCore traceOpt", "start": [92, 3], "end": [100, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.traceTreeCore", "code": "partial def Rapp.traceTreeCore (r : Rapp) (traceOpt : TraceOption) :\n      MetaM Unit := do\n    r.withHeadlineTraceNode traceOpt (collapsed := false) do\n      withConstAesopTraceNode traceOpt (return \"Metadata\") do\n        r.traceMetadata traceOpt\n      r.forSubgoalsM \u03bb gref => do\n        (\u2190 gref.get).traceTreeCore traceOpt", "start": [102, 3], "end": [108, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.traceTree", "code": "def Goal.traceTree (g : Goal) (traceOpt : TraceOption) : MetaM Unit := do\n  if \u2190 traceOpt.isEnabled then\n    g.traceTreeCore traceOpt", "start": [111, 1], "end": [113, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.Rapp.traceTree", "code": "def Rapp.traceTree (r : Rapp) (traceOpt : TraceOption) : MetaM Unit := do\n  if \u2190 traceOpt.isEnabled then\n    r.traceTreeCore traceOpt", "start": [115, 1], "end": [117, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Replay.lean", "imports": ["lake-packages/lean4/src/lean/Lean/CoreM.lean", "lake-packages/lean4/src/lean/Lean/Util/FoldConsts.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Environment.Replay.Context", "code": "structure Context where\n  newConstants : HashMap Name ConstantInfo", "start": [29, 1], "end": [30, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.Replay.State", "code": "structure State where\n  env : Environment\n  remaining : NameSet := {}\n  pending : NameSet := {}\n  postponedConstructors : NameSet := {}\n  postponedRecursors : NameSet := {}", "start": [32, 1], "end": [37, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.Replay.M", "code": "abbrev M := ReaderT Context <| StateRefT State IO", "start": [39, 1], "end": [39, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.Replay.isTodo", "code": "def isTodo (name : Name) : M Bool := do\n  let r := (\u2190 get).remaining\n  if r.contains name then\n    modify fun s => { s with remaining := s.remaining.erase name, pending := s.pending.insert name }\n    return true\n  else\n    return false", "start": [41, 1], "end": [48, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.Replay.throwKernelException", "code": "def throwKernelException (ex : KernelException) : M Unit := do\n    let ctx := { fileName := \"\", options := ({} : KVMap), fileMap := default }\n    let state := { env := (\u2190 get).env }\n    Prod.fst <$> (Lean.Core.CoreM.toIO \u00b7 ctx state) do Lean.throwKernelException ex", "start": [50, 1], "end": [54, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.Replay.addDecl", "code": "def addDecl (d : Declaration) : M Unit := do\n  match (\u2190 get).env.addDecl d with\n  | .ok env => modify fun s => { s with env := env }\n  | .error ex => throwKernelException ex", "start": [56, 1], "end": [60, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.Replay.replayConstant", "code": "partial def replayConstant (name : Name) : M Unit := do\n  if \u2190 isTodo name then\n    let some ci := (\u2190 read).newConstants.find? name | unreachable!\n    replayConstants ci.getUsedConstantsAsSet\n    if (\u2190 get).pending.contains name then\n      match ci with\n      | .defnInfo   info =>\n        addDecl (Declaration.defnDecl   info)\n      | .thmInfo    info =>\n        addDecl (Declaration.thmDecl    info)\n      | .axiomInfo  info =>\n        addDecl (Declaration.axiomDecl  info)\n      | .opaqueInfo info =>\n        addDecl (Declaration.opaqueDecl info)\n      | .inductInfo info =>\n        let lparams := info.levelParams\n        let nparams := info.numParams\n        let all \u2190 info.all.mapM fun n => do pure <| ((\u2190 read).newConstants.find! n)\n        for o in all do\n          modify fun s =>\n            { s with remaining := s.remaining.erase o.name, pending := s.pending.erase o.name }\n        let ctorInfo \u2190 all.mapM fun ci => do\n          pure (ci, \u2190 ci.inductiveVal!.ctors.mapM fun n => do\n            pure ((\u2190 read).newConstants.find! n))\n        for (_, ctors) in ctorInfo do\n          for ctor in ctors do\n            replayConstants ctor.getUsedConstantsAsSet\n        let types : List InductiveType := ctorInfo.map fun \u27e8ci, ctors\u27e9 =>\n          { name := ci.name\n            type := ci.type\n            ctors := ctors.map fun ci => { name := ci.name, type := ci.type } }\n        addDecl (Declaration.inductDecl lparams nparams types false)\n      | .ctorInfo info =>\n        modify fun s => { s with postponedConstructors := s.postponedConstructors.insert info.name }\n      | .recInfo info =>\n        modify fun s => { s with postponedRecursors := s.postponedRecursors.insert info.name }\n      | .quotInfo _ =>\n        addDecl (Declaration.quotDecl)\n      modify fun s => { s with pending := s.pending.erase name }", "start": [63, 1], "end": [116, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.Replay.replayConstants", "code": "partial def replayConstants (names : NameSet) : M Unit := do\n  for n in names do replayConstant n", "start": [118, 1], "end": [120, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.Replay.checkPostponedConstructors", "code": "def checkPostponedConstructors : M Unit := do\n  for ctor in (\u2190 get).postponedConstructors do\n    match (\u2190 get).env.constants.find? ctor, (\u2190 read).newConstants.find? ctor with\n    | some (.ctorInfo info), some (.ctorInfo info') =>\n      if ! (info == info') then throw <| IO.userError s!\"Invalid constructor {ctor}\"\n    | _, _ => throw <| IO.userError s!\"No such constructor {ctor}\"", "start": [124, 1], "end": [133, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.Replay.checkPostponedRecursors", "code": "def checkPostponedRecursors : M Unit := do\n  for ctor in (\u2190 get).postponedRecursors do\n    match (\u2190 get).env.constants.find? ctor, (\u2190 read).newConstants.find? ctor with\n    | some (.recInfo info), some (.recInfo info') =>\n      if ! (info == info') then throw <| IO.userError s!\"Invalid recursor {ctor}\"\n    | _, _ => throw <| IO.userError s!\"No such recursor {ctor}\"", "start": [135, 1], "end": [144, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.replay", "code": "def replay (newConstants : HashMap Name ConstantInfo) (env : Environment) : IO Environment := do\n  let mut remaining : NameSet := \u2205\n  for (n, ci) in newConstants.toList do\n    if !ci.isUnsafe && !ci.isPartial then\n      remaining := remaining.insert n\n  let (_, s) \u2190 StateRefT'.run (s := { env, remaining }) do\n    ReaderT.run (r := { newConstants }) do\n      for n in remaining do\n        replayConstant n\n      checkPostponedConstructors\n      checkPostponedRecursors\n  return s.env", "start": [150, 1], "end": [169, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder/Forward.lean", "imports": ["lake-packages/aesop/Aesop/Builder/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.ForwardBuilderOptions", "code": "structure ForwardBuilderOptions extends RegularBuilderOptions where\n  immediateHyps : Option (Array Name)\n  clear : Bool\n  \n  transparency : TransparencyMode\n  \n  indexTransparency : TransparencyMode\n  deriving Inhabited", "start": [14, 1], "end": [22, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.ForwardBuilderOptions.default", "code": "protected def ForwardBuilderOptions.default (clear : Bool) :\n    ForwardBuilderOptions where\n  toRegularBuilderOptions := .default\n  immediateHyps := none\n  clear := clear\n  transparency := .default\n  indexTransparency := .reducible", "start": [24, 1], "end": [30, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.getImmediatePremises", "code": "def getImmediatePremises (name : Name) (type : Expr) (md : TransparencyMode) :\n    Option (Array Name) \u2192 MetaM (UnorderedArraySet Nat)\n  | none =>\n    withTransparency md $ forallTelescopeReducing type \u03bb args _ => do\n      if args.isEmpty then\n        throwError \"aesop: while registering '{name}' as a forward rule: not a function\"\n      let mut result := #[]\n      for h : i in [:args.size] do\n        have h : i < args.size := h.2\n        let fvarId := args[i].fvarId!\n        let ldecl \u2190 fvarId.getDecl\n        let isNondep : MetaM Bool :=\n          args.allM (start := i + 1) \u03bb arg =>\n            return ! (\u2190 arg.fvarId!.getDecl).type.containsFVar fvarId\n        if \u2190 pure ! ldecl.binderInfo.isInstImplicit <&&> isNondep then\n          result := result.push i\n      return UnorderedArraySet.ofDeduplicatedArray result\n  | some immediate =>\n    withTransparency md $ forallTelescopeReducing type \u03bb args _ => do\n      let mut unseen := immediate.sortAndDeduplicate (ord := \u27e8Name.quickCmp\u27e9)\n      let mut result := #[]\n      for h : i in [:args.size] do\n        have h : i < args.size := by simp_all [Membership.mem]\n        let argName := (\u2190 args[i].fvarId!.getDecl).userName\n        if immediate.contains argName then\n          result := result.push i\n          unseen := unseen.erase argName\n      if ! unseen.isEmpty then throwError\n        \"aesop: while registering '{name}' as a forward rule: function does not have arguments with these names: '{unseen}'\"\n      return UnorderedArraySet.ofDeduplicatedArray result", "start": [34, 1], "end": [67, 58], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.getIndexingMode", "code": "private def getIndexingMode (type : Expr) (immediate : UnorderedArraySet Nat)\n    (md : TransparencyMode) : MetaM IndexingMode := do\n  let immediate := immediate.toArray\n  match immediate.max? with\n  | some i =>\n    withoutModifyingState do\n      let (args, _, _) \u2190 withTransparency md $ forallMetaTelescopeReducing type\n      match args.get? i with\n      | some arg =>\n        let argT := (\u2190 arg.mvarId!.getDecl).type\n        let keys \u2190 DiscrTree.mkPath argT\n        return .hyps keys\n      | none => throwError\n        \"aesop: internal error: immediate arg for forward rule is out of range\"\n  | none => return .unindexed", "start": [69, 1], "end": [83, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.forward", "code": "def forward (opts : ForwardBuilderOptions) : RuleBuilder := \u03bb input => do\n  if let .all := opts.transparency then\n    throwError \"aesop: forward builder currently does not support transparency 'all'\"\n  match input.kind with\n  | .global decl => do\n    let type := (\u2190 getConstInfo decl).type\n    let immediate \u2190\n      getImmediatePremises decl type opts.transparency opts.immediateHyps\n    let tac := .forwardConst decl immediate opts.clear opts.transparency\n    .global <$> mkResult tac type immediate\n  | .\u00ablocal\u00bb fvarUserName goal => do\n    goal.withContext do\n      let type \u2190 instantiateMVars (\u2190 getLocalDeclFromUserName fvarUserName).type\n      let immediate \u2190\n        getImmediatePremises fvarUserName type opts.transparency\n          opts.immediateHyps\n      let tac := .forwardFVar fvarUserName immediate opts.clear opts.transparency\n      .\u00ablocal\u00bb goal <$> mkResult tac type immediate\n  where\n    mkResult (tac : RuleTacDescr) (type : Expr)\n        (immediate : UnorderedArraySet Nat) : MetaM RuleBuilderResult := do\n      let indexingMode \u2190 opts.getIndexingModeM do\n        if opts.indexTransparency != .reducible then\n          return .unindexed\n        else\n          getIndexingMode type immediate opts.transparency\n      return .regular {\n        builder := .forward\n        tac, indexingMode\n      }", "start": [85, 1], "end": [114, 8], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder/Default.lean", "imports": ["lake-packages/aesop/Aesop/Builder/NormSimp.lean", "lake-packages/aesop/Aesop/Builder/Constructors.lean", "lake-packages/aesop/Aesop/Builder/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleBuilder.err", "code": "private def err (ruleType : String) : RuleBuilder := \u03bb input =>\n  throwError m!\"aesop: Unable to interpret {input.kind.toRuleIdent} as {ruleType} rule. Try specifying a builder.\"", "start": [26, 1], "end": [27, 115], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.default", "code": "def default : RuleBuilder := \u03bb input =>\n  match input.phase with\n  | PhaseName.safe =>\n    constructorsDef input <|>\n    tacticDef input <|>\n    applyDef input <|>\n    err \"a safe\" input\n  | PhaseName.unsafe =>\n    constructorsDef input <|>\n    tacticDef input <|>\n    applyDef input <|>\n    err \"an unsafe\" input\n  | PhaseName.norm =>\n    constructorsDef input <|>\n    tacticDef input <|>\n    simp input <|>\n    applyDef input <|>\n    err \"a norm\" input\n  where\n    tacticDef := tactic Inhabited.default\n    applyDef := apply Inhabited.default\n    constructorsDef := constructors Inhabited.default", "start": [29, 1], "end": [50, 54], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder/Unfold.lean", "imports": ["lake-packages/aesop/Aesop/Builder/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleBuilder.unfold", "code": "def unfold : RuleBuilder :=\n  ofGlobalRuleBuilder .unfold \u03bb _ decl =>\n    return .unfold { decl, unfoldThm? := \u2190 getUnfoldEqnFor? decl }", "start": [14, 1], "end": [16, 67], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder/Cases.lean", "imports": ["lake-packages/aesop/Aesop/RuleTac/Cases.lean", "lake-packages/aesop/Aesop/Builder/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.CasesPattern.check", "code": "def check (decl : Name) (p : CasesPattern) : MetaM Unit :=\n  withoutModifyingState do\n    let p \u2190 p.toExpr\n    unless p.isAppOf' decl do\n      throwError \"expected pattern '{p}' ({toString p}) to be an application of '{decl}'\"", "start": [17, 1], "end": [21, 90], "kind": "commanddeclaration"}, {"full_name": "Aesop.CasesPattern.toIndexingMode", "code": "def toIndexingMode (p : CasesPattern) : MetaM IndexingMode :=\n  withoutModifyingState do\n    .hyps <$> DiscrTree.mkPath (\u2190 p.toExpr)", "start": [23, 1], "end": [25, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.CasesBuilderOptions", "code": "structure CasesBuilderOptions extends RegularBuilderOptions where\n  patterns : Array CasesPattern\n  \n  transparency : TransparencyMode\n  \n  indexTransparency : TransparencyMode", "start": [30, 1], "end": [37, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.CasesBuilderOptions.indexingMode", "code": "def indexingMode (decl : Name) (opts : CasesBuilderOptions) :\n    MetaM IndexingMode :=\n  opts.getIndexingModeM do\n    if opts.indexTransparency != .reducible then\n      return .unindexed\n    if opts.patterns.isEmpty then\n      IndexingMode.hypsMatchingConst decl\n    else\n      .or <$> opts.patterns.mapM (\u00b7.toIndexingMode)", "start": [49, 1], "end": [57, 52], "kind": "commanddeclaration"}, {"full_name": "Aesop.CasesBuilderOptions.target", "code": "def target (decl : Name) (opts : CasesBuilderOptions) : CasesTarget :=\n  if opts.patterns.isEmpty then\n    .decl decl\n  else\n    .patterns opts.patterns", "start": [59, 1], "end": [63, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleBuilder.cases", "code": "def RuleBuilder.cases (opts : CasesBuilderOptions) : RuleBuilder :=\n  RuleBuilder.ofGlobalRuleBuilder BuilderName.cases \u03bb phase decl => do\n    if let .norm := phase then throwError\n      \"cases builder cannot currently be used for norm rules.\"\n      let inductInfo \u2190 RuleBuilder.checkConstIsInductive name decl\n    opts.patterns.forM (\u00b7.check decl)\n    let indexingMode \u2190 opts.indexingMode decl\n    let target := opts.target decl\n    return RuleBuilderResult.regular {\n      builder := name\n      tac := .cases target opts.transparency (isRecursiveType := inductInfo.isRec)\n      indexingMode\n    }\n  where\n    name := BuilderName.cases", "start": [68, 1], "end": [85, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/LeftRight.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.LeftRight.leftRightMeta", "code": "def leftRightMeta (name : Name) (idx max : Nat) (goal : MVarId) : MetaM (List MVarId) := do\n  goal.withContext do\n    goal.checkNotAssigned name\n    let target \u2190 goal.getType'\n    matchConstInduct target.getAppFn\n      (fun _ \u21a6 throwTacticEx `constructor goal \"target is not an inductive datatype\")\n      fun ival us \u21a6 do\n        unless ival.ctors.length == max do\n          throwTacticEx `constructor goal\n            s!\"{name} target applies for inductive types with exactly two constructors\"\n        let ctor := ival.ctors[idx]!\n        goal.apply <| mkConst ctor us", "start": [10, 1], "end": [21, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Function.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/Attr/Register.lean", "Mathlib/Init/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.comp_def", "code": "lemma comp_def {\u03b1 \u03b2 \u03b4 : Sort _} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : f \u2218 g = fun x \u21a6 f (g x) := rfl", "start": [26, 1], "end": [26, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Function.dcomp", "code": "@[inline, reducible]\ndef dcomp {\u03b2 : \u03b1 \u2192 Sort u\u2082} {\u03c6 : \u2200 {x : \u03b1}, \u03b2 x \u2192 Sort u\u2083} (f : \u2200 {x : \u03b1} (y : \u03b2 x), \u03c6 y)\n    (g : \u2200 x, \u03b2 x) : \u2200 x, \u03c6 (g x) := fun x => f (g x)", "start": [28, 1], "end": [32, 54], "kind": "commanddeclaration"}, {"full_name": "Function.compRight", "code": "@[reducible]\ndef compRight (f : \u03b2 \u2192 \u03b2 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b2) : \u03b2 \u2192 \u03b1 \u2192 \u03b2 := fun b a => f b (g a)", "start": [37, 1], "end": [38, 78], "kind": "commanddeclaration"}, {"full_name": "Function.compLeft", "code": "@[reducible]\ndef compLeft (f : \u03b2 \u2192 \u03b2 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b2 \u2192 \u03b2 := fun a b => f (g a) b", "start": [41, 1], "end": [42, 77], "kind": "commanddeclaration"}, {"full_name": "Function.onFun", "code": "@[reducible]\ndef onFun (f : \u03b2 \u2192 \u03b2 \u2192 \u03c6) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b1 \u2192 \u03c6 := fun x y => f (g x) (g y)", "start": [45, 1], "end": [49, 78], "kind": "commanddeclaration"}, {"full_name": "Function.combine", "code": "@[reducible]\ndef combine (f : \u03b1 \u2192 \u03b2 \u2192 \u03c6) (op : \u03c6 \u2192 \u03b4 \u2192 \u03b6) (g : \u03b1 \u2192 \u03b2 \u2192 \u03b4) : \u03b1 \u2192 \u03b2 \u2192 \u03b6 := fun x y =>\n  op (f x y) (g x y)", "start": [52, 1], "end": [60, 21], "kind": "commanddeclaration"}, {"full_name": "Function.swap", "code": "@[reducible]\ndef swap {\u03c6 : \u03b1 \u2192 \u03b2 \u2192 Sort u\u2083} (f : \u2200 x y, \u03c6 x y) : \u2200 y x, \u03c6 x y := fun y x => f x y", "start": [65, 1], "end": [66, 85], "kind": "commanddeclaration"}, {"full_name": "Function.app", "code": "@[reducible]\ndef app {\u03b2 : \u03b1 \u2192 Sort u\u2082} (f : \u2200 x, \u03b2 x) (x : \u03b1) : \u03b2 x :=\n  f x", "start": [69, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "Function.left_id", "code": "theorem left_id (f : \u03b1 \u2192 \u03b2) : id \u2218 f = f", "start": [80, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "Function.right_id", "code": "theorem right_id (f : \u03b1 \u2192 \u03b2) : f \u2218 id = f", "start": [84, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "Function.comp.assoc", "code": "theorem comp.assoc (f : \u03c6 \u2192 \u03b4) (g : \u03b2 \u2192 \u03c6) (h : \u03b1 \u2192 \u03b2) : (f \u2218 g) \u2218 h = f \u2218 g \u2218 h", "start": [90, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "Function.comp.left_id", "code": "@[simp, mfld_simps]\ntheorem comp.left_id (f : \u03b1 \u2192 \u03b2) : id \u2218 f = f", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "Function.comp.right_id", "code": "@[simp, mfld_simps]\ntheorem comp.right_id (f : \u03b1 \u2192 \u03b2) : f \u2218 id = f", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "Function.comp_const_right", "code": "theorem comp_const_right (f : \u03b2 \u2192 \u03c6) (b : \u03b2) : f \u2218 const \u03b1 b = const \u03b1 (f b)", "start": [104, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Injective", "code": "def Injective (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 \u2983a\u2081 a\u2082\u2984, f a\u2081 = f a\u2082 \u2192 a\u2081 = a\u2082", "start": [108, 1], "end": [110, 35], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.comp", "code": "theorem Injective.comp {g : \u03b2 \u2192 \u03c6} {f : \u03b1 \u2192 \u03b2} (hg : Injective g) (hf : Injective f) :\n    Injective (g \u2218 f)", "start": [113, 1], "end": [114, 59], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective", "code": "def Surjective (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 b, \u2203 a, f a = b", "start": [117, 1], "end": [120, 20], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.comp", "code": "theorem Surjective.comp {g : \u03b2 \u2192 \u03c6} {f : \u03b1 \u2192 \u03b2} (hg : Surjective g) (hf : Surjective f) :\n    Surjective (g \u2218 f)", "start": [123, 1], "end": [127, 74], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective", "code": "def Bijective (f : \u03b1 \u2192 \u03b2) :=\n  Injective f \u2227 Surjective f", "start": [130, 1], "end": [132, 29], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.comp", "code": "theorem Bijective.comp {g : \u03b2 \u2192 \u03c6} {f : \u03b1 \u2192 \u03b2} : Bijective g \u2192 Bijective f \u2192 Bijective (g \u2218 f)", "start": [135, 1], "end": [136, 87], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse", "code": "def LeftInverse (g : \u03b2 \u2192 \u03b1) (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 x, g (f x) = x", "start": [139, 1], "end": [141, 19], "kind": "commanddeclaration"}, {"full_name": "Function.HasLeftInverse", "code": "def HasLeftInverse (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2203 finv : \u03b2 \u2192 \u03b1, LeftInverse finv f", "start": [144, 1], "end": [146, 37], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse", "code": "def RightInverse (g : \u03b2 \u2192 \u03b1) (f : \u03b1 \u2192 \u03b2) : Prop :=\n  LeftInverse f g", "start": [149, 1], "end": [151, 18], "kind": "commanddeclaration"}, {"full_name": "Function.HasRightInverse", "code": "def HasRightInverse (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2203 finv : \u03b2 \u2192 \u03b1, RightInverse finv f", "start": [154, 1], "end": [156, 38], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.injective", "code": "theorem LeftInverse.injective {g : \u03b2 \u2192 \u03b1} {f : \u03b1 \u2192 \u03b2} : LeftInverse g f \u2192 Injective f", "start": [159, 1], "end": [164, 17], "kind": "commanddeclaration"}, {"full_name": "Function.HasLeftInverse.injective", "code": "theorem HasLeftInverse.injective {f : \u03b1 \u2192 \u03b2} : HasLeftInverse f \u2192 Injective f", "start": [167, 1], "end": [168, 47], "kind": "commanddeclaration"}, {"full_name": "Function.rightInverse_of_injective_of_leftInverse", "code": "theorem rightInverse_of_injective_of_leftInverse {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (injf : Injective f)\n    (lfg : LeftInverse f g) : RightInverse f g", "start": [171, 1], "end": [174, 9], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.surjective", "code": "theorem RightInverse.surjective {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : RightInverse g f) : Surjective f", "start": [177, 1], "end": [178, 22], "kind": "commanddeclaration"}, {"full_name": "Function.HasRightInverse.surjective", "code": "theorem HasRightInverse.surjective {f : \u03b1 \u2192 \u03b2} : HasRightInverse f \u2192 Surjective f", "start": [181, 1], "end": [182, 35], "kind": "commanddeclaration"}, {"full_name": "Function.leftInverse_of_surjective_of_rightInverse", "code": "theorem leftInverse_of_surjective_of_rightInverse {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (surjf : Surjective f)\n    (rfg : RightInverse f g) : LeftInverse f g", "start": [185, 1], "end": [191, 18], "kind": "commanddeclaration"}, {"full_name": "Function.injective_id", "code": "theorem injective_id : Injective (@id \u03b1)", "start": [194, 1], "end": [194, 63], "kind": "commanddeclaration"}, {"full_name": "Function.surjective_id", "code": "theorem surjective_id : Surjective (@id \u03b1)", "start": [197, 1], "end": [197, 64], "kind": "commanddeclaration"}, {"full_name": "Function.bijective_id", "code": "theorem bijective_id : Bijective (@id \u03b1)", "start": [200, 1], "end": [201, 32], "kind": "commanddeclaration"}, {"full_name": "Function.curry", "code": "@[inline]\ndef curry : (\u03b1 \u00d7 \u03b2 \u2192 \u03c6) \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03c6 := fun f a b => f (a, b)", "start": [210, 1], "end": [212, 61], "kind": "commanddeclaration"}, {"full_name": "Function.uncurry", "code": "@[inline]\ndef uncurry : (\u03b1 \u2192 \u03b2 \u2192 \u03c6) \u2192 \u03b1 \u00d7 \u03b2 \u2192 \u03c6 := fun f a => f a.1 a.2", "start": [215, 1], "end": [217, 62], "kind": "commanddeclaration"}, {"full_name": "Function.curry_uncurry", "code": "@[simp]\ntheorem curry_uncurry (f : \u03b1 \u2192 \u03b2 \u2192 \u03c6) : curry (uncurry f) = f", "start": [220, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "Function.uncurry_curry", "code": "@[simp]\ntheorem uncurry_curry (f : \u03b1 \u00d7 \u03b2 \u2192 \u03c6) : uncurry (curry f) = f", "start": [225, 1], "end": [227, 29], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.id", "code": "protected theorem LeftInverse.id {g : \u03b2 \u2192 \u03b1} {f : \u03b1 \u2192 \u03b2} (h : LeftInverse g f) : g \u2218 f = id", "start": [230, 1], "end": [231, 11], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.id", "code": "protected theorem RightInverse.id {g : \u03b2 \u2192 \u03b1} {f : \u03b1 \u2192 \u03b2} (h : RightInverse g f) : f \u2218 g = id", "start": [234, 1], "end": [235, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Algebra/Classes.lean", "imports": ["Mathlib/Init/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSymmOp", "code": "class IsSymmOp (\u03b1 : Type u) (\u03b2 : Type v) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b2) : Prop where\n  symm_op : \u2200 a b, op a b = op b a", "start": [70, 1], "end": [71, 35], "kind": "commanddeclaration"}, {"full_name": "IsCommutative", "code": "class IsCommutative (\u03b1 : Type u) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Prop where\n  comm : \u2200 a b, op a b = op b a", "start": [74, 1], "end": [76, 32], "kind": "commanddeclaration"}, {"full_name": "isSymmOp_of_isCommutative", "code": "instance (priority := 100) isSymmOp_of_isCommutative (\u03b1 : Type u) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n    [IsCommutative \u03b1 op] : IsSymmOp \u03b1 \u03b1 op where symm_op := IsCommutative.comm", "start": [82, 1], "end": [83, 79], "kind": "commanddeclaration"}, {"full_name": "IsAssociative", "code": "class IsAssociative (\u03b1 : Type u) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Prop where\n  assoc : \u2200 a b c, op (op a b) c = op a (op b c)", "start": [86, 1], "end": [88, 49], "kind": "commanddeclaration"}, {"full_name": "IsLeftId", "code": "class IsLeftId (\u03b1 : Type u) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (o : outParam \u03b1) : Prop where\n  left_id : \u2200 a, op o a = a", "start": [94, 1], "end": [96, 28], "kind": "commanddeclaration"}, {"full_name": "IsRightId", "code": "class IsRightId (\u03b1 : Type u) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (o : outParam \u03b1) : Prop where\n  right_id : \u2200 a, op a o = a", "start": [99, 1], "end": [101, 29], "kind": "commanddeclaration"}, {"full_name": "IsLeftCancel", "code": "class IsLeftCancel (\u03b1 : Type u) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Prop where\n  left_cancel : \u2200 a b c, op a b = op a c \u2192 b = c", "start": [116, 1], "end": [117, 49], "kind": "commanddeclaration"}, {"full_name": "IsRightCancel", "code": "class IsRightCancel (\u03b1 : Type u) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Prop where\n  right_cancel : \u2200 a b c, op a b = op c b \u2192 a = c", "start": [120, 1], "end": [121, 50], "kind": "commanddeclaration"}, {"full_name": "IsIdempotent", "code": "class IsIdempotent (\u03b1 : Type u) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Prop where\n  idempotent : \u2200 a, op a a = a", "start": [124, 1], "end": [125, 31], "kind": "commanddeclaration"}, {"full_name": "IsIrrefl", "code": "class IsIrrefl (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  irrefl : \u2200 a, \u00acr a a", "start": [173, 1], "end": [176, 23], "kind": "commanddeclaration"}, {"full_name": "IsRefl", "code": "class IsRefl (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  refl : \u2200 a, r a a", "start": [179, 1], "end": [181, 20], "kind": "commanddeclaration"}, {"full_name": "IsSymm", "code": "class IsSymm (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  symm : \u2200 a b, r a b \u2192 r b a", "start": [184, 1], "end": [186, 30], "kind": "commanddeclaration"}, {"full_name": "isSymmOp_of_isSymm", "code": "instance (priority := 100) isSymmOp_of_isSymm (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsSymm \u03b1 r] :\n    IsSymmOp \u03b1 Prop r where symm_op a b := propext <| Iff.intro (IsSymm.symm a b) (IsSymm.symm b a)", "start": [189, 1], "end": [191, 100], "kind": "commanddeclaration"}, {"full_name": "IsAsymm", "code": "class IsAsymm (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  asymm : \u2200 a b, r a b \u2192 \u00acr b a", "start": [194, 1], "end": [197, 32], "kind": "commanddeclaration"}, {"full_name": "IsAntisymm", "code": "class IsAntisymm (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  antisymm : \u2200 a b, r a b \u2192 r b a \u2192 a = b", "start": [200, 1], "end": [202, 42], "kind": "commanddeclaration"}, {"full_name": "IsTrans", "code": "class IsTrans (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  trans : \u2200 a b c, r a b \u2192 r b c \u2192 r a c", "start": [205, 1], "end": [207, 41], "kind": "commanddeclaration"}, {"full_name": "IsTotal", "code": "class IsTotal (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  total : \u2200 a b, r a b \u2228 r b a", "start": [216, 1], "end": [219, 31], "kind": "commanddeclaration"}, {"full_name": "IsPreorder", "code": "class IsPreorder (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) extends IsRefl \u03b1 r, IsTrans \u03b1 r : Prop", "start": [222, 1], "end": [224, 88], "kind": "commanddeclaration"}, {"full_name": "IsTotalPreorder", "code": "class IsTotalPreorder (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) extends IsTrans \u03b1 r, IsTotal \u03b1 r : Prop", "start": [227, 1], "end": [228, 94], "kind": "commanddeclaration"}, {"full_name": "isTotalPreorder_isPreorder", "code": "instance isTotalPreorder_isPreorder (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [s : IsTotalPreorder \u03b1 r] :\n    IsPreorder \u03b1 r where\n  trans := s.trans\n  refl a := Or.elim (@IsTotal.total _ r _ a a) id id", "start": [231, 1], "end": [235, 53], "kind": "commanddeclaration"}, {"full_name": "IsPartialOrder", "code": "class IsPartialOrder (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) extends IsPreorder \u03b1 r, IsAntisymm \u03b1 r : Prop", "start": [238, 1], "end": [240, 99], "kind": "commanddeclaration"}, {"full_name": "IsLinearOrder", "code": "class IsLinearOrder (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) extends IsPartialOrder \u03b1 r, IsTotal \u03b1 r : Prop", "start": [243, 1], "end": [245, 99], "kind": "commanddeclaration"}, {"full_name": "IsEquiv", "code": "class IsEquiv (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) extends IsPreorder \u03b1 r, IsSymm \u03b1 r : Prop", "start": [248, 1], "end": [250, 88], "kind": "commanddeclaration"}, {"full_name": "IsStrictOrder", "code": "class IsStrictOrder (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) extends IsIrrefl \u03b1 r, IsTrans \u03b1 r : Prop", "start": [258, 1], "end": [260, 93], "kind": "commanddeclaration"}, {"full_name": "IsIncompTrans", "code": "class IsIncompTrans (\u03b1 : Type u) (lt : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  incomp_trans : \u2200 a b c, \u00aclt a b \u2227 \u00aclt b a \u2192 \u00aclt b c \u2227 \u00aclt c b \u2192 \u00aclt a c \u2227 \u00aclt c a", "start": [263, 1], "end": [266, 84], "kind": "commanddeclaration"}, {"full_name": "IsStrictWeakOrder", "code": "class IsStrictWeakOrder (\u03b1 : Type u) (lt : \u03b1 \u2192 \u03b1 \u2192 Prop) extends IsStrictOrder \u03b1 lt,\n    IsIncompTrans \u03b1 lt : Prop", "start": [269, 1], "end": [272, 30], "kind": "commanddeclaration"}, {"full_name": "IsTrichotomous", "code": "class IsTrichotomous (\u03b1 : Type u) (lt : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  trichotomous : \u2200 a b, lt a b \u2228 a = b \u2228 lt b a", "start": [275, 1], "end": [278, 48], "kind": "commanddeclaration"}, {"full_name": "IsStrictTotalOrder", "code": "class IsStrictTotalOrder (\u03b1 : Type u) (lt : \u03b1 \u2192 \u03b1 \u2192 Prop) extends IsTrichotomous \u03b1 lt,\n    IsStrictOrder \u03b1 lt : Prop", "start": [281, 1], "end": [284, 30], "kind": "commanddeclaration"}, {"full_name": "eq_isEquiv", "code": "instance eq_isEquiv (\u03b1 : Type u) : IsEquiv \u03b1 (\u00b7 = \u00b7) where\n  symm := @Eq.symm _\n  trans := @Eq.trans _\n  refl := Eq.refl", "start": [287, 1], "end": [291, 18], "kind": "commanddeclaration"}, {"full_name": "irrefl", "code": "theorem irrefl [IsIrrefl \u03b1 r] (a : \u03b1) : \u00aca \u227a a", "start": [300, 1], "end": [301, 20], "kind": "commanddeclaration"}, {"full_name": "refl", "code": "theorem refl [IsRefl \u03b1 r] (a : \u03b1) : a \u227a a", "start": [304, 1], "end": [305, 16], "kind": "commanddeclaration"}, {"full_name": "trans", "code": "theorem trans [IsTrans \u03b1 r] {a b c : \u03b1} : a \u227a b \u2192 b \u227a c \u2192 a \u227a c", "start": [308, 1], "end": [309, 22], "kind": "commanddeclaration"}, {"full_name": "symm", "code": "theorem symm [IsSymm \u03b1 r] {a b : \u03b1} : a \u227a b \u2192 b \u227a a", "start": [312, 1], "end": [313, 18], "kind": "commanddeclaration"}, {"full_name": "antisymm", "code": "theorem antisymm [IsAntisymm \u03b1 r] {a b : \u03b1} : a \u227a b \u2192 b \u227a a \u2192 a = b", "start": [316, 1], "end": [317, 26], "kind": "commanddeclaration"}, {"full_name": "asymm", "code": "theorem asymm [IsAsymm \u03b1 r] {a b : \u03b1} : a \u227a b \u2192 \u00acb \u227a a", "start": [320, 1], "end": [321, 20], "kind": "commanddeclaration"}, {"full_name": "trichotomous", "code": "theorem trichotomous [IsTrichotomous \u03b1 r] : \u2200 a b : \u03b1, a \u227a b \u2228 a = b \u2228 b \u227a a", "start": [324, 1], "end": [325, 30], "kind": "commanddeclaration"}, {"full_name": "incomp_trans", "code": "theorem incomp_trans [IsIncompTrans \u03b1 r] {a b c : \u03b1} :\n    \u00aca \u227a b \u2227 \u00acb \u227a a \u2192 \u00acb \u227a c \u2227 \u00acc \u227a b \u2192 \u00aca \u227a c \u2227 \u00acc \u227a a", "start": [328, 1], "end": [330, 35], "kind": "commanddeclaration"}, {"full_name": "isAsymm_of_isTrans_of_isIrrefl", "code": "instance (priority := 90) isAsymm_of_isTrans_of_isIrrefl [IsTrans \u03b1 r] [IsIrrefl \u03b1 r] :\n    IsAsymm \u03b1 r :=\n  \u27e8fun a _b h\u2081 h\u2082 => absurd (_root_.trans h\u2081 h\u2082) (irrefl a)\u27e9", "start": [333, 1], "end": [335, 61], "kind": "commanddeclaration"}, {"full_name": "irrefl_of", "code": "@[elab_without_expected_type]\ntheorem irrefl_of [IsIrrefl \u03b1 r] (a : \u03b1) : \u00aca \u227a a", "start": [342, 1], "end": [344, 11], "kind": "commanddeclaration"}, {"full_name": "refl_of", "code": "@[elab_without_expected_type]\ntheorem refl_of [IsRefl \u03b1 r] (a : \u03b1) : a \u227a a", "start": [347, 1], "end": [349, 9], "kind": "commanddeclaration"}, {"full_name": "trans_of", "code": "@[elab_without_expected_type]\ntheorem trans_of [IsTrans \u03b1 r] {a b c : \u03b1} : a \u227a b \u2192 b \u227a c \u2192 a \u227a c", "start": [352, 1], "end": [354, 15], "kind": "commanddeclaration"}, {"full_name": "symm_of", "code": "@[elab_without_expected_type]\ntheorem symm_of [IsSymm \u03b1 r] {a b : \u03b1} : a \u227a b \u2192 b \u227a a", "start": [357, 1], "end": [359, 7], "kind": "commanddeclaration"}, {"full_name": "asymm_of", "code": "@[elab_without_expected_type]\ntheorem asymm_of [IsAsymm \u03b1 r] {a b : \u03b1} : a \u227a b \u2192 \u00acb \u227a a", "start": [362, 1], "end": [364, 8], "kind": "commanddeclaration"}, {"full_name": "total_of", "code": "@[elab_without_expected_type]\ntheorem total_of [IsTotal \u03b1 r] (a b : \u03b1) : a \u227a b \u2228 b \u227a a", "start": [367, 1], "end": [369, 20], "kind": "commanddeclaration"}, {"full_name": "trichotomous_of", "code": "@[elab_without_expected_type]\ntheorem trichotomous_of [IsTrichotomous \u03b1 r] : \u2200 a b : \u03b1, a \u227a b \u2228 a = b \u2228 b \u227a a", "start": [372, 1], "end": [374, 15], "kind": "commanddeclaration"}, {"full_name": "incomp_trans_of", "code": "@[elab_without_expected_type]\ntheorem incomp_trans_of [IsIncompTrans \u03b1 r] {a b c : \u03b1} :\n    \u00aca \u227a b \u2227 \u00acb \u227a a \u2192 \u00acb \u227a c \u2227 \u00acc \u227a b \u2192 \u00aca \u227a c \u2227 \u00acc \u227a a", "start": [377, 1], "end": [380, 15], "kind": "commanddeclaration"}, {"full_name": "StrictWeakOrder.Equiv", "code": "def Equiv (a b : \u03b1) : Prop :=\n  \u00aca \u227a b \u2227 \u00acb \u227a a", "start": [395, 1], "end": [396, 18], "kind": "commanddeclaration"}, {"full_name": "StrictWeakOrder.erefl", "code": "theorem erefl (a : \u03b1) : a \u2248 a", "start": [403, 1], "end": [404, 23], "kind": "commanddeclaration"}, {"full_name": "StrictWeakOrder.esymm", "code": "theorem esymm {a b : \u03b1} : a \u2248 b \u2192 b \u2248 a", "start": [407, 1], "end": [407, 68], "kind": "commanddeclaration"}, {"full_name": "StrictWeakOrder.etrans", "code": "theorem etrans {a b c : \u03b1} : a \u2248 b \u2192 b \u2248 c \u2192 a \u2248 c", "start": [410, 1], "end": [411, 15], "kind": "commanddeclaration"}, {"full_name": "StrictWeakOrder.not_lt_of_equiv", "code": "theorem not_lt_of_equiv {a b : \u03b1} : a \u2248 b \u2192 \u00aca \u227a b", "start": [414, 1], "end": [414, 67], "kind": "commanddeclaration"}, {"full_name": "StrictWeakOrder.not_lt_of_equiv'", "code": "theorem not_lt_of_equiv' {a b : \u03b1} : a \u2248 b \u2192 \u00acb \u227a a", "start": [417, 1], "end": [417, 68], "kind": "commanddeclaration"}, {"full_name": "StrictWeakOrder.isEquiv", "code": "instance isEquiv : IsEquiv \u03b1 (@Equiv _ r) where\n  refl := erefl\n  trans _ _ _ := etrans\n  symm _ _:= esymm", "start": [420, 1], "end": [423, 19], "kind": "commanddeclaration"}, {"full_name": "isStrictWeakOrder_of_isTotalPreorder", "code": "theorem isStrictWeakOrder_of_isTotalPreorder {\u03b1 : Type u} {le : \u03b1 \u2192 \u03b1 \u2192 Prop} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    [DecidableRel le] [IsTotalPreorder \u03b1 le] (h : \u2200 a b, lt a b \u2194 \u00acle b a) :\n    IsStrictWeakOrder \u03b1 lt", "start": [433, 1], "end": [452, 98], "kind": "commanddeclaration"}, {"full_name": "lt_of_lt_of_incomp", "code": "theorem lt_of_lt_of_incomp {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictWeakOrder \u03b1 lt]\n    [DecidableRel lt] : \u2200 {a b c}, lt a b \u2192 \u00aclt b c \u2227 \u00aclt c b \u2192 lt a c", "start": [455, 1], "end": [461, 22], "kind": "commanddeclaration"}, {"full_name": "lt_of_incomp_of_lt", "code": "theorem lt_of_incomp_of_lt {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictWeakOrder \u03b1 lt]\n    [DecidableRel lt] : \u2200 {a b c}, \u00aclt a b \u2227 \u00aclt b a \u2192 lt b c \u2192 lt a c", "start": [464, 1], "end": [470, 22], "kind": "commanddeclaration"}, {"full_name": "eq_of_incomp", "code": "theorem eq_of_incomp {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsTrichotomous \u03b1 lt] {a b} :\n    \u00aclt a b \u2227 \u00aclt b a \u2192 a = b", "start": [473, 1], "end": [478, 42], "kind": "commanddeclaration"}, {"full_name": "eq_of_eqv_lt", "code": "theorem eq_of_eqv_lt {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsTrichotomous \u03b1 lt] {a b} :\n    a \u2248[lt]b \u2192 a = b", "start": [481, 1], "end": [483, 15], "kind": "commanddeclaration"}, {"full_name": "incomp_iff_eq", "code": "theorem incomp_iff_eq {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsTrichotomous \u03b1 lt] [IsIrrefl \u03b1 lt] (a b) :\n    \u00aclt a b \u2227 \u00aclt b a \u2194 a = b", "start": [486, 1], "end": [488, 86], "kind": "commanddeclaration"}, {"full_name": "eqv_lt_iff_eq", "code": "theorem eqv_lt_iff_eq {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsTrichotomous \u03b1 lt] [IsIrrefl \u03b1 lt] (a b) :\n    a \u2248[lt]b \u2194 a = b", "start": [491, 1], "end": [493, 20], "kind": "commanddeclaration"}, {"full_name": "not_lt_of_lt", "code": "theorem not_lt_of_lt {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsStrictOrder \u03b1 lt] {a b} :\n    lt a b \u2192 \u00aclt b a", "start": [496, 1], "end": [497, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ToAdditive.lean", "imports": ["Mathlib/Lean/EnvExtension.lean", "Mathlib/Data/String/Defs.lean", "lake-packages/std/Std/Tactic/Ext/Attr.lean", "Mathlib/Tactic/Relation/Trans.lean", "lake-packages/std/Std/Tactic/CoeExt.lean", "Mathlib/Lean/Meta/Simp.lean", "lake-packages/std/Std/Tactic/Lint.lean", "Mathlib/Data/Array/Defs.lean", "Mathlib/Init/Data/Nat/Notation.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/KVMap.lean", "Mathlib/Lean/Expr/ReplaceRec.lean", "Mathlib/Tactic/Simps/Basic.lean", "lake-packages/std/Std/Tactic/Relation/Symm.lean", "lake-packages/std/Std/Tactic/Relation/Rfl.lean", "lake-packages/std/Std/Lean/NameMapAttribute.lean", "lake-packages/std/Std/Data/Option/Basic.lean", "Mathlib/Tactic/Eqns.lean"], "premises": [{"full_name": "endCapitalNames", "code": "def endCapitalNames : Lean.RBMap String (List String) compare :=\n  .ofList [(\"LE\", [\"\"]), (\"LT\", [\"\"]), (\"WF\", [\"\"]), (\"Coe\", [\"TC\", \"T\", \"HTCT\"])]", "start": [60, 1], "end": [72, 83], "kind": "commanddeclaration"}, {"full_name": "String.splitCase", "code": "partial def String.splitCase (s : String) (i\u2080 : Pos := 0) (r : List String := []) : List String :=\nId.run do\n  let i\u2081 := s.next i\u2080\n  if s.atEnd i\u2081 then\n    let r := s::r\n    return r.reverse\n  \n  if s.get i\u2080 == '_' || s.get i\u2081 == '_' then\n    return splitCase (s.extract i\u2081 s.endPos) 0 <| (s.extract 0 i\u2081)::r\n  if (s.get i\u2081).isUpper then\n    if let some strs := endCapitalNames.find? (s.extract 0 i\u2081) then\n      if let some (pref, newS) := strs.findSome?\n        fun x : String \u21a6 (s.extract i\u2081 s.endPos).dropPrefix? x |>.map (x, \u00b7.toString) then\n        return splitCase newS 0 <| (s.extract 0 i\u2081 ++ pref)::r\n    if !(s.get i\u2080).isUpper then\n      return splitCase (s.extract i\u2081 s.endPos) 0 <| (s.extract 0 i\u2081)::r\n  return splitCase s i\u2081 r", "start": [74, 1], "end": [103, 26], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.findTranslation?", "code": "def findTranslation? (env : Environment) : Name \u2192 Option Name :=\n  (ToAdditive.translations.getState env).find?", "start": [232, 1], "end": [234, 47], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.insertTranslation", "code": "def insertTranslation (src tgt : Name) (failIfExists := true) : CoreM Unit := do\n  if let some tgt' := findTranslation? (\u2190 getEnv) src then\n    if failIfExists then\n      throwError \"The translation {src} \u21a6 {tgt'} already exists\"\n    else\n      trace[to_additive] \"The translation {src} \u21a6 {tgt'} already exists\"\n      return\n  modifyEnv (ToAdditive.translations.addEntry \u00b7 (src, tgt))\n  trace[to_additive] \"Added translation {src} \u21a6 {tgt}\"", "start": [236, 1], "end": [245, 55], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.Config", "code": "structure Config : Type where\n  \n  trace : Bool := false\n  \n  tgt : Name := Name.anonymous\n  \n  doc : Option String := none\n  \n  allowAutoName : Bool := false\n  \n  reorder : List (List Nat) := []\n  \n  attrs : Array Syntax := #[]\n  \n  ref : Syntax\n  \n  existing : Option Bool := none\n  deriving Repr", "start": [247, 1], "end": [274, 16], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.additiveTestUnsafe", "code": "unsafe def additiveTestUnsafe (findTranslation? : Name \u2192 Option Name)\n  (ignore : Name \u2192 Option (List \u2115)) (e : Expr) : Bool :=\n  let rec visit (e : Expr) (inApp := false) : OptionT FindM Unit := do\n    if e.isConst then\n      if inApp || (findTranslation? e.constName).isSome then\n        failure\n      else\n        return\n    checkVisited e\n    match e with\n    | x@(.app e a)       =>\n        visit e true <|> do\n          guard !x.isConstantApplication\n          if let some n := e.getAppFn.constName? then\n            if let some l := ignore n then\n              if e.getAppNumArgs + 1 \u2208 l then\n                failure\n          visit a\n    | .lam _ _ t _       => visit t\n    | .forallE _ _ t _   => visit t\n    | .letE _ _ e body _ => visit e <|> visit body\n    | .mdata _ b         => visit b\n    | .proj _ _ b        => visit b\n    | _                  => failure\n  Option.isNone <| Id.run <| (visit e).run' mkPtrSet", "start": [279, 1], "end": [313, 53], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.additiveTest", "code": "def additiveTest (findTranslation? : Name \u2192 Option Name)\n    (ignore : Name \u2192 Option (List \u2115)) (e : Expr) : Bool :=\n  unsafe additiveTestUnsafe findTranslation? ignore e", "start": [315, 1], "end": [326, 54], "kind": "commanddeclaration"}, {"full_name": "List.swapFirstTwo", "code": "def _root_.List.swapFirstTwo {\u03b1 : Type _} : List \u03b1 \u2192 List \u03b1\n  | []      => []\n  | [x]     => [x]\n  | x::y::l => y::x::l", "start": [328, 1], "end": [332, 23], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.changeNumeral", "code": "def changeNumeral : Expr \u2192 Expr\n  | .lit (.natVal 1) => mkRawNatLit 0\n  | e                => e", "start": [334, 1], "end": [338, 26], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.applyReplacementFun", "code": "def applyReplacementFun (e : Expr) : MetaM Expr := do\n  let env \u2190 getEnv\n  let reorderFn : Name \u2192 List (List \u2115) := fun nm \u21a6 (reorderAttr.find? env nm |>.getD [])\n  let relevantArg : Name \u2192 \u2115 := fun nm \u21a6 (relevantArgAttr.find? env nm).getD 0\n  return aux\n      (findTranslation? <| \u2190 getEnv) reorderFn (ignoreArgsAttr.find? env)\n      (changeNumeralAttr.find? env) relevantArg (\u2190 getBoolOption `trace.to_additive_detail) e\nwhere \n  aux (findTranslation? : Name \u2192 Option Name)\n    (reorderFn : Name \u2192 List (List \u2115)) (ignore : Name \u2192 Option (List \u2115))\n    (changeNumeral? : Name \u2192 Option (List Nat)) (relevantArg : Name \u2192 \u2115) (trace : Bool) :\n    Expr \u2192 Expr :=\n  Lean.Expr.replaceRec fun r e \u21a6 Id.run do\n    if trace then\n      dbg_trace s!\"replacing at {e}\"\n    match e with\n    | .const n\u2080 ls\u2080 => do\n      let n\u2081 := n\u2080.mapPrefix findTranslation?\n      let ls\u2081 : List Level := if 0 \u2208 (reorderFn n\u2080).join then ls\u2080.swapFirstTwo else ls\u2080\n      if trace then\n        if n\u2080 != n\u2081 then\n          dbg_trace s!\"changing {n\u2080} to {n\u2081}\"\n        if 0 \u2208 (reorderFn n\u2080).join then\n          dbg_trace s!\"reordering the universe variables from {ls\u2080} to {ls\u2081}\"\n      return some <| Lean.mkConst n\u2081 ls\u2081\n    | .app g x => do\n      let gf := g.getAppFn\n      if gf.isBVar && x.isLit then\n        if trace then\n          dbg_trace s!\"applyReplacementFun: Variables applied to numerals are not changed {g.app x}\"\n        return some <| g.app x\n      let gArgs := g.getAppArgs\n      let mut gAllArgs := gArgs.push x\n      let (gfAdditive, gAllArgsAdditive) \u2190\n        if let some nm := gf.constName? then\n          let relevantArgId := relevantArg nm\n          let gfAdditive :=\n            if relevantArgId < gAllArgs.size && gf.isConst &&\n              not (additiveTest findTranslation? ignore gAllArgs[relevantArgId]!) then Id.run <| do\n              if trace then\n                dbg_trace\n                  s!\"{gAllArgs[relevantArgId]!} contains a fixed type, so {nm} is not changed\"\n              gf\n            else\n              r gf\n          \n          let reorder := reorderFn nm\n          if !reorder.isEmpty && relevantArgId < gAllArgs.size &&\n            additiveTest findTranslation? ignore gAllArgs[relevantArgId]! then\n            gAllArgs := gAllArgs.permute! reorder\n            if trace then\n              dbg_trace s!\"reordering the arguments of {nm} using the cyclic permutations {reorder}\"\n          \n          let firstArg := gAllArgs[0]!\n          if let some changedArgNrs := changeNumeral? nm then\n            if additiveTest findTranslation? ignore firstArg then\n              if trace then\n                dbg_trace s!\"applyReplacementFun: We change the numerals in this expression. {\n                  \"\"}However, we will still recurse into all the non-numeral arguments.\"\n              gAllArgs := gAllArgs.mapIdx fun argNr arg \u21a6\n                if changedArgNrs.contains argNr then\n                  changeNumeral arg\n                else\n                  arg\n          pure <| (gfAdditive, \u2190 gAllArgs.mapM r)\n        else\n          pure (\u2190 r gf, \u2190 gAllArgs.mapM r)\n      return some <| mkAppN gfAdditive gAllArgsAdditive\n    | .proj n\u2080 idx e => do\n      let n\u2081 := n\u2080.mapPrefix findTranslation?\n      if trace then\n        dbg_trace s!\"applyReplacementFun: in projection {e}.{idx} of type {n\u2080}, {\"\"\n          }replace type with {n\u2081}\"\n      return some <| .proj n\u2081 idx <| \u2190 r e\n    | _ => return none", "start": [340, 1], "end": [430, 23], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.etaExpandN", "code": "def etaExpandN (n : Nat) (e : Expr) : MetaM Expr := do\n  forallBoundedTelescope (\u2190 inferType e) (some n) fun xs _ \u21a6 mkLambdaFVars xs (mkAppN e xs)", "start": [432, 1], "end": [434, 92], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.expand", "code": "def expand (e : Expr) : MetaM Expr := do\n  let env \u2190 getEnv\n  let reorderFn : Name \u2192 List (List \u2115) := fun nm \u21a6 (reorderAttr.find? env nm |>.getD [])\n  let e\u2082 \u2190 Lean.Meta.transform (input := e) (post := fun e => return .done e) <| fun e \u21a6 do\n    let e0 := e.getAppFn\n    let es := e.getAppArgs\n    let some e0n := e0.constName? | return .continue\n    let reorder := reorderFn e0n\n    if reorder.isEmpty then\n      return .continue\n    let needed_n := reorder.join.foldr Nat.max 0 + 1\n    if needed_n \u2264 es.size || es.size == 0 then\n      return .continue\n    else\n      let e' \u2190 etaExpandN (needed_n - es.size) e\n      trace[to_additive_detail] \"expanded {e} to {e'}\"\n      return .continue e'\n  if e != e\u2082 then\n    trace[to_additive_detail] \"expand:\\nBefore: {e}\\nAfter:  {e\u2082}\"\n  return e\u2082", "start": [436, 1], "end": [463, 12], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.reorderForall", "code": "def reorderForall (src : Expr) (reorder : List (List Nat) := []) : MetaM Expr := do\n  if reorder == [] then\n    return src\n  forallTelescope src fun xs e => do\n    mkForallFVars (xs.permute! reorder) e", "start": [465, 1], "end": [470, 42], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.reorderLambda", "code": "def reorderLambda (src : Expr) (reorder : List (List Nat) := []) : MetaM Expr := do\n  if reorder == [] then\n    return src\n  lambdaTelescope src fun xs e => do\n    mkLambdaFVars (xs.permute! reorder) e", "start": [472, 1], "end": [477, 42], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.updateDecl", "code": "def updateDecl (tgt : Name) (srcDecl : ConstantInfo) (reorder : List (List Nat) := []) :\n    MetaM ConstantInfo := do\n  let mut decl := srcDecl.updateName tgt\n  if 0 \u2208 reorder.join then\n    decl := decl.updateLevelParams decl.levelParams.swapFirstTwo\n  decl := decl.updateType <| \u2190 applyReplacementFun <| \u2190 reorderForall (\u2190 expand decl.type) reorder\n  if let some v := decl.value? then\n    decl := decl.updateValue <| \u2190 applyReplacementFun <| \u2190 reorderLambda (\u2190 expand v) reorder\n  else if let .opaqueInfo info := decl then decl := .opaqueInfo { info with\n      value := \u2190 applyReplacementFun <| \u2190 reorderLambda (\u2190 expand info.value) reorder }\n  return decl", "start": [479, 1], "end": [491, 14], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.findTargetName", "code": "def findTargetName (env : Environment) (src pre tgt_pre : Name) : CoreM Name :=\n  \n  if let some post := pre.isPrefixOf? src then\n    return tgt_pre ++ post\n  \n  else if let some post := privateToUserName? src then\n    match findTranslation? env post.getPrefix with\n    | none => return src\n    | some addName => return src.updatePrefix <| mkPrivateName env addName\n  else if let some post := env.mainModule ++ `_auxLemma |>.isPrefixOf? src then\n    return env.mainModule ++ `_auxAddLemma ++ post\n  else if src.hasMacroScopes then\n    mkFreshUserName src.eraseMacroScopes\n  else\n    throwError \"internal @[to_additive] error.\"", "start": [493, 1], "end": [513, 48], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.findAuxDecls", "code": "def findAuxDecls (e : Expr) (pre mainModule : Name) : NameSet :=\n  let auxLemma := mainModule ++ `_auxLemma\n  e.foldConsts \u2205 fun n l \u21a6\n    if n.getPrefix == pre || n.getPrefix == auxLemma || isPrivateName n || n.hasMacroScopes then\n      l.insert n\n    else\n      l", "start": [515, 1], "end": [529, 8], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.transformDeclAux", "code": "partial def transformDeclAux\n    (cfg : Config) (pre tgt_pre : Name) : Name \u2192 CoreM Unit := fun src \u21a6 do\n  let env \u2190 getEnv\n  trace[to_additive_detail] \"visiting {src}\"\n  if (findTranslation? env src).isSome && src != pre then\n      return\n  if src != pre && !src.isInternal' then\n    throwError \"The declaration {pre} depends on the declaration {src} which is in the namespace {\n      pre}, but does not have the `@[to_additive]` attribute. This is not supported.\\n{\"\"\n      }Workaround: move {src} to a different namespace.\"\n  let tgt \u2190 findTargetName env src pre tgt_pre\n  if env.contains tgt then\n    if tgt == src then\n      trace[to_additive_detail] \"Auxiliary declaration {src} will be translated to itself.\"\n    else\n      trace[to_additive_detail] \"Already visited {tgt} as translation of {src}.\"\n    return\n  let srcDecl \u2190 getConstInfo src\n  for n in findAuxDecls srcDecl.type pre env.mainModule do\n    transformDeclAux cfg pre tgt_pre n\n  if let some value := srcDecl.value? then\n    for n in findAuxDecls value pre env.mainModule do\n      transformDeclAux cfg pre tgt_pre n\n  if let .opaqueInfo {value, ..} := srcDecl then\n    for n in findAuxDecls value pre env.mainModule do\n      transformDeclAux cfg pre tgt_pre n\n  if !pre.isPrefixOf src then\n    insertTranslation src tgt\n  let trgDecl : ConstantInfo \u2190\n    MetaM.run' <| updateDecl tgt srcDecl <| if src == pre then cfg.reorder else []\n  let value \u2190 match trgDecl with\n    | .thmInfo { value, .. } | .defnInfo { value, .. } | .opaqueInfo { value, .. } => pure value\n    | _ => throwError \"Expected {tgt} to have a value.\"\n  trace[to_additive] \"generating\\n{tgt} : {trgDecl.type} :=\\n  {value}\"\n  try\n    discard <| MetaM.run' <| inferType value\n  catch\n    | Exception.error _ msg => throwError \"@[to_additive] failed.\n      Type mismatch in additive declaration. For help, see the docstring\n      of `to_additive.attr`, section `Troubleshooting`.\n      Failed to add declaration\\n{tgt}:\\n{msg}\"\n    | _ => panic! \"unreachable\"\n  if isNoncomputable env src then\n    addDecl trgDecl.toDeclaration!\n    setEnv $ addNoncomputable (\u2190 getEnv) tgt\n  else\n    addAndCompile trgDecl.toDeclaration!\n  addDeclarationRanges tgt {\n    range := \u2190 getDeclarationRange (\u2190 getRef)\n    selectionRange := \u2190 getDeclarationRange cfg.ref }\n  if isProtected (\u2190 getEnv) src then\n    setEnv $ addProtected (\u2190 getEnv) tgt", "start": [531, 1], "end": [602, 41], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.copyInstanceAttribute", "code": "def copyInstanceAttribute (src tgt : Name) : CoreM Unit := do\n  if (\u2190 isInstance src) then\n    let prio := (\u2190 getInstancePriority? src).getD 100\n    let attr_kind := (\u2190 getInstanceAttrKind? src).getD .global\n    trace[to_additive_detail] \"Making {tgt} an instance with priority {prio}.\"\n    addInstance tgt attr_kind prio |>.run'", "start": [604, 1], "end": [612, 43], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.warnExt", "code": "def warnExt [Inhabited \u03c3] (stx : Syntax) (ext : PersistentEnvExtension \u03b1 \u03b2 \u03c3) (f : \u03c3 \u2192 Name \u2192 Bool)\n    (thisAttr attrName src tgt : Name) : CoreM Unit := do\n  if f (ext.getState (\u2190 getEnv)) src then\n    Linter.logLintIf linter.existingAttributeWarning stx <|\n      m!\"The source declaration {src} was given attribute {attrName} before calling @[{thisAttr}]. {\n      \"\"}The preferred method is to use `@[{thisAttr} (attr := {attrName})]` to apply the {\n      \"\"}attribute to both {src} and the target declaration {tgt}.\" ++\n      if thisAttr == `to_additive then\n      m!\"\\nSpecial case: If this declaration was generated by @[to_additive] {\n      \"\"}itself, you can use @[to_additive (attr := to_additive, {attrName})] on the original {\n      \"\"}declaration.\" else \"\"", "start": [614, 1], "end": [625, 31], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.warnAttr", "code": "def warnAttr [Inhabited \u03b2] (stx : Syntax) (attr : SimpleScopedEnvExtension \u03b1 \u03b2)\n    (f : \u03b2 \u2192 Name \u2192 Bool) (thisAttr attrName src tgt : Name) : CoreM Unit :=\nwarnExt stx attr.ext (f \u00b7.stateStack.head!.state \u00b7) thisAttr attrName src tgt", "start": [627, 1], "end": [630, 78], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.warnParametricAttr", "code": "def warnParametricAttr (stx : Syntax) (attr : ParametricAttribute \u03b2)\n    (thisAttr attrName src tgt : Name) : CoreM Unit :=\nwarnExt stx attr.ext (\u00b7.contains \u00b7) thisAttr attrName src tgt", "start": [632, 1], "end": [635, 62], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.additivizeLemmas", "code": "def additivizeLemmas [Monad m] [MonadError m] [MonadLiftT CoreM m]\n    (names : Array Name) (desc : String) (t : Name \u2192 m (Array Name)) : m Unit := do\n  let auxLemmas \u2190 names.mapM t\n  let nLemmas := auxLemmas[0]!.size\n  for (nm, lemmas) in names.zip auxLemmas do\n    unless lemmas.size == nLemmas do\n      throwError \"{names[0]!} and {nm} do not generate the same number of {desc}.\"\n  for (srcLemmas, tgtLemmas) in auxLemmas.zip <| auxLemmas.eraseIdx 0 do\n    for (srcLemma, tgtLemma) in srcLemmas.zip tgtLemmas do\n      insertTranslation srcLemma tgtLemma", "start": [637, 1], "end": [649, 42], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.firstMultiplicativeArg", "code": "def firstMultiplicativeArg (nm : Name) : MetaM Nat := do\n  forallTelescopeReducing (\u2190 getConstInfo nm).type fun xs _ \u21a6 do\n    let xs := xs.toList\n    let l \u2190 xs.filterMapM fun x \u21a6 do\n      forallTelescopeReducing (\u2190 inferType x) fun _ys tgt \u21a6 do\n        let (_tgt_fn, tgt_args) := tgt.getAppFnArgs\n        if let some c := tgt.getAppFn.constName? then\n          if findTranslation? (\u2190 getEnv) c |>.isNone then\n            return none\n        return tgt_args[0]?.bind fun tgtArg \u21a6\n          xs.findIdx? fun x \u21a6 Expr.containsFVar tgtArg x.fvarId!\n    trace[to_additive_detail] \"firstMultiplicativeArg: {l}\"\n    match l with\n    | [] => return 0\n    | (head :: tail) => return tail.foldr Nat.min head", "start": [651, 1], "end": [675, 55], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.capitalizeLikeAux", "code": "partial def capitalizeLikeAux (s : String) (i : String.Pos := 0) (p : String) : String :=\n  if p.atEnd i || s.atEnd i then\n    p\n  else\n    let j := p.next i\n    if (s.get i).isLower then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toLower)\n    else if (s.get i).isUpper then\n      capitalizeLikeAux s j <| p.set i (p.get i |>.toUpper)\n    else\n      capitalizeLikeAux s j p", "start": [677, 1], "end": [688, 30], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.capitalizeLike", "code": "def capitalizeLike (r : String) (s : String) :=\n  capitalizeLikeAux r 0 s", "start": [690, 1], "end": [692, 26], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.capitalizeFirstLike", "code": "def capitalizeFirstLike (s : String) : List String \u2192 List String\n  | x :: r => capitalizeLike s x :: r\n  | [] => []", "start": [694, 1], "end": [699, 13], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.nameDict", "code": "def nameDict : String \u2192 List String\n  | \"one\"         => [\"zero\"]\n  | \"mul\"         => [\"add\"]\n  | \"smul\"        => [\"vadd\"]\n  | \"inv\"         => [\"neg\"]\n  | \"div\"         => [\"sub\"]\n  | \"prod\"        => [\"sum\"]\n  | \"hmul\"        => [\"hadd\"]\n  | \"hsmul\"       => [\"hvadd\"]\n  | \"hdiv\"        => [\"hsub\"]\n  | \"hpow\"        => [\"hsmul\"]\n  | \"finprod\"     => [\"finsum\"]\n  | \"pow\"         => [\"nsmul\"]\n  | \"npow\"        => [\"nsmul\"]\n  | \"zpow\"        => [\"zsmul\"]\n  | \"monoid\"      => [\"add\", \"Monoid\"]\n  | \"submonoid\"   => [\"add\", \"Submonoid\"]\n  | \"group\"       => [\"add\", \"Group\"]\n  | \"subgroup\"    => [\"add\", \"Subgroup\"]\n  | \"semigroup\"   => [\"add\", \"Semigroup\"]\n  | \"magma\"       => [\"add\", \"Magma\"]\n  | \"haar\"        => [\"add\", \"Haar\"]\n  | \"prehaar\"     => [\"add\", \"Prehaar\"]\n  | \"unit\"        => [\"add\", \"Unit\"]\n  | \"units\"       => [\"add\", \"Units\"]\n  | \"rootable\"    => [\"divisible\"]\n  | x             => [x]", "start": [701, 1], "end": [734, 25], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.applyNameDict", "code": "def applyNameDict : List String \u2192 List String\n  | x :: s => (capitalizeFirstLike x (nameDict x.toLower)) ++ applyNameDict s\n  | [] => []", "start": [736, 1], "end": [742, 13], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.fixAbbreviation", "code": "def fixAbbreviation : List String \u2192 List String\n  | \"cancel\" :: \"Add\" :: s            => \"addCancel\" :: fixAbbreviation s\n  | \"Cancel\" :: \"Add\" :: s            => \"AddCancel\" :: fixAbbreviation s\n  | \"left\" :: \"Cancel\" :: \"Add\" :: s  => \"addLeftCancel\" :: fixAbbreviation s\n  | \"Left\" :: \"Cancel\" :: \"Add\" :: s  => \"AddLeftCancel\" :: fixAbbreviation s\n  | \"right\" :: \"Cancel\" :: \"Add\" :: s => \"addRightCancel\" :: fixAbbreviation s\n  | \"Right\" :: \"Cancel\" :: \"Add\" :: s => \"AddRightCancel\" :: fixAbbreviation s\n  | \"cancel\" :: \"Comm\" :: \"Add\" :: s  => \"addCancelComm\" :: fixAbbreviation s\n  | \"Cancel\" :: \"Comm\" :: \"Add\" :: s  => \"AddCancelComm\" :: fixAbbreviation s\n  | \"comm\" :: \"Add\" :: s              => \"addComm\" :: fixAbbreviation s\n  | \"Comm\" :: \"Add\" :: s              => \"AddComm\" :: fixAbbreviation s\n  | \"Zero\" :: \"LE\" :: s               => \"Nonneg\" :: fixAbbreviation s\n  | \"zero\" :: \"_\" :: \"le\" :: s        => \"nonneg\" :: fixAbbreviation s\n  | \"Zero\" :: \"LT\" :: s               => \"Pos\" :: fixAbbreviation s\n  | \"zero\" :: \"_\" :: \"lt\" :: s        => \"pos\" :: fixAbbreviation s\n  | \"LE\" :: \"Zero\" :: s               => \"Nonpos\" :: fixAbbreviation s\n  | \"le\" :: \"_\" :: \"zero\" :: s        => \"nonpos\" :: fixAbbreviation s\n  | \"LT\" :: \"Zero\" :: s               => \"Neg\" :: fixAbbreviation s\n  | \"lt\" :: \"_\" :: \"zero\" :: s        => \"neg\" :: fixAbbreviation s\n  | \"Add\" :: \"Single\" :: s            => \"Single\" :: fixAbbreviation s\n  | \"add\" :: \"Single\" :: s            => \"single\" :: fixAbbreviation s\n  | \"add\" :: \"_\" :: \"single\" :: s     => \"single\" :: fixAbbreviation s\n  | \"Add\" :: \"Support\" :: s           => \"Support\" :: fixAbbreviation s\n  | \"add\" :: \"Support\" :: s           => \"support\" :: fixAbbreviation s\n  | \"add\" :: \"_\" :: \"support\" :: s    => \"support\" :: fixAbbreviation s\n  | \"Add\" :: \"TSupport\" :: s          => \"TSupport\" :: fixAbbreviation s\n  | \"add\" :: \"TSupport\" :: s          => \"tsupport\" :: fixAbbreviation s\n  | \"add\" :: \"_\" :: \"tsupport\" :: s   => \"tsupport\" :: fixAbbreviation s\n  | \"Add\" :: \"Indicator\" :: s         => \"Indicator\" :: fixAbbreviation s\n  | \"add\" :: \"Indicator\" :: s         => \"indicator\" :: fixAbbreviation s\n  | \"add\" :: \"_\" :: \"indicator\" :: s  => \"indicator\" :: fixAbbreviation s\n  | \"is\" :: \"Square\" :: s             => \"even\" :: fixAbbreviation s\n  | \"Is\" :: \"Square\" :: s             => \"Even\" :: fixAbbreviation s\n  | \"is\" :: \"Regular\" :: s            => \"isAddRegular\" :: fixAbbreviation s\n  | \"Is\" :: \"Regular\" :: s            => \"IsAddRegular\" :: fixAbbreviation s\n  | \"is\" :: \"Left\" :: \"Regular\" :: s  => \"isAddLeftRegular\" :: fixAbbreviation s\n  | \"Is\" :: \"Left\" :: \"Regular\" :: s  => \"IsAddLeftRegular\" :: fixAbbreviation s\n  | \"is\" :: \"Right\" :: \"Regular\" :: s => \"isAddRightRegular\" :: fixAbbreviation s\n  | \"Is\" :: \"Right\" :: \"Regular\" :: s => \"IsAddRightRegular\" :: fixAbbreviation s\n  | \"HSmul\" :: s                      => \"HSMul\" :: fixAbbreviation s | \"NSmul\" :: s                      => \"NSMul\" :: fixAbbreviation s | \"Nsmul\" :: s                      => \"NSMul\" :: fixAbbreviation s | \"ZSmul\" :: s                      => \"ZSMul\" :: fixAbbreviation s | \"neg\" :: \"Fun\" :: s               => \"invFun\" :: fixAbbreviation s\n  | \"Neg\" :: \"Fun\" :: s               => \"InvFun\" :: fixAbbreviation s\n  | \"unique\" :: \"Prods\" :: s          => \"uniqueSums\" :: fixAbbreviation s\n  | \"Unique\" :: \"Prods\" :: s          => \"UniqueSums\" :: fixAbbreviation s\n  | \"order\" :: \"Of\" :: s              => \"addOrderOf\" :: fixAbbreviation s\n  | \"Order\" :: \"Of\" :: s              => \"AddOrderOf\" :: fixAbbreviation s\n  | \"is\"::\"Of\"::\"Fin\"::\"Order\"::s     => \"isOfFinAddOrder\" :: fixAbbreviation s\n  | \"Is\"::\"Of\"::\"Fin\"::\"Order\"::s     => \"IsOfFinAddOrder\" :: fixAbbreviation s\n  | \"is\" :: \"Central\" :: \"Scalar\" :: s  => \"isCentralVAdd\" :: fixAbbreviation s\n  | \"Is\" :: \"Central\" :: \"Scalar\" :: s  => \"IsCentralVAdd\" :: fixAbbreviation s\n  | x :: s                            => x :: fixAbbreviation s\n  | []                                => []", "start": [744, 1], "end": [809, 44], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.guessName", "code": "def guessName : String \u2192 String :=\n  String.mapTokens '\\'' <|\n  fun s =>\n    String.join <|\n    fixAbbreviation <|\n    applyNameDict <|\n    s.splitCase", "start": [811, 1], "end": [824, 16], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.targetName", "code": "def targetName (cfg : Config) (src : Name) : CoreM Name := do\n  let .str pre s := src | throwError \"to_additive: can't transport {src}\"\n  trace[to_additive_detail] \"The name {s} splits as {s.splitCase}\"\n  let tgt_auto := guessName s\n  let depth := cfg.tgt.getNumParts\n  let pre := pre.mapPrefix <| findTranslation? (\u2190 getEnv)\n  let (pre1, pre2) := pre.splitAt (depth - 1)\n  if cfg.tgt == pre2.str tgt_auto && !cfg.allowAutoName && cfg.tgt != src then\n    Linter.logLintIf linter.toAdditiveGenerateName cfg.ref\n      m!\"to_additive correctly autogenerated target name for {src}. {\"\\n\"\n      }You may remove the explicit argument {cfg.tgt}.\"\n  let res := if cfg.tgt == .anonymous then pre.str tgt_auto else pre1 ++ cfg.tgt\n  if res == src && cfg.tgt != src then\n    throwError \"to_additive: can't transport {src} to itself.\"\n  if cfg.tgt != .anonymous then\n    trace[to_additive_detail] \"The automatically generated name would be {pre.str tgt_auto}\"\n  return res", "start": [826, 1], "end": [844, 13], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.proceedFieldsAux", "code": "def proceedFieldsAux (src tgt : Name) (f : Name \u2192 CoreM (Array Name)) : CoreM Unit := do\n  let srcFields \u2190 f src\n  let tgtFields \u2190 f tgt\n  if srcFields.size != tgtFields.size then\n    throwError \"Failed to map fields of {src}, {tgt} with {srcFields} \u21a6 {tgtFields}\"\n  for (srcField, tgtField) in srcFields.zip tgtFields do\n    if srcField != tgtField then\n      insertTranslation (src ++ srcField) (tgt ++ tgtField)\n    else\n      trace[to_additive] \"Translation {src ++ srcField} \u21a6 {tgt ++ tgtField} is automatic.\"", "start": [846, 1], "end": [857, 91], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.proceedFields", "code": "def proceedFields (src tgt : Name) : CoreM Unit := do\n  let aux := proceedFieldsAux src tgt\n  aux fun declName \u21a6 do\n    if isStructure (\u2190 getEnv) declName then\n      return getStructureFields (\u2190 getEnv) declName\n    else\n      return #[]\n  aux fun declName \u21a6 do match (\u2190 getEnv).find? declName with\n    | some (ConstantInfo.inductInfo {ctors := ctors, ..}) => return ctors.toArray.map (\u00b7.getString)\n    | _ => pure #[]", "start": [859, 1], "end": [870, 20], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.elabToAdditive", "code": "def elabToAdditive : Syntax \u2192 CoreM Config\n  | `(attr| to_additive%$tk $[?%$trace]? $[$opts:toAdditiveOption]* $[$tgt]? $[$doc]?) => do\n    let mut attrs := #[]\n    let mut reorder := []\n    let mut existing := some false\n    for stx in opts do\n      match stx with\n      | `(toAdditiveOption| (attr := $[$stxs],*)) =>\n        attrs := attrs ++ stxs\n      | `(toAdditiveOption| (reorder := $[$[$reorders:num]*],*)) =>\n        reorder := reorder ++ reorders.toList.map (\u00b7.toList.map (\u00b7.raw.isNatLit?.get! - 1))\n      | `(toAdditiveOption| existing) =>\n        existing := some true\n      | _ => throwUnsupportedSyntax\n    reorder := reorder.reverse\n    trace[to_additive_detail] \"attributes: {attrs}; reorder arguments: {reorder}\"\n    return { trace := trace.isSome\n             tgt := match tgt with | some tgt => tgt.getId | none => Name.anonymous\n             doc := doc.bind (\u00b7.raw.isStrLit?)\n             allowAutoName := false\n             attrs\n             reorder\n             existing\n             ref := (tgt.map (\u00b7.raw)).getD tk }\n  | _ => throwUnsupportedSyntax", "start": [872, 1], "end": [897, 32], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.applyAttributes", "code": "partial def applyAttributes (stx : Syntax) (rawAttrs : Array Syntax) (thisAttr src tgt : Name) :\n  TermElabM (Array Name) := do\n  copyInstanceAttribute src tgt\n  if linter.existingAttributeWarning.get (\u2190 getOptions) then\n    let appliedAttrs \u2190 getAllSimpAttrs src\n    if appliedAttrs.size > 0 then\n      Linter.logLintIf linter.existingAttributeWarning stx <|\n        m!\"The source declaration {src} was given the simp-attribute(s) {appliedAttrs} before {\n        \"\"}calling @[{thisAttr}]. The preferred method is to use {\n        \"\"}`@[{thisAttr} (attr := {appliedAttrs})]` to apply the attribute to both {\n        src} and the target declaration {tgt}.\"\n    warnAttr stx Std.Tactic.Ext.extExtension\n      (fun b n => (b.tree.values.any fun t => t.declName = n)) thisAttr `ext src tgt\n    warnAttr stx Std.Tactic.reflExt (\u00b7.values.contains \u00b7) thisAttr `refl src tgt\n    warnAttr stx Std.Tactic.symmExt (\u00b7.values.contains \u00b7) thisAttr `symm src tgt\n    warnAttr stx Mathlib.Tactic.transExt (\u00b7.values.contains \u00b7) thisAttr `trans src tgt\n    warnAttr stx Std.Tactic.Coe.coeExt (\u00b7.contains \u00b7) thisAttr `coe src tgt\n    warnParametricAttr stx Lean.Linter.deprecatedAttr thisAttr `deprecated src tgt\n    warnParametricAttr stx simpsAttr thisAttr `simps src tgt\n    warnExt stx Term.elabAsElim.ext (\u00b7.contains \u00b7) thisAttr `elab_as_elim src tgt\n  let attrs \u2190 elabAttrs rawAttrs\n  let (additiveAttrs, attrs) := attrs.partition (\u00b7.name == `to_additive)\n  let nestedDecls \u2190\n    match additiveAttrs.size with\n      | 0 => pure #[]\n      | 1 => addToAdditiveAttr tgt (\u2190 elabToAdditive additiveAttrs[0]!.stx) additiveAttrs[0]!.kind\n      | _ => throwError \"cannot apply {thisAttr} multiple times.\"\n  let allDecls := #[src, tgt] ++ nestedDecls\n  if attrs.size > 0 then\n    trace[to_additive_detail] \"Applying attributes {attrs.map (\u00b7.stx)} to {allDecls}\"\n  for attr in attrs do\n    withRef attr.stx do withLogging do\n    if attr.name == `simp then\n      additivizeLemmas allDecls \"simp lemmas\"\n        (Meta.Simp.addSimpAttrFromSyntax \u00b7 simpExtension attr.kind attr.stx)\n      return\n    if attr.name == `simps then\n      additivizeLemmas allDecls \"simps lemmas\" (simpsTacFromSyntax \u00b7 attr.stx)\n      return\n    let env \u2190 getEnv\n    match getAttributeImpl env attr.name with\n    | Except.error errMsg => throwError errMsg\n    | Except.ok attrImpl  =>\n      let runAttr := do\n        attrImpl.add src attr.stx attr.kind\n        attrImpl.add tgt attr.stx attr.kind\n      let elaborator := attrImpl.ref\n      if (\u2190 getInfoState).enabled && (\u2190 getEnv).contains elaborator then\n        withInfoContext (mkInfo := return .ofCommandInfo { elaborator, stx := attr.stx }) do\n          try runAttr\n          finally if attr.stx[0].isIdent || attr.stx[0].isAtom then\n            pushInfoLeaf <| .ofCommandInfo { elaborator, stx := attr.stx[0] }\n      else\n        runAttr\n  return nestedDecls", "start": [900, 1], "end": [967, 21], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.copyMetaData", "code": "partial def copyMetaData (cfg : Config) (src tgt : Name) : CoreM (Array Name) := do\n  if let some eqns := eqnsAttribute.find? (\u2190 getEnv) src then\n    unless (eqnsAttribute.find? (\u2190 getEnv) tgt).isSome do\n      for eqn in eqns do _ \u2190 addToAdditiveAttr eqn cfg\n      eqnsAttribute.add tgt (eqns.map (findTranslation? (\u2190 getEnv) \u00b7 |>.get!))\n  else\n    \n    additivizeLemmas #[src, tgt] \"equation lemmas\" fun nm \u21a6\n      (\u00b7.getD #[]) <$> MetaM.run' (getEqnsFor? nm true)\n  MetaM.run' <| Elab.Term.TermElabM.run' <|\n    applyAttributes cfg.ref cfg.attrs `to_additive src tgt", "start": [969, 1], "end": [984, 59], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.transformDecl", "code": "partial def transformDecl (cfg : Config) (src tgt : Name) : CoreM (Array Name) := do\n  transformDeclAux cfg src tgt src\n  copyMetaData cfg src tgt", "start": [986, 1], "end": [993, 27], "kind": "commanddeclaration"}, {"full_name": "ToAdditive.addToAdditiveAttr", "code": "partial def addToAdditiveAttr (src : Name) (cfg : Config) (kind := AttributeKind.global) :\n  AttrM (Array Name) := do\n  if (kind != AttributeKind.global) then\n    throwError \"`to_additive` can only be used as a global attribute\"\n  withOptions (\u00b7 |>.updateBool `trace.to_additive (cfg.trace || \u00b7)) <| do\n  let tgt \u2190 targetName cfg src\n  let alreadyExists := (\u2190 getEnv).contains tgt\n  if cfg.existing == some !alreadyExists && !(\u2190 isInductive src) then\n    Linter.logLintIf linter.toAdditiveExisting cfg.ref <|\n      if alreadyExists then\n        m!\"The additive declaration already exists. Please specify this explicitly using {\n          \"\"}`@[to_additive existing]`.\"\n      else\n        \"The additive declaration doesn't exist. Please remove the option `existing`.\"\n  if cfg.reorder != [] then\n    trace[to_additive] \"@[to_additive] will reorder the arguments of {tgt}.\"\n    reorderAttr.add src cfg.reorder\n    if findTranslation? (\u2190 getEnv) src |>.isSome then\n      return #[tgt]\n  let firstMultArg \u2190 MetaM.run' <| firstMultiplicativeArg src\n  if firstMultArg != 0 then\n    trace[to_additive_detail] \"Setting relevant_arg for {src} to be {firstMultArg}.\"\n    relevantArgAttr.add src firstMultArg\n  insertTranslation src tgt alreadyExists\n  let nestedNames \u2190\n    if alreadyExists then\n      trace[to_additive_detail] \"declaration {tgt} already exists.\"\n      proceedFields src tgt\n      copyMetaData cfg src tgt\n    else\n      transformDecl cfg src tgt\n  pushInfoLeaf <| .ofTermInfo {\n    elaborator := .anonymous, lctx := {}, expectedType? := none, isBinder := !alreadyExists,\n    stx := cfg.ref, expr := \u2190 mkConstWithLevelParams tgt }\n  if let some doc := cfg.doc then\n    addDocString tgt doc\n  return nestedNames.push tgt", "start": [995, 1], "end": [1041, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/Free.lean", "imports": ["lake-packages/aesop/Aesop/Tree/TreeM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.freeGoalRef", "code": "private partial def freeGoalRef (gref : GoalRef) : BaseIO Unit := do\n    gref.modify \u03bb g => g.setParent dummyMVarClusterRef\n    (\u2190 gref.get).children.forM freeRappRef", "start": [22, 3], "end": [24, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.freeRappRef", "code": "private partial def freeRappRef (rref : RappRef) : BaseIO Unit := do\n    rref.modify \u03bb r => r.setParent dummyGoalRef\n    (\u2190 rref.get).children.forM freeMVarClusterRef", "start": [26, 3], "end": [28, 50], "kind": "commanddeclaration"}, {"full_name": "Aesop.freeMVarClusterRef", "code": "private partial def freeMVarClusterRef (cref : MVarClusterRef) :\n      BaseIO Unit := do\n    cref.modify \u03bb c => c.setParent none\n    (\u2190 cref.get).goals.forM freeGoalRef", "start": [30, 3], "end": [33, 40], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkDummyRefs", "code": "private def mkDummyRefs : BaseIO (GoalRef \u00d7 MVarClusterRef) := do\n  let cref \u2190 IO.mkRef $ MVarCluster.mk {\n    parent? := default\n    goals := #[]\n    isIrrelevant := default\n    state := default\n  }\n  let gref \u2190 IO.mkRef $ Goal.mk {\n    id := default\n    parent := cref\n    children := default\n    origin := default\n    depth := default\n    state := default\n    isIrrelevant := default\n    isForcedUnprovable := default\n    preNormGoal := default\n    normalizationState := default\n    mvars := default\n    successProbability := default\n    addedInIteration := default\n    lastExpandedInIteration := default\n    unsafeRulesSelected := default\n    unsafeQueue := default\n    failedRapps := default\n  }\n  return (gref, cref)", "start": [36, 1], "end": [62, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalRef.free", "code": "def GoalRef.free (gref : GoalRef) : BaseIO Unit := do\n  let (dgref, dcref) \u2190 mkDummyRefs\n  freeGoalRef dgref dcref gref", "start": [64, 1], "end": [66, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappRef.free", "code": "def RappRef.free (rref : RappRef) : BaseIO Unit := do\n  let (dgref, dcref) \u2190 mkDummyRefs\n  freeRappRef dgref dcref rref", "start": [68, 1], "end": [70, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.free", "code": "def MVarClusterRef.free (cref : MVarClusterRef) : BaseIO Unit := do\n  let (dgref, dcref) \u2190 mkDummyRefs\n  freeMVarClusterRef dgref dcref cref", "start": [72, 1], "end": [74, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.freeTree", "code": "def freeTree : TreeM Unit := do\n  (\u2190 get).root.free", "start": [76, 1], "end": [77, 20], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/AddRapp.lean", "imports": ["lake-packages/aesop/Aesop/RuleTac/RuleApplicationWithMVarInfo.lean", "lake-packages/aesop/Aesop/Check.lean", "lake-packages/aesop/Aesop/Tree/TreeM.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Tree/Traversal.lean"], "premises": [{"full_name": "Aesop.AddRapp", "code": "structure AddRapp extends RuleApplicationWithMVarInfo where\n  parent : GoalRef\n  appliedRule : RegularRule\n  successProbability : Percent", "start": [17, 1], "end": [20, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.clusterGoals", "code": "private def clusterGoals (goals : Array Goal) : Array (Array Goal) := Id.run do\n  let mut clusters := UnionFind.ofArray goals\n  let mut mvarOccs : HashMap MVarId (Array Goal) := {}\n  for g in goals do\n    for m in g.mvars do\n      match mvarOccs.find? m with\n      | some otherOccs =>\n        for g' in otherOccs do\n          clusters := clusters.merge g g'\n        mvarOccs := mvarOccs.insert m (otherOccs.push g)\n      | none =>\n        mvarOccs := mvarOccs.insert m #[g]\n  return clusters.sets.fst", "start": [22, 1], "end": [34, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.findPathForAssignedMVars", "code": "private def findPathForAssignedMVars (assignedMVars : UnorderedArraySet MVarId)\n    (start : GoalRef) : TreeM (Array RappRef \u00d7 HashSet GoalId) := do\n  if assignedMVars.isEmpty then\n    return (#[], {})\n  let unseen : IO.Ref (UnorderedArraySet MVarId) \u2190 IO.mkRef assignedMVars\n  let pathRapps : IO.Ref (Array RappRef) \u2190 IO.mkRef #[]\n  let pathGoals : IO.Ref (HashSet GoalId) \u2190 IO.mkRef {}\n  preTraverseUp\n    (\u03bb gref => do\n      let id := (\u2190 gref.get).originalGoalId\n      pathGoals.modify (\u00b7.insert id)\n      return true)\n    (\u03bb rref => do\n      pathRapps.modify (\u00b7.push rref)\n      for introducedMVar in (\u2190 rref.get).introducedMVars do\n        unseen.modify (\u00b7.erase introducedMVar)\n      if (\u2190 unseen.get).isEmpty then\n        return false\n      else\n        return true)\n    (\u03bb _ =>\n      return true)\n    (TreeRef.goal start)\n  let unseen \u2190 unseen.get\n  if ! unseen.isEmpty then\n    let rootGoalMVars := (\u2190 (\u2190 getRootGoal).get).mvars\n    if unseen.any (! rootGoalMVars.contains \u00b7) then\n      let reallyUnseen :=\n        unseen.toArray.filter (! rootGoalMVars.contains \u00b7) |>.map (\u00b7.name)\n      throwError \"aesop: internal error: introducing rapps not found for these mvars: {reallyUnseen}\"\n  return (\u2190 pathRapps.get, \u2190 pathGoals.get)", "start": [36, 1], "end": [66, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.getGoalsToCopy", "code": "private def getGoalsToCopy (assignedMVars : UnorderedArraySet MVarId)\n    (start : GoalRef) : TreeM (Array GoalRef) := do\n  let (pathRapps, pathGoals) \u2190 findPathForAssignedMVars assignedMVars start\n  let mut toCopy := #[]\n  let mut toCopyIds := HashSet.empty\n  for rref in pathRapps do\n    for cref in (\u2190 rref.get).children do\n      for gref in (\u2190 cref.get).goals do\n        let g \u2190 gref.get\n        let id := g.originalGoalId\n        if ! pathGoals.contains id && ! toCopyIds.contains id &&\n           g.mvars.any (assignedMVars.contains \u00b7) then\n          toCopy := toCopy.push gref\n          toCopyIds := toCopyIds.insert id\n  return toCopy", "start": [68, 1], "end": [88, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.copyGoals", "code": "private unsafe def copyGoals (assignedMVars : UnorderedArraySet MVarId)\n    (start : GoalRef) (parentMetaState : Meta.SavedState)\n    (parentSuccessProbability : Percent) (depth : Nat) :\n    TreeM (Array Goal) := do\n  let toCopy \u2190 getGoalsToCopy assignedMVars start\n  toCopy.mapM \u03bb gref => do\n    let g \u2190 gref.get\n    have : Ord MVarId := \u27e8\u03bb m\u2081 m\u2082 => m\u2081.name.quickCmp m\u2082.name\u27e9\n    let mvars \u2190 parentMetaState.runMetaM' $\n      .ofHashSet <$> g.preNormGoal.getMVarDependencies\n    return Goal.mk {\n      id := \u2190 getAndIncrementNextGoalId\n      parent := unsafeCast () children := #[]\n      origin := .copied g.id g.originalGoalId\n      depth\n      state := GoalState.unknown\n      isIrrelevant := false\n      isForcedUnprovable := false\n      preNormGoal := g.preNormGoal\n      normalizationState := NormalizationState.notNormal\n      mvars\n      successProbability := parentSuccessProbability\n      addedInIteration := (\u2190 read).currentIteration\n      lastExpandedInIteration := Iteration.none\n      unsafeRulesSelected := false\n      unsafeQueue := {}\n      failedRapps := #[]\n    }", "start": [90, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "Aesop.makeInitialGoal", "code": "private def makeInitialGoal (goal : MVarId) (mvars : UnorderedArraySet MVarId)\n    (parent : MVarClusterRef) (depth : Nat) (successProbability : Percent)\n    (origin : GoalOrigin) : TreeM Goal :=\n  return Goal.mk {\n    id := \u2190 getAndIncrementNextGoalId\n    children := #[]\n    state := GoalState.unknown\n    isIrrelevant := false\n    isForcedUnprovable := false\n    preNormGoal := goal\n    normalizationState := NormalizationState.notNormal\n    addedInIteration := (\u2190 read).currentIteration\n    lastExpandedInIteration := Iteration.none\n    unsafeRulesSelected := false\n    unsafeQueue := {}\n    failedRapps := #[]\n    parent, origin, depth, mvars, successProbability\n  }", "start": [120, 1], "end": [137, 4], "kind": "commanddeclaration"}, {"full_name": "Aesop.addRappUnsafe", "code": "private unsafe def addRappUnsafe (r : AddRapp) : TreeM RappRef := do\n  if \u2190 Check.rules.isEnabled then\n    let (parentGoal, preState) \u2190\n      (\u2190 r.parent.get).currentGoalAndMetaState (\u2190 getRootMetaState)\n    let (some msg) \u2190 r.toRuleApplicationWithMVarInfo.check preState parentGoal\n      | pure ()\n    throwError \"{Check.rules.name}: {msg}\"\n\n  let rref : RappRef \u2190 IO.mkRef $ Rapp.mk {\n    id := \u2190 getAndIncrementNextRappId\n    parent := r.parent\n    children := #[] state := NodeState.unknown\n    isIrrelevant := false\n    appliedRule := r.appliedRule\n    scriptBuilder? := r.scriptBuilder?\n    originalSubgoals := r.originalSubgoals\n    successProbability := r.successProbability\n    metaState := r.postState\n    introducedMVars := {} assignedMVars := r.assignedMVars\n  }\n\n  let parentGoal \u2190 r.parent.get\n  let goalDepth := parentGoal.depth + 1\n\n  let droppedMVars := parentGoal.mvars.filter \u03bb m =>\n    ! r.mvars.contains m && ! r.assignedMVars.contains m\n\n  let quasiAssignedMVars := r.assignedMVars ++ droppedMVars\n  let copiedGoals : Array Goal \u2190\n    if quasiAssignedMVars.isEmpty then\n      pure #[]\n    else\n      copyGoals quasiAssignedMVars r.parent r.postState\n        r.successProbability goalDepth\n\n  let copiedGoalMVars := copiedGoals.foldl (init := HashSet.empty)\n    \u03bb copiedGoalMVars g => copiedGoalMVars.insertMany g.mvars\n\n  let droppedGoals \u2190 droppedMVars.toArray.filterMapM \u03bb m => do\n    if copiedGoalMVars.contains m then\n      return none\n    else\n      let mvars \u2190 r.postState.runMetaM' $ .ofHashSet <$> m.getMVarDependencies\n      let g \u2190 makeInitialGoal m mvars (unsafeCast ()) goalDepth\n        r.successProbability .droppedMVar\n        return some g\n\n  let mut goals := Array.mkEmpty r.goals.size\n  let mut introducedMVars := r.introducedMVars\n  for (g, mvars) in r.goals do\n    if copiedGoalMVars.contains g then\n      introducedMVars := introducedMVars.insert g\n    else\n      goals := goals.push (g, mvars)\n\n  let subgoals \u2190 goals.mapM \u03bb (goal, mvars) =>\n    makeInitialGoal goal mvars (unsafeCast ()) goalDepth\n      r.successProbability .subgoal\n      let newGoals := subgoals ++ copiedGoals ++ droppedGoals\n\n  let crefs : Array MVarClusterRef \u2190\n    clusterGoals newGoals |>.mapM \u03bb gs => do\n      let grefs \u2190 gs.mapM (IO.mkRef \u00b7)\n      let cref \u2190 IO.mkRef $ MVarCluster.mk {\n        parent? := some rref\n        goals := grefs\n        isIrrelevant := false\n        state := NodeState.unknown\n      }\n      grefs.forM \u03bb gref => gref.modify \u03bb g => g.setParent cref\n      return cref\n\n  rref.modify \u03bb r =>\n    r.setChildren crefs |>.setIntroducedMVars introducedMVars\n  r.parent.modify \u03bb g => g.setChildren $ g.children.push rref\n\n  incrementNumGoals newGoals.size\n  incrementNumRapps\n  return rref", "start": [139, 1], "end": [236, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.addRapp", "code": "@[implemented_by addRappUnsafe]\nopaque addRapp : AddRapp \u2192 TreeM RappRef", "start": [246, 1], "end": [247, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/ExtractScript.lean", "imports": ["lake-packages/aesop/Aesop/Tracing.lean", "lake-packages/aesop/Aesop/Tree/TreeM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.ExtractScriptM", "code": "abbrev ExtractScriptM := StateRefT UnstructuredScript TreeM", "start": [16, 1], "end": [16, 60], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.extractScriptCore", "code": "partial def MVarClusterRef.extractScriptCore (cref : MVarClusterRef) :\n      ExtractScriptM Unit := do\n    let c \u2190 cref.get\n    let (some gref) \u2190 c.provenGoal? | throwError\n      m!\"the mvar cluster with goals {(\u2190 c.goals.mapM (\u00b7.get)).map (\u00b7.id)} does not contain a proven goal\"\n    gref.extractScriptCore", "start": [19, 3], "end": [24, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.GoalRef.extractScriptCore", "code": "partial def GoalRef.extractScriptCore (gref : GoalRef) : ExtractScriptM Unit := do\n    let g \u2190 gref.get\n    match g.normalizationState with\n    | .notNormal => throwError \"expected goal {g.id} to be normalised\"\n    | .provenByNormalization _ normScript? =>\n      modify (\u00b7 ++ (\u2190 getNormScript g.id normScript?))\n    | .normal postGoal postState normScript? =>\n      modify (\u00b7 ++ (\u2190 getNormScript g.id normScript?))\n      let (some rref) \u2190 g.firstProvenRapp? | throwError\n        m!\"goal {g.id} does not have a proven rapp\"\n      rref.extractScriptCore postGoal postState\n    where\n      @[inline, always_inline]\n      getNormScript (gid : GoalId) :\n          Except DisplayRuleName UnstructuredScript \u2192 ExtractScriptM UnstructuredScript\n        | .ok script => pure script\n        | .error rule => throwError \"normalization rule {rule} (at goal {gid}) does not support tactic script generation\"", "start": [26, 3], "end": [42, 122], "kind": "commanddeclaration"}, {"full_name": "Aesop.RappRef.extractScriptCore", "code": "partial def RappRef.extractScriptCore (rref : RappRef) (preGoal : MVarId)\n      (preState : Meta.SavedState) : ExtractScriptM Unit := do\n    let r \u2190 rref.get\n    let postState := r.metaState\n    let (some scriptBuilder) := r.scriptBuilder?\n      | throwError \"rule {r.appliedRule.name} (at rapp {r.id}) does not support tactic script generation\"\n    let tacticSeq \u2190\n      try\n        postState.runMetaM' scriptBuilder.unstructured.run\n      catch e =>\n        throwError \"script builder for rapp {r.id} reported error:{indentD $ e.toMessageData}\"\n    let postGoals \u2190 postState.runMetaM' do\n      r.originalSubgoals.mapM \u03bb g => return \u27e8g, \u2190 g.getMVarDependencies\u27e9\n    modify \u03bb s => s.push { postState, tacticSeq, preGoal, postGoals, preState }\n    r.children.forM (\u00b7.extractScriptCore)", "start": [44, 3], "end": [58, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.extractScript", "code": "@[inline]\ndef MVarClusterRef.extractScript (cref : MVarClusterRef) :\n    TreeM UnstructuredScript :=\n  (\u00b7.snd) <$> cref.extractScriptCore.run #[]", "start": [61, 1], "end": [64, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/Check.lean", "imports": ["lake-packages/aesop/Aesop/Check.lean", "lake-packages/aesop/Aesop/Tree/State.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Tree/Traversal.lean", "lake-packages/aesop/Aesop/Tree/TreeM.lean"], "premises": [{"full_name": "Aesop.MVarClusterRef.checkIds", "code": "def checkIds (root : MVarClusterRef) : CoreM Unit := do\n  let visitedGoalIds : IO.Ref (HashSet GoalId) \u2190 IO.mkRef {}\n  let visitedRappIds : IO.Ref (HashSet RappId) \u2190 IO.mkRef {}\n  preTraverseDown\n    (\u03bb gref => do\n      let id := (\u2190 gref.get).id\n      if (\u2190 visitedGoalIds.get).contains id then\n        throwError \"{Check.tree.name}: duplicate goal id: {id}\"\n      visitedGoalIds.modify \u03bb s => s.insert id\n      return true)\n    (\u03bb rref => do\n      let id := (\u2190 rref.get).id\n      if (\u2190 visitedRappIds.get).contains id then\n        throwError \"{Check.tree.name}: duplicate rapp id: {id}\"\n      visitedRappIds.modify \u03bb s => s.insert id\n      return true)\n    (\u03bb _ => return true)\n    (TreeRef.mvarCluster root)", "start": [17, 1], "end": [34, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.checkAcyclic", "code": "def checkAcyclic (root : MVarClusterRef) : CoreM Unit := do\n  let visitedGoalRefs        : IO.Ref (Array GoalRef)        \u2190 ST.mkRef #[]\n  let visitedRappRefs        : IO.Ref (Array RappRef)        \u2190 ST.mkRef #[]\n  let visitedMVarClusterRefs : IO.Ref (Array MVarClusterRef) \u2190 ST.mkRef #[]\n  preTraverseDown\n    (\u03bb gref => go visitedGoalRefs gref)\n    (\u03bb rref => go visitedRappRefs rref)\n    (\u03bb cref => go visitedMVarClusterRefs cref)\n    (TreeRef.mvarCluster root)\n  where\n    go {\u03b1} (visited : IO.Ref (Array (IO.Ref \u03b1))) (current : IO.Ref \u03b1) :\n        CoreM Bool := do\n      if \u2190 (\u2190 visited.get).anyM (current.ptrEq \u00b7) then throwError\n        \"{Check.tree.name}: search tree contains a cycle.\"\n      visited.modify (\u00b7.push current)\n      return true", "start": [36, 1], "end": [55, 18], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.checkConsistentParentChildLinks", "code": "def checkConsistentParentChildLinks (root : MVarClusterRef) : CoreM Unit :=\n  preTraverseDown\n    (\u03bb gref => do\n      for c in (\u2190 gref.get).children do\n        if \u2190 notM $ (\u2190 c.get).parent.ptrEq gref then err\n      return true)\n    (\u03bb rref => do\n      for c in (\u2190 rref.get).children do\n        match (\u2190 c.get).parent? with\n        | some parent =>\n          if \u2190 notM $ parent.ptrEq rref then err\n        | none =>\n          err\n      return true)\n    (\u03bb cref => do\n      for c in (\u2190 cref.get).goals do\n        if \u2190 notM $ (\u2190 c.get).parent.ptrEq cref then err\n      return true)\n    (TreeRef.mvarCluster root)\n  where\n    err := throwError \"{Check.tree.name}: search tree is not properly linked.\"", "start": [57, 1], "end": [77, 79], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.mvarClusterId", "code": "private def mvarClusterId (c : MVarCluster) : BaseIO String :=\n  match c.parent? with\n  | some parentRef => return s!\"mvar cluster of rapp {(\u2190 parentRef.get).id}\"\n  | none => return s!\"root mvar cluster\"", "start": [79, 1], "end": [82, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.checkState", "code": "def checkState (root : MVarClusterRef) : CoreM Unit :=\n  postTraverseDown\n    (\u03bb gref => do\n      let g \u2190 gref.get\n      go s!\"goal {g.id}\" (\u2190 g.stateNoCache) g.state)\n    (\u03bb rref => do\n      let r \u2190 rref.get\n      go s!\"rapp {r.id}\" (\u2190 r.stateNoCache) r.state)\n    (\u03bb cref => do\n      let c \u2190 cref.get\n      go (\u2190 mvarClusterId c) (\u2190 c.stateNoCache) c.state)\n    (TreeRef.mvarCluster root)\n  where\n    @[inline]\n    go {\u03c3} [BEq \u03c3] [ToString \u03c3] (id : String) (expected actual : \u03c3) :\n        CoreM Unit := do\n      if expected != actual then throwError\n        \"{Check.tree.name}: {id} has wrong state: marked as '{actual}' but should be '{expected}'.\"", "start": [84, 1], "end": [101, 100], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.checkIrrelevance", "code": "def checkIrrelevance (root : MVarClusterRef) : CoreM Unit :=\n  preTraverseDown\n    (\u03bb gref => do\n      let g \u2190 gref.get\n      go s!\"goal {g.id}\" (\u2190 g.isIrrelevantNoCache) g.isIrrelevant)\n    (\u03bb rref => do\n      let r \u2190 rref.get\n      go s!\"rapp {r.id}\" (\u2190 r.isIrrelevantNoCache) r.isIrrelevant)\n    (\u03bb cref => do\n      let c \u2190 cref.get\n      go (\u2190 mvarClusterId c) (\u2190 c.isIrrelevantNoCache) c.isIrrelevant)\n    (TreeRef.mvarCluster root)\n  where\n    @[inline]\n    go (id : String) (expected actual : Bool) : CoreM Bool := do\n      match actual, expected with\n      | true, false => throwError\n        \"{Check.tree.name}: {id} is marked as irrelevant, but is not irrelevant.\"\n      | false, true => throwError\n        \"{Check.tree.name}: {id} is marked as not irrelevant, but is irrelevant.\"\n      | _, _ => return true", "start": [103, 1], "end": [123, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.checkMVars", "code": "def checkMVars (root : MVarClusterRef) (rootMetaState : Meta.SavedState) :\n    MetaM Unit :=\n  preTraverseDown\n    (\u03bb gref => do\n      let g \u2190 gref.get\n      checkGoalMVars g\n      return true)\n    (\u03bb rref => do\n      let r \u2190 rref.get\n      checkAssignedMVars r\n      checkDroppedMVars r\n      return true)\n    (\u03bb _ => return true)\n    (TreeRef.mvarCluster root)\n  where\n    getParentInfo (r : Rapp) : CoreM (MVarId \u00d7 Meta.SavedState) := do\n      let some res := (\u2190 r.parent.get).postNormGoalAndMetaState? | throwError\n        \"{Check.tree.name}: expected parent goal of rapp {r.id} to be normalised (but not proven by normalisation).\"\n      return res\n\n    checkAssignedMVars (r : Rapp) : MetaM Unit := do\n      let (parentPostNormGoal, parentPostNormState) \u2190 getParentInfo r\n      let actualAssigned :=\n        (\u2190 getAssignedExprMVars parentPostNormState r.metaState).erase\n          parentPostNormGoal\n      unless actualAssigned.equalSet r.assignedMVars.toArray do throwError\n        \"{Check.tree.name}: rapp {r.id} reports incorrect assigned mvars.\\n  reported: {r.assignedMVars.toArray.map (\u00b7.name)}\\n  actual: {actualAssigned.map (\u00b7.name)}\"\n\n    checkDroppedMVars (r : Rapp) : MetaM Unit := do\n      let droppableMVars :=\n        (\u2190 r.parent.get).mvars ++ r.introducedMVars |>.toArray\n      let mut nonDroppedMVars := HashSet.ofArray r.assignedMVars.toArray\n      for cref in r.children do\n        for gref in (\u2190 cref.get).goals do\n          let g \u2190 gref.get\n          nonDroppedMVars := nonDroppedMVars.insert g.preNormGoal\n          nonDroppedMVars := nonDroppedMVars.insertMany g.mvars\n      if droppableMVars.any (! nonDroppedMVars.contains \u00b7) then throwError\n        \"{Check.tree.name}: rapp {r.id} dropped mvars.\\n  mvars introduced or present in parent: {droppableMVars.map (\u00b7.name)}\\n  mvars assigned or present in subgoals:\\n  {nonDroppedMVars.toArray.map (\u00b7.name)}\"\n\n    checkGoalMVars (g : Goal) : MetaM Unit := do\n      checkNormMVars g\n      let actualPreNormMVars \u2190 g.runMetaMInParentState'\n        g.preNormGoal.getMVarDependencies\n      let expectedMVars := HashSet.ofArray g.mvars.toArray\n      unless actualPreNormMVars == expectedMVars do throwError\n        \"{Check.tree.name}: goal {g.id} reports incorrect unassigned mvars.\\n  reported: {g.mvars.toArray.map (\u00b7.name)}\\n  actual: {actualPreNormMVars.toArray.map (\u00b7.name)}\"\n\n    checkNormMVars (g : Goal) : MetaM Unit := do\n      let go (parentMetaState postMetaState : Meta.SavedState)\n          (introduced : Array MVarId) : MetaM Unit := do\n        unless introduced.isEmpty do throwError\n          \"{Check.tree.name}: normalisation of goal {g.id} introduced additional metavariables:{indentD $ toMessageData $ introduced.map (\u00b7.name)}\"\n        let assigned :=\n          (\u2190 getAssignedExprMVars parentMetaState postMetaState).erase\n            g.preNormGoal\n        unless assigned.isEmpty do throwError\n          \"{Check.tree.name}: normalisation of goal {g.id} assigned metavariables:{indentD $ toMessageData $ assigned.map (\u00b7.name)}\"\n      match g.normalizationState with\n      | .notNormal => return\n      | .provenByNormalization postMetaState .. =>\n        let parentMetaState \u2190 g.parentMetaState rootMetaState\n        let introduced \u2190 getIntroducedExprMVars parentMetaState postMetaState\n        go parentMetaState postMetaState introduced\n      | .normal postGoal postMetaState .. =>\n        let parentMetaState \u2190 g.parentMetaState rootMetaState\n        let introduced :=\n          (\u2190 getIntroducedExprMVars parentMetaState postMetaState).erase\n            postGoal\n        go parentMetaState postMetaState introduced", "start": [125, 1], "end": [194, 52], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.checkInvariants", "code": "def checkInvariants (root : MVarClusterRef) (rootMetaState : Meta.SavedState) :\n    MetaM Unit := do\n  root.checkAcyclic\n  root.checkConsistentParentChildLinks\n  root.checkIds\n  root.checkState\n  root.checkIrrelevance\n  root.checkMVars rootMetaState", "start": [196, 1], "end": [203, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.MVarClusterRef.checkInvariantsIfEnabled", "code": "def checkInvariantsIfEnabled (root : MVarClusterRef)\n    (rootMetaState : Meta.SavedState) : MetaM Unit := do\n  if \u2190 Check.tree.isEnabled then\n    root.checkInvariants rootMetaState", "start": [205, 1], "end": [208, 39], "kind": "commanddeclaration"}, {"full_name": "checkInvariantsIfEnabled", "code": "def checkInvariantsIfEnabled : TreeM Unit := do\n  (\u2190 getRootMVarCluster).checkInvariantsIfEnabled (\u2190 getRootMetaState)", "start": [212, 1], "end": [213, 71], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree/ExtractProof.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Replay.lean", "lake-packages/aesop/Aesop/Tracing.lean", "lake-packages/aesop/Aesop/Tree/Tracing.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Tree/TreeM.lean"], "premises": [{"full_name": "Aesop.getNewConsts", "code": "private def getNewConsts (oldEnv newEnv : Environment) :\n    HashMap Name ConstantInfo := Id.run do\n  let oldMap\u2082 := oldEnv.constants.map\u2082\n  let newMap\u2082 := newEnv.constants.map\u2082\n  if oldMap\u2082.size == newMap\u2082.size then\n    HashMap.empty\n  else\n    newMap\u2082.foldl (init := HashMap.empty) \u03bb cs n c =>\n      if oldMap\u2082.contains n then cs else cs.insert n c", "start": [54, 1], "end": [62, 55], "kind": "commanddeclaration"}, {"full_name": "Aesop.copyNewDeclarations", "code": "private def copyNewDeclarations (oldEnv newEnv : Environment) : CoreM Unit := do\n  let newConsts := getNewConsts oldEnv newEnv\n  setEnv (\u2190 (\u2190 getEnv).replay newConsts)", "start": [72, 1], "end": [74, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.copyMatchEqnsExtState", "code": "private def copyMatchEqnsExtState (oldEnv newEnv : Environment) : CoreM Unit := do\n  let oldState := matchEqnsExt.getState oldEnv\n  let newState := matchEqnsExt.getState newEnv\n  if newState.map.size > oldState.map.size then\n    for (n, eqns) in newState.map do\n      if !oldState.map.contains n then\n        registerMatchEqns n eqns", "start": [77, 1], "end": [83, 33], "kind": "commanddeclaration"}, {"full_name": "Aesop.copyExprMVar", "code": "private partial def copyExprMVar (s : Meta.SavedState) (mvarId : MVarId) :\n    MetaM Unit := do\n  if \u2190 mvarId.isAssignedOrDelayedAssigned then\n    return\n  unless \u2190 mvarId.isDeclared do\n    let decl \u2190 s.runMetaM' $ do\n      mvarId.instantiateMVars\n      let decl \u2190 mvarId.getDecl\n      aesop_trace[extraction] \"declare ?{mvarId.name}:{indentD $ toMessageData mvarId}\"\n      pure decl\n    modifyMCtx \u03bb mctx => { mctx with decls := mctx.decls.insert mvarId decl }\n    let depMVarIds \u2190 mvarId.getMVarDependencies (includeDelayed := true)\n    for depMVarId in depMVarIds do\n      copyExprMVar s depMVarId\n  let assignment? \u2190 s.runMetaM' do\n    if let (some e) \u2190 getExprMVarAssignment? mvarId then\n      return some $ Sum.inl $ \u2190 instantiateMVars e\n    else if let (some d) \u2190 getDelayedMVarAssignment? mvarId then\n      return some $ Sum.inr d\n    else\n      return none\n  match assignment? with\n  | some (Sum.inl e) =>\n    for mvarId in \u2190 getMVars e do\n      copyExprMVar s mvarId\n    aesop_trace[extraction] \"assign  ?{mvarId.name} := {toString e}\"\n    mvarId.assign e\n  | some (Sum.inr d) =>\n    for mvarId in \u2190 getMVars (mkMVar d.mvarIdPending) do\n      copyExprMVar s mvarId\n    aesop_trace[extraction] \"dassign ?{mvarId.name} := {d.fvars} => {d.mvarIdPending.name}\"\n    mvarId.delayedAssign d\n  | none => return", "start": [87, 1], "end": [119, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.visitGoal", "code": "private def visitGoal (g : Goal) : MetaM (Option (MVarId \u00d7 Array RappRef)) := do\n  aesop_trace[extraction] \"visiting G{g.id}\"\n  match g.normalizationState with\n  | NormalizationState.notNormal => throwPRError\n    \"goal {g.id} was not normalised.\"\n  | NormalizationState.normal postNormGoal postState _ =>\n    copyExprMVar postState g.preNormGoal\n    return (postNormGoal, g.children)\n  | NormalizationState.provenByNormalization postState _ =>\n    copyExprMVar postState g.preNormGoal\n    return none", "start": [123, 1], "end": [133, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.visitRapp", "code": "private def visitRapp (parentEnv : Environment) (parentGoal : MVarId) (r : Rapp) :\n    MetaM (Array MVarClusterRef \u00d7 Environment) := do\n  aesop_trace[extraction] \"visiting R{r.id}\"\n  let newEnv := r.metaState.core.env\n  copyNewDeclarations parentEnv newEnv\n  copyMatchEqnsExtState parentEnv newEnv\n  copyExprMVar r.metaState parentGoal\n  for m in r.assignedMVars do\n    copyExprMVar r.metaState m\n  return (r.children, newEnv)", "start": [135, 1], "end": [144, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.extractProofGoal", "code": "private partial def extractProofGoal (parentEnv : Environment) (g : Goal) :\n      MetaM Unit := do\n    let (some (postNormGoal, children)) \u2190 visitGoal g\n      | return\n    let rref? \u2190 children.findM? \u03bb rref => return (\u2190 rref.get).state.isProven\n    let (some rref) := rref? | throwPRError\n      \"goal {g.id} does not have a proven rapp.\"\n    extractProofRapp parentEnv postNormGoal (\u2190 rref.get)", "start": [147, 3], "end": [154, 57], "kind": "commanddeclaration"}, {"full_name": "Aesop.extractProofRapp", "code": "private partial def extractProofRapp (parentEnv : Environment)\n      (parentGoal : MVarId) (r : Rapp) : MetaM Unit := do\n    let (children, newEnv) \u2190 visitRapp parentEnv parentGoal r\n    children.forM \u03bb cref => do extractProofMVarCluster newEnv (\u2190 cref.get)", "start": [156, 3], "end": [159, 75], "kind": "commanddeclaration"}, {"full_name": "Aesop.extractProofMVarCluster", "code": "private partial def extractProofMVarCluster (parentEnv : Environment)\n      (c : MVarCluster) : MetaM Unit := do\n    let gref? \u2190 c.goals.findM? \u03bb gref => return (\u2190 gref.get).state.isProven\n    let (some gref) := gref? | throwPRError\n      \"an mvar cluster does not contain a proven goal (candidate goals: {\u2190 c.goals.mapM \u03bb gref => return (\u2190 gref.get).id}).\"\n    extractProofGoal parentEnv (\u2190 gref.get)", "start": [161, 3], "end": [166, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.SafePrefixState", "code": "private structure SafePrefixState where\n  goals : Array MVarId := #[]", "start": [169, 1], "end": [170, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.SafePrefixM", "code": "private abbrev SafePrefixM := StateRefT SafePrefixState MetaM", "start": [172, 1], "end": [172, 62], "kind": "commanddeclaration"}, {"full_name": "Aesop.extractSafePrefixGoal", "code": "private partial def extractSafePrefixGoal (parentEnv : Environment)\n      (g : Goal) : SafePrefixM Unit := do\n    let (some (postNormGoal, _)) \u2190 visitGoal g\n      | return\n    let safeRapps \u2190 g.safeRapps\n    if safeRapps.size > 1 then\n      throwError \"aesop: internal error: goal {g.id} has multiple safe rapps\"\n    if h : 0 < safeRapps.size then\n      extractSafePrefixRapp parentEnv postNormGoal (\u2190 safeRapps[0].get)\n    else\n      modify \u03bb s => { s with goals := s.goals.push postNormGoal }", "start": [175, 3], "end": [185, 66], "kind": "commanddeclaration"}, {"full_name": "Aesop.extractSafePrefixRapp", "code": "private partial def extractSafePrefixRapp (parentEnv : Environment)\n      (parentGoal : MVarId) (r : Rapp) : SafePrefixM Unit := do\n    let (children, newEnv) \u2190 visitRapp parentEnv parentGoal r\n    children.forM \u03bb cref => do extractSafePrefixMVarCluster newEnv (\u2190 cref.get)", "start": [187, 3], "end": [190, 80], "kind": "commanddeclaration"}, {"full_name": "Aesop.extractSafePrefixMVarCluster", "code": "private partial def extractSafePrefixMVarCluster (parentEnv : Environment)\n      (c : MVarCluster) : SafePrefixM Unit :=\n    c.goals.forM \u03bb gref => do extractSafePrefixGoal parentEnv (\u2190 gref.get)", "start": [192, 3], "end": [194, 75], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.extractProof", "code": "def Goal.extractProof (root : Goal) : MetaM Unit := do\n  extractProofGoal (\u2190 getEnv) root", "start": [197, 1], "end": [198, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.extractProof", "code": "def extractProof : TreeM Unit := do\n  (\u2190 (\u2190 getRootGoal).get).extractProof", "start": [200, 1], "end": [201, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.Goal.extractSafePrefix", "code": "def Goal.extractSafePrefix (root : Goal) : MetaM (Array MVarId) := do\n  let (_, state) \u2190 extractSafePrefixGoal (\u2190 getEnv) root |>.run {}\n  return state.goals", "start": [203, 1], "end": [205, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.extractSafePrefix", "code": "def extractSafePrefix : TreeM (Array MVarId) := do\n  (\u2190 (\u2190 getRootGoal).get).extractSafePrefix", "start": [207, 1], "end": [208, 44], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Builder.lean", "imports": ["lake-packages/aesop/Aesop/Builder/Cases.lean", "lake-packages/aesop/Aesop/Builder/Constructors.lean", "lake-packages/aesop/Aesop/Builder/NormSimp.lean", "lake-packages/aesop/Aesop/Builder/Basic.lean", "lake-packages/aesop/Aesop/Builder/Apply.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Builder/Unfold.lean", "lake-packages/aesop/Aesop/Builder/Default.lean", "lake-packages/aesop/Aesop/Builder/Tactic.lean", "lake-packages/aesop/Aesop/Builder/Forward.lean"], "premises": []}
{"path": "Mathlib/Logic/Basic.lean", "imports": ["Mathlib/Init/Algebra/Classes.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Logic.lean", "lake-packages/std/Std/Util/LibraryNote.lean", "lake-packages/std/Std/Tactic/Lint/Basic.lean", "Mathlib/Init/Function.lean", "Mathlib/Tactic/Basic.lean", "Mathlib/Tactic/LeftRight.lean"], "premises": [{"full_name": "hidden", "code": "@[reducible] def hidden {\u03b1 : Sort*} {a : \u03b1} := a", "start": [45, 1], "end": [48, 49], "kind": "commanddeclaration"}, {"full_name": "decidableEq_of_subsingleton", "code": "instance (priority := 10) decidableEq_of_subsingleton [Subsingleton \u03b1] : DecidableEq \u03b1 :=\n  fun a b \u21a6 isTrue (Subsingleton.elim a b)", "start": [51, 1], "end": [52, 43], "kind": "commanddeclaration"}, {"full_name": "congr_heq", "code": "theorem congr_heq {\u03b1 \u03b2 \u03b3 : Sort _} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} {x : \u03b1} {y : \u03b2}\n    (h\u2081 : HEq f g) (h\u2082 : HEq x y) : f x = g y", "start": [60, 1], "end": [62, 26], "kind": "commanddeclaration"}, {"full_name": "congr_arg_heq", "code": "theorem congr_arg_heq {\u03b1} {\u03b2 : \u03b1 \u2192 Sort*} (f : \u2200 a, \u03b2 a) :\n    \u2200 {a\u2081 a\u2082 : \u03b1}, a\u2081 = a\u2082 \u2192 HEq (f a\u2081) (f a\u2082)", "start": [65, 1], "end": [67, 25], "kind": "commanddeclaration"}, {"full_name": "ULift.down_injective", "code": "theorem ULift.down_injective {\u03b1 : Sort _} : Function.Injective (@ULift.down \u03b1)", "start": [70, 1], "end": [71, 28], "kind": "commanddeclaration"}, {"full_name": "ULift.down_inj", "code": "@[simp] theorem ULift.down_inj {\u03b1 : Sort _} {a b : ULift \u03b1} : a.down = b.down \u2194 a = b", "start": [74, 1], "end": [75, 54], "kind": "commanddeclaration"}, {"full_name": "PLift.down_injective", "code": "theorem PLift.down_injective {\u03b1 : Sort*} : Function.Injective (@PLift.down \u03b1)", "start": [78, 1], "end": [79, 28], "kind": "commanddeclaration"}, {"full_name": "PLift.down_inj", "code": "@[simp] theorem PLift.down_inj {\u03b1 : Sort*} {a b : PLift \u03b1} : a.down = b.down \u2194 a = b", "start": [82, 1], "end": [83, 54], "kind": "commanddeclaration"}, {"full_name": "eq_iff_eq_cancel_left", "code": "@[simp] theorem eq_iff_eq_cancel_left {b c : \u03b1} : (\u2200 {a}, a = b \u2194 a = c) \u2194 b = c", "start": [86, 1], "end": [87, 45], "kind": "commanddeclaration"}, {"full_name": "eq_iff_eq_cancel_right", "code": "@[simp] theorem eq_iff_eq_cancel_right {a b : \u03b1} : (\u2200 {c}, a = c \u2194 b = c) \u2194 a = b", "start": [90, 1], "end": [91, 43], "kind": "commanddeclaration"}, {"full_name": "ne_and_eq_iff_right", "code": "lemma ne_and_eq_iff_right {\u03b1 : Sort*} {a b c : \u03b1} (h : b \u2260 c) : a \u2260 b \u2227 a = c \u2194 a = c :=\n  and_iff_right_of_imp (fun h2 => h2.symm \u25b8 h.symm)", "start": [94, 1], "end": [95, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Fact", "code": "class Fact (p : Prop) : Prop where\n  \n  out : p", "start": [98, 1], "end": [118, 10], "kind": "commanddeclaration"}, {"full_name": "Fact.elim", "code": "theorem Fact.elim {p : Prop} (h : Fact p) : p", "start": [127, 1], "end": [127, 53], "kind": "commanddeclaration"}, {"full_name": "fact_iff", "code": "theorem fact_iff {p : Prop} : Fact p \u2194 p", "start": [128, 1], "end": [128, 71], "kind": "commanddeclaration"}, {"full_name": "Function.swap\u2082", "code": "@[reducible] def Function.swap\u2082 {\u03ba\u2081 : \u03b9\u2081 \u2192 Sort*} {\u03ba\u2082 : \u03b9\u2082 \u2192 Sort*}\n    {\u03c6 : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 Sort*} (f : \u2200 i\u2081 j\u2081 i\u2082 j\u2082, \u03c6 i\u2081 j\u2081 i\u2082 j\u2082)\n    (i\u2082 j\u2082 i\u2081 j\u2081) : \u03c6 i\u2081 j\u2081 i\u2082 j\u2082 := f i\u2081 j\u2081 i\u2082 j\u2082", "start": [132, 1], "end": [135, 51], "kind": "commanddeclaration"}, {"full_name": "Iff.imp", "code": "alias Iff.imp := imp_congr", "start": [165, 1], "end": [165, 27], "kind": "stdtacticaliasalias"}, {"full_name": "eq_true_eq_id", "code": "@[simp] theorem eq_true_eq_id : Eq True = id", "start": [168, 1], "end": [169, 53], "kind": "commanddeclaration"}, {"full_name": "imp_iff_right_iff", "code": "@[simp] theorem imp_iff_right_iff : (a \u2192 b \u2194 b) \u2194 a \u2228 b", "start": [176, 1], "end": [176, 87], "kind": "commanddeclaration"}, {"full_name": "and_or_imp", "code": "@[simp] theorem and_or_imp : a \u2227 b \u2228 (a \u2192 c) \u2194 a \u2192 b \u2228 c", "start": [179, 1], "end": [179, 81], "kind": "commanddeclaration"}, {"full_name": "Function.mt", "code": "protected theorem Function.mt : (a \u2192 b) \u2192 \u00acb \u2192 \u00aca", "start": [182, 1], "end": [183, 56], "kind": "commanddeclaration"}, {"full_name": "dec_em", "code": "alias dec_em := Decidable.em", "start": [188, 1], "end": [188, 29], "kind": "stdtacticaliasalias"}, {"full_name": "dec_em'", "code": "theorem dec_em' (p : Prop) [Decidable p] : \u00acp \u2228 p", "start": [191, 1], "end": [191, 69], "kind": "commanddeclaration"}, {"full_name": "em", "code": "alias em := Classical.em", "start": [194, 1], "end": [194, 25], "kind": "stdtacticaliasalias"}, {"full_name": "em'", "code": "theorem em' (p : Prop) : \u00acp \u2228 p", "start": [197, 1], "end": [197, 47], "kind": "commanddeclaration"}, {"full_name": "or_not", "code": "theorem or_not {p : Prop} : p \u2228 \u00acp", "start": [200, 1], "end": [200, 43], "kind": "commanddeclaration"}, {"full_name": "Decidable.eq_or_ne", "code": "theorem Decidable.eq_or_ne (x y : \u03b1) [Decidable (x = y)] : x = y \u2228 x \u2260 y", "start": [203, 1], "end": [203, 92], "kind": "commanddeclaration"}, {"full_name": "Decidable.ne_or_eq", "code": "theorem Decidable.ne_or_eq (x y : \u03b1) [Decidable (x = y)] : x \u2260 y \u2228 x = y", "start": [206, 1], "end": [206, 93], "kind": "commanddeclaration"}, {"full_name": "eq_or_ne", "code": "theorem eq_or_ne (x y : \u03b1) : x = y \u2228 x \u2260 y", "start": [209, 1], "end": [209, 58], "kind": "commanddeclaration"}, {"full_name": "ne_or_eq", "code": "theorem ne_or_eq (x y : \u03b1) : x \u2260 y \u2228 x = y", "start": [212, 1], "end": [212, 59], "kind": "commanddeclaration"}, {"full_name": "by_contradiction", "code": "theorem by_contradiction : (\u00acp \u2192 False) \u2192 p", "start": [215, 1], "end": [215, 74], "kind": "commanddeclaration"}, {"full_name": "by_cases", "code": "theorem by_cases {q : Prop} (hpq : p \u2192 q) (hnpq : \u00acp \u2192 q) : q", "start": [219, 1], "end": [220, 35], "kind": "commanddeclaration"}, {"full_name": "by_contra", "code": "alias by_contra := by_contradiction", "start": [223, 1], "end": [223, 36], "kind": "stdtacticaliasalias"}, {"full_name": "of_not_not", "code": "theorem of_not_not : \u00ac\u00aca \u2192 a", "start": [250, 1], "end": [250, 42], "kind": "commanddeclaration"}, {"full_name": "not_ne_iff", "code": "theorem not_ne_iff : \u00aca \u2260 b \u2194 a = b", "start": [253, 1], "end": [253, 47], "kind": "commanddeclaration"}, {"full_name": "of_not_imp", "code": "theorem of_not_imp {a b : Prop} : \u00ac(a \u2192 b) \u2192 a", "start": [256, 1], "end": [256, 71], "kind": "commanddeclaration"}, {"full_name": "Not.decidable_imp_symm", "code": "alias Not.decidable_imp_symm := Decidable.not_imp_symm", "start": [259, 1], "end": [259, 55], "kind": "stdtacticaliasalias"}, {"full_name": "Not.imp_symm", "code": "theorem Not.imp_symm : (\u00aca \u2192 b) \u2192 \u00acb \u2192 a", "start": [262, 1], "end": [262, 67], "kind": "commanddeclaration"}, {"full_name": "not_imp_comm", "code": "theorem not_imp_comm : \u00aca \u2192 b \u2194 \u00acb \u2192 a", "start": [265, 1], "end": [265, 65], "kind": "commanddeclaration"}, {"full_name": "not_imp_self", "code": "@[simp] theorem not_imp_self : \u00aca \u2192 a \u2194 a", "start": [268, 1], "end": [268, 68], "kind": "commanddeclaration"}, {"full_name": "Imp.swap", "code": "theorem Imp.swap : a \u2192 b \u2192 c \u2194 b \u2192 a \u2192 c", "start": [271, 1], "end": [271, 75], "kind": "commanddeclaration"}, {"full_name": "Iff.not", "code": "alias Iff.not := not_congr", "start": [274, 1], "end": [274, 27], "kind": "stdtacticaliasalias"}, {"full_name": "Iff.not_left", "code": "theorem Iff.not_left (h : a \u2194 \u00acb) : \u00aca \u2194 b", "start": [277, 1], "end": [277, 66], "kind": "commanddeclaration"}, {"full_name": "Iff.not_right", "code": "theorem Iff.not_right (h : \u00aca \u2194 b) : a \u2194 \u00acb", "start": [280, 1], "end": [280, 72], "kind": "commanddeclaration"}, {"full_name": "xor_true", "code": "@[simp] theorem xor_true : Xor' True = Not", "start": [285, 1], "end": [285, 61], "kind": "commanddeclaration"}, {"full_name": "xor_false", "code": "@[simp] theorem xor_false : Xor' False = id", "start": [288, 1], "end": [288, 67], "kind": "commanddeclaration"}, {"full_name": "xor_comm", "code": "theorem xor_comm (a b) : Xor' a b = Xor' b a", "start": [291, 1], "end": [291, 82], "kind": "commanddeclaration"}, {"full_name": "xor_self", "code": "@[simp] theorem xor_self (a : Prop) : Xor' a a = False", "start": [296, 1], "end": [296, 73], "kind": "commanddeclaration"}, {"full_name": "xor_not_left", "code": "@[simp] theorem xor_not_left : Xor' (\u00aca) b \u2194 (a \u2194 b)", "start": [299, 1], "end": [299, 83], "kind": "commanddeclaration"}, {"full_name": "xor_not_right", "code": "@[simp] theorem xor_not_right : Xor' a (\u00acb) \u2194 (a \u2194 b)", "start": [302, 1], "end": [302, 84], "kind": "commanddeclaration"}, {"full_name": "xor_not_not", "code": "theorem xor_not_not : Xor' (\u00aca) (\u00acb) \u2194 Xor' a b", "start": [305, 1], "end": [305, 85], "kind": "commanddeclaration"}, {"full_name": "Xor'.or", "code": "protected theorem Xor'.or (h : Xor' a b) : a \u2228 b", "start": [308, 1], "end": [308, 76], "kind": "commanddeclaration"}, {"full_name": "Iff.and", "code": "alias Iff.and := and_congr", "start": [313, 1], "end": [313, 27], "kind": "stdtacticaliasalias"}, {"full_name": "And.rotate", "code": "alias \u27e8And.rotate, _\u27e9 := and_rotate", "start": [320, 1], "end": [320, 36], "kind": "stdtacticaliasaliaslr"}, {"full_name": "and_symm_right", "code": "theorem and_symm_right (a b : \u03b1) (p : Prop) : p \u2227 a = b \u2194 p \u2227 b = a", "start": [325, 1], "end": [325, 89], "kind": "commanddeclaration"}, {"full_name": "and_symm_left", "code": "theorem and_symm_left (a b : \u03b1) (p : Prop) : a = b \u2227 p \u2194 b = a \u2227 p", "start": [326, 1], "end": [326, 88], "kind": "commanddeclaration"}, {"full_name": "Iff.or", "code": "alias Iff.or := or_congr", "start": [330, 1], "end": [330, 25], "kind": "stdtacticaliasalias"}, {"full_name": "Or.rotate", "code": "alias \u27e8Or.rotate, _\u27e9 := or_rotate", "start": [335, 1], "end": [335, 34], "kind": "stdtacticaliasaliaslr"}, {"full_name": "or_of_or_of_imp_of_imp", "code": "@[deprecated Or.imp]\ntheorem or_of_or_of_imp_of_imp (h\u2081 : a \u2228 b) (h\u2082 : a \u2192 c) (h\u2083 : b \u2192 d) : c \u2228 d", "start": [338, 1], "end": [339, 97], "kind": "commanddeclaration"}, {"full_name": "or_of_or_of_imp_left", "code": "@[deprecated Or.imp_left]\ntheorem or_of_or_of_imp_left (h\u2081 : a \u2228 c) (h : a \u2192 b) : b \u2228 c", "start": [342, 1], "end": [343, 82], "kind": "commanddeclaration"}, {"full_name": "or_of_or_of_imp_right", "code": "@[deprecated Or.imp_right]\ntheorem or_of_or_of_imp_right (h\u2081 : c \u2228 a) (h : a \u2192 b) : c \u2228 b", "start": [346, 1], "end": [347, 84], "kind": "commanddeclaration"}, {"full_name": "Or.elim3", "code": "theorem Or.elim3 {d : Prop} (h : a \u2228 b \u2228 c) (ha : a \u2192 d) (hb : b \u2192 d) (hc : c \u2192 d) : d", "start": [350, 1], "end": [351, 41], "kind": "commanddeclaration"}, {"full_name": "Or.imp3", "code": "theorem Or.imp3 (had : a \u2192 d) (hbe : b \u2192 e) (hcf : c \u2192 f) : a \u2228 b \u2228 c \u2192 d \u2228 e \u2228 f", "start": [354, 1], "end": [355, 31], "kind": "commanddeclaration"}, {"full_name": "or_iff_not_imp_left", "code": "theorem or_iff_not_imp_left : a \u2228 b \u2194 \u00aca \u2192 b", "start": [360, 1], "end": [360, 78], "kind": "commanddeclaration"}, {"full_name": "or_iff_not_imp_right", "code": "theorem or_iff_not_imp_right : a \u2228 b \u2194 \u00acb \u2192 a", "start": [363, 1], "end": [363, 80], "kind": "commanddeclaration"}, {"full_name": "not_or_of_imp", "code": "theorem not_or_of_imp : (a \u2192 b) \u2192 \u00aca \u2228 b", "start": [366, 1], "end": [366, 68], "kind": "commanddeclaration"}, {"full_name": "Decidable.or_not_of_imp", "code": "protected theorem Decidable.or_not_of_imp [Decidable a] (h : a \u2192 b) : b \u2228 \u00aca", "start": [370, 1], "end": [371, 29], "kind": "commanddeclaration"}, {"full_name": "or_not_of_imp", "code": "theorem or_not_of_imp : (a \u2192 b) \u2192 b \u2228 \u00aca", "start": [374, 1], "end": [374, 68], "kind": "commanddeclaration"}, {"full_name": "imp_iff_not_or", "code": "theorem imp_iff_not_or : a \u2192 b \u2194 \u00aca \u2228 b", "start": [377, 1], "end": [377, 68], "kind": "commanddeclaration"}, {"full_name": "imp_iff_or_not", "code": "theorem imp_iff_or_not : b \u2192 a \u2194 a \u2228 \u00acb", "start": [380, 1], "end": [380, 68], "kind": "commanddeclaration"}, {"full_name": "not_imp_not", "code": "theorem not_imp_not : \u00aca \u2192 \u00acb \u2194 b \u2192 a", "start": [383, 1], "end": [383, 63], "kind": "commanddeclaration"}, {"full_name": "imp_and_neg_imp_iff", "code": "@[simp]\ntheorem imp_and_neg_imp_iff (p q : Prop) : (p \u2192 q) \u2227 (\u00acp \u2192 q) \u2194 q", "start": [386, 1], "end": [388, 94], "kind": "commanddeclaration"}, {"full_name": "Function.mtr", "code": "protected theorem Function.mtr : (\u00aca \u2192 \u00acb) \u2192 b \u2192 a", "start": [390, 1], "end": [391, 69], "kind": "commanddeclaration"}, {"full_name": "or_congr_left'", "code": "theorem or_congr_left' (h : \u00acc \u2192 (a \u2194 b)) : a \u2228 c \u2194 b \u2228 c", "start": [399, 1], "end": [399, 88], "kind": "commanddeclaration"}, {"full_name": "or_congr_right'", "code": "theorem or_congr_right' (h : \u00aca \u2192 (b \u2194 c)) : a \u2228 b \u2194 a \u2228 c", "start": [402, 1], "end": [402, 90], "kind": "commanddeclaration"}, {"full_name": "Iff.iff", "code": "alias Iff.iff := iff_congr", "start": [416, 1], "end": [416, 27], "kind": "stdtacticaliasalias"}, {"full_name": "iff_mpr_iff_true_intro", "code": "theorem iff_mpr_iff_true_intro (h : P) : Iff.mpr (iff_true_intro h) True.intro = h", "start": [420, 1], "end": [420, 90], "kind": "commanddeclaration"}, {"full_name": "imp_or", "code": "theorem imp_or {a b c : Prop} : a \u2192 b \u2228 c \u2194 (a \u2192 b) \u2228 (a \u2192 c)", "start": [425, 1], "end": [425, 82], "kind": "commanddeclaration"}, {"full_name": "imp_or'", "code": "theorem imp_or' : a \u2192 b \u2228 c \u2194 (a \u2192 b) \u2228 (a \u2192 c)", "start": [430, 1], "end": [430, 69], "kind": "commanddeclaration"}, {"full_name": "not_imp", "code": "theorem not_imp : \u00ac(a \u2192 b) \u2194 a \u2227 \u00acb", "start": [433, 1], "end": [433, 57], "kind": "commanddeclaration"}, {"full_name": "peirce", "code": "theorem peirce (a b : Prop) : ((a \u2192 b) \u2192 a) \u2192 a", "start": [436, 1], "end": [436, 72], "kind": "commanddeclaration"}, {"full_name": "not_iff_not", "code": "theorem not_iff_not : (\u00aca \u2194 \u00acb) \u2194 (a \u2194 b)", "start": [439, 1], "end": [439, 67], "kind": "commanddeclaration"}, {"full_name": "not_iff_comm", "code": "theorem not_iff_comm : (\u00aca \u2194 b) \u2194 (\u00acb \u2194 a)", "start": [442, 1], "end": [442, 69], "kind": "commanddeclaration"}, {"full_name": "not_iff", "code": "theorem not_iff : \u00ac(a \u2194 b) \u2194 (\u00aca \u2194 b)", "start": [445, 1], "end": [445, 59], "kind": "commanddeclaration"}, {"full_name": "iff_not_comm", "code": "theorem iff_not_comm : (a \u2194 \u00acb) \u2194 (b \u2194 \u00aca)", "start": [448, 1], "end": [448, 69], "kind": "commanddeclaration"}, {"full_name": "iff_iff_and_or_not_and_not", "code": "theorem iff_iff_and_or_not_and_not : (a \u2194 b) \u2194 a \u2227 b \u2228 \u00aca \u2227 \u00acb", "start": [451, 1], "end": [452, 39], "kind": "commanddeclaration"}, {"full_name": "iff_iff_not_or_and_or_not", "code": "theorem iff_iff_not_or_and_or_not : (a \u2194 b) \u2194 (\u00aca \u2228 b) \u2227 (a \u2228 \u00acb)", "start": [455, 1], "end": [456, 38], "kind": "commanddeclaration"}, {"full_name": "not_and_not_right", "code": "theorem not_and_not_right : \u00ac(a \u2227 \u00acb) \u2194 a \u2192 b", "start": [459, 1], "end": [459, 77], "kind": "commanddeclaration"}, {"full_name": "not_and_or", "code": "theorem not_and_or : \u00ac(a \u2227 b) \u2194 \u00aca \u2228 \u00acb", "start": [471, 1], "end": [473, 61], "kind": "commanddeclaration"}, {"full_name": "or_iff_not_and_not", "code": "theorem or_iff_not_and_not : a \u2228 b \u2194 \u00ac(\u00aca \u2227 \u00acb)", "start": [478, 1], "end": [478, 80], "kind": "commanddeclaration"}, {"full_name": "and_iff_not_or_not", "code": "theorem and_iff_not_or_not : a \u2227 b \u2194 \u00ac(\u00aca \u2228 \u00acb)", "start": [481, 1], "end": [481, 80], "kind": "commanddeclaration"}, {"full_name": "not_xor", "code": "@[simp] theorem not_xor (P Q : Prop) : \u00acXor' P Q \u2194 (P \u2194 Q)", "start": [484, 1], "end": [485, 76], "kind": "commanddeclaration"}, {"full_name": "xor_iff_not_iff", "code": "theorem xor_iff_not_iff (P Q : Prop) : Xor' P Q \u2194 \u00ac (P \u2194 Q)", "start": [488, 1], "end": [488, 87], "kind": "commanddeclaration"}, {"full_name": "xor_iff_iff_not", "code": "theorem xor_iff_iff_not : Xor' a b \u2194 (a \u2194 \u00acb)", "start": [491, 1], "end": [491, 92], "kind": "commanddeclaration"}, {"full_name": "xor_iff_not_iff'", "code": "theorem xor_iff_not_iff' : Xor' a b \u2194 (\u00aca \u2194 b)", "start": [494, 1], "end": [494, 94], "kind": "commanddeclaration"}, {"full_name": "Membership.mem.ne_of_not_mem", "code": "alias Membership.mem.ne_of_not_mem := ne_of_mem_of_not_mem", "start": [501, 1], "end": [501, 59], "kind": "stdtacticaliasalias"}, {"full_name": "Membership.mem.ne_of_not_mem'", "code": "alias Membership.mem.ne_of_not_mem' := ne_of_mem_of_not_mem'", "start": [502, 1], "end": [502, 61], "kind": "stdtacticaliasalias"}, {"full_name": "ball_cond_comm", "code": "theorem ball_cond_comm {\u03b1} {s : \u03b1 \u2192 Prop} {p : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200 a, s a \u2192 \u2200 b, s b \u2192 p a b) \u2194 \u2200 a b, s a \u2192 s b \u2192 p a b", "start": [510, 1], "end": [512, 65], "kind": "commanddeclaration"}, {"full_name": "ball_mem_comm", "code": "theorem ball_mem_comm {\u03b1 \u03b2} [Membership \u03b1 \u03b2] {s : \u03b2} {p : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200 a (_ : a \u2208 s) b (_ : b \u2208 s), p a b) \u2194 \u2200 a b, a \u2208 s \u2192 b \u2208 s \u2192 p a b", "start": [515, 1], "end": [517, 17], "kind": "commanddeclaration"}, {"full_name": "ne_of_apply_ne", "code": "theorem ne_of_apply_ne {\u03b1 \u03b2 : Sort*} (f : \u03b1 \u2192 \u03b2) {x y : \u03b1} (h : f x \u2260 f y) : x \u2260 y", "start": [520, 1], "end": [521, 36], "kind": "commanddeclaration"}, {"full_name": "eq_equivalence", "code": "theorem eq_equivalence : Equivalence (@Eq \u03b1)", "start": [524, 1], "end": [525, 37], "kind": "commanddeclaration"}, {"full_name": "eq_mp_eq_cast", "code": "@[simp] theorem eq_mp_eq_cast (h : \u03b1 = \u03b2) : Eq.mp h = cast h", "start": [528, 1], "end": [528, 68], "kind": "commanddeclaration"}, {"full_name": "eq_mpr_eq_cast", "code": "@[simp] theorem eq_mpr_eq_cast (h : \u03b1 = \u03b2) : Eq.mpr h = cast h.symm", "start": [531, 1], "end": [531, 75], "kind": "commanddeclaration"}, {"full_name": "cast_cast", "code": "@[simp] theorem cast_cast : \u2200 (ha : \u03b1 = \u03b2) (hb : \u03b2 = \u03b3) (a : \u03b1),\n    cast hb (cast ha a) = cast (ha.trans hb) a", "start": [534, 1], "end": [536, 23], "kind": "commanddeclaration"}, {"full_name": "congr_refl_left", "code": "theorem congr_refl_left (f : \u03b1 \u2192 \u03b2) {a b : \u03b1} (h : a = b) :\n    congr (Eq.refl f) h = congr_arg f h", "start": [540, 1], "end": [541, 47], "kind": "commanddeclaration"}, {"full_name": "congr_refl_right", "code": "theorem congr_refl_right {f g : \u03b1 \u2192 \u03b2} (h : f = g) (a : \u03b1) :\n    congr h (Eq.refl a) = congr_fun h a", "start": [545, 1], "end": [546, 47], "kind": "commanddeclaration"}, {"full_name": "congr_arg_refl", "code": "theorem congr_arg_refl (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : congr_arg f (Eq.refl a) = Eq.refl (f a)", "start": [550, 1], "end": [550, 92], "kind": "commanddeclaration"}, {"full_name": "congr_fun_rfl", "code": "theorem congr_fun_rfl (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : congr_fun (Eq.refl f) a = Eq.refl (f a)", "start": [554, 1], "end": [554, 91], "kind": "commanddeclaration"}, {"full_name": "congr_fun_congr_arg", "code": "theorem congr_fun_congr_arg (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {a a' : \u03b1} (p : a = a') (b : \u03b2) :\n    congr_fun (congr_arg f p) b = congr_arg (fun a \u21a6 f a b) p", "start": [558, 1], "end": [559, 69], "kind": "commanddeclaration"}, {"full_name": "heq_of_cast_eq", "code": "theorem heq_of_cast_eq : \u2200 (e : \u03b1 = \u03b2) (_ : cast e a = a'), HEq a a'", "start": [562, 1], "end": [563, 38], "kind": "commanddeclaration"}, {"full_name": "cast_eq_iff_heq", "code": "theorem cast_eq_iff_heq : cast e a = a' \u2194 HEq a a'", "start": [566, 1], "end": [567, 46], "kind": "commanddeclaration"}, {"full_name": "Eq.rec_eq_cast", "code": "theorem Eq.rec_eq_cast {\u03b1 : Sort _} {P : \u03b1 \u2192 Sort _} {x y : \u03b1} (h : x = y) (z : P x) :\n    h \u25b8 z = cast (congr_arg P h) z", "start": [570, 1], "end": [571, 58], "kind": "commanddeclaration"}, {"full_name": "eqRec_heq'", "code": "theorem eqRec_heq' {\u03b1 : Sort u_1} {a' : \u03b1} {motive : (a : \u03b1) \u2192 a' = a \u2192 Sort u}\n    (p : motive a' (rfl : a' = a')) {a : \u03b1} (t : a' = a) :\n    HEq (@Eq.rec \u03b1 a' motive p a t) p", "start": [574, 1], "end": [577, 18], "kind": "commanddeclaration"}, {"full_name": "rec_heq_of_heq", "code": "theorem rec_heq_of_heq {C : \u03b1 \u2192 Sort*} {x : C a} {y : \u03b2} (e : a = b) (h : HEq x y) :\n    HEq (e \u25b8 x) y", "start": [579, 1], "end": [580, 41], "kind": "commanddeclaration"}, {"full_name": "rec_heq_iff_heq", "code": "theorem rec_heq_iff_heq {C : \u03b1 \u2192 Sort*} {x : C a} {y : \u03b2} {e : a = b} :\n    HEq (e \u25b8 x) y \u2194 HEq x y", "start": [583, 1], "end": [584, 47], "kind": "commanddeclaration"}, {"full_name": "heq_rec_iff_heq", "code": "theorem heq_rec_iff_heq {C : \u03b1 \u2192 Sort*} {x : \u03b2} {y : C a} {e : a = b} :\n    HEq x (e \u25b8 y) \u2194 HEq x y", "start": [587, 1], "end": [588, 47], "kind": "commanddeclaration"}, {"full_name": "Eq.congr", "code": "protected theorem Eq.congr (h\u2081 : x\u2081 = y\u2081) (h\u2082 : x\u2082 = y\u2082) : x\u2081 = x\u2082 \u2194 y\u2081 = y\u2082", "start": [591, 1], "end": [592, 26], "kind": "commanddeclaration"}, {"full_name": "Eq.congr_left", "code": "theorem Eq.congr_left {x y z : \u03b1} (h : x = y) : x = z \u2194 y = z", "start": [595, 1], "end": [595, 75], "kind": "commanddeclaration"}, {"full_name": "Eq.congr_right", "code": "theorem Eq.congr_right {x y z : \u03b1} (h : x = y) : z = x \u2194 z = y", "start": [598, 1], "end": [598, 76], "kind": "commanddeclaration"}, {"full_name": "congr_arg\u2082", "code": "alias congr_arg\u2082 := congrArg\u2082", "start": [601, 1], "end": [601, 30], "kind": "stdtacticaliasalias"}, {"full_name": "congr_fun\u2082", "code": "theorem congr_fun\u2082 {f g : \u2200 a b, \u03b3 a b} (h : f = g) (a : \u03b1) (b : \u03b2 a) : f a b = g a b", "start": [606, 1], "end": [607, 30], "kind": "commanddeclaration"}, {"full_name": "congr_fun\u2083", "code": "theorem congr_fun\u2083 {f g : \u2200 a b c, \u03b4 a b c} (h : f = g) (a : \u03b1) (b : \u03b2 a) (c : \u03b3 a b) :\n    f a b c = g a b c", "start": [610, 1], "end": [612, 33], "kind": "commanddeclaration"}, {"full_name": "funext\u2082", "code": "theorem funext\u2082 {f g : \u2200 a b, \u03b3 a b} (h : \u2200 a b, f a b = g a b) : f = g", "start": [615, 1], "end": [616, 31], "kind": "commanddeclaration"}, {"full_name": "funext\u2083", "code": "theorem funext\u2083 {f g : \u2200 a b c, \u03b4 a b c} (h : \u2200 a b c, f a b c = g a b c) : f = g", "start": [619, 1], "end": [620, 32], "kind": "commanddeclaration"}, {"full_name": "pi_congr", "code": "theorem pi_congr {\u03b2' : \u03b1 \u2192 Sort _} (h : \u2200 a, \u03b2 a = \u03b2' a) : (\u2200 a, \u03b2 a) = \u2200 a, \u03b2' a", "start": [634, 1], "end": [635, 28], "kind": "commanddeclaration"}, {"full_name": "forall\u2082_imp", "code": "theorem forall\u2082_imp {p q : \u2200 a, \u03b2 a \u2192 Prop} (h : \u2200 a b, p a b \u2192 q a b) :\n    (\u2200 a b, p a b) \u2192 \u2200 a b, q a b", "start": [641, 1], "end": [643, 39], "kind": "commanddeclaration"}, {"full_name": "forall\u2083_imp", "code": "theorem forall\u2083_imp {p q : \u2200 a b, \u03b3 a b \u2192 Prop} (h : \u2200 a b c, p a b c \u2192 q a b c) :\n    (\u2200 a b c, p a b c) \u2192 \u2200 a b c, q a b c", "start": [646, 1], "end": [648, 40], "kind": "commanddeclaration"}, {"full_name": "Exists\u2082.imp", "code": "theorem Exists\u2082.imp {p q : \u2200 a, \u03b2 a \u2192 Prop} (h : \u2200 a b, p a b \u2192 q a b) :\n    (\u2203 a b, p a b) \u2192 \u2203 a b, q a b", "start": [651, 1], "end": [653, 39], "kind": "commanddeclaration"}, {"full_name": "Exists\u2083.imp", "code": "theorem Exists\u2083.imp {p q : \u2200 a b, \u03b3 a b \u2192 Prop} (h : \u2200 a b c, p a b c \u2192 q a b c) :\n    (\u2203 a b c, p a b c) \u2192 \u2203 a b c, q a b c", "start": [656, 1], "end": [658, 40], "kind": "commanddeclaration"}, {"full_name": "forall_swap", "code": "theorem forall_swap {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2200 x y, p x y) \u2194 \u2200 y x, p x y", "start": [667, 1], "end": [667, 87], "kind": "commanddeclaration"}, {"full_name": "forall\u2082_swap", "code": "theorem forall\u2082_swap {\u03ba\u2081 : \u03b9\u2081 \u2192 Sort*} {\u03ba\u2082 : \u03b9\u2082 \u2192 Sort*} {p : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 Prop} :\n    (\u2200 i\u2081 j\u2081 i\u2082 j\u2082, p i\u2081 j\u2081 i\u2082 j\u2082) \u2194 \u2200 i\u2082 j\u2082 i\u2081 j\u2081, p i\u2081 j\u2081 i\u2082 j\u2082", "start": [670, 1], "end": [671, 84], "kind": "commanddeclaration"}, {"full_name": "imp_forall_iff", "code": "theorem imp_forall_iff {\u03b1 : Type*} {p : Prop} {q : \u03b1 \u2192 Prop} : (p \u2192 \u2200 x, q x) \u2194 \u2200 x, p \u2192 q x", "start": [674, 1], "end": [677, 14], "kind": "commanddeclaration"}, {"full_name": "exists_swap", "code": "theorem exists_swap {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2203 x y, p x y) \u2194 \u2203 y x, p x y", "start": [680, 1], "end": [681, 57], "kind": "commanddeclaration"}, {"full_name": "not_exists_of_forall_not", "code": "alias \u27e8_, not_exists_of_forall_not\u27e9 := exists_imp", "start": [687, 1], "end": [687, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "not_forall_not", "code": "theorem not_forall_not : (\u00ac\u2200 x, \u00acp x) \u2194 \u2203 x, p x", "start": [700, 1], "end": [700, 77], "kind": "commanddeclaration"}, {"full_name": "forall_or_exists_not", "code": "lemma forall_or_exists_not (P : \u03b1 \u2192 Prop) : (\u2200 a, P a) \u2228 \u2203 a, \u00ac P a := by\n  rw [\u2190 not_forall]; exact em _", "start": [708, 1], "end": [709, 32], "kind": "mathlibtacticlemma"}, {"full_name": "exists_or_forall_not", "code": "lemma exists_or_forall_not (P : \u03b1 \u2192 Prop) : (\u2203 a, P a) \u2228 \u2200 a, \u00ac P a := by\n  rw [\u2190 not_exists]; exact em _", "start": [711, 1], "end": [712, 32], "kind": "mathlibtacticlemma"}, {"full_name": "forall_imp_iff_exists_imp", "code": "theorem forall_imp_iff_exists_imp [ha : Nonempty \u03b1] : (\u2200 x, p x) \u2192 b \u2194 \u2203 x, p x \u2192 b", "start": [714, 1], "end": [717, 81], "kind": "commanddeclaration"}, {"full_name": "forall_true_iff", "code": "@[mfld_simps]\ntheorem forall_true_iff : (\u03b1 \u2192 True) \u2194 True", "start": [720, 1], "end": [721, 62], "kind": "commanddeclaration"}, {"full_name": "forall_true_iff'", "code": "theorem forall_true_iff' (h : \u2200 a, p a \u2194 True) : (\u2200 a, p a) \u2194 True", "start": [726, 1], "end": [727, 43], "kind": "commanddeclaration"}, {"full_name": "forall\u2082_true_iff", "code": "theorem forall\u2082_true_iff {\u03b2 : \u03b1 \u2192 Sort*} : (\u2200 a, \u03b2 a \u2192 True) \u2194 True", "start": [731, 1], "end": [731, 79], "kind": "commanddeclaration"}, {"full_name": "forall\u2083_true_iff", "code": "theorem forall\u2083_true_iff {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*} :\n    (\u2200 (a) (b : \u03b2 a), \u03b3 a b \u2192 True) \u2194 True", "start": [735, 1], "end": [736, 54], "kind": "commanddeclaration"}, {"full_name": "exists_unique_iff_exists", "code": "@[simp] theorem exists_unique_iff_exists [Subsingleton \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2203! x, p x) \u2194 \u2203 x, p x", "start": [739, 1], "end": [741, 82], "kind": "commanddeclaration"}, {"full_name": "exists_unique_const", "code": "theorem exists_unique_const (\u03b1) [i : Nonempty \u03b1] [Subsingleton \u03b1] :\n    (\u2203! _ : \u03b1, b) \u2194 b", "start": [748, 1], "end": [749, 33], "kind": "commanddeclaration"}, {"full_name": "Decidable.and_forall_ne", "code": "theorem Decidable.and_forall_ne [DecidableEq \u03b1] (a : \u03b1) {p : \u03b1 \u2192 Prop} :\n    (p a \u2227 \u2200 b, b \u2260 a \u2192 p b) \u2194 \u2200 b, p b", "start": [758, 1], "end": [760, 85], "kind": "commanddeclaration"}, {"full_name": "and_forall_ne", "code": "theorem and_forall_ne (a : \u03b1) : (p a \u2227 \u2200 b, b \u2260 a \u2192 p b) \u2194 \u2200 b, p b", "start": [763, 1], "end": [764, 28], "kind": "commanddeclaration"}, {"full_name": "Ne.ne_or_ne", "code": "theorem Ne.ne_or_ne {x y : \u03b1} (z : \u03b1) (h : x \u2260 y) : x \u2260 z \u2228 y \u2260 z", "start": [767, 1], "end": [768, 48], "kind": "commanddeclaration"}, {"full_name": "exists_unique_eq", "code": "@[simp] theorem exists_unique_eq {a' : \u03b1} : \u2203! a, a = a'", "start": [771, 1], "end": [772, 70], "kind": "commanddeclaration"}, {"full_name": "exists_unique_eq'", "code": "@[simp] theorem exists_unique_eq' {a' : \u03b1} : \u2203! a, a' = a", "start": [775, 1], "end": [776, 61], "kind": "commanddeclaration"}, {"full_name": "exists_apply_eq_apply'", "code": "theorem exists_apply_eq_apply' (f : \u03b1 \u2192 \u03b2) (a' : \u03b1) : \u2203 a, f a' = f a", "start": [780, 1], "end": [780, 83], "kind": "commanddeclaration"}, {"full_name": "exists_apply_eq", "code": "theorem exists_apply_eq (a : \u03b1) (b : \u03b2) : \u2203 f : \u03b1 \u2192 \u03b2, f a = b", "start": [784, 1], "end": [784, 83], "kind": "commanddeclaration"}, {"full_name": "exists_exists_and_eq_and", "code": "@[simp] theorem exists_exists_and_eq_and {f : \u03b1 \u2192 \u03b2} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} :\n    (\u2203 b, (\u2203 a, p a \u2227 f a = b) \u2227 q b) \u2194 \u2203 a, p a \u2227 q (f a)", "start": [786, 1], "end": [788, 98], "kind": "commanddeclaration"}, {"full_name": "exists_exists_eq_and", "code": "@[simp] theorem exists_exists_eq_and {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} :\n    (\u2203 b, (\u2203 a, f a = b) \u2227 p b) \u2194 \u2203 a, p (f a)", "start": [791, 1], "end": [793, 80], "kind": "commanddeclaration"}, {"full_name": "exists_or_eq_left", "code": "@[simp] theorem exists_or_eq_left (y : \u03b1) (p : \u03b1 \u2192 Prop) : \u2203 x : \u03b1, x = y \u2228 p x", "start": [796, 1], "end": [796, 97], "kind": "commanddeclaration"}, {"full_name": "exists_or_eq_right", "code": "@[simp] theorem exists_or_eq_right (y : \u03b1) (p : \u03b1 \u2192 Prop) : \u2203 x : \u03b1, p x \u2228 x = y", "start": [799, 1], "end": [799, 98], "kind": "commanddeclaration"}, {"full_name": "exists_or_eq_left'", "code": "@[simp] theorem exists_or_eq_left' (y : \u03b1) (p : \u03b1 \u2192 Prop) : \u2203 x : \u03b1, y = x \u2228 p x", "start": [802, 1], "end": [802, 98], "kind": "commanddeclaration"}, {"full_name": "exists_or_eq_right'", "code": "@[simp] theorem exists_or_eq_right' (y : \u03b1) (p : \u03b1 \u2192 Prop) : \u2203 x : \u03b1, p x \u2228 y = x", "start": [805, 1], "end": [805, 99], "kind": "commanddeclaration"}, {"full_name": "forall_apply_eq_imp_iff'", "code": "theorem forall_apply_eq_imp_iff' {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} :\n    (\u2200 a b, f a = b \u2192 p b) \u2194 \u2200 a, p (f a)", "start": [808, 1], "end": [809, 53], "kind": "commanddeclaration"}, {"full_name": "forall_eq_apply_imp_iff'", "code": "theorem forall_eq_apply_imp_iff' {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} :\n    (\u2200 a b, b = f a \u2192 p b) \u2194 \u2200 a, p (f a)", "start": [814, 1], "end": [815, 53], "kind": "commanddeclaration"}, {"full_name": "exists_eq_right'", "code": "@[simp] theorem exists_eq_right' {a' : \u03b1} : (\u2203 a, p a \u2227 a' = a) \u2194 p a'", "start": [821, 1], "end": [821, 98], "kind": "commanddeclaration"}, {"full_name": "exists\u2082_comm", "code": "theorem exists\u2082_comm {\u03ba\u2081 : \u03b9\u2081 \u2192 Sort*} {\u03ba\u2082 : \u03b9\u2082 \u2192 Sort*} {p : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 Prop} :\n    (\u2203 i\u2081 j\u2081 i\u2082 j\u2082, p i\u2081 j\u2081 i\u2082 j\u2082) \u2194 \u2203 i\u2082 j\u2082 i\u2081 j\u2081, p i\u2081 j\u2081 i\u2082 j\u2082", "start": [826, 1], "end": [828, 51], "kind": "commanddeclaration"}, {"full_name": "And.exists", "code": "theorem And.exists {p q : Prop} {f : p \u2227 q \u2192 Prop} : (\u2203 h, f h) \u2194 \u2203 hp hq, f \u27e8hp, hq\u27e9", "start": [831, 1], "end": [832, 64], "kind": "commanddeclaration"}, {"full_name": "forall_or_of_or_forall", "code": "theorem forall_or_of_or_forall (h : b \u2228 \u2200 x, p x) (x) : b \u2228 p x", "start": [835, 1], "end": [835, 93], "kind": "commanddeclaration"}, {"full_name": "Decidable.forall_or_left", "code": "protected theorem Decidable.forall_or_left {q : Prop} {p : \u03b1 \u2192 Prop} [Decidable q] :\n    (\u2200 x, q \u2228 p x) \u2194 q \u2228 \u2200 x, p x", "start": [839, 1], "end": [842, 66], "kind": "commanddeclaration"}, {"full_name": "forall_or_left", "code": "theorem forall_or_left {q} {p : \u03b1 \u2192 Prop} : (\u2200 x, q \u2228 p x) \u2194 q \u2228 \u2200 x, p x", "start": [845, 1], "end": [846, 27], "kind": "commanddeclaration"}, {"full_name": "Decidable.forall_or_right", "code": "protected theorem Decidable.forall_or_right {q} {p : \u03b1 \u2192 Prop} [Decidable q] :\n    (\u2200 x, p x \u2228 q) \u2194 (\u2200 x, p x) \u2228 q", "start": [850, 1], "end": [851, 83], "kind": "commanddeclaration"}, {"full_name": "forall_or_right", "code": "theorem forall_or_right {q} {p : \u03b1 \u2192 Prop} : (\u2200 x, p x \u2228 q) \u2194 (\u2200 x, p x) \u2228 q", "start": [854, 1], "end": [855, 28], "kind": "commanddeclaration"}, {"full_name": "exists_unique_prop", "code": "theorem exists_unique_prop {p q : Prop} : (\u2203! _ : p, q) \u2194 p \u2227 q", "start": [858, 1], "end": [858, 75], "kind": "commanddeclaration"}, {"full_name": "exists_unique_false", "code": "@[simp] theorem exists_unique_false : \u00ac\u2203! _ : \u03b1, False", "start": [861, 1], "end": [861, 76], "kind": "commanddeclaration"}, {"full_name": "Exists.fst", "code": "theorem Exists.fst {b : Prop} {p : b \u2192 Prop} : Exists p \u2192 b", "start": [864, 1], "end": [865, 16], "kind": "commanddeclaration"}, {"full_name": "Exists.snd", "code": "theorem Exists.snd {b : Prop} {p : b \u2192 Prop} : \u2200 h : Exists p, p h.fst", "start": [868, 1], "end": [869, 16], "kind": "commanddeclaration"}, {"full_name": "Prop.exists_iff", "code": "theorem Prop.exists_iff {p : Prop \u2192 Prop} : (\u2203 h, p h) \u2194 p False \u2228 p True", "start": [872, 1], "end": [874, 88], "kind": "commanddeclaration"}, {"full_name": "Prop.forall_iff", "code": "theorem Prop.forall_iff {p : Prop \u2192 Prop} : (\u2200 h, p h) \u2194 p False \u2227 p True", "start": [876, 1], "end": [877, 78], "kind": "commanddeclaration"}, {"full_name": "exists_prop_of_true", "code": "theorem exists_prop_of_true {p : Prop} {q : p \u2192 Prop} (h : p) : (\u2203 h' : p, q h') \u2194 q h", "start": [879, 1], "end": [880, 28], "kind": "commanddeclaration"}, {"full_name": "exists_iff_of_forall", "code": "theorem exists_iff_of_forall {p : Prop} {q : p \u2192 Prop} (h : \u2200 h, q h) : (\u2203 h, q h) \u2194 p", "start": [883, 1], "end": [884, 33], "kind": "commanddeclaration"}, {"full_name": "exists_unique_prop_of_true", "code": "theorem exists_unique_prop_of_true {p : Prop} {q : p \u2192 Prop} (h : p) : (\u2203! h' : p, q h') \u2194 q h", "start": [887, 1], "end": [888, 37], "kind": "commanddeclaration"}, {"full_name": "forall_prop_of_false", "code": "theorem forall_prop_of_false {p : Prop} {q : p \u2192 Prop} (hn : \u00acp) : (\u2200 h' : p, q h') \u2194 True", "start": [891, 1], "end": [892, 35], "kind": "commanddeclaration"}, {"full_name": "exists_prop_of_false", "code": "theorem exists_prop_of_false {p : Prop} {q : p \u2192 Prop} : \u00acp \u2192 \u00ac\u2203 h' : p, q h'", "start": [895, 1], "end": [896, 16], "kind": "commanddeclaration"}, {"full_name": "exists_prop_congr", "code": "@[congr]\ntheorem exists_prop_congr {p p' : Prop} {q q' : p \u2192 Prop} (hq : \u2200 h, q h \u2194 q' h) (hp : p \u2194 p') :\n    Exists q \u2194 \u2203 h : p', q' (hp.2 h)", "start": [899, 1], "end": [902, 74], "kind": "commanddeclaration"}, {"full_name": "exists_prop_congr'", "code": "@[congr]\ntheorem exists_prop_congr' {p p' : Prop} {q q' : p \u2192 Prop} (hq : \u2200 h, q h \u2194 q' h) (hp : p \u2194 p') :\n    Exists q = \u2203 h : p', q' (hp.2 h)", "start": [905, 1], "end": [908, 36], "kind": "commanddeclaration"}, {"full_name": "exists_true_left", "code": "@[simp] theorem exists_true_left (p : True \u2192 Prop) : (\u2203 x, p x) \u2194 p True.intro", "start": [911, 1], "end": [913, 24], "kind": "commanddeclaration"}, {"full_name": "forall_prop_congr", "code": "theorem forall_prop_congr {p p' : Prop} {q q' : p \u2192 Prop} (hq : \u2200 h, q h \u2194 q' h) (hp : p \u2194 p') :\n    (\u2200 h, q h) \u2194 \u2200 h : p', q' (hp.2 h)", "start": [918, 1], "end": [920, 77], "kind": "commanddeclaration"}, {"full_name": "forall_prop_congr'", "code": "theorem forall_prop_congr' {p p' : Prop} {q q' : p \u2192 Prop} (hq : \u2200 h, q h \u2194 q' h) (hp : p \u2194 p') :\n    (\u2200 h, q h) = \u2200 h : p', q' (hp.2 h)", "start": [925, 1], "end": [927, 36], "kind": "commanddeclaration"}, {"full_name": "forall_true_left", "code": "@[simp] theorem forall_true_left (p : True \u2192 Prop) : (\u2200 x, p x) \u2194 p True.intro", "start": [930, 1], "end": [932, 24], "kind": "commanddeclaration"}, {"full_name": "ExistsUnique.elim\u2082", "code": "theorem ExistsUnique.elim\u2082 {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*} [\u2200 x, Subsingleton (p x)]\n    {q : \u2200 (x) (_ : p x), Prop} {b : Prop} (h\u2082 : \u2203! (x : _) (h : p x), q x h)\n    (h\u2081 : \u2200 (x) (h : p x), q x h \u2192 (\u2200 (y) (hy : p y), q y hy \u2192 y = x) \u2192 b) : b", "start": [935, 1], "end": [940, 73], "kind": "commanddeclaration"}, {"full_name": "ExistsUnique.intro\u2082", "code": "theorem ExistsUnique.intro\u2082 {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*} [\u2200 x, Subsingleton (p x)]\n    {q : \u2200 (x : \u03b1) (_ : p x), Prop} (w : \u03b1) (hp : p w) (hq : q w hp)\n    (H : \u2200 (y) (hy : p y), q y hy \u2192 y = w) : \u2203! (x : _) (hx : p x), q x hx", "start": [943, 1], "end": [947, 69], "kind": "commanddeclaration"}, {"full_name": "ExistsUnique.exists\u2082", "code": "theorem ExistsUnique.exists\u2082 {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*} {q : \u2200 (x : \u03b1) (_ : p x), Prop}\n    (h : \u2203! (x : _) (hx : p x), q x hx) : \u2203 (x : _) (hx : p x), q x hx", "start": [950, 1], "end": [952, 36], "kind": "commanddeclaration"}, {"full_name": "ExistsUnique.unique\u2082", "code": "theorem ExistsUnique.unique\u2082 {\u03b1 : Sort*} {p : \u03b1 \u2192 Sort*} [\u2200 x, Subsingleton (p x)]\n    {q : \u2200 (x : \u03b1) (_ : p x), Prop} (h : \u2203! (x : _) (hx : p x), q x hx) {y\u2081 y\u2082 : \u03b1}\n    (hpy\u2081 : p y\u2081) (hqy\u2081 : q y\u2081 hpy\u2081) (hpy\u2082 : p y\u2082) (hqy\u2082 : q y\u2082 hpy\u2082) : y\u2081 = y\u2082", "start": [955, 1], "end": [959, 43], "kind": "commanddeclaration"}, {"full_name": "Classical.dec", "code": "noncomputable def dec (p : Prop) : Decidable p := by infer_instance", "start": [970, 1], "end": [971, 68], "kind": "commanddeclaration"}, {"full_name": "Classical.decPred", "code": "noncomputable def decPred (p : \u03b1 \u2192 Prop) : DecidablePred p := by infer_instance", "start": [974, 1], "end": [975, 80], "kind": "commanddeclaration"}, {"full_name": "Classical.decRel", "code": "noncomputable def decRel (p : \u03b1 \u2192 \u03b1 \u2192 Prop) : DecidableRel p := by infer_instance", "start": [978, 1], "end": [979, 82], "kind": "commanddeclaration"}, {"full_name": "Classical.decEq", "code": "noncomputable def decEq (\u03b1 : Sort u) : DecidableEq \u03b1 := by infer_instance", "start": [982, 1], "end": [983, 74], "kind": "commanddeclaration"}, {"full_name": "Classical.existsCases", "code": "noncomputable def existsCases (H0 : C) (H : \u2200 a, p a \u2192 C) : C :=\n  if h : \u2203 a, p a then H (Classical.choose h) (Classical.choose_spec h) else H0", "start": [986, 1], "end": [990, 80], "kind": "commanddeclaration"}, {"full_name": "Classical.some_spec\u2082", "code": "theorem some_spec\u2082 {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} {h : \u2203 a, p a} (q : \u03b1 \u2192 Prop)\n    (hpq : \u2200 a, p a \u2192 q a) : q (choose h)", "start": [993, 1], "end": [994, 68], "kind": "commanddeclaration"}, {"full_name": "Classical.subtype_of_exists", "code": "noncomputable def subtype_of_exists {\u03b1 : Type*} {P : \u03b1 \u2192 Prop} (h : \u2203 x, P x) : { x // P x } :=\n  \u27e8Classical.choose h, Classical.choose_spec h\u27e9", "start": [997, 1], "end": [999, 48], "kind": "commanddeclaration"}, {"full_name": "Classical.byContradiction'", "code": "protected noncomputable def byContradiction' {\u03b1 : Sort*} (H : \u00ac(\u03b1 \u2192 False)) : \u03b1 :=\n  Classical.choice <| (peirce _ False) fun h \u21a6 (H fun a \u21a6 h \u27e8a\u27e9).elim", "start": [1002, 1], "end": [1004, 70], "kind": "commanddeclaration"}, {"full_name": "Classical.choice_of_byContradiction'", "code": "def choice_of_byContradiction' {\u03b1 : Sort*} (contra : \u00ac(\u03b1 \u2192 False) \u2192 \u03b1) : Nonempty \u03b1 \u2192 \u03b1 :=\n  fun H \u21a6 contra H.elim", "start": [1007, 1], "end": [1009, 24], "kind": "commanddeclaration"}, {"full_name": "Exists.classicalRecOn", "code": "noncomputable def Exists.classicalRecOn {p : \u03b1 \u2192 Prop} (h : \u2203 a, p a) {C} (H : \u2200 a, p a \u2192 C) : C :=\n  H (Classical.choose h) (Classical.choose_spec h)", "start": [1014, 1], "end": [1019, 51], "kind": "commanddeclaration"}, {"full_name": "bex_def", "code": "theorem bex_def : (\u2203 (x : _) (_ : p x), q x) \u2194 \u2203 x, p x \u2227 q x", "start": [1027, 1], "end": [1028, 65], "kind": "commanddeclaration"}, {"full_name": "BEx.elim", "code": "theorem BEx.elim {b : Prop} : (\u2203 x h, P x h) \u2192 (\u2200 a h, P a h \u2192 b) \u2192 b", "start": [1031, 1], "end": [1032, 34], "kind": "commanddeclaration"}, {"full_name": "BEx.intro", "code": "theorem BEx.intro (a : \u03b1) (h\u2081 : p a) (h\u2082 : P a h\u2081) : \u2203 (x : _) (h : p x), P x h", "start": [1035, 1], "end": [1036, 14], "kind": "commanddeclaration"}, {"full_name": "ball_congr", "code": "theorem ball_congr (H : \u2200 x h, P x h \u2194 Q x h) : (\u2200 x h, P x h) \u2194 \u2200 x h, Q x h", "start": [1039, 1], "end": [1040, 44], "kind": "commanddeclaration"}, {"full_name": "bex_congr", "code": "theorem bex_congr (H : \u2200 x h, P x h \u2194 Q x h) : (\u2203 x h, P x h) \u2194 \u2203 x h, Q x h", "start": [1043, 1], "end": [1044, 42], "kind": "commanddeclaration"}, {"full_name": "bex_eq_left", "code": "theorem bex_eq_left {a : \u03b1} : (\u2203 (x : _) (_ : x = a), p x) \u2194 p a", "start": [1047, 1], "end": [1048, 42], "kind": "commanddeclaration"}, {"full_name": "BAll.imp_right", "code": "theorem BAll.imp_right (H : \u2200 x h, P x h \u2192 Q x h) (h\u2081 : \u2200 x h, P x h) (x h) : Q x h", "start": [1051, 1], "end": [1052, 18], "kind": "commanddeclaration"}, {"full_name": "BEx.imp_right", "code": "theorem BEx.imp_right (H : \u2200 x h, P x h \u2192 Q x h) : (\u2203 x h, P x h) \u2192 \u2203 x h, Q x h", "start": [1055, 1], "end": [1056, 35], "kind": "commanddeclaration"}, {"full_name": "BAll.imp_left", "code": "theorem BAll.imp_left (H : \u2200 x, p x \u2192 q x) (h\u2081 : \u2200 x, q x \u2192 r x) (x) (h : p x) : r x", "start": [1059, 1], "end": [1060, 16], "kind": "commanddeclaration"}, {"full_name": "BEx.imp_left", "code": "theorem BEx.imp_left (H : \u2200 x, p x \u2192 q x) : (\u2203 (x : _) (_ : p x), r x) \u2192 \u2203 (x : _) (_ : q x), r x", "start": [1063, 1], "end": [1064, 35], "kind": "commanddeclaration"}, {"full_name": "ball_of_forall", "code": "theorem ball_of_forall (h : \u2200 x, p x) (x) : p x", "start": [1067, 1], "end": [1067, 55], "kind": "commanddeclaration"}, {"full_name": "forall_of_ball", "code": "theorem forall_of_ball (H : \u2200 x, p x) (h : \u2200 x, p x \u2192 q x) (x) : q x", "start": [1070, 1], "end": [1070, 83], "kind": "commanddeclaration"}, {"full_name": "bex_of_exists", "code": "theorem bex_of_exists (H : \u2200 x, p x) : (\u2203 x, q x) \u2192 \u2203 (x : _) (_ : p x), q x", "start": [1073, 1], "end": [1074, 28], "kind": "commanddeclaration"}, {"full_name": "exists_of_bex", "code": "theorem exists_of_bex : (\u2203 (x : _) (_ : p x), q x) \u2192 \u2203 x, q x", "start": [1077, 1], "end": [1078, 26], "kind": "commanddeclaration"}, {"full_name": "bex_imp", "code": "theorem bex_imp : (\u2203 x h, P x h) \u2192 b \u2194 \u2200 x h, P x h \u2192 b", "start": [1081, 1], "end": [1081, 67], "kind": "commanddeclaration"}, {"full_name": "not_bex", "code": "theorem not_bex : (\u00ac\u2203 x h, P x h) \u2194 \u2200 x h, \u00acP x h", "start": [1084, 1], "end": [1084, 61], "kind": "commanddeclaration"}, {"full_name": "not_ball_of_bex_not", "code": "theorem not_ball_of_bex_not : (\u2203 x h, \u00acP x h) \u2192 \u00ac\u2200 x h, P x h", "start": [1087, 1], "end": [1088, 35], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_ball", "code": "protected theorem Decidable.not_ball [Decidable (\u2203 x h, \u00acP x h)] [\u2200 x h, Decidable (P x h)] :\n    (\u00ac\u2200 x h, P x h) \u2194 \u2203 x h, \u00acP x h", "start": [1092, 1], "end": [1095, 46], "kind": "commanddeclaration"}, {"full_name": "not_ball", "code": "theorem not_ball : (\u00ac\u2200 x h, P x h) \u2194 \u2203 x h, \u00acP x h", "start": [1098, 1], "end": [1098, 73], "kind": "commanddeclaration"}, {"full_name": "ball_true_iff", "code": "theorem ball_true_iff (p : \u03b1 \u2192 Prop) : (\u2200 x, p x \u2192 True) \u2194 True", "start": [1101, 1], "end": [1102, 35], "kind": "commanddeclaration"}, {"full_name": "ball_and", "code": "theorem ball_and : (\u2200 x h, P x h \u2227 Q x h) \u2194 (\u2200 x h, P x h) \u2227 \u2200 x h, Q x h", "start": [1105, 1], "end": [1106, 58], "kind": "commanddeclaration"}, {"full_name": "bex_or", "code": "theorem bex_or : (\u2203 x h, P x h \u2228 Q x h) \u2194 (\u2203 x h, P x h) \u2228 \u2203 x h, Q x h", "start": [1109, 1], "end": [1110, 55], "kind": "commanddeclaration"}, {"full_name": "ball_or_left", "code": "theorem ball_or_left : (\u2200 x, p x \u2228 q x \u2192 r x) \u2194 (\u2200 x, p x \u2192 r x) \u2227 \u2200 x, q x \u2192 r x", "start": [1113, 1], "end": [1114, 54], "kind": "commanddeclaration"}, {"full_name": "bex_or_left", "code": "theorem bex_or_left :\n    (\u2203 (x : _) (_ : p x \u2228 q x), r x) \u2194 (\u2203 (x : _) (_ : p x), r x) \u2228 \u2203 (x : _) (_ : q x), r x", "start": [1117, 1], "end": [1120, 64], "kind": "commanddeclaration"}, {"full_name": "dite_eq_iff", "code": "theorem dite_eq_iff : dite P A B = c \u2194 (\u2203 h, A h = c) \u2228 \u2203 h, B h = c", "start": [1132, 1], "end": [1133, 69], "kind": "commanddeclaration"}, {"full_name": "ite_eq_iff", "code": "theorem ite_eq_iff : ite P a b = c \u2194 P \u2227 a = c \u2228 \u00acP \u2227 b = c", "start": [1136, 1], "end": [1137, 67], "kind": "commanddeclaration"}, {"full_name": "eq_ite_iff", "code": "theorem eq_ite_iff : a = ite P b c \u2194 P \u2227 a = b \u2228 \u00acP \u2227 a = c", "start": [1140, 1], "end": [1141, 86], "kind": "commanddeclaration"}, {"full_name": "dite_eq_iff'", "code": "theorem dite_eq_iff' : dite P A B = c \u2194 (\u2200 h, A h = c) \u2227 \u2200 h, B h = c", "start": [1143, 1], "end": [1145, 91], "kind": "commanddeclaration"}, {"full_name": "ite_eq_iff'", "code": "theorem ite_eq_iff' : ite P a b = c \u2194 (P \u2192 a = c) \u2227 (\u00acP \u2192 b = c)", "start": [1148, 1], "end": [1148, 81], "kind": "commanddeclaration"}, {"full_name": "dite_eq_left_iff", "code": "@[simp] theorem dite_eq_left_iff : dite P (fun _ \u21a6 a) B = a \u2194 \u2200 h, B h = a", "start": [1151, 1], "end": [1152, 69], "kind": "commanddeclaration"}, {"full_name": "dite_eq_right_iff", "code": "@[simp] theorem dite_eq_right_iff : (dite P A fun _ \u21a6 b) = b \u2194 \u2200 h, A h = b", "start": [1155, 1], "end": [1156, 69], "kind": "commanddeclaration"}, {"full_name": "ite_eq_left_iff", "code": "@[simp] theorem ite_eq_left_iff : ite P a b = a \u2194 \u00acP \u2192 b = a", "start": [1159, 1], "end": [1159, 81], "kind": "commanddeclaration"}, {"full_name": "ite_eq_right_iff", "code": "@[simp] theorem ite_eq_right_iff : ite P a b = b \u2194 P \u2192 a = b", "start": [1162, 1], "end": [1162, 82], "kind": "commanddeclaration"}, {"full_name": "dite_ne_left_iff", "code": "theorem dite_ne_left_iff : dite P (fun _ \u21a6 a) B \u2260 a \u2194 \u2203 h, a \u2260 B h", "start": [1165, 1], "end": [1167, 45], "kind": "commanddeclaration"}, {"full_name": "dite_ne_right_iff", "code": "theorem dite_ne_right_iff : (dite P A fun _ \u21a6 b) \u2260 b \u2194 \u2203 h, A h \u2260 b", "start": [1170, 1], "end": [1171, 52], "kind": "commanddeclaration"}, {"full_name": "ite_ne_left_iff", "code": "theorem ite_ne_left_iff : ite P a b \u2260 a \u2194 \u00acP \u2227 a \u2260 b", "start": [1174, 1], "end": [1175, 59], "kind": "commanddeclaration"}, {"full_name": "ite_ne_right_iff", "code": "theorem ite_ne_right_iff : ite P a b \u2260 b \u2194 P \u2227 a \u2260 b", "start": [1178, 1], "end": [1179, 60], "kind": "commanddeclaration"}, {"full_name": "Ne.dite_eq_left_iff", "code": "protected theorem Ne.dite_eq_left_iff (h : \u2200 h, a \u2260 B h) : dite P (fun _ \u21a6 a) B = a \u2194 P", "start": [1182, 1], "end": [1183, 94], "kind": "commanddeclaration"}, {"full_name": "Ne.dite_eq_right_iff", "code": "protected theorem Ne.dite_eq_right_iff (h : \u2200 h, A h \u2260 b) : (dite P A fun _ \u21a6 b) = b \u2194 \u00acP", "start": [1186, 1], "end": [1187, 75], "kind": "commanddeclaration"}, {"full_name": "Ne.ite_eq_left_iff", "code": "protected theorem Ne.ite_eq_left_iff (h : a \u2260 b) : ite P a b = a \u2194 P", "start": [1190, 1], "end": [1191, 32], "kind": "commanddeclaration"}, {"full_name": "Ne.ite_eq_right_iff", "code": "protected theorem Ne.ite_eq_right_iff (h : a \u2260 b) : ite P a b = b \u2194 \u00acP", "start": [1194, 1], "end": [1195, 33], "kind": "commanddeclaration"}, {"full_name": "Ne.dite_ne_left_iff", "code": "protected theorem Ne.dite_ne_left_iff (h : \u2200 h, a \u2260 B h) : dite P (fun _ \u21a6 a) B \u2260 a \u2194 \u00acP", "start": [1198, 1], "end": [1199, 51], "kind": "commanddeclaration"}, {"full_name": "Ne.dite_ne_right_iff", "code": "protected theorem Ne.dite_ne_right_iff (h : \u2200 h, A h \u2260 b) : (dite P A fun _ \u21a6 b) \u2260 b \u2194 P", "start": [1202, 1], "end": [1203, 52], "kind": "commanddeclaration"}, {"full_name": "Ne.ite_ne_left_iff", "code": "protected theorem Ne.ite_ne_left_iff (h : a \u2260 b) : ite P a b \u2260 a \u2194 \u00acP", "start": [1206, 1], "end": [1207, 32], "kind": "commanddeclaration"}, {"full_name": "Ne.ite_ne_right_iff", "code": "protected theorem Ne.ite_ne_right_iff (h : a \u2260 b) : ite P a b \u2260 b \u2194 P", "start": [1210, 1], "end": [1211, 33], "kind": "commanddeclaration"}, {"full_name": "dite_eq_ite", "code": "@[simp] theorem dite_eq_ite : (dite P (fun _ \u21a6 a) fun _ \u21a6 b) = ite P a b", "start": [1216, 1], "end": [1217, 80], "kind": "commanddeclaration"}, {"full_name": "dite_eq_or_eq", "code": "theorem dite_eq_or_eq : (\u2203 h, dite P A B = A h) \u2228 \u2203 h, dite P A B = B h", "start": [1220, 1], "end": [1221, 61], "kind": "commanddeclaration"}, {"full_name": "ite_eq_or_eq", "code": "theorem ite_eq_or_eq : ite P a b = a \u2228 ite P a b = b", "start": [1224, 1], "end": [1225, 53], "kind": "commanddeclaration"}, {"full_name": "apply_dite\u2082", "code": "theorem apply_dite\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (P : Prop) [Decidable P] (a : P \u2192 \u03b1) (b : \u00acP \u2192 \u03b1)\n    (c : P \u2192 \u03b2) (d : \u00acP \u2192 \u03b2) :\n    f (dite P a b) (dite P c d) = dite P (fun h \u21a6 f (a h) (c h)) fun h \u21a6 f (b h) (d h)", "start": [1228, 1], "end": [1233, 30], "kind": "commanddeclaration"}, {"full_name": "apply_ite\u2082", "code": "theorem apply_ite\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (P : Prop) [Decidable P] (a b : \u03b1) (c d : \u03b2) :\n    f (ite P a b) (ite P c d) = ite P (f a c) (f b d)", "start": [1236, 1], "end": [1240, 64], "kind": "commanddeclaration"}, {"full_name": "dite_apply", "code": "theorem dite_apply (f : P \u2192 \u2200 a, \u03c3 a) (g : \u00acP \u2192 \u2200 a, \u03c3 a) (a : \u03b1) :\n    (dite P f g) a = dite P (fun h \u21a6 f h a) fun h \u21a6 g h a", "start": [1243, 1], "end": [1246, 90], "kind": "commanddeclaration"}, {"full_name": "ite_apply", "code": "theorem ite_apply (f g : \u2200 a, \u03c3 a) (a : \u03b1) : (ite P f g) a = ite P (f a) (g a)", "start": [1249, 1], "end": [1252, 41], "kind": "commanddeclaration"}, {"full_name": "ite_and", "code": "theorem ite_and : ite (P \u2227 Q) a b = ite P (ite Q a b) b", "start": [1255, 1], "end": [1256, 56], "kind": "commanddeclaration"}, {"full_name": "dite_dite_comm", "code": "theorem dite_dite_comm {B : Q \u2192 \u03b1} {C : \u00acP \u2192 \u00acQ \u2192 \u03b1} (h : P \u2192 \u00acQ) :\n    (if p : P then A p else if q : Q then B q else C p q) =\n     if q : Q then B q else if p : P then A p else C p q", "start": [1259, 1], "end": [1264, 50], "kind": "commanddeclaration"}, {"full_name": "ite_ite_comm", "code": "theorem ite_ite_comm (h : P \u2192 \u00acQ) :\n    (if P then a else if Q then b else c) =\n     if Q then b else if P then a else c", "start": [1267, 1], "end": [1270, 23], "kind": "commanddeclaration"}, {"full_name": "ite_prop_iff_or", "code": "theorem ite_prop_iff_or : (if P then Q else R) \u2194 (P \u2227 Q \u2228 \u00ac P \u2227 R)", "start": [1275, 1], "end": [1276, 30], "kind": "commanddeclaration"}, {"full_name": "dite_prop_iff_or", "code": "theorem dite_prop_iff_or {Q : P \u2192 Prop} {R : \u00acP \u2192 Prop} [Decidable P] :\n    dite P Q R \u2194 (\u2203 p, Q p) \u2228 (\u2203 p, R p)", "start": [1278, 1], "end": [1280, 73], "kind": "commanddeclaration"}, {"full_name": "ite_prop_iff_and", "code": "theorem ite_prop_iff_and : (if P then Q else R) \u2194 ((P \u2192 Q) \u2227 (\u00ac P \u2192 R))", "start": [1283, 1], "end": [1284, 30], "kind": "commanddeclaration"}, {"full_name": "dite_prop_iff_and", "code": "theorem dite_prop_iff_and {Q : P \u2192 Prop} {R : \u00acP \u2192 Prop} [Decidable P] :\n    dite P Q R \u2194 (\u2200 h, Q h) \u2227 (\u2200 h, R h)", "start": [1286, 1], "end": [1288, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/ZeroOne.lean", "imports": ["Mathlib/Tactic/ToAdditive.lean", "Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Zero", "code": "class Zero.{u} (\u03b1 : Type u) where\n  zero : \u03b1", "start": [13, 1], "end": [14, 11], "kind": "commanddeclaration"}, {"full_name": "Zero.toOfNat0", "code": "instance Zero.toOfNat0 {\u03b1} [Zero \u03b1] : OfNat \u03b1 (nat_lit 0) where\n  ofNat := \u2039Zero \u03b1\u203a.1", "start": [17, 1], "end": [18, 22], "kind": "commanddeclaration"}, {"full_name": "Zero.ofOfNat0", "code": "instance Zero.ofOfNat0 {\u03b1} [OfNat \u03b1 (nat_lit 0)] : Zero \u03b1 where\n  zero := 0", "start": [20, 1], "end": [21, 12], "kind": "commanddeclaration"}, {"full_name": "One", "code": "@[to_additive]\nclass One (\u03b1 : Type u) where\n  one : \u03b1", "start": [24, 1], "end": [26, 10], "kind": "commanddeclaration"}, {"full_name": "One.toOfNat1", "code": "@[to_additive existing Zero.toOfNat0]\ninstance One.toOfNat1 {\u03b1} [One \u03b1] : OfNat \u03b1 (nat_lit 1) where\n  ofNat := \u2039One \u03b1\u203a.1", "start": [29, 1], "end": [31, 21], "kind": "commanddeclaration"}, {"full_name": "One.ofOfNat1", "code": "@[to_additive existing Zero.ofOfNat0, to_additive_change_numeral 2]\ninstance One.ofOfNat1 {\u03b1} [OfNat \u03b1 (nat_lit 1)] : One \u03b1 where\n  one := 1", "start": [32, 1], "end": [34, 11], "kind": "commanddeclaration"}, {"full_name": "bit0", "code": "@[deprecated, match_pattern] def bit0 {\u03b1 : Type u} [Add \u03b1] (a : \u03b1) : \u03b1 := a + a", "start": [36, 1], "end": [36, 80], "kind": "commanddeclaration"}, {"full_name": "bit1", "code": "@[deprecated, match_pattern] def bit1 {\u03b1 : Type u} [One \u03b1] [Add \u03b1] (a : \u03b1) : \u03b1 := bit0 a + 1", "start": [39, 1], "end": [39, 93], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Tree.lean", "imports": ["lake-packages/aesop/Aesop/Tree/UnsafeQueue.lean", "lake-packages/aesop/Aesop/Tree/RunMetaM.lean", "lake-packages/aesop/Aesop/Tree/State.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Tree/Tracing.lean", "lake-packages/aesop/Aesop/Tree/TreeM.lean", "lake-packages/aesop/Aesop/Tree/Data.lean", "lake-packages/aesop/Aesop/Tree/ExtractProof.lean", "lake-packages/aesop/Aesop/Tree/Check.lean", "lake-packages/aesop/Aesop/Tree/ExtractScript.lean", "lake-packages/aesop/Aesop/Tree/AddRapp.lean", "lake-packages/aesop/Aesop/Tree/Free.lean", "lake-packages/aesop/Aesop/Tree/Traversal.lean"], "premises": []}
{"path": "lake-packages/aesop/Aesop/RuleSet.lean", "imports": ["lake-packages/aesop/Aesop/Index.lean", "lake-packages/aesop/Aesop/Builder.lean", "lake-packages/aesop/Aesop/Rule.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleSetMember", "code": "inductive RuleSetMember\n  | normRule (r : NormRule)\n  | unsafeRule (r : UnsafeRule)\n  | safeRule (r : SafeRule)\n  | normSimpRule (r : NormSimpRule)\n  | localNormSimpRule (r : LocalNormSimpRule)\n  | unfoldRule (r : UnfoldRule)\n  deriving Inhabited", "start": [16, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSetMember.name", "code": "def name : RuleSetMember \u2192 RuleName\n  | normRule r => r.name\n  | unsafeRule r => r.name\n  | safeRule r => r.name\n  | normSimpRule r => r.name\n  | localNormSimpRule r => r.name\n  | unfoldRule r => r.name", "start": [27, 1], "end": [33, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSetMember.isGlobal", "code": "def isGlobal (m : RuleSetMember) : Bool :=\n  m.name.scope == .global", "start": [35, 1], "end": [36, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleNameFilter", "code": "structure RuleNameFilter where\n  ident : RuleIdent\n  builders : Array BuilderName phases : Array PhaseName", "start": [41, 1], "end": [44, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleNameFilter.ofIdent", "code": "def ofIdent (i : RuleIdent) : RuleNameFilter where\n  ident := i\n  builders := #[]\n  phases := #[]", "start": [48, 1], "end": [51, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleNameFilter.match", "code": "def \u00abmatch\u00bb (f : RuleNameFilter) (n : RuleName) : Bool :=\n  f.ident.name == n.name &&\n  f.ident.scope == n.scope &&\n  (f.builders.isEmpty || f.builders.any (\u00b7 == n.builder)) &&\n  (f.phases.isEmpty || f.phases.any (\u00b7 == n.phase))", "start": [53, 1], "end": [57, 52], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet", "code": "structure RuleSet where\n  normRules : Index NormRule\n  unsafeRules : Index UnsafeRule\n  safeRules : Index SafeRule\n  normSimpLemmas : SimpTheorems\n  normSimpLemmaDescrs : PHashMap RuleName (Array SimpEntry)\n    simpAttrNormSimpLemmas : Array (Name \u00d7 SimpTheorems)\n    localNormSimpLemmas : Array LocalNormSimpRule\n    unfoldRules : PHashMap Name (Option Name)\n    ruleNames : PHashMap RuleIdent (UnorderedArraySet RuleName)\n    erased : HashSet RuleName\n    deriving Inhabited", "start": [62, 1], "end": [104, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.trace", "code": "def trace (rs : RuleSet) (traceOpt : TraceOption) : CoreM Unit := do\n  if ! (\u2190 traceOpt.isEnabled) then\n    return\n  withConstAesopTraceNode traceOpt (return \"Erased rules\") do\n    aesop_trace![traceOpt] \"(Note: even if these rules appear in the sections below, they will not be applied by Aesop.)\"\n    for r in rs.erased.toArray.qsortOrd do\n      aesop_trace![traceOpt] r\n  withConstAesopTraceNode traceOpt (return \"Unsafe rules\") do\n    rs.unsafeRules.trace traceOpt\n  withConstAesopTraceNode traceOpt (return \"Safe rules\") do\n    rs.safeRules.trace traceOpt\n  withConstAesopTraceNode traceOpt (return \"Normalisation rules\") do\n    rs.normRules.trace traceOpt\n  withConstAesopTraceNode traceOpt (return \"Normalisation simp theorems specific to this rule set\") do\n    traceSimpTheorems rs.normSimpLemmas traceOpt\n  withConstAesopTraceNode traceOpt (return \"Normalisation simp theorems inherited from simp attributes\") do\n    rs.simpAttrNormSimpLemmas.forM \u03bb (name, simpTheorems) =>\n      withConstAesopTraceNode traceOpt (return m!\"Simp set {printSimpSetName name}:\") do\n        traceSimpTheorems simpTheorems traceOpt\n  withConstAesopTraceNode traceOpt (return \"Local normalisation simp theorems\") do\n    for r in rs.localNormSimpLemmas.map (\u00b7.fvarUserName.toString) |>.qsortOrd do\n      aesop_trace![traceOpt] r\n  withConstAesopTraceNode traceOpt (return \"Constants to unfold\") do\n    for r in rs.unfoldRules.toArray.map (\u00b7.fst.toString) |>.qsortOrd do\n      aesop_trace![traceOpt] r\nwhere\n  printSimpSetName : Name \u2192 String\n    | `_ => \"<default>\"\n    | n => toString n", "start": [108, 1], "end": [136, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.empty", "code": "def empty : RuleSet where\n  normRules := {}\n  unsafeRules := {}\n  safeRules := {}\n  normSimpLemmas := {}\n  normSimpLemmaDescrs := {}\n  simpAttrNormSimpLemmas := {}\n  localNormSimpLemmas := {}\n  unfoldRules := {}\n  ruleNames := {}\n  erased := {}", "start": [138, 1], "end": [148, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.merge", "code": "def merge (rs\u2081 rs\u2082 : RuleSet) : RuleSet where\n  normRules := rs\u2081.normRules.merge rs\u2082.normRules\n  unsafeRules := rs\u2081.unsafeRules.merge rs\u2082.unsafeRules\n  safeRules := rs\u2081.safeRules.merge rs\u2082.safeRules\n  normSimpLemmas := SimpTheorems.merge rs\u2081.normSimpLemmas rs\u2082.normSimpLemmas\n  normSimpLemmaDescrs :=\n    rs\u2081.normSimpLemmaDescrs.mergeWith rs\u2082.normSimpLemmaDescrs \u03bb _ nsd\u2081 _ => nsd\u2081\n    simpAttrNormSimpLemmas :=\n    have : Ord (Name \u00d7 SimpTheorems) := .on \u27e8Name.quickCmp\u27e9 (\u00b7.fst)\n    rs\u2081.simpAttrNormSimpLemmas.mergeSortedDeduplicating\n      rs\u2082.simpAttrNormSimpLemmas\n  localNormSimpLemmas := rs\u2081.localNormSimpLemmas ++ rs\u2082.localNormSimpLemmas\n  unfoldRules := rs\u2081.unfoldRules.mergeWith rs\u2082.unfoldRules\n    \u03bb _ unfoldThm?\u2081 _ => unfoldThm?\u2081\n  ruleNames :=\n    rs\u2081.ruleNames.mergeWith rs\u2082.ruleNames \u03bb _ ns\u2081 ns\u2082 =>\n      ns\u2081 ++ ns\u2082\n  erased :=\n    let go (rs\u2081 rs\u2082 : RuleSet) (init : HashSet RuleName) : HashSet RuleName :=\n      rs\u2081.erased.fold (init := init) \u03bb x n =>\n        match rs\u2082.ruleNames.find? n.toRuleIdent with\n        | none => x.insert n\n        | some ns =>\n          if ns.contains n then x else x.insert n\n    go rs\u2082 rs\u2081 $ go rs\u2081 rs\u2082 {}", "start": [153, 1], "end": [183, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.add", "code": "def add (rs : RuleSet) (r : RuleSetMember) : RuleSet :=\n  let n := r.name\n  let erased := rs.erased.erase n\n  let ruleNames :=\n    let ident := n.toRuleIdent\n    match rs.ruleNames.find? ident with\n    | none => rs.ruleNames.insert ident $ .singleton n\n    | some ns => rs.ruleNames.insert ident $ ns.insert n\n  let rs := { rs with erased := erased, ruleNames := ruleNames }\n  match r with\n  | .normRule r =>\n    { rs with normRules := rs.normRules.add r r.indexingMode }\n  | .unsafeRule r =>\n    { rs with unsafeRules := rs.unsafeRules.add r r.indexingMode }\n  | .safeRule r =>\n    { rs with safeRules := rs.safeRules.add r r.indexingMode }\n  | .normSimpRule r => {\n      rs with\n      normSimpLemmas :=\n        r.entries.foldl (init := rs.normSimpLemmas) \u03bb simpLemmas e =>\n          SimpTheorems.addSimpEntry simpLemmas e\n      normSimpLemmaDescrs := rs.normSimpLemmaDescrs.insert r.name r.entries\n    }\n  | .localNormSimpRule r =>\n    { rs with localNormSimpLemmas := rs.localNormSimpLemmas.push r }\n  | .unfoldRule r =>\n    { rs with unfoldRules := rs.unfoldRules.insert r.decl r.unfoldThm? }", "start": [185, 1], "end": [211, 73], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.addArray", "code": "def addArray (rs : RuleSet) (ra : Array RuleSetMember) : RuleSet :=\n  ra.foldl add rs", "start": [213, 1], "end": [214, 18], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.simpTheoremsContains", "code": "private def simpTheoremsContains (st : SimpTheorems) (decl : Name) : Bool :=\n  st.isLemma (.decl decl) ||\n  st.isDeclToUnfold decl ||\n  st.toUnfoldThms.contains decl", "start": [216, 1], "end": [219, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.eraseSimpAttrNormSimpLemmas", "code": "def eraseSimpAttrNormSimpLemmas (rs : RuleSet) (f : RuleNameFilter) :\n    RuleSet \u00d7 Bool := Id.run do\n  let mut simpAttrNormSimpLemmas := rs.simpAttrNormSimpLemmas\n  let mut anyErased := false\n  if let .const theoremName := f.ident then\n    if f.builders.isEmpty || f.builders.contains .simp then\n      let origin := .decl theoremName\n      for i in [:simpAttrNormSimpLemmas.size] do\n        let (name, simpTheorems) := simpAttrNormSimpLemmas[i]!\n        if simpTheoremsContains simpTheorems theoremName then\n          simpAttrNormSimpLemmas :=\n            simpAttrNormSimpLemmas.set! i (name, simpTheorems.eraseCore origin)\n          anyErased := true\n  return ({ rs with simpAttrNormSimpLemmas }, anyErased)", "start": [221, 1], "end": [234, 57], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.erase", "code": "def erase (rs : RuleSet) (f : RuleNameFilter) : RuleSet \u00d7 Bool := Id.run do\n  let (rs, anyErased) := rs.eraseSimpAttrNormSimpLemmas f\n  let some ns := rs.ruleNames.find? f.ident\n    | (rs, anyErased)\n  let (toErase, toKeep) := ns.partition f.match\n  if toErase.isEmpty then\n    (rs, anyErased)\n  else do\n    let ruleNames :=\n      if toKeep.isEmpty then\n        rs.ruleNames.erase f.ident\n      else\n        rs.ruleNames.insert f.ident toKeep\n\n    let mut erased := rs.erased\n    let mut normSimpLemmaDescrs := rs.normSimpLemmaDescrs\n    let mut normSimpLemmas := rs.normSimpLemmas\n    let mut localNormSimpLemmas := rs.localNormSimpLemmas\n    let mut unfoldRules := rs.unfoldRules\n    for r in toErase do\n      if r.builder == .simp then\n        if r.scope == .global then\n          if let some simpEntries := normSimpLemmaDescrs.find? r then\n            normSimpLemmaDescrs := normSimpLemmaDescrs.erase r\n            for e in simpEntries do\n              normSimpLemmas := SimpTheorems.eraseSimpEntry normSimpLemmas e\n        else\n          localNormSimpLemmas := localNormSimpLemmas.filter \u03bb l => l.name != r\n      else if r.builder == .unfold then\n        unfoldRules := unfoldRules.erase r.name\n      else\n        erased := erased.insert r\n\n    let res := {\n      rs with\n      ruleNames, erased, normSimpLemmas, normSimpLemmaDescrs\n      localNormSimpLemmas, unfoldRules\n    }\n    return (res, true)", "start": [237, 1], "end": [275, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.eraseAllRulesWithIdent", "code": "def eraseAllRulesWithIdent (rs : RuleSet) (i : RuleIdent) : RuleSet \u00d7 Bool :=\n  rs.erase (.ofIdent i)", "start": [277, 1], "end": [278, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.unindex", "code": "def unindex (rs : RuleSet) (p : RuleName \u2192 Bool) : RuleSet := {\n  rs with\n  normRules := rs.normRules.unindex (\u03bb r => p r.name)\n  unsafeRules := rs.unsafeRules.unindex (\u03bb r => p r.name)\n  safeRules := rs.safeRules.unindex (\u03bb r => p r.name)\n}", "start": [280, 1], "end": [285, 2], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.isErased", "code": "@[inline]\nprivate def isErased (rs : RuleSet) (n : RuleName) : Bool :=\n  rs.erased.contains n", "start": [287, 1], "end": [289, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.containsSimpAttrNormSimpLemma", "code": "def containsSimpAttrNormSimpLemma (rs : RuleSet) (decl : Name) : Bool :=\n  rs.simpAttrNormSimpLemmas.any \u03bb (_, simpTheorems) =>\n    simpTheoremsContains simpTheorems decl", "start": [291, 1], "end": [293, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.contains", "code": "def contains (rs : RuleSet) (n : RuleName) : Bool :=\n  ! rs.isErased n &&\n  ((n.builder == .simp && n.scope == .global &&\n    rs.containsSimpAttrNormSimpLemma n.name) ||\n  match rs.ruleNames.find? n.toRuleIdent with\n  | none => false\n  | some ns => ns.contains n)", "start": [295, 1], "end": [301, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.rulesMatching", "code": "def rulesMatching (rs : RuleSet) (f : RuleNameFilter) :\n    UnorderedArraySet RuleName :=\n  match rs.ruleNames.find? f.ident with\n  | none => \u2205\n  | some ns => ns.filter f.match", "start": [304, 1], "end": [308, 33], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.applicableNormalizationRules", "code": "def applicableNormalizationRules (rs : RuleSet) (goal : MVarId) :\n    MetaM (Array (IndexMatchResult NormRule)) :=\n  rs.normRules.applicableRules (ord := \u27e8Rule.compareByPriorityThenName\u27e9) goal\n    (!rs.isErased \u00b7.name)", "start": [310, 1], "end": [313, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.applicableUnsafeRules", "code": "def applicableUnsafeRules (rs : RuleSet) (goal : MVarId) :\n    MetaM (Array (IndexMatchResult UnsafeRule)) := do\n  rs.unsafeRules.applicableRules (ord := \u27e8Rule.compareByPriorityThenName\u27e9) goal\n    (!rs.isErased \u00b7.name)", "start": [315, 1], "end": [318, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.applicableSafeRules", "code": "def applicableSafeRules (rs : RuleSet) (goal : MVarId) :\n    MetaM (Array (IndexMatchResult SafeRule)) := do\n  rs.safeRules.applicableRules (ord := \u27e8Rule.compareByPriorityThenName\u27e9) goal\n    (!rs.isErased \u00b7.name)", "start": [320, 1], "end": [323, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSet.globalNormSimpTheorems", "code": "def globalNormSimpTheorems (rs : RuleSet) : SimpTheoremsArray :=\n  Array.mkEmpty (rs.simpAttrNormSimpLemmas.size + 1)\n    |>.append (rs.simpAttrNormSimpLemmas.map (\u00b7.snd))\n    |>.push rs.normSimpLemmas", "start": [325, 1], "end": [328, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSetName", "code": "abbrev RuleSetName := Name", "start": [333, 1], "end": [333, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.defaultRuleSetName", "code": "def defaultRuleSetName : RuleSetName := `default", "start": [335, 1], "end": [335, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.builtinRuleSetName", "code": "def builtinRuleSetName : RuleSetName := `builtin", "start": [337, 1], "end": [337, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.localRuleSetName", "code": "def localRuleSetName : RuleSetName := `local", "start": [339, 1], "end": [339, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.builtinRuleSetNames", "code": "def builtinRuleSetNames : Array RuleSetName :=\n  #[defaultRuleSetName, builtinRuleSetName, localRuleSetName]", "start": [341, 1], "end": [342, 62], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSetName.isReserved", "code": "def RuleSetName.isReserved (n : RuleSetName) : Bool :=\n  builtinRuleSetNames.contains n", "start": [344, 1], "end": [345, 33], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSetNameFilter", "code": "structure RuleSetNameFilter where\n  ns : Array RuleSetName", "start": [347, 1], "end": [348, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSetNameFilter.all", "code": "protected def all : RuleSetNameFilter :=\n  \u27e8#[]\u27e9", "start": [352, 1], "end": [353, 8], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSetNameFilter.matchesAll", "code": "def matchesAll (f : RuleSetNameFilter) : Bool :=\n  f.ns.isEmpty", "start": [355, 1], "end": [356, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSetNameFilter.match", "code": "def \u00abmatch\u00bb (f : RuleSetNameFilter) (n : RuleSetName) : Bool :=\n  f.matchesAll || f.ns.contains n", "start": [358, 1], "end": [359, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSetNameFilter.matchedRuleSetNames", "code": "def matchedRuleSetNames (f : RuleSetNameFilter) : Option (Array RuleSetName) :=\n  if f.matchesAll then\n    none\n  else\n    some f.ns", "start": [361, 1], "end": [365, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets", "code": "structure RuleSets where\n  rs : HashMap RuleSetName RuleSet\n  deriving Inhabited", "start": [370, 1], "end": [372, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.empty", "code": "protected def empty : RuleSets where\n  rs := \u2205", "start": [376, 1], "end": [377, 10], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.trace", "code": "def trace (rss : RuleSets) (opt : TraceOption) : CoreM Unit := do\n  for (rsName, rs) in rss.rs.toArray.qsort compareRuleSets do\n    withConstAesopTraceNode opt (return m!\"Rule set {rsName}\") do\n      rs.trace opt\n  where\n    compareRuleSets (x y : RuleSetName \u00d7 RuleSet) : Bool :=\n      x.fst.cmp y.fst |>.isLT", "start": [382, 1], "end": [388, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.addEmptyRuleSet", "code": "def addEmptyRuleSet (rss : RuleSets) (rsName : RuleSetName) : RuleSets :=\n  \u27e8rss.rs.insert rsName {}\u27e9", "start": [391, 1], "end": [392, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.addRuleSet", "code": "def addRuleSet (rss : RuleSets) (rsName : RuleSetName) (rs : RuleSet) :\n    RuleSets :=\n  \u27e8rss.rs.insert rsName rs\u27e9", "start": [395, 1], "end": [397, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.containsRuleSet", "code": "def containsRuleSet (rss : RuleSets) (name : RuleSetName) : Bool :=\n  rss.rs.contains name", "start": [399, 1], "end": [400, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.ensureRuleSet", "code": "def ensureRuleSet (rss : RuleSets) (name : RuleSetName) : RuleSets :=\n  if rss.containsRuleSet name then\n    rss\n  else\n    rss.addEmptyRuleSet name", "start": [403, 1], "end": [407, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.eraseRuleSet", "code": "def eraseRuleSet (rss : RuleSets) (rsName : RuleSetName) : RuleSets :=\n  \u27e8rss.rs.erase rsName\u27e9", "start": [411, 1], "end": [412, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.getRuleSet?", "code": "def getRuleSet? (rss : RuleSets) (rsName : RuleSetName) : Option RuleSet :=\n  rss.rs.find? rsName", "start": [414, 1], "end": [415, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.modifyRuleSetM", "code": "@[inline]\ndef modifyRuleSetM [Monad m] (rss : RuleSets) (rsName : RuleSetName)\n    (f : RuleSet \u2192 m RuleSet) : m RuleSets := do\n  let (some rs) := rss.getRuleSet? rsName\n    | return rss\n  return \u27e8rss.rs.insert rsName (\u2190 f rs)\u27e9", "start": [419, 1], "end": [424, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.modifyRuleSet", "code": "@[inline]\ndef modifyRuleSet (rss : RuleSets) (rsName : RuleSetName)\n    (f : RuleSet \u2192 RuleSet) : RuleSets :=\n  Id.run $ rss.modifyRuleSetM rsName (\u03bb rs => pure $ f rs)", "start": [428, 1], "end": [431, 59], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.containsRule", "code": "def containsRule (rss : RuleSets) (rsName : RuleSetName) (rName : RuleName) :\n    Bool :=\n  match rss.getRuleSet? rsName with\n  | none => false\n  | some rs => rs.contains rName", "start": [433, 1], "end": [437, 33], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.addRuleUnchecked", "code": "def addRuleUnchecked (rss : RuleSets) (rsName : RuleSetName) (r : RuleSetMember) :\n    RuleSets :=\n  rss.modifyRuleSet rsName (\u00b7.add r)", "start": [440, 1], "end": [442, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.addRuleChecked", "code": "def addRuleChecked [Monad m] [MonadError m] (rss : RuleSets)\n    (rsName : RuleSetName) (rule : RuleSetMember) : m RuleSets := do\n  if ! rss.containsRuleSet rsName then throwError\n    \"aesop: no such rule set: '{rsName}'\\n  (Use 'declare_aesop_rule_set' to declare rule sets.\\n   Declared rule sets are not visible in the current file; they only become visible once you import the declaring file.)\"\n  if rss.containsRule rsName rule.name then throwError\n    \"aesop: rule '{rule.name.name}' is already registered in rule set '{rsName}'\"\n  return rss.addRuleUnchecked rsName rule", "start": [444, 1], "end": [450, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.eraseRules", "code": "def eraseRules (rss : RuleSets) (rsf : RuleSetNameFilter)\n    (rf : RuleNameFilter) : RuleSets \u00d7 Bool :=\n  rss.rs.fold (init := (rss, false)) \u03bb (rss, anyErased) rsName rs =>\n    if rsf.match rsName then\n      let (rs, rsErased) := rs.erase rf\n      if rsErased then\n        (\u27e8rss.rs.insert rsName rs\u27e9, true)\n      else\n        (rss, anyErased)\n    else\n      (rss, anyErased)", "start": [454, 1], "end": [464, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.eraseRulesChecked", "code": "def eraseRulesChecked [Monad m] [MonadError m] (rss : RuleSets)\n    (rsf : RuleSetNameFilter) (rf : RuleNameFilter) : m RuleSets := do\n  let (rss, anyErased) := rss.eraseRules rsf rf\n  unless anyErased do\n    let rsNames? := rsf.matchedRuleSetNames\n    match rsNames? with\n    | none => throwError \"aesop: '{rf.ident.name}' is not registered (with the given features) in any rule set.\"\n    | some rsNames => throwError \"aesop: '{rf.ident.name}' is not registered (with the given features) in any of the rule sets {rsNames.map toString}.\"\n  return rss", "start": [466, 1], "end": [474, 13], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.unindexPredicate?", "code": "@[inline, always_inline]\ndef unindexPredicate? (options : Options) : Option (RuleName \u2192 Bool) :=\n  if options.destructProductsTransparency == .reducible then\n    none\n  else\n    some \u03bb n => n.name == `Aesop.BuiltinRules.destructProducts", "start": [476, 1], "end": [481, 63], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleSets.getMergedRuleSet", "code": "def getMergedRuleSet (rss : RuleSets) (options : Options) :\n    RuleSet :=\n  let update : RuleSet \u2192 RuleSet :=\n    match unindexPredicate? options with\n    | none => id\n    | some p => \u03bb rs => rs.unindex p\n  rss.rs.fold (init := \u2205) \u03bb result _ rs => result.merge (update rs)", "start": [483, 1], "end": [489, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Nonempty.lean", "imports": ["Mathlib/Init/ZeroOne.lean", "Mathlib/Logic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Zero.nonempty", "code": "instance (priority := 20) Zero.nonempty [Zero \u03b1] : Nonempty \u03b1 :=\n  \u27e80\u27e9", "start": [28, 1], "end": [29, 6], "kind": "commanddeclaration"}, {"full_name": "One.nonempty", "code": "instance (priority := 20) One.nonempty [One \u03b1] : Nonempty \u03b1 :=\n  \u27e81\u27e9", "start": [31, 1], "end": [32, 6], "kind": "commanddeclaration"}, {"full_name": "exists_true_iff_nonempty", "code": "theorem exists_true_iff_nonempty {\u03b1 : Sort*} : (\u2203 _ : \u03b1, True) \u2194 Nonempty \u03b1", "start": [34, 1], "end": [35, 54], "kind": "commanddeclaration"}, {"full_name": "nonempty_Prop", "code": "@[simp]\ntheorem nonempty_Prop {p : Prop} : Nonempty p \u2194 p", "start": [38, 1], "end": [40, 38], "kind": "commanddeclaration"}, {"full_name": "not_nonempty_iff_imp_false", "code": "theorem not_nonempty_iff_imp_false {\u03b1 : Sort*} : \u00acNonempty \u03b1 \u2194 \u03b1 \u2192 False", "start": [43, 1], "end": [44, 37], "kind": "commanddeclaration"}, {"full_name": "nonempty_sigma", "code": "@[simp]\ntheorem nonempty_sigma : Nonempty (\u03a3a : \u03b1, \u03b3 a) \u2194 \u2203 a : \u03b1, Nonempty (\u03b3 a)", "start": [47, 1], "end": [49, 62], "kind": "commanddeclaration"}, {"full_name": "nonempty_psigma", "code": "@[simp]\ntheorem nonempty_psigma {\u03b1} {\u03b2 : \u03b1 \u2192 Sort*} : Nonempty (PSigma \u03b2) \u2194 \u2203 a : \u03b1, Nonempty (\u03b2 a)", "start": [52, 1], "end": [54, 62], "kind": "commanddeclaration"}, {"full_name": "nonempty_subtype", "code": "@[simp]\ntheorem nonempty_subtype {\u03b1} {p : \u03b1 \u2192 Prop} : Nonempty (Subtype p) \u2194 \u2203 a : \u03b1, p a", "start": [57, 1], "end": [59, 58], "kind": "commanddeclaration"}, {"full_name": "nonempty_prod", "code": "@[simp]\ntheorem nonempty_prod : Nonempty (\u03b1 \u00d7 \u03b2) \u2194 Nonempty \u03b1 \u2227 Nonempty \u03b2", "start": [62, 1], "end": [64, 66], "kind": "commanddeclaration"}, {"full_name": "nonempty_pprod", "code": "@[simp]\ntheorem nonempty_pprod {\u03b1 \u03b2} : Nonempty (PProd \u03b1 \u03b2) \u2194 Nonempty \u03b1 \u2227 Nonempty \u03b2", "start": [67, 1], "end": [69, 66], "kind": "commanddeclaration"}, {"full_name": "nonempty_sum", "code": "@[simp]\ntheorem nonempty_sum : Nonempty (Sum \u03b1 \u03b2) \u2194 Nonempty \u03b1 \u2228 Nonempty \u03b2", "start": [72, 1], "end": [82, 32], "kind": "commanddeclaration"}, {"full_name": "nonempty_psum", "code": "@[simp]\ntheorem nonempty_psum {\u03b1 \u03b2} : Nonempty (PSum \u03b1 \u03b2) \u2194 Nonempty \u03b1 \u2228 Nonempty \u03b2", "start": [85, 1], "end": [95, 33], "kind": "commanddeclaration"}, {"full_name": "nonempty_ulift", "code": "@[simp]\ntheorem nonempty_ulift : Nonempty (ULift \u03b1) \u2194 Nonempty \u03b1", "start": [98, 1], "end": [100, 46], "kind": "commanddeclaration"}, {"full_name": "nonempty_plift", "code": "@[simp]\ntheorem nonempty_plift {\u03b1} : Nonempty (PLift \u03b1) \u2194 Nonempty \u03b1", "start": [103, 1], "end": [105, 46], "kind": "commanddeclaration"}, {"full_name": "Nonempty.forall", "code": "@[simp]\ntheorem Nonempty.forall {\u03b1} {p : Nonempty \u03b1 \u2192 Prop} : (\u2200 h : Nonempty \u03b1, p h) \u2194 \u2200 a, p \u27e8a\u27e9", "start": [108, 1], "end": [110, 44], "kind": "commanddeclaration"}, {"full_name": "Nonempty.exists", "code": "@[simp]\ntheorem Nonempty.exists {\u03b1} {p : Nonempty \u03b1 \u2192 Prop} : (\u2203 h : Nonempty \u03b1, p h) \u2194 \u2203 a, p \u27e8a\u27e9", "start": [113, 1], "end": [115, 58], "kind": "commanddeclaration"}, {"full_name": "Classical.inhabited_of_nonempty'", "code": "noncomputable def Classical.inhabited_of_nonempty' {\u03b1} [h : Nonempty \u03b1] : Inhabited \u03b1 :=\n  \u27e8Classical.choice h\u27e9", "start": [118, 1], "end": [123, 23], "kind": "commanddeclaration"}, {"full_name": "Nonempty.some", "code": "@[reducible]\nprotected noncomputable def Nonempty.some {\u03b1} (h : Nonempty \u03b1) : \u03b1 :=\n  Classical.choice h", "start": [126, 1], "end": [129, 21], "kind": "commanddeclaration"}, {"full_name": "Classical.arbitrary", "code": "@[reducible]\nprotected noncomputable def Classical.arbitrary (\u03b1) [h : Nonempty \u03b1] : \u03b1 :=\n  Classical.choice h", "start": [132, 1], "end": [135, 21], "kind": "commanddeclaration"}, {"full_name": "Nonempty.map", "code": "theorem Nonempty.map {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) : Nonempty \u03b1 \u2192 Nonempty \u03b2", "start": [138, 1], "end": [141, 17], "kind": "commanddeclaration"}, {"full_name": "Nonempty.map2", "code": "protected theorem Nonempty.map2 {\u03b1 \u03b2 \u03b3 : Sort*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    Nonempty \u03b1 \u2192 Nonempty \u03b2 \u2192 Nonempty \u03b3", "start": [144, 1], "end": [146, 24], "kind": "commanddeclaration"}, {"full_name": "Nonempty.congr", "code": "protected theorem Nonempty.congr {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) : Nonempty \u03b1 \u2194 Nonempty \u03b2", "start": [149, 1], "end": [150, 35], "kind": "commanddeclaration"}, {"full_name": "Nonempty.elim_to_inhabited", "code": "theorem Nonempty.elim_to_inhabited {\u03b1 : Sort*} [h : Nonempty \u03b1] {p : Prop} (f : Inhabited \u03b1 \u2192 p) :\n    p", "start": [153, 1], "end": [155, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.Nonempty", "code": "protected instance Prod.Nonempty {\u03b1 \u03b2} [h : Nonempty \u03b1] [h2 : Nonempty \u03b2] : Nonempty (\u03b1 \u00d7 \u03b2) :=\n  h.elim fun g \u21a6 h2.elim fun g2 \u21a6 \u27e8\u27e8g, g2\u27e9\u27e9", "start": [158, 1], "end": [159, 44], "kind": "commanddeclaration"}, {"full_name": "Pi.Nonempty", "code": "protected instance Pi.Nonempty {\u03b9 : Sort*} {\u03b1 : \u03b9 \u2192 Sort*} [\u2200 i, Nonempty (\u03b1 i)] :\n    Nonempty (\u2200 i, \u03b1 i) :=\n  \u27e8fun _ \u21a6 Classical.arbitrary _\u27e9", "start": [161, 1], "end": [163, 34], "kind": "commanddeclaration"}, {"full_name": "Classical.nonempty_pi", "code": "theorem Classical.nonempty_pi {\u03b9} {\u03b1 : \u03b9 \u2192 Sort*} : Nonempty (\u2200 i, \u03b1 i) \u2194 \u2200 i, Nonempty (\u03b1 i)", "start": [165, 1], "end": [166, 40], "kind": "commanddeclaration"}, {"full_name": "subsingleton_of_not_nonempty", "code": "theorem subsingleton_of_not_nonempty {\u03b1 : Sort*} (h : \u00acNonempty \u03b1) : Subsingleton \u03b1", "start": [169, 1], "end": [170, 60], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonempty", "code": "theorem Function.Surjective.nonempty [h : Nonempty \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Function.Surjective f) :\n    Nonempty \u03b1", "start": [173, 1], "end": [177, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Set.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Classes/SetNotation.lean", "lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set", "code": "def Set (\u03b1 : Type u) := \u03b1 \u2192 Prop", "start": [38, 1], "end": [38, 33], "kind": "commanddeclaration"}, {"full_name": "setOf", "code": "def setOf {\u03b1 : Type u} (p : \u03b1 \u2192 Prop) : Set \u03b1 :=\n  p", "start": [41, 1], "end": [42, 4], "kind": "commanddeclaration"}, {"full_name": "Set.Mem", "code": "protected def Mem (a : \u03b1) (s : Set \u03b1) : Prop :=\n  s a", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Set.ext", "code": "theorem ext {a b : Set \u03b1} (h : \u2200 (x : \u03b1), x \u2208 a \u2194 x \u2208 b) : a = b", "start": [54, 1], "end": [55, 33], "kind": "commanddeclaration"}, {"full_name": "Set.Subset", "code": "protected def Subset (s\u2081 s\u2082 : Set \u03b1) :=\n  \u2200 \u2983a\u2984, a \u2208 s\u2081 \u2192 a \u2208 s\u2082", "start": [57, 1], "end": [58, 25], "kind": "commanddeclaration"}, {"full_name": "Set.setOf.unexpander", "code": "@[app_unexpander setOf]\ndef setOf.unexpander : Lean.PrettyPrinter.Unexpander\n  | `($_ fun $x:ident \u21a6 $p) => `({ $x:ident | $p })\n  | `($_ fun ($x:ident : $ty:term) \u21a6 $p) => `({ $x:ident : $ty:term | $p })\n  | _ => throw ()", "start": [80, 1], "end": [84, 18], "kind": "commanddeclaration"}, {"full_name": "Set.univ", "code": "def univ : Set \u03b1 := {_a | True}", "start": [90, 1], "end": [90, 32], "kind": "commanddeclaration"}, {"full_name": "Set.insert", "code": "protected def insert (a : \u03b1) (s : Set \u03b1) : Set \u03b1 := {b | b = a \u2228 b \u2208 s}", "start": [93, 1], "end": [93, 72], "kind": "commanddeclaration"}, {"full_name": "Set.singleton", "code": "protected def singleton (a : \u03b1) : Set \u03b1 := {b | b = a}", "start": [97, 1], "end": [97, 55], "kind": "commanddeclaration"}, {"full_name": "Set.instSingletonSet", "code": "instance instSingletonSet : Singleton \u03b1 (Set \u03b1) := \u27e8Set.singleton\u27e9", "start": [99, 1], "end": [99, 67], "kind": "commanddeclaration"}, {"full_name": "Set.union", "code": "protected def union (s\u2081 s\u2082 : Set \u03b1) : Set \u03b1 := {a | a \u2208 s\u2081 \u2228 a \u2208 s\u2082}", "start": [101, 1], "end": [101, 69], "kind": "commanddeclaration"}, {"full_name": "Set.inter", "code": "protected def inter (s\u2081 s\u2082 : Set \u03b1) : Set \u03b1 := {a | a \u2208 s\u2081 \u2227 a \u2208 s\u2082}", "start": [105, 1], "end": [105, 69], "kind": "commanddeclaration"}, {"full_name": "Set.compl", "code": "protected def compl (s : Set \u03b1) : Set \u03b1 := {a | a \u2209 s}", "start": [109, 1], "end": [109, 55], "kind": "commanddeclaration"}, {"full_name": "Set.diff", "code": "protected def diff (s t : Set \u03b1) : Set \u03b1 := {a \u2208 s | a \u2209 t}", "start": [111, 1], "end": [111, 60], "kind": "commanddeclaration"}, {"full_name": "Set.powerset", "code": "def powerset (s : Set \u03b1) : Set (Set \u03b1) := {t | t \u2286 s}", "start": [115, 1], "end": [115, 54], "kind": "commanddeclaration"}, {"full_name": "Set.image", "code": "def image (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Set \u03b2 := {f a | a \u2208 s}", "start": [119, 1], "end": [119, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormCast/Tactic.lean", "imports": ["lake-packages/std/Std/Tactic/NormCast/Ext.lean", "lake-packages/std/Std/Tactic/CoeExt.lean", "Mathlib/Lean/Meta/Simp.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Classes/Cast.lean"], "premises": [{"full_name": "Tactic.NormCast.proveEqUsing", "code": "def proveEqUsing (s : SimpTheorems) (a b : Expr) : MetaM (Option Simp.Result) := do\n  let go : SimpM (Option Simp.Result) := do\n    let methods := Simp.DefaultMethods.methods\n    let a' \u2190 Simp.simp a methods\n    let b' \u2190 Simp.simp b methods\n    unless \u2190 isDefEq a'.expr b'.expr do return none\n    mkEqTrans a' (\u2190 mkEqSymm b b')\n  withReducible do\n    (go { simpTheorems := #[s], congrTheorems := \u2190 Meta.getSimpCongrTheorems }).run' {}", "start": [20, 1], "end": [29, 88], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.proveEqUsingDown", "code": "def proveEqUsingDown (a b : Expr) : MetaM (Option Simp.Result) := do\n  withTraceNode `Tactic.norm_cast (return m!\"{exceptOptionEmoji \u00b7} proving: {\u2190 mkEq a b}\") do\n  proveEqUsing (\u2190 normCastExt.down.getTheorems) a b", "start": [31, 1], "end": [34, 52], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.mkCoe", "code": "def mkCoe (e : Expr) (ty : Expr) : MetaM Expr := do\n  let .some e' \u2190 coerce? e ty | failure\n  return e'", "start": [36, 1], "end": [38, 12], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.isCoeOf?", "code": "def isCoeOf? (e : Expr) : MetaM (Option Expr) := do\n  if let Expr.const fn .. := e.getAppFn then\n    if let some info \u2190 getCoeFnInfo? fn then\n      if e.getAppNumArgs == info.numArgs then\n        return e.getArg! info.coercee\n  return none", "start": [40, 1], "end": [45, 14], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.isNumeral?", "code": "def isNumeral? (e : Expr) : Option (Expr \u00d7 Nat) :=\n  if e.isConstOf ``Nat.zero then\n    (mkConst ``Nat, 0)\n  else if let Expr.app (Expr.app (Expr.app (Expr.const ``OfNat.ofNat ..) \u03b1 ..)\n      (Expr.lit (Literal.natVal n) ..) ..) .. := e then\n    some (\u03b1, n)\n  else\n    none", "start": [47, 1], "end": [54, 9], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.splittingProcedure", "code": "def splittingProcedure (expr : Expr) : MetaM Simp.Result := do\n  let Expr.app (Expr.app op x ..) y .. := expr | return {expr}\n\n  let Expr.forallE _ \u03b3 (Expr.forallE _ \u03b3' ty ..) .. \u2190 inferType op | return {expr}\n  if \u03b3'.hasLooseBVars || ty.hasLooseBVars then return {expr}\n  unless \u2190 isDefEq \u03b3 \u03b3' do return {expr}\n\n  let msg := m!\"splitting {expr}\"\n  let msg\n    | .error _ => return m!\"{bombEmoji} {msg}\"\n    | .ok r => return if r.expr == expr then m!\"{crossEmoji} {msg}\" else\n      m!\"{checkEmoji} {msg} to {r.expr}\"\n  withTraceNode `Tactic.norm_cast msg do\n\n  try\n    let some x' \u2190 isCoeOf? x | failure\n    let some y' \u2190 isCoeOf? y | failure\n    let \u03b1 \u2190 inferType x'\n    let \u03b2 \u2190 inferType y'\n\n    (try\n      let x2 \u2190 mkCoe (\u2190 mkCoe x' \u03b2) \u03b3\n      let some x_x2 \u2190 proveEqUsingDown x x2 | failure\n      Simp.mkCongrFun (\u2190 Simp.mkCongr {expr := op} x_x2) y\n    catch _ =>\n      let y2 \u2190 mkCoe (\u2190 mkCoe y' \u03b1) \u03b3\n      let some y_y2 \u2190 proveEqUsingDown y y2 | failure\n      Simp.mkCongr {expr := mkApp op x} y_y2)\n  catch _ => try\n    let some (_, n) := isNumeral? y | failure\n    let some x' \u2190 isCoeOf? x | failure\n    let \u03b1 \u2190 inferType x'\n    let y2 \u2190 mkCoe (\u2190 mkNumeral \u03b1 n) \u03b3\n    let some y_y2 \u2190 proveEqUsingDown y y2 | failure\n    Simp.mkCongr {expr := mkApp op x} y_y2\n  catch _ => try\n    let some (_, n) := isNumeral? x | failure\n    let some y' \u2190 isCoeOf? y | failure\n    let \u03b2 \u2190 inferType y'\n    let x2 \u2190 mkCoe (\u2190 mkNumeral \u03b2 n) \u03b3\n    let some x_x2 \u2190 proveEqUsingDown x x2 | failure\n    Simp.mkCongrFun (\u2190 Simp.mkCongr {expr := op} x_x2) y\n  catch _ =>\n    return {expr}", "start": [56, 1], "end": [107, 18], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.prove", "code": "def prove (e : Expr) : SimpM (Option Expr) := do\n  withTraceNode `Tactic.norm_cast (return m!\"{exceptOptionEmoji \u00b7} discharging: {e}\") do\n  return (\u2190 findLocalDeclWithType? e).map mkFVar", "start": [109, 1], "end": [117, 49], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.upwardAndElim", "code": "partial def upwardAndElim (up : SimpTheorems) (e : Expr) : SimpM Simp.Step := do\n  let r \u2190 Simp.rewrite? e up.post up.erased prove (tag := \"squash\") (rflOnly := false)\n  let r := r.getD { expr := e }\n  let r \u2190 mkEqTrans r <|\u2190 splittingProcedure r.expr\n  if r.expr == e then return Simp.Step.done {expr := e}\n  return Simp.Step.visit r", "start": [119, 1], "end": [131, 27], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.numeralToCoe", "code": "def numeralToCoe (e : Expr) : MetaM Simp.Result := do\n  let some (\u03b1, n) := isNumeral? e | failure\n  if (\u2190 whnf \u03b1).isConstOf ``Nat then failure\n  let newE \u2190 mkAppOptM ``Nat.cast #[\u03b1, none, toExpr n]\n  let some pr \u2190 proveEqUsingDown e newE | failure\n  return pr", "start": [133, 1], "end": [142, 12], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.derive", "code": "def derive (e : Expr) : MetaM Simp.Result := do\n  withTraceNode `Tactic.norm_cast (fun _ => return m!\"{e}\") do\n  let e \u2190 instantiateMVars e\n\n  let config : Simp.Config := {\n    zeta := false\n    beta := false\n    eta  := false\n    proj := false\n    iota := false\n  }\n  let congrTheorems \u2190 Meta.getSimpCongrTheorems\n\n  let r := {expr := e}\n\n  let withTrace phase := withTraceNode `Tactic.norm_cast fun\n    | .ok r => return m!\"{r.expr} (after {phase})\"\n    | .error _ => return m!\"{bombEmoji} {phase}\"\n\n  let r \u2190 withTrace \"pre-processing numerals\" do\n    let post e := return Simp.Step.done (\u2190 try numeralToCoe e catch _ => pure {expr := e})\n    Simp.mkEqTrans r (\u2190 Simp.main r.expr { config, congrTheorems } (methods := { post })).1\n\n  let r \u2190 withTrace \"moving upward, splitting and eliminating\" do\n    let post := upwardAndElim (\u2190 normCastExt.up.getTheorems)\n    Simp.mkEqTrans r (\u2190 Simp.main r.expr { config, congrTheorems } (methods := { post })).1\n\n  let r \u2190 withTrace \"squashing\" do\n    let simpTheorems := #[\u2190 normCastExt.squash.getTheorems]\n    mkEqTrans r (\u2190 simp r.expr { simpTheorems, config, congrTheorems }).1\n\n  return r", "start": [144, 1], "end": [181, 11], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.normCastTarget", "code": "def normCastTarget : TacticM Unit :=\n  liftMetaTactic1 fun goal \u21a6 do\n    let tgt \u2190 instantiateMVars (\u2190 goal.getType)\n    let prf \u2190 derive tgt\n    applySimpResultToTarget goal tgt prf", "start": [199, 1], "end": [203, 41], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.normCastHyp", "code": "def normCastHyp (fvarId : FVarId) : TacticM Unit :=\n  liftMetaTactic1 fun goal \u21a6 do\n    let hyp \u2190 instantiateMVars (\u2190 fvarId.getDecl).type\n    let prf \u2190 derive hyp\n    return (\u2190 applySimpResultToLocalDecl goal fvarId prf false).map (\u00b7.snd)", "start": [205, 1], "end": [209, 76], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.evalConvNormCast", "code": "@[tactic convNormCast] def evalConvNormCast : Tactic :=\n  open Elab.Tactic.Conv in fun _ \u21a6 withMainContext do\n    applySimpResult (\u2190 derive (\u2190 getLhs))", "start": [252, 1], "end": [254, 42], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormCast.evalPushCast", "code": "@[tactic pushCast] def evalPushCast : Tactic := fun stx \u21a6 do\n  let { ctx, dischargeWrapper, .. } \u2190 withMainContext do\n    mkSimpContext' (\u2190 pushCastExt.getTheorems) stx (eraseLocal := false)\n  let ctx := { ctx with config := { ctx.config with failIfUnchanged := false } }\n  dischargeWrapper.with fun discharge? \u21a6\n    discard <| simpLocation ctx discharge? (expandOptLocation stx[5])", "start": [258, 1], "end": [263, 70], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Profiling.lean", "imports": ["lake-packages/aesop/Aesop/Tree/Data.lean", "lake-packages/aesop/Aesop/Nanos.lean", "lake-packages/aesop/Aesop/Tracing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleProfile", "code": "structure RuleProfile where\n  rule : DisplayRuleName\n  elapsed : Nanos\n  successful : Bool\n  deriving Inhabited", "start": [17, 1], "end": [21, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Profile", "code": "structure Profile where\n  total : Nanos\n  configParsing : Nanos\n  ruleSetConstruction : Nanos\n  search : Nanos\n  ruleSelection : Nanos\n  ruleApplications : Array RuleProfile\n  deriving Inhabited", "start": [34, 1], "end": [41, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Profile.empty", "code": "protected def empty : Profile where\n  total := 0\n  configParsing := 0\n  ruleSetConstruction := 0\n  search := 0\n  ruleSelection := 0\n  ruleApplications := #[]", "start": [45, 1], "end": [51, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.Profile.ruleApplicationTotals", "code": "def ruleApplicationTotals (p : Profile) :\n    HashMap DisplayRuleName (Nanos \u00d7 Nanos) := Id.run do\n  let mut m := {}\n  for rp in p.ruleApplications do\n    if rp.successful then\n      m :=\n        match m.find? rp.rule with\n        | none => m.insert rp.rule (rp.elapsed, 0)\n        | some (successful, failed) =>\n          m.insert rp.rule (successful + rp.elapsed, failed)\n    else\n      m :=\n        match m.find? rp.rule with\n        | none => m.insert rp.rule (0, rp.elapsed)\n        | some (successful, failed) =>\n          m.insert rp.rule (successful, failed + rp.elapsed)\n  return m", "start": [58, 1], "end": [74, 11], "kind": "commanddeclaration"}, {"full_name": "Aesop.Profile.trace", "code": "def trace (p : Profile) (opt : TraceOption) : CoreM Unit := do\n  if ! (\u2190 opt.isEnabled) then\n    return\n  let totalRuleApplications :=\n    p.ruleApplications.foldl (init := 0) \u03bb total rp =>\n      total + rp.elapsed\n  aesop_trace![opt] \"Total: {p.total.printAsMillis}\"\n  aesop_trace![opt] \"Configuration parsing: {p.configParsing.printAsMillis}\"\n  aesop_trace![opt] \"Rule set construction: {p.ruleSetConstruction.printAsMillis}\"\n  withConstAesopTraceNode opt (collapsed := false)\n      (return m!\"Search: {p.search.printAsMillis}\") do\n    aesop_trace![opt] \"Rule selection: {p.ruleSelection.printAsMillis}\"\n    withConstAesopTraceNode opt (collapsed := false)\n        (return m!\"Rule applications: {totalRuleApplications.printAsMillis}\") do\n      let timings :=\n        p.ruleApplicationTotals.fold\n          (init := Array.mkEmpty p.ruleApplicationTotals.size)\n          \u03bb timings n (successful, failed) =>\n            timings.push (n, successful, failed)\n      let timings := timings.qsortOrd (ord := \u27e8compareTimings\u27e9)\n      for (n, s, f) in timings do\n        aesop_trace![opt] \"[{(s + f).printAsMillis} / {s.printAsMillis} / {f.printAsMillis}] {n}\"\n  where\n    compareTimings (x y : DisplayRuleName \u00d7 Nanos \u00d7 Nanos) : Ordering :=\n      compareLex\n        (compareOn (\u03bb (_, s, f) => s + f))\n        (compareOn (\u03bb (n, _, _) => n))\n        x y\n      |>.swap", "start": [76, 1], "end": [104, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.ProfileT.Context", "code": "structure Context where\n  isProfilingEnabled : Bool", "start": [111, 1], "end": [112, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.ProfileT", "code": "abbrev ProfileT m :=\n  ReaderT ProfileT.Context $ StateRefT' IO.RealWorld Profile m", "start": [116, 1], "end": [117, 63], "kind": "commanddeclaration"}, {"full_name": "Aesop.ProfileT.run", "code": "protected def run [Monad m] [MonadLiftT (ST IO.RealWorld) m] (x : ProfileT m \u03b1)\n    (isProfilingEnabled : Bool) (profile : Profile) : m (\u03b1 \u00d7 Profile) :=\n  ReaderT.run x { isProfilingEnabled } |>.run profile", "start": [121, 1], "end": [123, 54], "kind": "commanddeclaration"}, {"full_name": "Aesop.isProfilingEnabled", "code": "@[inline, always_inline]\ndef isProfilingEnabled [MonadProfile m] : m Bool :=\n  return (\u2190 read).isProfilingEnabled", "start": [134, 1], "end": [136, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.recordRuleSelectionProfile", "code": "@[inline, always_inline]\ndef recordRuleSelectionProfile (elapsed : Nanos) : m Unit :=\n  modify \u03bb p => { p with ruleSelection := p.ruleSelection + elapsed }", "start": [138, 1], "end": [140, 70], "kind": "commanddeclaration"}, {"full_name": "Aesop.recordRuleProfile", "code": "@[inline, always_inline]\ndef recordRuleProfile (rp : RuleProfile) : m Unit :=\n  modify \u03bb p => { p with ruleApplications := p.ruleApplications.push rp }", "start": [142, 1], "end": [144, 74], "kind": "commanddeclaration"}, {"full_name": "Aesop.profiling", "code": "@[inline, always_inline]\ndef profiling [MonadLiftT BaseIO m] (x : m \u03b1)\n    (recordProfile : \u03b1 \u2192 Nanos \u2192 m Unit) : m \u03b1 := do\n  if \u2190 isProfilingEnabled then\n    let (result, elapsed) \u2190 time x\n    recordProfile result elapsed\n    return result\n  else\n    x", "start": [146, 1], "end": [154, 6], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Search/Queue/Class.lean", "imports": ["lake-packages/aesop/Aesop/Tree.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Queue", "code": "class Queue (Q : Type) where\n  init : BaseIO Q\n  addGoals : Q \u2192 Array GoalRef \u2192 BaseIO Q\n  popGoal : Q \u2192 BaseIO (Option GoalRef \u00d7 Q)", "start": [13, 1], "end": [16, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.Queue.init'", "code": "def init' [Queue Q] (grefs : Array GoalRef) : BaseIO Q := do\n  addGoals (\u2190 init) grefs", "start": [20, 1], "end": [21, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Search/Expansion/Simp.lean", "imports": ["lake-packages/aesop/Aesop/RuleSet.lean", "lake-packages/aesop/Aesop/Script.lean", "lake-packages/aesop/Aesop/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.SimpResult", "code": "inductive SimpResult\n  | solved (usedTheorems : Simp.UsedSimps)\n  | unchanged (newGoal : MVarId)\n  | simplified (newGoal : MVarId) (usedTheorems : UsedSimps)", "start": [16, 1], "end": [19, 61], "kind": "commanddeclaration"}, {"full_name": "Aesop.SimpResult.newGoal?", "code": "def newGoal? : SimpResult \u2192 Option MVarId\n  | solved .. => none\n  | unchanged g => some g\n  | simplified g .. => some g", "start": [23, 1], "end": [26, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkSimpOnly", "code": "def mkSimpOnly (stx : Syntax) (usedSimps : UsedSimps) (includeFVars : Bool) :\n    MetaM Syntax := do\n  let mut stx := stx\n  if stx[3].isNone then\n    stx := stx.setArg 3 (mkNullNode #[mkAtom \"only\"])\n  let mut args : Array Syntax := #[]\n  let mut localsOrStar := some #[]\n  let lctx \u2190 getLCtx\n  let env \u2190 getEnv\n  for (thm, _) in usedSimps.toArray.qsort (\u00b7.2 < \u00b7.2) do\n    match thm with\n    | .decl declName inv => if env.contains declName && !Lean.Elab.Tactic.simpOnlyBuiltins.contains declName then\n        args := args.push (\u2190 if inv then\n          `(Parser.Tactic.simpLemma| \u2190 $(mkIdent (\u2190 unresolveNameGlobal declName)):ident)\n        else\n          `(Parser.Tactic.simpLemma| $(mkIdent (\u2190 unresolveNameGlobal declName)):ident))\n    | .fvar fvarId => if ! includeFVars then\n        continue\n      if let some ldecl := lctx.find? fvarId then\n        localsOrStar := localsOrStar.bind fun locals =>\n          if !ldecl.userName.isInaccessibleUserName &&\n              (lctx.findFromUserName? ldecl.userName).get!.fvarId == ldecl.fvarId then\n            some (locals.push ldecl.userName)\n          else\n            none\n      | .stx _ thmStx => args := args.push thmStx\n    | .other _ => pure ()     if let some locals := localsOrStar then\n    args := args ++ (\u2190 locals.mapM fun id => `(Parser.Tactic.simpLemma| $(mkIdent id):ident))\n  else\n    args := args.push (\u2190 `(Parser.Tactic.simpStar| *))\n  let argsStx := if args.isEmpty then #[] else #[mkAtom \"[\", (mkAtom \",\").mkSep args, mkAtom \"]\"]\n  stx := stx.setArg 4 (mkNullNode argsStx)\n  return stx", "start": [36, 1], "end": [75, 13], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkNormSimpSyntax", "code": "def mkNormSimpSyntax (normSimpUseHyps : Bool)\n    (configStx? : Option Term) : MetaM Syntax.Tactic := do\n  if normSimpUseHyps then\n    match configStx? with\n    | none => `(tactic| simp_all)\n    | some cfg =>\n      `(tactic| simp_all (config := ($cfg : Aesop.SimpConfig).toConfigCtx))\n  else\n    match configStx? with\n    | none => `(tactic| simp at *)\n    | some cfg =>\n      `(tactic| simp (config := ($cfg : Aesop.SimpConfig).toConfig) at *)", "start": [78, 1], "end": [89, 74], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkNormSimpOnlySyntax", "code": "def mkNormSimpOnlySyntax (inGoal : MVarId) (normSimpUseHyps : Bool)\n    (configStx? : Option Term) (usedTheorems : Simp.UsedSimps) :\n    MetaM Syntax.Tactic := do\n  let originalStx \u2190 mkNormSimpSyntax normSimpUseHyps configStx?\n  let includeFVars := ! normSimpUseHyps\n  let stx \u2190 inGoal.withContext do\n    mkSimpOnly originalStx usedTheorems (includeFVars := includeFVars)\n  return \u27e8stx\u27e9", "start": [91, 1], "end": [98, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkNormSimpContext", "code": "def mkNormSimpContext (rs : RuleSet) (simpConfig : Aesop.SimpConfig) :\n    MetaM Simp.Context :=\n  return {\n    \u2190 Simp.Context.mkDefault with\n    simpTheorems := #[rs.normSimpLemmas]\n    config := simpConfig.toConfig\n  }", "start": [100, 1], "end": [106, 4], "kind": "commanddeclaration"}, {"full_name": "Aesop.simpGoal", "code": "def simpGoal (mvarId : MVarId) (ctx : Simp.Context)\n    (discharge? : Option Simp.Discharge := none)\n    (simplifyTarget : Bool := true) (fvarIdsToSimp : Array FVarId := #[])\n    (usedSimps : UsedSimps := {}) : MetaM SimpResult := do\n  let mvarIdOld := mvarId\n  let ctx := { ctx with config.failIfUnchanged := false }\n  let (result, usedSimps) \u2190\n    Meta.simpGoal mvarId ctx discharge? simplifyTarget fvarIdsToSimp usedSimps\n  if let some (_, mvarId) := result then\n    if mvarId == mvarIdOld then\n      return .unchanged mvarId\n    else\n      return .simplified mvarId usedSimps\n  else\n    return .solved usedSimps", "start": [108, 1], "end": [122, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.simpGoalWithAllHypotheses", "code": "def simpGoalWithAllHypotheses (mvarId : MVarId) (ctx : Simp.Context)\n    (discharge? : Option Simp.Discharge := none)\n    (simplifyTarget : Bool := true) (usedSimps : UsedSimps := {}) :\n    MetaM SimpResult :=\n  mvarId.withContext do\n    let lctx \u2190 getLCtx\n    let mut fvarIdsToSimp := Array.mkEmpty lctx.decls.size\n    for ldecl in lctx do\n      if ldecl.isImplementationDetail then\n        continue\n      fvarIdsToSimp := fvarIdsToSimp.push ldecl.fvarId\n    Aesop.simpGoal mvarId ctx discharge? simplifyTarget fvarIdsToSimp usedSimps", "start": [124, 1], "end": [135, 80], "kind": "commanddeclaration"}, {"full_name": "Aesop.simpAll", "code": "def simpAll (mvarId : MVarId) (ctx : Simp.Context)\n    (usedSimps : UsedSimps := {}) : MetaM SimpResult := do\n  let ctx := { ctx with config.failIfUnchanged := false }\n  match \u2190 Lean.Meta.simpAll mvarId ctx usedSimps with\n  | (none, usedSimps) => return .solved usedSimps\n  | (some mvarIdNew, usedSimps) =>\n    if mvarIdNew == mvarId then\n      return .unchanged mvarIdNew\n    else\n      return .simplified mvarIdNew usedSimps", "start": [137, 1], "end": [146, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Core.lean", "imports": ["lake-packages/std/Std/Tactic/Simpa.lean", "Mathlib/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.toModifiers", "code": "def toModifiers (nm : Name) (newDoc : Option String := none) :\n    CoreM Modifiers := do\n  let env \u2190 getEnv\n  let d \u2190 getConstInfo nm\n  let mods : Modifiers :=\n  { docString? := newDoc\n    visibility :=\n    if isPrivateNameExport nm then\n      Visibility.private\n    else if isProtected env nm then\n      Visibility.regular\n    else\n      Visibility.protected\n    isNoncomputable := if (env.find? $ nm.mkStr \"_cstage1\").isSome then false else true\n    recKind := RecKind.default isUnsafe := d.isUnsafe\n    attrs := #[] }\n  return mods", "start": [24, 1], "end": [45, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.toPreDefinition", "code": "def toPreDefinition (nm newNm : Name) (newType newValue : Expr) (newDoc : Option String := none) :\n    CoreM PreDefinition := do\n  let d \u2190 getConstInfo nm\n  let mods \u2190 toModifiers nm newDoc\n  let predef : PreDefinition :=\n  { ref := Syntax.missing\n    kind := if d.isDef then DefKind.def else DefKind.theorem\n    levelParams := d.levelParams\n    modifiers := mods\n    declName := newNm\n    type := newType\n    value := newValue }\n  return predef", "start": [47, 1], "end": [65, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.setProtected", "code": "def setProtected {m : Type \u2192 Type} [MonadEnv m] (nm : Name) : m Unit :=\n  modifyEnv (addProtected \u00b7 nm)", "start": [67, 1], "end": [69, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.introsWithBinderIdents", "code": "def MVarId.introsWithBinderIdents\n    (g : MVarId) (ids : List (TSyntax ``binderIdent)) :\n    MetaM (List (TSyntax ``binderIdent) \u00d7 Array FVarId \u00d7 MVarId) := do\n  let type \u2190 g.getType\n  let type \u2190 instantiateMVars type\n  let n := getIntrosSize type\n  if n == 0 then\n    return (ids, #[], g)\n  let mut ids := ids\n  let mut names := #[]\n  for _ in [0:n] do\n    names := names.push (ids.headD (Unhygienic.run `(binderIdent| _)))\n    ids := ids.tail\n  let (xs, g) \u2190 g.introN n <| names.toList.map fun stx =>\n    match stx.raw with\n    | `(binderIdent| $n:ident) => n.getId\n    | _ => `_\n  g.withContext do\n    for n in names, fvar in xs do\n      (Expr.fvar fvar).addLocalVarInfoForBinderIdent n\n  return (ids, xs, g)", "start": [72, 1], "end": [93, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getSimpArgs", "code": "def getSimpArgs : Syntax \u2192 TacticM (Array Syntax)\n  | `(simpArgs| [$args,*]) => pure args.getElems\n  | _                      => Elab.throwUnsupportedSyntax", "start": [106, 1], "end": [109, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getDSimpArgs", "code": "def getDSimpArgs : Syntax \u2192 TacticM (Array Syntax)\n  | `(dsimpArgs| [$args,*]) => pure args.getElems\n  | _                       => Elab.throwUnsupportedSyntax", "start": [111, 1], "end": [114, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getWithArgs", "code": "def getWithArgs : Syntax \u2192 TacticM (Array Syntax)\n  | `(withArgs| with $args*) => pure args\n  | _                        => Elab.throwUnsupportedSyntax", "start": [116, 1], "end": [119, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getUsingArg", "code": "def getUsingArg : Syntax \u2192 TacticM Syntax\n  | `(usingArg| using $e) => pure e\n  | _                     => Elab.throwUnsupportedSyntax", "start": [121, 1], "end": [124, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.filterOutImplementationDetails", "code": "def filterOutImplementationDetails (lctx : LocalContext) (fvarIds : Array FVarId) : Array FVarId :=\n  fvarIds.filter (fun fvar => ! (lctx.fvarIdToDecl.find! fvar).isImplementationDetail)", "start": [136, 1], "end": [139, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getFVarIdAt", "code": "def getFVarIdAt (goal : MVarId) (id : Syntax) : TacticM FVarId := withRef id do\n  let e \u2190 goal.withContext do\n    elabTermForApply id (mayPostpone := false)\n  match e with\n  | Expr.fvar fvarId => return fvarId\n  | _                => throwError \"unexpected term '{e}'; expected single reference to variable\"", "start": [141, 1], "end": [148, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getFVarIdsAt", "code": "def getFVarIdsAt (goal : MVarId) (ids : Option (Array Syntax) := none)\n    (includeImplementationDetails : Bool := false) : TacticM (Array FVarId) :=\n  goal.withContext do\n    let lctx := (\u2190 goal.getDecl).lctx\n    let fvarIds \u2190 match ids with\n    | none => pure lctx.getFVarIds\n    | some ids => ids.mapM <| getFVarIdAt goal\n    if includeImplementationDetails then\n      return fvarIds\n    else\n      return filterOutImplementationDetails lctx fvarIds", "start": [150, 1], "end": [167, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.allGoals", "code": "def allGoals (tac : TacticM Unit) : TacticM Unit := do\n  let mvarIds \u2190 getGoals\n  let mut mvarIdsNew := #[]\n  for mvarId in mvarIds do\n    unless (\u2190 mvarId.isAssigned) do\n      setGoals [mvarId]\n      try\n        tac\n        mvarIdsNew := mvarIdsNew ++ (\u2190 getUnsolvedGoals)\n      catch ex =>\n        if (\u2190 read).recover then\n          logException ex\n          mvarIdsNew := mvarIdsNew.push mvarId\n        else\n          throw ex\n  setGoals mvarIdsNew.toList", "start": [169, 1], "end": [191, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.andThenOnSubgoals", "code": "def andThenOnSubgoals (tac1 : TacticM Unit) (tac2 : TacticM Unit) : TacticM Unit :=\n  focus do tac1; allGoals tac2", "start": [193, 1], "end": [197, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.iterateAtMost", "code": "def iterateAtMost : Nat \u2192 m Unit \u2192 m Unit\n  | 0, _ => pure ()\n  | n + 1, tac => try tac; iterateAtMost n tac catch _ => pure ()", "start": [201, 1], "end": [205, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.iterateExactly'", "code": "def iterateExactly' : Nat \u2192 m Unit \u2192 m Unit\n  | 0, _ => pure ()\n  | n+1, tac => tac *> iterateExactly' n tac", "start": [207, 1], "end": [211, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.iterateRange", "code": "def iterateRange : Nat \u2192 Nat \u2192 m Unit \u2192 m Unit\n  | 0, 0, _   => pure ()\n  | 0, b, tac => iterateAtMost b tac\n  | (a+1), n, tac => do tac; iterateRange a (n-1) tac", "start": [213, 1], "end": [220, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.iterateUntilFailure", "code": "partial def iterateUntilFailure (tac : m Unit) : m Unit :=\n  try tac; iterateUntilFailure tac catch _ => pure ()", "start": [222, 1], "end": [224, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.iterateUntilFailureWithResults", "code": "partial def iterateUntilFailureWithResults {\u03b1 : Type} (tac : m \u03b1) : m (List \u03b1) := do\n  try\n    let a \u2190 tac\n    let l \u2190 iterateUntilFailureWithResults tac\n    pure (a :: l)\n  catch _ => pure []", "start": [226, 1], "end": [234, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.iterateUntilFailureCount", "code": "def iterateUntilFailureCount {\u03b1 : Type} (tac : m \u03b1) : m Nat := do\n  let r \u2190 iterateUntilFailureWithResults tac\n  return r.length", "start": [236, 1], "end": [241, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.getPackageDir", "code": "def getPackageDir (pkg : String) : IO System.FilePath := do\n  let sp \u2190 initSrcSearchPath (\u2190 findSysroot)\n  let root? \u2190 sp.findM? fun p =>\n    (p / pkg).isDir <||> ((p / pkg).withExtension \"lean\").pathExists\n  if let some root := root? then return root\n  throw <| IO.userError s!\"Could not find {pkg} directory. {\n    \"\"}Make sure the LEAN_SRC_PATH environment variable is set correctly.\"", "start": [248, 1], "end": [255, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.getMathlibDir", "code": "def getMathlibDir := getPackageDir \"Mathlib\"", "start": [257, 1], "end": [258, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Function/Basic.lean", "imports": ["Mathlib/Init/Set.lean", "Mathlib/Logic/Nonempty.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.eval", "code": "@[reducible, simp] def eval {\u03b2 : \u03b1 \u2192 Sort*} (x : \u03b1) (f : \u2200 x, \u03b2 x) : \u03b2 x := f x", "start": [27, 1], "end": [29, 80], "kind": "commanddeclaration"}, {"full_name": "Function.eval_apply", "code": "theorem eval_apply {\u03b2 : \u03b1 \u2192 Sort*} (x : \u03b1) (f : \u2200 x, \u03b2 x) : eval x f = f x", "start": [32, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "Function.const_def", "code": "theorem const_def {y : \u03b2} : (fun _ : \u03b1 \u21a6 y) = const \u03b1 y", "start": [36, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Function.const_comp", "code": "@[simp]\ntheorem const_comp {f : \u03b1 \u2192 \u03b2} {c : \u03b3} : const \u03b2 c \u2218 f = const \u03b1 c", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Function.comp_const", "code": "@[simp]\ntheorem comp_const {f : \u03b2 \u2192 \u03b3} {b : \u03b2} : f \u2218 const \u03b1 b = const \u03b1 (f b)", "start": [45, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Function.const_injective", "code": "theorem const_injective [Nonempty \u03b1] : Injective (const \u03b1 : \u03b2 \u2192 \u03b1 \u2192 \u03b2)", "start": [50, 1], "end": [52, 16], "kind": "commanddeclaration"}, {"full_name": "Function.const_inj", "code": "@[simp]\ntheorem const_inj [Nonempty \u03b1] {y\u2081 y\u2082 : \u03b2} : const \u03b1 y\u2081 = const \u03b1 y\u2082 \u2194 y\u2081 = y\u2082", "start": [55, 1], "end": [57, 47], "kind": "commanddeclaration"}, {"full_name": "Function.id_def", "code": "theorem id_def : @id \u03b1 = fun x \u21a6 x", "start": [60, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Function.onFun_apply", "code": "theorem onFun_apply (f : \u03b2 \u2192 \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) (a b : \u03b1) : onFun f g a b = f (g a) (g b)", "start": [66, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "Function.hfunext", "code": "lemma hfunext {\u03b1 \u03b1' : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b2' : \u03b1' \u2192 Sort v} {f : \u2200a, \u03b2 a} {f' : \u2200a, \u03b2' a}\n    (h\u03b1 : \u03b1 = \u03b1') (h : \u2200a a', HEq a a' \u2192 HEq (f a) (f' a')) : HEq f f' := by\n  subst h\u03b1\n  have : \u2200a, HEq (f a) (f' a) := \u03bb a => h a a (HEq.refl a)\n  have : \u03b2 = \u03b2' := by funext a\n                      exact type_eq_of_heq (this a)\n  subst this\n  apply heq_of_eq\n  funext a\n  exact eq_of_heq (this a)", "start": [70, 1], "end": [79, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Function.funext_iff", "code": "theorem funext_iff {\u03b2 : \u03b1 \u2192 Sort*} {f\u2081 f\u2082 : \u2200 x : \u03b1, \u03b2 x} : f\u2081 = f\u2082 \u2194 \u2200 a, f\u2081 a = f\u2082 a", "start": [82, 1], "end": [83, 39], "kind": "commanddeclaration"}, {"full_name": "Function.ne_iff", "code": "theorem ne_iff {\u03b2 : \u03b1 \u2192 Sort*} {f\u2081 f\u2082 : \u2200 a, \u03b2 a} : f\u2081 \u2260 f\u2082 \u2194 \u2203 a, f\u2081 a \u2260 f\u2082 a", "start": [86, 1], "end": [87, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.injective", "code": "protected theorem Bijective.injective {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) : Injective f", "start": [90, 1], "end": [90, 91], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.surjective", "code": "protected theorem Bijective.surjective {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) : Surjective f", "start": [92, 1], "end": [92, 93], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.eq_iff", "code": "theorem Injective.eq_iff (I : Injective f) {a b : \u03b1} : f a = f b \u2194 a = b", "start": [95, 1], "end": [96, 24], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.beq_eq", "code": "theorem Injective.beq_eq [BEq \u03b1] [LawfulBEq \u03b1] [BEq \u03b2] [LawfulBEq \u03b2]\n    (I : Injective f) {a b : \u03b1} : (f a == f b) = (a == b)", "start": [99, 1], "end": [101, 64], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.eq_iff'", "code": "theorem Injective.eq_iff' (I : Injective f) {a b : \u03b1} {c : \u03b2} (h : f b = c) : f a = c \u2194 a = b", "start": [103, 1], "end": [104, 15], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.ne", "code": "theorem Injective.ne (hf : Injective f) {a\u2081 a\u2082 : \u03b1} : a\u2081 \u2260 a\u2082 \u2192 f a\u2081 \u2260 f a\u2082", "start": [107, 1], "end": [108, 18], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.ne_iff", "code": "theorem Injective.ne_iff (hf : Injective f) {x y : \u03b1} : f x \u2260 f y \u2194 x \u2260 y", "start": [111, 1], "end": [112, 29], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.ne_iff'", "code": "theorem Injective.ne_iff' (hf : Injective f) {x y : \u03b1} {z : \u03b2} (h : f y = z) : f x \u2260 z \u2194 x \u2260 y", "start": [115, 1], "end": [116, 16], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.decidableEq", "code": "protected def Injective.decidableEq [DecidableEq \u03b2] (I : Injective f) : DecidableEq \u03b1 :=\n  fun _ _ \u21a6 decidable_of_iff _ I.eq_iff", "start": [119, 1], "end": [122, 40], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.of_comp", "code": "theorem Injective.of_comp {g : \u03b3 \u2192 \u03b1} (I : Injective (f \u2218 g)) : Injective g", "start": [125, 1], "end": [126, 49], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.of_comp_iff", "code": "@[simp]\ntheorem Injective.of_comp_iff {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (g : \u03b3 \u2192 \u03b1) :\n    Injective (f \u2218 g) \u2194 Injective g", "start": [129, 1], "end": [132, 31], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.of_comp_iff'", "code": "@[simp]\ntheorem Injective.of_comp_iff' (f : \u03b1 \u2192 \u03b2) {g : \u03b3 \u2192 \u03b1} (hg : Bijective g) :\n    Injective (f \u2218 g) \u2194 Injective f", "start": [135, 1], "end": [141, 30], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.comp_left", "code": "theorem Injective.comp_left {g : \u03b2 \u2192 \u03b3} (hg : Function.Injective g) :\n    Function.Injective ((\u00b7 \u2218 \u00b7) g : (\u03b1 \u2192 \u03b2) \u2192 \u03b1 \u2192 \u03b3)", "start": [144, 1], "end": [147, 59], "kind": "commanddeclaration"}, {"full_name": "Function.injective_of_subsingleton", "code": "theorem injective_of_subsingleton [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) : Injective f", "start": [150, 1], "end": [151, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.dite", "code": "lemma Injective.dite (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    {f : {a : \u03b1 // p a} \u2192 \u03b2} {f' : {a : \u03b1 // \u00ac p a} \u2192 \u03b2}\n    (hf : Injective f) (hf' : Injective f')\n    (im_disj : \u2200 {x x' : \u03b1} {hx : p x} {hx' : \u00ac p x'}, f \u27e8x, hx\u27e9 \u2260 f' \u27e8x', hx'\u27e9) :\n  Function.Injective (\u03bb x => if h : p x then f \u27e8x, h\u27e9 else f' \u27e8x, h\u27e9) :=\nby intros x\u2081 x\u2082 h\n   dsimp only at h\n   by_cases h\u2081 : p x\u2081 <;> by_cases h\u2082 : p x\u2082\n   \u00b7 rw [dif_pos h\u2081, dif_pos h\u2082] at h; injection (hf h)\n   \u00b7 rw [dif_pos h\u2081, dif_neg h\u2082] at h; exact (im_disj h).elim\n   \u00b7 rw [dif_neg h\u2081, dif_pos h\u2082] at h; exact (im_disj h.symm).elim\n   \u00b7 rw [dif_neg h\u2081, dif_neg h\u2082] at h; injection (hf' h)", "start": [154, 1], "end": [165, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Surjective.of_comp", "code": "theorem Surjective.of_comp {g : \u03b3 \u2192 \u03b1} (S : Surjective (f \u2218 g)) : Surjective f", "start": [168, 1], "end": [170, 11], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.of_comp_iff", "code": "@[simp]\ntheorem Surjective.of_comp_iff (f : \u03b1 \u2192 \u03b2) {g : \u03b3 \u2192 \u03b1} (hg : Surjective g) :\n    Surjective (f \u2218 g) \u2194 Surjective f", "start": [173, 1], "end": [176, 42], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.of_comp_iff'", "code": "@[simp]\ntheorem Surjective.of_comp_iff' (hf : Bijective f) (g : \u03b3 \u2192 \u03b1) :\n    Surjective (f \u2218 g) \u2194 Surjective g", "start": [179, 1], "end": [185, 24], "kind": "commanddeclaration"}, {"full_name": "Function.decidableEqPfun", "code": "instance decidableEqPfun (p : Prop) [Decidable p] (\u03b1 : p \u2192 Type*) [\u2200 hp, DecidableEq (\u03b1 hp)] :\n    DecidableEq (\u2200 hp, \u03b1 hp)\n  | f, g => decidable_of_iff (\u2200 hp, f hp = g hp) funext_iff.symm", "start": [188, 1], "end": [190, 65], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.forall", "code": "protected theorem Surjective.forall (hf : Surjective f) {p : \u03b2 \u2192 Prop} :\n    (\u2200 y, p y) \u2194 \u2200 x, p (f x)", "start": [192, 1], "end": [196, 14], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.forall\u2082", "code": "protected theorem Surjective.forall\u2082 (hf : Surjective f) {p : \u03b2 \u2192 \u03b2 \u2192 Prop} :\n    (\u2200 y\u2081 y\u2082, p y\u2081 y\u2082) \u2194 \u2200 x\u2081 x\u2082, p (f x\u2081) (f x\u2082)", "start": [199, 1], "end": [201, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.forall\u2083", "code": "protected theorem Surjective.forall\u2083 (hf : Surjective f) {p : \u03b2 \u2192 \u03b2 \u2192 \u03b2 \u2192 Prop} :\n    (\u2200 y\u2081 y\u2082 y\u2083, p y\u2081 y\u2082 y\u2083) \u2194 \u2200 x\u2081 x\u2082 x\u2083, p (f x\u2081) (f x\u2082) (f x\u2083)", "start": [204, 1], "end": [206, 53], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.exists", "code": "protected theorem Surjective.exists (hf : Surjective f) {p : \u03b2 \u2192 Prop} :\n    (\u2203 y, p y) \u2194 \u2203 x, p (f x)", "start": [209, 1], "end": [214, 29], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.exists\u2082", "code": "protected theorem Surjective.exists\u2082 (hf : Surjective f) {p : \u03b2 \u2192 \u03b2 \u2192 Prop} :\n    (\u2203 y\u2081 y\u2082, p y\u2081 y\u2082) \u2194 \u2203 x\u2081 x\u2082, p (f x\u2081) (f x\u2082)", "start": [217, 1], "end": [219, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.exists\u2083", "code": "protected theorem Surjective.exists\u2083 (hf : Surjective f) {p : \u03b2 \u2192 \u03b2 \u2192 \u03b2 \u2192 Prop} :\n    (\u2203 y\u2081 y\u2082 y\u2083, p y\u2081 y\u2082 y\u2083) \u2194 \u2203 x\u2081 x\u2082 x\u2083, p (f x\u2081) (f x\u2082) (f x\u2083)", "start": [222, 1], "end": [224, 53], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.injective_comp_right", "code": "theorem Surjective.injective_comp_right (hf : Surjective f) : Injective fun g : \u03b2 \u2192 \u03b3 \u21a6 g \u2218 f", "start": [227, 1], "end": [228, 51], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.right_cancellable", "code": "protected theorem Surjective.right_cancellable (hf : Surjective f) {g\u2081 g\u2082 : \u03b2 \u2192 \u03b3} :\n    g\u2081 \u2218 f = g\u2082 \u2218 f \u2194 g\u2081 = g\u2082", "start": [231, 1], "end": [233, 33], "kind": "commanddeclaration"}, {"full_name": "Function.surjective_of_right_cancellable_Prop", "code": "theorem surjective_of_right_cancellable_Prop (h : \u2200 g\u2081 g\u2082 : \u03b2 \u2192 Prop, g\u2081 \u2218 f = g\u2082 \u2218 f \u2192 g\u2081 = g\u2082) :\n    Surjective f", "start": [236, 1], "end": [239, 39], "kind": "commanddeclaration"}, {"full_name": "Function.bijective_iff_existsUnique", "code": "theorem bijective_iff_existsUnique (f : \u03b1 \u2192 \u03b2) : Bijective f \u2194 \u2200 b : \u03b2, \u2203! a : \u03b1, f a = b", "start": [242, 1], "end": [246, 80], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.existsUnique", "code": "protected theorem Bijective.existsUnique {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) (b : \u03b2) :\n    \u2203! a : \u03b1, f a = b", "start": [249, 1], "end": [252, 41], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.existsUnique_iff", "code": "theorem Bijective.existsUnique_iff {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) {p : \u03b2 \u2192 Prop} :\n    (\u2203! y, p y) \u2194 \u2203! x, p (f x)", "start": [255, 1], "end": [263, 48], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.of_comp_iff", "code": "theorem Bijective.of_comp_iff (f : \u03b1 \u2192 \u03b2) {g : \u03b3 \u2192 \u03b1} (hg : Bijective g) :\n    Bijective (f \u2218 g) \u2194 Bijective f", "start": [266, 1], "end": [268, 83], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.of_comp_iff'", "code": "theorem Bijective.of_comp_iff' {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) (g : \u03b3 \u2192 \u03b1) :\n    Function.Bijective (f \u2218 g) \u2194 Function.Bijective g", "start": [271, 1], "end": [273, 82], "kind": "commanddeclaration"}, {"full_name": "Function.cantor_surjective", "code": "theorem cantor_surjective {\u03b1} (f : \u03b1 \u2192 Set \u03b1) : \u00acSurjective f", "start": [276, 1], "end": [280, 68], "kind": "commanddeclaration"}, {"full_name": "Function.cantor_injective", "code": "theorem cantor_injective {\u03b1 : Type*} (f : Set \u03b1 \u2192 \u03b1) : \u00acInjective f", "start": [283, 1], "end": [287, 100], "kind": "commanddeclaration"}, {"full_name": "Function.not_surjective_Type", "code": "theorem not_surjective_Type {\u03b1 : Type u} (f : \u03b1 \u2192 Type max u v) : \u00acSurjective f", "start": [290, 1], "end": [303, 30], "kind": "commanddeclaration"}, {"full_name": "Function.IsPartialInv", "code": "def IsPartialInv {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 Option \u03b1) : Prop :=\n  \u2200 x y, g y = some x \u2194 f x = y", "start": [306, 1], "end": [310, 32], "kind": "commanddeclaration"}, {"full_name": "Function.isPartialInv_left", "code": "theorem isPartialInv_left {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} {g} (H : IsPartialInv f g) (x) : g (f x) = some x", "start": [313, 1], "end": [314, 16], "kind": "commanddeclaration"}, {"full_name": "Function.injective_of_isPartialInv", "code": "theorem injective_of_isPartialInv {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} {g} (H : IsPartialInv f g) :\n    Injective f", "start": [317, 1], "end": [319, 62], "kind": "commanddeclaration"}, {"full_name": "Function.injective_of_isPartialInv_right", "code": "theorem injective_of_isPartialInv_right {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} {g} (H : IsPartialInv f g) (x y b)\n    (h\u2081 : b \u2208 g x) (h\u2082 : b \u2208 g y) : x = y", "start": [322, 1], "end": [324, 43], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.comp_eq_id", "code": "theorem LeftInverse.comp_eq_id {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : LeftInverse f g) : f \u2218 g = id", "start": [327, 1], "end": [328, 11], "kind": "commanddeclaration"}, {"full_name": "Function.leftInverse_iff_comp", "code": "theorem leftInverse_iff_comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} : LeftInverse f g \u2194 f \u2218 g = id", "start": [331, 1], "end": [332, 38], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.comp_eq_id", "code": "theorem RightInverse.comp_eq_id {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : RightInverse f g) : g \u2218 f = id", "start": [335, 1], "end": [336, 11], "kind": "commanddeclaration"}, {"full_name": "Function.rightInverse_iff_comp", "code": "theorem rightInverse_iff_comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} : RightInverse f g \u2194 g \u2218 f = id", "start": [339, 1], "end": [340, 39], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.comp", "code": "theorem LeftInverse.comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} {h : \u03b2 \u2192 \u03b3} {i : \u03b3 \u2192 \u03b2} (hf : LeftInverse f g)\n    (hh : LeftInverse h i) : LeftInverse (h \u2218 f) (g \u2218 i)", "start": [343, 1], "end": [345, 58], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.comp", "code": "theorem RightInverse.comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} {h : \u03b2 \u2192 \u03b3} {i : \u03b3 \u2192 \u03b2} (hf : RightInverse f g)\n    (hh : RightInverse h i) : RightInverse (h \u2218 f) (g \u2218 i)", "start": [348, 1], "end": [350, 25], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.rightInverse", "code": "theorem LeftInverse.rightInverse {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : LeftInverse g f) : RightInverse f g", "start": [353, 1], "end": [354, 4], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.leftInverse", "code": "theorem RightInverse.leftInverse {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : RightInverse g f) : LeftInverse f g", "start": [357, 1], "end": [358, 4], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.surjective", "code": "theorem LeftInverse.surjective {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : LeftInverse f g) : Surjective f", "start": [361, 1], "end": [362, 28], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.injective", "code": "theorem RightInverse.injective {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : RightInverse f g) : Injective f", "start": [365, 1], "end": [366, 26], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.rightInverse_of_injective", "code": "theorem LeftInverse.rightInverse_of_injective {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : LeftInverse f g)\n    (hf : Injective f) : RightInverse f g", "start": [369, 1], "end": [371, 24], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.rightInverse_of_surjective", "code": "theorem LeftInverse.rightInverse_of_surjective {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : LeftInverse f g)\n    (hg : Surjective g) : RightInverse f g", "start": [374, 1], "end": [376, 54], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.leftInverse_of_surjective", "code": "theorem RightInverse.leftInverse_of_surjective {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} :\n    RightInverse f g \u2192 Surjective f \u2192 LeftInverse f g", "start": [379, 1], "end": [381, 41], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.leftInverse_of_injective", "code": "theorem RightInverse.leftInverse_of_injective {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} :\n    RightInverse f g \u2192 Injective g \u2192 LeftInverse f g", "start": [384, 1], "end": [386, 40], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.eq_rightInverse", "code": "theorem LeftInverse.eq_rightInverse {f : \u03b1 \u2192 \u03b2} {g\u2081 g\u2082 : \u03b2 \u2192 \u03b1} (h\u2081 : LeftInverse g\u2081 f)\n    (h\u2082 : RightInverse g\u2082 f) : g\u2081 = g\u2082", "start": [389, 1], "end": [393, 65], "kind": "commanddeclaration"}, {"full_name": "Function.partialInv", "code": "noncomputable def partialInv {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (b : \u03b2) : Option \u03b1 :=\n  if h : \u2203 a, f a = b then some (Classical.choose h) else none", "start": [398, 1], "end": [401, 63], "kind": "commanddeclaration"}, {"full_name": "Function.partialInv_of_injective", "code": "theorem partialInv_of_injective {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (I : Injective f) : IsPartialInv f (partialInv f)", "start": [404, 1], "end": [416, 78], "kind": "commanddeclaration"}, {"full_name": "Function.partialInv_left", "code": "theorem partialInv_left {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (I : Injective f) : \u2200 x, partialInv f (f x) = some x", "start": [419, 1], "end": [420, 48], "kind": "commanddeclaration"}, {"full_name": "Function.invFun", "code": "noncomputable def invFun {\u03b1 : Sort u} {\u03b2} [Nonempty \u03b1] (f : \u03b1 \u2192 \u03b2) : \u03b2 \u2192 \u03b1 :=\n  fun y \u21a6 if h : (\u2203 x, f x = y) then h.choose else Classical.arbitrary \u03b1", "start": [431, 1], "end": [435, 73], "kind": "commanddeclaration"}, {"full_name": "Function.invFun_eq", "code": "theorem invFun_eq (h : \u2203 a, f a = b) : f (invFun f b) = b", "start": [438, 1], "end": [439, 50], "kind": "commanddeclaration"}, {"full_name": "Function.apply_invFun_apply", "code": "theorem apply_invFun_apply {\u03b1 : Type u\u2081} {\u03b2 : Type u\u2082} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} :\n    f (@invFun _ _ \u27e8a\u27e9 f (f a)) = f a", "start": [442, 1], "end": [444, 34], "kind": "commanddeclaration"}, {"full_name": "Function.invFun_neg", "code": "theorem invFun_neg (h : \u00ac\u2203 a, f a = b) : invFun f b = Classical.choice \u2039_\u203a", "start": [446, 1], "end": [447, 12], "kind": "commanddeclaration"}, {"full_name": "Function.invFun_eq_of_injective_of_rightInverse", "code": "theorem invFun_eq_of_injective_of_rightInverse {g : \u03b2 \u2192 \u03b1} (hf : Injective f)\n    (hg : RightInverse g f) : invFun f = g", "start": [450, 1], "end": [456, 37], "kind": "commanddeclaration"}, {"full_name": "Function.rightInverse_invFun", "code": "theorem rightInverse_invFun (hf : Surjective f) : RightInverse (invFun f) f", "start": [459, 1], "end": [460, 28], "kind": "commanddeclaration"}, {"full_name": "Function.leftInverse_invFun", "code": "theorem leftInverse_invFun (hf : Injective f) : LeftInverse (invFun f) f", "start": [463, 1], "end": [464, 35], "kind": "commanddeclaration"}, {"full_name": "Function.invFun_surjective", "code": "theorem invFun_surjective (hf : Injective f) : Surjective (invFun f)", "start": [467, 1], "end": [468, 37], "kind": "commanddeclaration"}, {"full_name": "Function.invFun_comp", "code": "theorem invFun_comp (hf : Injective f) : invFun f \u2218 f = id", "start": [471, 1], "end": [472, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.hasLeftInverse", "code": "theorem Injective.hasLeftInverse (hf : Injective f) : HasLeftInverse f", "start": [475, 1], "end": [476, 36], "kind": "commanddeclaration"}, {"full_name": "Function.injective_iff_hasLeftInverse", "code": "theorem injective_iff_hasLeftInverse : Injective f \u2194 HasLeftInverse f", "start": [479, 1], "end": [480, 55], "kind": "commanddeclaration"}, {"full_name": "Function.surjInv", "code": "noncomputable def surjInv {f : \u03b1 \u2192 \u03b2} (h : Surjective f) (b : \u03b2) : \u03b1 :=\n  Classical.choose (h b)", "start": [489, 1], "end": [492, 25], "kind": "commanddeclaration"}, {"full_name": "Function.surjInv_eq", "code": "theorem surjInv_eq (h : Surjective f) (b) : f (surjInv h b) = b", "start": [495, 1], "end": [496, 30], "kind": "commanddeclaration"}, {"full_name": "Function.rightInverse_surjInv", "code": "theorem rightInverse_surjInv (hf : Surjective f) : RightInverse (surjInv hf) f", "start": [499, 1], "end": [500, 16], "kind": "commanddeclaration"}, {"full_name": "Function.leftInverse_surjInv", "code": "theorem leftInverse_surjInv (hf : Bijective f) : LeftInverse (surjInv hf.2) f", "start": [503, 1], "end": [504, 76], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.hasRightInverse", "code": "theorem Surjective.hasRightInverse (hf : Surjective f) : HasRightInverse f", "start": [507, 1], "end": [508, 31], "kind": "commanddeclaration"}, {"full_name": "Function.surjective_iff_hasRightInverse", "code": "theorem surjective_iff_hasRightInverse : Surjective f \u2194 HasRightInverse f", "start": [511, 1], "end": [512, 59], "kind": "commanddeclaration"}, {"full_name": "Function.bijective_iff_has_inverse", "code": "theorem bijective_iff_has_inverse : Bijective f \u2194 \u2203 g, LeftInverse g f \u2227 RightInverse g f", "start": [515, 1], "end": [517, 35], "kind": "commanddeclaration"}, {"full_name": "Function.injective_surjInv", "code": "theorem injective_surjInv (h : Surjective f) : Injective (surjInv h)", "start": [520, 1], "end": [521, 37], "kind": "commanddeclaration"}, {"full_name": "Function.surjective_to_subsingleton", "code": "theorem surjective_to_subsingleton [na : Nonempty \u03b1] [Subsingleton \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    Surjective f", "start": [524, 1], "end": [526, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.comp_left", "code": "theorem Surjective.comp_left {g : \u03b2 \u2192 \u03b3} (hg : Surjective g) :\n    Surjective ((\u00b7 \u2218 \u00b7) g : (\u03b1 \u2192 \u03b2) \u2192 \u03b1 \u2192 \u03b3)", "start": [529, 1], "end": [532, 60], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.comp_left", "code": "theorem Bijective.comp_left {g : \u03b2 \u2192 \u03b3} (hg : Bijective g) :\n    Bijective ((\u00b7 \u2218 \u00b7) g : (\u03b1 \u2192 \u03b2) \u2192 \u03b1 \u2192 \u03b3)", "start": [535, 1], "end": [538, 52], "kind": "commanddeclaration"}, {"full_name": "Function.update", "code": "def update (f : \u2200 a, \u03b2 a) (a' : \u03b1) (v : \u03b2 a') (a : \u03b1) : \u03b2 a :=\n  if h : a = a' then Eq.ndrec v h.symm else f a", "start": [549, 1], "end": [551, 48], "kind": "commanddeclaration"}, {"full_name": "Function.update_same", "code": "@[simp]\ntheorem update_same (a : \u03b1) (v : \u03b2 a) (f : \u2200 a, \u03b2 a) : update f a v a = v", "start": [554, 1], "end": [556, 14], "kind": "commanddeclaration"}, {"full_name": "Function.update_noteq", "code": "@[simp]\ntheorem update_noteq {a a' : \u03b1} (h : a \u2260 a') (v : \u03b2 a') (f : \u2200 a, \u03b2 a) : update f a' v a = f a", "start": [559, 1], "end": [561, 12], "kind": "commanddeclaration"}, {"full_name": "Function.update_apply", "code": "theorem update_apply {\u03b2 : Sort*} (f : \u03b1 \u2192 \u03b2) (a' : \u03b1) (b : \u03b2) (a : \u03b1) :\n    update f a' b a = if a = a' then b else f a", "start": [564, 1], "end": [567, 61], "kind": "commanddeclaration"}, {"full_name": "Function.update_eq_const_of_subsingleton", "code": "@[nontriviality]\ntheorem update_eq_const_of_subsingleton [Subsingleton \u03b1] (a : \u03b1) (v : \u03b1') (f : \u03b1 \u2192 \u03b1') :\n    update f a v = const \u03b1 v", "start": [570, 1], "end": [573, 61], "kind": "commanddeclaration"}, {"full_name": "Function.surjective_eval", "code": "theorem surjective_eval {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} [h : \u2200 a, Nonempty (\u03b2 a)] (a : \u03b1) :\n    Surjective (eval a : (\u2200 a, \u03b2 a) \u2192 \u03b2 a)", "start": [575, 1], "end": [578, 47], "kind": "commanddeclaration"}, {"full_name": "Function.update_injective", "code": "theorem update_injective (f : \u2200 a, \u03b2 a) (a' : \u03b1) : Injective (update f a')", "start": [581, 1], "end": [583, 41], "kind": "commanddeclaration"}, {"full_name": "Function.forall_update_iff", "code": "lemma forall_update_iff (f : \u2200a, \u03b2 a) {a : \u03b1} {b : \u03b2 a} (p : \u2200a, \u03b2 a \u2192 Prop) :\n    (\u2200 x, p x (update f a b x)) \u2194 p a b \u2227 \u2200 x, x \u2260 a \u2192 p x (f x) := by\n  rw [\u2190 and_forall_ne a, update_same]\n  simp (config := { contextual := true })", "start": [586, 1], "end": [589, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Function.exists_update_iff", "code": "theorem exists_update_iff (f : \u2200 a, \u03b2 a) {a : \u03b1} {b : \u03b2 a} (p : \u2200 a, \u03b2 a \u2192 Prop) :\n    (\u2203 x, p x (update f a b x)) \u2194 p a b \u2228 \u2203 (x : _) (_ : x \u2260 a), p x (f x)", "start": [592, 1], "end": [595, 30], "kind": "commanddeclaration"}, {"full_name": "Function.update_eq_iff", "code": "theorem update_eq_iff {a : \u03b1} {b : \u03b2 a} {f g : \u2200 a, \u03b2 a} :\n    update f a b = g \u2194 b = g a \u2227 \u2200 (x) (_ : x \u2260 a), f x = g x", "start": [598, 1], "end": [600, 60], "kind": "commanddeclaration"}, {"full_name": "Function.eq_update_iff", "code": "theorem eq_update_iff {a : \u03b1} {b : \u03b2 a} {f g : \u2200 a, \u03b2 a} :\n    g = update f a b \u2194 g a = b \u2227 \u2200 (x) (_ : x \u2260 a), g x = f x", "start": [603, 1], "end": [605, 60], "kind": "commanddeclaration"}, {"full_name": "Function.update_eq_self_iff", "code": "@[simp] lemma update_eq_self_iff : update f a b = f \u2194 b = f a := by simp [update_eq_iff]", "start": [608, 1], "end": [608, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Function.eq_update_self_iff", "code": "@[simp] lemma eq_update_self_iff : f = update f a b \u2194 f a = b := by simp [eq_update_iff]", "start": [611, 1], "end": [611, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Function.ne_update_self_iff", "code": "lemma ne_update_self_iff : f \u2260 update f a b \u2194 f a \u2260 b := eq_update_self_iff.not", "start": [614, 1], "end": [614, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Function.update_ne_self_iff", "code": "lemma update_ne_self_iff : update f a b \u2260 f \u2194 b \u2260 f a := update_eq_self_iff.not", "start": [617, 1], "end": [617, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Function.update_eq_self", "code": "@[simp]\ntheorem update_eq_self (a : \u03b1) (f : \u2200 a, \u03b2 a) : update f a (f a) = f", "start": [620, 1], "end": [622, 39], "kind": "commanddeclaration"}, {"full_name": "Function.update_comp_eq_of_forall_ne'", "code": "theorem update_comp_eq_of_forall_ne' {\u03b1'} (g : \u2200 a, \u03b2 a) {f : \u03b1' \u2192 \u03b1} {i : \u03b1} (a : \u03b2 i)\n    (h : \u2200 x, f x \u2260 i) : (fun j \u21a6 (update g i a) (f j)) = fun j \u21a6 g (f j)", "start": [625, 1], "end": [627, 40], "kind": "commanddeclaration"}, {"full_name": "Function.update_comp_eq_of_forall_ne", "code": "theorem update_comp_eq_of_forall_ne {\u03b1 \u03b2 : Sort*} (g : \u03b1' \u2192 \u03b2) {f : \u03b1 \u2192 \u03b1'} {i : \u03b1'} (a : \u03b2)\n    (h : \u2200 x, f x \u2260 i) : update g i a \u2218 f = g \u2218 f", "start": [630, 1], "end": [633, 37], "kind": "commanddeclaration"}, {"full_name": "Function.update_comp_eq_of_injective'", "code": "theorem update_comp_eq_of_injective' (g : \u2200 a, \u03b2 a) {f : \u03b1' \u2192 \u03b1} (hf : Function.Injective f)\n    (i : \u03b1') (a : \u03b2 (f i)) : (fun j \u21a6 update g (f i) a (f j)) = update (fun i \u21a6 g (f i)) i a", "start": [636, 1], "end": [638, 78], "kind": "commanddeclaration"}, {"full_name": "Function.update_comp_eq_of_injective", "code": "theorem update_comp_eq_of_injective {\u03b2 : Sort*} (g : \u03b1' \u2192 \u03b2) {f : \u03b1 \u2192 \u03b1'}\n    (hf : Function.Injective f) (i : \u03b1) (a : \u03b2) :\n    Function.update g (f i) a \u2218 f = Function.update (g \u2218 f) i a", "start": [641, 1], "end": [645, 40], "kind": "commanddeclaration"}, {"full_name": "Function.apply_update", "code": "theorem apply_update {\u03b9 : Sort*} [DecidableEq \u03b9] {\u03b1 \u03b2 : \u03b9 \u2192 Sort*} (f : \u2200 i, \u03b1 i \u2192 \u03b2 i)\n    (g : \u2200 i, \u03b1 i) (i : \u03b9) (v : \u03b1 i) (j : \u03b9) :\n    f j (update g i v j) = update (fun k \u21a6 f k (g k)) i (f i v) j", "start": [648, 1], "end": [654, 13], "kind": "commanddeclaration"}, {"full_name": "Function.apply_update\u2082", "code": "theorem apply_update\u2082 {\u03b9 : Sort*} [DecidableEq \u03b9] {\u03b1 \u03b2 \u03b3 : \u03b9 \u2192 Sort*} (f : \u2200 i, \u03b1 i \u2192 \u03b2 i \u2192 \u03b3 i)\n    (g : \u2200 i, \u03b1 i) (h : \u2200 i, \u03b2 i) (i : \u03b9) (v : \u03b1 i) (w : \u03b2 i) (j : \u03b9) :\n    f j (update g i v j) (update h i w j) = update (fun k \u21a6 f k (g k) (h k)) i (f i v w) j", "start": [657, 1], "end": [663, 13], "kind": "commanddeclaration"}, {"full_name": "Function.comp_update", "code": "theorem comp_update {\u03b1' : Sort*} {\u03b2 : Sort*} (f : \u03b1' \u2192 \u03b2) (g : \u03b1 \u2192 \u03b1') (i : \u03b1) (v : \u03b1') :\n    f \u2218 update g i v = update (f \u2218 g) i (f v)", "start": [667, 1], "end": [669, 33], "kind": "commanddeclaration"}, {"full_name": "Function.update_comm", "code": "theorem update_comm {\u03b1} [DecidableEq \u03b1] {\u03b2 : \u03b1 \u2192 Sort*} {a b : \u03b1} (h : a \u2260 b) (v : \u03b2 a) (w : \u03b2 b)\n    (f : \u2200 a, \u03b2 a) : update (update f a v) b w = update (update f b w) a v", "start": [672, 1], "end": [681, 44], "kind": "commanddeclaration"}, {"full_name": "Function.update_idem", "code": "@[simp]\ntheorem update_idem {\u03b1} [DecidableEq \u03b1] {\u03b2 : \u03b1 \u2192 Sort*} {a : \u03b1} (v w : \u03b2 a) (f : \u2200 a, \u03b2 a) :\n    update (update f a v) a w = update f a w", "start": [684, 1], "end": [688, 42], "kind": "commanddeclaration"}, {"full_name": "Function.extend", "code": "def extend (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) (j : \u03b2 \u2192 \u03b3) : \u03b2 \u2192 \u03b3 := fun b \u21a6\n  if h : \u2203 a, f a = b then g (Classical.choose h) else j b", "start": [699, 1], "end": [712, 59], "kind": "commanddeclaration"}, {"full_name": "Function.FactorsThrough", "code": "def FactorsThrough (g : \u03b1 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 \u2983a b\u2984, f a = f b \u2192 g a = g b", "start": [715, 1], "end": [717, 33], "kind": "commanddeclaration"}, {"full_name": "Function.extend_def", "code": "theorem extend_def (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) (e' : \u03b2 \u2192 \u03b3) (b : \u03b2) [Decidable (\u2203 a, f a = b)] :\n    extend f g e' b = if h : \u2203 a, f a = b then g (Classical.choose h) else e' b", "start": [720, 1], "end": [723, 8], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.factorsThrough", "code": "lemma Injective.factorsThrough (hf : Injective f) (g : \u03b1 \u2192 \u03b3) : g.FactorsThrough f :=\n  fun _ _ h => congr_arg g (hf h)", "start": [726, 1], "end": [727, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Function.FactorsThrough.extend_apply", "code": "lemma FactorsThrough.extend_apply {g : \u03b1 \u2192 \u03b3} (hf : g.FactorsThrough f) (e' : \u03b2 \u2192 \u03b3) (a : \u03b1) :\n    extend f g e' (f a) = g a := by\n  simp only [extend_def, dif_pos, exists_apply_eq_apply]\n  exact hf (Classical.choose_spec (exists_apply_eq_apply f a))", "start": [730, 1], "end": [733, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Injective.extend_apply", "code": "@[simp]\ntheorem Injective.extend_apply (hf : Injective f) (g : \u03b1 \u2192 \u03b3) (e' : \u03b2 \u2192 \u03b3) (a : \u03b1) :\n    extend f g e' (f a) = g a", "start": [736, 1], "end": [739, 42], "kind": "commanddeclaration"}, {"full_name": "Function.extend_apply'", "code": "@[simp]\ntheorem extend_apply' (g : \u03b1 \u2192 \u03b3) (e' : \u03b2 \u2192 \u03b3) (b : \u03b2) (hb : \u00ac\u2203 a, f a = b) :\n    extend f g e' b = e' b", "start": [742, 1], "end": [745, 33], "kind": "commanddeclaration"}, {"full_name": "Function.factorsThrough_iff", "code": "lemma factorsThrough_iff (g : \u03b1 \u2192 \u03b3) [Nonempty \u03b3] : g.FactorsThrough f \u2194 \u2203 (e : \u03b2 \u2192 \u03b3), g = e \u2218 f :=\n\u27e8fun hf => \u27e8extend f g (const \u03b2 (Classical.arbitrary \u03b3)),\n      funext (fun x => by simp only [comp_apply, hf.extend_apply])\u27e9,\n  fun h _ _ hf => by rw [Classical.choose_spec h, comp_apply, comp_apply, hf]\u27e9", "start": [748, 1], "end": [751, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Function.FactorsThrough.apply_extend", "code": "lemma FactorsThrough.apply_extend {\u03b4} {g : \u03b1 \u2192 \u03b3} (hf : FactorsThrough g f)\n    (F : \u03b3 \u2192 \u03b4) (e' : \u03b2 \u2192 \u03b3) (b : \u03b2) :\n    F (extend f g e' b) = extend f (F \u2218 g) (F \u2218 e') b := by\n  by_cases hb : \u2203 a, f a = b\n  case pos =>\n    rcases hb with \u27e8a, ha\u27e9\n    subst b\n    rw [hf.extend_apply, FactorsThrough.extend_apply, comp]\n    case intro.hf =>\n      intro a b h\n      simp only [comp_apply]\n      apply congr_arg\n      exact hf h\n  case neg =>\n    rw [extend_apply' _ _ _ hb, extend_apply' _ _ _ hb, comp]", "start": [754, 1], "end": [768, 62], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Injective.apply_extend", "code": "lemma Injective.apply_extend {\u03b4} (hf : Injective f) (F : \u03b3 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b3) (e' : \u03b2 \u2192 \u03b3) (b : \u03b2) :\n    F (extend f g e' b) = extend f (F \u2218 g) (F \u2218 e') b :=\n  (hf.factorsThrough g).apply_extend F e' b", "start": [771, 1], "end": [773, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Function.extend_injective", "code": "theorem extend_injective (hf : Injective f) (e' : \u03b2 \u2192 \u03b3) : Injective fun g \u21a6 extend f g e'", "start": [776, 1], "end": [781, 10], "kind": "commanddeclaration"}, {"full_name": "Function.FactorsThrough.extend_comp", "code": "lemma FactorsThrough.extend_comp {g : \u03b1 \u2192 \u03b3} (e' : \u03b2 \u2192 \u03b3) (hf : FactorsThrough g f) :\n    extend f g e' \u2218 f = g :=\n  funext $ fun a => hf.extend_apply e' a", "start": [784, 1], "end": [786, 41], "kind": "mathlibtacticlemma"}, {"full_name": "Function.extend_comp", "code": "@[simp]\ntheorem extend_comp (hf : Injective f) (g : \u03b1 \u2192 \u03b3) (e' : \u03b2 \u2192 \u03b3) : extend f g e' \u2218 f = g", "start": [789, 1], "end": [791, 40], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.surjective_comp_right'", "code": "theorem Injective.surjective_comp_right' (hf : Injective f) (g\u2080 : \u03b2 \u2192 \u03b3) :\n    Surjective fun g : \u03b2 \u2192 \u03b3 \u21a6 g \u2218 f", "start": [794, 1], "end": [796, 46], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.surjective_comp_right", "code": "theorem Injective.surjective_comp_right [Nonempty \u03b3] (hf : Injective f) :\n    Surjective fun g : \u03b2 \u2192 \u03b3 \u21a6 g \u2218 f", "start": [799, 1], "end": [801, 57], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.comp_right", "code": "theorem Bijective.comp_right (hf : Bijective f) : Bijective fun g : \u03b2 \u2192 \u03b3 \u21a6 g \u2218 f", "start": [804, 1], "end": [807, 91], "kind": "commanddeclaration"}, {"full_name": "Function.uncurry_def", "code": "theorem uncurry_def {\u03b1 \u03b2 \u03b3} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : uncurry f = fun p \u21a6 f p.1 p.2", "start": [812, 1], "end": [813, 6], "kind": "commanddeclaration"}, {"full_name": "Function.uncurry_apply_pair", "code": "@[simp]\ntheorem uncurry_apply_pair {\u03b1 \u03b2 \u03b3} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (x : \u03b1) (y : \u03b2) : uncurry f (x, y) = f x y", "start": [816, 1], "end": [818, 6], "kind": "commanddeclaration"}, {"full_name": "Function.curry_apply", "code": "@[simp]\ntheorem curry_apply {\u03b1 \u03b2 \u03b3} (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (x : \u03b1) (y : \u03b2) : curry f x y = f (x, y)", "start": [821, 1], "end": [823, 6], "kind": "commanddeclaration"}, {"full_name": "Function.bicompl", "code": "def bicompl (f : \u03b3 \u2192 \u03b4 \u2192 \u03b5) (g : \u03b1 \u2192 \u03b3) (h : \u03b2 \u2192 \u03b4) (a b) :=\n  f (g a) (h b)", "start": [830, 1], "end": [833, 16], "kind": "commanddeclaration"}, {"full_name": "Function.bicompr", "code": "def bicompr (f : \u03b3 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a b) :=\n  f (g a b)", "start": [836, 1], "end": [838, 12], "kind": "commanddeclaration"}, {"full_name": "Function.uncurry_bicompr", "code": "theorem uncurry_bicompr (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 \u03b4) : uncurry (g \u2218\u2082 f) = g \u2218 uncurry f", "start": [844, 1], "end": [845, 6], "kind": "commanddeclaration"}, {"full_name": "Function.uncurry_bicompl", "code": "theorem uncurry_bicompl (f : \u03b3 \u2192 \u03b4 \u2192 \u03b5) (g : \u03b1 \u2192 \u03b3) (h : \u03b2 \u2192 \u03b4) :\n    uncurry (bicompl f g h) = uncurry f \u2218 Prod.map g h", "start": [848, 1], "end": [850, 6], "kind": "commanddeclaration"}, {"full_name": "Function.HasUncurry", "code": "class HasUncurry (\u03b1 : Type*) (\u03b2 : outParam (Type*)) (\u03b3 : outParam (Type*)) where\n  \n  uncurry : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [859, 1], "end": [866, 22], "kind": "commanddeclaration"}, {"full_name": "Function.hasUncurryBase", "code": "instance hasUncurryBase : HasUncurry (\u03b1 \u2192 \u03b2) \u03b1 \u03b2 :=\n  \u27e8id\u27e9", "start": [871, 1], "end": [872, 7], "kind": "commanddeclaration"}, {"full_name": "Function.hasUncurryInduction", "code": "instance hasUncurryInduction [HasUncurry \u03b2 \u03b3 \u03b4] : HasUncurry (\u03b1 \u2192 \u03b2) (\u03b1 \u00d7 \u03b3) \u03b4 :=\n  \u27e8fun f p \u21a6 (\u21bf(f p.1)) p.2\u27e9", "start": [874, 1], "end": [875, 29], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive", "code": "def Involutive {\u03b1} (f : \u03b1 \u2192 \u03b1) : Prop :=\n  \u2200 x, f (f x) = x", "start": [879, 1], "end": [881, 19], "kind": "commanddeclaration"}, {"full_name": "Bool.involutive_not", "code": "theorem _root_.Bool.involutive_not : Involutive not", "start": [884, 1], "end": [885, 15], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.comp_self", "code": "@[simp]\ntheorem comp_self : f \u2218 f = id", "start": [891, 1], "end": [893, 11], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.leftInverse", "code": "protected theorem leftInverse : LeftInverse f f", "start": [896, 1], "end": [896, 53], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.rightInverse", "code": "protected theorem rightInverse : RightInverse f f", "start": [899, 1], "end": [899, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.injective", "code": "protected theorem injective : Injective f", "start": [902, 1], "end": [902, 69], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.surjective", "code": "protected theorem surjective : Surjective f", "start": [905, 1], "end": [905, 66], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.bijective", "code": "protected theorem bijective : Bijective f", "start": [908, 1], "end": [908, 73], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.ite_not", "code": "protected theorem ite_not (P : Prop) [Decidable P] (x : \u03b1) : f (ite P x (f x)) = ite (\u00acP) x (f x)", "start": [911, 1], "end": [913, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.eq_iff", "code": "protected theorem eq_iff {x y : \u03b1} : f x = y \u2194 x = f y", "start": [916, 1], "end": [918, 28], "kind": "commanddeclaration"}, {"full_name": "Function.Injective2", "code": "def Injective2 {\u03b1 \u03b2 \u03b3} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Prop :=\n  \u2200 \u2983a\u2081 a\u2082 b\u2081 b\u2082\u2984, f a\u2081 b\u2081 = f a\u2082 b\u2082 \u2192 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082", "start": [923, 1], "end": [927, 57], "kind": "commanddeclaration"}, {"full_name": "Function.Injective2.left", "code": "protected theorem left (hf : Injective2 f) (b : \u03b2) : Function.Injective fun a \u21a6 f a b", "start": [934, 1], "end": [936, 26], "kind": "commanddeclaration"}, {"full_name": "Function.Injective2.right", "code": "protected theorem right (hf : Injective2 f) (a : \u03b1) : Function.Injective (f a)", "start": [939, 1], "end": [941, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Injective2.uncurry", "code": "protected theorem uncurry {\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hf : Injective2 f) :\n    Function.Injective (uncurry f)", "start": [944, 1], "end": [946, 51], "kind": "commanddeclaration"}, {"full_name": "Function.Injective2.left'", "code": "theorem left' (hf : Injective2 f) [Nonempty \u03b2] : Function.Injective f", "start": [949, 1], "end": [952, 35], "kind": "commanddeclaration"}, {"full_name": "Function.Injective2.right'", "code": "theorem right' (hf : Injective2 f) [Nonempty \u03b1] : Function.Injective fun b a \u21a6 f a b", "start": [955, 1], "end": [959, 38], "kind": "commanddeclaration"}, {"full_name": "Function.Injective2.eq_iff", "code": "theorem eq_iff (hf : Injective2 f) {a\u2081 a\u2082 b\u2081 b\u2082} : f a\u2081 b\u2081 = f a\u2082 b\u2082 \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082", "start": [962, 1], "end": [963, 52], "kind": "commanddeclaration"}, {"full_name": "Function.sometimes", "code": "noncomputable def sometimes {\u03b1 \u03b2} [Nonempty \u03b2] (f : \u03b1 \u2192 \u03b2) : \u03b2 :=\n  if h : Nonempty \u03b1 then f (Classical.choice h) else Classical.choice \u2039_\u203a", "start": [972, 1], "end": [976, 74], "kind": "commanddeclaration"}, {"full_name": "Function.sometimes_eq", "code": "theorem sometimes_eq {p : Prop} {\u03b1} [Nonempty \u03b1] (f : p \u2192 \u03b1) (a : p) : sometimes f = f a", "start": [979, 1], "end": [980, 14], "kind": "commanddeclaration"}, {"full_name": "Function.sometimes_spec", "code": "theorem sometimes_spec {p : Prop} {\u03b1} [Nonempty \u03b1] (P : \u03b1 \u2192 Prop) (f : p \u2192 \u03b1) (a : p)\n    (h : P (f a)) : P (sometimes f)", "start": [983, 1], "end": [985, 24], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise", "code": "def Set.piecewise {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Sort v} (s : Set \u03b1) (f g : \u2200 i, \u03b2 i)\n    [\u2200 j, Decidable (j \u2208 s)] : \u2200 i, \u03b2 i :=\n  fun i \u21a6 if i \u2208 s then f i else g i", "start": [992, 1], "end": [995, 37], "kind": "commanddeclaration"}, {"full_name": "eq_rec_on_bijective", "code": "theorem eq_rec_on_bijective {\u03b1 : Sort*} {C : \u03b1 \u2192 Sort*} :\n    \u2200 {a a' : \u03b1} (h : a = a'), Function.Bijective (@Eq.ndrec _ _ C \u00b7 _ h)", "start": [1001, 1], "end": [1003, 50], "kind": "commanddeclaration"}, {"full_name": "eq_mp_bijective", "code": "theorem eq_mp_bijective {\u03b1 \u03b2 : Sort _} (h : \u03b1 = \u03b2) : Function.Bijective (Eq.mp h)", "start": [1006, 1], "end": [1010, 42], "kind": "commanddeclaration"}, {"full_name": "eq_mpr_bijective", "code": "theorem eq_mpr_bijective {\u03b1 \u03b2 : Sort _} (h : \u03b1 = \u03b2) : Function.Bijective (Eq.mpr h)", "start": [1013, 1], "end": [1015, 42], "kind": "commanddeclaration"}, {"full_name": "cast_bijective", "code": "theorem cast_bijective {\u03b1 \u03b2 : Sort _} (h : \u03b1 = \u03b2) : Function.Bijective (cast h)", "start": [1018, 1], "end": [1020, 42], "kind": "commanddeclaration"}, {"full_name": "eq_rec_inj", "code": "@[simp]\ntheorem eq_rec_inj {\u03b1 : Sort*} {a a' : \u03b1} (h : a = a') {C : \u03b1 \u2192 Type*} (x y : C a) :\n    (Eq.ndrec x h : C a') = Eq.ndrec y h \u2194 x = y", "start": [1027, 1], "end": [1030, 43], "kind": "commanddeclaration"}, {"full_name": "cast_inj", "code": "@[simp]\ntheorem cast_inj {\u03b1 \u03b2 : Type u} (h : \u03b1 = \u03b2) {x y : \u03b1} : cast h x = cast h y \u2194 x = y", "start": [1033, 1], "end": [1035, 38], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.eq_rec_eq", "code": "theorem Function.LeftInverse.eq_rec_eq {\u03b1 \u03b2 : Sort*} {\u03b3 : \u03b2 \u2192 Sort v} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : Function.LeftInverse g f) (C : \u2200 a : \u03b1, \u03b3 (f a)) (a : \u03b1) :\n    @Eq.rec \u03b2 (f (g (f a))) (fun x _ \u21a6 \u03b3 x) (C (g (f a))) (f a) (congr_arg f (h a)) = C a", "start": [1038, 1], "end": [1042, 51], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.eq_rec_on_eq", "code": "theorem Function.LeftInverse.eq_rec_on_eq {\u03b1 \u03b2 : Sort*} {\u03b3 : \u03b2 \u2192 Sort v} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : Function.LeftInverse g f) (C : \u2200 a : \u03b1, \u03b3 (f a)) (a : \u03b1) :\n    @Eq.recOn \u03b2 (f (g (f a))) (fun x _ \u21a6 \u03b3 x) (f a) (congr_arg f (h a)) (C (g (f a))) = C a", "start": [1045, 1], "end": [1049, 18], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.cast_eq", "code": "theorem Function.LeftInverse.cast_eq {\u03b1 \u03b2 : Sort*} {\u03b3 : \u03b2 \u2192 Sort v} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : Function.LeftInverse g f) (C : \u2200 a : \u03b1, \u03b3 (f a)) (a : \u03b1) :\n    cast (congr_arg (fun a \u21a6 \u03b3 (f a)) (h a)) (C (g (f a))) = C a", "start": [1052, 1], "end": [1055, 26], "kind": "commanddeclaration"}, {"full_name": "Set.SeparatesPoints", "code": "def Set.SeparatesPoints {\u03b1 \u03b2 : Type*} (A : Set (\u03b1 \u2192 \u03b2)) : Prop :=\n  \u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 \u2203 f \u2208 A, (f x : \u03b2) \u2260 f y", "start": [1058, 1], "end": [1061, 48], "kind": "commanddeclaration"}, {"full_name": "IsSymmOp.flip_eq", "code": "theorem IsSymmOp.flip_eq {\u03b1 \u03b2} (op) [IsSymmOp \u03b1 \u03b2 op] : flip op = op", "start": [1064, 1], "end": [1065, 60], "kind": "commanddeclaration"}, {"full_name": "InvImage.equivalence", "code": "theorem InvImage.equivalence {\u03b1 : Sort u} {\u03b2 : Sort v} (r : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\n    (h : Equivalence r) : Equivalence (InvImage r f)", "start": [1068, 1], "end": [1070, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/CompileInductive.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/CSimpAttr.lean", "Mathlib/Tactic/RunCmd.lean", "lake-packages/lean4/src/lean/Lean/Elab/PreDefinition.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Util.replaceConst", "code": "private def replaceConst (repl : AssocList Name Name) (e : Expr) : Expr :=\n  e.replace fun | .const n us => repl.find? n |>.map (.const \u00b7 us) | _ => none", "start": [28, 1], "end": [29, 79], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Util.mkRecNames", "code": "def mkRecNames (all : List Name) (numMotives : Nat) : List Name :=\n  if numMotives \u2264 all.length then\n    all.map mkRecName\n  else\n    let main := all[0]!\n    all.map mkRecName ++\n      (List.range (numMotives - all.length)).map (fun i => main.str s!\"rec_{i+1}\")", "start": [31, 1], "end": [39, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Util.addAndCompile'", "code": "private def addAndCompile' (decl : Declaration) : CoreM Unit := do\n  try addAndCompile decl\n  catch e =>\n    match decl with\n    | .defnDecl val => throwError \"while compiling {val.name}: {e.toMessageData}\"\n    | .mutualDefnDecl val => throwError \"while compiling {val.map (\u00b7.name)}: {e.toMessageData}\"\n    | _ => unreachable!", "start": [41, 1], "end": [47, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Util.compileDefn", "code": "def compileDefn (dv : DefinitionVal) : MetaM Unit := do\n  if ((\u2190 getEnv).getModuleIdxFor? dv.name).isNone then\n    return \u2190 compileDecl <| .defnDecl dv\n  let name \u2190 mkFreshUserName dv.name\n  addAndCompile' <| .defnDecl { dv with name }\n  let levels := dv.levelParams.map .param\n  let old := .const dv.name levels\n  let new := .const name levels\n  let name \u2190 mkFreshUserName <| dv.name.str \"eq\"\n  addDecl <| .thmDecl {\n    name\n    levelParams := dv.levelParams\n    type := \u2190 mkEq old new\n    value := \u2190 mkEqRefl old\n  }\n  Compiler.CSimp.add name .global", "start": [49, 1], "end": [70, 34], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Util.isCompiled", "code": "def isCompiled (env : Environment) (n : Name) : Bool :=\n  env.contains (n.str \"_cstage2\") || (Compiler.CSimp.ext.getState env).map.contains n", "start": [74, 1], "end": [77, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Util.compileStructOnly", "code": "private def compileStructOnly (iv : InductiveVal) (rv : RecursorVal) : MetaM Unit := do\n  let value \u2190 forallTelescope rv.type fun xs _ =>\n    let val := xs[rv.getFirstMinorIdx]!\n    let val := mkAppN val \u27e8.map (xs[rv.getMajorIdx]!.proj iv.name) <| .range rv.rules[0]!.nfields\u27e9\n    mkLambdaFVars xs val\n  go value\nwhere\n  go value := do\n    let name \u2190 mkFreshUserName rv.name\n    addAndCompile' <| .defnDecl { rv with\n      name\n      value\n      hints := .abbrev\n      safety := .safe\n    }\n    let levels := rv.levelParams.map .param\n    let old := .const rv.name levels\n    let new := .const name levels\n    let name \u2190 mkFreshUserName <| rv.name.str \"eq\"\n    addDecl <| .mutualDefnDecl [{\n      name\n      levelParams := rv.levelParams\n      type := \u2190 mkEq old new\n      value := .const name levels\n      hints := .opaque\n      safety := .partial\n    }]\n    Compiler.CSimp.add name .global\n    compileDefn <| \u2190 getConstInfoDefn <| mkRecOnName iv.name", "start": [93, 1], "end": [121, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Util.compileInductiveOnly", "code": "def compileInductiveOnly (iv : InductiveVal) (warn := true) : MetaM Unit := do\n  let rv \u2190 getConstInfoRec <| mkRecName iv.name\n  if \u2190 isProp rv.type then\n    if warn then logWarning m!\"not compiling {rv.name}\"\n    return\n  if isCompiled (\u2190 getEnv) rv.name then\n    if warn then logWarning m!\"already compiled {rv.name}\"\n    return\n  if !iv.isRec && rv.numMotives == 1 && iv.numCtors == 1 && iv.numIndices == 0 then\n    compileStructOnly iv rv\n    return\n  let levels := rv.levelParams.map .param\n  let rvs \u2190\n    if rv.numMotives == 1 then pure [rv]\n    else mkRecNames iv.all rv.numMotives |>.mapM getConstInfoRec\n  let rvs \u2190 rvs.mapM fun rv => return (rv, \u2190 mkFreshUserName rv.name)\n  let repl := rvs.foldl (fun l (rv, name) => .cons rv.name name l) .nil\n  addAndCompile' <| .mutualDefnDecl <|\u2190 rvs.mapM fun (rv, name) => do\n    pure { rv with\n      name\n      value := \u2190 forallTelescope rv.type fun xs body => do\n        let major := xs[rv.getMajorIdx]!\n        (\u2190 whnfD <| \u2190 inferType major).withApp fun head args => do\n          let .const iv levels' := head | throwError \"not an inductive\"\n          let iv \u2190 getConstInfoInduct iv\n          let rv' \u2190 getConstInfoRec <| mkRecName iv.name\n          if !iv.isRec && rv'.numMotives == 1 && iv.numCtors == 1 && iv.numIndices == 0 then\n            let rule := rv.rules[0]!\n            let val := .beta (replaceConst repl rule.rhs) xs[:rv.getFirstIndexIdx]\n            let val := .beta val \u27e8.map (major.proj iv.name) <| .range rule.nfields\u27e9\n            mkLambdaFVars xs val\n          else\n            let val := .const (mkCasesOnName iv.name) (.param rv.levelParams.head! :: levels')\n            let val := mkAppN val args[:rv'.numParams]\n            let val := .app val <| \u2190 mkLambdaFVars xs[rv.getFirstIndexIdx:] body\n            let val := mkAppN val xs[rv.getFirstIndexIdx:]\n            let val := mkAppN val <| rv.rules.toArray.map fun rule =>\n              .beta (replaceConst repl rule.rhs) xs[:rv.getFirstIndexIdx]\n            mkLambdaFVars xs val\n      hints := .opaque\n      safety := .partial\n    }\n  for (rv, name) in rvs do\n    let old := .const rv.name levels\n    let new := .const name levels\n    let name \u2190 mkFreshUserName <| rv.name.str \"eq\"\n    addDecl <| .mutualDefnDecl [{\n      name\n      levelParams := rv.levelParams\n      type := \u2190 mkEq old new\n      value := .const name levels\n      hints := .opaque\n      safety := .partial\n    }]\n    Compiler.CSimp.add name .global\n  for name in iv.all do\n    for aux in [mkRecOnName name, mkBRecOnName name] do\n      if let some (.defnInfo dv) := (\u2190 getEnv).find? aux then\n        compileDefn dv", "start": [123, 1], "end": [184, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Util.compileInductive", "code": "partial def compileInductive (iv : InductiveVal) (warn := true) : MetaM Unit := do\n  compileInductiveOnly iv warn\n  compileSizeOf iv", "start": [188, 1], "end": [193, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Util.compileSizeOf", "code": "partial def compileSizeOf (iv : InductiveVal) : MetaM Unit := do\n  let go aux := do\n    if let some (.defnInfo dv) := (\u2190 getEnv).find? aux then\n      if !isCompiled (\u2190 getEnv) aux then\n        let deps : NameSet := dv.value.foldConsts \u2205 fun c arr =>\n          if let .str name \"_sizeOf_inst\" := c then arr.insert name else arr\n        for i in deps do\n          if let some (.inductInfo iv) := (\u2190 getEnv).find? i then\n            compileInductive iv (warn := false)\n        compileDefn dv\n  let rv \u2190 getConstInfoRec <| mkRecName iv.name\n  for name in iv.all do\n    for i in [:rv.numMotives] do\n      go <| name.str s!\"_sizeOf_{i+1}\"\n    go <| name.str \"_sizeOf_inst\"", "start": [195, 1], "end": [213, 34], "kind": "commanddeclaration"}, {"full_name": "Float.valUnsafe", "code": "private unsafe def Float.valUnsafe : Float \u2192 floatSpec.float := unsafeCast", "start": [245, 1], "end": [245, 75], "kind": "commanddeclaration"}, {"full_name": "Float.mkUnsafe", "code": "private unsafe def Float.mkUnsafe : floatSpec.float \u2192 Float := unsafeCast", "start": [246, 1], "end": [246, 74], "kind": "commanddeclaration"}, {"full_name": "Float.valImpl", "code": "@[implemented_by Float.valUnsafe] private def Float.valImpl (x : Float) : floatSpec.float := x.1", "start": [247, 1], "end": [247, 97], "kind": "commanddeclaration"}, {"full_name": "Float.mkImpl", "code": "@[implemented_by Float.mkUnsafe] private def Float.mkImpl (x : floatSpec.float) : Float := \u27e8x\u27e9", "start": [248, 1], "end": [248, 95], "kind": "commanddeclaration"}, {"full_name": "Float.val_eq", "code": "@[csimp] private theorem Float.val_eq : @Float.val = Float.valImpl", "start": [249, 1], "end": [249, 74], "kind": "commanddeclaration"}, {"full_name": "Float.mk_eq", "code": "@[csimp] private theorem Float.mk_eq : @Float.mk = Float.mkImpl", "start": [250, 1], "end": [250, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormCast.lean", "imports": ["Mathlib/Tactic/NormCast/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/aesop/Aesop/Search/SearchM.lean", "imports": ["lake-packages/aesop/Aesop/RuleSet.lean", "lake-packages/aesop/Aesop/Search/Expansion/Simp.lean", "lake-packages/aesop/Aesop/Options.lean", "lake-packages/aesop/Aesop/Search/Queue/Class.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Profiling.lean"], "premises": [{"full_name": "Aesop.NormSimpContext", "code": "structure NormSimpContext extends Simp.Context where\n  enabled : Bool\n  useHyps : Bool\n  configStx? : Option Term\n  deriving Inhabited", "start": [18, 1], "end": [22, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.SearchM.Context", "code": "structure Context where\n  ruleSet : RuleSet\n  normSimpContext : NormSimpContext\n  options : Aesop.Options'\n  profilingEnabled : Bool\n  deriving Nonempty", "start": [26, 1], "end": [31, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.SearchM.Context.normSimpConfig", "code": "def Context.normSimpConfig (ctx : Context) : SimpConfig where\n  useHyps := ctx.normSimpContext.useHyps\n  toConfigCtx := { ctx.normSimpContext.config with }", "start": [33, 1], "end": [35, 53], "kind": "commanddeclaration"}, {"full_name": "Aesop.SearchM.State", "code": "structure State (Q) [Aesop.Queue Q] where\n  iteration : Iteration\n  queue : Q\n  profile : Profile\n  maxRuleApplicationDepthReached : Bool\n  deriving Inhabited", "start": [37, 1], "end": [42, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.SearchM", "code": "abbrev SearchM Q [Aesop.Queue Q] :=\n  ReaderT SearchM.Context $ StateRefT (SearchM.State Q) $ StateRefT Tree MetaM", "start": [46, 1], "end": [47, 79], "kind": "commanddeclaration"}, {"full_name": "Aesop.SearchM.run'", "code": "def run' (ctx : SearchM.Context) (\u03c3 : SearchM.State Q) (t : Tree)\n    (x : SearchM Q \u03b1) : MetaM (\u03b1 \u00d7 SearchM.State Q \u00d7 Tree) := do\n  let ((a, \u03c3), t) \u2190 ReaderT.run x ctx |>.run \u03c3 |>.run t\n  return (a, \u03c3, t)", "start": [85, 1], "end": [88, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.SearchM.run", "code": "def run (ruleSet : RuleSet) (options : Aesop.Options')\n    (simpConfig : Aesop.SimpConfig) (simpConfigStx? : Option Term)\n    (goal : MVarId) (profile : Profile) (x : SearchM Q \u03b1) :\n    MetaM (\u03b1 \u00d7 State Q \u00d7 Tree) := do\n  let t \u2190 mkInitialTree goal\n  let profilingEnabled := (\u2190 getOptions).getBool `profiler\n  let normSimpContext := {\n    (\u2190 Simp.Context.mkDefault) with\n    config := simpConfig.toConfig\n    simpTheorems := ruleSet.globalNormSimpTheorems\n    configStx? := simpConfigStx?\n    enabled := simpConfig.enabled\n    useHyps := simpConfig.useHyps\n  }\n  let ctx := { ruleSet, options, profilingEnabled, normSimpContext }\n  let #[rootGoal] := (\u2190 t.root.get).goals\n    | throwError \"aesop: internal error: root mvar cluster does not contain exactly one goal.\"\n  let state := {\n    queue := \u2190 Queue.init' #[rootGoal]\n    iteration := Iteration.one\n    profile\n    maxRuleApplicationDepthReached := false\n  }\n  let ((a, state), tree) \u2190 ReaderT.run x ctx |>.run state |>.run t\n  return (a, state, tree)", "start": [90, 1], "end": [114, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.getTree", "code": "def getTree : SearchM Q Tree :=\n  getThe Tree", "start": [118, 1], "end": [119, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.setTree", "code": "def setTree : Tree \u2192 SearchM Q Unit :=\n  setThe Tree", "start": [121, 1], "end": [122, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.modifyTree", "code": "def modifyTree : (Tree \u2192 Tree) \u2192 SearchM Q Unit :=\n  modifyThe Tree", "start": [124, 1], "end": [125, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.getIteration", "code": "def getIteration : SearchM Q Iteration :=\n  return (\u2190 get).iteration", "start": [127, 1], "end": [128, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.incrementIteration", "code": "def incrementIteration : SearchM Q Unit :=\n  modify \u03bb s => { s with iteration := s.iteration.succ }", "start": [130, 1], "end": [131, 57], "kind": "commanddeclaration"}, {"full_name": "Aesop.popGoal?", "code": "def popGoal? : SearchM Q (Option GoalRef) := do\n  let s \u2190 get\n  let (goal?, queue) \u2190 Queue.popGoal s.queue\n  set { s with queue }\n  return goal?", "start": [133, 1], "end": [137, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.enqueueGoals", "code": "def enqueueGoals (gs : Array GoalRef) : SearchM Q Unit := do\n  let s \u2190 get\n  let queue \u2190 Queue.addGoals s.queue gs\n  set { s with queue }", "start": [139, 1], "end": [142, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.setMaxRuleApplicationDepthReached", "code": "def setMaxRuleApplicationDepthReached : SearchM Q Unit :=\n  modify \u03bb s => { s with maxRuleApplicationDepthReached := true }", "start": [144, 1], "end": [145, 66], "kind": "commanddeclaration"}, {"full_name": "Aesop.wasMaxRuleApplicationDepthReached", "code": "def wasMaxRuleApplicationDepthReached : SearchM Q Bool :=\n  return (\u2190 get).maxRuleApplicationDepthReached", "start": [147, 1], "end": [148, 48], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/RuleTac/Preprocess.lean", "imports": ["lake-packages/aesop/Aesop/RuleTac/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleTac.preprocess", "code": "def preprocess : RuleTac := RuleTac.ofSingleRuleTac \u03bb input => do\n  let (postMVarId, _, scriptBuilder?) \u2190\n    renameInaccessibleFVarsWithScript input.goal input.options.generateScript\n  return (#[postMVarId], scriptBuilder?, none)", "start": [13, 1], "end": [20, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/RuleTac/Apply.lean", "imports": ["lake-packages/aesop/Aesop/RuleTac/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleTac.applyExpr", "code": "private def applyExpr (goal : MVarId) (e : Expr) (n : Name)\n    (md : TransparencyMode) (generateScript : Bool) :\n    MetaM (Array MVarId \u00d7 Option RuleTacScriptBuilder \u00d7 Option Percent) := do\n  let goals := (\u2190 withTransparency md $ goal.apply e).toArray\n  let scriptBuilder? :=\n    mkScriptBuilder? generateScript $\n      .ofTactic goals.size do\n        withAllTransparencySyntax md (\u2190 `(tactic| apply $(mkIdent n)))\n  return (goals, scriptBuilder?, none)", "start": [14, 1], "end": [22, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.applyConst", "code": "def applyConst (decl : Name) (md : TransparencyMode) : RuleTac :=\n  RuleTac.ofSingleRuleTac \u03bb input => do\n    applyExpr input.goal (\u2190 mkConstWithFreshMVarLevels decl) decl md\n      input.options.generateScript", "start": [24, 1], "end": [27, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.applyFVar", "code": "def applyFVar (userName : Name) (md : TransparencyMode) : RuleTac :=\n  RuleTac.ofSingleRuleTac \u03bb input =>\n    input.goal.withContext do\n      applyExpr input.goal (\u2190 getLocalDeclFromUserName userName).toExpr\n        userName md input.options.generateScript", "start": [29, 1], "end": [33, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.applyConsts", "code": "def applyConsts (decls : Array Name) (md : TransparencyMode) :\n    RuleTac := \u03bb input => do\n  let initialState \u2190 saveState\n  let generateScript := input.options.generateScript\n  let apps \u2190 decls.filterMapM \u03bb decl => do\n    try\n      let e \u2190 mkConstWithFreshMVarLevels decl\n      let (goals, scriptBuilder?, successProbability?) \u2190\n        applyExpr input.goal e decl md generateScript\n      let postState \u2190 saveState\n      return some { postState, goals, scriptBuilder?, successProbability? }\n    catch _ =>\n      return none\n    finally\n      restoreState initialState\n  if apps.isEmpty then throwError\n    \"failed to apply any of these declarations:{decls}\"\n  return \u27e8apps\u27e9", "start": [37, 1], "end": [54, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/RuleTac/Forward.lean", "imports": ["lake-packages/std/Std/Lean/Meta/AssertHypotheses.lean", "lake-packages/aesop/Aesop/RuleTac/Basic.lean", "lake-packages/std/Std/Lean/Meta/UnusedNames.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleTac.makeForwardHyps", "code": "private partial def makeForwardHyps (e : Expr)\n    (immediate : UnorderedArraySet Nat) (collectUsedHyps : Bool) :\n    MetaM (Array Expr \u00d7 Array FVarId) :=\n  withNewMCtxDepth (allowLevelAssignments := true) do\n    let (argMVars, binderInfos, _) \u2190 forallMetaTelescopeReducing (\u2190 inferType e)\n    let app := mkAppN e argMVars\n    let mut instMVars := Array.mkEmpty argMVars.size\n    let mut immediateMVars := Array.mkEmpty argMVars.size\n    for i in [:argMVars.size] do\n      let mvarId := argMVars[i]!.mvarId!\n      if immediate.contains i then\n        immediateMVars := immediateMVars.push mvarId\n      else if binderInfos[i]!.isInstImplicit then\n        instMVars := instMVars.push mvarId\n    loop app instMVars immediateMVars 0 #[] #[] #[]\n  where\n    loop (app : Expr) (instMVars : Array MVarId) (immediateMVars : Array MVarId)\n        (i : Nat) (proofsAcc : Array Expr) (currentUsedHyps : Array FVarId)\n        (usedHypsAcc : Array FVarId) :\n        MetaM (Array Expr \u00d7 Array FVarId) := do\n      if h : i < immediateMVars.size then\n        let mvarId := immediateMVars.get \u27e8i, h\u27e9\n        let type \u2190 mvarId.getType\n        (\u2190 getLCtx).foldlM (init := (proofsAcc, usedHypsAcc)) \u03bb s@(proofsAcc, usedHypsAcc) ldecl =>\n          if ldecl.isImplementationDetail then\n            pure s\n          else\n            withoutModifyingState do\n              if \u2190 isDefEq ldecl.type type then\n                mvarId.assign (mkFVar ldecl.fvarId)\n                let currentUsedHyps :=\n                  if collectUsedHyps then\n                    currentUsedHyps.push ldecl.fvarId\n                  else\n                    currentUsedHyps\n                loop app instMVars immediateMVars (i + 1) proofsAcc\n                    currentUsedHyps usedHypsAcc\n              else\n                pure s\n      else\n        for instMVar in instMVars do\n          instMVar.withContext do\n            let inst \u2190 synthInstance (\u2190 instMVar.getType)\n            instMVar.assign inst\n        let proofsAcc := proofsAcc.push (\u2190 abstractMVars app).expr\n        let usedHypsAcc := usedHypsAcc ++ currentUsedHyps\n        return (proofsAcc, usedHypsAcc)", "start": [16, 1], "end": [62, 40], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.forwardHypPrefix", "code": "def forwardHypPrefix := `fwd", "start": [80, 1], "end": [80, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.forwardImplDetailHypPrefix", "code": "def forwardImplDetailHypPrefix := `_fwd", "start": [83, 1], "end": [83, 40], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.mkFreshForwardImplDetailHypName", "code": "def mkFreshForwardImplDetailHypName : MetaM Name :=\n  mkFreshIdWithPrefix forwardImplDetailHypPrefix", "start": [86, 1], "end": [87, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.isForwardImplDetailHypName", "code": "def isForwardImplDetailHypName (n : Name) : Bool :=\n  forwardImplDetailHypPrefix.isPrefixOf n", "start": [89, 1], "end": [90, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.getForwardHypTypes", "code": "def getForwardHypTypes : MetaM (HashSet Expr) := do\n  let mut result := {}\n  for ldecl in (\u2190 getLCtx) do\n    if ldecl.isImplementationDetail && isForwardImplDetailHypName ldecl.userName then\n      result := result.insert ldecl.type\n  return result", "start": [92, 1], "end": [97, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.applyForwardRule", "code": "def applyForwardRule (goal : MVarId) (e : Expr)\n    (immediate : UnorderedArraySet Nat) (clear : Bool) (generateScript : Bool)\n    (md : TransparencyMode) : MetaM (MVarId \u00d7 Option RuleTacScriptBuilder) :=\n  withTransparency md $ goal.withContext do\n    let (newHypProofs, usedHyps) \u2190\n      makeForwardHyps e immediate (collectUsedHyps := clear)\n    if newHypProofs.isEmpty then\n      err\n    let forwardHypTypes \u2190 getForwardHypTypes\n    let mut newHyps := Array.mkEmpty newHypProofs.size\n    let mut newHypTypes : HashSet Expr := {}\n    let newHypUserNames \u2190 getUnusedUserNames newHypProofs.size forwardHypPrefix\n    for proof in newHypProofs, userName in newHypUserNames do\n      let type \u2190 inferType proof\n      if forwardHypTypes.contains type || newHypTypes.contains type then\n        continue\n      newHypTypes := newHypTypes.insert type\n      newHyps := newHyps.push { value := proof, type, userName }\n    if newHyps.isEmpty then\n      err\n    let (_, goal, assertScriptBuilder?) \u2190\n      assertHypothesesWithScript goal newHyps generateScript\n    let assertScriptBuilder? :=\n      assertScriptBuilder?.map (\u00b7.withAllTransparency md)\n    let implDetailHyps \u2190 newHyps.mapM \u03bb hyp =>\n      return {\n        hyp with\n        userName := \u2190 mkFreshForwardImplDetailHypName\n        binderInfo := .default\n        kind := .implDetail\n      }\n    let (_, goal) \u2190 goal.assertHypotheses' implDetailHyps\n    if clear then\n      let (goal, _, clearScriptBuilder?) \u2190\n        tryClearManyWithScript goal usedHyps generateScript\n      let scriptBuilder? :=\n        return (\u2190 assertScriptBuilder?).seq #[(\u2190 clearScriptBuilder?)]\n      return (goal, scriptBuilder?)\n    else\n      return (goal, assertScriptBuilder?)\n  where\n    err {\u03b1} : MetaM \u03b1 := throwError\n      \"found no instances of {e} (other than possibly those which had been previously added by forward rules)\"", "start": [99, 1], "end": [141, 111], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.forwardExpr", "code": "@[inline]\ndef forwardExpr (e : Expr) (immediate : UnorderedArraySet Nat)\n    (clear : Bool) (md : TransparencyMode) : RuleTac :=\n  SingleRuleTac.toRuleTac \u03bb input => input.goal.withContext do\n    let (goal, scriptBuilder?) \u2190\n      applyForwardRule input.goal e immediate (clear := clear)\n        (generateScript := input.options.generateScript) md\n    return (#[goal], scriptBuilder?, none)", "start": [143, 1], "end": [150, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.forwardConst", "code": "def forwardConst (decl : Name) (immediate : UnorderedArraySet Nat)\n    (clear : Bool) (md : TransparencyMode) : RuleTac := \u03bb input => do\n  forwardExpr (\u2190 mkConstWithFreshMVarLevels decl) immediate clear md input", "start": [152, 1], "end": [154, 75], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.forwardFVar", "code": "def forwardFVar (userName : Name) (immediate : UnorderedArraySet Nat)\n    (clear : Bool) (md : TransparencyMode) : RuleTac := \u03bb input =>\n  input.goal.withContext do\n    let ldecl \u2190 getLocalDeclFromUserName userName\n    forwardExpr (mkFVar ldecl.fvarId) immediate (clear := clear) md input", "start": [156, 1], "end": [160, 74], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/RuleTac/Tactic.lean", "imports": ["lake-packages/aesop/Aesop/RuleTac/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleTac.tacticMImpl", "code": "unsafe def tacticMImpl (decl : Name) : RuleTac :=\n  SingleRuleTac.toRuleTac \u03bb input => do\n    let tac \u2190 evalConst (TacticM Unit) decl\n    let goals \u2190 run input.goal tac |>.run'\n    return (goals.toArray, none, none)", "start": [16, 1], "end": [20, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.tacticM", "code": "@[implemented_by tacticMImpl]\nopaque tacticM (decl : Name) : RuleTac", "start": [23, 1], "end": [24, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.ruleTacImpl", "code": "unsafe def ruleTacImpl (decl : Name) : RuleTac := \u03bb input => do\n  let tac \u2190 evalConst RuleTac decl\n  tac input", "start": [27, 1], "end": [29, 12], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.ruleTac", "code": "@[implemented_by ruleTacImpl]\nopaque ruleTac (decl : Name) : RuleTac", "start": [32, 1], "end": [33, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.singleRuleTacImpl", "code": "unsafe def singleRuleTacImpl (decl : Name) : RuleTac :=\n  SingleRuleTac.toRuleTac \u03bb input => do\n    let tac \u2190 evalConst SingleRuleTac decl\n    tac input", "start": [36, 1], "end": [39, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.singleRuleTac", "code": "@[implemented_by singleRuleTacImpl]\nopaque singleRuleTac (decl : Name) : RuleTac", "start": [42, 1], "end": [43, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.tacGenImpl", "code": "unsafe def tacGenImpl (decl : Name) : RuleTac := \u03bb input => do\n  let tacGen \u2190 evalConst TacGen decl\n  let initialState \u2190 saveState\n  let suggestions \u2190 tacGen input.goal\n  let mut apps := Array.mkEmpty suggestions.size\n  let mut errors : Array (String \u00d7 Exception) := Array.mkEmpty suggestions.size\n  for (tacticStr, successProbability) in suggestions do\n    initialState.restore\n    let env \u2190 getEnv\n    try\n      let some successProbability := Percent.ofFloat successProbability\n        | throwError \"invalid success probability '{successProbability}', must be between 0 and 1\"\n      let .ok stx :=\n        Parser.runParserCategory env `tactic tacticStr (fileName := \"<stdin>\")\n        | throwError \"failed to parse tactic syntax{indentD tacticStr}\"\n      let goals := (\u2190 run input.goal (evalTactic stx) |>.run').toArray\n      let postState \u2190 saveState\n      if let some proof \u2190 getExprMVarAssignment? input.goal then\n        if (\u2190 instantiateMVars proof).hasSorry then\n          throwError \"generated proof contains sorry\"\n      let scriptBuilder? :=\n        mkScriptBuilder? input.options.generateScript $\n          .ofTactic goals.size (return \u27e8stx\u27e9)\n      apps := apps.push {\n        successProbability? := some successProbability\n        goals, postState, scriptBuilder?\n      }\n    catch e =>\n      errors := errors.push (tacticStr, e)\n  if apps.isEmpty then throwError\n    \"Failed to apply any tactics generated. Errors:{indentD $ MessageData.joinSep (errors.toList.map (\u03bb (tac, e) => m!\"{tac}: {e.toMessageData}\")) \"\\n\"}\"\n  return \u27e8apps\u27e9", "start": [46, 1], "end": [77, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleTac.tacGen", "code": "@[implemented_by tacGenImpl]\nopaque tacGen (decl : Name) : RuleTac", "start": [80, 1], "end": [81, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Frontend/ElabM.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Frontend.ElabOptions", "code": "structure ElabOptions where\n  parsePriorities : Bool\n  parseBuilderOptions : Bool", "start": [14, 1], "end": [16, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.ElabOptions.forAdditionalRules", "code": "def forAdditionalRules : ElabOptions where\n  parsePriorities := true\n  parseBuilderOptions := true", "start": [20, 1], "end": [22, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.ElabOptions.forErasing", "code": "def forErasing : ElabOptions where\n  parsePriorities := false\n  parseBuilderOptions := false", "start": [24, 1], "end": [26, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.ElabM", "code": "abbrev ElabM := ReaderT ElabOptions TermElabM", "start": [31, 1], "end": [31, 46], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Frontend/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "elabBoolLit", "code": "def elabBoolLit [Monad m] [MonadRef m] [MonadExceptOf Exception m]\n    (stx : TSyntax `Aesop.bool_lit) : m Bool :=\n  withRef stx do\n    match stx with\n    | `(bool_lit| true) => return true\n    | `(bool_lit| false) => return false\n    | _ => throwUnsupportedSyntax", "start": [20, 1], "end": [26, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Frontend/Extension/Init.lean", "imports": ["lake-packages/aesop/Aesop/RuleSet.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleSetExtension", "code": "abbrev RuleSetExtension := SimpleScopedEnvExtension RuleSetMember RuleSet", "start": [13, 1], "end": [17, 74], "kind": "commanddeclaration"}, {"full_name": "Aesop.DeclaredRuleSets", "code": "structure DeclaredRuleSets where\n  ruleSets : HashMap Name RuleSetExtension\n  defaultRuleSets : NameSet\n  deriving Inhabited", "start": [19, 1], "end": [25, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.getDeclaredRuleSets", "code": "def getDeclaredRuleSets : IO (HashMap RuleSetName RuleSetExtension) :=\n  return (\u2190 declaredRuleSetsRef.get).ruleSets", "start": [33, 1], "end": [34, 46], "kind": "commanddeclaration"}, {"full_name": "Aesop.getDefaultRuleSetNames", "code": "def getDefaultRuleSetNames : IO NameSet :=\n  return (\u2190 declaredRuleSetsRef.get).defaultRuleSets", "start": [36, 1], "end": [37, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Meta/CongrTheorems.lean", "imports": ["Mathlib/Lean/Meta.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.mkHCongrWithArity'", "code": "def mkHCongrWithArity' (f : Expr) (numArgs : Nat) : MetaM CongrTheorem := do\n  let thm \u2190 mkHCongrWithArity f numArgs\n  process thm thm.type thm.argKinds.toList #[] #[] #[]\nwhere\n  \n  process (cthm : CongrTheorem) (type : Expr) (argKinds : List CongrArgKind)\n      (argKinds' : Array CongrArgKind) (params args : Array Expr) : MetaM CongrTheorem := do\n    match argKinds with\n    | [] =>\n      if params.size == args.size then\n        return cthm\n      else\n        let pf' \u2190 mkLambdaFVars params (mkAppN cthm.proof args)\n        return {proof := pf', type := \u2190 inferType pf', argKinds := argKinds'}\n    | argKind :: argKinds =>\n      match argKind with\n      | .eq | .heq =>\n        forallBoundedTelescope type (some 3) fun params' type' => do\n          let #[x, y, eq] := params' | unreachable!\n          let g := (\u2190 mkFreshExprMVar (\u2190 inferType eq)).mvarId!\n          let g \u2190 g.clear eq.fvarId!\n          if (\u2190 observing? <| prove g params).isSome then\n            process cthm type' argKinds (argKinds'.push .subsingletonInst)\n              (params := params ++ #[x, y]) (args := args ++ #[x, y, .mvar g])\n          else\n            process cthm type' argKinds (argKinds'.push argKind)\n              (params := params ++ params') (args := args ++ params')\n      | _ => panic! \"Unexpected CongrArgKind\"\n  \n  prove (g : MVarId) (params : Array Expr) : MetaM Unit := do\n    let g \u2190 g.cleanup\n    let [g] \u2190 g.casesRec fun localDecl => do\n      return (localDecl.type.isEq || localDecl.type.isHEq) && params.contains localDecl.toExpr\n      | failure\n    try g.refl; return catch _ => pure ()\n    try g.hrefl; return catch _ => pure ()\n    if \u2190 g.proofIrrelHeq then return\n    let g \u2190 g.heqOfEq\n    if \u2190 g.subsingletonElim then return\n    failure", "start": [16, 1], "end": [72, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkRichHCongr", "code": "partial def mkRichHCongr (fType : Expr) (info : FunInfo)\n    (fixedFun : Bool := false) (fixedParams : Array Bool := #[])\n    (forceHEq : Bool := false) :\n    MetaM CongrTheorem := do\n  trace[Meta.CongrTheorems] \"ftype: {fType}\"\n  trace[Meta.CongrTheorems] \"deps: {info.paramInfo.map (fun p => p.backDeps)}\"\n  trace[Meta.CongrTheorems] \"fixedFun={fixedFun}, fixedParams={fixedParams}\"\n  doubleTelescope fType info.getArity fixedParams fun xs ys fixedParams => do\n    trace[Meta.CongrTheorems] \"xs = {xs}\"\n    trace[Meta.CongrTheorems] \"ys = {ys}\"\n    trace[Meta.CongrTheorems] \"computed fixedParams={fixedParams}\"\n    let lctx := (\u2190 getLCtx) withLocalDeclD `f fType fun ef => withLocalDeclD `f' fType fun pef' => do\n    let ef' := if fixedFun then ef else pef'\n    withLocalDeclD `e (\u2190 mkEq ef ef') fun ee => do\n    withNewEqs xs ys fixedParams fun kinds eqs => do\n      let fParams := if fixedFun then #[ef] else #[ef, ef', ee]\n      let mut hs := fParams     let mut hs' := fParams    let mut vals' := fParams  for i in [0 : info.getArity] do\n        hs := hs.push xs[i]!\n        hs' := hs'.push xs[i]!\n        vals' := vals'.push xs[i]!\n        if let some (eq, eq', val) := eqs[i]! then\n          hs := hs.push ys[i]! |>.push eq\n          hs' := hs'.push ys[i]! |>.push eq'\n          vals' := vals'.push ys[i]! |>.push val\n      let mkConcl := if forceHEq then mkHEq else mkEqHEq\n      let congrType \u2190 mkForallFVars hs (\u2190 mkConcl (mkAppN ef xs) (mkAppN ef' ys))\n      trace[Meta.CongrTheorems] \"simple congrType: {congrType}\"\n      let some proof \u2190 withLCtx lctx (\u2190 getLocalInstances) <| trySolve congrType\n        | throwError \"Internal error when constructing congruence lemma proof\"\n      let mut hs'' := #[] let mut pfVars := #[] let mut pfVals := #[] let mut kinds' : Array CongrArgKind := #[if fixedFun then .fixed else .eq]\n      for i in [0 : info.getArity] do\n        hs'' := hs''.push xs[i]!\n        if let some (_, eq', _) := eqs[i]! then\n          hs'' := hs''.push ys[i]!\n          let pf? \u2190 withLCtx lctx (\u2190 getLocalInstances) <| trySolve (\u2190 inferType eq')\n          if let some pf := pf? then\n            pfVars := pfVars.push eq'\n            pfVals := pfVals.push pf\n            kinds' := kinds'.push .subsingletonInst\n          else\n            hs'' := hs''.push eq'\n            kinds' := kinds'.push kinds[i]!\n        else\n          kinds' := kinds'.push .fixed\n      trace[Meta.CongrTheorems] \"CongrArgKinds: {repr kinds'}\"\n      let proof' \u2190 mkLambdaFVars fParams (\u2190 mkLambdaFVars (usedOnly := true) hs''\n                    (mkAppN (\u2190 mkLambdaFVars pfVars (proof.beta vals')) pfVals))\n      let congrType' \u2190 inferType proof'\n      trace[Meta.CongrTheorems] \"rich congrType: {congrType'}\"\n      return {proof := proof', type := congrType', argKinds := kinds'}\nwhere\n  \n  doubleTelescope {\u03b1} (fty : Expr) (numVars : Nat) (fixed : Array Bool)\n      (k : Array Expr \u2192 Array Expr \u2192 Array Bool \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n    let rec loop (i : Nat)\n        (ftyx ftyy : Expr) (xs ys : Array Expr) (fixed' : Array Bool) : MetaM \u03b1 := do\n      if i < numVars then\n        let ftyx \u2190 whnf ftyx\n        let ftyy \u2190 whnf ftyy\n        unless ftyx.isForall do\n          throwError \"doubleTelescope: function doesn't have enough parameters\"\n        withLocalDeclD ftyx.bindingName! ftyx.bindingDomain! fun fvarx => do\n          let ftyx' := ftyx.bindingBody!.instantiate1 fvarx\n          if fixed.getD i false && ftyx.bindingDomain! == ftyy.bindingDomain! then\n            let ftyy' := ftyy.bindingBody!.instantiate1 fvarx\n            loop (i + 1) ftyx' ftyy' (xs.push fvarx) (ys.push fvarx) (fixed'.push true)\n          else\n            let yname := ftyy.bindingName!.appendAfter \"'\"\n            withLocalDeclD yname ftyy.bindingDomain! fun fvary => do\n              let ftyy' := ftyy.bindingBody!.instantiate1 fvary\n              loop (i + 1) ftyx' ftyy' (xs.push fvarx) (ys.push fvary) (fixed'.push false)\n      else\n        k xs ys fixed'\n    loop 0 fty fty #[] #[] #[]\n  \n  withNewEqs {\u03b1} (xs ys : Array Expr) (fixedParams : Array Bool)\n      (k : Array CongrArgKind \u2192 Array (Option (Expr \u00d7 Expr \u00d7 Expr)) \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n    let rec loop (i : Nat)\n        (kinds : Array CongrArgKind) (eqs : Array (Option (Expr \u00d7 Expr \u00d7 Expr))) := do\n      if i < xs.size then\n        let x := xs[i]!\n        let y := ys[i]!\n        if fixedParams[i]! then\n          loop (i+1) (kinds.push .fixed) (eqs.push none)\n        else\n          let deps := info.paramInfo[i]!.backDeps.filterMap (fun j => eqs[j]!)\n          let eq' \u2190 mkForallFVars (deps.map fun (eq, _, _) => eq) (\u2190 mkEqHEq x y)\n          withLocalDeclD ((`e).appendIndexAfter (i+1)) (\u2190 mkEqHEq x y) fun h =>\n          withLocalDeclD ((`e').appendIndexAfter (i+1)) eq' fun h' => do\n            let v := mkAppN h' (deps.map fun (_, _, val) => val)\n            let kind := if (\u2190 inferType h).eq?.isSome then .eq else .heq\n            loop (i+1) (kinds.push kind) (eqs.push (h, h', v))\n      else\n        k kinds eqs\n    loop 0 #[] #[]\n  \n  trySolveCore (mvarId : MVarId) : MetaM Unit := do\n    let mvarId \u2190 mvarId.cleanup\n    let (_, mvarId) \u2190 mvarId.intros\n    let mvarId := (\u2190 mvarId.substEqs).getD mvarId\n    try mvarId.refl; return catch _ => pure ()\n    try mvarId.hrefl; return catch _ => pure ()\n    if \u2190 mvarId.proofIrrelHeq then return\n    let mvarId \u2190 mvarId.heqOfEq\n    if \u2190 mvarId.subsingletonElim then return\n    throwError \"was not able to solve for proof\"\n  \n  trySolve (ty : Expr) : MetaM (Option Expr) := observing? do\n    let mvar \u2190 mkFreshExprMVar ty\n    trace[Meta.CongrTheorems] \"trySolve {mvar.mvarId!}\"\n    withReducible <| trySolveCore mvar.mvarId!\n    trace[Meta.CongrTheorems] \"trySolve success!\"\n    let pf \u2190 instantiateMVars mvar\n    return pf", "start": [74, 1], "end": [262, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Relation/Rfl.lean", "imports": ["Mathlib/Lean/Meta.lean", "lake-packages/std/Std/Tactic/Relation/Rfl.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.rflTac", "code": "def rflTac : TacticM Unit :=\n  withMainContext do liftMetaFinishingTactic (\u00b7.applyRfl)", "start": [21, 1], "end": [26, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.rel_of_eq_and_refl", "code": "private theorem rel_of_eq_and_refl {\u03b1 : Sort _} {R : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    {x y : \u03b1} (hxy : x = y) (h : R x x) : R x y", "start": [28, 1], "end": [31, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.liftReflToEq", "code": "def _root_.Lean.MVarId.liftReflToEq (mvarId : MVarId) : MetaM MVarId := do\n  mvarId.checkNotAssigned `liftReflToEq\n  let .app (.app rel _) _ \u2190 withReducible mvarId.getType' | return mvarId\n  if rel.isAppOf `Eq then\n    return mvarId\n  for lem in \u2190 (Std.Tactic.reflExt.getState (\u2190 getEnv)).getMatch rel do\n    let res \u2190 observing? do\n      let [mvarIdEq, mvarIdR] \u2190 mvarId.apply (\u2190 mkConstWithFreshMVarLevels ``rel_of_eq_and_refl)\n        | failure\n      let [] \u2190 mvarIdR.apply (\u2190 mkConstWithFreshMVarLevels lem) | failure\n      return mvarIdEq\n    if let some mvarIdEq := res then\n      return mvarIdEq\n  return mvarId", "start": [33, 1], "end": [55, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/SplitIfs.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/Core.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.SplitPosition", "code": "private inductive SplitPosition\n| target\n| hyp (fvarId: FVarId)", "start": [17, 1], "end": [21, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getSplitCandidates", "code": "private def getSplitCandidates (loc : Location) : TacticM (List (SplitPosition \u00d7 Expr)) :=\nmatch loc with\n| Location.wildcard => do\n   let candidates \u2190 (\u2190 getLCtx).getFVarIds.mapM\n     (fun fvarId \u21a6 do\n       let typ \u2190 instantiateMVars (\u2190 inferType (mkFVar fvarId))\n       return (SplitPosition.hyp fvarId, typ))\n   pure ((SplitPosition.target, \u2190 getMainTarget) :: candidates.toList)\n| Location.targets hyps tgt => do\n   let candidates \u2190 (\u2190 hyps.mapM getFVarId).mapM\n     (fun fvarId \u21a6 do\n       let typ \u2190 instantiateMVars (\u2190 inferType (mkFVar fvarId))\n       return (SplitPosition.hyp fvarId, typ))\n   if tgt\n   then return (SplitPosition.target, \u2190 getMainTarget) :: candidates.toList\n   else return candidates.toList", "start": [23, 1], "end": [40, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.findIfCondAt", "code": "private def findIfCondAt (loc : Location) : TacticM (Option (SplitPosition \u00d7 Expr)) := do\n  for (pos, e) in (\u2190 getSplitCandidates loc) do\n    if let some cond := SplitIf.findIfToSplit? e\n    then return some (pos, cond)\n  return none", "start": [42, 1], "end": [48, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.discharge?", "code": "private def discharge? (e : Expr) : SimpM (Option Expr) := do\n  let e \u2190 instantiateMVars e\n  if let some e1 \u2190 SplitIf.discharge? false e\n    then return some e1\n  if e.isConstOf `True\n    then return some (mkConst `True.intro)\n  return none", "start": [50, 1], "end": [60, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.reduceIfsAt", "code": "private def reduceIfsAt (loc : Location) : TacticM Unit := do\n  let ctx \u2190 SplitIf.getSimpContext\n  let ctx := { ctx with config := { ctx.config with failIfUnchanged := false } }\n  let _ \u2190 simpLocation ctx discharge? loc\n  pure ()", "start": [62, 1], "end": [68, 10], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.splitIf1", "code": "private def splitIf1 (cond : Expr) (hName : Name) (loc : Location) : TacticM Unit := do\n  let splitCases :=\n    evalTactic (\u2190 `(tactic| by_cases $(mkIdent hName) : $(\u2190 Elab.Term.exprToSyntax cond)))\n  andThenOnSubgoals splitCases (reduceIfsAt loc)", "start": [70, 1], "end": [78, 49], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getNextName", "code": "private def getNextName (hNames: IO.Ref (List (TSyntax `Lean.binderIdent))) : MetaM Name := do\n  match \u2190hNames.get with\n  | [] => mkFreshUserName `h\n  | n::ns => do hNames.set ns\n                if let `(binderIdent| $x:ident) := n\n                then pure x.getId\n                else pure `_", "start": [80, 1], "end": [89, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.valueKnown", "code": "private def valueKnown (cond : Expr) : TacticM Bool := do\n  let hTypes \u2190 (((\u2190 getLCtx).getFVarIds.map mkFVar).mapM inferType : MetaM _)\n  let hTypes := hTypes.toList\n  let not_cond := mkApp (mkConst `Not) cond\n  return (hTypes.contains cond) || (hTypes.contains not_cond)", "start": [91, 1], "end": [97, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.splitIfsCore", "code": "private partial def splitIfsCore\n    (loc : Location)\n    (hNames : IO.Ref (List (TSyntax `Lean.binderIdent))) :\n    List Expr \u2192 TacticM Unit := fun done \u21a6 withMainContext do\n  let some (_,cond) \u2190 findIfCondAt loc\n      | Meta.throwTacticEx `split_ifs (\u2190getMainGoal) \"no if-then-else conditions to split\"\n\n  let cond := if cond.isAppOf `Not then cond.getAppArgs[0]! else cond\n\n  if done.contains cond then return ()\n  let no_split \u2190 valueKnown cond\n  if no_split then\n    andThenOnSubgoals (reduceIfsAt loc) (splitIfsCore loc hNames (cond::done) <|> pure ())\n  else do\n    let hName \u2190 getNextName hNames\n    andThenOnSubgoals (splitIf1 cond hName loc) ((splitIfsCore loc hNames (cond::done)) <|>\n      pure ())", "start": [99, 1], "end": [119, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Ordering/Basic.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordering.orElse", "code": "@[inline]\ndef orElse : Ordering \u2192 Ordering \u2192 Ordering\n  | lt, _ => lt\n  | eq, o => o\n  | gt, _ => gt", "start": [17, 1], "end": [22, 16], "kind": "commanddeclaration"}, {"full_name": "Ordering.toRel", "code": "def toRel [LT \u03b1] : Ordering \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop\n  | .lt => (\u00b7 < \u00b7)\n  | .eq => Eq\n  | .gt => (\u00b7 > \u00b7)", "start": [24, 1], "end": [28, 19], "kind": "commanddeclaration"}, {"full_name": "cmpUsing", "code": "def cmpUsing {\u03b1 : Type u} (lt : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel lt] (a b : \u03b1) : Ordering :=\n  if lt a b then Ordering.lt else if lt b a then Ordering.gt else Ordering.eq", "start": [32, 1], "end": [37, 78], "kind": "commanddeclaration"}, {"full_name": "cmp", "code": "def cmp {\u03b1 : Type u} [LT \u03b1] [DecidableRel ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] (a b : \u03b1) : Ordering :=\n  cmpUsing (\u00b7 < \u00b7) a b", "start": [40, 1], "end": [45, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/FunLike/Basic.lean", "imports": ["Mathlib/Tactic/NormCast.lean", "Mathlib/Util/CompileInductive.lean", "Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FunLike", "code": "@[notation_class * toFun Simps.findCoercionArgs]\nclass FunLike (F : Sort*) (\u03b1 : outParam (Sort*)) (\u03b2 : outParam <| \u03b1 \u2192 Sort*) where\n  \n  coe : F \u2192 \u2200 a : \u03b1, \u03b2 a\n  \n  coe_injective' : Function.Injective coe", "start": [123, 1], "end": [134, 42], "kind": "commanddeclaration"}, {"full_name": "FunLike.hasCoeToFun", "code": "instance (priority := 100) hasCoeToFun : CoeFun F fun _ \u21a6 \u2200 a : \u03b1, \u03b2 a where coe := FunLike.coe", "start": [150, 1], "end": [150, 96], "kind": "commanddeclaration"}, {"full_name": "FunLike.coe_eq_coe_fn", "code": "theorem coe_eq_coe_fn : (FunLike.coe (F := F)) = (fun f => \u2191f)", "start": [157, 1], "end": [157, 70], "kind": "commanddeclaration"}, {"full_name": "FunLike.coe_injective", "code": "theorem coe_injective : Function.Injective (fun f : F \u21a6 (f : \u2200 a : \u03b1, \u03b2 a))", "start": [160, 1], "end": [161, 25], "kind": "commanddeclaration"}, {"full_name": "FunLike.coe_fn_eq", "code": "@[simp]\ntheorem coe_fn_eq {f g : F} : (f : \u2200 a : \u03b1, \u03b2 a) = (g : \u2200 a : \u03b1, \u03b2 a) \u2194 f = g", "start": [164, 1], "end": [166, 62], "kind": "commanddeclaration"}, {"full_name": "FunLike.ext'", "code": "theorem ext' {f g : F} (h : (f : \u2200 a : \u03b1, \u03b2 a) = (g : \u2200 a : \u03b1, \u03b2 a)) : f = g", "start": [169, 1], "end": [170, 27], "kind": "commanddeclaration"}, {"full_name": "FunLike.ext'_iff", "code": "theorem ext'_iff {f g : F} : f = g \u2194 (f : \u2200 a : \u03b1, \u03b2 a) = (g : \u2200 a : \u03b1, \u03b2 a)", "start": [173, 1], "end": [174, 17], "kind": "commanddeclaration"}, {"full_name": "FunLike.ext", "code": "theorem ext (f g : F) (h : \u2200 x : \u03b1, f x = g x) : f = g", "start": [177, 1], "end": [178, 36], "kind": "commanddeclaration"}, {"full_name": "FunLike.ext_iff", "code": "theorem ext_iff {f g : F} : f = g \u2194 \u2200 x, f x = g x", "start": [181, 1], "end": [182, 43], "kind": "commanddeclaration"}, {"full_name": "FunLike.congr_fun", "code": "protected theorem congr_fun {f g : F} (h\u2081 : f = g) (x : \u03b1) : f x = g x", "start": [185, 1], "end": [186, 31], "kind": "commanddeclaration"}, {"full_name": "FunLike.ne_iff", "code": "theorem ne_iff {f g : F} : f \u2260 g \u2194 \u2203 a, f a \u2260 g a", "start": [189, 1], "end": [190, 31], "kind": "commanddeclaration"}, {"full_name": "FunLike.exists_ne", "code": "theorem exists_ne {f g : F} (h : f \u2260 g) : \u2203 x, f x \u2260 g x", "start": [193, 1], "end": [194, 14], "kind": "commanddeclaration"}, {"full_name": "FunLike.subsingleton_cod", "code": "lemma subsingleton_cod [\u2200 a, Subsingleton (\u03b2 a)] : Subsingleton F :=\n  \u27e8fun _ _ \u21a6 coe_injective $ Subsingleton.elim _ _\u27e9", "start": [197, 1], "end": [199, 52], "kind": "mathlibtacticlemma"}, {"full_name": "FunLike.congr", "code": "protected theorem congr {f g : F} {x y : \u03b1} (h\u2081 : f = g) (h\u2082 : x = y) : f x = g y", "start": [214, 1], "end": [215, 28], "kind": "commanddeclaration"}, {"full_name": "FunLike.congr_arg", "code": "protected theorem congr_arg (f : F) {x y : \u03b1} (h\u2082 : x = y) : f x = f y", "start": [218, 1], "end": [219, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Search/Expansion/Basic.lean", "imports": ["lake-packages/aesop/Aesop/Search/SearchM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.runRuleTac", "code": "def runRuleTac (tac : RuleTac) (ruleName : RuleName)\n    (preState : Meta.SavedState) (input : RuleTacInput) :\n    MetaM (Sum Exception RuleTacOutput) := do\n  let result \u2190\n    try\n      Sum.inr <$> preState.runMetaM' (tac input)\n    catch e =>\n      return Sum.inl e\n  if \u2190 Check.rules.isEnabled then\n    if let (Sum.inr ruleOutput) := result then\n      ruleOutput.applications.forM \u03bb rapp => do\n        if let (some err) \u2190 rapp.check then\n          throwError \"{Check.rules.name}: while applying rule {ruleName}: {err}\"\n  return result", "start": [14, 1], "end": [27, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/RuleTac.lean", "imports": ["lake-packages/aesop/Aesop/RuleTac/RuleApplicationWithMVarInfo.lean", "lake-packages/aesop/Aesop/RuleTac/Basic.lean", "lake-packages/aesop/Aesop/RuleTac/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/RuleTac/Cases.lean", "lake-packages/aesop/Aesop/RuleTac/Forward.lean", "lake-packages/aesop/Aesop/RuleTac/Apply.lean", "lake-packages/aesop/Aesop/RuleTac/Preprocess.lean"], "premises": [{"full_name": "Aesop.RuleTacDescr.run", "code": "protected def run : RuleTacDescr \u2192 RuleTacInput \u2192 MetaM RuleTacOutput\n  | applyConst decl md => RuleTac.applyConst decl md\n  | applyFVar userName md => RuleTac.applyFVar userName md\n  | constructors cs md => RuleTac.applyConsts cs md\n  | forwardConst decl    immediate clear md =>\n    RuleTac.forwardConst decl immediate clear md\n  | forwardFVar userName immediate clear md =>\n    RuleTac.forwardFVar userName immediate clear md\n  | cases decl md isRecursiveType => RuleTac.cases decl md isRecursiveType\n  | tacticM decl => RuleTac.tacticM decl\n  | singleRuleTac decl => RuleTac.singleRuleTac decl\n  | ruleTac decl => RuleTac.ruleTac decl\n  | tacGen decl => RuleTac.tacGen decl\n  | preprocess => RuleTac.preprocess", "start": [19, 1], "end": [32, 37], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Search/RuleSelection.lean", "imports": ["lake-packages/aesop/Aesop/Search/SearchM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.selectNormRules", "code": "def selectNormRules (rs : RuleSet) (goal : MVarId) :\n    ProfileT MetaM (Array (IndexMatchResult NormRule)) :=\n  profiling (rs.applicableNormalizationRules goal) \u03bb _ elapsed =>\n    recordRuleSelectionProfile elapsed", "start": [15, 1], "end": [18, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.preprocessRule", "code": "def preprocessRule : SafeRule where\n  name := {\n    name := `Aesop.BuiltinRule.preprocess\n    builder := .tactic\n    phase := .safe\n    scope := .global\n  }\n  indexingMode := .unindexed\n  extra := { penalty := 0, safety := .safe }\n  tac := .preprocess", "start": [20, 1], "end": [29, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.selectSafeRulesCore", "code": "def selectSafeRulesCore (g : Goal) :\n    SearchM Q (Array (IndexMatchResult SafeRule)) := do\n  if \u2190 g.isRoot then\n    return #[{ rule := preprocessRule, locations := \u2205 }]\n  let ruleSet := (\u2190 read).ruleSet\n  g.runMetaMInPostNormState' \u03bb postNormGoal =>\n    ruleSet.applicableSafeRules postNormGoal", "start": [31, 1], "end": [37, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.selectSafeRules", "code": "def selectSafeRules (g : Goal) :\n    SearchM Q (Array (IndexMatchResult SafeRule)) :=\n  profiling (selectSafeRulesCore g) \u03bb _ elapsed =>\n    recordRuleSelectionProfile elapsed", "start": [39, 1], "end": [42, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.selectUnsafeRulesCore", "code": "def selectUnsafeRulesCore (postponedSafeRules : Array PostponedSafeRule)\n    (gref : GoalRef) : SearchM Q UnsafeQueue := do\n  let g \u2190 gref.get\n  match g.unsafeQueue? with\n  | some rules => return rules\n  | none => do\n    let ruleSet := (\u2190 read).ruleSet\n    let unsafeRules \u2190  g.runMetaMInPostNormState' \u03bb postNormGoal =>\n      ruleSet.applicableUnsafeRules postNormGoal\n    let unsafeQueue := UnsafeQueue.initial postponedSafeRules unsafeRules\n    gref.set $ g.setUnsafeRulesSelected true |>.setUnsafeQueue unsafeQueue\n    return unsafeQueue", "start": [44, 1], "end": [55, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.selectUnsafeRules", "code": "def selectUnsafeRules (postponedSafeRules : Array PostponedSafeRule)\n    (gref : GoalRef) : SearchM Q UnsafeQueue :=\n  profiling (selectUnsafeRulesCore postponedSafeRules gref) \u03bb _ elapsed =>\n    recordRuleSelectionProfile elapsed", "start": [57, 1], "end": [60, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Frontend/RuleExpr.lean", "imports": ["lake-packages/aesop/Aesop/RuleSet.lean", "lake-packages/aesop/Aesop/Builder.lean", "lake-packages/aesop/Aesop/Rule/Name.lean", "lake-packages/aesop/Aesop/Frontend/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Frontend/ElabM.lean", "lake-packages/aesop/Aesop/Percent.lean"], "premises": [{"full_name": "Aesop.Frontend.Priority", "code": "inductive Priority\n  | int (i : Int)\n  | percent (p : Percent)\n  deriving Inhabited", "start": [34, 1], "end": [37, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Priority.elab", "code": "def \u00abelab\u00bb (stx : Syntax) : ElabM Priority :=\n  withRef stx do\n    unless (\u2190 read).parsePriorities do throwError\n      \"unexpected priority.\"\n    match stx with\n    | `(priority| $p:num %) =>\n      let p := p.raw.toNat\n      match Percent.ofNat p with\n      | some p => return percent p\n      | none => throwError \"percentage '{p}%' is not between 0 and 100.\"\n    | `(priority| - $i:num) =>\n      return int $ - i.raw.toNat\n    | `(priority| $i:num) =>\n      return int i.raw.toNat\n    | _ => throwUnsupportedSyntax", "start": [41, 1], "end": [55, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Priority.toInt?", "code": "def toInt? : Priority \u2192 Option Int\n  | int i => some i\n  | _ => none", "start": [62, 1], "end": [64, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Priority.toPercent?", "code": "def toPercent? : Priority \u2192 Option Percent\n  | percent p => some p\n  | _ => none", "start": [66, 1], "end": [68, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.PhaseName.elab", "code": "def PhaseName.\u00abelab\u00bb (stx : Syntax) : ElabM PhaseName :=\n  withRef stx do\n    match stx with\n    | `(phase| safe) => return .safe\n    | `(phase| norm) => return .norm\n    | `(phase| unsafe) => return .\u00abunsafe\u00bb\n    | _ => throwUnsupportedSyntax", "start": [84, 1], "end": [90, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.DBuilderName", "code": "inductive DBuilderName\n  | regular (b : BuilderName)\n  | \u00abdefault\u00bb\n  deriving Inhabited", "start": [109, 1], "end": [112, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.DBuilderName.elab", "code": "def \u00abelab\u00bb (stx : Syntax) : ElabM DBuilderName :=\n  withRef stx do\n    match stx with\n    | `(builder_name| apply) => return regular .apply\n    | `(builder_name| simp) => return regular .simp\n    | `(builder_name| unfold) => return regular .unfold\n    | `(builder_name| tactic) => return regular .tactic\n    | `(builder_name| constructors) => return regular .constructors\n    | `(builder_name| forward) => return regular .forward\n    | `(builder_name| destruct) => return regular .destruct\n    | `(builder_name| cases) => return regular .cases\n    | `(builder_name| default) => return \u00abdefault\u00bb\n    | _ => throwUnsupportedSyntax", "start": [116, 1], "end": [128, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.DBuilderName.toBuilderName?", "code": "def toBuilderName? : DBuilderName \u2192 Option BuilderName\n  | regular b => some b\n  | _ => none", "start": [135, 1], "end": [137, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.elabPattern", "code": "def elabPattern (stx : Syntax) : TermElabM Expr :=\n  withRef stx $ withReader adjustCtx $ withSynthesize do\n    instantiateMVars (\u2190 elabTerm stx none)\n  where\n    adjustCtx (old : Term.Context) : Term.Context := {\n      old with\n      mayPostpone := false\n      errToSorry := false\n      autoBoundImplicit := false\n      sectionVars := {}\n      sectionFVars := {}\n      inPattern := true\n    }", "start": [152, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.elabSingleIndexingMode", "code": "def elabSingleIndexingMode (stx : Syntax) : ElabM IndexingMode :=\n  withRef stx do\n    match stx with\n    | `(indexing_mode| target $t:term) => .target <$> elabKeys t\n    | `(indexing_mode| hyp $t:term) => .hyps <$> elabKeys t\n    | `(indexing_mode| unindexed) => return .unindexed\n    | _ => throwUnsupportedSyntax\n  where\n    elabKeys {s} (stx : Syntax) : ElabM (Array (DiscrTree.Key s)) :=\n      show TermElabM _ from withoutModifyingState do\n        let e \u2190 elabPattern stx\n        DiscrTree.mkPath e", "start": [166, 1], "end": [177, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.IndexingMode.elab", "code": "def IndexingMode.elab (stxs : Array Syntax) : ElabM IndexingMode :=\n  .or <$> stxs.mapM elabSingleIndexingMode", "start": [179, 1], "end": [180, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.CasesPattern.elab", "code": "def CasesPattern.elab (stx : Syntax) : TermElabM CasesPattern := do\n  abstractMVars (\u2190 elabPattern stx)", "start": [182, 1], "end": [183, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.elabTransparency", "code": "def elabTransparency : TSyntax ``transparency \u2192 TermElabM TransparencyMode\n  | `(transparency| default) => return .default\n  | `(transparency| reducible) => return .reducible\n  | `(transparency| instances) => return .instances\n  | `(transparency| all) => return .all\n  | _ => throwUnsupportedSyntax", "start": [193, 1], "end": [198, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOption", "code": "inductive BuilderOption\n  | immediate (names : Array Name)\n  | index (imode : IndexingMode)\n  | patterns (pats : Array CasesPattern)\n  | transparency (md : TransparencyMode) (alsoForIndex : Bool)", "start": [215, 1], "end": [219, 63], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOption.elab", "code": "def \u00abelab\u00bb (stx : TSyntax `Aesop.builder_option) : ElabM BuilderOption :=\n  withRef stx do\n    match stx with\n    | `(builder_option| (immediate := [$ns:ident,*])) =>\n      return immediate $ (ns : Array Syntax).map (\u00b7.getId)\n    | `(builder_option| (index := [$imodes:Aesop.indexing_mode,*])) =>\n      index <$> IndexingMode.elab imodes\n    | `(builder_option| (patterns := [$pats:term,*])) =>\n      patterns <$> (pats : Array Syntax).mapM (CasesPattern.elab \u00b7)\n    | `(builder_option| (transparency := $md)) =>\n      let md \u2190 elabTransparency md\n      return transparency md (alsoForIndex := false)\n    | `(builder_option| (transparency! := $md)) =>\n      let md \u2190 elabTransparency md\n      return transparency md (alsoForIndex := true)\n    | _ => throwUnsupportedSyntax", "start": [223, 1], "end": [238, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOption.name", "code": "protected def name : BuilderOption \u2192 String\n  | immediate .. => \"immediate\"\n  | index .. => \"index\"\n  | patterns .. => \"patterns\"\n  | transparency .. => \"transparency\"", "start": [240, 1], "end": [244, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOption.toCtorIdx", "code": "protected def toCtorIdx : BuilderOption \u2192 Nat\n  | immediate .. => 0\n  | index .. => 1\n  | patterns .. => 2\n  | transparency .. => 3", "start": [246, 1], "end": [250, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions", "code": "structure BuilderOptions (\u03c3 : Type _) where\n  builderName : DBuilderName\n  init : \u03c3\n  add : \u03c3 \u2192 BuilderOption \u2192 Option \u03c3", "start": [255, 1], "end": [258, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions.elab", "code": "def \u00abelab\u00bb (bo : BuilderOptions \u03b1) (stx : Syntax) : ElabM \u03b1 :=\n  withRef stx do\n    match stx with\n    | `(Parser.builderOptions| $stxs:Aesop.builder_option*) => do\n      let mut opts := bo.init\n      let mut seen : HashSet Nat := {}\n      for stx in stxs do\n        let opt \u2190 BuilderOption.elab stx\n        let idx := opt.toCtorIdx\n        if seen.contains idx then withRef stx $ throwError\n          \"duplicate builder option '{opt.name}'\"\n        seen := seen.insert idx\n        match bo.add opts opt with\n        | some opts' => opts := opts'\n        | none => withRef stx $ throwError\n          \"builder '{bo.builderName}' does not accept option '{opt.name}'\"\n      return opts\n    | _ => throwUnsupportedSyntax", "start": [262, 1], "end": [279, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions.none", "code": "protected def none (builderName : DBuilderName) : BuilderOptions Unit where\n  builderName := builderName\n  init := ()\n  add _ _ := none", "start": [281, 1], "end": [284, 18], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions.regular", "code": "def regular (builderName : BuilderName) :\n    BuilderOptions RegularBuilderOptions where\n  builderName := .regular builderName\n  init := default\n  add\n    | opts, .index imode => some { opts with indexingMode? := imode }\n    | _, _ => none", "start": [286, 1], "end": [292, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions.forwardCore", "code": "@[inline, always_inline]\nprivate def forwardCore (clear : Bool) :\n    BuilderOptions ForwardBuilderOptions where\n  builderName := .regular $ if clear then .destruct else .forward\n  init := .default clear\n  add\n    | opts, .immediate ns => some { opts with immediateHyps := ns }\n    | opts, .index imode => some { opts with indexingMode? := imode }\n    | opts, .transparency transparency alsoForIndex =>\n      let opts := { opts with transparency }\n      if alsoForIndex then\n        some { opts with indexTransparency := transparency }\n      else\n        some opts\n    | _, _ => none", "start": [294, 1], "end": [308, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions.forward", "code": "def forward : BuilderOptions ForwardBuilderOptions :=\n  forwardCore (clear := false)", "start": [310, 1], "end": [311, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions.destruct", "code": "def destruct : BuilderOptions ForwardBuilderOptions :=\n  forwardCore (clear := true)", "start": [313, 1], "end": [314, 30], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions.cases", "code": "def cases : BuilderOptions CasesBuilderOptions where\n  builderName := .regular .cases\n  init := default\n  add\n    | opts, .patterns patterns => some { opts with patterns }\n    | opts, .index indexingMode? => some { opts with indexingMode? }\n    | opts, .transparency transparency alsoForIndex =>\n      let opts := { opts with transparency }\n      if alsoForIndex then\n        some { opts with indexTransparency := transparency }\n      else\n        some opts\n    | _, _ => none", "start": [316, 1], "end": [328, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions.apply", "code": "def apply : BuilderOptions ApplyBuilderOptions where\n  builderName := .regular .cases\n  init := default\n  add\n    | opts, .index indexingMode? => some { opts with indexingMode? }\n    | opts, .transparency transparency alsoForIndex =>\n      let opts := { opts with transparency }\n      if alsoForIndex then\n        some { opts with indexTransparency := transparency }\n      else\n        some opts\n    | _, _ => none", "start": [330, 1], "end": [341, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.BuilderOptions.constructors", "code": "def constructors : BuilderOptions ConstructorsBuilderOptions where\n  builderName := .regular .cases\n  init := default\n  add\n    | opts, .index indexingMode? => some { opts with indexingMode? }\n    | opts, .transparency transparency alsoForIndex =>\n      let opts := { opts with transparency }\n      if alsoForIndex then\n        some { opts with indexTransparency := transparency }\n      else\n        some opts\n    | _, _ => none", "start": [343, 1], "end": [354, 19], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Builder", "code": "inductive Builder\n  | apply (opts : ApplyBuilderOptions)\n  | simp\n  | unfold\n  | tactic (opts : RegularBuilderOptions)\n  | constructors (opts : ConstructorsBuilderOptions)\n  | forward (opts : ForwardBuilderOptions)\n  | cases (opts : CasesBuilderOptions)\n  | \u00abdefault\u00bb\n  deriving Inhabited", "start": [368, 1], "end": [377, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Builder.elabOptions", "code": "def elabOptions (b : DBuilderName) (opts : Syntax) : ElabM Builder := do\n  match b with\n  | .regular .apply => apply <$> BuilderOptions.apply.elab opts\n  | .regular .simp => checkNoOptions; return simp\n  | .regular .unfold => checkNoOptions; return unfold\n  | .regular .tactic => tactic <$> (BuilderOptions.regular .tactic |>.elab opts)\n  | .regular .constructors => constructors <$> BuilderOptions.constructors.elab opts\n  | .regular .forward => forward <$> BuilderOptions.forward.elab opts\n  | .regular .destruct => forward <$> BuilderOptions.destruct.elab opts\n  | .regular .cases => \u00abcases\u00bb <$> BuilderOptions.cases.elab opts\n  | .default => checkNoOptions; return default\n  where\n    checkNoOptions := BuilderOptions.none b |>.\u00abelab\u00bb opts", "start": [381, 1], "end": [393, 59], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Builder.elab", "code": "def \u00abelab\u00bb (stx : Syntax) : ElabM Builder :=\n  withRef stx do\n    match stx with\n    | `(builder| $b:Aesop.builder_name) => do\n      elabOptions (\u2190 DBuilderName.elab b) (mkNode ``Parser.builderOptions #[])\n    | `(builder| ($b:Aesop.builder_name $opts:builderOptions)) => do\n      elabOptions (\u2190 DBuilderName.elab b) opts\n    | _ => throwUnsupportedSyntax", "start": [395, 1], "end": [402, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Builder.toRuleBuilder", "code": "def toRuleBuilder : Builder \u2192 RuleBuilder\n  | apply opts  => RuleBuilder.apply opts\n  | simp => RuleBuilder.simp\n  | unfold => RuleBuilder.unfold\n  | tactic opts => RuleBuilder.tactic opts\n  | constructors opts => RuleBuilder.constructors opts\n  | forward opts => RuleBuilder.forward opts\n  | cases opts => RuleBuilder.cases opts\n  | \u00abdefault\u00bb => RuleBuilder.default", "start": [404, 1], "end": [412, 37], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Builder.toDBuilderName", "code": "def toDBuilderName : Builder \u2192 DBuilderName\n  | apply .. => regular .apply\n  | simp => regular .simp\n  | unfold => regular .unfold\n  | tactic .. => regular .tactic\n  | constructors .. => regular .constructors\n  | forward .. => regular .forward\n  | cases .. => regular .cases\n  | .\u00abdefault\u00bb => .default", "start": [415, 1], "end": [423, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleSetName.elab", "code": "def RuleSetName.elab (stx : Syntax) : RuleSetName :=\n  stx.getId.eraseMacroScopes", "start": [433, 1], "end": [434, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleSets", "code": "structure RuleSets where\n  ruleSets : Array RuleSetName\n  deriving Inhabited", "start": [440, 1], "end": [442, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleSets.elab", "code": "def \u00abelab\u00bb (stx : Syntax) : ElabM RuleSets :=\n  withRef stx do\n    match stx with\n    | `(Parser.ruleSetsFeature| (rule_sets [$ns:ident,*])) =>\n      return \u27e8(ns : Array Syntax).map RuleSetName.elab\u27e9\n    | _ => throwUnsupportedSyntax", "start": [446, 1], "end": [451, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Feature", "code": "inductive Feature\n  | phase (p : PhaseName)\n  | priority (p : Priority)\n  | builder (b : Builder)\n  | ident (i : RuleIdent)\n  | ruleSets (rs : RuleSets)\n  deriving Inhabited", "start": [473, 1], "end": [479, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Feature.elabRuleIdent", "code": "private def elabRuleIdent (stx : Syntax) : ElabM RuleIdent :=\n  resolveLocal <|> resolveGlobal <|> throwError\n    \"unknown rule name: {stx.getId}\"\n  where\n    resolveLocal : ElabM RuleIdent := do\n      let n := stx.getId.eraseMacroScopes\n      match (\u2190 getLCtx).findFromUserName? n with\n      | some ldecl =>\n        if ldecl.isImplementationDetail then\n          throwError \"\"\n        else\n          return .fvar n\n      | none => throwError \"\"\n\n    resolveGlobal : ElabM RuleIdent := do\n      .const <$> resolveGlobalConstNoOverload stx", "start": [483, 1], "end": [498, 50], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.Feature.elab", "code": "partial def \u00abelab\u00bb (stx : Syntax) : ElabM Feature :=\n  withRef stx do\n    match stx with\n    | `(feature| $p:Aesop.priority) => priority <$> Priority.elab p\n    | `(feature| $p:Aesop.phase) => phase <$> PhaseName.elab p\n    | `(feature| $b:Aesop.builder) => builder <$> Builder.elab b\n    | `(feature| $rs:ruleSetsFeature) => ruleSets <$> RuleSets.elab rs\n    | `(feature| $i:ident) => ident <$> elabRuleIdent i\n    | stx =>\n      if stx.isOfKind choiceKind then\n        let nonIdentAlts :=\n          stx.getArgs.filter \u03bb stx => ! stx.isOfKind ``Parser.featIdent\n        if nonIdentAlts.size != 1 then\n          panic! \"expected choice node with exactly one non-ident child\"\n        else\n          \u00abelab\u00bb nonIdentAlts[0]!\n      else\n        throwUnsupportedSyntax", "start": [500, 1], "end": [517, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr", "code": "inductive RuleExpr\n  | node (f : Feature) (children : Array RuleExpr)\n  deriving Inhabited", "start": [533, 1], "end": [535, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.elab", "code": "partial def \u00abelab\u00bb (stx : Syntax) : ElabM RuleExpr :=\n  withRef stx do\n    match stx with\n    | `(rule_expr| $f:Aesop.feature $e:Aesop.rule_expr) => do\n      return node (\u2190 Feature.elab f) #[\u2190 \u00abelab\u00bb e]\n    | `(rule_expr| $f:Aesop.feature [ $es:Aesop.rule_expr,* ]) => do\n      return node (\u2190 Feature.elab f) (\u2190 (es : Array Syntax).mapM \u00abelab\u00bb)\n    | `(rule_expr| $f:Aesop.feature) => do\n      return node (\u2190 Feature.elab f) #[]\n    | _ => throwUnsupportedSyntax", "start": [539, 1], "end": [548, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.foldBranchesM", "code": "partial def foldBranchesM {m} [Monad m] (f : \u03c3 \u2192 Feature \u2192 m \u03c3) (init : \u03c3)\n    (e : RuleExpr) : m (Array \u03c3) :=\n  go init #[] e\n  where\n    go (c : \u03c3) (acc : Array \u03c3) : RuleExpr \u2192 m (Array \u03c3)\n      | RuleExpr.node feat cs => do\n        let c \u2190 f c feat\n        if cs.isEmpty then\n          return acc.push c\n        else\n          cs.foldlM (init := acc) (go c)", "start": [552, 1], "end": [562, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleConfig", "code": "structure RuleConfig (f : Type \u2192 Type) where\n  ident : f RuleIdent\n  phase : f PhaseName\n  priority : f Priority\n  builder : f Builder\n  ruleSets : RuleSets", "start": [567, 1], "end": [572, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleConfig.getPenalty", "code": "def getPenalty (phase : PhaseName) (c : RuleConfig Id) : m Int := do\n  let (some penalty) := c.priority.toInt? | throwError\n    \"{phase} rules must specify an integer penalty (not a success probability)\"\n  return penalty", "start": [576, 1], "end": [579, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleConfig.getSuccessProbability", "code": "def getSuccessProbability (c : RuleConfig Id) : m Percent := do\n  let (some prob) := c.priority.toPercent? | throwError\n    \"unsafe rules must specify a success probability (not an integer penalty)\"\n  return prob", "start": [581, 1], "end": [584, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleConfig.getSimpPriority", "code": "def getSimpPriority (c : RuleConfig Id) : m Nat := do\n  let prio? := c.priority.toInt?.bind \u03bb prio =>\n    if prio < 0 then none else some prio.toNat\n  let (some prio) := prio? | throwError\n    \"simp rules must specify a non-negative integer priority\"\n  return prio", "start": [586, 1], "end": [591, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleConfig.buildLocalRule", "code": "def buildLocalRule (c : RuleConfig Id) (goal : MVarId) :\n    MetaM (MVarId \u00d7 RuleSetMember \u00d7 Array RuleSetName) := do\n  match c.phase with\n  | phase@PhaseName.safe =>\n    let penalty \u2190 c.getPenalty phase\n    let (goal, res) \u2190 runRegularBuilder goal phase c.builder\n    let rule := RuleSetMember.safeRule {\n      name := c.ident.toRuleName phase res.builder\n      tac := res.tac\n      indexingMode := res.indexingMode\n      extra := { penalty, safety := Safety.safe }\n      }\n    return (goal, rule, c.ruleSets.ruleSets)\n  | phase@PhaseName.\u00abunsafe\u00bb =>\n    let successProbability \u2190 c.getSuccessProbability\n    let (goal, res) \u2190 runRegularBuilder goal phase c.builder\n    let rule := RuleSetMember.unsafeRule {\n      name := c.ident.toRuleName phase res.builder\n      tac := res.tac\n      indexingMode := res.indexingMode\n      extra := { successProbability }\n    }\n    return (goal, rule, c.ruleSets.ruleSets)\n  | phase@PhaseName.norm =>\n    let (goal, res) \u2190 runBuilder goal phase c.builder\n    let rule \u2190\n      match res with\n      | .regular res => do\n        let penalty \u2190 c.getPenalty phase\n        pure $ .normRule {\n          res with\n          name := c.ident.toRuleName phase res.builder\n          extra := { penalty }\n        }\n      | .globalSimp entries => do\n        let prio \u2190 c.getSimpPriority\n        let entries := entries.map (updateSimpEntryPriority prio)\n        pure $ .normSimpRule {\n          entries\n          name := c.ident.toRuleName phase .simp\n        }\n      | .localSimp fvarUserName => pure $ .localNormSimpRule { fvarUserName }\n      | .unfold r => pure $ .unfoldRule r\n    return (goal, rule, c.ruleSets.ruleSets)\n  where\n    runBuilder (goal : MVarId) (phase : PhaseName) (b : Builder) :\n        MetaM (MVarId \u00d7 RuleBuilderResult) := do\n      let builderInput : RuleBuilderInput :=\n        match c.ident with\n        | RuleIdent.const decl => {\n            phase := phase\n            kind := RuleBuilderKind.global decl\n          }\n        | RuleIdent.fvar fvarUserName => {\n            phase := phase\n            kind := RuleBuilderKind.local fvarUserName goal\n          }\n      match \u2190 b.toRuleBuilder builderInput with\n      | .global r => return (goal, r)\n      | .\u00ablocal\u00bb goal r => return (goal, r)\n\n    runRegularBuilder (goal : MVarId) (phase : PhaseName) (b : Builder) :\n        MetaM (MVarId \u00d7 RegularRuleBuilderResult) := do\n      let (goal, RuleBuilderResult.regular r) \u2190 runBuilder goal phase b\n        | throwError \"builder {b.toDBuilderName} cannot be used for {phase} rules\"\n      return (goal, r)", "start": [593, 1], "end": [659, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleConfig.buildGlobalRule", "code": "def buildGlobalRule (c : RuleConfig Id) :\n    MetaM (RuleSetMember \u00d7 Array RuleSetName) :=\n  Prod.snd <$> buildLocalRule c \u27e8`_dummy\u27e9", "start": [662, 1], "end": [664, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleConfig.toRuleNameFilter", "code": "def toRuleNameFilter (c : RuleConfig Option) :\n    m (RuleSetNameFilter \u00d7 RuleNameFilter) := do\n  let (some ident) := c.ident | throwError\n    \"rule name not specified\"\n  let builders \u2190\n    match c.builder with\n    | none => pure #[]\n    | some b => do\n      let (some builder) := b.toDBuilderName.toBuilderName? | throwError\n        \"{b.toDBuilderName} cannot be used when erasing rules.\\nUse the corresponding non-default builder (e.g. 'apply' or 'constructors') instead.\"\n        pure #[builder]\n  let phases :=\n    match c.phase with\n    | none => #[]\n    | some p => #[p]\n  let ruleSetNames := c.ruleSets.ruleSets\n  return ({ ns := ruleSetNames }, { ident, builders, phases })", "start": [668, 1], "end": [686, 63], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.toAdditionalRules", "code": "def toAdditionalRules (e : RuleExpr) (init : RuleConfig Option)\n    (defaultRuleSet : RuleSetName) : m (Array (RuleConfig Id)) := do\n  let cs \u2190 e.foldBranchesM (init := init) go\n  cs.mapM finish\n  where\n    go (r : RuleConfig Option) : Feature \u2192 m (RuleConfig Option)\n      | .phase p => do\n        if let (some previous) := r.phase then throwError\n          \"duplicate phase declaration: '{p}'\\n(previous declaration: '{previous}')\"\n        return { r with phase := some p }\n      | .priority p => do\n        if let (some previous) := r.priority then throwError\n          \"duplicate priority declaration: '{p}'\\n(previous declaration: '{previous}')\"\n        return { r with priority := some p }\n      | .builder b => do\n        if let (some previous) := r.builder then throwError\n          \"duplicate builder declaration: '{b.toDBuilderName}'\\n(previous declaration: '{previous.toDBuilderName}')\"\n        return { r with builder := some b }\n      | .ident ident => do\n        if let (some previous) := r.ident then throwError\n          \"duplicate rule name: '{ident}'\\n(previous rule name: '{previous}')\"\n        return { r with ident }\n      | .ruleSets newRuleSets =>\n        have _ : Ord RuleSetName := \u27e8Name.quickCmp\u27e9\n        let ruleSets :=\n          \u27e8Array.mergeSortedDeduplicating r.ruleSets.ruleSets $\n            newRuleSets.ruleSets.qsortOrd\u27e9\n        return { r with ruleSets }\n\n    getPhaseAndPriority (c : RuleConfig Option) :\n        m (PhaseName \u00d7 Priority) :=\n      match c.builder, c.phase, c.priority with\n      | _, some phase, some prio =>\n        return (phase, prio)\n      | some .simp, none, none =>\n        return (.norm, .int defaultSimpRulePriority)\n      | some .simp, none, some prio =>\n        return (.norm, prio)\n      | some .simp, some phase, none =>\n        return (phase, .int defaultSimpRulePriority)\n      | _, some .unsafe, none =>\n        return (.unsafe, .percent defaultSuccessProbability)\n      | _, some .safe, none =>\n        return (.safe, .int defaultSafePenalty)\n      | _, some .norm, none =>\n        return (.norm, .int defaultNormPenalty)\n      | _, none, some prio@(.percent _) =>\n        return (.unsafe, prio)\n      | _, none, _ =>\n        throwError \"phase (safe/unsafe/norm) not specified.\"\n\n    finish (c : RuleConfig Option) : m (RuleConfig Id) := do\n      let (some ident) := c.ident | throwError\n        \"rule name not specified\"\n      let (phase, priority) \u2190 getPhaseAndPriority c\n      let builder := c.builder.getD .default\n      let ruleSets :=\n        if c.ruleSets.ruleSets.isEmpty then\n          \u27e8#[defaultRuleSet]\u27e9\n        else\n          c.ruleSets\n      return { ident, phase, priority, builder, ruleSets }", "start": [693, 1], "end": [754, 59], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.toAdditionalGlobalRules", "code": "def toAdditionalGlobalRules (decl : Name) (e : RuleExpr) :\n    m (Array (RuleConfig Id)) :=\n  let init := {\n    ident := RuleIdent.const decl\n    phase := none\n    priority := none\n    builder := none\n    ruleSets := \u27e8#[]\u27e9\n  }\n  toAdditionalRules e init defaultRuleSetName", "start": [756, 1], "end": [765, 46], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.buildAdditionalGlobalRules", "code": "def buildAdditionalGlobalRules (decl : Name) (e : RuleExpr) :\n    MetaM (Array (RuleSetMember \u00d7 Array RuleSetName)) := do\n  (\u2190 e.toAdditionalGlobalRules decl).mapM (\u00b7.buildGlobalRule)", "start": [767, 1], "end": [769, 62], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.toAdditionalLocalRules", "code": "def toAdditionalLocalRules (goal : MVarId) (e : RuleExpr) :\n    MetaM (Array (RuleConfig Id)) :=\n  goal.withContext do\n    let init := {\n      ident := none\n      phase := none\n      priority := none\n      builder := none\n      ruleSets := \u27e8#[]\u27e9\n    }\n    toAdditionalRules e init localRuleSetName", "start": [771, 1], "end": [781, 46], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.buildAdditionalLocalRules", "code": "def buildAdditionalLocalRules (goal : MVarId) (e : RuleExpr) :\n    MetaM (MVarId \u00d7 Array (RuleSetMember \u00d7 Array RuleSetName)) := do\n  let configs \u2190 e.toAdditionalLocalRules goal\n  let mut goal := goal\n  let mut rs := Array.mkEmpty configs.size\n  for config in configs do\n    let (goal', rule) \u2190 config.buildLocalRule goal\n    goal := goal'\n    rs := rs.push rule\n  return (goal, rs)", "start": [783, 1], "end": [792, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.toRuleNameFilters", "code": "def toRuleNameFilters (e : RuleExpr) :\n    m (Array (RuleSetNameFilter \u00d7 RuleNameFilter)) := do\n  let initialConfig := {\n      ident := none\n      phase := none\n      priority := none\n      builder := none\n      ruleSets := \u27e8#[]\u27e9\n  }\n  let configs \u2190 e.foldBranchesM (init := initialConfig) go\n  configs.mapM (\u00b7.toRuleNameFilter)\n  where\n    go (r : RuleConfig Option) : Feature \u2192 m (RuleConfig Option)\n      | .phase p => do\n        if let (some previous) := r.phase then throwError\n          \"duplicate phase declaration: '{p}'\\n(previous declaration: '{previous}')\"\n        return { r with phase := some p }\n      | .priority prio =>\n        throwError \"unexpected priority '{prio}'\"\n      | .ident ident => do\n        if let (some previous) := r.ident then throwError\n          \"duplicate rule name: '{ident}'\\n(previous rule name: '{previous}')\"\n        return { r with ident }\n      | .builder b => do\n        if let (some previous) := r.builder then throwError\n          \"duplicate builder declaration: '{b.toDBuilderName}'\\n(previous declaration: '{previous.toDBuilderName}')\"\n        return { r with builder := some b }\n      | .ruleSets newRuleSets =>\n        have _ : Ord RuleSetName := \u27e8Name.quickCmp\u27e9\n        let ruleSets :=\n          \u27e8Array.mergeSortedDeduplicating r.ruleSets.ruleSets $\n            newRuleSets.ruleSets.qsortOrd\u27e9\n        return { r with ruleSets }", "start": [794, 1], "end": [826, 35], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.toGlobalRuleNameFilters", "code": "def toGlobalRuleNameFilters (e : RuleExpr) :\n    m (Array (RuleSetNameFilter \u00d7 RuleNameFilter)) :=\n  e.toRuleNameFilters", "start": [828, 1], "end": [830, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.RuleExpr.toLocalRuleNameFilters", "code": "def toLocalRuleNameFilters (goal : MVarId) (e : RuleExpr) :\n    MetaM (Array (RuleSetNameFilter \u00d7 RuleNameFilter)) :=\n  goal.withContext $ e.toRuleNameFilters", "start": [832, 1], "end": [834, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Frontend/Extension.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Extension/Init.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Frontend.extensionDescr", "code": "def extensionDescr (rsName : RuleSetName) :\n    SimpleScopedEnvExtension.Descr RuleSetMember RuleSet where\n  name := rsName\n  addEntry rs r := rs.add r\n  initial := \u2205", "start": [13, 1], "end": [17, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.declareRuleSetUnchecked", "code": "def declareRuleSetUnchecked (rsName : RuleSetName) (isDefault : Bool) :\n    IO Unit := do\n  let ext \u2190 registerSimpleScopedEnvExtension $ extensionDescr rsName\n  declaredRuleSetsRef.modify \u03bb rs =>\n    let ruleSets := rs.ruleSets.insert rsName ext\n    let defaultRuleSets :=\n      if isDefault then\n        rs.defaultRuleSets.insert rsName\n      else\n        rs.defaultRuleSets\n    { ruleSets, defaultRuleSets }", "start": [19, 1], "end": [29, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.isRuleSetDeclared", "code": "def isRuleSetDeclared (rsName : RuleSetName) : IO Bool :=\n  return (\u2190 getDeclaredRuleSets).contains rsName", "start": [31, 1], "end": [32, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.checkRuleSetNotDeclared", "code": "def checkRuleSetNotDeclared (rsName : RuleSetName) : m Unit := do\n  if \u2190 isRuleSetDeclared rsName then\n    throwError \"rule set '{rsName}' already exists\"", "start": [37, 1], "end": [39, 52], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.declareRuleSet", "code": "def declareRuleSet (rsName : RuleSetName) (isDefault : Bool) : m Unit := do\n  checkRuleSetNotDeclared rsName\n  declareRuleSetUnchecked rsName isDefault", "start": [41, 1], "end": [43, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.getRuleSetExtension", "code": "def getRuleSetExtension (rsName : RuleSetName) : m RuleSetExtension := do\n  let (some ext) := (\u2190 getDeclaredRuleSets).find? rsName\n    | throwError \"no such rule set: '{rsName}'\\n  (Use 'declare_aesop_rule_set' to declare rule sets.\\n   Declared rule sets are not visible in the current file; they only become visible once you import the declaring file.)\"\n  return ext", "start": [48, 1], "end": [51, 13], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.getRuleSet", "code": "def getRuleSet (rsName : RuleSetName) (includeGlobalSimpTheorems : Bool) :\n    CoreM RuleSet := do\n  let mut rs := (\u2190 getRuleSetExtension rsName).getState (\u2190 getEnv)\n  if includeGlobalSimpTheorems && rsName == defaultRuleSetName then\n    rs := { rs with\n      simpAttrNormSimpLemmas :=\n        rs.simpAttrNormSimpLemmas.push (`_, \u2190 Meta.getSimpTheorems)\n        |>.qsort (\u03bb (x, _) (y, _) => x.quickLt y)\n    }\n  return rs", "start": [53, 1], "end": [62, 12], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.getRuleSets", "code": "def getRuleSets (rsNames : NameSet)\n    (includeGlobalSimpTheorems : Bool) : CoreM RuleSets :=\n  rsNames.foldM (init := \u2205) \u03bb rss rsName => do\n    let rs \u2190 getRuleSet rsName includeGlobalSimpTheorems\n    return rss.addRuleSet rsName rs", "start": [64, 1], "end": [68, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.getDefaultRuleSets", "code": "def getDefaultRuleSets (includeGlobalSimpTheorems : Bool) : CoreM RuleSets := do\n  getRuleSets (\u2190 getDefaultRuleSetNames) includeGlobalSimpTheorems", "start": [70, 1], "end": [71, 67], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.getDefaultRuleSet", "code": "def getDefaultRuleSet (includeGlobalSimpTheorems : Bool) (options : Options) :\n    CoreM RuleSet :=\n  return (\u2190 getDefaultRuleSets includeGlobalSimpTheorems).getMergedRuleSet\n    options", "start": [73, 1], "end": [76, 12], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.getAllRuleSets", "code": "def getAllRuleSets (includeGlobalSimpTheorems : Bool) : CoreM RuleSets := do\n  (\u2190 getDeclaredRuleSets).foldM (init := \u2205) \u03bb rss rsName _ =>\n    return rss.addRuleSet rsName (\u2190 getRuleSet rsName includeGlobalSimpTheorems)", "start": [78, 1], "end": [80, 81], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.addRuleUnchecked", "code": "def addRuleUnchecked (rsName : RuleSetName) (r : RuleSetMember)\n    (kind : AttributeKind) : m Unit := do\n  let ext \u2190 getRuleSetExtension rsName\n  ext.add r kind", "start": [82, 1], "end": [85, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.addRule", "code": "def addRule (rsName : RuleSetName) (r : RuleSetMember) (kind : AttributeKind) :\n    m Unit := do\n  let ext \u2190 getRuleSetExtension rsName\n  let rs := ext.getState (\u2190 getEnv)\n  if rs.contains r.name then\n    throwError \"Rule '{r.name.name}' is already registered in rule set '{rsName}'.\"\n  ext.add r kind", "start": [87, 1], "end": [93, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.eraseRules", "code": "def eraseRules (rsf : RuleSetNameFilter) (rf : RuleNameFilter) (check : Bool) :\n    m Unit := do\n  match rsf.matchedRuleSetNames with\n  | none =>\n    let anyErased \u2190\n      (\u2190 getDeclaredRuleSets).foldM (init := false) \u03bb b _ ext => go b ext\n    if check && ! anyErased then\n      throwError \"'{rf.ident.name}' is not registered (with the given features) in any rule set.\"\n  | some rsNames =>\n    let anyErased \u2190\n      rsNames.foldlM (init := false) \u03bb b rsName => do\n        go b (\u2190 getRuleSetExtension rsName)\n    if check && ! anyErased then\n      throwError \"'{rf.ident.name}' is not registered (with the given features) in any of the rule sets {rsNames.map toString}.\"\n  where\n    go (anyErased : Bool) (ext : RuleSetExtension) : m Bool := do\n      let env \u2190 getEnv\n      let rs := ext.getState env\n      setEnv $ ext.modifyState env \u03bb _ => \u2205 let (rs, rsErased) := rs.erase rf\n      setEnv $ ext.modifyState env \u03bb _ => rs\n      return anyErased || rsErased", "start": [95, 1], "end": [116, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Congr!.lean", "imports": ["Mathlib/Tactic/Relation/Rfl.lean", "Mathlib/Lean/Meta/CongrTheorems.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Tactic/RCases.lean", "lake-packages/std/Std/Logic.lean"], "premises": [{"full_name": "Congr!.Config", "code": "structure Congr!.Config where\n  \n  closePre : Bool := true\n  \n  closePost : Bool := true\n  \n  transparency : TransparencyMode := TransparencyMode.reducible\n  \n  preTransparency : TransparencyMode := TransparencyMode.reducible\n  \n  preferLHS : Bool := true\n  \n  partialApp : Bool := true\n  \n  sameFun : Bool := false\n  \n  maxArgs : Option Nat := none\n  \n  typeEqs : Bool := false\n  \n  etaExpand : Bool := false\n  \n  useCongrSimp : Bool := false", "start": [30, 1], "end": [109, 31], "kind": "commanddeclaration"}, {"full_name": "Congr!.Config.unfoldSameFun", "code": "def Congr!.Config.unfoldSameFun : Congr!.Config where\n  partialApp := false\n  sameFun := true\n  transparency := .default\n  preTransparency := .default", "start": [111, 1], "end": [118, 30], "kind": "commanddeclaration"}, {"full_name": "Congr!.Config.numArgsOk", "code": "def Congr!.Config.numArgsOk (config : Config) (numArgs : Nat) : Bool :=\n  numArgs \u2264 config.maxArgs.getD numArgs", "start": [120, 1], "end": [122, 40], "kind": "commanddeclaration"}, {"full_name": "Congr!.Config.maxArgsFor", "code": "def Congr!.Config.maxArgsFor (config : Config) (numArgs : Nat) : Nat :=\n  min numArgs (config.maxArgs.getD numArgs)", "start": [124, 1], "end": [126, 44], "kind": "commanddeclaration"}, {"full_name": "applyCongrThm?", "code": "private def applyCongrThm?\n    (config : Congr!.Config) (mvarId : MVarId) (congrThmType congrThmProof : Expr) :\n    MetaM (List MVarId) := do\n  trace[congr!] \"trying to apply congr lemma {congrThmType}\"\n  try\n    let mvarId \u2190 mvarId.assert (\u2190 mkFreshUserName `h_congr_thm) congrThmType congrThmProof\n    let (fvarId, mvarId) \u2190 mvarId.intro1P\n    let mvarIds \u2190 withTransparency config.transparency <|\n      mvarId.apply (mkFVar fvarId) { synthAssignedInstances := false }\n    mvarIds.mapM fun mvarId => mvarId.tryClear fvarId\n  catch e =>\n    withTraceNode `congr! (fun _ => pure m!\"failed to apply congr lemma\") do\n      trace[congr!] \"{e.toMessageData}\"\n    throw e", "start": [128, 1], "end": [147, 12], "kind": "commanddeclaration"}, {"full_name": "Congr!.plausiblyEqualTypes", "code": "def Congr!.plausiblyEqualTypes (ty1 ty2 : Expr) (maxDepth : Nat := 5) : MetaM Bool :=\n  match maxDepth with\n  | 0 => return false\n  | maxDepth + 1 => do\n    if (\u2190 isProp ty1) && (\u2190 isProp ty2) then\n      return true\n    unless \u2190 withNewMCtxDepth <| isDefEq (\u2190 inferType ty1) (\u2190 inferType ty2) do\n      return false\n    let ty1 \u2190 whnfD ty1\n    let ty2 \u2190 whnfD ty2\n    unless \u2190 withNewMCtxDepth <| isDefEq ty1.getAppFn ty2.getAppFn do\n      return false\n    for arg1 in ty1.getAppArgs, arg2 in ty2.getAppArgs do\n      if (\u2190 isType arg1) && (\u2190 isType arg2) then\n        unless \u2190 plausiblyEqualTypes arg1 arg2 maxDepth do\n          return false\n    return true", "start": [149, 1], "end": [181, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.smartHCongr?", "code": "partial\ndef Lean.MVarId.smartHCongr? (config : Congr!.Config) (mvarId : MVarId) :\n    MetaM (Option (List MVarId)) :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `congr!\n    commitWhenSome? do\n      let mvarId \u2190 mvarId.eqOfHEq\n      let some (_, lhs, _, rhs) := (\u2190 withReducible mvarId.getType').heq? | return none\n      if let some mvars \u2190 loop mvarId 0 lhs rhs [] [] then\n        return mvars\n      trace[congr!] \"Default smartHCongr? failed, trying LHS/RHS method\"\n      let (fst, snd) := if config.preferLHS then (lhs, rhs) else (rhs, lhs)\n      if let some mvars \u2190 forSide mvarId fst then\n        return mvars\n      else if let some mvars \u2190 forSide mvarId snd then\n        return mvars\n      else\n        return none\nwhere\n  loop (mvarId : MVarId) (numArgs : Nat) (lhs rhs : Expr) (lhsArgs rhsArgs : List Expr) :\n      MetaM (Option (List MVarId)) :=\n    match lhs.cleanupAnnotations, rhs.cleanupAnnotations with\n    | .app f a, .app f' b => do\n      if not (config.numArgsOk (numArgs + 1)) then\n        return none\n      let lhsArgs' := a :: lhsArgs\n      let rhsArgs' := b :: rhsArgs\n      if let some mvars \u2190 loop mvarId (numArgs + 1) f f' lhsArgs' rhsArgs' then\n        return mvars\n      if not config.partialApp && f.isApp && f'.isApp then\n        return none\n      unless \u2190 withNewMCtxDepth <| isDefEq (\u2190 inferType f) (\u2190 inferType f') do\n        return none\n      let funDefEq \u2190 withReducible <| withNewMCtxDepth <| isDefEq f f'\n      if config.sameFun && not funDefEq then\n        return none\n      let info \u2190 getFunInfoNArgs f (numArgs + 1)\n      let mut fixed : Array Bool := #[]\n      for larg in lhsArgs', rarg in rhsArgs', pinfo in info.paramInfo do\n        if !config.typeEqs && (!pinfo.isExplicit || pinfo.hasFwdDeps) then\n          if \u2190 isType larg then\n            unless \u2190 Congr!.plausiblyEqualTypes larg rarg do\n              fixed := fixed.push true\n              continue\n        fixed := fixed.push (\u2190 withReducible <| withNewMCtxDepth <| isDefEq larg rarg)\n      let cthm \u2190 mkRichHCongr (forceHEq := true) (\u2190 inferType f) info\n                  (fixedFun := funDefEq) (fixedParams := fixed)\n      let (congrThm', congrProof') :=\n        if funDefEq then\n          (cthm.type.bindingBody!.instantiate1 f, cthm.proof.beta #[f])\n        else\n          (cthm.type.bindingBody!.bindingBody!.instantiateRev #[f, f'],\n           cthm.proof.beta #[f, f'])\n      observing? <| applyCongrThm? config mvarId congrThm' congrProof'\n    | _, _ => return none\n  forSide (mvarId : MVarId) (side : Expr) : MetaM (Option (List MVarId)) := do\n    let side := side.cleanupAnnotations\n    if not side.isApp then return none\n    let numArgs := config.maxArgsFor side.getAppNumArgs\n    if not config.partialApp && numArgs < side.getAppNumArgs then\n        return none\n    let mut f := side\n    for _ in [:numArgs] do\n      f := f.appFn!'\n    let info \u2190 getFunInfoNArgs f numArgs\n    let mut fixed : Array Bool := #[]\n    if !config.typeEqs then\n      for pinfo in info.paramInfo, arg in side.getAppArgs do\n        if pinfo.isProp || !(\u2190 isType arg) then\n          fixed := fixed.push false\n        else if pinfo.isExplicit && !pinfo.hasFwdDeps then\n          fixed := fixed.push false\n        else\n          fixed := fixed.push true\n    let cthm \u2190 mkRichHCongr (forceHEq := true) (\u2190 inferType f) info\n                (fixedFun := true) (fixedParams := fixed)\n    let congrThm' := cthm.type.bindingBody!.instantiate1 f\n    let congrProof' := cthm.proof.beta #[f]\n    observing? <| applyCongrThm? config mvarId congrThm' congrProof'", "start": [183, 1], "end": [297, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congrSimp?", "code": "def Lean.MVarId.congrSimp? (config : Congr!.Config) (mvarId : MVarId) :\n    MetaM (Option (List MVarId)) :=\n  mvarId.withContext do\n    unless config.useCongrSimp do return none\n    mvarId.checkNotAssigned `congrSimp?\n    let some (_, lhs, rhs) := (\u2190 withReducible mvarId.getType').eq? | return none\n    let (fst, snd) := if config.preferLHS then (lhs, rhs) else (rhs, lhs)\n    if let some mvars \u2190 forSide mvarId fst then\n      return mvars\n    else if let some mvars \u2190 forSide mvarId snd then\n      return mvars\n    else\n      return none\nwhere\n  forSide (mvarId : MVarId) (side : Expr) : MetaM (Option (List MVarId)) :=\n    commitWhenSome? do\n      let side := side.cleanupAnnotations\n      if not side.isApp then return none\n      let numArgs := config.maxArgsFor side.getAppNumArgs\n      if not config.partialApp && numArgs < side.getAppNumArgs then\n        return none\n      let mut f := side\n      for _ in [:numArgs] do\n        f := f.appFn!'\n      let some congrThm \u2190 mkCongrSimpNArgs f numArgs\n        | return none\n      observing? <| applyCongrThm? config mvarId congrThm.type congrThm.proof\n  \n  mkCongrSimpNArgs (f : Expr) (nArgs : Nat) : MetaM (Option CongrTheorem) := do\n    let f := (\u2190 instantiateMVars f).cleanupAnnotations\n    let info \u2190 getFunInfoNArgs f nArgs\n    mkCongrSimpCore? f info\n      (\u2190 getCongrSimpKinds f info) (subsingletonInstImplicitRhs := false)", "start": [299, 1], "end": [339, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.userCongr?", "code": "def Lean.MVarId.userCongr? (config : Congr!.Config) (mvarId : MVarId) :\n    MetaM (Option (List MVarId)) :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `userCongr?\n    let some (lhs, rhs) := (\u2190 withReducible mvarId.getType').eqOrIff? | return none\n    let (fst, snd) := if config.preferLHS then (lhs, rhs) else (rhs, lhs)\n    if let some mvars \u2190 forSide fst then\n      return mvars\n    else if let some mvars \u2190 forSide snd then\n      return mvars\n    else\n      return none\nwhere\n  forSide (side : Expr) : MetaM (Option (List MVarId)) := do\n    let side := side.cleanupAnnotations\n    if not side.isApp then return none\n    let some name := side.getAppFn.constName? | return none\n    let congrTheorems := (\u2190 getSimpCongrTheorems).get name\n    for congrTheorem in congrTheorems do\n      let res \u2190 observing? do\n        let cinfo \u2190 getConstInfo congrTheorem.theoremName\n        let us \u2190 cinfo.levelParams.mapM fun _ => mkFreshLevelMVar\n        let proof := mkConst congrTheorem.theoremName us\n        let ptype \u2190 instantiateTypeLevelParams cinfo us\n        applyCongrThm? config mvarId ptype proof\n      if let some mvars := res then\n        return mvars\n    return none", "start": [341, 1], "end": [375, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congrPi?", "code": "def Lean.MVarId.congrPi? (mvarId : MVarId) : MetaM (Option (List MVarId)) :=\n  observing? do withReducible <| mvarId.apply (\u2190 mkConstWithFreshMVarLevels `pi_congr)", "start": [377, 1], "end": [381, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.obviousFunext?", "code": "def Lean.MVarId.obviousFunext? (mvarId : MVarId) : MetaM (Option (List MVarId)) :=\n  mvarId.withContext <| observing? do\n    let some (_, lhs, rhs) := (\u2190 withReducible mvarId.getType').eq? | failure\n    if not lhs.cleanupAnnotations.isLambda && not rhs.cleanupAnnotations.isLambda then failure\n    mvarId.apply (\u2190 mkConstWithFreshMVarLevels ``funext)", "start": [383, 1], "end": [394, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.obviousHfunext?", "code": "def Lean.MVarId.obviousHfunext? (mvarId : MVarId) : MetaM (Option (List MVarId)) :=\n  mvarId.withContext <| observing? do\n    let some (_, lhs, _, rhs) := (\u2190 withReducible mvarId.getType').heq? | failure\n    if not lhs.cleanupAnnotations.isLambda && not rhs.cleanupAnnotations.isLambda then failure\n    mvarId.apply (\u2190 mkConstWithFreshMVarLevels `Function.hfunext)", "start": [396, 1], "end": [407, 66], "kind": "commanddeclaration"}, {"full_name": "implies_congr'", "code": "private theorem implies_congr' {\u03b1 \u03b1' : Sort u} {\u03b2 \u03b2' : Sort v} (h : \u03b1 = \u03b1') (h' : \u03b1' \u2192 \u03b2 = \u03b2') :\n    (\u03b1 \u2192 \u03b2) = (\u03b1' \u2192 \u03b2')", "start": [409, 1], "end": [415, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congrImplies?'", "code": "def Lean.MVarId.congrImplies?' (mvarId : MVarId) : MetaM (Option (List MVarId)) :=\n  observing? do\n    let [mvarId\u2081, mvarId\u2082] \u2190 mvarId.apply (\u2190 mkConstWithFreshMVarLevels ``implies_congr')\n      | throwError \"unexpected number of goals\"\n    return [mvarId\u2081, mvarId\u2082]", "start": [417, 1], "end": [423, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.subsingletonHelim?", "code": "def Lean.MVarId.subsingletonHelim? (mvarId : MVarId) : MetaM (Option (List MVarId)) :=\n  mvarId.withContext <| observing? do\n    mvarId.checkNotAssigned `subsingletonHelim\n    let some (\u03b1, lhs, \u03b2, rhs) := (\u2190 withReducible mvarId.getType').heq? | failure\n    let eqmvar \u2190 mkFreshExprSyntheticOpaqueMVar (\u2190 mkEq \u03b1 \u03b2) (\u2190 mvarId.getTag)\n    if let some pf \u2190 observing? (mkAppM ``Subsingleton.helim #[eqmvar, lhs, rhs]) then\n      mvarId.assign pf\n      return [eqmvar.mvarId!]\n    let eqsymm \u2190 mkAppM ``Eq.symm #[eqmvar]\n    if let some pf \u2190 observing? (mkAppM ``Subsingleton.helim #[eqsymm, rhs, lhs]) then\n      mvarId.assign (\u2190 mkAppM ``HEq.symm #[pf])\n      return [eqmvar.mvarId!]\n    failure", "start": [425, 1], "end": [445, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congrPasses!", "code": "def Lean.MVarId.congrPasses! :\n    List (String \u00d7 (Congr!.Config \u2192 MVarId \u2192 MetaM (Option (List MVarId)))) :=\n  [(\"user congr\", userCongr?),\n   (\"hcongr lemma\", smartHCongr?),\n   (\"congr simp lemma\", congrSimp?),\n   (\"Subsingleton.helim\", fun _ => subsingletonHelim?),\n   (\"obvious funext\", fun _ => obviousFunext?),\n   (\"obvious hfunext\", fun _ => obviousHfunext?),\n   (\"congr_implies\", fun _ => congrImplies?'),\n   (\"congr_pi\", fun _ => congrPi?)]", "start": [447, 1], "end": [459, 36], "kind": "commanddeclaration"}, {"full_name": "CongrState", "code": "structure CongrState where\n  \n  goals : Array MVarId\n  \n  patterns : List (TSyntax `rcasesPat)", "start": [461, 1], "end": [465, 39], "kind": "commanddeclaration"}, {"full_name": "CongrMetaM", "code": "abbrev CongrMetaM := StateRefT CongrState MetaM", "start": [467, 1], "end": [467, 48], "kind": "commanddeclaration"}, {"full_name": "CongrMetaM.nextPattern", "code": "def CongrMetaM.nextPattern : CongrMetaM (Option (TSyntax `rcasesPat)) := do\n  modifyGet fun s =>\n    if let p :: ps := s.patterns then\n      (p, {s with patterns := ps})\n    else\n      (none, s)", "start": [469, 1], "end": [475, 16], "kind": "commanddeclaration"}, {"full_name": "heq_imp_of_eq_imp", "code": "private theorem heq_imp_of_eq_imp {p : HEq x y \u2192 Prop} (h : (he : x = y) \u2192 p (heq_of_eq he))\n    (he : HEq x y) : p he", "start": [477, 1], "end": [480, 14], "kind": "commanddeclaration"}, {"full_name": "eq_imp_of_iff_imp", "code": "private theorem eq_imp_of_iff_imp {p : x = y \u2192 Prop} (h : (he : x \u2194 y) \u2192 p (propext he))\n    (he : x = y) : p he", "start": [482, 1], "end": [485, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.introsClean", "code": "partial\ndef Lean.MVarId.introsClean (mvarId : MVarId) : CongrMetaM (List MVarId) :=\n  loop mvarId\nwhere\n  heqImpOfEqImp (mvarId : MVarId) : MetaM (Option MVarId) :=\n    observing? <| withReducible do\n      let [mvarId] \u2190 mvarId.apply (\u2190 mkConstWithFreshMVarLevels ``heq_imp_of_eq_imp) | failure\n      return mvarId\n  eqImpOfIffImp (mvarId : MVarId) : MetaM (Option MVarId) :=\n    observing? <| withReducible do\n      let [mvarId] \u2190 mvarId.apply (\u2190 mkConstWithFreshMVarLevels ``eq_imp_of_iff_imp) | failure\n      return mvarId\n  loop (mvarId : MVarId) : CongrMetaM (List MVarId) :=\n    mvarId.withContext do\n      let ty \u2190 withReducible <| mvarId.getType'\n      if ty.isForall then\n        let mvarId := (\u2190 heqImpOfEqImp mvarId).getD mvarId\n        let mvarId := (\u2190 eqImpOfIffImp mvarId).getD mvarId\n        let ty \u2190 withReducible <| mvarId.getType'\n        if ty.isArrow then\n          if \u2190 (isTrivialType ty.bindingDomain!\n                <||> (\u2190 getLCtx).anyM (fun decl => do\n                        return (\u2190 instantiateMVars decl.type) == ty.bindingDomain!)) then\n            let mvar \u2190 mkFreshExprSyntheticOpaqueMVar ty.bindingBody! (\u2190 mvarId.getTag)\n            mvarId.assign <| .lam .anonymous ty.bindingDomain! mvar .default\n            return \u2190 loop mvar.mvarId!\n        if let some patt \u2190 CongrMetaM.nextPattern then\n          let gs \u2190 Term.TermElabM.run' <| Std.Tactic.RCases.rintro #[patt] none mvarId\n          List.join <$> gs.mapM loop\n        else\n          let (_, mvarId) \u2190 mvarId.intro1\n          loop mvarId\n      else\n        return [mvarId]\n  isTrivialType (ty : Expr) : MetaM Bool := do\n    unless \u2190 Meta.isProp ty do\n      return false\n    let ty \u2190 instantiateMVars ty\n    if let some (lhs, rhs) := ty.eqOrIff? then\n      if lhs.cleanupAnnotations == rhs.cleanupAnnotations then\n        return true\n    if let some (\u03b1, lhs, \u03b2, rhs) := ty.heq? then\n      if \u03b1.cleanupAnnotations == \u03b2.cleanupAnnotations\n          && lhs.cleanupAnnotations == rhs.cleanupAnnotations then\n        return true\n    return false", "start": [487, 1], "end": [544, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.preCongr!", "code": "def Lean.MVarId.preCongr! (mvarId : MVarId) (tryClose : Bool) : MetaM (Option MVarId) := do\n  let mvarId \u2190 mvarId.heqOfEq\n  if tryClose then\n    if \u2190 mvarId.assumptionCore then return none\n  let mvarId \u2190 mvarId.iffOfEq\n  if tryClose then\n    try withAssignableSyntheticOpaque mvarId.refl; return none catch _ => pure ()\n    if \u2190 mvarId.subsingletonElim then return none\n    if \u2190 mvarId.proofIrrelHeq then return none\n  return some mvarId", "start": [546, 1], "end": [564, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congrCore!", "code": "def Lean.MVarId.congrCore! (config : Congr!.Config) (mvarId : MVarId) :\n    MetaM (Option (List MVarId)) := do\n  mvarId.checkNotAssigned `congr!\n  let s \u2190 saveState\n  \n  let mvarId \u2190 mvarId.liftReflToEq\n  for (passName, pass) in congrPasses! do\n    try\n      if let some mvarIds \u2190 pass config mvarId then\n        trace[congr!] \"pass succeeded: {passName}\"\n        return mvarIds\n    catch e =>\n      throwTacticEx `congr! mvarId\n        m!\"internal error in congruence pass {passName}, {e.toMessageData}\"\n    if \u2190 mvarId.isAssigned then\n      throwTacticEx `congr! mvarId\n        s!\"congruence pass {passName} assigned metavariable but failed\"\n  restoreState s\n  trace[congr!] \"no passes succeeded\"\n  return none", "start": [566, 1], "end": [586, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.postCongr!", "code": "def Lean.MVarId.postCongr! (config : Congr!.Config) (mvarId : MVarId) : MetaM (Option MVarId) := do\n  let some mvarId \u2190 mvarId.preCongr! config.closePost | return none\n  let mvarId \u2190 mvarId.propext\n  if config.closePost then\n    if \u2190 mvarId.assumptionCore then return none\n  if config.etaExpand then\n    if let some (_, lhs, rhs) := (\u2190 withReducible mvarId.getType').eq? then\n      let lhs' \u2190 Meta.etaExpand lhs\n      let rhs' \u2190 Meta.etaExpand rhs\n      return \u2190 mvarId.change (\u2190 mkEq lhs' rhs')\n  return mvarId", "start": [588, 1], "end": [601, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congrN!", "code": "def Lean.MVarId.congrN! (mvarId : MVarId)\n    (depth? : Option Nat := none) (config : Congr!.Config := {})\n    (patterns : List (TSyntax `rcasesPat) := []) :\n    MetaM (List MVarId) := do\n  let ty \u2190 withReducible <| mvarId.getType'\n  let defaultDepth := min 1000000 (8 * (1 + ty.approxDepth.toNat))\n  let depth := depth?.getD defaultDepth\n  let (_, s) \u2190 go depth depth mvarId |>.run {goals := #[], patterns := patterns}\n  return s.goals.toList\nwhere\n  post (mvarId : MVarId) : CongrMetaM Unit := do\n    for mvarId in \u2190 mvarId.introsClean do\n      if let some mvarId \u2190 mvarId.postCongr! config then\n        modify (fun s => {s with goals := s.goals.push mvarId})\n      else\n        trace[congr!] \"Dispatched goal by post-processing step.\"\n  go (depth : Nat) (n : Nat) (mvarId : MVarId) : CongrMetaM Unit := do\n    for mvarId in \u2190 mvarId.introsClean do\n      if let some mvarId \u2190 withTransparency config.preTransparency <|\n                              mvarId.preCongr! config.closePre then\n        match n with\n          | 0 =>\n            trace[congr!] \"At level {depth - n}, doing post-processing. {mvarId}\"\n            post mvarId\n          | n + 1 =>\n            trace[congr!] \"At level {depth - n}, trying congrCore!. {mvarId}\"\n            if let some mvarIds \u2190 mvarId.congrCore! config then\n              mvarIds.forM (go depth n)\n            else\n              post mvarId", "start": [603, 1], "end": [638, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Order/Defs.lean", "imports": ["Mathlib/Init/Data/Ordering/Basic.lean", "Mathlib/Init/Algebra/Classes.lean", "Mathlib/Tactic/SplitIfs.lean", "Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Preorder", "code": "class Preorder (\u03b1 : Type u) extends LE \u03b1, LT \u03b1 where\n  le_refl : \u2200 a : \u03b1, a \u2264 a\n  le_trans : \u2200 a b c : \u03b1, a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c\n  lt := fun a b => a \u2264 b \u2227 \u00acb \u2264 a\n  lt_iff_le_not_le : \u2200 a b : \u03b1, a < b \u2194 a \u2264 b \u2227 \u00acb \u2264 a := by intros; rfl", "start": [36, 1], "end": [41, 73], "kind": "commanddeclaration"}, {"full_name": "le_refl", "code": "@[refl]\ntheorem le_refl : \u2200 a : \u03b1, a \u2264 a", "start": [48, 1], "end": [51, 19], "kind": "commanddeclaration"}, {"full_name": "le_trans", "code": "@[trans]\ntheorem le_trans : \u2200 {a b c : \u03b1}, a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c", "start": [54, 1], "end": [57, 26], "kind": "commanddeclaration"}, {"full_name": "lt_iff_le_not_le", "code": "theorem lt_iff_le_not_le : \u2200 {a b : \u03b1}, a < b \u2194 a \u2264 b \u2227 \u00acb \u2264 a", "start": [60, 1], "end": [61, 32], "kind": "commanddeclaration"}, {"full_name": "lt_of_le_not_le", "code": "theorem lt_of_le_not_le : \u2200 {a b : \u03b1}, a \u2264 b \u2192 \u00acb \u2264 a \u2192 a < b", "start": [64, 1], "end": [65, 56], "kind": "commanddeclaration"}, {"full_name": "le_not_le_of_lt", "code": "theorem le_not_le_of_lt : \u2200 {a b : \u03b1}, a < b \u2192 a \u2264 b \u2227 \u00acb \u2264 a", "start": [68, 1], "end": [69, 43], "kind": "commanddeclaration"}, {"full_name": "le_of_eq", "code": "theorem le_of_eq {a b : \u03b1} : a = b \u2192 a \u2264 b", "start": [72, 1], "end": [72, 69], "kind": "commanddeclaration"}, {"full_name": "ge_trans", "code": "@[trans]\ntheorem ge_trans : \u2200 {a b c : \u03b1}, a \u2265 b \u2192 b \u2265 c \u2192 a \u2265 c", "start": [75, 1], "end": [76, 87], "kind": "commanddeclaration"}, {"full_name": "lt_irrefl", "code": "theorem lt_irrefl : \u2200 a : \u03b1, \u00aca < a", "start": [79, 1], "end": [82, 24], "kind": "commanddeclaration"}, {"full_name": "gt_irrefl", "code": "theorem gt_irrefl : \u2200 a : \u03b1, \u00aca > a", "start": [85, 1], "end": [86, 12], "kind": "commanddeclaration"}, {"full_name": "lt_trans", "code": "@[trans]\ntheorem lt_trans : \u2200 {a b c : \u03b1}, a < b \u2192 b < c \u2192 a < c", "start": [89, 1], "end": [94, 75], "kind": "commanddeclaration"}, {"full_name": "gt_trans", "code": "@[trans]\ntheorem gt_trans : \u2200 {a b c : \u03b1}, a > b \u2192 b > c \u2192 a > c", "start": [97, 1], "end": [98, 87], "kind": "commanddeclaration"}, {"full_name": "ne_of_lt", "code": "theorem ne_of_lt {a b : \u03b1} (h : a < b) : a \u2260 b", "start": [101, 1], "end": [101, 88], "kind": "commanddeclaration"}, {"full_name": "ne_of_gt", "code": "theorem ne_of_gt {a b : \u03b1} (h : b < a) : a \u2260 b", "start": [104, 1], "end": [104, 88], "kind": "commanddeclaration"}, {"full_name": "lt_asymm", "code": "theorem lt_asymm {a b : \u03b1} (h : a < b) : \u00acb < a", "start": [107, 1], "end": [107, 97], "kind": "commanddeclaration"}, {"full_name": "le_of_lt", "code": "theorem le_of_lt : \u2200 {a b : \u03b1}, a < b \u2192 a \u2264 b", "start": [110, 1], "end": [111, 46], "kind": "commanddeclaration"}, {"full_name": "lt_of_lt_of_le", "code": "@[trans]\ntheorem lt_of_lt_of_le : \u2200 {a b c : \u03b1}, a < b \u2192 b \u2264 c \u2192 a < c", "start": [114, 1], "end": [118, 73], "kind": "commanddeclaration"}, {"full_name": "lt_of_le_of_lt", "code": "@[trans]\ntheorem lt_of_le_of_lt : \u2200 {a b c : \u03b1}, a \u2264 b \u2192 b < c \u2192 a < c", "start": [121, 1], "end": [125, 73], "kind": "commanddeclaration"}, {"full_name": "gt_of_gt_of_ge", "code": "@[trans]\ntheorem gt_of_gt_of_ge {a b c : \u03b1} (h\u2081 : a > b) (h\u2082 : b \u2265 c) : a > c", "start": [128, 1], "end": [130, 23], "kind": "commanddeclaration"}, {"full_name": "gt_of_ge_of_gt", "code": "@[trans]\ntheorem gt_of_ge_of_gt {a b c : \u03b1} (h\u2081 : a \u2265 b) (h\u2082 : b > c) : a > c", "start": [133, 1], "end": [135, 23], "kind": "commanddeclaration"}, {"full_name": "not_le_of_gt", "code": "theorem not_le_of_gt {a b : \u03b1} (h : a > b) : \u00aca \u2264 b", "start": [148, 1], "end": [149, 28], "kind": "commanddeclaration"}, {"full_name": "not_lt_of_ge", "code": "theorem not_lt_of_ge {a b : \u03b1} (h : a \u2265 b) : \u00aca < b", "start": [152, 1], "end": [152, 85], "kind": "commanddeclaration"}, {"full_name": "le_of_lt_or_eq", "code": "theorem le_of_lt_or_eq : \u2200 {a b : \u03b1}, a < b \u2228 a = b \u2192 a \u2264 b", "start": [155, 1], "end": [157, 42], "kind": "commanddeclaration"}, {"full_name": "le_of_eq_or_lt", "code": "theorem le_of_eq_or_lt {a b : \u03b1} (h : a = b \u2228 a < b) : a \u2264 b", "start": [160, 1], "end": [161, 30], "kind": "commanddeclaration"}, {"full_name": "decidableLTOfDecidableLE", "code": "def decidableLTOfDecidableLE [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] : @DecidableRel \u03b1 (\u00b7 < \u00b7)\n  | a, b =>\n    if hab : a \u2264 b then\n      if hba : b \u2264 a then isFalse fun hab' => not_le_of_gt hab' hba\n      else isTrue <| lt_of_le_not_le hab hba\n    else isFalse fun hab' => hab (le_of_lt hab')", "start": [164, 1], "end": [170, 49], "kind": "commanddeclaration"}, {"full_name": "PartialOrder", "code": "class PartialOrder (\u03b1 : Type u) extends Preorder \u03b1 where\n  le_antisymm : \u2200 a b : \u03b1, a \u2264 b \u2192 b \u2264 a \u2192 a = b", "start": [181, 1], "end": [183, 49], "kind": "commanddeclaration"}, {"full_name": "le_antisymm", "code": "theorem le_antisymm : \u2200 {a b : \u03b1}, a \u2264 b \u2192 b \u2264 a \u2192 a = b", "start": [188, 1], "end": [189, 31], "kind": "commanddeclaration"}, {"full_name": "le_antisymm_iff", "code": "theorem le_antisymm_iff {a b : \u03b1} : a = b \u2194 a \u2264 b \u2227 b \u2264 a", "start": [192, 1], "end": [193, 78], "kind": "commanddeclaration"}, {"full_name": "lt_of_le_of_ne", "code": "theorem lt_of_le_of_ne {a b : \u03b1} : a \u2264 b \u2192 a \u2260 b \u2192 a < b", "start": [196, 1], "end": [197, 47], "kind": "commanddeclaration"}, {"full_name": "decidableEqOfDecidableLE", "code": "def decidableEqOfDecidableLE [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] : DecidableEq \u03b1\n  | a, b =>\n    if hab : a \u2264 b then\n      if hba : b \u2264 a then isTrue (le_antisymm hab hba) else isFalse fun heq => hba (heq \u25b8 le_refl _)\n    else isFalse fun heq => hab (heq \u25b8 le_refl _)", "start": [200, 1], "end": [205, 50], "kind": "commanddeclaration"}, {"full_name": "Decidable.lt_or_eq_of_le", "code": "theorem lt_or_eq_of_le {a b : \u03b1} (hab : a \u2264 b) : a < b \u2228 a = b", "start": [212, 1], "end": [213, 89], "kind": "commanddeclaration"}, {"full_name": "Decidable.eq_or_lt_of_le", "code": "theorem eq_or_lt_of_le {a b : \u03b1} (hab : a \u2264 b) : a = b \u2228 a < b", "start": [216, 1], "end": [217, 28], "kind": "commanddeclaration"}, {"full_name": "Decidable.le_iff_lt_or_eq", "code": "theorem le_iff_lt_or_eq {a b : \u03b1} : a \u2264 b \u2194 a < b \u2228 a = b", "start": [220, 1], "end": [221, 35], "kind": "commanddeclaration"}, {"full_name": "lt_or_eq_of_le", "code": "theorem lt_or_eq_of_le {a b : \u03b1} : a \u2264 b \u2192 a < b \u2228 a = b", "start": [228, 1], "end": [229, 27], "kind": "commanddeclaration"}, {"full_name": "le_iff_lt_or_eq", "code": "theorem le_iff_lt_or_eq {a b : \u03b1} : a \u2264 b \u2194 a < b \u2228 a = b", "start": [232, 1], "end": [233, 28], "kind": "commanddeclaration"}, {"full_name": "maxDefault", "code": "def maxDefault {\u03b1 : Type u} [LE \u03b1] [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] (a b : \u03b1) :=\n  if a \u2264 b then b else a", "start": [244, 1], "end": [246, 25], "kind": "commanddeclaration"}, {"full_name": "minDefault", "code": "def minDefault {\u03b1 : Type u} [LE \u03b1] [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] (a b : \u03b1) :=\n  if a \u2264 b then a else b", "start": [249, 1], "end": [251, 25], "kind": "commanddeclaration"}, {"full_name": "LinearOrder", "code": "class LinearOrder (\u03b1 : Type u) extends PartialOrder \u03b1, Min \u03b1, Max \u03b1, Ord \u03b1 :=\n  \n  le_total (a b : \u03b1) : a \u2264 b \u2228 b \u2264 a\n  \n  decidableLE : DecidableRel (\u00b7 \u2264 \u00b7 : \u03b1 \u2192 \u03b1 \u2192 Prop)\n  \n  decidableEq : DecidableEq \u03b1 := @decidableEqOfDecidableLE _ _ decidableLE\n  \n  decidableLT : DecidableRel (\u00b7 < \u00b7 : \u03b1 \u2192 \u03b1 \u2192 Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  min := fun a b => if a \u2264 b then a else b\n  max := fun a b => if a \u2264 b then b else a\n  \n  min_def : \u2200 a b, min a b = if a \u2264 b then a else b := by intros; rfl\n  \n  max_def : \u2200 a b, max a b = if a \u2264 b then b else a := by intros; rfl\n  compare a b := compareOfLessAndEq a b\n  \n  compare_eq_compareOfLessAndEq : \u2200 a b, compare a b = compareOfLessAndEq a b := by\n    compareOfLessAndEq_rfl", "start": [267, 1], "end": [288, 27], "kind": "commanddeclaration"}, {"full_name": "le_total", "code": "theorem le_total : \u2200 a b : \u03b1, a \u2264 b \u2228 b \u2264 a", "start": [295, 1], "end": [296, 23], "kind": "commanddeclaration"}, {"full_name": "le_of_not_ge", "code": "theorem le_of_not_ge {a b : \u03b1} : \u00aca \u2265 b \u2192 a \u2264 b", "start": [299, 1], "end": [300, 33], "kind": "commanddeclaration"}, {"full_name": "le_of_not_le", "code": "theorem le_of_not_le {a b : \u03b1} : \u00aca \u2264 b \u2192 b \u2264 a", "start": [303, 1], "end": [304, 33], "kind": "commanddeclaration"}, {"full_name": "not_lt_of_gt", "code": "theorem not_lt_of_gt {a b : \u03b1} (h : a > b) : \u00aca < b", "start": [307, 1], "end": [308, 13], "kind": "commanddeclaration"}, {"full_name": "lt_trichotomy", "code": "theorem lt_trichotomy (a b : \u03b1) : a < b \u2228 a = b \u2228 b < a", "start": [311, 1], "end": [318, 29], "kind": "commanddeclaration"}, {"full_name": "le_of_not_lt", "code": "theorem le_of_not_lt {a b : \u03b1} (h : \u00acb < a) : a \u2264 b", "start": [321, 1], "end": [325, 40], "kind": "commanddeclaration"}, {"full_name": "le_of_not_gt", "code": "theorem le_of_not_gt {a b : \u03b1} : \u00aca > b \u2192 a \u2264 b", "start": [328, 1], "end": [329, 15], "kind": "commanddeclaration"}, {"full_name": "lt_of_not_ge", "code": "theorem lt_of_not_ge {a b : \u03b1} (h : \u00aca \u2265 b) : a < b", "start": [332, 1], "end": [333, 53], "kind": "commanddeclaration"}, {"full_name": "lt_or_le", "code": "theorem lt_or_le (a b : \u03b1) : a < b \u2228 b \u2264 a", "start": [336, 1], "end": [337, 65], "kind": "commanddeclaration"}, {"full_name": "le_or_lt", "code": "theorem le_or_lt (a b : \u03b1) : a \u2264 b \u2228 b < a", "start": [340, 1], "end": [341, 22], "kind": "commanddeclaration"}, {"full_name": "lt_or_ge", "code": "theorem lt_or_ge : \u2200 a b : \u03b1, a < b \u2228 a \u2265 b", "start": [344, 1], "end": [345, 11], "kind": "commanddeclaration"}, {"full_name": "le_or_gt", "code": "theorem le_or_gt : \u2200 a b : \u03b1, a \u2264 b \u2228 a > b", "start": [348, 1], "end": [349, 11], "kind": "commanddeclaration"}, {"full_name": "lt_or_gt_of_ne", "code": "theorem lt_or_gt_of_ne {a b : \u03b1} (h : a \u2260 b) : a < b \u2228 a > b", "start": [352, 1], "end": [356, 38], "kind": "commanddeclaration"}, {"full_name": "ne_iff_lt_or_gt", "code": "theorem ne_iff_lt_or_gt {a b : \u03b1} : a \u2260 b \u2194 a < b \u2228 a > b", "start": [359, 1], "end": [360, 57], "kind": "commanddeclaration"}, {"full_name": "lt_iff_not_ge", "code": "theorem lt_iff_not_ge (x y : \u03b1) : x < y \u2194 \u00acx \u2265 y", "start": [363, 1], "end": [364, 31], "kind": "commanddeclaration"}, {"full_name": "not_lt", "code": "@[simp]\ntheorem not_lt {a b : \u03b1} : \u00aca < b \u2194 b \u2264 a", "start": [367, 1], "end": [369, 31], "kind": "commanddeclaration"}, {"full_name": "not_le", "code": "@[simp]\ntheorem not_le {a b : \u03b1} : \u00aca \u2264 b \u2194 b < a", "start": [372, 1], "end": [374, 27], "kind": "commanddeclaration"}, {"full_name": "eq_or_lt_of_not_lt", "code": "theorem eq_or_lt_of_not_lt {a b : \u03b1} (h : \u00aca < b) : a = b \u2228 b < a", "start": [386, 1], "end": [387, 95], "kind": "commanddeclaration"}, {"full_name": "isStrictWeakOrder_of_linearOrder", "code": "instance isStrictWeakOrder_of_linearOrder : IsStrictWeakOrder \u03b1 (\u00b7 < \u00b7) :=\n  have : IsTotalPreorder \u03b1 (\u00b7 \u2264 \u00b7) := by infer_instance isStrictWeakOrder_of_isTotalPreorder lt_iff_not_ge", "start": [396, 1], "end": [398, 53], "kind": "commanddeclaration"}, {"full_name": "isStrictTotalOrder_of_linearOrder", "code": "instance isStrictTotalOrder_of_linearOrder : IsStrictTotalOrder \u03b1 (\u00b7 < \u00b7) where\n  trichotomous := lt_trichotomy", "start": [402, 1], "end": [403, 32], "kind": "commanddeclaration"}, {"full_name": "ltByCases", "code": "def ltByCases (x y : \u03b1) {P : Sort*} (h\u2081 : x < y \u2192 P) (h\u2082 : x = y \u2192 P) (h\u2083 : y < x \u2192 P) : P :=\n  if h : x < y then h\u2081 h\n  else if h' : y < x then h\u2083 h' else h\u2082 (le_antisymm (le_of_not_gt h') (le_of_not_gt h))", "start": [406, 1], "end": [409, 89], "kind": "commanddeclaration"}, {"full_name": "le_imp_le_of_lt_imp_lt", "code": "theorem le_imp_le_of_lt_imp_lt {\u03b2} [Preorder \u03b1] [LinearOrder \u03b2] {a b : \u03b1} {c d : \u03b2}\n    (H : d < c \u2192 b < a) (h : a \u2264 b) : c \u2264 d", "start": [412, 1], "end": [414, 47], "kind": "commanddeclaration"}, {"full_name": "compare_lt_iff_lt", "code": "theorem compare_lt_iff_lt {a b : \u03b1} : (compare a b = .lt) \u2194 a < b", "start": [420, 1], "end": [422, 41], "kind": "commanddeclaration"}, {"full_name": "compare_gt_iff_gt", "code": "theorem compare_gt_iff_gt {a b : \u03b1} : (compare a b = .gt) \u2194 a > b", "start": [424, 1], "end": [429, 27], "kind": "commanddeclaration"}, {"full_name": "compare_eq_iff_eq", "code": "theorem compare_eq_iff_eq {a b : \u03b1} : (compare a b = .eq) \u2194 a = b", "start": [431, 1], "end": [436, 40], "kind": "commanddeclaration"}, {"full_name": "compare_le_iff_le", "code": "theorem compare_le_iff_le {a b : \u03b1} : (compare a b \u2260 .gt) \u2194 a \u2264 b", "start": [438, 1], "end": [442, 67], "kind": "commanddeclaration"}, {"full_name": "compare_ge_iff_ge", "code": "theorem compare_ge_iff_ge {a b : \u03b1} : (compare a b \u2260 .lt) \u2194 a \u2265 b", "start": [444, 1], "end": [448, 62], "kind": "commanddeclaration"}, {"full_name": "compare_iff", "code": "theorem compare_iff (a b : \u03b1) {o : Ordering} : compare a b = o \u2194 o.toRel a b", "start": [450, 1], "end": [454, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Core.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/Relation/Trans.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Tactic/Relation/Symm.lean", "lake-packages/std/Std/Tactic/Relation/Rfl.lean", "lake-packages/std/Std/Classes/SetNotation.lean", "lake-packages/std/Std/Classes/Dvd.lean"], "premises": [{"full_name": "Prod.mk.injArrow", "code": "def Prod.mk.injArrow {\u03b1 : Type u} {\u03b2 : Type v} {x\u2081 : \u03b1} {y\u2081 : \u03b2} {x\u2082 : \u03b1} {y\u2082 : \u03b2} :\n    (x\u2081, y\u2081) = (x\u2082, y\u2082) \u2192 \u2200 \u2983P : Sort w\u2984, (x\u2081 = x\u2082 \u2192 y\u2081 = y\u2082 \u2192 P) \u2192 P :=\n  fun h\u2081 _ h\u2082 \u21a6 Prod.noConfusion h\u2081 h\u2082", "start": [69, 1], "end": [71, 39], "kind": "commanddeclaration"}, {"full_name": "PProd.mk.injArrow", "code": "def PProd.mk.injArrow {\u03b1 : Type u} {\u03b2 : Type v} {x\u2081 : \u03b1} {y\u2081 : \u03b2} {x\u2082 : \u03b1} {y\u2082 : \u03b2} :\n    (x\u2081, y\u2081) = (x\u2082, y\u2082) \u2192 \u2200 \u2983P : Sort w\u2984, (x\u2081 = x\u2082 \u2192 y\u2081 = y\u2082 \u2192 P) \u2192 P :=\n  fun h\u2081 _ h\u2082 \u21a6 Prod.noConfusion h\u2081 h\u2082", "start": [73, 1], "end": [75, 39], "kind": "commanddeclaration"}, {"full_name": "AndThen'", "code": "@[deprecated AndThen]\nclass AndThen' (\u03b1 : Type u) (\u03b2 : Type v) (\u03c3 : outParam <| Type w) where\n  andthen : \u03b1 \u2192 \u03b2 \u2192 \u03c3", "start": [133, 1], "end": [135, 22], "kind": "commanddeclaration"}, {"full_name": "Std.Priority.default", "code": "@[deprecated] def Std.Priority.default : Nat := 1000", "start": [162, 1], "end": [162, 53], "kind": "commanddeclaration"}, {"full_name": "Std.Priority.max", "code": "@[deprecated] def Std.Priority.max : Nat := 4294967295", "start": [163, 1], "end": [163, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.prio", "code": "@[deprecated] protected def Nat.prio := Std.Priority.default + 100", "start": [165, 1], "end": [165, 67], "kind": "commanddeclaration"}, {"full_name": "Std.Prec.max", "code": "@[deprecated] def Std.Prec.max : Nat := 1024", "start": [166, 1], "end": [166, 45], "kind": "commanddeclaration"}, {"full_name": "Std.Prec.arrow", "code": "@[deprecated] def Std.Prec.arrow : Nat := 25", "start": [167, 1], "end": [167, 45], "kind": "commanddeclaration"}, {"full_name": "Std.Prec.maxPlus", "code": "@[deprecated] def Std.Prec.maxPlus : Nat := Std.Prec.max + 10", "start": [169, 1], "end": [169, 62], "kind": "commanddeclaration"}, {"full_name": "Combinator.I", "code": "def I (a : \u03b1) := a", "start": [180, 1], "end": [180, 19], "kind": "commanddeclaration"}, {"full_name": "Combinator.K", "code": "def K (a : \u03b1) (_b : \u03b2) := a", "start": [181, 1], "end": [181, 28], "kind": "commanddeclaration"}, {"full_name": "Combinator.S", "code": "def S (x : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (y : \u03b1 \u2192 \u03b2) (z : \u03b1) := x z (y z)", "start": [182, 1], "end": [182, 55], "kind": "commanddeclaration"}, {"full_name": "BinTree", "code": "@[deprecated] inductive BinTree (\u03b1 : Type u)\n  | Empty : BinTree \u03b1\n  | leaf (val : \u03b1) : BinTree \u03b1\n  | node (left right : BinTree \u03b1) : BinTree \u03b1", "start": [186, 1], "end": [189, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Inhabit.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.nonempty_to_inhabited", "code": "noncomputable def nonempty_to_inhabited (\u03b1 : Sort*) (_ : Nonempty \u03b1) : Inhabited \u03b1 :=\n  Inhabited.mk (Classical.ofNonempty)", "start": [18, 1], "end": [20, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.nonempty_prop_to_inhabited", "code": "def nonempty_prop_to_inhabited (\u03b1 : Prop) (\u03b1_nonempty : Nonempty \u03b1) : Inhabited \u03b1 :=\n  Inhabited.mk <| Nonempty.elim \u03b1_nonempty id", "start": [22, 1], "end": [25, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalInhabit", "code": "def evalInhabit (goal : MVarId) (h_name : Option Ident) (term : Syntax) : TacticM MVarId := do\n  goal.withContext do\n    let e \u2190 Tactic.elabTerm term none\n    let e_lvl \u2190 Meta.getLevel e\n    let inhabited_e := mkApp (mkConst ``Inhabited [e_lvl]) e\n    let nonempty_e := mkApp (mkConst ``Nonempty [e_lvl]) e\n    let nonempty_e_pf \u2190 synthInstance nonempty_e\n    let h_name : Name :=\n      match h_name with\n      | some h_name => h_name.getId\n      | none => `inhabited_h\n    let pf \u2190\n      if \u2190 isProp e then Meta.mkAppM ``nonempty_prop_to_inhabited #[e, nonempty_e_pf]\n      else Meta.mkAppM ``nonempty_to_inhabited #[e, nonempty_e_pf]\n    let (_, r) \u2190 (\u2190 goal.assert h_name inhabited_e pf).intro1P\n    return r", "start": [34, 1], "end": [51, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/FunLike/Embedding.lean", "imports": ["Mathlib/Data/FunLike/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EmbeddingLike", "code": "class EmbeddingLike (F : Sort*) (\u03b1 \u03b2 : outParam (Sort*)) extends FunLike F \u03b1 fun _ \u21a6 \u03b2 where\n  \n  injective' : \u2200 f : F, Function.Injective (coe f)", "start": [131, 1], "end": [136, 51], "kind": "commanddeclaration"}, {"full_name": "EmbeddingLike.injective", "code": "protected theorem injective (f : F) : Function.Injective f", "start": [143, 1], "end": [144, 15], "kind": "commanddeclaration"}, {"full_name": "EmbeddingLike.apply_eq_iff_eq", "code": "@[simp]\ntheorem apply_eq_iff_eq (f : F) {x y : \u03b1} : f x = f y \u2194 x = y", "start": [147, 1], "end": [149, 37], "kind": "commanddeclaration"}, {"full_name": "EmbeddingLike.comp_injective", "code": "@[simp]\ntheorem comp_injective {F : Sort*} [EmbeddingLike F \u03b2 \u03b3] (f : \u03b1 \u2192 \u03b2) (e : F) :\n    Function.Injective (e \u2218 f) \u2194 Function.Injective f", "start": [152, 1], "end": [155, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Coe.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.CoeImpl.elabPartiallyAppliedCoe", "code": "def elabPartiallyAppliedCoe (sym : String) (expectedType : Expr)\n    (mkCoe : (expectedType x : Expr) \u2192 TermElabM Expr) : TermElabM Expr := do\n  let expectedType \u2190 instantiateMVars expectedType\n  let Expr.forallE _ a b .. := expectedType | do\n    tryPostpone\n    throwError \"({sym}) must have a function type, not{indentExpr expectedType}\"\n  if b.hasLooseBVars then\n    tryPostpone\n    throwError \"({sym}) must have a non-dependent function type, not{indentExpr expectedType}\"\n  if a.hasExprMVar then tryPostpone\n  let f \u2190 withLocalDeclD `x a fun x \u21a6 do\n    mkLambdaFVars #[x] (\u2190 mkCoe b x)\n  return f.etaExpanded?.getD f", "start": [22, 1], "end": [35, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Bool/Basic.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "xor", "code": "@[inline]\ndef xor : Bool \u2192 Bool \u2192 Bool\n  | true, false => true\n  | false, true => true\n  | _, _ => false", "start": [21, 1], "end": [26, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Quot.lean", "imports": ["Mathlib/Init/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EqvGen", "code": "inductive EqvGen : \u03b1 \u2192 \u03b1 \u2192 Prop\n  | rel : \u2200 x y, r x y \u2192 EqvGen x y\n  | refl : \u2200 x, EqvGen x x\n  | symm : \u2200 x y, EqvGen x y \u2192 EqvGen y x\n  | trans : \u2200 x y z, EqvGen x y \u2192 EqvGen y z \u2192 EqvGen x z", "start": [20, 1], "end": [25, 58], "kind": "commanddeclaration"}, {"full_name": "EqvGen.is_equivalence", "code": "theorem EqvGen.is_equivalence : Equivalence (@EqvGen \u03b1 r)", "start": [28, 1], "end": [29, 68], "kind": "commanddeclaration"}, {"full_name": "EqvGen.Setoid", "code": "def EqvGen.Setoid : Setoid \u03b1 :=\n  Setoid.mk _ (EqvGen.is_equivalence r)", "start": [31, 1], "end": [37, 40], "kind": "commanddeclaration"}, {"full_name": "Quot.exact", "code": "theorem Quot.exact {a b : \u03b1} (H : Quot.mk r a = Quot.mk r b) : EqvGen r a b", "start": [40, 1], "end": [42, 93], "kind": "commanddeclaration"}, {"full_name": "Quot.EqvGen_sound", "code": "theorem Quot.EqvGen_sound {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1} (H : EqvGen r a b) :\n    Quot.mk r a = Quot.mk r b", "start": [45, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.decidableEq", "code": "instance Quotient.decidableEq {\u03b1 : Sort u} {s : Setoid \u03b1} [d : \u2200 a b : \u03b1, Decidable (a \u2248 b)] :\n    DecidableEq (Quotient s) :=\n  \u03bb q\u2081 q\u2082 : Quotient s =>\n    Quotient.recOnSubsingleton\u2082 q\u2081 q\u2082\n      (\u03bb a\u2081 a\u2082 =>\n        match (d a\u2081 a\u2082) with\n        | (isTrue h\u2081)  => isTrue (Quotient.sound h\u2081)\n        | (isFalse h\u2082) => isFalse (\u03bb h => absurd (Quotient.exact h) h\u2082))", "start": [58, 1], "end": [65, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Relator.lean", "imports": ["Mathlib/Logic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Relator.LiftFun", "code": "def LiftFun (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) : Prop :=\n  \u2200\u2983a b\u2984, R a b \u2192 S (f a) (g b)", "start": [33, 1], "end": [36, 32], "kind": "commanddeclaration"}, {"full_name": "Relator.RightTotal", "code": "def RightTotal : Prop := \u2200 b, \u2203 a, R a b", "start": [48, 1], "end": [49, 41], "kind": "commanddeclaration"}, {"full_name": "Relator.LeftTotal", "code": "def LeftTotal : Prop := \u2200 a, \u2203 b, R a b", "start": [52, 1], "end": [53, 40], "kind": "commanddeclaration"}, {"full_name": "Relator.BiTotal", "code": "def BiTotal : Prop := LeftTotal R \u2227 RightTotal R", "start": [56, 1], "end": [57, 49], "kind": "commanddeclaration"}, {"full_name": "Relator.LeftUnique", "code": "def LeftUnique : Prop := \u2200 \u2983a b c\u2984, R a c \u2192 R b c \u2192 a = b", "start": [60, 1], "end": [62, 58], "kind": "commanddeclaration"}, {"full_name": "Relator.RightUnique", "code": "def RightUnique : Prop := \u2200 \u2983a b c\u2984, R a b \u2192 R a c \u2192 b = c", "start": [65, 1], "end": [67, 59], "kind": "commanddeclaration"}, {"full_name": "Relator.BiUnique", "code": "def BiUnique : Prop := LeftUnique R \u2227 RightUnique R", "start": [70, 1], "end": [71, 52], "kind": "commanddeclaration"}, {"full_name": "Relator.RightTotal.rel_forall", "code": "lemma RightTotal.rel_forall (h : RightTotal R) :\n    ((R \u21d2 (\u00b7 \u2192 \u00b7)) \u21d2 (\u00b7 \u2192 \u00b7)) (fun p => \u2200i, p i) (fun q => \u2200i, q i) :=\n  fun _ _ Hrel H b => Exists.elim (h b) (fun _ Rab => Hrel Rab (H _))", "start": [76, 1], "end": [78, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.LeftTotal.rel_exists", "code": "lemma LeftTotal.rel_exists (h : LeftTotal R) :\n    ((R \u21d2 (\u00b7 \u2192 \u00b7)) \u21d2 (\u00b7 \u2192 \u00b7)) (fun p => \u2203i, p i) (fun q => \u2203i, q i) :=\n  fun _ _ Hrel \u27e8a, pa\u27e9 => (h a).imp $ fun _ Rab => Hrel Rab pa", "start": [81, 1], "end": [83, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.BiTotal.rel_forall", "code": "lemma BiTotal.rel_forall (h : BiTotal R) :\n    ((R \u21d2 Iff) \u21d2 Iff) (fun p => \u2200i, p i) (fun q => \u2200i, q i) :=\n  fun _ _ Hrel =>\n    \u27e8fun H b => Exists.elim (h.right b) (fun _ Rab => (Hrel Rab).mp (H _)),\n      fun H a => Exists.elim (h.left a) (fun _ Rab => (Hrel Rab).mpr (H _))\u27e9", "start": [86, 1], "end": [90, 77], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.BiTotal.rel_exists", "code": "lemma BiTotal.rel_exists (h : BiTotal R) :\n    ((R \u21d2 Iff) \u21d2 Iff) (fun p => \u2203i, p i) (fun q => \u2203i, q i) :=\n  fun _ _ Hrel =>\n    \u27e8fun \u27e8a, pa\u27e9 => (h.left a).imp $ fun _ Rab => (Hrel Rab).1 pa,\n      fun \u27e8b, qb\u27e9 => (h.right b).imp $ fun _ Rab => (Hrel Rab).2 qb\u27e9", "start": [93, 1], "end": [97, 69], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.left_unique_of_rel_eq", "code": "lemma left_unique_of_rel_eq {eq' : \u03b2 \u2192 \u03b2 \u2192 Prop} (he : (R \u21d2 (R \u21d2 Iff)) Eq eq') : LeftUnique R :=\n  fun a b c (ac : R a c) (bc : R b c) => (he ac bc).mpr ((he bc bc).mp rfl)", "start": [100, 1], "end": [101, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.rel_imp", "code": "lemma rel_imp : (Iff \u21d2 (Iff \u21d2 Iff)) (\u00b7 \u2192 \u00b7) (\u00b7 \u2192 \u00b7) :=\n  fun _ _ h _ _ l => imp_congr h l", "start": [106, 1], "end": [107, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.rel_not", "code": "lemma rel_not : (Iff \u21d2 Iff) Not Not :=\n  fun _ _ h => not_congr h", "start": [110, 1], "end": [111, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.bi_total_eq", "code": "lemma bi_total_eq {\u03b1 : Type u\u2081} : Relator.BiTotal (@Eq \u03b1) :=\n  { left := fun a => \u27e8a, rfl\u27e9, right := fun a => \u27e8a, rfl\u27e9 }", "start": [114, 1], "end": [115, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.LeftUnique.flip", "code": "lemma LeftUnique.flip (h : LeftUnique r) : RightUnique (flip r) :=\n  fun _ _ _ h\u2081 h\u2082 => h h\u2081 h\u2082", "start": [121, 1], "end": [122, 29], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.rel_and", "code": "lemma rel_and : ((\u00b7\u2194\u00b7) \u21d2 (\u00b7\u2194\u00b7) \u21d2 (\u00b7\u2194\u00b7)) (\u00b7\u2227\u00b7) (\u00b7\u2227\u00b7) :=\n  fun _ _ h\u2081 _ _ h\u2082 => and_congr h\u2081 h\u2082", "start": [125, 1], "end": [126, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.rel_or", "code": "lemma rel_or : ((\u00b7\u2194\u00b7) \u21d2 (\u00b7\u2194\u00b7) \u21d2 (\u00b7\u2194\u00b7)) (\u00b7\u2228\u00b7) (\u00b7\u2228\u00b7) :=\n  fun _ _ h\u2081 _ _ h\u2082 => or_congr h\u2081 h\u2082", "start": [129, 1], "end": [130, 38], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.rel_iff", "code": "lemma rel_iff : ((\u00b7\u2194\u00b7) \u21d2 (\u00b7\u2194\u00b7) \u21d2 (\u00b7\u2194\u00b7)) (\u00b7\u2194\u00b7) (\u00b7\u2194\u00b7) :=\n  fun _ _ h\u2081 _ _ h\u2082 => iff_congr h\u2081 h\u2082", "start": [133, 1], "end": [134, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.rel_eq", "code": "lemma rel_eq {r : \u03b1 \u2192 \u03b2 \u2192 Prop} (hr : BiUnique r) : (r \u21d2 r \u21d2 (\u00b7\u2194\u00b7)) (\u00b7=\u00b7) (\u00b7=\u00b7) :=\n  fun _ _ h\u2081 _ _ h\u2082 => \u27e8fun h => hr.right h\u2081 $ h.symm \u25b8 h\u2082, fun h => hr.left h\u2081 $ h.symm \u25b8 h\u2082\u27e9", "start": [137, 1], "end": [138, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.LeftTotal.refl", "code": "protected lemma refl (hr : \u2200 a : \u03b1, r\u2081\u2081 a a) :\n    LeftTotal r\u2081\u2081 :=\n  fun a \u21a6 \u27e8a, hr _\u27e9", "start": [145, 1], "end": [147, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.LeftTotal.symm", "code": "protected lemma symm (hr : \u2200 (a : \u03b1) (b : \u03b2), r\u2081\u2082 a b \u2192 r\u2082\u2081 b a) :\n    LeftTotal r\u2081\u2082 \u2192 RightTotal r\u2082\u2081 :=\n  fun h a \u21a6 (h a).imp (fun _ \u21a6 hr _ _)", "start": [149, 1], "end": [151, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.LeftTotal.trans", "code": "protected lemma trans (hr : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), r\u2081\u2082 a b \u2192 r\u2082\u2083 b c \u2192 r\u2081\u2083 a c) :\n    LeftTotal r\u2081\u2082 \u2192 LeftTotal r\u2082\u2083 \u2192 LeftTotal r\u2081\u2083 :=\n  fun h\u2081 h\u2082 a \u21a6 let \u27e8b, hab\u27e9 := h\u2081 a; let \u27e8c, hbc\u27e9 := h\u2082 b; \u27e8c, hr _ _ _ hab hbc\u27e9", "start": [153, 1], "end": [155, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.RightTotal.refl", "code": "protected lemma refl (hr : \u2200 a : \u03b1, r\u2081\u2081 a a) :\n    RightTotal r\u2081\u2081 :=\n  LeftTotal.refl hr", "start": [161, 1], "end": [163, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.RightTotal.symm", "code": "protected lemma symm (hr : \u2200 (a : \u03b1) (b : \u03b2), r\u2081\u2082 a b \u2192 r\u2082\u2081 b a) :\n    RightTotal r\u2081\u2082 \u2192 LeftTotal r\u2082\u2081 :=\n  LeftTotal.symm (fun _ _ \u21a6 hr _ _)", "start": [165, 1], "end": [167, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.RightTotal.trans", "code": "protected lemma trans (hr : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), r\u2081\u2082 a b \u2192 r\u2082\u2083 b c \u2192 r\u2081\u2083 a c) :\n    RightTotal r\u2081\u2082 \u2192 RightTotal r\u2082\u2083 \u2192 RightTotal r\u2081\u2083 :=\n  swap <| LeftTotal.trans (fun _ _ _ \u21a6 swap <| hr _ _ _)", "start": [169, 1], "end": [171, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.BiTotal.refl", "code": "protected lemma refl (hr : \u2200 a : \u03b1, r\u2081\u2081 a a) :\n    BiTotal r\u2081\u2081 :=\n  \u27e8LeftTotal.refl hr, RightTotal.refl hr\u27e9", "start": [177, 1], "end": [179, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.BiTotal.symm", "code": "protected lemma symm (hr : \u2200 (a : \u03b1) (b : \u03b2), r\u2081\u2082 a b \u2192 r\u2082\u2081 b a) :\n    BiTotal r\u2081\u2082 \u2192 BiTotal r\u2082\u2081 :=\n  fun h \u21a6 \u27e8h.2.symm hr, h.1.symm hr\u27e9", "start": [181, 1], "end": [183, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Relator.BiTotal.trans", "code": "protected lemma trans (hr : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), r\u2081\u2082 a b \u2192 r\u2082\u2083 b c \u2192 r\u2081\u2083 a c) :\n    BiTotal r\u2081\u2082 \u2192 BiTotal r\u2082\u2083 \u2192 BiTotal r\u2081\u2083 :=\n  fun h\u2081 h\u2082 \u21a6 \u27e8h\u2081.1.trans hr h\u2082.1, h\u2081.2.trans hr h\u2082.2\u27e9", "start": [185, 1], "end": [187, 55], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Logic/IsEmpty.lean", "imports": ["Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsEmpty", "code": "class IsEmpty (\u03b1 : Sort*) : Prop where\n  protected false : \u03b1 \u2192 False", "start": [25, 1], "end": [27, 30], "kind": "commanddeclaration"}, {"full_name": "instIsEmptyEmpty", "code": "instance instIsEmptyEmpty : IsEmpty Empty :=\n  \u27e8Empty.elim\u27e9", "start": [30, 1], "end": [31, 15], "kind": "commanddeclaration"}, {"full_name": "instIsEmptyPEmpty", "code": "instance instIsEmptyPEmpty : IsEmpty PEmpty :=\n  \u27e8PEmpty.elim\u27e9", "start": [33, 1], "end": [34, 16], "kind": "commanddeclaration"}, {"full_name": "Fin.isEmpty", "code": "instance Fin.isEmpty : IsEmpty (Fin 0) :=\n  \u27e8fun n \u21a6 Nat.not_lt_zero n.1 n.2\u27e9", "start": [39, 1], "end": [40, 36], "kind": "commanddeclaration"}, {"full_name": "Fin.isEmpty'", "code": "instance Fin.isEmpty' : IsEmpty (Fin Nat.zero) :=\n  Fin.isEmpty", "start": [42, 1], "end": [43, 14], "kind": "commanddeclaration"}, {"full_name": "Function.isEmpty", "code": "protected theorem Function.isEmpty [IsEmpty \u03b2] (f : \u03b1 \u2192 \u03b2) : IsEmpty \u03b1", "start": [45, 1], "end": [46, 32], "kind": "commanddeclaration"}, {"full_name": "PProd.isEmpty_left", "code": "instance PProd.isEmpty_left [IsEmpty \u03b1] : IsEmpty (PProd \u03b1 \u03b2) :=\n  Function.isEmpty PProd.fst", "start": [52, 1], "end": [53, 29], "kind": "commanddeclaration"}, {"full_name": "PProd.isEmpty_right", "code": "instance PProd.isEmpty_right [IsEmpty \u03b2] : IsEmpty (PProd \u03b1 \u03b2) :=\n  Function.isEmpty PProd.snd", "start": [55, 1], "end": [56, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.isEmpty_left", "code": "instance Prod.isEmpty_left {\u03b1 \u03b2} [IsEmpty \u03b1] : IsEmpty (\u03b1 \u00d7 \u03b2) :=\n  Function.isEmpty Prod.fst", "start": [58, 1], "end": [59, 28], "kind": "commanddeclaration"}, {"full_name": "Prod.isEmpty_right", "code": "instance Prod.isEmpty_right {\u03b1 \u03b2} [IsEmpty \u03b2] : IsEmpty (\u03b1 \u00d7 \u03b2) :=\n  Function.isEmpty Prod.snd", "start": [61, 1], "end": [62, 28], "kind": "commanddeclaration"}, {"full_name": "instIsEmptySum", "code": "instance instIsEmptySum {\u03b1 \u03b2} [IsEmpty \u03b1] [IsEmpty \u03b2] : IsEmpty (Sum \u03b1 \u03b2) :=\n  \u27e8fun x \u21a6 Sum.rec IsEmpty.false IsEmpty.false x\u27e9", "start": [67, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "Subtype.isEmpty_of_false", "code": "theorem Subtype.isEmpty_of_false {p : \u03b1 \u2192 Prop} (hp : \u2200 a, \u00acp a) : IsEmpty (Subtype p)", "start": [74, 1], "end": [76, 21], "kind": "commanddeclaration"}, {"full_name": "Subtype.isEmpty_false", "code": "instance Subtype.isEmpty_false : IsEmpty { _a : \u03b1 // False } :=\n  Subtype.isEmpty_of_false fun _ \u21a6 id", "start": [79, 1], "end": [81, 38], "kind": "commanddeclaration"}, {"full_name": "Sigma.isEmpty_left", "code": "instance Sigma.isEmpty_left {\u03b1} [IsEmpty \u03b1] {E : \u03b1 \u2192 Type*} : IsEmpty (Sigma E) :=\n  Function.isEmpty Sigma.fst", "start": [83, 1], "end": [84, 29], "kind": "commanddeclaration"}, {"full_name": "isEmptyElim", "code": "@[elab_as_elim]\ndef isEmptyElim [IsEmpty \u03b1] {p : \u03b1 \u2192 Sort*} (a : \u03b1) : p a :=\n  (IsEmpty.false a).elim", "start": [88, 1], "end": [91, 25], "kind": "commanddeclaration"}, {"full_name": "isEmpty_iff", "code": "theorem isEmpty_iff : IsEmpty \u03b1 \u2194 \u03b1 \u2192 False", "start": [94, 1], "end": [95, 33], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.elim", "code": "@[elab_as_elim]\nprotected def elim {\u03b1 : Sort u} (_ : IsEmpty \u03b1) {p : \u03b1 \u2192 Sort*} (a : \u03b1) : p a :=\n  isEmptyElim a", "start": [102, 1], "end": [105, 16], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.elim'", "code": "protected def elim' {\u03b2 : Sort*} (h : IsEmpty \u03b1) (a : \u03b1) : \u03b2 :=\n  (h.false a).elim", "start": [108, 1], "end": [111, 19], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.prop_iff", "code": "protected theorem prop_iff {p : Prop} : IsEmpty p \u2194 \u00acp", "start": [114, 1], "end": [115, 14], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.forall_iff", "code": "@[simp]\ntheorem forall_iff {p : \u03b1 \u2192 Prop} : (\u2200 a, p a) \u2194 True", "start": [120, 1], "end": [122, 29], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.exists_iff", "code": "@[simp]\ntheorem exists_iff {p : \u03b1 \u2192 Prop} : (\u2203 a, p a) \u2194 False", "start": [125, 1], "end": [127, 47], "kind": "commanddeclaration"}, {"full_name": "not_nonempty_iff", "code": "@[simp]\ntheorem not_nonempty_iff : \u00acNonempty \u03b1 \u2194 IsEmpty \u03b1", "start": [136, 1], "end": [138, 57], "kind": "commanddeclaration"}, {"full_name": "not_isEmpty_iff", "code": "@[simp]\ntheorem not_isEmpty_iff : \u00acIsEmpty \u03b1 \u2194 Nonempty \u03b1", "start": [141, 1], "end": [143, 35], "kind": "commanddeclaration"}, {"full_name": "isEmpty_Prop", "code": "@[simp]\ntheorem isEmpty_Prop {p : Prop} : IsEmpty p \u2194 \u00acp", "start": [146, 1], "end": [148, 48], "kind": "commanddeclaration"}, {"full_name": "isEmpty_pi", "code": "@[simp]\ntheorem isEmpty_pi {\u03c0 : \u03b1 \u2192 Sort*} : IsEmpty (\u2200 a, \u03c0 a) \u2194 \u2203 a, IsEmpty (\u03c0 a)", "start": [151, 1], "end": [153, 68], "kind": "commanddeclaration"}, {"full_name": "isEmpty_sigma", "code": "@[simp]\ntheorem isEmpty_sigma {\u03b1} {E : \u03b1 \u2192 Type*} : IsEmpty (Sigma E) \u2194 \u2200 a, IsEmpty (E a)", "start": [156, 1], "end": [158, 61], "kind": "commanddeclaration"}, {"full_name": "isEmpty_psigma", "code": "@[simp]\ntheorem isEmpty_psigma {\u03b1} {E : \u03b1 \u2192 Sort*} : IsEmpty (PSigma E) \u2194 \u2200 a, IsEmpty (E a)", "start": [161, 1], "end": [163, 62], "kind": "commanddeclaration"}, {"full_name": "isEmpty_subtype", "code": "@[simp]\ntheorem isEmpty_subtype (p : \u03b1 \u2192 Prop) : IsEmpty (Subtype p) \u2194 \u2200 x, \u00acp x", "start": [166, 1], "end": [168, 63], "kind": "commanddeclaration"}, {"full_name": "isEmpty_prod", "code": "@[simp]\ntheorem isEmpty_prod {\u03b1 \u03b2 : Type*} : IsEmpty (\u03b1 \u00d7 \u03b2) \u2194 IsEmpty \u03b1 \u2228 IsEmpty \u03b2", "start": [171, 1], "end": [173, 60], "kind": "commanddeclaration"}, {"full_name": "isEmpty_pprod", "code": "@[simp]\ntheorem isEmpty_pprod : IsEmpty (PProd \u03b1 \u03b2) \u2194 IsEmpty \u03b1 \u2228 IsEmpty \u03b2", "start": [176, 1], "end": [178, 61], "kind": "commanddeclaration"}, {"full_name": "isEmpty_sum", "code": "@[simp]\ntheorem isEmpty_sum {\u03b1 \u03b2} : IsEmpty (Sum \u03b1 \u03b2) \u2194 IsEmpty \u03b1 \u2227 IsEmpty \u03b2", "start": [181, 1], "end": [183, 55], "kind": "commanddeclaration"}, {"full_name": "isEmpty_psum", "code": "@[simp]\ntheorem isEmpty_psum {\u03b1 \u03b2} : IsEmpty (PSum \u03b1 \u03b2) \u2194 IsEmpty \u03b1 \u2227 IsEmpty \u03b2", "start": [186, 1], "end": [188, 56], "kind": "commanddeclaration"}, {"full_name": "isEmpty_ulift", "code": "@[simp]\ntheorem isEmpty_ulift {\u03b1} : IsEmpty (ULift \u03b1) \u2194 IsEmpty \u03b1", "start": [191, 1], "end": [193, 49], "kind": "commanddeclaration"}, {"full_name": "isEmpty_plift", "code": "@[simp]\ntheorem isEmpty_plift {\u03b1} : IsEmpty (PLift \u03b1) \u2194 IsEmpty \u03b1", "start": [196, 1], "end": [198, 49], "kind": "commanddeclaration"}, {"full_name": "wellFounded_of_isEmpty", "code": "theorem wellFounded_of_isEmpty {\u03b1} [IsEmpty \u03b1] (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : WellFounded r", "start": [201, 1], "end": [202, 16], "kind": "commanddeclaration"}, {"full_name": "isEmpty_or_nonempty", "code": "theorem isEmpty_or_nonempty : IsEmpty \u03b1 \u2228 Nonempty \u03b1", "start": [207, 1], "end": [208, 63], "kind": "commanddeclaration"}, {"full_name": "not_isEmpty_of_nonempty", "code": "@[simp]\ntheorem not_isEmpty_of_nonempty [h : Nonempty \u03b1] : \u00acIsEmpty \u03b1", "start": [211, 1], "end": [213, 24], "kind": "commanddeclaration"}, {"full_name": "Function.extend_of_isEmpty", "code": "theorem Function.extend_of_isEmpty [IsEmpty \u03b1] (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) (h : \u03b2 \u2192 \u03b3) :\n    Function.extend f g h = h", "start": [218, 1], "end": [220, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Fin/Basic.lean", "imports": ["Mathlib/Init/Data/Nat/Notation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fin.eq_of_veq", "code": "theorem eq_of_veq : \u2200 {i j : Fin n}, i.val = j.val \u2192 i = j", "start": [16, 1], "end": [17, 49], "kind": "commanddeclaration"}, {"full_name": "Fin.veq_of_eq", "code": "theorem veq_of_eq : \u2200 {i j : Fin n}, i = j \u2192 i.val = j.val", "start": [19, 1], "end": [20, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.ne_of_vne", "code": "theorem ne_of_vne {i j : Fin n} (h : i.val \u2260 j.val) : i \u2260 j", "start": [22, 1], "end": [22, 96], "kind": "commanddeclaration"}, {"full_name": "Fin.vne_of_ne", "code": "theorem vne_of_ne {i j : Fin n} (h : i \u2260 j) : i.val \u2260 j.val", "start": [24, 1], "end": [24, 96], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Search/Expansion/Norm.lean", "imports": ["lake-packages/aesop/Aesop/Search/RuleSelection.lean", "lake-packages/aesop/Aesop/Search/Expansion/Simp.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/RuleTac.lean", "lake-packages/aesop/Aesop/Search/SearchM.lean", "lake-packages/aesop/Aesop/Search/Expansion/Basic.lean"], "premises": [{"full_name": "Aesop.NormRuleResult", "code": "inductive NormRuleResult\n  | succeeded (goal : MVarId)\n      (scriptStep? : Except DisplayRuleName TacticInvocation)\n  | proved (scriptStep? : Except DisplayRuleName TacticInvocation)\n  | failed (scriptStep? : Option TacticInvocation)", "start": [18, 1], "end": [22, 51], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormRuleResult.isSuccessful", "code": "def isSuccessful : NormRuleResult \u2192 Bool\n  | succeeded .. | proved .. => true\n  | failed .. => false", "start": [27, 1], "end": [29, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormRuleResult.newGoal?", "code": "def newGoal? : NormRuleResult \u2192 Option MVarId\n  | succeeded goal .. => goal\n  | proved .. | failed .. => none", "start": [31, 1], "end": [33, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormRuleResult.toEmoji", "code": "def toEmoji : NormRuleResult \u2192 String\n  | succeeded .. => ruleSuccessEmoji\n  | proved .. => ruleProvedEmoji\n  | failed .. => ruleFailureEmoji", "start": [35, 1], "end": [38, 34], "kind": "commanddeclaration"}, {"full_name": "Aesop.withNormTraceNode", "code": "@[inline, always_inline]\ndef withNormTraceNode (ruleName : DisplayRuleName) (k : MetaM NormRuleResult) :\n    MetaM NormRuleResult :=\n  withAesopTraceNode .steps fmt do\n    let result \u2190 k\n    if let some newGoal := result.newGoal? then\n      aesop_trace[steps] newGoal\n    return result\n  where\n    fmt (r : Except Exception NormRuleResult) : MetaM MessageData := do\n      let emoji := exceptRuleResultToEmoji (\u00b7.toEmoji) r\n      return m!\"{emoji} {ruleName}\"", "start": [42, 1], "end": [53, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkNormRuleTacticInvocation", "code": "def mkNormRuleTacticInvocation (ruleName : RuleName)\n    (scriptBuilder? : Option RuleTacScriptBuilder)\n    (preGoal : MVarId) (outGoal? : Option GoalWithMVars)\n    (preState postState : Meta.SavedState) :\n    MetaM (Except DisplayRuleName TacticInvocation) := do\n  let (some scriptBuilder) := scriptBuilder?\n    | return .error $ .ruleName ruleName\n  try\n    let tacticSeq \u2190 scriptBuilder.unstructured.run\n    let postGoals := outGoal?.toArray\n    return .ok { tacticSeq, preGoal, postGoals, preState, postState }\n  catch e =>\n    throwError \"aesop: error while running script builder for rule {ruleName}:{indentD e.toMessageData}\"", "start": [55, 1], "end": [67, 105], "kind": "commanddeclaration"}, {"full_name": "Aesop.runNormRuleTac", "code": "def runNormRuleTac (rule : NormRule) (input : RuleTacInput) :\n    MetaM NormRuleResult := do\n  let preMetaState \u2190 saveState\n  let result? \u2190 runRuleTac rule.tac.run rule.name preMetaState input\n  match result? with\n  | Sum.inl e =>\n    aesop_trace[steps] e.toMessageData\n    return .failed none\n  | Sum.inr result =>\n    let #[rapp] := result.applications\n      | err m!\"rule did not produce exactly one rule application.\"\n    restoreState rapp.postState\n    if rapp.goals.isEmpty then\n      let step? \u2190\n        mkNormRuleTacticInvocation rule.name rapp.scriptBuilder? input.goal none\n          preMetaState rapp.postState\n      return .proved step?\n    let (#[g]) := rapp.goals\n      | err m!\"rule produced more than one subgoal.\"\n    let mvars := .ofArray input.mvars.toArray\n    if \u2190 Check.rules.isEnabled then\n      let actualMVars \u2190 rapp.postState.runMetaM' g.getMVarDependencies\n      if ! actualMVars == mvars then\n         err \"the goal produced by the rule depends on different metavariables than the original goal.\"\n    let step? \u2190\n      mkNormRuleTacticInvocation rule.name rapp.scriptBuilder? input.goal\n        (some \u27e8g, mvars\u27e9) preMetaState rapp.postState\n    return .succeeded g step?\n  where\n    err {\u03b1} (msg : MessageData) : MetaM \u03b1 := throwError\n      \"aesop: error while running norm rule {rule.name}: {msg}\\nThe rule was run on this goal:{indentD $ MessageData.ofGoal input.goal}\"", "start": [69, 1], "end": [99, 137], "kind": "commanddeclaration"}, {"full_name": "Aesop.runNormRuleCore", "code": "def runNormRuleCore (goal : MVarId) (mvars : UnorderedArraySet MVarId)\n    (options : Options') (rule : IndexMatchResult NormRule) :\n    MetaM NormRuleResult := do\n  let ruleInput := {\n    indexMatchLocations := rule.locations\n    goal, mvars, options\n  }\n  withNormTraceNode (.ruleName rule.rule.name) do\n    runNormRuleTac rule.rule ruleInput", "start": [101, 1], "end": [109, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.runNormRule", "code": "def runNormRule (goal : MVarId) (mvars : UnorderedArraySet MVarId)\n    (options : Options') (rule : IndexMatchResult NormRule) :\n    ProfileT MetaM NormRuleResult :=\n  profiling (runNormRuleCore goal mvars options rule) \u03bb result elapsed =>\n    recordRuleProfile {\n      elapsed,\n      successful := result.isSuccessful\n      rule := .ruleName rule.rule.name\n    }", "start": [111, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "Aesop.runFirstNormRule", "code": "def runFirstNormRule (goal : MVarId) (mvars : UnorderedArraySet MVarId)\n    (options : Options') (rules : Array (IndexMatchResult NormRule)) :\n    ProfileT MetaM NormRuleResult := do\n  for rule in rules do\n    let result \u2190 runNormRule goal mvars options rule\n    if result.isSuccessful then\n      return result\n  return .failed none", "start": [121, 1], "end": [128, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.mkNormSimpScriptStep", "code": "def mkNormSimpScriptStep (ctx : NormSimpContext)\n    (preGoal : MVarId) (postGoal? : Option GoalWithMVars)\n    (preState postState : Meta.SavedState) (usedTheorems : Simp.UsedSimps) :\n    MetaM TacticInvocation := do\n  let tactic \u2190\n    mkNormSimpOnlySyntax preGoal ctx.useHyps ctx.configStx? usedTheorems\n  return {\n    tacticSeq := #[tactic]\n    postGoals := postGoal?.toArray\n    preGoal, preState, postState\n  }", "start": [130, 1], "end": [140, 4], "kind": "commanddeclaration"}, {"full_name": "Aesop.SimpResult.toNormRuleResult", "code": "def SimpResult.toNormRuleResult (ruleName : DisplayRuleName)\n    (ctx : NormSimpContext) (originalGoal : GoalWithMVars)\n    (preState postState : Meta.SavedState) (generateScript : Bool) :\n    SimpResult \u2192 MetaM NormRuleResult\n  | .unchanged newGoal => do\n    let scriptStep? :=\n      if generateScript then\n        some $ .noop originalGoal.goal \u27e8newGoal, originalGoal.mvars\u27e9 preState\n                 postState\n      else\n        none\n    return .failed scriptStep?\n  | .solved usedTheorems => do\n    let scriptStep? \u2190 mkScriptStep? none usedTheorems\n    return .proved scriptStep?\n  | .simplified newGoal usedTheorems => do\n    let scriptStep? \u2190 mkScriptStep? (some newGoal) usedTheorems\n    return .succeeded newGoal scriptStep?\n  where\n    @[inline, always_inline]\n    mkScriptStep? (newGoal? : Option MVarId) (usedTheorems : Simp.UsedSimps) :\n        MetaM (Except DisplayRuleName TacticInvocation) := do\n      if generateScript then\n        let newGoal? := newGoal?.map (\u27e8\u00b7, originalGoal.mvars\u27e9)\n        .ok <$> mkNormSimpScriptStep ctx originalGoal.goal newGoal? preState\n                  postState usedTheorems\n      else\n        return .error ruleName", "start": [142, 1], "end": [169, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.normSimpCore", "code": "def normSimpCore (ctx : NormSimpContext)\n    (localSimpRules : Array LocalNormSimpRule) (goal : MVarId)\n    (goalMVars : HashSet MVarId) (generateScript : Bool) :\n    MetaM NormRuleResult := do\n  goal.withContext do\n    let preState \u2190 saveState\n    let result \u2190\n      if ctx.useHyps then\n        Aesop.simpAll goal ctx.toContext\n      else\n        let lctx \u2190 getLCtx\n        let mut simpTheorems := ctx.simpTheorems\n        for localRule in localSimpRules do\n          let (some ldecl) := lctx.findFromUserName? localRule.fvarUserName\n            | continue\n          let (some simpTheorems') \u2190 observing? $\n            simpTheorems.addTheorem (.fvar ldecl.fvarId) ldecl.toExpr\n            | continue\n          simpTheorems := simpTheorems'\n        let ctx := { ctx with simpTheorems }\n        Aesop.simpGoalWithAllHypotheses goal ctx\n\n    let result \u2190\n      match result with\n      | .solved .. =>\n        let anyMVarDropped \u2190 goalMVars.anyM (notM \u00b7.isAssignedOrDelayedAssigned)\n        if anyMVarDropped then\n          aesop_trace[steps] \"Normalisation simp solved the goal but dropped some metavariables. Skipping normalisation simp.\"\n          restoreState preState\n          pure $ .unchanged goal\n        else\n          pure result\n      | .simplified .. =>\n        pure result\n      | .unchanged .. =>\n        aesop_trace[steps] \"norm simp left the goal unchanged\"\n        pure result\n\n    let postState \u2190 saveState\n\n    result.toNormRuleResult .normSimp ctx \u27e8goal, goalMVars\u27e9 preState postState\n      generateScript", "start": [171, 1], "end": [214, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.checkSimp", "code": "@[inline, always_inline]\ndef checkSimp (name : String) (mayCloseGoal : Bool) (goal : MVarId)\n    (x : MetaM NormRuleResult) : MetaM NormRuleResult := do\n  if ! (\u2190 Check.rules.isEnabled) then\n    x\n  else\n    let preMetaState \u2190 saveState\n    let result \u2190 x\n    let newGoal? := result.newGoal?\n    let postMetaState \u2190 saveState\n    let introduced :=\n        (\u2190 getIntroducedExprMVars preMetaState postMetaState).filter\n        (some \u00b7 != newGoal?)\n    unless introduced.isEmpty do throwError\n        \"{Check.rules.name}: {name} introduced mvars:{introduced.map (\u00b7.name)}\"\n    let assigned :=\n        (\u2190 getAssignedExprMVars preMetaState postMetaState).filter (\u00b7 != goal)\n    unless assigned.isEmpty do throwError\n        \"{Check.rules.name}: {name} assigned mvars:{introduced.map (\u00b7.name)}\"\n    if \u2190 pure (! mayCloseGoal && newGoal?.isNone) <&&> goal.isAssigned then\n        throwError \"{Check.rules.name}: {name} solved the goal\"\n    return result", "start": [216, 1], "end": [237, 18], "kind": "commanddeclaration"}, {"full_name": "Aesop.checkedNormSimpCore", "code": "def checkedNormSimpCore (ctx : NormSimpContext)\n    (localSimpRules : Array LocalNormSimpRule) (goal : MVarId)\n    (goalMVars : HashSet MVarId) (generateScript : Bool) :\n    MetaM NormRuleResult :=\n  checkSimp \"norm simp\" (mayCloseGoal := true) goal do\n    try\n      withNormTraceNode .normSimp do\n        normSimpCore ctx localSimpRules goal goalMVars generateScript\n    catch e =>\n      throwError \"aesop: error in norm simp: {e.toMessageData}\"", "start": [239, 1], "end": [248, 64], "kind": "commanddeclaration"}, {"full_name": "Aesop.normSimp", "code": "def normSimp (ctx : NormSimpContext) (localSimpRules : Array LocalNormSimpRule)\n    (goal : MVarId) (goalMVars : HashSet MVarId) (generateScript : Bool) :\n    ProfileT MetaM NormRuleResult :=\n  profiling\n    (checkedNormSimpCore ctx localSimpRules goal goalMVars generateScript)\n    \u03bb _ elapsed => recordRuleProfile\n      { rule := .normSimp, elapsed, successful := true }", "start": [250, 1], "end": [256, 57], "kind": "commanddeclaration"}, {"full_name": "Aesop.normUnfoldCore", "code": "def normUnfoldCore (unfoldRules : PHashMap Name (Option Name))\n    (goal : MVarId) (goalMVars : HashSet MVarId) (generateScript : Bool) :\n    MetaM NormRuleResult := do\n  let preState \u2190 saveState\n  let (result, scriptBuilder?) \u2190\n    unfoldManyStarWithScript goal (unfoldRules.find? \u00b7) generateScript\n  let postState \u2190 saveState\n  match result with\n  | .unchanged =>\n    aesop_trace[steps] \"nothing to unfold\"\n    return .failed none\n  | .changed newGoal _ =>\n    let scriptStep? \u2190 do\n      match scriptBuilder? with\n      | some unfoldScriptBuilder =>\n        pure $ .ok {\n          tacticSeq := \u2190 unfoldScriptBuilder.unstructured.run\n          preGoal := goal\n          postGoals := #[\u27e8newGoal, goalMVars\u27e9]\n          preState, postState\n        }\n      | none => pure $ .error .normUnfold\n    return .succeeded newGoal scriptStep?", "start": [258, 1], "end": [280, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.checkedNormUnfoldCore", "code": "def checkedNormUnfoldCore (unfoldRules : PHashMap Name (Option Name))\n    (goal : MVarId) (goalMVars : HashSet MVarId) (generateScript : Bool) :\n    MetaM NormRuleResult := do\n  checkSimp \"unfold simp\" (mayCloseGoal := false) goal do\n    try\n      withNormTraceNode .normUnfold do\n        normUnfoldCore unfoldRules goal goalMVars generateScript\n    catch e =>\n      throwError \"aesop: error in norm unfold: {e.toMessageData}\"", "start": [282, 1], "end": [290, 66], "kind": "commanddeclaration"}, {"full_name": "Aesop.normUnfold", "code": "def normUnfold (unfoldRules : PHashMap Name (Option Name))\n    (goal : MVarId) (goalMVars : HashSet MVarId) (generateScript : Bool) :\n    ProfileT MetaM NormRuleResult :=\n  profiling (checkedNormUnfoldCore unfoldRules goal goalMVars generateScript)\n    \u03bb _ elapsed => recordRuleProfile\n      { rule := .normUnfold, elapsed, successful := true }", "start": [292, 1], "end": [297, 59], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormSeqResult", "code": "inductive NormSeqResult where\n  | proved (script? : Except DisplayRuleName UnstructuredScript)\n  | unproved (goal : MVarId)\n      (script? : Except DisplayRuleName UnstructuredScript)", "start": [299, 1], "end": [302, 60], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormStep", "code": "abbrev NormStep :=\n  MVarId \u2192 Array (IndexMatchResult NormRule) \u2192\n  Array (IndexMatchResult NormRule) \u2192 ProfileT MetaM NormRuleResult", "start": [304, 1], "end": [306, 68], "kind": "commanddeclaration"}, {"full_name": "Aesop.runNormSteps", "code": "def runNormSteps (rs : RuleSet) (goal : MVarId) (maxIterations : Nat)\n    (steps : Array NormStep) (stepsNe : 0 < steps.size) :\n    ProfileT MetaM NormSeqResult := do\n  let mut iteration := 0\n  let mut step : Fin steps.size := \u27e80, stepsNe\u27e9\n  let mut goal := goal\n  let mut script? : Except DisplayRuleName UnstructuredScript := .ok #[]\n  let mut preSimpRules := \u2205\n  let mut postSimpRules := \u2205\n  while iteration < maxIterations do\n    if step.val == 0 then\n      let rules \u2190 selectNormRules rs goal\n      let (preSimpRules', postSimpRules') :=\n        rules.partition \u03bb r => r.rule.extra.penalty < (0 : Int)\n      preSimpRules := preSimpRules'\n      postSimpRules := postSimpRules'\n    match \u2190 steps[step] goal preSimpRules postSimpRules with\n    | .succeeded newGoal scriptStep? =>\n      goal := newGoal\n      script? := return (\u2190 script?).push (\u2190 scriptStep?)\n      iteration := iteration + 1\n      step := \u27e80, stepsNe\u27e9\n    | .proved scriptStep? =>\n      script? := return (\u2190 script?).push (\u2190 scriptStep?)\n      return .proved script?\n    | .failed scriptStep? =>\n      script? :=\n        match scriptStep? with\n        | none => script?\n        | some scriptStep => return (\u2190 script?).push scriptStep\n      if h : step.val + 1 < steps.size then\n        step := \u27e8step.val + 1, h\u27e9\n      else\n        return .unproved goal script?\n  throwError \"aesop: exceeded maximum number of normalisation iterations ({maxIterations}). This means normalisation probably got stuck in an infinite loop.\"", "start": [308, 1], "end": [342, 158], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormStep.runPreSimpRules", "code": "def NormStep.runPreSimpRules (options : Options')\n    (mvars : UnorderedArraySet MVarId) : NormStep\n  | goal, preSimpRules, _ => runFirstNormRule goal mvars options preSimpRules", "start": [344, 1], "end": [346, 78], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormStep.runPostSimpRules", "code": "def NormStep.runPostSimpRules (options : Options')\n    (mvars : UnorderedArraySet MVarId) : NormStep\n  | goal, _, postSimpRules =>\n    runFirstNormRule goal mvars options postSimpRules", "start": [348, 1], "end": [351, 54], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormStep.unfold", "code": "def NormStep.unfold (rs : RuleSet) (options : Options')\n    (mvars : HashSet MVarId) : NormStep\n  | goal, _, _ => do\n    if options.enableUnfold then\n      normUnfold rs.unfoldRules goal mvars options.generateScript\n    else\n      aesop_trace[steps] \"norm unfold is disabled (options := \\{ ..., enableUnfold := false })\"\n      return .failed none", "start": [353, 1], "end": [360, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.NormStep.simp", "code": "def NormStep.simp (rs : RuleSet) (ctx : NormSimpContext) (options : Options')\n    (mvars : HashSet MVarId) : NormStep\n  | goal, _, _ => do\n    if ! ctx.enabled then\n      aesop_trace[steps] \"norm simp is disabled (simp_options := \\{ ..., enabled := false })\"\n      return .failed none\n    normSimp ctx rs.localNormSimpLemmas goal mvars options.generateScript", "start": [362, 1], "end": [368, 74], "kind": "commanddeclaration"}, {"full_name": "Aesop.normalizeGoalMVar", "code": "partial def normalizeGoalMVar (rs : RuleSet) (normSimpContext : NormSimpContext)\n    (options : Options') (goal : MVarId) (mvars : UnorderedArraySet MVarId) :\n    ProfileT MetaM NormSeqResult := do\n  let mvarsHashSet := .ofArray mvars.toArray\n  let mut normSteps := #[\n    NormStep.runPreSimpRules options mvars,\n    NormStep.unfold rs options mvarsHashSet,\n    NormStep.simp rs normSimpContext options mvarsHashSet,\n    NormStep.runPostSimpRules options mvars\n  ]\n  runNormSteps rs goal options.maxNormIterations normSteps (by simp)", "start": [370, 1], "end": [380, 69], "kind": "commanddeclaration"}, {"full_name": "Aesop.normalizeGoalIfNecessary", "code": "def normalizeGoalIfNecessary (gref : GoalRef) [Aesop.Queue Q] :\n    SearchM Q Bool := do\n  let g \u2190 gref.get\n  if \u2190 g.isRoot then\n    let rootState \u2190 getRootMetaState\n    gref.modify \u03bb g =>\n      g.setNormalizationState (.normal g.preNormGoal rootState (.ok #[]))\n    return false\n  match g.normalizationState with\n  | .provenByNormalization .. => return true\n  | .normal .. => return false\n  | .notNormal => pure ()\n  let ctx \u2190 read\n  let profilingEnabled \u2190 isProfilingEnabled\n  let profile \u2190 getThe Profile\n  let ((normResult, profile), postState) \u2190\n    (\u2190 gref.get).runMetaMInParentState do\n      normalizeGoalMVar ctx.ruleSet ctx.normSimpContext ctx.options\n        g.preNormGoal g.mvars\n      |>.run profilingEnabled profile\n  modify \u03bb s => { s with profile }\n  match normResult with\n  | .unproved postGoal script? =>\n    gref.modify (\u00b7.setNormalizationState (.normal postGoal postState script?))\n    return false\n  | .proved script? =>\n    gref.modify\n      (\u00b7.setNormalizationState (.provenByNormalization postState script?))\n    gref.markProvenByNormalization\n    return true", "start": [383, 1], "end": [413, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Frontend/Attribute.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Extension.lean", "lake-packages/aesop/Aesop/Frontend/RuleExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Frontend.AttrConfig", "code": "structure AttrConfig where\n  rules : Array RuleExpr\n  deriving Inhabited", "start": [26, 1], "end": [28, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.Frontend.AttrConfig.elab", "code": "def \u00abelab\u00bb (stx : Syntax) : TermElabM AttrConfig :=\n  withRef stx do\n    match stx with\n    | `(attr| aesop $e:Aesop.rule_expr) => do\n      let r \u2190 RuleExpr.elab e |>.run ElabOptions.forAdditionalRules\n      return { rules := #[r] }\n    | `(attr| aesop [ $es:Aesop.rule_expr,* ]) => do\n      let rs \u2190 (es : Array Syntax).mapM \u03bb e =>\n        RuleExpr.elab e |>.run ElabOptions.forAdditionalRules\n      return { rules := rs }\n    | _ => throwUnsupportedSyntax", "start": [32, 1], "end": [42, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Convert.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/Congr!.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.convert", "code": "def Lean.MVarId.convert (e : Expr) (sym : Bool)\n    (depth : Option Nat := none) (config : Congr!.Config := {})\n    (patterns : List (TSyntax `rcasesPat) := []) (g : MVarId) :\n    MetaM (List MVarId) := do\n  let src \u2190 inferType e\n  let tgt \u2190 g.getType\n  let v \u2190 mkFreshExprMVar (\u2190 mkAppM ``Eq (if sym then #[src, tgt] else #[tgt, src]))\n  g.assign (\u2190 mkAppM (if sym then ``Eq.mp else ``Eq.mpr) #[v, e])\n  let m := v.mvarId!\n  try m.congrN! depth config patterns\n  catch _ => return [m]", "start": [15, 1], "end": [34, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Spread.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Init/Order/LinearOrder.lean", "imports": ["Mathlib/Init/Order/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "min_def", "code": "theorem min_def (a b : \u03b1) : min a b = if a \u2264 b then a else b", "start": [25, 1], "end": [26, 29], "kind": "commanddeclaration"}, {"full_name": "max_def", "code": "theorem max_def (a b : \u03b1) : max a b = if a \u2264 b then b else a", "start": [29, 1], "end": [30, 29], "kind": "commanddeclaration"}, {"full_name": "min_le_left", "code": "theorem min_le_left (a b : \u03b1) : min a b \u2264 a", "start": [33, 1], "end": [37, 54], "kind": "commanddeclaration"}, {"full_name": "min_le_right", "code": "theorem min_le_right (a b : \u03b1) : min a b \u2264 b", "start": [40, 1], "end": [44, 41], "kind": "commanddeclaration"}, {"full_name": "le_min", "code": "theorem le_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) : c \u2264 min a b", "start": [47, 1], "end": [51, 42], "kind": "commanddeclaration"}, {"full_name": "le_max_left", "code": "theorem le_max_left (a b : \u03b1) : a \u2264 max a b", "start": [54, 1], "end": [58, 41], "kind": "commanddeclaration"}, {"full_name": "le_max_right", "code": "theorem le_max_right (a b : \u03b1) : b \u2264 max a b", "start": [61, 1], "end": [65, 54], "kind": "commanddeclaration"}, {"full_name": "max_le", "code": "theorem max_le {a b c : \u03b1} (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) : max a b \u2264 c", "start": [68, 1], "end": [72, 42], "kind": "commanddeclaration"}, {"full_name": "eq_min", "code": "theorem eq_min {a b c : \u03b1} (h\u2081 : c \u2264 a) (h\u2082 : c \u2264 b) (h\u2083 : \u2200 {d}, d \u2264 a \u2192 d \u2264 b \u2192 d \u2264 c) :\n    c = min a b", "start": [75, 1], "end": [77, 71], "kind": "commanddeclaration"}, {"full_name": "min_comm", "code": "theorem min_comm (a b : \u03b1) : min a b = min b a", "start": [80, 1], "end": [81, 72], "kind": "commanddeclaration"}, {"full_name": "min_assoc", "code": "theorem min_assoc (a b c : \u03b1) : min (min a b) c = min a (min b c)", "start": [84, 1], "end": [89, 42], "kind": "commanddeclaration"}, {"full_name": "min_left_comm", "code": "theorem min_left_comm : \u2200 a b c : \u03b1, min a (min b c) = min b (min a c)", "start": [92, 1], "end": [93, 56], "kind": "commanddeclaration"}, {"full_name": "min_self", "code": "@[simp]\ntheorem min_self (a : \u03b1) : min a a = a", "start": [96, 1], "end": [97, 60], "kind": "commanddeclaration"}, {"full_name": "min_eq_left", "code": "theorem min_eq_left {a b : \u03b1} (h : a \u2264 b) : min a b = a", "start": [100, 1], "end": [101, 64], "kind": "commanddeclaration"}, {"full_name": "min_eq_right", "code": "theorem min_eq_right {a b : \u03b1} (h : b \u2264 a) : min a b = b", "start": [104, 1], "end": [105, 31], "kind": "commanddeclaration"}, {"full_name": "eq_max", "code": "theorem eq_max {a b c : \u03b1} (h\u2081 : a \u2264 c) (h\u2082 : b \u2264 c) (h\u2083 : \u2200 {d}, a \u2264 d \u2192 b \u2264 d \u2192 c \u2264 d) :\n    c = max a b", "start": [108, 1], "end": [110, 71], "kind": "commanddeclaration"}, {"full_name": "max_comm", "code": "theorem max_comm (a b : \u03b1) : max a b = max b a", "start": [113, 1], "end": [114, 72], "kind": "commanddeclaration"}, {"full_name": "max_assoc", "code": "theorem max_assoc (a b c : \u03b1) : max (max a b) c = max a (max b c)", "start": [117, 1], "end": [122, 41], "kind": "commanddeclaration"}, {"full_name": "max_left_comm", "code": "theorem max_left_comm : \u2200 a b c : \u03b1, max a (max b c) = max b (max a c)", "start": [125, 1], "end": [126, 56], "kind": "commanddeclaration"}, {"full_name": "max_self", "code": "@[simp]\ntheorem max_self (a : \u03b1) : max a a = a", "start": [129, 1], "end": [130, 60], "kind": "commanddeclaration"}, {"full_name": "max_eq_left", "code": "theorem max_eq_left {a b : \u03b1} (h : b \u2264 a) : max a b = a", "start": [133, 1], "end": [134, 64], "kind": "commanddeclaration"}, {"full_name": "max_eq_right", "code": "theorem max_eq_right {a b : \u03b1} (h : a \u2264 b) : max a b = b", "start": [137, 1], "end": [138, 31], "kind": "commanddeclaration"}, {"full_name": "min_eq_left_of_lt", "code": "theorem min_eq_left_of_lt {a b : \u03b1} (h : a < b) : min a b = a", "start": [142, 1], "end": [143, 27], "kind": "commanddeclaration"}, {"full_name": "min_eq_right_of_lt", "code": "theorem min_eq_right_of_lt {a b : \u03b1} (h : b < a) : min a b = b", "start": [146, 1], "end": [147, 28], "kind": "commanddeclaration"}, {"full_name": "max_eq_left_of_lt", "code": "theorem max_eq_left_of_lt {a b : \u03b1} (h : b < a) : max a b = a", "start": [150, 1], "end": [151, 27], "kind": "commanddeclaration"}, {"full_name": "max_eq_right_of_lt", "code": "theorem max_eq_right_of_lt {a b : \u03b1} (h : a < b) : max a b = b", "start": [154, 1], "end": [155, 28], "kind": "commanddeclaration"}, {"full_name": "lt_min", "code": "theorem lt_min {a b c : \u03b1} (h\u2081 : a < b) (h\u2082 : a < c) : a < min b c", "start": [159, 1], "end": [163, 51], "kind": "commanddeclaration"}, {"full_name": "max_lt", "code": "theorem max_lt {a b c : \u03b1} (h\u2081 : a < c) (h\u2082 : b < c) : max a b < c", "start": [166, 1], "end": [170, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Prod/Basic.lean", "imports": ["Mathlib/Tactic/Inhabit.lean", "Mathlib/Init/Core.lean", "Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Function.lean"], "premises": [{"full_name": "Prod_map", "code": "@[simp]\ntheorem Prod_map (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) (p : \u03b1 \u00d7 \u03b2) : Prod.map f g p = (f p.1, g p.2)", "start": [24, 1], "end": [26, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.mk.eta", "code": "@[simp]\ntheorem mk.eta : \u2200 {p : \u03b1 \u00d7 \u03b2}, (p.1, p.2) = p", "start": [31, 1], "end": [33, 18], "kind": "commanddeclaration"}, {"full_name": "Prod.forall", "code": "@[simp]\ntheorem \u00abforall\u00bb {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} : (\u2200 x, p x) \u2194 \u2200 a b, p (a, b)", "start": [35, 1], "end": [37, 47], "kind": "commanddeclaration"}, {"full_name": "Prod.exists", "code": "@[simp]\ntheorem \u00abexists\u00bb {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} : (\u2203 x, p x) \u2194 \u2203 a b, p (a, b)", "start": [40, 1], "end": [42, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.forall'", "code": "theorem forall' {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2200 x : \u03b1 \u00d7 \u03b2, p x.1 x.2) \u2194 \u2200 a b, p a b", "start": [45, 1], "end": [46, 14], "kind": "commanddeclaration"}, {"full_name": "Prod.exists'", "code": "theorem exists' {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2203 x : \u03b1 \u00d7 \u03b2, p x.1 x.2) \u2194 \u2203 a b, p a b", "start": [49, 1], "end": [50, 14], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_comp_mk", "code": "@[simp]\ntheorem snd_comp_mk (x : \u03b1) : Prod.snd \u2218 (Prod.mk x : \u03b2 \u2192 \u03b1 \u00d7 \u03b2) = id", "start": [53, 1], "end": [55, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_comp_mk", "code": "@[simp]\ntheorem fst_comp_mk (x : \u03b1) : Prod.fst \u2218 (Prod.mk x : \u03b2 \u2192 \u03b1 \u00d7 \u03b2) = Function.const \u03b2 x", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.map_mk", "code": "@[simp, mfld_simps]\ntheorem map_mk (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) (a : \u03b1) (b : \u03b2) : map f g (a, b) = (f a, g b)", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.map_fst", "code": "theorem map_fst (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) (p : \u03b1 \u00d7 \u03b2) : (map f g p).1 = f p.1", "start": [68, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.map_snd", "code": "theorem map_snd (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) (p : \u03b1 \u00d7 \u03b2) : (map f g p).2 = g p.2", "start": [72, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.map_fst'", "code": "theorem map_fst' (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) : Prod.fst \u2218 map f g = f \u2218 Prod.fst", "start": [76, 1], "end": [77, 24], "kind": "commanddeclaration"}, {"full_name": "Prod.map_snd'", "code": "theorem map_snd' (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) : Prod.snd \u2218 map f g = g \u2218 Prod.snd", "start": [80, 1], "end": [81, 24], "kind": "commanddeclaration"}, {"full_name": "Prod.map_comp_map", "code": "theorem map_comp_map {\u03b5 \u03b6 : Type*} (f : \u03b1 \u2192 \u03b2) (f' : \u03b3 \u2192 \u03b4) (g : \u03b2 \u2192 \u03b5) (g' : \u03b4 \u2192 \u03b6) :\n    Prod.map g g' \u2218 Prod.map f f' = Prod.map (g \u2218 f) (g' \u2218 f')", "start": [84, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.map_map", "code": "theorem map_map {\u03b5 \u03b6 : Type*} (f : \u03b1 \u2192 \u03b2) (f' : \u03b3 \u2192 \u03b4) (g : \u03b2 \u2192 \u03b5) (g' : \u03b4 \u2192 \u03b6) (x : \u03b1 \u00d7 \u03b3) :\n    Prod.map g g' (Prod.map f f' x) = Prod.map (g \u2218 f) (g' \u2218 f') x", "start": [92, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.mk.inj_iff", "code": "theorem mk.inj_iff {a\u2081 a\u2082 : \u03b1} {b\u2081 b\u2082 : \u03b2} : (a\u2081, b\u2081) = (a\u2082, b\u2082) \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082", "start": [103, 1], "end": [104, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.mk.inj_left", "code": "theorem mk.inj_left {\u03b1 \u03b2 : Type*} (a : \u03b1) : Function.Injective (Prod.mk a : \u03b2 \u2192 \u03b1 \u00d7 \u03b2)", "start": [107, 1], "end": [109, 67], "kind": "commanddeclaration"}, {"full_name": "Prod.mk.inj_right", "code": "theorem mk.inj_right {\u03b1 \u03b2 : Type*} (b : \u03b2) :\n    Function.Injective (fun a \u21a6 Prod.mk a b : \u03b1 \u2192 \u03b1 \u00d7 \u03b2)", "start": [112, 1], "end": [115, 62], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_inj_left", "code": "lemma mk_inj_left : (a, b\u2081) = (a, b\u2082) \u2194 b\u2081 = b\u2082 := (mk.inj_left _).eq_iff", "start": [118, 1], "end": [118, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Prod.mk_inj_right", "code": "lemma mk_inj_right : (a\u2081, b) = (a\u2082, b) \u2194 a\u2081 = a\u2082 := (mk.inj_right _).eq_iff", "start": [121, 1], "end": [121, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Prod.ext_iff", "code": "theorem ext_iff {p q : \u03b1 \u00d7 \u03b2} : p = q \u2194 p.1 = q.1 \u2227 p.2 = q.2", "start": [124, 1], "end": [125, 18], "kind": "commanddeclaration"}, {"full_name": "Prod.ext", "code": "@[ext]\ntheorem ext {\u03b1 \u03b2} {p q : \u03b1 \u00d7 \u03b2} (h\u2081 : p.1 = q.1) (h\u2082 : p.2 = q.2) : p = q", "start": [128, 1], "end": [130, 21], "kind": "commanddeclaration"}, {"full_name": "Prod.map_def", "code": "theorem map_def {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} : Prod.map f g = fun p : \u03b1 \u00d7 \u03b2 \u21a6 (f p.1, g p.2)", "start": [133, 1], "end": [134, 53], "kind": "commanddeclaration"}, {"full_name": "Prod.id_prod", "code": "theorem id_prod : (fun p : \u03b1 \u00d7 \u03b2 \u21a6 (p.1, p.2)) = id", "start": [137, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.map_id", "code": "@[simp]\ntheorem map_id : Prod.map (@id \u03b1) (@id \u03b2) = id", "start": [141, 1], "end": [143, 10], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_surjective", "code": "theorem fst_surjective [h : Nonempty \u03b2] : Function.Surjective (@fst \u03b1 \u03b2)", "start": [146, 1], "end": [147, 39], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_surjective", "code": "theorem snd_surjective [h : Nonempty \u03b1] : Function.Surjective (@snd \u03b1 \u03b2)", "start": [150, 1], "end": [151, 39], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_injective", "code": "theorem fst_injective [Subsingleton \u03b2] : Function.Injective (@fst \u03b1 \u03b2)", "start": [154, 1], "end": [155, 44], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_injective", "code": "theorem snd_injective [Subsingleton \u03b1] : Function.Injective (@snd \u03b1 \u03b2)", "start": [158, 1], "end": [159, 44], "kind": "commanddeclaration"}, {"full_name": "Prod.swap", "code": "def swap : \u03b1 \u00d7 \u03b2 \u2192 \u03b2 \u00d7 \u03b1 := fun p \u21a6 (p.2, p.1)", "start": [162, 1], "end": [163, 47], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_swap", "code": "@[simp]\ntheorem swap_swap : \u2200 x : \u03b1 \u00d7 \u03b2, swap (swap x) = x", "start": [166, 1], "end": [168, 18], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_swap", "code": "@[simp]\ntheorem fst_swap {p : \u03b1 \u00d7 \u03b2} : (swap p).1 = p.2", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_swap", "code": "@[simp]\ntheorem snd_swap {p : \u03b1 \u00d7 \u03b2} : (swap p).2 = p.1", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_prod_mk", "code": "@[simp]\ntheorem swap_prod_mk {a : \u03b1} {b : \u03b2} : swap (a, b) = (b, a)", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_swap_eq", "code": "@[simp]\ntheorem swap_swap_eq : swap \u2218 swap = @id (\u03b1 \u00d7 \u03b2)", "start": [186, 1], "end": [188, 19], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_leftInverse", "code": "@[simp]\ntheorem swap_leftInverse : Function.LeftInverse (@swap \u03b1 \u03b2) swap", "start": [191, 1], "end": [193, 12], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_rightInverse", "code": "@[simp]\ntheorem swap_rightInverse : Function.RightInverse (@swap \u03b1 \u03b2) swap", "start": [196, 1], "end": [198, 12], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_injective", "code": "theorem swap_injective : Function.Injective (@swap \u03b1 \u03b2)", "start": [201, 1], "end": [202, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_surjective", "code": "theorem swap_surjective : Function.Surjective (@swap \u03b1 \u03b2)", "start": [205, 1], "end": [206, 30], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_bijective", "code": "theorem swap_bijective : Function.Bijective (@swap \u03b1 \u03b2)", "start": [209, 1], "end": [210, 36], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_inj", "code": "@[simp]\ntheorem swap_inj {p q : \u03b1 \u00d7 \u03b2} : swap p = swap q \u2194 p = q", "start": [213, 1], "end": [215, 24], "kind": "commanddeclaration"}, {"full_name": "Prod.eq_iff_fst_eq_snd_eq", "code": "theorem eq_iff_fst_eq_snd_eq : \u2200 {p q : \u03b1 \u00d7 \u03b2}, p = q \u2194 p.1 = q.1 \u2227 p.2 = q.2", "start": [218, 1], "end": [219, 34], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_eq_iff", "code": "theorem fst_eq_iff : \u2200 {p : \u03b1 \u00d7 \u03b2} {x : \u03b1}, p.1 = x \u2194 p = (x, p.2)", "start": [222, 1], "end": [223, 25], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_eq_iff", "code": "theorem snd_eq_iff : \u2200 {p : \u03b1 \u00d7 \u03b2} {x : \u03b2}, p.2 = x \u2194 p = (p.1, x)", "start": [226, 1], "end": [227, 25], "kind": "commanddeclaration"}, {"full_name": "Prod.lex_def", "code": "theorem lex_def (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) {p q : \u03b1 \u00d7 \u03b2} :\n    Prod.Lex r s p q \u2194 r p.1 q.1 \u2228 p.1 = q.1 \u2227 s p.2 q.2", "start": [232, 1], "end": [237, 72], "kind": "commanddeclaration"}, {"full_name": "Prod.lex_iff", "code": "lemma lex_iff : Prod.Lex r s x y \u2194 r x.1 y.1 \u2228 x.1 = y.1 \u2227 s x.2 y.2 := lex_def _ _", "start": [240, 1], "end": [240, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Prod.Lex.decidable", "code": "instance Lex.decidable [DecidableEq \u03b1]\n    (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [DecidableRel r] [DecidableRel s] :\n    DecidableRel (Prod.Lex r s) :=\n  fun _ _ \u21a6 decidable_of_decidable_of_iff (lex_def r s).symm", "start": [243, 1], "end": [246, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.refl_left", "code": "@[refl]\ntheorem Lex.refl_left (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsRefl \u03b1 r] : \u2200 x, Prod.Lex r s x x", "start": [248, 1], "end": [250, 36], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.refl_right", "code": "@[refl]\ntheorem Lex.refl_right (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsRefl \u03b2 s] : \u2200 x, Prod.Lex r s x x", "start": [256, 1], "end": [258, 35], "kind": "commanddeclaration"}, {"full_name": "Prod.isIrrefl", "code": "instance isIrrefl [IsIrrefl \u03b1 r] [IsIrrefl \u03b2 s] : IsIrrefl (\u03b1 \u00d7 \u03b2) (Prod.Lex r s) :=\n  \u27e8by rintro \u27e8i, a\u27e9 (\u27e8_, _, h\u27e9 | \u27e8_, h\u27e9) <;> exact irrefl _ h\u27e9", "start": [264, 1], "end": [265, 63], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.trans", "code": "@[trans]\ntheorem Lex.trans {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsTrans \u03b1 r] [IsTrans \u03b2 s] :\n    \u2200 {x y z : \u03b1 \u00d7 \u03b2}, Prod.Lex r s x y \u2192 Prod.Lex r s y z \u2192 Prod.Lex r s x z", "start": [267, 1], "end": [273, 95], "kind": "commanddeclaration"}, {"full_name": "Prod.isTotal_left", "code": "instance isTotal_left {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsTotal \u03b1 r] :\n    IsTotal (\u03b1 \u00d7 \u03b2) (Prod.Lex r s) :=\n  \u27e8fun \u27e8a\u2081, _\u27e9 \u27e8a\u2082, _\u27e9 \u21a6 (IsTotal.total a\u2081 a\u2082).imp (Lex.left _ _) (Lex.left _ _)\u27e9", "start": [289, 1], "end": [291, 82], "kind": "commanddeclaration"}, {"full_name": "Prod.isTotal_right", "code": "instance isTotal_right {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsTrichotomous \u03b1 r] [IsTotal \u03b2 s] :\n    IsTotal (\u03b1 \u00d7 \u03b2) (Prod.Lex r s) :=\n  \u27e8fun \u27e8i, a\u27e9 \u27e8j, b\u27e9 \u21a6 by\n    obtain hij | rfl | hji := trichotomous_of r i j\n    \u00b7 exact Or.inl (.left _ _ hij)\n    \u00b7 exact (total_of s a b).imp (.right _) (.right _)\n    \u00b7 exact Or.inr (.left _ _ hji) \u27e9", "start": [294, 1], "end": [300, 37], "kind": "commanddeclaration"}, {"full_name": "Prod.IsTrichotomous", "code": "instance IsTrichotomous [IsTrichotomous \u03b1 r] [IsTrichotomous \u03b2 s] :\n  IsTrichotomous (\u03b1 \u00d7 \u03b2) (Prod.Lex r s) :=\n\u27e8fun \u27e8i, a\u27e9 \u27e8j, b\u27e9 \u21a6 by\n  obtain hij | rfl | hji := trichotomous_of r i j\n  { exact Or.inl (Lex.left _ _ hij) }\n  { exact (trichotomous_of (s) a b).imp3 (Lex.right _) (congr_arg _) (Lex.right _) }\n  { exact Or.inr (Or.inr $ Lex.left _ _ hji) }\u27e9", "start": [303, 1], "end": [309, 48], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.Prod_map", "code": "theorem Injective.Prod_map (hf : Injective f) (hg : Injective g) : Injective (map f g)", "start": [319, 1], "end": [320, 63], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.Prod_map", "code": "theorem Surjective.Prod_map (hf : Surjective f) (hg : Surjective g) : Surjective (map f g)", "start": [323, 1], "end": [327, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.Prod_map", "code": "theorem Bijective.Prod_map (hf : Bijective f) (hg : Bijective g) : Bijective (map f g)", "start": [330, 1], "end": [331, 43], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.Prod_map", "code": "theorem LeftInverse.Prod_map (hf : LeftInverse f\u2081 f\u2082) (hg : LeftInverse g\u2081 g\u2082) :\n    LeftInverse (map f\u2081 g\u2081) (map f\u2082 g\u2082)", "start": [334, 1], "end": [336, 73], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.Prod_map", "code": "theorem RightInverse.Prod_map :\n    RightInverse f\u2081 f\u2082 \u2192 RightInverse g\u2081 g\u2082 \u2192 RightInverse (map f\u2081 g\u2081) (map f\u2082 g\u2082)", "start": [339, 1], "end": [341, 23], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.Prod_map", "code": "theorem Involutive.Prod_map {f : \u03b1 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b2} :\n    Involutive f \u2192 Involutive g \u2192 Involutive (map f g)", "start": [344, 1], "end": [346, 23], "kind": "commanddeclaration"}, {"full_name": "Prod.map_injective", "code": "@[simp]\ntheorem map_injective [Nonempty \u03b1] [Nonempty \u03b2] {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} :\n    Injective (map f g) \u2194 Injective f \u2227 Injective g", "start": [355, 1], "end": [366, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.map_surjective", "code": "@[simp]\ntheorem map_surjective [Nonempty \u03b3] [Nonempty \u03b4] {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} :\n    Surjective (map f g) \u2194 Surjective f \u2227 Surjective g", "start": [369, 1], "end": [381, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.map_bijective", "code": "@[simp]\ntheorem map_bijective [Nonempty \u03b1] [Nonempty \u03b2] {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} :\n    Bijective (map f g) \u2194 Bijective f \u2227 Bijective g", "start": [384, 1], "end": [389, 68], "kind": "commanddeclaration"}, {"full_name": "Prod.map_leftInverse", "code": "@[simp]\ntheorem map_leftInverse [Nonempty \u03b2] [Nonempty \u03b4] {f\u2081 : \u03b1 \u2192 \u03b2} {g\u2081 : \u03b3 \u2192 \u03b4} {f\u2082 : \u03b2 \u2192 \u03b1}\n    {g\u2082 : \u03b4 \u2192 \u03b3} : LeftInverse (map f\u2081 g\u2081) (map f\u2082 g\u2082) \u2194 LeftInverse f\u2081 f\u2082 \u2227 LeftInverse g\u2081 g\u2082", "start": [392, 1], "end": [402, 32], "kind": "commanddeclaration"}, {"full_name": "Prod.map_rightInverse", "code": "@[simp]\ntheorem map_rightInverse [Nonempty \u03b1] [Nonempty \u03b3] {f\u2081 : \u03b1 \u2192 \u03b2} {g\u2081 : \u03b3 \u2192 \u03b4} {f\u2082 : \u03b2 \u2192 \u03b1}\n    {g\u2082 : \u03b4 \u2192 \u03b3} : RightInverse (map f\u2081 g\u2081) (map f\u2082 g\u2082) \u2194 RightInverse f\u2081 f\u2082 \u2227 RightInverse g\u2081 g\u2082", "start": [405, 1], "end": [408, 18], "kind": "commanddeclaration"}, {"full_name": "Prod.map_involutive", "code": "@[simp]\ntheorem map_involutive [Nonempty \u03b1] [Nonempty \u03b2] {f : \u03b1 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b2} :\n    Involutive (map f g) \u2194 Involutive f \u2227 Involutive g", "start": [411, 1], "end": [414, 18], "kind": "commanddeclaration"}, {"full_name": "delabProdProjs", "code": "@[delab app.Prod.fst, delab app.Prod.snd]\ndef delabProdProjs : Delab := do\n  let #[_, _, _] := (\u2190 SubExpr.getExpr).getAppArgs | failure\n  let stx \u2190 delabProjectionApp\n  match stx with\n  | `($(x).fst) => `($(x).1)\n  | `($(x).snd) => `($(x).2)\n  | _ => failure", "start": [422, 1], "end": [430, 17], "kind": "commanddeclaration"}, {"full_name": "unexpandProdFst", "code": "@[app_unexpander Prod.fst]\ndef unexpandProdFst : Lean.PrettyPrinter.Unexpander\n  | `($(_) $p $xs*) => `($p.1 $xs*)\n  | _ => throw ()", "start": [432, 1], "end": [437, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandProdSnd", "code": "@[app_unexpander Prod.snd]\ndef unexpandProdSnd : Lean.PrettyPrinter.Unexpander\n  | `($(_) $p $xs*) => `($p.2 $xs*)\n  | _ => throw ()", "start": [439, 1], "end": [444, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Cases.lean", "imports": ["lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Tactic/OpenPrivate.lean", "Mathlib/Lean/Expr/Basic.lean"], "premises": [{"full_name": "Mathlib.Tactic.ElimApp.evalNames", "code": "def ElimApp.evalNames (elimInfo : ElimInfo) (alts : Array ElimApp.Alt) (withArg : Syntax)\n    (numEqs := 0) (numGeneralized := 0) (toClear : Array FVarId := #[]) :\n    TermElabM (Array MVarId) := do\n  let mut names : List Syntax := withArg[1].getArgs |>.toList\n  let mut subgoals := #[]\n  for { name := altName, mvarId := g, .. } in alts do\n    let numFields \u2190 getAltNumFields elimInfo altName\n    let (altVarNames, names') := names.splitAtD numFields (Unhygienic.run `(_))\n    names := names'\n    let (fvars, g) \u2190 g.introN numFields <| altVarNames.map (getNameOfIdent' \u00b7[0])\n    let some (g, subst) \u2190 Cases.unifyEqs? numEqs g {} | pure ()\n    let (_, g) \u2190 g.introNP numGeneralized\n    let g \u2190 liftM $ toClear.foldlM (\u00b7.tryClear) g\n    for fvar in fvars, stx in altVarNames do\n      g.withContext <| (subst.apply <| .fvar fvar).addLocalVarInfoForBinderIdent \u27e8stx\u27e9\n    subgoals := subgoals.push g\n  pure subgoals", "start": [42, 1], "end": [58, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Classical.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/Subtype.lean", "imports": ["Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subtype.prop", "code": "theorem prop (x : Subtype p) : p x", "start": [36, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.forall", "code": "@[simp]\nprotected theorem \u00abforall\u00bb {q : { a // p a } \u2192 Prop} : (\u2200 x, q x) \u2194 \u2200 a b, q \u27e8a, b\u27e9", "start": [42, 1], "end": [44, 47], "kind": "commanddeclaration"}, {"full_name": "Subtype.forall'", "code": "protected theorem forall' {q : \u2200 x, p x \u2192 Prop} : (\u2200 x h, q x h) \u2194 \u2200 x : { a // p a }, q x x.2", "start": [47, 1], "end": [50, 47], "kind": "commanddeclaration"}, {"full_name": "Subtype.exists", "code": "@[simp]\nprotected theorem \u00abexists\u00bb {q : { a // p a } \u2192 Prop} : (\u2203 x, q x) \u2194 \u2203 a b, q \u27e8a, b\u27e9", "start": [53, 1], "end": [55, 61], "kind": "commanddeclaration"}, {"full_name": "Subtype.exists'", "code": "protected theorem exists' {q : \u2200 x, p x \u2192 Prop} : (\u2203 x h, q x h) \u2194 \u2203 x : { a // p a }, q x x.2", "start": [58, 1], "end": [61, 47], "kind": "commanddeclaration"}, {"full_name": "Subtype.ext", "code": "@[ext]\nprotected theorem ext : \u2200 {a1 a2 : { x // p x }}, (a1 : \u03b1) = (a2 : \u03b1) \u2192 a1 = a2", "start": [64, 1], "end": [66, 31], "kind": "commanddeclaration"}, {"full_name": "Subtype.ext_iff", "code": "theorem ext_iff {a1 a2 : { x // p x }} : a1 = a2 \u2194 (a1 : \u03b1) = (a2 : \u03b1)", "start": [69, 1], "end": [70, 29], "kind": "commanddeclaration"}, {"full_name": "Subtype.heq_iff_coe_eq", "code": "theorem heq_iff_coe_eq (h : \u2200 x, p x \u2194 q x) {a1 : { x // p x }} {a2 : { x // q x }} :\n    HEq a1 a2 \u2194 (a1 : \u03b1) = (a2 : \u03b1)", "start": [73, 1], "end": [76, 78], "kind": "commanddeclaration"}, {"full_name": "Subtype.heq_iff_coe_heq", "code": "lemma heq_iff_coe_heq {\u03b1 \u03b2 : Sort _} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {a : {x // p x}}\n    {b : {y // q y}} (h : \u03b1 = \u03b2) (h' : HEq p q) : HEq a b \u2194 HEq (a : \u03b1) (b : \u03b2) := by\n  subst h\n  subst h'\n  rw [heq_iff_eq, heq_iff_eq, ext_iff]", "start": [79, 1], "end": [83, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Subtype.ext_val", "code": "theorem ext_val {a1 a2 : { x // p x }} : a1.1 = a2.1 \u2192 a1 = a2", "start": [86, 1], "end": [87, 14], "kind": "commanddeclaration"}, {"full_name": "Subtype.ext_iff_val", "code": "theorem ext_iff_val {a1 a2 : { x // p x }} : a1 = a2 \u2194 a1.1 = a2.1", "start": [90, 1], "end": [91, 10], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_eta", "code": "@[simp]\ntheorem coe_eta (a : { a // p a }) (h : p a) : mk (\u2191a) h = a", "start": [94, 1], "end": [96, 18], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_mk", "code": "theorem coe_mk (a h) : (@mk \u03b1 p a h : \u03b1) = a", "start": [99, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.mk_eq_mk", "code": "theorem mk_eq_mk {a h a' h'} : @mk \u03b1 p a h = @mk \u03b1 p a' h' \u2194 a = a'", "start": [107, 1], "end": [108, 10], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_eq_of_eq_mk", "code": "theorem coe_eq_of_eq_mk {a : { a // p a }} {b : \u03b1} (h : \u2191a = b) : a = \u27e8b, h \u25b8 a.2\u27e9", "start": [111, 1], "end": [112, 16], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_eq_iff", "code": "theorem coe_eq_iff {a : { a // p a }} {b : \u03b1} : \u2191a = b \u2194 \u2203 h, a = \u27e8b, h\u27e9", "start": [115, 1], "end": [116, 71], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_injective", "code": "theorem coe_injective : Injective (fun (a : Subtype p) \u21a6 (a : \u03b1))", "start": [119, 1], "end": [119, 91], "kind": "commanddeclaration"}, {"full_name": "Subtype.val_injective", "code": "theorem val_injective : Injective (@val _ p)", "start": [122, 1], "end": [123, 16], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_inj", "code": "theorem coe_inj {a b : Subtype p} : (a : \u03b1) = b \u2194 a = b", "start": [126, 1], "end": [127, 23], "kind": "commanddeclaration"}, {"full_name": "Subtype.val_inj", "code": "theorem val_inj {a b : Subtype p} : a.val = b.val \u2194 a = b", "start": [130, 1], "end": [131, 10], "kind": "commanddeclaration"}, {"full_name": "exists_eq_subtype_mk_iff", "code": "@[simp, nolint simpNF]\ntheorem _root_.exists_eq_subtype_mk_iff {a : Subtype p} {b : \u03b1} :\n    (\u2203 h : p b, a = Subtype.mk b h) \u2194 \u2191a = b", "start": [136, 1], "end": [139, 18], "kind": "commanddeclaration"}, {"full_name": "exists_subtype_mk_eq_iff", "code": "@[simp, nolint simpNF]\ntheorem _root_.exists_subtype_mk_eq_iff {a : Subtype p} {b : \u03b1} :\n    (\u2203 h : p b, Subtype.mk b h = a) \u2194 b = a", "start": [144, 1], "end": [147, 69], "kind": "commanddeclaration"}, {"full_name": "Subtype.restrict", "code": "def restrict {\u03b1} {\u03b2 : \u03b1 \u2192 Type*} (p : \u03b1 \u2192 Prop) (f : \u2200 x, \u03b2 x) (x : Subtype p) : \u03b2 x.1 :=\n  f x", "start": [150, 1], "end": [152, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.restrict_apply", "code": "theorem restrict_apply {\u03b1} {\u03b2 : \u03b1 \u2192 Type*} (f : \u2200 x, \u03b2 x) (p : \u03b1 \u2192 Prop) (x : Subtype p) :\n    restrict p f x = f x.1", "start": [155, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.restrict_def", "code": "theorem restrict_def {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (p : \u03b1 \u2192 Prop) :\n    restrict p f = f \u2218 (fun (a : Subtype p) \u21a6 a)", "start": [160, 1], "end": [161, 56], "kind": "commanddeclaration"}, {"full_name": "Subtype.restrict_injective", "code": "theorem restrict_injective {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (p : \u03b1 \u2192 Prop) (h : Injective f) :\n    Injective (restrict p f)", "start": [164, 1], "end": [166, 23], "kind": "commanddeclaration"}, {"full_name": "Subtype.surjective_restrict", "code": "theorem surjective_restrict {\u03b1} {\u03b2 : \u03b1 \u2192 Type*} [ne : \u2200 a, Nonempty (\u03b2 a)] (p : \u03b1 \u2192 Prop) :\n    Surjective fun f : \u2200 x, \u03b2 x \u21a6 restrict p f", "start": [169, 1], "end": [174, 19], "kind": "commanddeclaration"}, {"full_name": "Subtype.coind", "code": "@[simps]\ndef coind {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) {p : \u03b2 \u2192 Prop} (h : \u2200 a, p (f a)) : \u03b1 \u2192 Subtype p := fun a \u21a6 \u27e8f a, h a\u27e9", "start": [177, 1], "end": [179, 100], "kind": "commanddeclaration"}, {"full_name": "Subtype.coind_injective", "code": "theorem coind_injective {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} (h : \u2200 a, p (f a)) (hf : Injective f) :\n    Injective (coind f h)", "start": [183, 1], "end": [184, 84], "kind": "commanddeclaration"}, {"full_name": "Subtype.coind_surjective", "code": "theorem coind_surjective {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} (h : \u2200 a, p (f a)) (hf : Surjective f) :\n    Surjective (coind f h)", "start": [187, 1], "end": [190, 24], "kind": "commanddeclaration"}, {"full_name": "Subtype.coind_bijective", "code": "theorem coind_bijective {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} (h : \u2200 a, p (f a)) (hf : Bijective f) :\n    Bijective (coind f h)", "start": [193, 1], "end": [195, 52], "kind": "commanddeclaration"}, {"full_name": "Subtype.map", "code": "@[simps]\ndef map {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (h : \u2200 a, p a \u2192 q (f a)) :\n    Subtype p \u2192 Subtype q :=\n  fun x \u21a6 \u27e8f x, h x x.prop\u27e9", "start": [198, 1], "end": [202, 28], "kind": "commanddeclaration"}, {"full_name": "Subtype.map_comp", "code": "theorem map_comp {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} {x : Subtype p}\n    (f : \u03b1 \u2192 \u03b2) (h : \u2200 a, p a \u2192 q (f a)) (g : \u03b2 \u2192 \u03b3) (l : \u2200 a, q a \u2192 r (g a)) :\n    map g l (map f h x) = map (g \u2218 f) (fun a ha \u21a6 l (f a) <| h a ha) x", "start": [206, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.map_id", "code": "theorem map_id {p : \u03b1 \u2192 Prop} {h : \u2200 a, p a \u2192 p (id a)} : map (@id \u03b1) h = id", "start": [212, 1], "end": [213, 21], "kind": "commanddeclaration"}, {"full_name": "Subtype.map_injective", "code": "theorem map_injective {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (h : \u2200 a, p a \u2192 q (f a))\n    (hf : Injective f) : Injective (map f h)", "start": [216, 1], "end": [218, 45], "kind": "commanddeclaration"}, {"full_name": "Subtype.map_involutive", "code": "theorem map_involutive {p : \u03b1 \u2192 Prop} {f : \u03b1 \u2192 \u03b1} (h : \u2200 a, p a \u2192 p (f a))\n    (hf : Involutive f) : Involutive (map f h)", "start": [221, 1], "end": [223, 29], "kind": "commanddeclaration"}, {"full_name": "Subtype.equiv_iff", "code": "theorem equiv_iff [HasEquiv \u03b1] {p : \u03b1 \u2192 Prop} {s t : Subtype p} : s \u2248 t \u2194 (s : \u03b1) \u2248 (t : \u03b1)", "start": [229, 1], "end": [230, 10], "kind": "commanddeclaration"}, {"full_name": "Subtype.refl", "code": "protected theorem refl (s : Subtype p) : s \u2248 s", "start": [235, 1], "end": [236, 16], "kind": "commanddeclaration"}, {"full_name": "Subtype.symm", "code": "protected theorem symm {s t : Subtype p} (h : s \u2248 t) : t \u2248 s", "start": [239, 1], "end": [240, 16], "kind": "commanddeclaration"}, {"full_name": "Subtype.trans", "code": "protected theorem trans {s t u : Subtype p} (h\u2081 : s \u2248 t) (h\u2082 : t \u2248 u) : s \u2248 u", "start": [243, 1], "end": [244, 21], "kind": "commanddeclaration"}, {"full_name": "Subtype.equivalence", "code": "theorem equivalence (p : \u03b1 \u2192 Prop) : Equivalence (@HasEquiv.Equiv (Subtype p) _)", "start": [247, 1], "end": [248, 66], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_prop", "code": "@[simp]\ntheorem coe_prop {S : Set \u03b1} (a : { a // a \u2208 S }) : \u2191a \u2208 S", "start": [261, 1], "end": [263, 9], "kind": "commanddeclaration"}, {"full_name": "Subtype.val_prop", "code": "theorem val_prop {S : Set \u03b1} (a : { a // a \u2208 S }) : a.val \u2208 S", "start": [266, 1], "end": [267, 13], "kind": "commanddeclaration"}]}
