{"path": "lake-packages/lean4/src/lean/Init/Prelude.lean", "imports": [], "premises": [{"full_name": "id", "code": "@[inline] def id {\u03b1 : Sort u} (a : \u03b1) : \u03b1 := a", "start": [21, 1], "end": [33, 47], "kind": "commanddeclaration"}, {"full_name": "Function.comp", "code": "@[inline] def Function.comp {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b4 : Sort w} (f : \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b4 :=\n  fun x => f (g x)", "start": [35, 1], "end": [53, 19], "kind": "commanddeclaration"}, {"full_name": "Function.const", "code": "@[inline] def Function.const {\u03b1 : Sort u} (\u03b2 : Sort v) (a : \u03b1) : \u03b2 \u2192 \u03b1 :=\n  fun _ => a", "start": [55, 1], "end": [67, 13], "kind": "commanddeclaration"}, {"full_name": "inferInstance", "code": "abbrev inferInstance {\u03b1 : Sort u} [i : \u03b1] : \u03b1 := i", "start": [70, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "inferInstanceAs", "code": "abbrev inferInstanceAs (\u03b1 : Sort u) [i : \u03b1] : \u03b1 := i", "start": [89, 1], "end": [100, 53], "kind": "commanddeclaration"}, {"full_name": "PUnit", "code": "inductive PUnit : Sort u where\n  \n  | unit : PUnit", "start": [103, 1], "end": [111, 17], "kind": "commanddeclaration"}, {"full_name": "Unit", "code": "abbrev Unit : Type := PUnit", "start": [113, 1], "end": [129, 28], "kind": "commanddeclaration"}, {"full_name": "Unit.unit", "code": "@[match_pattern] abbrev Unit.unit : Unit := PUnit.unit", "start": [131, 1], "end": [135, 55], "kind": "commanddeclaration"}, {"full_name": "lcErased", "code": "unsafe axiom lcErased : Type", "start": [137, 1], "end": [138, 29], "kind": "commanddeclaration"}, {"full_name": "lcProof", "code": "unsafe axiom lcProof {\u03b1 : Prop} : \u03b1", "start": [140, 1], "end": [149, 36], "kind": "commanddeclaration"}, {"full_name": "lcCast", "code": "unsafe axiom lcCast {\u03b1 : Sort u} {\u03b2 : Sort v} (a : \u03b1) : \u03b2", "start": [151, 1], "end": [154, 58], "kind": "commanddeclaration"}, {"full_name": "lcUnreachable", "code": "unsafe axiom lcUnreachable {\u03b1 : Sort u} : \u03b1", "start": [157, 1], "end": [169, 44], "kind": "commanddeclaration"}, {"full_name": "True", "code": "inductive True : Prop where\n  \n  | intro : True", "start": [171, 1], "end": [179, 17], "kind": "commanddeclaration"}, {"full_name": "False", "code": "inductive False : Prop", "start": [181, 1], "end": [189, 23], "kind": "commanddeclaration"}, {"full_name": "Empty", "code": "inductive Empty : Type", "start": [191, 1], "end": [195, 23], "kind": "commanddeclaration"}, {"full_name": "PEmpty", "code": "inductive PEmpty : Sort u where", "start": [198, 1], "end": [202, 32], "kind": "commanddeclaration"}, {"full_name": "Not", "code": "def Not (a : Prop) : Prop := a \u2192 False", "start": [204, 1], "end": [211, 39], "kind": "commanddeclaration"}, {"full_name": "False.elim", "code": "@[macro_inline] def False.elim {C : Sort u} (h : False) : C :=\n  h.rec", "start": [213, 1], "end": [224, 8], "kind": "commanddeclaration"}, {"full_name": "absurd", "code": "@[macro_inline] def absurd {a : Prop} {b : Sort v} (h\u2081 : a) (h\u2082 : Not a) : b :=\n  (h\u2082 h\u2081).rec", "start": [226, 1], "end": [234, 14], "kind": "commanddeclaration"}, {"full_name": "Eq", "code": "inductive Eq : \u03b1 \u2192 \u03b1 \u2192 Prop where\n  \n  | refl (a : \u03b1) : Eq a a", "start": [236, 1], "end": [266, 26], "kind": "commanddeclaration"}, {"full_name": "Eq.ndrec", "code": "@[simp] abbrev Eq.ndrec.{u1, u2} {\u03b1 : Sort u2} {a : \u03b1} {motive : \u03b1 \u2192 Sort u1} (m : motive a) {b : \u03b1} (h : Eq a b) : motive b :=\n  h.rec m", "start": [268, 1], "end": [270, 10], "kind": "commanddeclaration"}, {"full_name": "rfl", "code": "@[match_pattern] def rfl {\u03b1 : Sort u} {a : \u03b1} : Eq a a := Eq.refl a", "start": [272, 1], "end": [281, 68], "kind": "commanddeclaration"}, {"full_name": "id_eq", "code": "@[simp] theorem id_eq (a : \u03b1) : Eq (id a) a", "start": [283, 1], "end": [284, 51], "kind": "commanddeclaration"}, {"full_name": "Eq.subst", "code": "theorem Eq.subst {\u03b1 : Sort u} {motive : \u03b1 \u2192 Prop} {a b : \u03b1} (h\u2081 : Eq a b) (h\u2082 : motive a) : motive b", "start": [286, 1], "end": [300, 17], "kind": "commanddeclaration"}, {"full_name": "Eq.symm", "code": "theorem Eq.symm {\u03b1 : Sort u} {a b : \u03b1} (h : Eq a b) : Eq b a", "start": [302, 1], "end": [311, 10], "kind": "commanddeclaration"}, {"full_name": "Eq.trans", "code": "theorem Eq.trans {\u03b1 : Sort u} {a b c : \u03b1} (h\u2081 : Eq a b) (h\u2082 : Eq b c) : Eq a c", "start": [313, 1], "end": [323, 10], "kind": "commanddeclaration"}, {"full_name": "cast", "code": "@[macro_inline] def cast {\u03b1 \u03b2 : Sort u} (h : Eq \u03b1 \u03b2) (a : \u03b1) : \u03b2 :=\n  h.rec a", "start": [325, 1], "end": [337, 10], "kind": "commanddeclaration"}, {"full_name": "congrArg", "code": "theorem congrArg {\u03b1 : Sort u} {\u03b2 : Sort v} {a\u2081 a\u2082 : \u03b1} (f : \u03b1 \u2192 \u03b2) (h : Eq a\u2081 a\u2082) : Eq (f a\u2081) (f a\u2082)", "start": [339, 1], "end": [350, 10], "kind": "commanddeclaration"}, {"full_name": "congr", "code": "theorem congr {\u03b1 : Sort u} {\u03b2 : Sort v} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {a\u2081 a\u2082 : \u03b1} (h\u2081 : Eq f\u2081 f\u2082) (h\u2082 : Eq a\u2081 a\u2082) : Eq (f\u2081 a\u2081) (f\u2082 a\u2082)", "start": [352, 1], "end": [360, 16], "kind": "commanddeclaration"}, {"full_name": "congrFun", "code": "theorem congrFun {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x} (h : Eq f g) (a : \u03b1) : Eq (f a) (g a)", "start": [362, 1], "end": [364, 10], "kind": "commanddeclaration"}, {"full_name": "Quot.lcInv", "code": "unsafe axiom Quot.lcInv {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (q : Quot r) : \u03b1", "start": [426, 1], "end": [429, 73], "kind": "commanddeclaration"}, {"full_name": "HEq", "code": "inductive HEq : {\u03b1 : Sort u} \u2192 \u03b1 \u2192 {\u03b2 : Sort u} \u2192 \u03b2 \u2192 Prop where\n  \n  | refl (a : \u03b1) : HEq a a", "start": [431, 1], "end": [445, 27], "kind": "commanddeclaration"}, {"full_name": "HEq.rfl", "code": "@[match_pattern] protected def HEq.rfl {\u03b1 : Sort u} {a : \u03b1} : HEq a a :=\n  HEq.refl a", "start": [447, 1], "end": [449, 13], "kind": "commanddeclaration"}, {"full_name": "eq_of_heq", "code": "theorem eq_of_heq {\u03b1 : Sort u} {a a' : \u03b1} (h : HEq a a') : Eq a a'", "start": [451, 1], "end": [455, 22], "kind": "commanddeclaration"}, {"full_name": "Prod", "code": "structure Prod (\u03b1 : Type u) (\u03b2 : Type v) where\n  \n  fst : \u03b1\n  \n  snd : \u03b2", "start": [457, 1], "end": [470, 10], "kind": "commanddeclaration"}, {"full_name": "PProd", "code": "structure PProd (\u03b1 : Sort u) (\u03b2 : Sort v) where\n  \n  fst : \u03b1\n  \n  snd : \u03b2", "start": [474, 1], "end": [482, 10], "kind": "commanddeclaration"}, {"full_name": "MProd", "code": "structure MProd (\u03b1 \u03b2 : Type u) where\n  \n  fst : \u03b1\n  \n  snd : \u03b2", "start": [484, 1], "end": [492, 10], "kind": "commanddeclaration"}, {"full_name": "And", "code": "structure And (a b : Prop) : Prop where\n  \n  intro ::\n  \n  left : a\n  \n  right : b", "start": [494, 1], "end": [507, 12], "kind": "commanddeclaration"}, {"full_name": "Or", "code": "inductive Or (a b : Prop) : Prop where\n  \n  | inl (h : a) : Or a b\n  \n  | inr (h : b) : Or a b", "start": [509, 1], "end": [519, 25], "kind": "commanddeclaration"}, {"full_name": "Or.intro_left", "code": "theorem Or.intro_left (b : Prop) (h : a) : Or a b", "start": [521, 1], "end": [523, 11], "kind": "commanddeclaration"}, {"full_name": "Or.intro_right", "code": "theorem Or.intro_right (a : Prop) (h : b) : Or a b", "start": [525, 1], "end": [527, 11], "kind": "commanddeclaration"}, {"full_name": "Or.elim", "code": "theorem Or.elim {c : Prop} (h : Or a b) (left : a \u2192 c) (right : b \u2192 c) : c", "start": [529, 1], "end": [536, 24], "kind": "commanddeclaration"}, {"full_name": "Bool", "code": "inductive Bool : Type where\n  \n  | false : Bool\n  \n  | true : Bool", "start": [538, 1], "end": [549, 16], "kind": "commanddeclaration"}, {"full_name": "Subtype", "code": "structure Subtype {\u03b1 : Sort u} (p : \u03b1 \u2192 Prop) where\n  \n  val : \u03b1\n  \n  property : p val", "start": [553, 1], "end": [567, 19], "kind": "commanddeclaration"}, {"full_name": "optParam", "code": "@[reducible] def optParam (\u03b1 : Sort u) (default : \u03b1) : Sort u := \u03b1", "start": [570, 1], "end": [577, 67], "kind": "commanddeclaration"}, {"full_name": "outParam", "code": "@[reducible] def outParam (\u03b1 : Sort u) : Sort u := \u03b1", "start": [579, 1], "end": [595, 53], "kind": "commanddeclaration"}, {"full_name": "semiOutParam", "code": "@[reducible] def semiOutParam (\u03b1 : Sort u) : Sort u := \u03b1", "start": [597, 1], "end": [618, 57], "kind": "commanddeclaration"}, {"full_name": "namedPattern", "code": "@[reducible] def namedPattern {\u03b1 : Sort u} (x a : \u03b1) (h : Eq x a) : \u03b1 := a", "start": [621, 1], "end": [622, 75], "kind": "commanddeclaration"}, {"full_name": "sorryAx", "code": "@[extern \"lean_sorry\", never_extract]\naxiom sorryAx (\u03b1 : Sort u) (synthetic := false) : \u03b1", "start": [624, 1], "end": [641, 52], "kind": "commanddeclaration"}, {"full_name": "eq_false_of_ne_true", "code": "theorem eq_false_of_ne_true : {b : Bool} \u2192 Not (Eq b true) \u2192 Eq b false", "start": [643, 1], "end": [645, 20], "kind": "commanddeclaration"}, {"full_name": "eq_true_of_ne_false", "code": "theorem eq_true_of_ne_false : {b : Bool} \u2192 Not (Eq b false) \u2192 Eq b true", "start": [647, 1], "end": [649, 35], "kind": "commanddeclaration"}, {"full_name": "ne_false_of_eq_true", "code": "theorem ne_false_of_eq_true : {b : Bool} \u2192 Eq b true \u2192 Not (Eq b false)", "start": [651, 1], "end": [653, 35], "kind": "commanddeclaration"}, {"full_name": "ne_true_of_eq_false", "code": "theorem ne_true_of_eq_false : {b : Bool} \u2192 Eq b false \u2192 Not (Eq b true)", "start": [655, 1], "end": [657, 44], "kind": "commanddeclaration"}, {"full_name": "Inhabited", "code": "class Inhabited (\u03b1 : Sort u) where\n  \n  default : \u03b1", "start": [659, 1], "end": [674, 14], "kind": "commanddeclaration"}, {"full_name": "Nonempty", "code": "class inductive Nonempty (\u03b1 : Sort u) : Prop where\n  \n  | intro (val : \u03b1) : Nonempty \u03b1", "start": [678, 1], "end": [688, 33], "kind": "commanddeclaration"}, {"full_name": "Classical.choice", "code": "axiom Classical.choice {\u03b1 : Sort u} : Nonempty \u03b1 \u2192 \u03b1", "start": [690, 1], "end": [712, 53], "kind": "commanddeclaration"}, {"full_name": "Nonempty.elim", "code": "protected def Nonempty.elim {\u03b1 : Sort u} {p : Prop} (h\u2081 : Nonempty \u03b1) (h\u2082 : \u03b1 \u2192 p) : p :=\n  match h\u2081 with\n  | intro a => h\u2082 a", "start": [714, 1], "end": [722, 20], "kind": "commanddeclaration"}, {"full_name": "Classical.ofNonempty", "code": "noncomputable def Classical.ofNonempty {\u03b1 : Sort u} [Nonempty \u03b1] : \u03b1 :=\n  Classical.choice inferInstance", "start": [727, 1], "end": [732, 33], "kind": "commanddeclaration"}, {"full_name": "PLift", "code": "structure PLift (\u03b1 : Sort u) : Type u where\n      up ::\n   down : \u03b1", "start": [751, 1], "end": [754, 49], "kind": "commanddeclaration"}, {"full_name": "PLift.up_down", "code": "theorem PLift.up_down {\u03b1 : Sort u} (b : PLift \u03b1) : Eq (up (down b)) b", "start": [756, 1], "end": [757, 77], "kind": "commanddeclaration"}, {"full_name": "PLift.down_up", "code": "theorem PLift.down_up {\u03b1 : Sort u} (a : \u03b1) : Eq (down (up a)) a", "start": [759, 1], "end": [760, 71], "kind": "commanddeclaration"}, {"full_name": "NonemptyType", "code": "def NonemptyType := Subtype fun \u03b1 : Type u => Nonempty \u03b1", "start": [762, 1], "end": [768, 57], "kind": "commanddeclaration"}, {"full_name": "NonemptyType.type", "code": "abbrev NonemptyType.type (type : NonemptyType.{u}) : Type u :=\n  type.val", "start": [770, 1], "end": [772, 11], "kind": "commanddeclaration"}, {"full_name": "ULift", "code": "structure ULift.{r, s} (\u03b1 : Type s) : Type (max s r) where\n      up ::\n   down : \u03b1", "start": [778, 1], "end": [788, 49], "kind": "commanddeclaration"}, {"full_name": "ULift.up_down", "code": "theorem ULift.up_down {\u03b1 : Type u} (b : ULift.{v} \u03b1) : Eq (up (down b)) b", "start": [790, 1], "end": [791, 81], "kind": "commanddeclaration"}, {"full_name": "ULift.down_up", "code": "theorem ULift.down_up {\u03b1 : Type u} (a : \u03b1) : Eq (down (up.{v} a)) a", "start": [793, 1], "end": [794, 75], "kind": "commanddeclaration"}, {"full_name": "Decidable", "code": "class inductive Decidable (p : Prop) where\n  \n  | isFalse (h : Not p) : Decidable p\n  \n  | isTrue (h : p) : Decidable p", "start": [796, 1], "end": [814, 33], "kind": "commanddeclaration"}, {"full_name": "Decidable.decide", "code": "@[inline_if_reduce, nospecialize] def Decidable.decide (p : Prop) [h : Decidable p] : Bool :=\n  h.casesOn (fun _ => false) (fun _ => true)", "start": [816, 1], "end": [823, 45], "kind": "commanddeclaration"}, {"full_name": "DecidablePred", "code": "abbrev DecidablePred {\u03b1 : Sort u} (r : \u03b1 \u2192 Prop) :=\n  (a : \u03b1) \u2192 Decidable (r a)", "start": [827, 1], "end": [829, 28], "kind": "commanddeclaration"}, {"full_name": "DecidableRel", "code": "abbrev DecidableRel {\u03b1 : Sort u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :=\n  (a b : \u03b1) \u2192 Decidable (r a b)", "start": [831, 1], "end": [833, 32], "kind": "commanddeclaration"}, {"full_name": "DecidableEq", "code": "abbrev DecidableEq (\u03b1 : Sort u) :=\n  (a b : \u03b1) \u2192 Decidable (Eq a b)", "start": [835, 1], "end": [840, 33], "kind": "commanddeclaration"}, {"full_name": "decEq", "code": "def decEq {\u03b1 : Sort u} [inst : DecidableEq \u03b1] (a b : \u03b1) : Decidable (Eq a b) :=\n  inst a b", "start": [842, 1], "end": [844, 11], "kind": "commanddeclaration"}, {"full_name": "decide_eq_true", "code": "theorem decide_eq_true : [inst : Decidable p] \u2192 p \u2192 Eq (decide p) true", "start": [847, 1], "end": [849, 35], "kind": "commanddeclaration"}, {"full_name": "decide_eq_false", "code": "theorem decide_eq_false : [Decidable p] \u2192 Not p \u2192 Eq (decide p) false", "start": [851, 1], "end": [853, 26], "kind": "commanddeclaration"}, {"full_name": "of_decide_eq_true", "code": "theorem of_decide_eq_true [inst : Decidable p] : Eq (decide p) true \u2192 p", "start": [855, 1], "end": [858, 70], "kind": "commanddeclaration"}, {"full_name": "of_decide_eq_false", "code": "theorem of_decide_eq_false [inst : Decidable p] : Eq (decide p) false \u2192 Not p", "start": [860, 1], "end": [863, 21], "kind": "commanddeclaration"}, {"full_name": "of_decide_eq_self_eq_true", "code": "theorem of_decide_eq_self_eq_true [inst : DecidableEq \u03b1] (a : \u03b1) : Eq (decide (Eq a a)) true", "start": [865, 1], "end": [868, 32], "kind": "commanddeclaration"}, {"full_name": "Bool.decEq", "code": "@[inline] def Bool.decEq (a b : Bool) : Decidable (Eq a b) :=\n   match a, b with\n   | false, false => isTrue rfl\n   | false, true  => isFalse (fun h => Bool.noConfusion h)\n   | true, false  => isFalse (fun h => Bool.noConfusion h)\n   | true, true   => isTrue rfl", "start": [870, 1], "end": [876, 32], "kind": "commanddeclaration"}, {"full_name": "BEq", "code": "class BEq (\u03b1 : Type u) where\n  \n  beq : \u03b1 \u2192 \u03b1 \u2192 Bool", "start": [881, 1], "end": [891, 21], "kind": "commanddeclaration"}, {"full_name": "dite", "code": "@[macro_inline] def dite {\u03b1 : Sort u} (c : Prop) [h : Decidable c] (t : c \u2192 \u03b1) (e : Not c \u2192 \u03b1) : \u03b1 :=\n  h.casesOn e t", "start": [899, 1], "end": [914, 16], "kind": "commanddeclaration"}, {"full_name": "ite", "code": "@[macro_inline] def ite {\u03b1 : Sort u} (c : Prop) [h : Decidable c] (t e : \u03b1) : \u03b1 :=\n  h.casesOn (fun _ => e) (fun _ => t)", "start": [918, 1], "end": [936, 38], "kind": "commanddeclaration"}, {"full_name": "cond", "code": "@[macro_inline] def cond {\u03b1 : Type u} (c : Bool) (x y : \u03b1) : \u03b1 :=\n  match c with\n  | true  => x\n  | false => y", "start": [965, 1], "end": [974, 15], "kind": "commanddeclaration"}, {"full_name": "or", "code": "@[macro_inline] def or (x y : Bool) : Bool :=\n  match x with\n  | true  => true\n  | false => y", "start": [976, 1], "end": [985, 15], "kind": "commanddeclaration"}, {"full_name": "and", "code": "@[macro_inline] def and (x y : Bool) : Bool :=\n  match x with\n  | false => false\n  | true  => y", "start": [987, 1], "end": [996, 15], "kind": "commanddeclaration"}, {"full_name": "not", "code": "@[inline] def not : Bool \u2192 Bool\n  | true  => false\n  | false => true", "start": [998, 1], "end": [1004, 18], "kind": "commanddeclaration"}, {"full_name": "Nat", "code": "inductive Nat where\n  \n  | zero : Nat\n  \n  | succ (n : Nat) : Nat", "start": [1006, 1], "end": [1044, 25], "kind": "commanddeclaration"}, {"full_name": "OfNat", "code": "class OfNat (\u03b1 : Type u) (_ : Nat) where\n  \n  ofNat : \u03b1", "start": [1049, 1], "end": [1066, 12], "kind": "commanddeclaration"}, {"full_name": "LE", "code": "class LE (\u03b1 : Type u) where\n  \n  le : \u03b1 \u2192 \u03b1 \u2192 Prop", "start": [1072, 1], "end": [1075, 20], "kind": "commanddeclaration"}, {"full_name": "LT", "code": "class LT (\u03b1 : Type u) where\n  \n  lt : \u03b1 \u2192 \u03b1 \u2192 Prop", "start": [1077, 1], "end": [1080, 20], "kind": "commanddeclaration"}, {"full_name": "GE.ge", "code": "@[reducible] def GE.ge {\u03b1 : Type u} [LE \u03b1] (a b : \u03b1) : Prop := LE.le b a", "start": [1082, 1], "end": [1083, 73], "kind": "commanddeclaration"}, {"full_name": "GT.gt", "code": "@[reducible] def GT.gt {\u03b1 : Type u} [LT \u03b1] (a b : \u03b1) : Prop := LT.lt b a", "start": [1084, 1], "end": [1085, 73], "kind": "commanddeclaration"}, {"full_name": "Max", "code": "class Max (\u03b1 : Type u) where\n  \n  max : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1087, 1], "end": [1090, 18], "kind": "commanddeclaration"}, {"full_name": "maxOfLe", "code": "@[inline]\ndef maxOfLe [LE \u03b1] [DecidableRel (@LE.le \u03b1 _)] : Max \u03b1 where\n  max x y := ite (LE.le x y) y x", "start": [1094, 1], "end": [1098, 33], "kind": "commanddeclaration"}, {"full_name": "Min", "code": "class Min (\u03b1 : Type u) where\n  \n  min : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1100, 1], "end": [1103, 18], "kind": "commanddeclaration"}, {"full_name": "minOfLe", "code": "@[inline]\ndef minOfLe [LE \u03b1] [DecidableRel (@LE.le \u03b1 _)] : Min \u03b1 where\n  min x y := ite (LE.le x y) x y", "start": [1107, 1], "end": [1111, 33], "kind": "commanddeclaration"}, {"full_name": "Trans", "code": "class Trans (r : \u03b1 \u2192 \u03b2 \u2192 Sort u) (s : \u03b2 \u2192 \u03b3 \u2192 Sort v) (t : outParam (\u03b1 \u2192 \u03b3 \u2192 Sort w)) where\n  \n  trans : r a b \u2192 s b c \u2192 t a c", "start": [1113, 1], "end": [1124, 32], "kind": "commanddeclaration"}, {"full_name": "HAdd", "code": "class HAdd (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hAdd : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1134, 1], "end": [1141, 19], "kind": "commanddeclaration"}, {"full_name": "HSub", "code": "class HSub (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hSub : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1143, 1], "end": [1151, 19], "kind": "commanddeclaration"}, {"full_name": "HMul", "code": "class HMul (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hMul : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1153, 1], "end": [1160, 19], "kind": "commanddeclaration"}, {"full_name": "HDiv", "code": "class HDiv (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hDiv : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1162, 1], "end": [1173, 19], "kind": "commanddeclaration"}, {"full_name": "HMod", "code": "class HMod (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hMod : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1175, 1], "end": [1183, 19], "kind": "commanddeclaration"}, {"full_name": "HPow", "code": "class HPow (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hPow : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1185, 1], "end": [1192, 19], "kind": "commanddeclaration"}, {"full_name": "HAppend", "code": "class HAppend (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hAppend : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1194, 1], "end": [1201, 22], "kind": "commanddeclaration"}, {"full_name": "HOrElse", "code": "class HOrElse (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hOrElse : \u03b1 \u2192 (Unit \u2192 \u03b2) \u2192 \u03b3", "start": [1203, 1], "end": [1213, 31], "kind": "commanddeclaration"}, {"full_name": "HAndThen", "code": "class HAndThen (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hAndThen : \u03b1 \u2192 (Unit \u2192 \u03b2) \u2192 \u03b3", "start": [1215, 1], "end": [1225, 32], "kind": "commanddeclaration"}, {"full_name": "HAnd", "code": "class HAnd (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hAnd : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1227, 1], "end": [1231, 19], "kind": "commanddeclaration"}, {"full_name": "HXor", "code": "class HXor (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hXor : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1233, 1], "end": [1237, 19], "kind": "commanddeclaration"}, {"full_name": "HOr", "code": "class HOr (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hOr : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1239, 1], "end": [1243, 18], "kind": "commanddeclaration"}, {"full_name": "HShiftLeft", "code": "class HShiftLeft (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hShiftLeft : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1245, 1], "end": [1252, 25], "kind": "commanddeclaration"}, {"full_name": "HShiftRight", "code": "class HShiftRight (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hShiftRight : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [1254, 1], "end": [1260, 26], "kind": "commanddeclaration"}, {"full_name": "Add", "code": "class Add (\u03b1 : Type u) where\n  \n  add : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1262, 1], "end": [1265, 18], "kind": "commanddeclaration"}, {"full_name": "Sub", "code": "class Sub (\u03b1 : Type u) where\n  \n  sub : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1267, 1], "end": [1270, 18], "kind": "commanddeclaration"}, {"full_name": "Mul", "code": "class Mul (\u03b1 : Type u) where\n  \n  mul : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1272, 1], "end": [1275, 18], "kind": "commanddeclaration"}, {"full_name": "Neg", "code": "class Neg (\u03b1 : Type u) where\n  \n  neg : \u03b1 \u2192 \u03b1", "start": [1277, 1], "end": [1284, 14], "kind": "commanddeclaration"}, {"full_name": "Div", "code": "class Div (\u03b1 : Type u) where\n  \n  div : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1286, 1], "end": [1289, 18], "kind": "commanddeclaration"}, {"full_name": "Mod", "code": "class Mod (\u03b1 : Type u) where\n  \n  mod : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1291, 1], "end": [1294, 18], "kind": "commanddeclaration"}, {"full_name": "Pow", "code": "class Pow (\u03b1 : Type u) (\u03b2 : Type v) where\n  \n  pow : \u03b1 \u2192 \u03b2 \u2192 \u03b1", "start": [1296, 1], "end": [1303, 18], "kind": "commanddeclaration"}, {"full_name": "Append", "code": "class Append (\u03b1 : Type u) where\n  \n  append : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1305, 1], "end": [1308, 21], "kind": "commanddeclaration"}, {"full_name": "OrElse", "code": "class OrElse (\u03b1 : Type u) where\n  \n  orElse  : \u03b1 \u2192 (Unit \u2192 \u03b1) \u2192 \u03b1", "start": [1310, 1], "end": [1317, 31], "kind": "commanddeclaration"}, {"full_name": "AndThen", "code": "class AndThen (\u03b1 : Type u) where\n  \n  andThen : \u03b1 \u2192 (Unit \u2192 \u03b1) \u2192 \u03b1", "start": [1319, 1], "end": [1326, 31], "kind": "commanddeclaration"}, {"full_name": "AndOp", "code": "class AndOp (\u03b1 : Type u) where\n  \n  and : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1328, 1], "end": [1334, 18], "kind": "commanddeclaration"}, {"full_name": "Xor", "code": "class Xor (\u03b1 : Type u) where\n  \n  xor : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1336, 1], "end": [1339, 18], "kind": "commanddeclaration"}, {"full_name": "OrOp", "code": "class OrOp (\u03b1 : Type u) where\n  \n  or : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1341, 1], "end": [1347, 17], "kind": "commanddeclaration"}, {"full_name": "Complement", "code": "class Complement (\u03b1 : Type u) where\n  \n  complement : \u03b1 \u2192 \u03b1", "start": [1349, 1], "end": [1352, 21], "kind": "commanddeclaration"}, {"full_name": "ShiftLeft", "code": "class ShiftLeft (\u03b1 : Type u) where\n  \n  shiftLeft : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1354, 1], "end": [1357, 24], "kind": "commanddeclaration"}, {"full_name": "ShiftRight", "code": "class ShiftRight (\u03b1 : Type u) where\n  \n  shiftRight : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [1359, 1], "end": [1362, 25], "kind": "commanddeclaration"}, {"full_name": "Membership", "code": "class Membership (\u03b1 : outParam (Type u)) (\u03b3 : Type v) where\n  \n  mem : \u03b1 \u2192 \u03b3 \u2192 Prop", "start": [1425, 1], "end": [1432, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.add", "code": "@[extern \"lean_nat_add\"]\nprotected def Nat.add : (@& Nat) \u2192 (@& Nat) \u2192 Nat\n  | a, Nat.zero   => a\n  | a, Nat.succ b => Nat.succ (Nat.add a b)", "start": [1435, 1], "end": [1445, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.mul", "code": "@[extern \"lean_nat_mul\"]\nprotected def Nat.mul : (@& Nat) \u2192 (@& Nat) \u2192 Nat\n  | _, 0          => 0\n  | a, Nat.succ b => Nat.add (Nat.mul a b) a", "start": [1455, 1], "end": [1465, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.pow", "code": "@[extern \"lean_nat_pow\"]\nprotected def Nat.pow (m : @& Nat) : (@& Nat) \u2192 Nat\n  | 0      => 1\n  | succ n => Nat.mul (Nat.pow m n) m", "start": [1471, 1], "end": [1481, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.beq", "code": "@[extern \"lean_nat_dec_eq\"]\ndef Nat.beq : (@& Nat) \u2192 (@& Nat) \u2192 Bool\n  | zero,   zero   => true\n  | zero,   succ _ => false\n  | succ _, zero   => false\n  | succ n, succ m => beq n m", "start": [1487, 1], "end": [1499, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_beq_eq_true", "code": "theorem Nat.eq_of_beq_eq_true : {n m : Nat} \u2192 Eq (beq n m) true \u2192 Eq n m", "start": [1504, 1], "end": [1511, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.ne_of_beq_eq_false", "code": "theorem Nat.ne_of_beq_eq_false : {n m : Nat} \u2192 Eq (beq n m) false \u2192 Not (Eq n m)", "start": [1513, 1], "end": [1519, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.decEq", "code": "@[reducible, extern \"lean_nat_dec_eq\"]\nprotected def Nat.decEq (n m : @& Nat) : Decidable (Eq n m) :=\n  match h:beq n m with\n  | true  => isTrue (eq_of_beq_eq_true h)\n  | false => isFalse (ne_of_beq_eq_false h)", "start": [1521, 1], "end": [1532, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.ble", "code": "@[extern \"lean_nat_dec_le\"]\ndef Nat.ble : @& Nat \u2192 @& Nat \u2192 Bool\n  | zero,   zero   => true\n  | zero,   succ _ => true\n  | succ _, zero   => false\n  | succ n, succ m => ble n m", "start": [1537, 1], "end": [1549, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.le", "code": "protected inductive Nat.le (n : Nat) : Nat \u2192 Prop\n  \n  | refl     : Nat.le n n\n  \n  | step {m} : Nat.le n m \u2192 Nat.le n (succ m)", "start": [1551, 1], "end": [1559, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.lt", "code": "protected def Nat.lt (n m : Nat) : Prop :=\n  Nat.le (succ n) m", "start": [1564, 1], "end": [1566, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.not_succ_le_zero", "code": "theorem Nat.not_succ_le_zero : \u2200 (n : Nat), LE.le (succ n) 0 \u2192 False", "start": [1571, 1], "end": [1573, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.not_lt_zero", "code": "theorem Nat.not_lt_zero (n : Nat) : Not (LT.lt n 0)", "start": [1575, 1], "end": [1576, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_le", "code": "theorem Nat.zero_le : (n : Nat) \u2192 LE.le 0 n", "start": [1578, 1], "end": [1580, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_le_succ", "code": "theorem Nat.succ_le_succ : LE.le n m \u2192 LE.le (succ n) (succ m)", "start": [1582, 1], "end": [1584, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_lt_succ", "code": "theorem Nat.zero_lt_succ (n : Nat) : LT.lt 0 (succ n)", "start": [1586, 1], "end": [1587, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.le_step", "code": "theorem Nat.le_step (h : LE.le n m) : LE.le n (succ m)", "start": [1589, 1], "end": [1590, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.le_trans", "code": "protected theorem Nat.le_trans {n m k : Nat} : LE.le n m \u2192 LE.le m k \u2192 LE.le n k", "start": [1592, 1], "end": [1594, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_trans", "code": "protected theorem Nat.lt_trans {n m k : Nat} (h\u2081 : LT.lt n m) : LT.lt m k \u2192 LT.lt n k", "start": [1596, 1], "end": [1597, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.le_succ", "code": "theorem Nat.le_succ (n : Nat) : LE.le n (succ n)", "start": [1599, 1], "end": [1600, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.le_succ_of_le", "code": "theorem Nat.le_succ_of_le {n m : Nat} (h : LE.le n m) : LE.le n (succ m)", "start": [1602, 1], "end": [1603, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.le_refl", "code": "protected theorem Nat.le_refl (n : Nat) : LE.le n n", "start": [1605, 1], "end": [1606, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_pos", "code": "theorem Nat.succ_pos (n : Nat) : LT.lt 0 (succ n)", "start": [1608, 1], "end": [1609, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.pred", "code": "@[extern \"lean_nat_pred\"]\ndef Nat.pred : (@& Nat) \u2192 Nat\n  | 0      => 0\n  | succ a => a", "start": [1612, 1], "end": [1621, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_le_pred", "code": "theorem Nat.pred_le_pred : {n m : Nat} \u2192 LE.le n m \u2192 LE.le (pred n) (pred m)", "start": [1623, 1], "end": [1626, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_succ_le_succ", "code": "theorem Nat.le_of_succ_le_succ {n m : Nat} : LE.le (succ n) (succ m) \u2192 LE.le n m", "start": [1628, 1], "end": [1629, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_lt_succ", "code": "theorem Nat.le_of_lt_succ {m n : Nat} : LT.lt m (succ n) \u2192 LE.le m n", "start": [1631, 1], "end": [1632, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_or_lt_of_le", "code": "protected theorem Nat.eq_or_lt_of_le : {n m: Nat} \u2192 LE.le n m \u2192 Or (Eq n m) (LT.lt n m)", "start": [1634, 1], "end": [1642, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_or_ge", "code": "protected theorem Nat.lt_or_ge (n m : Nat) : Or (LT.lt n m) (GE.ge n m)", "start": [1644, 1], "end": [1653, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.not_succ_le_self", "code": "theorem Nat.not_succ_le_self : (n : Nat) \u2192 Not (LE.le (succ n) n)", "start": [1655, 1], "end": [1657, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_irrefl", "code": "protected theorem Nat.lt_irrefl (n : Nat) : Not (LT.lt n n)", "start": [1659, 1], "end": [1660, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_le_of_lt", "code": "protected theorem Nat.lt_of_le_of_lt {n m k : Nat} (h\u2081 : LE.le n m) (h\u2082 : LT.lt m k) : LT.lt n k", "start": [1662, 1], "end": [1663, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.le_antisymm", "code": "protected theorem Nat.le_antisymm {n m : Nat} (h\u2081 : LE.le n m) (h\u2082 : LE.le m n) : Eq n m", "start": [1665, 1], "end": [1668, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_le_of_ne", "code": "protected theorem Nat.lt_of_le_of_ne {n m : Nat} (h\u2081 : LE.le n m) (h\u2082 : Not (Eq n m)) : LT.lt n m", "start": [1670, 1], "end": [1673, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_ble_eq_true", "code": "theorem Nat.le_of_ble_eq_true (h : Eq (Nat.ble n m) true) : LE.le n m", "start": [1675, 1], "end": [1678, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.ble_self_eq_true", "code": "theorem Nat.ble_self_eq_true : (n : Nat) \u2192 Eq (Nat.ble n n) true", "start": [1680, 1], "end": [1682, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.ble_succ_eq_true", "code": "theorem Nat.ble_succ_eq_true : {n m : Nat} \u2192 Eq (Nat.ble n m) true \u2192 Eq (Nat.ble n (succ m)) true", "start": [1684, 1], "end": [1686, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.ble_eq_true_of_le", "code": "theorem Nat.ble_eq_true_of_le (h : LE.le n m) : Eq (Nat.ble n m) true", "start": [1688, 1], "end": [1691, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.not_le_of_not_ble_eq_true", "code": "theorem Nat.not_le_of_not_ble_eq_true (h : Not (Eq (Nat.ble n m) true)) : Not (LE.le n m)", "start": [1693, 1], "end": [1694, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.decLe", "code": "@[extern \"lean_nat_dec_le\"]\ninstance Nat.decLe (n m : @& Nat) : Decidable (LE.le n m) :=\n  dite (Eq (Nat.ble n m) true) (fun h => isTrue (Nat.le_of_ble_eq_true h)) (fun h => isFalse (Nat.not_le_of_not_ble_eq_true h))", "start": [1696, 1], "end": [1698, 128], "kind": "commanddeclaration"}, {"full_name": "Nat.decLt", "code": "@[extern \"lean_nat_dec_lt\"]\ninstance Nat.decLt (n m : @& Nat) : Decidable (LT.lt n m) :=\n  decLe (succ n) m", "start": [1700, 1], "end": [1702, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.sub", "code": "@[extern \"lean_nat_sub\"]\nprotected def Nat.sub : (@& Nat) \u2192 (@& Nat) \u2192 Nat\n  | a, 0      => a\n  | a, succ b => pred (Nat.sub a b)", "start": [1707, 1], "end": [1718, 36], "kind": "commanddeclaration"}, {"full_name": "System.Platform.getNumBits", "code": "@[extern \"lean_system_platform_nbits\"] opaque System.Platform.getNumBits : Unit \u2192 Subtype fun (n : Nat) => Or (Eq n 32) (Eq n 64) :=\n  fun _ => \u27e864, Or.inr rfl\u27e9", "start": [1723, 1], "end": [1732, 28], "kind": "commanddeclaration"}, {"full_name": "System.Platform.numBits", "code": "def System.Platform.numBits : Nat :=\n  (getNumBits ()).val", "start": [1734, 1], "end": [1736, 22], "kind": "commanddeclaration"}, {"full_name": "System.Platform.numBits_eq", "code": "theorem System.Platform.numBits_eq : Or (Eq numBits 32) (Eq numBits 64)", "start": [1738, 1], "end": [1739, 27], "kind": "commanddeclaration"}, {"full_name": "Fin", "code": "structure Fin (n : Nat) where\n  \n  val  : Nat\n  \n  isLt : LT.lt val n", "start": [1741, 1], "end": [1750, 21], "kind": "commanddeclaration"}, {"full_name": "Fin.eq_of_val_eq", "code": "theorem Fin.eq_of_val_eq {n} : \u2200 {i j : Fin n}, Eq i.val j.val \u2192 Eq i j", "start": [1752, 1], "end": [1753, 31], "kind": "commanddeclaration"}, {"full_name": "Fin.val_eq_of_eq", "code": "theorem Fin.val_eq_of_eq {n} {i j : Fin n} (h : Eq i j) : Eq i.val j.val", "start": [1755, 1], "end": [1756, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.ne_of_val_ne", "code": "theorem Fin.ne_of_val_ne {n} {i j : Fin n} (h : Not (Eq i.val j.val)) : Not (Eq i j)", "start": [1758, 1], "end": [1759, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.decLt", "code": "instance Fin.decLt {n} (a b : Fin n) : Decidable (LT.lt a b) := Nat.decLt ..", "start": [1773, 1], "end": [1773, 77], "kind": "commanddeclaration"}, {"full_name": "Fin.decLe", "code": "instance Fin.decLe {n} (a b : Fin n) : Decidable (LE.le a b) := Nat.decLe ..", "start": [1774, 1], "end": [1774, 77], "kind": "commanddeclaration"}, {"full_name": "UInt8.size", "code": "def UInt8.size : Nat := 256", "start": [1776, 1], "end": [1777, 28], "kind": "commanddeclaration"}, {"full_name": "UInt8", "code": "structure UInt8 where\n  \n  val : Fin UInt8.size", "start": [1779, 1], "end": [1786, 23], "kind": "commanddeclaration"}, {"full_name": "UInt8.ofNatCore", "code": "@[extern \"lean_uint8_of_nat\"]\ndef UInt8.ofNatCore (n : @& Nat) (h : LT.lt n UInt8.size) : UInt8 where\n  val := { val := n, isLt := h }", "start": [1791, 1], "end": [1797, 33], "kind": "commanddeclaration"}, {"full_name": "UInt8.decEq", "code": "@[extern \"lean_uint8_dec_eq\"]\ndef UInt8.decEq (a b : UInt8) : Decidable (Eq a b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 =>\n    dite (Eq n m) (fun h => isTrue (h \u25b8 rfl)) (fun h => isFalse (fun h' => UInt8.noConfusion h' (fun h' => absurd h' h)))", "start": [1800, 1], "end": [1808, 122], "kind": "commanddeclaration"}, {"full_name": "UInt16.size", "code": "def UInt16.size : Nat := 65536", "start": [1815, 1], "end": [1816, 31], "kind": "commanddeclaration"}, {"full_name": "UInt16", "code": "structure UInt16 where\n  \n  val : Fin UInt16.size", "start": [1818, 1], "end": [1825, 24], "kind": "commanddeclaration"}, {"full_name": "UInt16.ofNatCore", "code": "@[extern \"lean_uint16_of_nat\"]\ndef UInt16.ofNatCore (n : @& Nat) (h : LT.lt n UInt16.size) : UInt16 where\n  val := { val := n, isLt := h }", "start": [1830, 1], "end": [1836, 33], "kind": "commanddeclaration"}, {"full_name": "UInt16.decEq", "code": "@[extern \"lean_uint16_dec_eq\"]\ndef UInt16.decEq (a b : UInt16) : Decidable (Eq a b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 =>\n    dite (Eq n m) (fun h => isTrue (h \u25b8 rfl)) (fun h => isFalse (fun h' => UInt16.noConfusion h' (fun h' => absurd h' h)))", "start": [1839, 1], "end": [1847, 123], "kind": "commanddeclaration"}, {"full_name": "UInt32.size", "code": "def UInt32.size : Nat := 4294967296", "start": [1854, 1], "end": [1855, 36], "kind": "commanddeclaration"}, {"full_name": "UInt32", "code": "structure UInt32 where\n  \n  val : Fin UInt32.size", "start": [1857, 1], "end": [1864, 24], "kind": "commanddeclaration"}, {"full_name": "UInt32.ofNatCore", "code": "@[extern \"lean_uint32_of_nat\"]\ndef UInt32.ofNatCore (n : @& Nat) (h : LT.lt n UInt32.size) : UInt32 where\n  val := { val := n, isLt := h }", "start": [1869, 1], "end": [1875, 33], "kind": "commanddeclaration"}, {"full_name": "UInt32.toNat", "code": "@[extern \"lean_uint32_to_nat\"]\ndef UInt32.toNat (n : UInt32) : Nat := n.val.val", "start": [1877, 1], "end": [1882, 49], "kind": "commanddeclaration"}, {"full_name": "UInt32.decEq", "code": "@[extern \"lean_uint32_dec_eq\"]\ndef UInt32.decEq (a b : UInt32) : Decidable (Eq a b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 =>\n    dite (Eq n m) (fun h => isTrue (h \u25b8 rfl)) (fun h => isFalse (fun h' => UInt32.noConfusion h' (fun h' => absurd h' h)))", "start": [1885, 1], "end": [1893, 123], "kind": "commanddeclaration"}, {"full_name": "UInt32.decLt", "code": "@[extern \"lean_uint32_dec_lt\"]\ndef UInt32.decLt (a b : UInt32) : Decidable (LT.lt a b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (LT.lt n m))", "start": [1907, 1], "end": [1914, 56], "kind": "commanddeclaration"}, {"full_name": "UInt32.decLe", "code": "@[extern \"lean_uint32_dec_le\"]\ndef UInt32.decLe (a b : UInt32) : Decidable (LE.le a b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (LE.le n m))", "start": [1917, 1], "end": [1924, 56], "kind": "commanddeclaration"}, {"full_name": "UInt64.size", "code": "def UInt64.size : Nat := 18446744073709551616", "start": [1931, 1], "end": [1932, 46], "kind": "commanddeclaration"}, {"full_name": "UInt64", "code": "structure UInt64 where\n  \n  val : Fin UInt64.size", "start": [1933, 1], "end": [1940, 24], "kind": "commanddeclaration"}, {"full_name": "UInt64.ofNatCore", "code": "@[extern \"lean_uint64_of_nat\"]\ndef UInt64.ofNatCore (n : @& Nat) (h : LT.lt n UInt64.size) : UInt64 where\n  val := { val := n, isLt := h }", "start": [1945, 1], "end": [1951, 33], "kind": "commanddeclaration"}, {"full_name": "UInt64.decEq", "code": "@[extern \"lean_uint64_dec_eq\"]\ndef UInt64.decEq (a b : UInt64) : Decidable (Eq a b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 =>\n    dite (Eq n m) (fun h => isTrue (h \u25b8 rfl)) (fun h => isFalse (fun h' => UInt64.noConfusion h' (fun h' => absurd h' h)))", "start": [1954, 1], "end": [1962, 123], "kind": "commanddeclaration"}, {"full_name": "USize.size", "code": "def USize.size : Nat := hPow 2 System.Platform.numBits", "start": [1969, 1], "end": [1973, 55], "kind": "commanddeclaration"}, {"full_name": "usize_size_eq", "code": "theorem usize_size_eq : Or (Eq USize.size 4294967296) (Eq USize.size 18446744073709551616)", "start": [1975, 1], "end": [1979, 40], "kind": "commanddeclaration"}, {"full_name": "USize", "code": "structure USize where\n  \n  val : Fin USize.size", "start": [1981, 1], "end": [1991, 23], "kind": "commanddeclaration"}, {"full_name": "USize.ofNatCore", "code": "@[extern \"lean_usize_of_nat\"]\ndef USize.ofNatCore (n : @& Nat) (h : LT.lt n USize.size) : USize := {\n  val := { val := n, isLt := h }\n}", "start": [1996, 1], "end": [2003, 2], "kind": "commanddeclaration"}, {"full_name": "USize.decEq", "code": "@[extern \"lean_usize_dec_eq\"]\ndef USize.decEq (a b : USize) : Decidable (Eq a b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 =>\n    dite (Eq n m) (fun h =>isTrue (h \u25b8 rfl)) (fun h => isFalse (fun h' => USize.noConfusion h' (fun h' => absurd h' h)))", "start": [2006, 1], "end": [2014, 121], "kind": "commanddeclaration"}, {"full_name": "USize.ofNat32", "code": "@[extern \"lean_usize_of_nat\"]\ndef USize.ofNat32 (n : @& Nat) (h : LT.lt n 4294967296) : USize where\n  val := {\n    val  := n\n    isLt := match USize.size, usize_size_eq with\n      | _, Or.inl rfl => h\n      | _, Or.inr rfl => Nat.lt_trans h (by decide)\n  }", "start": [2023, 1], "end": [2035, 4], "kind": "commanddeclaration"}, {"full_name": "Nat.isValidChar", "code": "abbrev Nat.isValidChar (n : Nat) : Prop :=\n  Or (LT.lt n 0xd800) (And (LT.lt 0xdfff n) (LT.lt n 0x110000))", "start": [2037, 1], "end": [2042, 64], "kind": "commanddeclaration"}, {"full_name": "UInt32.isValidChar", "code": "abbrev UInt32.isValidChar (n : UInt32) : Prop :=\n  n.toNat.isValidChar", "start": [2044, 1], "end": [2049, 22], "kind": "commanddeclaration"}, {"full_name": "Char", "code": "structure Char where\n  \n  val   : UInt32\n  \n  valid : val.isValidChar", "start": [2051, 1], "end": [2057, 26], "kind": "commanddeclaration"}, {"full_name": "isValidChar_UInt32", "code": "private theorem isValidChar_UInt32 {n : Nat} (h : n.isValidChar) : LT.lt n UInt32.size", "start": [2059, 1], "end": [2062, 48], "kind": "commanddeclaration"}, {"full_name": "Char.ofNatAux", "code": "@[extern \"lean_uint32_of_nat\"]\ndef Char.ofNatAux (n : @& Nat) (h : n.isValidChar) : Char :=\n  { val := \u27e8{ val := n, isLt := isValidChar_UInt32 h }\u27e9, valid := h }", "start": [2064, 1], "end": [2070, 70], "kind": "commanddeclaration"}, {"full_name": "Char.ofNat", "code": "@[noinline, match_pattern]\ndef Char.ofNat (n : Nat) : Char :=\n  dite (n.isValidChar)\n    (fun h => Char.ofNatAux n h)\n    (fun _ => { val := \u27e8{ val := 0, isLt := by decide }\u27e9, valid := Or.inl (by decide) })", "start": [2072, 1], "end": [2080, 89], "kind": "commanddeclaration"}, {"full_name": "Char.eq_of_val_eq", "code": "theorem Char.eq_of_val_eq : \u2200 {c d : Char}, Eq c.val d.val \u2192 Eq c d", "start": [2082, 1], "end": [2083, 31], "kind": "commanddeclaration"}, {"full_name": "Char.val_eq_of_eq", "code": "theorem Char.val_eq_of_eq : \u2200 {c d : Char}, Eq c d \u2192 Eq c.val d.val", "start": [2085, 1], "end": [2086, 21], "kind": "commanddeclaration"}, {"full_name": "Char.ne_of_val_ne", "code": "theorem Char.ne_of_val_ne {c d : Char} (h : Not (Eq c.val d.val)) : Not (Eq c d)", "start": [2088, 1], "end": [2089, 39], "kind": "commanddeclaration"}, {"full_name": "Char.val_ne_of_ne", "code": "theorem Char.val_ne_of_ne {c d : Char} (h : Not (Eq c d)) : Not (Eq c.val d.val)", "start": [2091, 1], "end": [2092, 39], "kind": "commanddeclaration"}, {"full_name": "Char.utf8Size", "code": "def Char.utf8Size (c : Char) : UInt32 :=\n  let v := c.val\n  ite (LE.le v (UInt32.ofNatCore 0x7F (by decide)))\n    (UInt32.ofNatCore 1 (by decide))\n    (ite (LE.le v (UInt32.ofNatCore 0x7FF (by decide)))\n      (UInt32.ofNatCore 2 (by decide))\n      (ite (LE.le v (UInt32.ofNatCore 0xFFFF (by decide)))\n        (UInt32.ofNatCore 3 (by decide))\n        (UInt32.ofNatCore 4 (by decide))))", "start": [2100, 1], "end": [2109, 43], "kind": "commanddeclaration"}, {"full_name": "Option", "code": "inductive Option (\u03b1 : Type u) where\n  \n  | none : Option \u03b1\n  \n  | some (val : \u03b1) : Option \u03b1", "start": [2111, 1], "end": [2143, 30], "kind": "commanddeclaration"}, {"full_name": "Option.getD", "code": "@[macro_inline] def Option.getD : Option \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  | some x, _ => x\n  | none,   e => e", "start": [2152, 1], "end": [2161, 19], "kind": "commanddeclaration"}, {"full_name": "Option.map", "code": "@[inline] protected def Option.map (f : \u03b1 \u2192 \u03b2) : Option \u03b1 \u2192 Option \u03b2\n  | some x => some (f x)\n  | none   => none", "start": [2163, 1], "end": [2169, 19], "kind": "commanddeclaration"}, {"full_name": "List", "code": "inductive List (\u03b1 : Type u) where\n  \n  | nil : List \u03b1\n  \n  | cons (head : \u03b1) (tail : List \u03b1) : List \u03b1", "start": [2171, 1], "end": [2187, 45], "kind": "commanddeclaration"}, {"full_name": "List.hasDecEq", "code": "protected def List.hasDecEq {\u03b1 : Type u} [DecidableEq \u03b1] : (a b : List \u03b1) \u2192 Decidable (Eq a b)\n  | nil,       nil       => isTrue rfl\n  | cons _ _, nil        => isFalse (fun h => List.noConfusion h)\n  | nil,       cons _ _  => isFalse (fun h => List.noConfusion h)\n  | cons a as, cons b bs =>\n    match decEq a b with\n    | isTrue hab  =>\n      match List.hasDecEq as bs with\n      | isTrue habs  => isTrue (hab \u25b8 habs \u25b8 rfl)\n      | isFalse nabs => isFalse (fun h => List.noConfusion h (fun _ habs => absurd habs nabs))\n    | isFalse nab => isFalse (fun h => List.noConfusion h (fun hab _ => absurd hab nab))", "start": [2192, 1], "end": [2203, 89], "kind": "commanddeclaration"}, {"full_name": "List.foldl", "code": "@[specialize]\ndef List.foldl {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1) : (init : \u03b1) \u2192 List \u03b2 \u2192 \u03b1\n  | a, nil      => a\n  | a, cons b l => foldl f (f a b) l", "start": [2207, 1], "end": [2214, 37], "kind": "commanddeclaration"}, {"full_name": "List.set", "code": "def List.set : List \u03b1 \u2192 Nat \u2192 \u03b1 \u2192 List \u03b1\n  | cons _ as, 0,          b => cons b as\n  | cons a as, Nat.succ n, b => cons a (set as n b)\n  | nil,       _,          _ => nil", "start": [2216, 1], "end": [2223, 36], "kind": "commanddeclaration"}, {"full_name": "List.length", "code": "def List.length : List \u03b1 \u2192 Nat\n  | nil       => 0\n  | cons _ as => HAdd.hAdd (length as) 1", "start": [2225, 1], "end": [2234, 41], "kind": "commanddeclaration"}, {"full_name": "List.lengthTRAux", "code": "def List.lengthTRAux : List \u03b1 \u2192 Nat \u2192 Nat\n  | nil,       n => n\n  | cons _ as, n => lengthTRAux as (Nat.succ n)", "start": [2236, 1], "end": [2239, 48], "kind": "commanddeclaration"}, {"full_name": "List.lengthTR", "code": "def List.lengthTR (as : List \u03b1) : Nat :=\n  lengthTRAux as 0", "start": [2241, 1], "end": [2246, 19], "kind": "commanddeclaration"}, {"full_name": "List.length_cons", "code": "@[simp] theorem List.length_cons {\u03b1} (a : \u03b1) (as : List \u03b1) : Eq (cons a as).length as.length.succ", "start": [2248, 1], "end": [2249, 6], "kind": "commanddeclaration"}, {"full_name": "List.concat", "code": "def List.concat {\u03b1 : Type u} : List \u03b1 \u2192 \u03b1 \u2192 List \u03b1\n  | nil,       b => cons b nil\n  | cons a as, b => cons a (concat as b)", "start": [2251, 1], "end": [2254, 41], "kind": "commanddeclaration"}, {"full_name": "List.get", "code": "def List.get {\u03b1 : Type u} : (as : List \u03b1) \u2192 Fin as.length \u2192 \u03b1\n  | cons a _,  \u27e80, _\u27e9 => a\n  | cons _ as, \u27e8Nat.succ i, h\u27e9 => get as \u27e8i, Nat.le_of_succ_le_succ h\u27e9", "start": [2256, 1], "end": [2263, 71], "kind": "commanddeclaration"}, {"full_name": "String", "code": "structure String where\n  \n  mk ::\n  \n  data : List Char", "start": [2265, 1], "end": [2277, 19], "kind": "commanddeclaration"}, {"full_name": "String.decEq", "code": "@[extern \"lean_string_dec_eq\"]\ndef String.decEq (s\u2081 s\u2082 : @& String) : Decidable (Eq s\u2081 s\u2082) :=\n  match s\u2081, s\u2082 with\n  | \u27e8s\u2081\u27e9, \u27e8s\u2082\u27e9 =>\n    dite (Eq s\u2081 s\u2082) (fun h => isTrue (congrArg _ h)) (fun h => isFalse (fun h' => String.noConfusion h' (fun h' => absurd h' h)))", "start": [2282, 1], "end": [2290, 130], "kind": "commanddeclaration"}, {"full_name": "String.Pos", "code": "structure String.Pos where\n  \n  byteIdx : Nat := 0", "start": [2294, 1], "end": [2303, 21], "kind": "commanddeclaration"}, {"full_name": "Substring", "code": "structure Substring where\n  \n  str      : String\n  \n  startPos : String.Pos\n  \n  stopPos  : String.Pos", "start": [2313, 1], "end": [2325, 24], "kind": "commanddeclaration"}, {"full_name": "Substring.bsize", "code": "@[inline] def Substring.bsize : Substring \u2192 Nat\n  | \u27e8_, b, e\u27e9 => e.byteIdx.sub b.byteIdx", "start": [2330, 1], "end": [2332, 41], "kind": "commanddeclaration"}, {"full_name": "String.csize", "code": "def String.csize (c : Char) : Nat :=\n  c.utf8Size.toNat", "start": [2334, 1], "end": [2336, 19], "kind": "commanddeclaration"}, {"full_name": "String.utf8ByteSize", "code": "@[extern \"lean_string_utf8_byte_size\"]\ndef String.utf8ByteSize : (@& String) \u2192 Nat\n  | \u27e8s\u27e9 => go s\nwhere\n  go : List Char \u2192 Nat\n   | .nil       => 0\n   | .cons c cs => hAdd (go cs) (csize c)", "start": [2338, 1], "end": [2348, 42], "kind": "commanddeclaration"}, {"full_name": "String.endPos", "code": "@[inline] def String.endPos (s : String) : String.Pos where\n  byteIdx := utf8ByteSize s", "start": [2374, 1], "end": [2376, 28], "kind": "commanddeclaration"}, {"full_name": "String.toSubstring", "code": "@[inline] def String.toSubstring (s : String) : Substring where\n  str      := s\n  startPos := {}\n  stopPos  := s.endPos", "start": [2378, 1], "end": [2382, 23], "kind": "commanddeclaration"}, {"full_name": "String.toSubstring'", "code": "def String.toSubstring' (s : String) : Substring :=\n  s.toSubstring", "start": [2384, 1], "end": [2386, 16], "kind": "commanddeclaration"}, {"full_name": "unsafeCast", "code": "unsafe def unsafeCast {\u03b1 : Sort u} {\u03b2 : Sort v} (a : \u03b1) : \u03b2 :=\n  PLift.down (ULift.down.{max u v} (cast lcProof (ULift.up.{max u v} (PLift.up a))))", "start": [2388, 1], "end": [2413, 85], "kind": "commanddeclaration"}, {"full_name": "panicCore", "code": "@[never_extract, extern \"lean_panic_fn\"]\ndef panicCore {\u03b1 : Type u} [Inhabited \u03b1] (msg : String) : \u03b1 := default", "start": [2416, 1], "end": [2428, 71], "kind": "commanddeclaration"}, {"full_name": "panic", "code": "@[noinline, never_extract]\ndef panic {\u03b1 : Type u} [Inhabited \u03b1] (msg : String) : \u03b1 :=\n  panicCore msg", "start": [2430, 1], "end": [2443, 16], "kind": "commanddeclaration"}, {"full_name": "GetElem", "code": "class GetElem (cont : Type u) (idx : Type v) (elem : outParam (Type w)) (dom : outParam (cont \u2192 idx \u2192 Prop)) where\n  \n  getElem (xs : cont) (i : idx) (h : dom xs i) : elem", "start": [2448, 1], "end": [2481, 54], "kind": "commanddeclaration"}, {"full_name": "Array", "code": "structure Array (\u03b1 : Type u) where\n  \n  mk ::\n  \n  data : List \u03b1", "start": [2485, 1], "end": [2501, 16], "kind": "commanddeclaration"}, {"full_name": "Array.mkEmpty", "code": "@[extern \"lean_mk_empty_array_with_capacity\"]\ndef Array.mkEmpty {\u03b1 : Type u} (c : @& Nat) : Array \u03b1 where\n  data := List.nil", "start": [2506, 1], "end": [2509, 19], "kind": "commanddeclaration"}, {"full_name": "Array.empty", "code": "def Array.empty {\u03b1 : Type u} : Array \u03b1 := mkEmpty 0", "start": [2511, 1], "end": [2512, 52], "kind": "commanddeclaration"}, {"full_name": "Array.size", "code": "@[reducible, extern \"lean_array_get_size\"]\ndef Array.size {\u03b1 : Type u} (a : @& Array \u03b1) : Nat :=\n a.data.length", "start": [2514, 1], "end": [2517, 15], "kind": "commanddeclaration"}, {"full_name": "Array.get", "code": "@[extern \"lean_array_fget\"]\ndef Array.get {\u03b1 : Type u} (a : @& Array \u03b1) (i : @& Fin a.size) : \u03b1 :=\n  a.data.get i", "start": [2519, 1], "end": [2522, 15], "kind": "commanddeclaration"}, {"full_name": "Array.getD", "code": "@[inline] abbrev Array.getD (a : Array \u03b1) (i : Nat) (v\u2080 : \u03b1) : \u03b1 :=\n  dite (LT.lt i a.size) (fun h => a.get \u27e8i, h\u27e9) (fun _ => v\u2080)", "start": [2524, 1], "end": [2526, 62], "kind": "commanddeclaration"}, {"full_name": "Array.get!", "code": "@[extern \"lean_array_get\"]\ndef Array.get! {\u03b1 : Type u} [Inhabited \u03b1] (a : @& Array \u03b1) (i : @& Nat) : \u03b1 :=\n  Array.getD a i default", "start": [2528, 1], "end": [2531, 25], "kind": "commanddeclaration"}, {"full_name": "Array.push", "code": "@[extern \"lean_array_push\"]\ndef Array.push {\u03b1 : Type u} (a : Array \u03b1) (v : \u03b1) : Array \u03b1 where\n  data := List.concat a.data v", "start": [2536, 1], "end": [2542, 31], "kind": "commanddeclaration"}, {"full_name": "Array.mkArray0", "code": "def Array.mkArray0 {\u03b1 : Type u} : Array \u03b1 :=\n  mkEmpty 0", "start": [2544, 1], "end": [2546, 12], "kind": "commanddeclaration"}, {"full_name": "Array.mkArray1", "code": "def Array.mkArray1 {\u03b1 : Type u} (a\u2081 : \u03b1) : Array \u03b1 :=\n  (mkEmpty 1).push a\u2081", "start": [2548, 1], "end": [2550, 22], "kind": "commanddeclaration"}, {"full_name": "Array.mkArray2", "code": "def Array.mkArray2 {\u03b1 : Type u} (a\u2081 a\u2082 : \u03b1) : Array \u03b1 :=\n  ((mkEmpty 2).push a\u2081).push a\u2082", "start": [2552, 1], "end": [2554, 32], "kind": "commanddeclaration"}, {"full_name": "Array.mkArray3", "code": "def Array.mkArray3 {\u03b1 : Type u} (a\u2081 a\u2082 a\u2083 : \u03b1) : Array \u03b1 :=\n  (((mkEmpty 3).push a\u2081).push a\u2082).push a\u2083", "start": [2556, 1], "end": [2558, 42], "kind": "commanddeclaration"}, {"full_name": "Array.mkArray4", "code": "def Array.mkArray4 {\u03b1 : Type u} (a\u2081 a\u2082 a\u2083 a\u2084 : \u03b1) : Array \u03b1 :=\n  ((((mkEmpty 4).push a\u2081).push a\u2082).push a\u2083).push a\u2084", "start": [2560, 1], "end": [2562, 52], "kind": "commanddeclaration"}, {"full_name": "Array.mkArray5", "code": "def Array.mkArray5 {\u03b1 : Type u} (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 : \u03b1) : Array \u03b1 :=\n  (((((mkEmpty 5).push a\u2081).push a\u2082).push a\u2083).push a\u2084).push a\u2085", "start": [2564, 1], "end": [2566, 62], "kind": "commanddeclaration"}, {"full_name": "Array.mkArray6", "code": "def Array.mkArray6 {\u03b1 : Type u} (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 a\u2086 : \u03b1) : Array \u03b1 :=\n  ((((((mkEmpty 6).push a\u2081).push a\u2082).push a\u2083).push a\u2084).push a\u2085).push a\u2086", "start": [2568, 1], "end": [2570, 72], "kind": "commanddeclaration"}, {"full_name": "Array.mkArray7", "code": "def Array.mkArray7 {\u03b1 : Type u} (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 a\u2086 a\u2087 : \u03b1) : Array \u03b1 :=\n  (((((((mkEmpty 7).push a\u2081).push a\u2082).push a\u2083).push a\u2084).push a\u2085).push a\u2086).push a\u2087", "start": [2572, 1], "end": [2574, 82], "kind": "commanddeclaration"}, {"full_name": "Array.mkArray8", "code": "def Array.mkArray8 {\u03b1 : Type u} (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 a\u2086 a\u2087 a\u2088 : \u03b1) : Array \u03b1 :=\n  ((((((((mkEmpty 8).push a\u2081).push a\u2082).push a\u2083).push a\u2084).push a\u2085).push a\u2086).push a\u2087).push a\u2088", "start": [2576, 1], "end": [2578, 92], "kind": "commanddeclaration"}, {"full_name": "Array.set", "code": "@[extern \"lean_array_fset\"]\ndef Array.set (a : Array \u03b1) (i : @& Fin a.size) (v : \u03b1) : Array \u03b1 where\n  data := a.data.set i.val v", "start": [2580, 1], "end": [2588, 29], "kind": "commanddeclaration"}, {"full_name": "Array.setD", "code": "@[inline] def Array.setD (a : Array \u03b1) (i : Nat) (v : \u03b1) : Array \u03b1 :=\n  dite (LT.lt i a.size) (fun h => a.set \u27e8i, h\u27e9 v) (fun _ => a)", "start": [2590, 1], "end": [2597, 63], "kind": "commanddeclaration"}, {"full_name": "Array.set!", "code": "@[extern \"lean_array_set\"]\ndef Array.set! (a : Array \u03b1) (i : @& Nat) (v : \u03b1) : Array \u03b1 :=\n  Array.setD a i v", "start": [2599, 1], "end": [2607, 19], "kind": "commanddeclaration"}, {"full_name": "Array.appendCore", "code": "protected def Array.appendCore {\u03b1 : Type u}  (as : Array \u03b1) (bs : Array \u03b1) : Array \u03b1 :=\n  let rec loop (i : Nat) (j : Nat) (as : Array \u03b1) : Array \u03b1 :=\n    dite (LT.lt j bs.size)\n      (fun hlt =>\n        match i with\n        | 0           => as\n        | Nat.succ i' => loop i' (hAdd j 1) (as.push (bs.get \u27e8j, hlt\u27e9)))\n      (fun _ => as)\n  loop bs.size 0 as", "start": [2609, 1], "end": [2618, 20], "kind": "commanddeclaration"}, {"full_name": "Array.extract", "code": "def Array.extract (as : Array \u03b1) (start stop : Nat) : Array \u03b1 :=\n  let rec loop (i : Nat) (j : Nat) (bs : Array \u03b1) : Array \u03b1 :=\n    dite (LT.lt j as.size)\n      (fun hlt =>\n        match i with\n        | 0           => bs\n        | Nat.succ i' => loop i' (hAdd j 1) (bs.push (as.get \u27e8j, hlt\u27e9)))\n      (fun _ => bs)\n  let sz' := Nat.sub (min stop as.size) start\n  loop sz' start (mkEmpty sz')", "start": [2620, 1], "end": [2634, 31], "kind": "commanddeclaration"}, {"full_name": "List.toArrayAux", "code": "@[inline_if_reduce]\ndef List.toArrayAux : List \u03b1 \u2192 Array \u03b1 \u2192 Array \u03b1\n  | nil,       r => r\n  | cons a as, r => toArrayAux as (r.push a)", "start": [2636, 1], "end": [2640, 45], "kind": "commanddeclaration"}, {"full_name": "List.redLength", "code": "@[inline_if_reduce]\ndef List.redLength : List \u03b1 \u2192 Nat\n  | nil       => 0\n  | cons _ as => as.redLength.succ", "start": [2642, 1], "end": [2646, 35], "kind": "commanddeclaration"}, {"full_name": "List.toArray", "code": "@[inline, match_pattern, export lean_list_to_array]\ndef List.toArray (as : List \u03b1) : Array \u03b1 :=\n  as.toArrayAux (Array.mkEmpty as.redLength)", "start": [2648, 1], "end": [2656, 45], "kind": "commanddeclaration"}, {"full_name": "Bind", "code": "class Bind (m : Type u \u2192 Type v) where\n  \n  bind : {\u03b1 \u03b2 : Type u} \u2192 m \u03b1 \u2192 (\u03b1 \u2192 m \u03b2) \u2192 m \u03b2", "start": [2658, 1], "end": [2662, 48], "kind": "commanddeclaration"}, {"full_name": "Pure", "code": "class Pure (f : Type u \u2192 Type v) where\n  \n  pure {\u03b1 : Type u} : \u03b1 \u2192 f \u03b1", "start": [2666, 1], "end": [2670, 30], "kind": "commanddeclaration"}, {"full_name": "Functor", "code": "class Functor (f : Type u \u2192 Type v) : Type (max (u+1) v) where\n  \n  map : {\u03b1 \u03b2 : Type u} \u2192 (\u03b1 \u2192 \u03b2) \u2192 f \u03b1 \u2192 f \u03b2\n  \n  mapConst : {\u03b1 \u03b2 : Type u} \u2192 \u03b1 \u2192 f \u03b2 \u2192 f \u03b1 := Function.comp map (Function.const _)", "start": [2674, 1], "end": [2688, 84], "kind": "commanddeclaration"}, {"full_name": "Seq", "code": "class Seq (f : Type u \u2192 Type v) : Type (max (u+1) v) where\n  \n  seq : {\u03b1 \u03b2 : Type u} \u2192 f (\u03b1 \u2192 \u03b2) \u2192 (Unit \u2192 f \u03b1) \u2192 f \u03b2", "start": [2690, 1], "end": [2698, 56], "kind": "commanddeclaration"}, {"full_name": "SeqLeft", "code": "class SeqLeft (f : Type u \u2192 Type v) : Type (max (u+1) v) where\n  \n  seqLeft : {\u03b1 \u03b2 : Type u} \u2192 f \u03b1 \u2192 (Unit \u2192 f \u03b2) \u2192 f \u03b1", "start": [2700, 1], "end": [2707, 54], "kind": "commanddeclaration"}, {"full_name": "SeqRight", "code": "class SeqRight (f : Type u \u2192 Type v) : Type (max (u+1) v) where\n  \n  seqRight : {\u03b1 \u03b2 : Type u} \u2192 f \u03b1 \u2192 (Unit \u2192 f \u03b2) \u2192 f \u03b2", "start": [2709, 1], "end": [2716, 55], "kind": "commanddeclaration"}, {"full_name": "Applicative", "code": "class Applicative (f : Type u \u2192 Type v) extends Functor f, Pure f, Seq f, SeqLeft f, SeqRight f where\n  map      := fun x y => Seq.seq (pure x) fun _ => y\n  seqLeft  := fun a b => Seq.seq (Functor.map (Function.const _) a) b\n  seqRight := fun a b => Seq.seq (Functor.map (Function.const _ id) a) b", "start": [2718, 1], "end": [2733, 73], "kind": "commanddeclaration"}, {"full_name": "Monad", "code": "class Monad (m : Type u \u2192 Type v) extends Applicative m, Bind m : Type (max (u+1) v) where\n  map      f x := bind x (Function.comp pure f)\n  seq      f x := bind f fun y => Functor.map y (x ())\n  seqLeft  x y := bind x fun a => bind (y ()) (fun _ => pure a)\n  seqRight x y := bind x fun _ => y ()", "start": [2735, 1], "end": [2754, 39], "kind": "commanddeclaration"}, {"full_name": "Array.sequenceMap", "code": "def Array.sequenceMap {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : Array \u03b1) (f : \u03b1 \u2192 m \u03b2) : m (Array \u03b2) :=\n  let rec loop (i : Nat) (j : Nat) (bs : Array \u03b2) : m (Array \u03b2) :=\n    dite (LT.lt j as.size)\n      (fun hlt =>\n        match i with\n        | 0           => pure bs\n        | Nat.succ i' => Bind.bind (f (as.get \u27e8j, hlt\u27e9)) fun b => loop i' (hAdd j 1) (bs.push b))\n      (fun _ => pure bs)\n  loop as.size 0 (Array.mkEmpty as.size)", "start": [2765, 1], "end": [2774, 41], "kind": "commanddeclaration"}, {"full_name": "MonadLift", "code": "class MonadLift (m : semiOutParam (Type u \u2192 Type v)) (n : Type u \u2192 Type w) where\n  \n  monadLift : {\u03b1 : Type u} \u2192 m \u03b1 \u2192 n \u03b1", "start": [2776, 1], "end": [2786, 39], "kind": "commanddeclaration"}, {"full_name": "MonadLiftT", "code": "class MonadLiftT (m : Type u \u2192 Type v) (n : Type u \u2192 Type w) where\n  \n  monadLift : {\u03b1 : Type u} \u2192 m \u03b1 \u2192 n \u03b1", "start": [2788, 1], "end": [2797, 39], "kind": "commanddeclaration"}, {"full_name": "liftM", "code": "abbrev liftM := @monadLift", "start": [2801, 1], "end": [2802, 27], "kind": "commanddeclaration"}, {"full_name": "MonadFunctor", "code": "class MonadFunctor (m : semiOutParam (Type u \u2192 Type v)) (n : Type u \u2192 Type w) where\n  \n  monadMap {\u03b1 : Type u} : ({\u03b2 : Type u} \u2192 m \u03b2 \u2192 m \u03b2) \u2192 n \u03b1 \u2192 n \u03b1", "start": [2811, 1], "end": [2822, 65], "kind": "commanddeclaration"}, {"full_name": "MonadFunctorT", "code": "class MonadFunctorT (m : Type u \u2192 Type v) (n : Type u \u2192 Type w) where\n  \n  monadMap {\u03b1 : Type u} : ({\u03b2 : Type u} \u2192 m \u03b2 \u2192 m \u03b2) \u2192 n \u03b1 \u2192 n \u03b1", "start": [2824, 1], "end": [2829, 65], "kind": "commanddeclaration"}, {"full_name": "monadFunctorRefl", "code": "instance monadFunctorRefl (m) : MonadFunctorT m m where\n  monadMap f := f", "start": [2837, 1], "end": [2838, 18], "kind": "commanddeclaration"}, {"full_name": "Except", "code": "inductive Except (\u03b5 : Type u) (\u03b1 : Type v) where\n  \n  | error : \u03b5 \u2192 Except \u03b5 \u03b1\n  \n  | ok    : \u03b1 \u2192 Except \u03b5 \u03b1", "start": [2840, 1], "end": [2850, 27], "kind": "commanddeclaration"}, {"full_name": "MonadExceptOf", "code": "class MonadExceptOf (\u03b5 : semiOutParam (Type u)) (m : Type v \u2192 Type w) where\n  \n  throw {\u03b1 : Type v} : \u03b5 \u2192 m \u03b1\n  \n  tryCatch {\u03b1 : Type v} (body : m \u03b1) (handler : \u03b5 \u2192 m \u03b1) : m \u03b1", "start": [2857, 1], "end": [2879, 63], "kind": "commanddeclaration"}, {"full_name": "throwThe", "code": "abbrev throwThe (\u03b5 : Type u) {m : Type v \u2192 Type w} [MonadExceptOf \u03b5 m] {\u03b1 : Type v} (e : \u03b5) : m \u03b1 :=\n  MonadExceptOf.throw e", "start": [2881, 1], "end": [2886, 24], "kind": "commanddeclaration"}, {"full_name": "tryCatchThe", "code": "abbrev tryCatchThe (\u03b5 : Type u) {m : Type v \u2192 Type w} [MonadExceptOf \u03b5 m] {\u03b1 : Type v} (x : m \u03b1) (handle : \u03b5 \u2192 m \u03b1) : m \u03b1 :=\n  MonadExceptOf.tryCatch x handle", "start": [2888, 1], "end": [2893, 34], "kind": "commanddeclaration"}, {"full_name": "MonadExcept", "code": "class MonadExcept (\u03b5 : outParam (Type u)) (m : Type v \u2192 Type w) where\n  \n  throw {\u03b1 : Type v} : \u03b5 \u2192 m \u03b1\n  \n  tryCatch {\u03b1 : Type v} : m \u03b1 \u2192 (\u03b5 \u2192 m \u03b1) \u2192 m \u03b1", "start": [2895, 1], "end": [2903, 48], "kind": "commanddeclaration"}, {"full_name": "MonadExcept.ofExcept", "code": "def MonadExcept.ofExcept [Monad m] [MonadExcept \u03b5 m] : Except \u03b5 \u03b1 \u2192 m \u03b1\n  | .ok a    => pure a\n  | .error e => throw e", "start": [2905, 1], "end": [2908, 24], "kind": "commanddeclaration"}, {"full_name": "MonadExcept.orElse", "code": "@[inline] protected def orElse [MonadExcept \u03b5 m] {\u03b1 : Type v} (t\u2081 : m \u03b1) (t\u2082 : Unit \u2192 m \u03b1) : m \u03b1 :=\n  tryCatch t\u2081 fun _ => t\u2082 ()", "start": [2919, 1], "end": [2921, 29], "kind": "commanddeclaration"}, {"full_name": "ReaderT", "code": "def ReaderT (\u03c1 : Type u) (m : Type u \u2192 Type v) (\u03b1 : Type u) : Type (max u v) :=\n  \u03c1 \u2192 m \u03b1", "start": [2928, 1], "end": [2935, 10], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run", "code": "@[always_inline, inline]\ndef ReaderT.run {\u03c1 : Type u} {m : Type u \u2192 Type v} {\u03b1 : Type u} (x : ReaderT \u03c1 m \u03b1) (r : \u03c1) : m \u03b1 :=\n  x r", "start": [2940, 1], "end": [2946, 6], "kind": "commanddeclaration"}, {"full_name": "ReaderT.read", "code": "@[always_inline, inline]\nprotected def read [Monad m] : ReaderT \u03c1 m \u03c1 :=\n  pure", "start": [2966, 1], "end": [2969, 7], "kind": "commanddeclaration"}, {"full_name": "ReaderT.pure", "code": "@[always_inline, inline]\nprotected def pure [Monad m] {\u03b1} (a : \u03b1) : ReaderT \u03c1 m \u03b1 :=\n  fun _ => pure a", "start": [2971, 1], "end": [2974, 18], "kind": "commanddeclaration"}, {"full_name": "ReaderT.bind", "code": "@[always_inline, inline]\nprotected def bind [Monad m] {\u03b1 \u03b2} (x : ReaderT \u03c1 m \u03b1) (f : \u03b1 \u2192 ReaderT \u03c1 m \u03b2) : ReaderT \u03c1 m \u03b2 :=\n  fun r => bind (x r) fun a => f a r", "start": [2976, 1], "end": [2979, 37], "kind": "commanddeclaration"}, {"full_name": "ReaderT.adapt", "code": "@[always_inline, inline]\nprotected def adapt {\u03c1' \u03b1 : Type u} (f : \u03c1' \u2192 \u03c1) : ReaderT \u03c1 m \u03b1 \u2192 ReaderT \u03c1' m \u03b1 :=\n  fun x r => x (f r)", "start": [2999, 1], "end": [3005, 21], "kind": "commanddeclaration"}, {"full_name": "MonadReaderOf", "code": "class MonadReaderOf (\u03c1 : semiOutParam (Type u)) (m : Type u \u2192 Type v) where\n  \n  read : m \u03c1", "start": [3010, 1], "end": [3026, 13], "kind": "commanddeclaration"}, {"full_name": "readThe", "code": "@[always_inline, inline]\ndef readThe (\u03c1 : Type u) {m : Type u \u2192 Type v} [MonadReaderOf \u03c1 m] : m \u03c1 :=\n  MonadReaderOf.read", "start": [3028, 1], "end": [3034, 21], "kind": "commanddeclaration"}, {"full_name": "MonadReader", "code": "class MonadReader (\u03c1 : outParam (Type u)) (m : Type u \u2192 Type v) where\n  \n  read : m \u03c1", "start": [3036, 1], "end": [3039, 13], "kind": "commanddeclaration"}, {"full_name": "MonadWithReaderOf", "code": "class MonadWithReaderOf (\u03c1 : semiOutParam (Type u)) (m : Type u \u2192 Type v) where\n  \n  withReader {\u03b1 : Type u} : (\u03c1 \u2192 \u03c1) \u2192 m \u03b1 \u2192 m \u03b1", "start": [3052, 1], "end": [3062, 48], "kind": "commanddeclaration"}, {"full_name": "withTheReader", "code": "@[always_inline, inline]\ndef withTheReader (\u03c1 : Type u) {m : Type u \u2192 Type v} [MonadWithReaderOf \u03c1 m] {\u03b1 : Type u} (f : \u03c1 \u2192 \u03c1) (x : m \u03b1) : m \u03b1 :=\n  MonadWithReaderOf.withReader f x", "start": [3064, 1], "end": [3070, 35], "kind": "commanddeclaration"}, {"full_name": "MonadWithReader", "code": "class MonadWithReader (\u03c1 : outParam (Type u)) (m : Type u \u2192 Type v) where\n  \n  withReader {\u03b1 : Type u} : (\u03c1 \u2192 \u03c1) \u2192 m \u03b1 \u2192 m \u03b1", "start": [3072, 1], "end": [3076, 48], "kind": "commanddeclaration"}, {"full_name": "MonadStateOf", "code": "class MonadStateOf (\u03c3 : semiOutParam (Type u)) (m : Type u \u2192 Type v) where\n  \n  get : m \u03c3\n  \n  set : \u03c3 \u2192 m PUnit\n  \n  modifyGet {\u03b1 : Type u} : (\u03c3 \u2192 Prod \u03b1 \u03c3) \u2192 m \u03b1", "start": [3089, 1], "end": [3106, 48], "kind": "commanddeclaration"}, {"full_name": "getThe", "code": "abbrev getThe (\u03c3 : Type u) {m : Type u \u2192 Type v} [MonadStateOf \u03c3 m] : m \u03c3 :=\n  MonadStateOf.get", "start": [3110, 1], "end": [3115, 19], "kind": "commanddeclaration"}, {"full_name": "modifyThe", "code": "@[always_inline, inline]\nabbrev modifyThe (\u03c3 : Type u) {m : Type u \u2192 Type v} [MonadStateOf \u03c3 m] (f : \u03c3 \u2192 \u03c3) : m PUnit :=\n  MonadStateOf.modifyGet fun s => (PUnit.unit, f s)", "start": [3117, 1], "end": [3123, 52], "kind": "commanddeclaration"}, {"full_name": "modifyGetThe", "code": "@[always_inline, inline]\nabbrev modifyGetThe {\u03b1 : Type u} (\u03c3 : Type u) {m : Type u \u2192 Type v} [MonadStateOf \u03c3 m] (f : \u03c3 \u2192 Prod \u03b1 \u03c3) : m \u03b1 :=\n  MonadStateOf.modifyGet f", "start": [3125, 1], "end": [3131, 27], "kind": "commanddeclaration"}, {"full_name": "MonadState", "code": "class MonadState (\u03c3 : outParam (Type u)) (m : Type u \u2192 Type v) where\n  \n  get : m \u03c3\n  \n  set : \u03c3 \u2192 m PUnit\n  \n  modifyGet {\u03b1 : Type u} : (\u03c3 \u2192 Prod \u03b1 \u03c3) \u2192 m \u03b1", "start": [3133, 1], "end": [3145, 48], "kind": "commanddeclaration"}, {"full_name": "modify", "code": "@[always_inline, inline]\ndef modify {\u03c3 : Type u} {m : Type u \u2192 Type v} [MonadState \u03c3 m] (f : \u03c3 \u2192 \u03c3) : m PUnit :=\n  modifyGet fun s => (PUnit.unit, f s)", "start": [3154, 1], "end": [3162, 39], "kind": "commanddeclaration"}, {"full_name": "getModify", "code": "@[always_inline, inline]\ndef getModify {\u03c3 : Type u} {m : Type u \u2192 Type v} [MonadState \u03c3 m] [Monad m] (f : \u03c3 \u2192 \u03c3) : m \u03c3 :=\n  modifyGet fun s => (s, f s)", "start": [3164, 1], "end": [3170, 30], "kind": "commanddeclaration"}, {"full_name": "EStateM.Result", "code": "inductive Result (\u03b5 \u03c3 \u03b1 : Type u) where\n  \n  | ok    : \u03b1 \u2192 \u03c3 \u2192 Result \u03b5 \u03c3 \u03b1\n  \n  | error : \u03b5 \u2192 \u03c3 \u2192 Result \u03b5 \u03c3 \u03b1", "start": [3182, 1], "end": [3190, 33], "kind": "commanddeclaration"}, {"full_name": "EStateM", "code": "def EStateM (\u03b5 \u03c3 \u03b1 : Type u) := \u03c3 \u2192 Result \u03b5 \u03c3 \u03b1", "start": [3200, 1], "end": [3204, 49], "kind": "commanddeclaration"}, {"full_name": "EStateM.pure", "code": "@[always_inline, inline]\nprotected def pure (a : \u03b1) : EStateM \u03b5 \u03c3 \u03b1 := fun s =>\n  Result.ok a s", "start": [3213, 1], "end": [3216, 16], "kind": "commanddeclaration"}, {"full_name": "EStateM.set", "code": "@[always_inline, inline]\nprotected def set (s : \u03c3) : EStateM \u03b5 \u03c3 PUnit := fun _ =>\n  Result.ok \u27e8\u27e9 s", "start": [3218, 1], "end": [3221, 17], "kind": "commanddeclaration"}, {"full_name": "EStateM.get", "code": "@[always_inline, inline]\nprotected def get : EStateM \u03b5 \u03c3 \u03c3 := fun s =>\n  Result.ok s s", "start": [3223, 1], "end": [3226, 16], "kind": "commanddeclaration"}, {"full_name": "EStateM.modifyGet", "code": "@[always_inline, inline]\nprotected def modifyGet (f : \u03c3 \u2192 Prod \u03b1 \u03c3) : EStateM \u03b5 \u03c3 \u03b1 := fun s =>\n  match f s with\n  | (a, s) => Result.ok a s", "start": [3228, 1], "end": [3232, 28], "kind": "commanddeclaration"}, {"full_name": "EStateM.throw", "code": "@[always_inline, inline]\nprotected def throw (e : \u03b5) : EStateM \u03b5 \u03c3 \u03b1 := fun s =>\n  Result.error e s", "start": [3234, 1], "end": [3237, 19], "kind": "commanddeclaration"}, {"full_name": "EStateM.Backtrackable", "code": "class Backtrackable (\u03b4 : outParam (Type u)) (\u03c3 : Type u) where\n  \n  save    : \u03c3 \u2192 \u03b4\n  \n  restore : \u03c3 \u2192 \u03b4 \u2192 \u03c3", "start": [3239, 1], "end": [3249, 22], "kind": "commanddeclaration"}, {"full_name": "EStateM.tryCatch", "code": "@[always_inline, inline]\nprotected def tryCatch {\u03b4} [Backtrackable \u03b4 \u03c3] {\u03b1} (x : EStateM \u03b5 \u03c3 \u03b1) (handle : \u03b5 \u2192 EStateM \u03b5 \u03c3 \u03b1) : EStateM \u03b5 \u03c3 \u03b1 := fun s =>\n  let d := Backtrackable.save s\n  match x s with\n  | Result.error e s => handle e (Backtrackable.restore s d)\n  | ok               => ok", "start": [3251, 1], "end": [3257, 27], "kind": "commanddeclaration"}, {"full_name": "EStateM.orElse", "code": "@[always_inline, inline]\nprotected def orElse {\u03b4} [Backtrackable \u03b4 \u03c3] (x\u2081 : EStateM \u03b5 \u03c3 \u03b1) (x\u2082 : Unit \u2192 EStateM \u03b5 \u03c3 \u03b1) : EStateM \u03b5 \u03c3 \u03b1 := fun s =>\n  let d := Backtrackable.save s;\n  match x\u2081 s with\n  | Result.error _ s => x\u2082 () (Backtrackable.restore s d)\n  | ok               => ok", "start": [3259, 1], "end": [3265, 27], "kind": "commanddeclaration"}, {"full_name": "EStateM.adaptExcept", "code": "@[always_inline, inline]\ndef adaptExcept {\u03b5' : Type u} (f : \u03b5 \u2192 \u03b5') (x : EStateM \u03b5 \u03c3 \u03b1) : EStateM \u03b5' \u03c3 \u03b1 := fun s =>\n  match x s with\n  | Result.error e s => Result.error (f e) s\n  | Result.ok a s    => Result.ok a s", "start": [3267, 1], "end": [3272, 38], "kind": "commanddeclaration"}, {"full_name": "EStateM.bind", "code": "@[always_inline, inline]\nprotected def bind (x : EStateM \u03b5 \u03c3 \u03b1) (f : \u03b1 \u2192 EStateM \u03b5 \u03c3 \u03b2) : EStateM \u03b5 \u03c3 \u03b2 := fun s =>\n  match x s with\n  | Result.ok a s    => f a s\n  | Result.error e s => Result.error e s", "start": [3274, 1], "end": [3279, 41], "kind": "commanddeclaration"}, {"full_name": "EStateM.map", "code": "@[always_inline, inline]\nprotected def map (f : \u03b1 \u2192 \u03b2) (x : EStateM \u03b5 \u03c3 \u03b1) : EStateM \u03b5 \u03c3 \u03b2 := fun s =>\n  match x s with\n  | Result.ok a s    => Result.ok (f a) s\n  | Result.error e s => Result.error e s", "start": [3281, 1], "end": [3286, 41], "kind": "commanddeclaration"}, {"full_name": "EStateM.seqRight", "code": "@[always_inline, inline]\nprotected def seqRight (x : EStateM \u03b5 \u03c3 \u03b1) (y : Unit \u2192 EStateM \u03b5 \u03c3 \u03b2) : EStateM \u03b5 \u03c3 \u03b2 := fun s =>\n  match x s with\n  | Result.ok _ s    => y () s\n  | Result.error e s => Result.error e s", "start": [3288, 1], "end": [3293, 41], "kind": "commanddeclaration"}, {"full_name": "EStateM.run", "code": "@[always_inline, inline]\ndef run (x : EStateM \u03b5 \u03c3 \u03b1) (s : \u03c3) : Result \u03b5 \u03c3 \u03b1 := x s", "start": [3314, 1], "end": [3316, 58], "kind": "commanddeclaration"}, {"full_name": "EStateM.run'", "code": "@[always_inline, inline]\ndef run' (x : EStateM \u03b5 \u03c3 \u03b1) (s : \u03c3) : Option \u03b1 :=\n  match run x s with\n  | Result.ok v _   => some v\n  | Result.error .. => none", "start": [3318, 1], "end": [3326, 28], "kind": "commanddeclaration"}, {"full_name": "EStateM.dummySave", "code": "@[inline] def dummySave : \u03c3 \u2192 PUnit := fun _ => \u27e8\u27e9", "start": [3328, 1], "end": [3329, 51], "kind": "commanddeclaration"}, {"full_name": "EStateM.dummyRestore", "code": "@[inline] def dummyRestore : \u03c3 \u2192 PUnit \u2192 \u03c3 := fun s _ => s", "start": [3331, 1], "end": [3332, 59], "kind": "commanddeclaration"}, {"full_name": "EStateM.nonBacktrackable", "code": "instance nonBacktrackable : Backtrackable PUnit \u03c3 where\n  save    := dummySave\n  restore := dummyRestore", "start": [3334, 1], "end": [3342, 26], "kind": "commanddeclaration"}, {"full_name": "Hashable", "code": "class Hashable (\u03b1 : Sort u) where\n  \n  hash : \u03b1 \u2192 UInt64", "start": [3346, 1], "end": [3349, 20], "kind": "commanddeclaration"}, {"full_name": "UInt64.toUSize", "code": "@[extern \"lean_uint64_to_usize\"]\nopaque UInt64.toUSize (u : UInt64) : USize", "start": [3353, 1], "end": [3355, 43], "kind": "commanddeclaration"}, {"full_name": "USize.toUInt64", "code": "@[extern \"lean_usize_to_uint64\"]\ndef USize.toUInt64 (u : USize) : UInt64 where\n  val := {\n    val  := u.val.val\n    isLt :=\n      let \u27e8n, h\u27e9 := u\n      show LT.lt n _ from\n      match USize.size, usize_size_eq, h with\n      | _, Or.inl rfl, h => Nat.lt_trans h (by decide)\n      | _, Or.inr rfl, h => h\n  }", "start": [3357, 1], "end": [3372, 4], "kind": "commanddeclaration"}, {"full_name": "mixHash", "code": "@[extern \"lean_uint64_mix_hash\"]\nopaque mixHash (u\u2081 u\u2082 : UInt64) : UInt64", "start": [3374, 1], "end": [3376, 41], "kind": "commanddeclaration"}, {"full_name": "String.hash", "code": "@[extern \"lean_string_hash\"]\nprotected opaque String.hash (s : @& String) : UInt64", "start": [3381, 1], "end": [3383, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Name", "code": "inductive Name where\n  \n  | anonymous : Name\n  \n  | str (pre : Name) (str : String)\n  \n  | num (pre : Name) (i : Nat)\nwith\n  \n  @[computed_field] hash : Name \u2192 UInt64\n    | .anonymous => .ofNatCore 1723 (by decide)\n    | .str p s => mixHash p.hash s.hash\n    | .num p v => mixHash p.hash (dite (LT.lt v UInt64.size) (fun h => UInt64.ofNatCore v h) (fun _ => UInt64.ofNatCore 17 (by decide)))", "start": [3390, 1], "end": [3430, 137], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkStr", "code": "@[export lean_name_mk_string]\nabbrev mkStr (p : Name) (s : String) : Name :=\n  Name.str p s", "start": [3440, 1], "end": [3445, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkNum", "code": "@[export lean_name_mk_numeral]\nabbrev mkNum (p : Name) (v : Nat) : Name :=\n  Name.num p v", "start": [3447, 1], "end": [3452, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkSimple", "code": "abbrev mkSimple (s : String) : Name :=\n  .str .anonymous s", "start": [3454, 1], "end": [3458, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkStr1", "code": "@[reducible] def mkStr1 (s\u2081 : String) : Name :=\n  .str .anonymous s\u2081", "start": [3460, 1], "end": [3462, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkStr2", "code": "@[reducible] def mkStr2 (s\u2081 s\u2082 : String) : Name :=\n  .str (.str .anonymous s\u2081) s\u2082", "start": [3464, 1], "end": [3466, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkStr3", "code": "@[reducible] def mkStr3 (s\u2081 s\u2082 s\u2083 : String) : Name :=\n  .str (.str (.str .anonymous s\u2081) s\u2082) s\u2083", "start": [3468, 1], "end": [3470, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkStr4", "code": "@[reducible] def mkStr4 (s\u2081 s\u2082 s\u2083 s\u2084 : String) : Name :=\n  .str (.str (.str (.str .anonymous s\u2081) s\u2082) s\u2083) s\u2084", "start": [3472, 1], "end": [3474, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkStr5", "code": "@[reducible] def mkStr5 (s\u2081 s\u2082 s\u2083 s\u2084 s\u2085 : String) : Name :=\n  .str (.str (.str (.str (.str .anonymous s\u2081) s\u2082) s\u2083) s\u2084) s\u2085", "start": [3476, 1], "end": [3478, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkStr6", "code": "@[reducible] def mkStr6 (s\u2081 s\u2082 s\u2083 s\u2084 s\u2085 s\u2086 : String) : Name :=\n  .str (.str (.str (.str (.str (.str .anonymous s\u2081) s\u2082) s\u2083) s\u2084) s\u2085) s\u2086", "start": [3480, 1], "end": [3482, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkStr7", "code": "@[reducible] def mkStr7 (s\u2081 s\u2082 s\u2083 s\u2084 s\u2085 s\u2086 s\u2087 : String) : Name :=\n  .str (.str (.str (.str (.str (.str (.str .anonymous s\u2081) s\u2082) s\u2083) s\u2084) s\u2085) s\u2086) s\u2087", "start": [3484, 1], "end": [3486, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.mkStr8", "code": "@[reducible] def mkStr8 (s\u2081 s\u2082 s\u2083 s\u2084 s\u2085 s\u2086 s\u2087 s\u2088 : String) : Name :=\n  .str (.str (.str (.str (.str (.str (.str (.str .anonymous s\u2081) s\u2082) s\u2083) s\u2084) s\u2085) s\u2086) s\u2087) s\u2088", "start": [3488, 1], "end": [3490, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.beq", "code": "@[extern \"lean_name_eq\"]\nprotected def beq : (@& Name) \u2192 (@& Name) \u2192 Bool\n  | anonymous, anonymous => true\n  | str p\u2081 s\u2081, str p\u2082 s\u2082 => and (BEq.beq s\u2081 s\u2082) (Name.beq p\u2081 p\u2082)\n  | num p\u2081 n\u2081, num p\u2082 n\u2082 => and (BEq.beq n\u2081 n\u2082) (Name.beq p\u2081 p\u2082)\n  | _,         _         => false", "start": [3492, 1], "end": [3498, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.appendCore", "code": "def appendCore : Name \u2192 Name \u2192 Name\n  | n, .anonymous => n\n  | n, .str p s => .str (appendCore n p) s\n  | n, .num p d => .num (appendCore n p) d", "start": [3503, 1], "end": [3510, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.SourceInfo", "code": "inductive SourceInfo where\n  \n  | original (leading : Substring) (pos : String.Pos) (trailing : Substring) (endPos : String.Pos)\n  \n  | synthetic (pos : String.Pos) (endPos : String.Pos) (canonical := false)\n  \n  | protected none", "start": [3516, 1], "end": [3549, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.SourceInfo.getPos?", "code": "def getPos? (info : SourceInfo) (canonicalOnly := false) : Option String.Pos :=\n  match info, canonicalOnly with\n  | original (pos := pos) ..,  _\n  | synthetic (pos := pos) (canonical := true) .., _\n  | synthetic (pos := pos) .., false => some pos\n  | _,                         _     => none", "start": [3555, 1], "end": [3564, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNodeKind", "code": "abbrev SyntaxNodeKind := Name", "start": [3568, 1], "end": [3575, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Preresolved", "code": "inductive Syntax.Preresolved where\n  \n  | namespace (ns : Name)\n  \n  | decl (n : Name) (fields : List String)", "start": [3579, 1], "end": [3588, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax", "code": "inductive Syntax where\n  \n  | missing : Syntax\n  \n  | node   (info : SourceInfo) (kind : SyntaxNodeKind) (args : Array Syntax) : Syntax\n  \n  | atom   (info : SourceInfo) (val : String) : Syntax\n  \n  | ident  (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax", "start": [3590, 1], "end": [3628, 114], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.node1", "code": "def Syntax.node1 (info : SourceInfo) (kind : SyntaxNodeKind) (a\u2081 : Syntax) : Syntax :=\n  Syntax.node info kind (Array.mkArray1 a\u2081)", "start": [3630, 1], "end": [3632, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.node2", "code": "def Syntax.node2 (info : SourceInfo) (kind : SyntaxNodeKind) (a\u2081 a\u2082 : Syntax) : Syntax :=\n  Syntax.node info kind (Array.mkArray2 a\u2081 a\u2082)", "start": [3634, 1], "end": [3636, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.node3", "code": "def Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a\u2081 a\u2082 a\u2083 : Syntax) : Syntax :=\n  Syntax.node info kind (Array.mkArray3 a\u2081 a\u2082 a\u2083)", "start": [3638, 1], "end": [3640, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.node4", "code": "def Syntax.node4 (info : SourceInfo) (kind : SyntaxNodeKind) (a\u2081 a\u2082 a\u2083 a\u2084 : Syntax) : Syntax :=\n  Syntax.node info kind (Array.mkArray4 a\u2081 a\u2082 a\u2083 a\u2084)", "start": [3642, 1], "end": [3644, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.node5", "code": "def Syntax.node5 (info : SourceInfo) (kind : SyntaxNodeKind) (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 : Syntax) : Syntax :=\n  Syntax.node info kind (Array.mkArray5 a\u2081 a\u2082 a\u2083 a\u2084 a\u2085)", "start": [3646, 1], "end": [3648, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.node6", "code": "def Syntax.node6 (info : SourceInfo) (kind : SyntaxNodeKind) (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 a\u2086 : Syntax) : Syntax :=\n  Syntax.node info kind (Array.mkArray6 a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 a\u2086)", "start": [3650, 1], "end": [3652, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.node7", "code": "def Syntax.node7 (info : SourceInfo) (kind : SyntaxNodeKind) (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 a\u2086 a\u2087 : Syntax) : Syntax :=\n  Syntax.node info kind (Array.mkArray7 a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 a\u2086 a\u2087)", "start": [3654, 1], "end": [3656, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.node8", "code": "def Syntax.node8 (info : SourceInfo) (kind : SyntaxNodeKind) (a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 a\u2086 a\u2087 a\u2088 : Syntax) : Syntax :=\n  Syntax.node info kind (Array.mkArray8 a\u2081 a\u2082 a\u2083 a\u2084 a\u2085 a\u2086 a\u2087 a\u2088)", "start": [3658, 1], "end": [3660, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNodeKinds", "code": "def SyntaxNodeKinds := List SyntaxNodeKind", "start": [3662, 1], "end": [3663, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntax", "code": "structure TSyntax (ks : SyntaxNodeKinds) where\n  \n  raw : Syntax", "start": [3665, 1], "end": [3674, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.choiceKind", "code": "abbrev choiceKind : SyntaxNodeKind := `choice", "start": [3684, 1], "end": [3688, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.nullKind", "code": "abbrev nullKind : SyntaxNodeKind := `null", "start": [3690, 1], "end": [3691, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.groupKind", "code": "abbrev groupKind : SyntaxNodeKind := `group", "start": [3693, 1], "end": [3697, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.identKind", "code": "abbrev identKind : SyntaxNodeKind := `ident", "start": [3699, 1], "end": [3704, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.strLitKind", "code": "abbrev strLitKind : SyntaxNodeKind := `str", "start": [3706, 1], "end": [3707, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.charLitKind", "code": "abbrev charLitKind : SyntaxNodeKind := `char", "start": [3709, 1], "end": [3710, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.numLitKind", "code": "abbrev numLitKind : SyntaxNodeKind := `num", "start": [3712, 1], "end": [3713, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.scientificLitKind", "code": "abbrev scientificLitKind : SyntaxNodeKind := `scientific", "start": [3715, 1], "end": [3716, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.nameLitKind", "code": "abbrev nameLitKind : SyntaxNodeKind := `name", "start": [3718, 1], "end": [3719, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.fieldIdxKind", "code": "abbrev fieldIdxKind : SyntaxNodeKind := `fieldIdx", "start": [3721, 1], "end": [3722, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.hygieneInfoKind", "code": "abbrev hygieneInfoKind : SyntaxNodeKind := `hygieneInfo", "start": [3724, 1], "end": [3732, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.interpolatedStrLitKind", "code": "abbrev interpolatedStrLitKind : SyntaxNodeKind := `interpolatedStrLitKind", "start": [3734, 1], "end": [3738, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.interpolatedStrKind", "code": "abbrev interpolatedStrKind : SyntaxNodeKind := `interpolatedStrKind", "start": [3739, 1], "end": [3743, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.mkNode", "code": "@[inline] def mkNode (k : SyntaxNodeKind) (args : Array Syntax) : TSyntax (.cons k .nil) :=\n  \u27e8Syntax.node SourceInfo.none k args\u27e9", "start": [3745, 1], "end": [3747, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.mkNullNode", "code": "@[inline] def mkNullNode (args : Array Syntax := Array.empty) : Syntax :=\n  mkNode nullKind args |>.raw", "start": [3749, 1], "end": [3752, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getKind", "code": "def getKind (stx : Syntax) : SyntaxNodeKind :=\n  match stx with\n  | Syntax.node _ k _    => k\n  | Syntax.missing     => `missing\n  | Syntax.atom _ v    => Name.mkSimple v\n  | Syntax.ident ..    => identKind", "start": [3756, 1], "end": [3769, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.setKind", "code": "def setKind (stx : Syntax) (k : SyntaxNodeKind) : Syntax :=\n  match stx with\n  | Syntax.node info _ args => Syntax.node info k args\n  | _                       => stx", "start": [3771, 1], "end": [3778, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isOfKind", "code": "def isOfKind (stx : Syntax) (k : SyntaxNodeKind) : Bool :=\n  beq stx.getKind k", "start": [3780, 1], "end": [3782, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getArg", "code": "def getArg (stx : Syntax) (i : Nat) : Syntax :=\n  match stx with\n  | Syntax.node _ _ args => args.getD i Syntax.missing\n  | _                    => Syntax.missing", "start": [3784, 1], "end": [3791, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getArgs", "code": "def getArgs (stx : Syntax) : Array Syntax :=\n  match stx with\n  | Syntax.node _ _ args => args\n  | _                    => Array.empty", "start": [3796, 1], "end": [3800, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getNumArgs", "code": "def getNumArgs (stx : Syntax) : Nat :=\n  match stx with\n  | Syntax.node _ _ args => args.size\n  | _                    => 0", "start": [3802, 1], "end": [3806, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getOptional?", "code": "def getOptional? (stx : Syntax) : Option Syntax :=\n  match stx with\n  | Syntax.node _ k args => match and (beq k nullKind) (beq args.size 1) with\n    | true  => some (args.get! 0)\n    | false => none\n  | _                    => none", "start": [3808, 1], "end": [3817, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isMissing", "code": "def isMissing : Syntax \u2192 Bool\n  | Syntax.missing => true\n  | _ => false", "start": [3819, 1], "end": [3822, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isNodeOf", "code": "def isNodeOf (stx : Syntax) (k : SyntaxNodeKind) (n : Nat) : Bool :=\n  and (stx.isOfKind k) (beq stx.getNumArgs n)", "start": [3824, 1], "end": [3826, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isIdent", "code": "def isIdent : Syntax \u2192 Bool\n  | ident .. => true\n  | _        => false", "start": [3828, 1], "end": [3831, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getId", "code": "def getId : Syntax \u2192 Name\n  | ident _ _ val _ => val\n  | _               => Name.anonymous", "start": [3833, 1], "end": [3836, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.setArgs", "code": "def setArgs (stx : Syntax) (args : Array Syntax) : Syntax :=\n  match stx with\n  | node info k _ => node info k args\n  | stx           => stx", "start": [3838, 1], "end": [3845, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.setArg", "code": "def setArg (stx : Syntax) (i : Nat) (arg : Syntax) : Syntax :=\n  match stx with\n  | node info k args => node info k (args.setD i arg)\n  | stx              => stx", "start": [3847, 1], "end": [3854, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getHeadInfo?", "code": "partial def getHeadInfo? : Syntax \u2192 Option SourceInfo\n  | atom info _   => some info\n  | ident info .. => some info\n  | node SourceInfo.none _ args   =>\n    let rec loop (i : Nat) : Option SourceInfo :=\n      match decide (LT.lt i args.size) with\n      | true => match getHeadInfo? (args.get! i) with\n         | some info => some info\n         | none      => loop (hAdd i 1)\n      | false => none\n    loop 0\n  | node info _ _ => some info\n  | _             => none", "start": [3856, 1], "end": [3869, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getHeadInfo", "code": "partial def getHeadInfo (stx : Syntax) : SourceInfo :=\n  match stx.getHeadInfo? with\n  | some info => info\n  | none      => SourceInfo.none", "start": [3871, 1], "end": [3875, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getPos?", "code": "def getPos? (stx : Syntax) (canonicalOnly := false) : Option String.Pos :=\n  stx.getHeadInfo.getPos? canonicalOnly", "start": [3877, 1], "end": [3883, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getTailPos?", "code": "partial def getTailPos? (stx : Syntax) (canonicalOnly := false) : Option String.Pos :=\n  match stx, canonicalOnly with\n  | atom (SourceInfo.original (endPos := pos) ..) .., _\n  | atom (SourceInfo.synthetic (endPos := pos) (canonical := true) ..) _, _\n  | atom (SourceInfo.synthetic (endPos := pos) ..) _,  false\n  | ident (SourceInfo.original (endPos := pos) ..) .., _\n  | ident (SourceInfo.synthetic (endPos := pos) (canonical := true) ..) .., _\n  | ident (SourceInfo.synthetic (endPos := pos) ..) .., false\n  | node (SourceInfo.original (endPos := pos) ..) .., _\n  | node (SourceInfo.synthetic (endPos := pos) (canonical := true) ..) .., _\n  | node (SourceInfo.synthetic (endPos := pos) ..) .., false => some pos\n  | node _ _ args, _ =>\n    let rec loop (i : Nat) : Option String.Pos :=\n      match decide (LT.lt i args.size) with\n      | true => match getTailPos? (args.get! ((args.size.sub i).sub 1)) canonicalOnly with\n         | some info => some info\n         | none      => loop (hAdd i 1)\n      | false => none\n    loop 0\n  | _, _ => none", "start": [3886, 1], "end": [3910, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.SepArray", "code": "structure SepArray (sep : String) where\n  \n  elemsAndSeps : Array Syntax", "start": [3912, 1], "end": [3919, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.TSepArray", "code": "structure TSepArray (ks : SyntaxNodeKinds) (sep : String) where\n  \n  elemsAndSeps : Array Syntax", "start": [3921, 1], "end": [3925, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntaxArray", "code": "abbrev TSyntaxArray (ks : SyntaxNodeKinds) := Array (TSyntax ks)", "start": [3929, 1], "end": [3930, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntaxArray.rawImpl", "code": "unsafe def TSyntaxArray.rawImpl : TSyntaxArray ks \u2192 Array Syntax := unsafeCast", "start": [3932, 1], "end": [3933, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntaxArray.raw", "code": "@[implemented_by TSyntaxArray.rawImpl]\nopaque TSyntaxArray.raw (as : TSyntaxArray ks) : Array Syntax := Array.empty", "start": [3935, 1], "end": [3937, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntaxArray.mkImpl", "code": "unsafe def TSyntaxArray.mkImpl : Array Syntax \u2192 TSyntaxArray ks := unsafeCast", "start": [3939, 1], "end": [3940, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntaxArray.mk", "code": "@[implemented_by TSyntaxArray.mkImpl]\nopaque TSyntaxArray.mk (as : Array Syntax) : TSyntaxArray ks := Array.empty", "start": [3942, 1], "end": [3944, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.SourceInfo.fromRef", "code": "def SourceInfo.fromRef (ref : Syntax) (canonical := false) : SourceInfo :=\n  let noncanonical ref :=\n    match ref.getPos?, ref.getTailPos? with\n    | some pos, some tailPos => .synthetic pos tailPos\n    | _,        _            => .none\n  match canonical with\n  | true =>\n    match ref.getPos? true, ref.getTailPos? true with\n    | some pos, some tailPos => .synthetic pos tailPos true\n    | _,        _            => noncanonical ref\n  | false => noncanonical ref", "start": [3946, 1], "end": [3957, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAtom", "code": "def mkAtom (val : String) : Syntax :=\n  Syntax.atom SourceInfo.none val", "start": [3959, 1], "end": [3961, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAtomFrom", "code": "def mkAtomFrom (src : Syntax) (val : String) (canonical := false) : Syntax :=\n  Syntax.atom (SourceInfo.fromRef src canonical) val", "start": [3963, 1], "end": [3965, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserDescr", "code": "inductive ParserDescr where\n  \n  | const  (name : Name)\n  \n  | unary  (name : Name) (p : ParserDescr)\n  \n  | binary (name : Name) (p\u2081 p\u2082 : ParserDescr)\n  \n  | node (kind : SyntaxNodeKind) (prec : Nat) (p : ParserDescr)\n  \n  | trailingNode (kind : SyntaxNodeKind) (prec lhsPrec : Nat) (p : ParserDescr)\n  \n  | symbol (val : String)\n  \n  | nonReservedSymbol (val : String) (includeIdent : Bool)\n  \n  | cat (catName : Name) (rbp : Nat)\n  \n  | parser (declName : Name)\n  \n  | nodeWithAntiquot (name : String) (kind : SyntaxNodeKind) (p : ParserDescr)\n  \n  | sepBy  (p : ParserDescr) (sep : String) (psep : ParserDescr) (allowTrailingSep : Bool := false)\n  \n  | sepBy1 (p : ParserDescr) (sep : String) (psep : ParserDescr) (allowTrailingSep : Bool := false)", "start": [3969, 1], "end": [4015, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.TrailingParserDescr", "code": "abbrev TrailingParserDescr := ParserDescr", "start": [4020, 1], "end": [4026, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.MacroScope", "code": "abbrev MacroScope := Nat", "start": [4034, 1], "end": [4040, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.reservedMacroScope", "code": "def reservedMacroScope := 0", "start": [4041, 1], "end": [4042, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.firstFrontendMacroScope", "code": "def firstFrontendMacroScope := hAdd reservedMacroScope 1", "start": [4043, 1], "end": [4044, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadRef", "code": "class MonadRef (m : Type \u2192 Type) where\n  \n  getRef      : m Syntax\n  \n  withRef {\u03b1} : Syntax \u2192 m \u03b1 \u2192 m \u03b1", "start": [4046, 1], "end": [4056, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.replaceRef", "code": "def replaceRef (ref : Syntax) (oldRef : Syntax) : Syntax :=\n  match ref.getPos? with\n  | some _ => ref\n  | _      => oldRef", "start": [4064, 1], "end": [4071, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.withRef", "code": "@[always_inline, inline]\ndef withRef [Monad m] [MonadRef m] {\u03b1} (ref : Syntax) (x : m \u03b1) : m \u03b1 :=\n  bind getRef fun oldRef =>\n  let ref := replaceRef ref oldRef\n  MonadRef.withRef ref x", "start": [4073, 1], "end": [4082, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadQuotation", "code": "class MonadQuotation (m : Type \u2192 Type) extends MonadRef m where\n  \n  getCurrMacroScope : m MacroScope\n  \n  getMainModule     : m Name\n  \n  withFreshMacroScope {\u03b1 : Type} : m \u03b1 \u2192 m \u03b1", "start": [4084, 1], "end": [4111, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadRef.mkInfoFromRefPos", "code": "@[inline]\ndef MonadRef.mkInfoFromRefPos [Monad m] [MonadRef m] : m SourceInfo :=\n  return SourceInfo.fromRef (\u2190 getRef)", "start": [4115, 1], "end": [4118, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.hasMacroScopes", "code": "def Name.hasMacroScopes : Name \u2192 Bool\n  | str _ s => beq s \"_hyg\"\n  | num p _ => hasMacroScopes p\n  | _       => false", "start": [4146, 1], "end": [4150, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.eraseMacroScopesAux", "code": "private def eraseMacroScopesAux : Name \u2192 Name\n  | .str p s   => match beq s \"_@\" with\n    | true  => p\n    | false => eraseMacroScopesAux p\n  | .num p _   => eraseMacroScopesAux p\n  | .anonymous => Name.anonymous", "start": [4152, 1], "end": [4157, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.eraseMacroScopes", "code": "@[export lean_erase_macro_scopes]\ndef Name.eraseMacroScopes (n : Name) : Name :=\n  match n.hasMacroScopes with\n  | true  => eraseMacroScopesAux n\n  | false => n", "start": [4159, 1], "end": [4164, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.simpMacroScopesAux", "code": "private def simpMacroScopesAux : Name \u2192 Name\n  | .num p i => Name.mkNum (simpMacroScopesAux p) i\n  | n        => eraseMacroScopesAux n", "start": [4166, 1], "end": [4168, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.simpMacroScopes", "code": "@[export lean_simp_macro_scopes]\ndef Name.simpMacroScopes (n : Name) : Name :=\n  match n.hasMacroScopes with\n  | true  => simpMacroScopesAux n\n  | false => n", "start": [4170, 1], "end": [4175, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.MacroScopesView", "code": "structure MacroScopesView where\n  \n  name       : Name\n  \n  imported   : Name\n  \n  mainModule : Name\n  \n  scopes     : List MacroScope", "start": [4177, 1], "end": [4194, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.MacroScopesView.review", "code": "def MacroScopesView.review (view : MacroScopesView) : Name :=\n  match view.scopes with\n  | List.nil      => view.name\n  | List.cons _ _ =>\n    let base := (Name.mkStr (Name.appendCore (Name.appendCore (Name.mkStr view.name \"_@\") view.imported) view.mainModule) \"_hyg\")\n    view.scopes.foldl Name.mkNum base", "start": [4199, 1], "end": [4205, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.assembleParts", "code": "private def assembleParts : List Name \u2192 Name \u2192 Name\n  | .nil,                acc => acc\n  | .cons (.str _ s) ps, acc => assembleParts ps (Name.mkStr acc s)\n  | .cons (.num _ n) ps, acc => assembleParts ps (Name.mkNum acc n)\n  | _,                   _   => panic \"Error: unreachable @ assembleParts\"", "start": [4207, 1], "end": [4211, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.extractImported", "code": "private def extractImported (scps : List MacroScope) (mainModule : Name) : Name \u2192 List Name \u2192 MacroScopesView\n  | n@(Name.str p str), parts =>\n    match beq str \"_@\" with\n    | true  => { name := p, mainModule := mainModule, imported := assembleParts parts Name.anonymous, scopes := scps }\n    | false => extractImported scps mainModule p (List.cons n parts)\n  | n@(Name.num p _), parts => extractImported scps mainModule p (List.cons n parts)\n  | _,                    _     => panic \"Error: unreachable @ extractImported\"", "start": [4213, 1], "end": [4219, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.extractMainModule", "code": "private def extractMainModule (scps : List MacroScope) : Name \u2192 List Name \u2192 MacroScopesView\n  | n@(Name.str p str), parts =>\n    match beq str \"_@\" with\n    | true  => { name := p, mainModule := assembleParts parts Name.anonymous, imported := Name.anonymous, scopes := scps }\n    | false => extractMainModule scps p (List.cons n parts)\n  | n@(Name.num _ _), acc => extractImported scps (assembleParts acc Name.anonymous) n List.nil\n  | _,                    _   => panic \"Error: unreachable @ extractMainModule\"", "start": [4221, 1], "end": [4227, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.extractMacroScopesAux", "code": "private def extractMacroScopesAux : Name \u2192 List MacroScope \u2192 MacroScopesView\n  | Name.num p scp, acc => extractMacroScopesAux p (List.cons scp acc)\n  | Name.str p _  , acc => extractMainModule acc p List.nil | _,                _   => panic \"Error: unreachable @ extractMacroScopesAux\"", "start": [4229, 1], "end": [4232, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.extractMacroScopes", "code": "def extractMacroScopes (n : Name) : MacroScopesView :=\n  match n.hasMacroScopes with\n  | true  => extractMacroScopesAux n List.nil\n  | false => { name := n, scopes := List.nil, imported := Name.anonymous, mainModule := Name.anonymous }", "start": [4234, 1], "end": [4241, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.addMacroScope", "code": "def addMacroScope (mainModule : Name) (n : Name) (scp : MacroScope) : Name :=\n  match n.hasMacroScopes with\n  | true =>\n    let view := extractMacroScopes n\n    match beq view.mainModule mainModule with\n    | true  => Name.mkNum n scp\n    | false =>\n      { view with\n        imported   := view.scopes.foldl Name.mkNum (Name.appendCore view.imported view.mainModule)\n        mainModule := mainModule\n        scopes     := List.cons scp List.nil\n      }.review\n  | false =>\n    Name.mkNum (Name.mkStr (Name.appendCore (Name.mkStr n \"_@\") mainModule) \"_hyg\") scp", "start": [4243, 1], "end": [4257, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.append", "code": "def Name.append (a b : Name) : Name :=\n  match a.hasMacroScopes, b.hasMacroScopes with\n  | true, true  =>\n    panic \"Error: invalid `Name.append`, both arguments have macro scopes, consider using `eraseMacroScopes`\"\n  | true, false =>\n    let view := extractMacroScopes a\n    { view with name := appendCore view.name b }.review\n  | false, true =>\n    let view := extractMacroScopes b\n    { view with name := appendCore a view.name }.review\n  | false, false => appendCore a b", "start": [4259, 1], "end": [4273, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadQuotation.addMacroScope", "code": "@[inline] def MonadQuotation.addMacroScope {m : Type \u2192 Type} [MonadQuotation m] [Monad m] (n : Name) : m Name :=\n  bind getMainModule     fun mainModule =>\n  bind getCurrMacroScope fun scp =>\n  pure (Lean.addMacroScope mainModule n scp)", "start": [4278, 1], "end": [4285, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.defaultMaxRecDepth", "code": "def defaultMaxRecDepth := 512", "start": [4287, 1], "end": [4288, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.maxRecDepthErrorMessage", "code": "def maxRecDepthErrorMessage : String :=\n  \"maximum recursion depth has been reached (use `set_option maxRecDepth <num>` to increase limit)\"", "start": [4290, 1], "end": [4292, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.matchesNull", "code": "def matchesNull (stx : Syntax) (n : Nat) : Bool :=\n  stx.isNodeOf nullKind n", "start": [4296, 1], "end": [4298, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.matchesIdent", "code": "def matchesIdent (stx : Syntax) (id : Name) : Bool :=\n  and stx.isIdent (beq stx.getId.eraseMacroScopes id.eraseMacroScopes)", "start": [4300, 1], "end": [4309, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.matchesLit", "code": "def matchesLit (stx : Syntax) (k : SyntaxNodeKind) (val : String) : Bool :=\n  match stx with\n  | Syntax.node _ k' args => and (beq k k') (match args.getD 0 Syntax.missing with\n    | Syntax.atom _ val' => beq val val'\n    | _                  => false)\n  | _                     => false", "start": [4311, 1], "end": [4317, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.MethodsRefPointed", "code": "private opaque MethodsRefPointed : NonemptyType.{0}", "start": [4323, 1], "end": [4324, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.MethodsRef", "code": "private def MethodsRef : Type := MethodsRefPointed.type", "start": [4326, 1], "end": [4326, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.Context", "code": "structure Context where\n  \n  methods        : MethodsRef\n  \n  mainModule     : Name\n  \n  currMacroScope : MacroScope\n  \n  currRecDepth   : Nat := 0\n  \n  maxRecDepth    : Nat := defaultMaxRecDepth\n  \n  ref            : Syntax", "start": [4330, 1], "end": [4344, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.Exception", "code": "inductive Exception where\n  \n  | error             : Syntax \u2192 String \u2192 Exception\n  \n  | unsupportedSyntax : Exception", "start": [4346, 1], "end": [4353, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.State", "code": "structure State where\n  \n  macroScope : MacroScope\n  \n  traceMsgs  : List (Prod Name String) := List.nil\n  deriving Inhabited", "start": [4355, 1], "end": [4362, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MacroM", "code": "abbrev MacroM := ReaderT Macro.Context (EStateM Macro.Exception Macro.State)", "start": [4366, 1], "end": [4376, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro", "code": "abbrev Macro := Syntax \u2192 MacroM Syntax", "start": [4378, 1], "end": [4383, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.addMacroScope", "code": "def addMacroScope (n : Name) : MacroM Name :=\n  bind read fun ctx =>\n  pure (Lean.addMacroScope ctx.mainModule n ctx.currMacroScope)", "start": [4391, 1], "end": [4394, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.throwUnsupported", "code": "def throwUnsupported {\u03b1} : MacroM \u03b1 :=\n  throw Exception.unsupportedSyntax", "start": [4396, 1], "end": [4398, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.throwError", "code": "def throwError {\u03b1} (msg : String) : MacroM \u03b1 :=\n  bind getRef fun ref =>\n  throw (Exception.error ref msg)", "start": [4400, 1], "end": [4406, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.throwErrorAt", "code": "def throwErrorAt {\u03b1} (ref : Syntax) (msg : String) : MacroM \u03b1 :=\n  withRef ref (throwError msg)", "start": [4408, 1], "end": [4410, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.withFreshMacroScope", "code": "@[inline] protected def withFreshMacroScope {\u03b1} (x : MacroM \u03b1) : MacroM \u03b1 :=\n  bind (modifyGet (fun s => (s.macroScope, { s with macroScope := hAdd s.macroScope 1 }))) fun fresh =>\n  withReader (fun ctx => { ctx with currMacroScope := fresh }) x", "start": [4412, 1], "end": [4418, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.withIncRecDepth", "code": "@[inline] def withIncRecDepth {\u03b1} (ref : Syntax) (x : MacroM \u03b1) : MacroM \u03b1 :=\n  bind read fun ctx =>\n  match beq ctx.currRecDepth ctx.maxRecDepth with\n  | true  => throw (Exception.error ref maxRecDepthErrorMessage)\n  | false => withReader (fun ctx => { ctx with currRecDepth := hAdd ctx.currRecDepth 1 }) x", "start": [4420, 1], "end": [4425, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.Methods", "code": "structure Methods where\n  \n  expandMacro?      : Syntax \u2192 MacroM (Option Syntax)\n  \n  getCurrNamespace  : MacroM Name\n  \n  hasDecl           : Name \u2192 MacroM Bool\n  \n  resolveNamespace  : Name \u2192 MacroM (List Name)\n  \n  resolveGlobalName : Name \u2192 MacroM (List (Prod Name (List String)))\n  deriving Inhabited", "start": [4432, 1], "end": [4447, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.mkMethodsImp", "code": "unsafe def mkMethodsImp (methods : Methods) : MethodsRef :=\n  unsafeCast methods", "start": [4449, 1], "end": [4451, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.mkMethods", "code": "@[implemented_by mkMethodsImp]\nopaque mkMethods (methods : Methods) : MethodsRef", "start": [4453, 1], "end": [4455, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.getMethodsImp", "code": "unsafe def getMethodsImp : MacroM Methods :=\n  bind read fun ctx => pure (unsafeCast (ctx.methods))", "start": [4460, 1], "end": [4462, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.getMethods", "code": "@[implemented_by getMethodsImp] opaque getMethods : MacroM Methods", "start": [4464, 1], "end": [4465, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.expandMacro?", "code": "def expandMacro? (stx : Syntax) : MacroM (Option Syntax) := do\n  (\u2190 getMethods).expandMacro? stx", "start": [4467, 1], "end": [4472, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.hasDecl", "code": "def hasDecl (declName : Name) : MacroM Bool := do\n  (\u2190 getMethods).hasDecl declName", "start": [4474, 1], "end": [4476, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.getCurrNamespace", "code": "def getCurrNamespace : MacroM Name := do\n  (\u2190 getMethods).getCurrNamespace", "start": [4478, 1], "end": [4480, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.resolveNamespace", "code": "def resolveNamespace (n : Name) : MacroM (List Name) := do\n  (\u2190 getMethods).resolveNamespace n", "start": [4482, 3], "end": [4484, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.resolveGlobalName", "code": "def resolveGlobalName (n : Name) : MacroM (List (Prod Name (List String))) := do\n  (\u2190 getMethods).resolveGlobalName n", "start": [4486, 1], "end": [4492, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Macro.trace", "code": "def trace (clsName : Name) (msg : String) : MacroM Unit := do\n  modify fun s => { s with traceMsgs := List.cons (Prod.mk clsName msg) s.traceMsgs }", "start": [4494, 1], "end": [4496, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.UnexpandM", "code": "abbrev UnexpandM := ReaderT Syntax (EStateM Unit Unit)", "start": [4504, 1], "end": [4508, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Unexpander", "code": "abbrev Unexpander := Syntax \u2192 UnexpandM Syntax", "start": [4510, 1], "end": [4516, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Coe.lean", "imports": ["lake-packages/lean4/src/lean/Init/Prelude.lean"], "premises": [{"full_name": "Coe", "code": "class Coe (\u03b1 : semiOutParam (Sort u)) (\u03b2 : Sort v) where\n  \n  coe : \u03b1 \u2192 \u03b2", "start": [120, 1], "end": [129, 14], "kind": "commanddeclaration"}, {"full_name": "CoeTC", "code": "class CoeTC (\u03b1 : Sort u) (\u03b2 : Sort v) where\n  \n  coe : \u03b1 \u2192 \u03b2", "start": [132, 1], "end": [139, 14], "kind": "commanddeclaration"}, {"full_name": "CoeOut", "code": "class CoeOut (\u03b1 : Sort u) (\u03b2 : semiOutParam (Sort v)) where\n  \n  coe : \u03b1 \u2192 \u03b2", "start": [146, 1], "end": [152, 14], "kind": "commanddeclaration"}, {"full_name": "CoeOTC", "code": "class CoeOTC (\u03b1 : Sort u) (\u03b2 : Sort v) where\n  \n  coe : \u03b1 \u2192 \u03b2", "start": [155, 1], "end": [162, 14], "kind": "commanddeclaration"}, {"full_name": "CoeHead", "code": "class CoeHead (\u03b1 : Sort u) (\u03b2 : semiOutParam (Sort v)) where\n  \n  coe : \u03b1 \u2192 \u03b2", "start": [173, 1], "end": [180, 14], "kind": "commanddeclaration"}, {"full_name": "CoeHTC", "code": "class CoeHTC (\u03b1 : Sort u) (\u03b2 : Sort v) where\n  \n  coe : \u03b1 \u2192 \u03b2", "start": [183, 1], "end": [190, 14], "kind": "commanddeclaration"}, {"full_name": "CoeTail", "code": "class CoeTail (\u03b1 : semiOutParam (Sort u)) (\u03b2 : Sort v) where\n  \n  coe : \u03b1 \u2192 \u03b2", "start": [197, 1], "end": [205, 14], "kind": "commanddeclaration"}, {"full_name": "CoeHTCT", "code": "class CoeHTCT (\u03b1 : Sort u) (\u03b2 : Sort v) where\n  \n  coe : \u03b1 \u2192 \u03b2", "start": [208, 1], "end": [215, 14], "kind": "commanddeclaration"}, {"full_name": "CoeDep", "code": "class CoeDep (\u03b1 : Sort u) (_ : \u03b1) (\u03b2 : Sort v) where\n  \n  coe : \u03b2", "start": [222, 1], "end": [234, 10], "kind": "commanddeclaration"}, {"full_name": "CoeT", "code": "class CoeT (\u03b1 : Sort u) (_ : \u03b1) (\u03b2 : Sort v) where\n  \n  coe : \u03b2", "start": [237, 1], "end": [248, 10], "kind": "commanddeclaration"}, {"full_name": "CoeFun", "code": "class CoeFun (\u03b1 : Sort u) (\u03b3 : outParam (\u03b1 \u2192 Sort v)) where\n  \n  coe : (f : \u03b1) \u2192 \u03b3 f", "start": [255, 1], "end": [266, 22], "kind": "commanddeclaration"}, {"full_name": "CoeSort", "code": "class CoeSort (\u03b1 : Sort u) (\u03b2 : outParam (Sort v)) where\n  \n  coe : \u03b1 \u2192 \u03b2", "start": [271, 1], "end": [279, 14], "kind": "commanddeclaration"}, {"full_name": "boolToProp", "code": "instance boolToProp : Coe Bool Prop where\n  coe b := Eq b true", "start": [295, 1], "end": [296, 21], "kind": "commanddeclaration"}, {"full_name": "boolToSort", "code": "instance boolToSort : CoeSort Bool Prop where\n  coe b := b", "start": [298, 1], "end": [299, 13], "kind": "commanddeclaration"}, {"full_name": "decPropToBool", "code": "instance decPropToBool (p : Prop) [Decidable p] : CoeDep Prop p Bool where\n  coe := decide p", "start": [301, 1], "end": [302, 18], "kind": "commanddeclaration"}, {"full_name": "optionCoe", "code": "instance optionCoe {\u03b1 : Type u} : Coe \u03b1 (Option \u03b1) where\n  coe := some", "start": [304, 1], "end": [305, 14], "kind": "commanddeclaration"}, {"full_name": "subtypeCoe", "code": "instance subtypeCoe {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} : CoeOut (Subtype p) \u03b1 where\n  coe v := v.val", "start": [307, 1], "end": [308, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Internal.liftCoeM", "code": "@[inline, coe_decl] def Lean.Internal.liftCoeM {m : Type u \u2192 Type v} {n : Type u \u2192 Type w} {\u03b1 \u03b2 : Type u}\n    [MonadLiftT m n] [\u2200 a, CoeT \u03b1 a \u03b2] [Monad n] (x : m \u03b1) : n \u03b2 := do\n  let a \u2190 liftM x\n  pure (CoeT.coe a)", "start": [312, 1], "end": [321, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Internal.coeM", "code": "@[inline, coe_decl] def Lean.Internal.coeM {m : Type u \u2192 Type v} {\u03b1 \u03b2 : Type u}\n    [\u2200 a, CoeT \u03b1 a \u03b2] [Monad m] (x : m \u03b1) : m \u03b2 := do\n  let a \u2190 x\n  pure (CoeT.coe a)", "start": [323, 1], "end": [331, 20], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Notation.lean", "imports": ["lake-packages/lean4/src/lean/Init/Coe.lean", "lake-packages/lean4/src/lean/Init/Prelude.lean"], "premises": [{"full_name": "Lean.Parser.Category", "code": "structure Parser.Category", "start": [15, 1], "end": [19, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Category.command", "code": "def command : Category := {}", "start": [23, 1], "end": [28, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Category.term", "code": "def term : Category := {}", "start": [30, 1], "end": [35, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Category.tactic", "code": "def tactic : Category := {}", "start": [37, 1], "end": [45, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Category.doElem", "code": "def doElem : Category := {}", "start": [47, 1], "end": [49, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Category.level", "code": "def level : Category := {}", "start": [51, 1], "end": [54, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Category.attr", "code": "def attr : Category := {}", "start": [56, 1], "end": [58, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Category.stx", "code": "def stx : Category := {}", "start": [60, 1], "end": [62, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Category.prio", "code": "def prio : Category := {}", "start": [64, 1], "end": [70, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Category.prec", "code": "def prec : Category := {}", "start": [72, 1], "end": [81, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Tactics.lean", "imports": ["lake-packages/lean4/src/lean/Init/Notation.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/SizeOf.lean", "imports": ["lake-packages/lean4/src/lean/Init/Tactics.lean"], "premises": [{"full_name": "SizeOf", "code": "class SizeOf (\u03b1 : Sort u) where\n  \n  sizeOf : \u03b1 \u2192 Nat", "start": [12, 1], "end": [28, 19], "kind": "commanddeclaration"}, {"full_name": "default.sizeOf", "code": "protected def default.sizeOf (\u03b1 : Sort u) : \u03b1 \u2192 Nat\n  | _ => 0", "start": [37, 1], "end": [42, 11], "kind": "commanddeclaration"}, {"full_name": "sizeOf_default", "code": "@[simp] theorem sizeOf_default (n : \u03b1) : sizeOf n = 0", "start": [47, 1], "end": [47, 61], "kind": "commanddeclaration"}, {"full_name": "sizeOf_nat", "code": "@[simp] theorem sizeOf_nat (n : Nat) : sizeOf n = n", "start": [52, 1], "end": [52, 59], "kind": "commanddeclaration"}, {"full_name": "sizeOf_thunk", "code": "@[simp] theorem sizeOf_thunk [SizeOf \u03b1] (f : Unit \u2192 \u03b1) : sizeOf f = sizeOf (f ())", "start": [57, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Unit.sizeOf", "code": "@[simp] theorem Unit.sizeOf (u : Unit) : sizeOf u = 1", "start": [85, 1], "end": [85, 61], "kind": "commanddeclaration"}, {"full_name": "Bool.sizeOf_eq_one", "code": "@[simp] theorem Bool.sizeOf_eq_one (b : Bool) : sizeOf b = 1", "start": [86, 1], "end": [86, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.sizeOf", "code": "protected noncomputable def Name.sizeOf : Name \u2192 Nat\n  | anonymous => 1\n  | str p s   => 1 + Name.sizeOf p + sizeOf s\n  | num p n   => 1 + Name.sizeOf p + sizeOf n", "start": [90, 1], "end": [97, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.anonymous.sizeOf_spec", "code": "@[simp] theorem Name.anonymous.sizeOf_spec : sizeOf anonymous = 1", "start": [102, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.str.sizeOf_spec", "code": "@[simp] theorem Name.str.sizeOf_spec (p : Name) (s : String) : sizeOf (str p s) = 1 + sizeOf p + sizeOf s", "start": [104, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.num.sizeOf_spec", "code": "@[simp] theorem Name.num.sizeOf_spec (p : Name) (n : Nat) : sizeOf (num p n) = 1 + sizeOf p + sizeOf n", "start": [106, 1], "end": [107, 6], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Core.lean", "imports": ["lake-packages/lean4/src/lean/Init/SizeOf.lean", "lake-packages/lean4/src/lean/Init/Prelude.lean"], "premises": [{"full_name": "inline", "code": "def inline {\u03b1 : Sort u} (a : \u03b1) : \u03b1 := a", "start": [15, 1], "end": [20, 41], "kind": "commanddeclaration"}, {"full_name": "flip", "code": "@[inline] def flip {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03c6 : Sort w} (f : \u03b1 \u2192 \u03b2 \u2192 \u03c6) : \u03b2 \u2192 \u03b1 \u2192 \u03c6 :=\n  fun b a => f a b", "start": [22, 1], "end": [29, 19], "kind": "commanddeclaration"}, {"full_name": "Function.const_apply", "code": "@[simp] theorem Function.const_apply {y : \u03b2} {x : \u03b1} : const \u03b1 y x = y", "start": [31, 1], "end": [31, 78], "kind": "commanddeclaration"}, {"full_name": "Function.comp_apply", "code": "@[simp] theorem Function.comp_apply {f : \u03b2 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2} {x : \u03b1} : comp f g x = f (g x)", "start": [33, 1], "end": [33, 98], "kind": "commanddeclaration"}, {"full_name": "Thunk", "code": "structure Thunk (\u03b1 : Type u) : Type u where\n  \n  mk ::\n  \n  private fn : Unit \u2192 \u03b1", "start": [37, 1], "end": [46, 24], "kind": "commanddeclaration"}, {"full_name": "Thunk.pure", "code": "@[extern \"lean_thunk_pure\"] protected def Thunk.pure (a : \u03b1) : Thunk \u03b1 :=\n  \u27e8fun _ => a\u27e9", "start": [50, 1], "end": [52, 15], "kind": "commanddeclaration"}, {"full_name": "Thunk.get", "code": "@[extern \"lean_thunk_get_own\"] protected def Thunk.get (x : @& Thunk \u03b1) : \u03b1 :=\n  x.fn ()", "start": [54, 1], "end": [61, 10], "kind": "commanddeclaration"}, {"full_name": "Thunk.map", "code": "@[inline] protected def Thunk.map (f : \u03b1 \u2192 \u03b2) (x : Thunk \u03b1) : Thunk \u03b2 :=\n  \u27e8fun _ => f x.get\u27e9", "start": [63, 1], "end": [65, 21], "kind": "commanddeclaration"}, {"full_name": "Thunk.bind", "code": "@[inline] protected def Thunk.bind (x : Thunk \u03b1) (f : \u03b1 \u2192 Thunk \u03b2) : Thunk \u03b2 :=\n  \u27e8fun _ => (f x.get).get\u27e9", "start": [66, 1], "end": [68, 27], "kind": "commanddeclaration"}, {"full_name": "Thunk.sizeOf_eq", "code": "@[simp] theorem Thunk.sizeOf_eq [SizeOf \u03b1] (a : Thunk \u03b1) : sizeOf a = 1 + sizeOf a.get", "start": [70, 1], "end": [71, 16], "kind": "commanddeclaration"}, {"full_name": "thunkCoe", "code": "instance thunkCoe : CoeTail \u03b1 (Thunk \u03b1) where\n  coe a := \u27e8fun _ => a\u27e9", "start": [73, 1], "end": [75, 24], "kind": "commanddeclaration"}, {"full_name": "Eq.ndrecOn", "code": "abbrev Eq.ndrecOn.{u1, u2} {\u03b1 : Sort u2} {a : \u03b1} {motive : \u03b1 \u2192 Sort u1} {b : \u03b1} (h : a = b) (m : motive a) : motive b :=\n  Eq.ndrec m h", "start": [77, 1], "end": [79, 15], "kind": "commanddeclaration"}, {"full_name": "Iff", "code": "structure Iff (a b : Prop) : Prop where\n  \n  intro ::\n  \n  mp : a \u2192 b\n  \n  mpr : b \u2192 a", "start": [81, 1], "end": [92, 14], "kind": "commanddeclaration"}, {"full_name": "Sum", "code": "inductive Sum (\u03b1 : Type u) (\u03b2 : Type v) where\n  \n  | inl (val : \u03b1) : Sum \u03b1 \u03b2\n  \n  | inr (val : \u03b2) : Sum \u03b1 \u03b2", "start": [97, 1], "end": [106, 28], "kind": "commanddeclaration"}, {"full_name": "PSum", "code": "inductive PSum (\u03b1 : Sort u) (\u03b2 : Sort v) where\n  \n  | inl (val : \u03b1) : PSum \u03b1 \u03b2\n  \n  | inr (val : \u03b2) : PSum \u03b1 \u03b2", "start": [110, 1], "end": [125, 29], "kind": "commanddeclaration"}, {"full_name": "Sigma", "code": "structure Sigma {\u03b1 : Type u} (\u03b2 : \u03b1 \u2192 Type v) where\n  \n  mk ::\n  \n  fst : \u03b1\n  \n  snd : \u03b2 fst", "start": [129, 1], "end": [144, 14], "kind": "commanddeclaration"}, {"full_name": "PSigma", "code": "structure PSigma {\u03b1 : Sort u} (\u03b2 : \u03b1 \u2192 Sort v) where\n  \n  mk ::\n  \n  fst : \u03b1\n  \n  snd : \u03b2 fst", "start": [148, 1], "end": [169, 14], "kind": "commanddeclaration"}, {"full_name": "Exists", "code": "inductive Exists {\u03b1 : Sort u} (p : \u03b1 \u2192 Prop) : Prop where\n  \n  | intro (w : \u03b1) (h : p w) : Exists p", "start": [171, 1], "end": [199, 39], "kind": "commanddeclaration"}, {"full_name": "ForInStep", "code": "inductive ForInStep (\u03b1 : Type u) where\n  \n  | done  : \u03b1 \u2192 ForInStep \u03b1\n  \n  | yield : \u03b1 \u2192 ForInStep \u03b1\n  deriving Inhabited", "start": [201, 1], "end": [219, 21], "kind": "commanddeclaration"}, {"full_name": "ForIn", "code": "class ForIn (m : Type u\u2081 \u2192 Type u\u2082) (\u03c1 : Type u) (\u03b1 : outParam (Type v)) where\n  \n  forIn {\u03b2} [Monad m] (x : \u03c1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2", "start": [221, 1], "end": [248, 74], "kind": "commanddeclaration"}, {"full_name": "ForIn'", "code": "class ForIn' (m : Type u\u2081 \u2192 Type u\u2082) (\u03c1 : Type u) (\u03b1 : outParam (Type v)) (d : outParam $ Membership \u03b1 \u03c1) where\n  \n  forIn' {\u03b2} [Monad m] (x : \u03c1) (b : \u03b2) (f : (a : \u03b1) \u2192 a \u2208 x \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2", "start": [252, 1], "end": [264, 89], "kind": "commanddeclaration"}, {"full_name": "DoResultPRBC", "code": "inductive DoResultPRBC (\u03b1 \u03b2 \u03c3 : Type u) where\n  \n  | pure : \u03b1 \u2192 \u03c3 \u2192 DoResultPRBC \u03b1 \u03b2 \u03c3\n  \n  | return : \u03b2 \u2192 \u03c3 \u2192 DoResultPRBC \u03b1 \u03b2 \u03c3\n  \n  | break : \u03c3 \u2192 DoResultPRBC \u03b1 \u03b2 \u03c3\n  \n  | continue : \u03c3 \u2192 DoResultPRBC \u03b1 \u03b2 \u03c3", "start": [269, 1], "end": [292, 38], "kind": "commanddeclaration"}, {"full_name": "DoResultPR", "code": "inductive DoResultPR (\u03b1 \u03b2 \u03c3 : Type u) where\n  \n  | pure   : \u03b1 \u2192 \u03c3 \u2192 DoResultPR \u03b1 \u03b2 \u03c3\n  \n  | return : \u03b2 \u2192 \u03c3 \u2192 DoResultPR \u03b1 \u03b2 \u03c3", "start": [294, 1], "end": [303, 38], "kind": "commanddeclaration"}, {"full_name": "DoResultBC", "code": "inductive DoResultBC (\u03c3 : Type u) where\n  \n  | break    : \u03c3 \u2192 DoResultBC \u03c3\n  \n  | continue : \u03c3 \u2192 DoResultBC \u03c3", "start": [305, 1], "end": [316, 32], "kind": "commanddeclaration"}, {"full_name": "DoResultSBC", "code": "inductive DoResultSBC (\u03b1 \u03c3 : Type u) where\n  \n  | pureReturn : \u03b1 \u2192 \u03c3 \u2192 DoResultSBC \u03b1 \u03c3\n  \n  | break    : \u03c3 \u2192 DoResultSBC \u03b1 \u03c3\n  \n  | continue   : \u03c3 \u2192 DoResultSBC \u03b1 \u03c3", "start": [318, 1], "end": [335, 37], "kind": "commanddeclaration"}, {"full_name": "HasEquiv", "code": "class HasEquiv (\u03b1 : Sort u) where\n  \n  Equiv : \u03b1 \u2192 \u03b1 \u2192 Sort v", "start": [337, 1], "end": [341, 25], "kind": "commanddeclaration"}, {"full_name": "EmptyCollection", "code": "class EmptyCollection (\u03b1 : Type u) where\n  \n  emptyCollection : \u03b1", "start": [345, 1], "end": [349, 22], "kind": "commanddeclaration"}, {"full_name": "Task", "code": "structure Task (\u03b1 : Type u) : Type u where\n  \n  pure ::\n  \n  get : \u03b1\n  deriving Inhabited, Nonempty", "start": [354, 1], "end": [368, 31], "kind": "commanddeclaration"}, {"full_name": "Task.Priority", "code": "abbrev Priority := Nat", "start": [374, 1], "end": [375, 23], "kind": "commanddeclaration"}, {"full_name": "Task.Priority.default", "code": "def Priority.default : Priority := 0", "start": [377, 1], "end": [378, 37], "kind": "commanddeclaration"}, {"full_name": "Task.Priority.max", "code": "def Priority.max : Priority := 8", "start": [379, 1], "end": [387, 33], "kind": "commanddeclaration"}, {"full_name": "Task.Priority.dedicated", "code": "def Priority.dedicated : Priority := 9", "start": [388, 1], "end": [394, 39], "kind": "commanddeclaration"}, {"full_name": "Task.spawn", "code": "@[noinline, extern \"lean_task_spawn\"]\nprotected def spawn {\u03b1 : Type u} (fn : Unit \u2192 \u03b1) (prio := Priority.default) : Task \u03b1 :=\n  \u27e8fn ()\u27e9", "start": [397, 1], "end": [405, 10], "kind": "commanddeclaration"}, {"full_name": "Task.map", "code": "@[noinline, extern \"lean_task_map\"]\nprotected def map {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (x : Task \u03b1) (prio := Priority.default) : Task \u03b2 :=\n  \u27e8f x.get\u27e9", "start": [408, 1], "end": [417, 12], "kind": "commanddeclaration"}, {"full_name": "Task.bind", "code": "@[noinline, extern \"lean_task_bind\"]\nprotected def bind {\u03b1 : Type u} {\u03b2 : Type v} (x : Task \u03b1) (f : \u03b1 \u2192 Task \u03b2) (prio := Priority.default) : Task \u03b2 :=\n  \u27e8(f x.get).get\u27e9", "start": [420, 1], "end": [430, 18], "kind": "commanddeclaration"}, {"full_name": "NonScalar", "code": "structure NonScalar where\n   mk ::\n   val : Nat", "start": [434, 1], "end": [442, 52], "kind": "commanddeclaration"}, {"full_name": "PNonScalar", "code": "inductive PNonScalar : Type u where\n  \n  | mk (v : Nat) : PNonScalar", "start": [444, 1], "end": [455, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.add_zero", "code": "@[simp] protected theorem Nat.add_zero (n : Nat) : n + 0 = n", "start": [457, 1], "end": [457, 68], "kind": "commanddeclaration"}, {"full_name": "optParam_eq", "code": "theorem optParam_eq (\u03b1 : Sort u) (default : \u03b1) : optParam \u03b1 default = \u03b1", "start": [459, 1], "end": [459, 79], "kind": "commanddeclaration"}, {"full_name": "strictOr", "code": "@[extern \"lean_strict_or\"] def strictOr  (b\u2081 b\u2082 : Bool) := b\u2081 || b\u2082", "start": [463, 1], "end": [467, 68], "kind": "commanddeclaration"}, {"full_name": "strictAnd", "code": "@[extern \"lean_strict_and\"] def strictAnd (b\u2081 b\u2082 : Bool) := b\u2081 && b\u2082", "start": [469, 1], "end": [473, 69], "kind": "commanddeclaration"}, {"full_name": "bne", "code": "@[inline] def bne {\u03b1 : Type u} [BEq \u03b1] (a b : \u03b1) : Bool :=\n  !(a == b)", "start": [475, 1], "end": [483, 12], "kind": "commanddeclaration"}, {"full_name": "LawfulBEq", "code": "class LawfulBEq (\u03b1 : Type u) [BEq \u03b1] : Prop where\n  \n  eq_of_beq : {a b : \u03b1} \u2192 a == b \u2192 a = b\n  \n  protected rfl : {a : \u03b1} \u2192 a == a", "start": [487, 1], "end": [496, 35], "kind": "commanddeclaration"}, {"full_name": "trivial", "code": "@[inherit_doc True.intro] def trivial : True := \u27e8\u27e9", "start": [514, 1], "end": [514, 51], "kind": "commanddeclaration"}, {"full_name": "mt", "code": "theorem mt {a b : Prop} (h\u2081 : a \u2192 b) (h\u2082 : \u00acb) : \u00aca", "start": [516, 1], "end": [517, 23], "kind": "commanddeclaration"}, {"full_name": "not_false", "code": "theorem not_false : \u00acFalse", "start": [519, 1], "end": [519, 33], "kind": "commanddeclaration"}, {"full_name": "not_not_intro", "code": "theorem not_not_intro {p : Prop} (h : p) : \u00ac \u00ac p", "start": [521, 1], "end": [522, 23], "kind": "commanddeclaration"}, {"full_name": "proofIrrel", "code": "theorem proofIrrel {a : Prop} (h\u2081 h\u2082 : a) : h\u2081 = h\u2082", "start": [525, 1], "end": [525, 59], "kind": "commanddeclaration"}, {"full_name": "id.def", "code": "theorem id.def {\u03b1 : Sort u} (a : \u03b1) : id a = a", "start": [527, 1], "end": [527, 54], "kind": "commanddeclaration"}, {"full_name": "Eq.mp", "code": "@[macro_inline] def Eq.mp {\u03b1 \u03b2 : Sort u} (h : \u03b1 = \u03b2) (a : \u03b1) : \u03b2 :=\n  h \u25b8 a", "start": [529, 1], "end": [537, 8], "kind": "commanddeclaration"}, {"full_name": "Eq.mpr", "code": "@[macro_inline] def Eq.mpr {\u03b1 \u03b2 : Sort u} (h : \u03b1 = \u03b2) (b : \u03b2) : \u03b1 :=\n  h \u25b8 b", "start": [539, 1], "end": [547, 8], "kind": "commanddeclaration"}, {"full_name": "Eq.substr", "code": "@[elab_as_elim]\ntheorem Eq.substr {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} {a b : \u03b1} (h\u2081 : b = a) (h\u2082 : p a) : p b", "start": [549, 1], "end": [551, 10], "kind": "commanddeclaration"}, {"full_name": "cast_eq", "code": "theorem cast_eq {\u03b1 : Sort u} (h : \u03b1 = \u03b1) (a : \u03b1) : cast h a = a", "start": [553, 1], "end": [554, 6], "kind": "commanddeclaration"}, {"full_name": "Ne", "code": "@[reducible] def Ne {\u03b1 : Sort u} (a b : \u03b1) :=\n  \u00ac(a = b)", "start": [556, 1], "end": [561, 11], "kind": "commanddeclaration"}, {"full_name": "Ne.intro", "code": "theorem Ne.intro (h : a = b \u2192 False) : a \u2260 b", "start": [569, 1], "end": [569, 50], "kind": "commanddeclaration"}, {"full_name": "Ne.elim", "code": "theorem Ne.elim (h : a \u2260 b) : a = b \u2192 False", "start": [571, 1], "end": [571, 49], "kind": "commanddeclaration"}, {"full_name": "Ne.irrefl", "code": "theorem Ne.irrefl (h : a \u2260 a) : False", "start": [573, 1], "end": [573, 47], "kind": "commanddeclaration"}, {"full_name": "Ne.symm", "code": "theorem Ne.symm (h : a \u2260 b) : b \u2260 a", "start": [575, 1], "end": [576, 24], "kind": "commanddeclaration"}, {"full_name": "false_of_ne", "code": "theorem false_of_ne : a \u2260 a \u2192 False", "start": [578, 1], "end": [578, 49], "kind": "commanddeclaration"}, {"full_name": "ne_false_of_self", "code": "theorem ne_false_of_self : p \u2192 p \u2260 False", "start": [580, 1], "end": [581, 41], "kind": "commanddeclaration"}, {"full_name": "ne_true_of_not", "code": "theorem ne_true_of_not : \u00acp \u2192 p \u2260 True", "start": [583, 1], "end": [586, 17], "kind": "commanddeclaration"}, {"full_name": "true_ne_false", "code": "theorem true_ne_false : \u00acTrue = False", "start": [588, 1], "end": [589, 27], "kind": "commanddeclaration"}, {"full_name": "Bool.of_not_eq_true", "code": "theorem Bool.of_not_eq_true : {b : Bool} \u2192 \u00ac (b = true) \u2192 b = false", "start": [593, 1], "end": [595, 20], "kind": "commanddeclaration"}, {"full_name": "Bool.of_not_eq_false", "code": "theorem Bool.of_not_eq_false : {b : Bool} \u2192 \u00ac (b = false) \u2192 b = true", "start": [597, 1], "end": [599, 29], "kind": "commanddeclaration"}, {"full_name": "ne_of_beq_false", "code": "theorem ne_of_beq_false [BEq \u03b1] [LawfulBEq \u03b1] {a b : \u03b1} (h : (a == b) = false) : a \u2260 b", "start": [601, 1], "end": [602, 90], "kind": "commanddeclaration"}, {"full_name": "beq_false_of_ne", "code": "theorem beq_false_of_ne [BEq \u03b1] [LawfulBEq \u03b1] {a b : \u03b1} (h : a \u2260 b) : (a == b) = false", "start": [604, 1], "end": [607, 27], "kind": "commanddeclaration"}, {"full_name": "HEq.ndrec", "code": "theorem HEq.ndrec.{u1, u2} {\u03b1 : Sort u2} {a : \u03b1} {motive : {\u03b2 : Sort u2} \u2192 \u03b2 \u2192 Sort u1} (m : motive a) {\u03b2 : Sort u2} {b : \u03b2} (h : HEq a b) : motive b", "start": [612, 1], "end": [613, 10], "kind": "commanddeclaration"}, {"full_name": "HEq.ndrecOn", "code": "theorem HEq.ndrecOn.{u1, u2} {\u03b1 : Sort u2} {a : \u03b1} {motive : {\u03b2 : Sort u2} \u2192 \u03b2 \u2192 Sort u1} {\u03b2 : Sort u2} {b : \u03b2} (h : HEq a b) (m : motive a) : motive b", "start": [615, 1], "end": [616, 10], "kind": "commanddeclaration"}, {"full_name": "HEq.elim", "code": "theorem HEq.elim {\u03b1 : Sort u} {a : \u03b1} {p : \u03b1 \u2192 Sort v} {b : \u03b1} (h\u2081 : HEq a b) (h\u2082 : p a) : p b", "start": [618, 1], "end": [619, 20], "kind": "commanddeclaration"}, {"full_name": "HEq.subst", "code": "theorem HEq.subst {p : (T : Sort u) \u2192 T \u2192 Prop} (h\u2081 : HEq a b) (h\u2082 : p \u03b1 a) : p \u03b2 b", "start": [621, 1], "end": [622, 20], "kind": "commanddeclaration"}, {"full_name": "HEq.symm", "code": "theorem HEq.symm (h : HEq a b) : HEq b a", "start": [624, 1], "end": [625, 21], "kind": "commanddeclaration"}, {"full_name": "heq_of_eq", "code": "theorem heq_of_eq (h : a = a') : HEq a a'", "start": [627, 1], "end": [628, 26], "kind": "commanddeclaration"}, {"full_name": "HEq.trans", "code": "theorem HEq.trans (h\u2081 : HEq a b) (h\u2082 : HEq b c) : HEq a c", "start": [630, 1], "end": [631, 18], "kind": "commanddeclaration"}, {"full_name": "heq_of_heq_of_eq", "code": "theorem heq_of_heq_of_eq (h\u2081 : HEq a b) (h\u2082 : b = b') : HEq a b'", "start": [633, 1], "end": [634, 30], "kind": "commanddeclaration"}, {"full_name": "heq_of_eq_of_heq", "code": "theorem heq_of_eq_of_heq (h\u2081 : a = a') (h\u2082 : HEq a' b) : HEq a b", "start": [636, 1], "end": [637, 30], "kind": "commanddeclaration"}, {"full_name": "type_eq_of_heq", "code": "theorem type_eq_of_heq (h : HEq a b) : \u03b1 = \u03b2", "start": [639, 1], "end": [640, 20], "kind": "commanddeclaration"}, {"full_name": "eqRec_heq", "code": "theorem eqRec_heq {\u03b1 : Sort u} {\u03c6 : \u03b1 \u2192 Sort v} {a a' : \u03b1} : (h : a = a') \u2192 (p : \u03c6 a) \u2192 HEq (Eq.recOn (motive := fun x _ => \u03c6 x) h p) p", "start": [644, 1], "end": [645, 25], "kind": "commanddeclaration"}, {"full_name": "heq_of_eqRec_eq", "code": "theorem heq_of_eqRec_eq {\u03b1 \u03b2 : Sort u} {a : \u03b1} {b : \u03b2} (h\u2081 : \u03b1 = \u03b2) (h\u2082 : Eq.rec (motive := fun \u03b1 _ => \u03b1) a h\u2081 = b) : HEq a b", "start": [647, 1], "end": [650, 11], "kind": "commanddeclaration"}, {"full_name": "cast_heq", "code": "theorem cast_heq {\u03b1 \u03b2 : Sort u} : (h : \u03b1 = \u03b2) \u2192 (a : \u03b1) \u2192 HEq (cast h a) a", "start": [652, 1], "end": [653, 25], "kind": "commanddeclaration"}, {"full_name": "iff_iff_implies_and_implies", "code": "theorem iff_iff_implies_and_implies (a b : Prop) : (a \u2194 b) \u2194 (a \u2192 b) \u2227 (b \u2192 a)", "start": [657, 1], "end": [658, 80], "kind": "commanddeclaration"}, {"full_name": "Iff.refl", "code": "theorem Iff.refl (a : Prop) : a \u2194 a", "start": [660, 1], "end": [661, 38], "kind": "commanddeclaration"}, {"full_name": "Iff.rfl", "code": "protected theorem Iff.rfl {a : Prop} : a \u2194 a", "start": [663, 1], "end": [664, 13], "kind": "commanddeclaration"}, {"full_name": "Iff.trans", "code": "theorem Iff.trans (h\u2081 : a \u2194 b) (h\u2082 : b \u2194 c) : a \u2194 c", "start": [666, 1], "end": [669, 43], "kind": "commanddeclaration"}, {"full_name": "Iff.symm", "code": "theorem Iff.symm (h : a \u2194 b) : b \u2194 a", "start": [671, 1], "end": [672, 35], "kind": "commanddeclaration"}, {"full_name": "Iff.comm", "code": "theorem Iff.comm : (a \u2194 b) \u2194 (b \u2194 a)", "start": [674, 1], "end": [675, 30], "kind": "commanddeclaration"}, {"full_name": "Iff.of_eq", "code": "theorem Iff.of_eq (h : a = b) : a \u2194 b", "start": [677, 1], "end": [678, 17], "kind": "commanddeclaration"}, {"full_name": "And.comm", "code": "theorem And.comm : a \u2227 b \u2194 b \u2227 a", "start": [680, 1], "end": [681, 52], "kind": "commanddeclaration"}, {"full_name": "Exists.elim", "code": "theorem Exists.elim {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} {b : Prop}\n   (h\u2081 : Exists (fun x => p x)) (h\u2082 : \u2200 (a : \u03b1), p a \u2192 b) : b", "start": [685, 1], "end": [688, 24], "kind": "commanddeclaration"}, {"full_name": "decide_true_eq_true", "code": "theorem decide_true_eq_true (h : Decidable True) : @decide True h = true", "start": [692, 1], "end": [695, 36], "kind": "commanddeclaration"}, {"full_name": "decide_false_eq_false", "code": "theorem decide_false_eq_false (h : Decidable False) : @decide False h = false", "start": [697, 1], "end": [700, 30], "kind": "commanddeclaration"}, {"full_name": "toBoolUsing", "code": "@[inline] def toBoolUsing {p : Prop} (d : Decidable p) : Bool :=\n  decide (h := d)", "start": [702, 1], "end": [704, 18], "kind": "commanddeclaration"}, {"full_name": "toBoolUsing_eq_true", "code": "theorem toBoolUsing_eq_true {p : Prop} (d : Decidable p) (h : p) : toBoolUsing d = true", "start": [706, 1], "end": [707, 31], "kind": "commanddeclaration"}, {"full_name": "ofBoolUsing_eq_true", "code": "theorem ofBoolUsing_eq_true {p : Prop} {d : Decidable p} (h : toBoolUsing d = true) : p", "start": [709, 1], "end": [710, 34], "kind": "commanddeclaration"}, {"full_name": "ofBoolUsing_eq_false", "code": "theorem ofBoolUsing_eq_false {p : Prop} {d : Decidable p} (h : toBoolUsing d = false) : \u00ac p", "start": [712, 1], "end": [713, 35], "kind": "commanddeclaration"}, {"full_name": "Decidable.byCases", "code": "@[macro_inline] def byCases {q : Sort u} [dec : Decidable p] (h1 : p \u2192 q) (h2 : \u00acp \u2192 q) : q :=\n  match dec with\n  | isTrue h  => h1 h\n  | isFalse h => h2 h", "start": [724, 1], "end": [732, 22], "kind": "commanddeclaration"}, {"full_name": "Decidable.em", "code": "theorem em (p : Prop) [Decidable p] : p \u2228 \u00acp", "start": [734, 1], "end": [735, 24], "kind": "commanddeclaration"}, {"full_name": "Decidable.byContradiction", "code": "theorem byContradiction [dec : Decidable p] (h : \u00acp \u2192 False) : p", "start": [738, 1], "end": [739, 43], "kind": "commanddeclaration"}, {"full_name": "Decidable.of_not_not", "code": "theorem of_not_not [Decidable p] : \u00ac \u00ac p \u2192 p", "start": [741, 1], "end": [742, 55], "kind": "commanddeclaration"}, {"full_name": "Decidable.not_and_iff_or_not", "code": "theorem not_and_iff_or_not (p q : Prop) [d\u2081 : Decidable p] [d\u2082 : Decidable q] : \u00ac (p \u2227 q) \u2194 \u00ac p \u2228 \u00ac q", "start": [744, 1], "end": [752, 26], "kind": "commanddeclaration"}, {"full_name": "decidable_of_decidable_of_iff", "code": "@[inline] def decidable_of_decidable_of_iff [Decidable p] (h : p \u2194 q) : Decidable q :=\n  if hp : p then\n    isTrue (Iff.mp h hp)\n  else\n    isFalse fun hq => absurd (Iff.mpr h hq) hp", "start": [758, 1], "end": [763, 47], "kind": "commanddeclaration"}, {"full_name": "decidable_of_decidable_of_eq", "code": "@[inline] def decidable_of_decidable_of_eq [Decidable p] (h : p = q) : Decidable q :=\n  decidable_of_decidable_of_iff (p := p) (h \u25b8 Iff.rfl)", "start": [765, 1], "end": [767, 55], "kind": "commanddeclaration"}, {"full_name": "if_pos", "code": "theorem if_pos {c : Prop} {h : Decidable c} (hc : c) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = t", "start": [790, 1], "end": [793, 33], "kind": "commanddeclaration"}, {"full_name": "if_neg", "code": "theorem if_neg {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t e : \u03b1} : (ite c t e) = e", "start": [795, 1], "end": [798, 23], "kind": "commanddeclaration"}, {"full_name": "iteInduction", "code": "def iteInduction {c} [inst : Decidable c] {motive : \u03b1 \u2192 Sort _} {t e : \u03b1}\n    (hpos : c \u2192 motive t) (hneg : \u00acc \u2192 motive e) : motive (ite c t e) :=\n  match inst with\n  | isTrue h => hpos h\n  | isFalse h => hneg h", "start": [800, 1], "end": [805, 24], "kind": "commanddeclaration"}, {"full_name": "dif_pos", "code": "theorem dif_pos {c : Prop} {h : Decidable c} (hc : c) {\u03b1 : Sort u} {t : c \u2192 \u03b1} {e : \u00ac c \u2192 \u03b1} : (dite c t e) = t hc", "start": [807, 1], "end": [810, 33], "kind": "commanddeclaration"}, {"full_name": "dif_neg", "code": "theorem dif_neg {c : Prop} {h : Decidable c} (hnc : \u00acc) {\u03b1 : Sort u} {t : c \u2192 \u03b1} {e : \u00ac c \u2192 \u03b1} : (dite c t e) = e hnc", "start": [812, 1], "end": [815, 23], "kind": "commanddeclaration"}, {"full_name": "dif_eq_if", "code": "theorem dif_eq_if (c : Prop) {h : Decidable c} {\u03b1 : Sort u} (t : \u03b1) (e : \u03b1) : dite c (fun _ => t) (fun _ => e) = ite c t e", "start": [818, 1], "end": [821, 23], "kind": "commanddeclaration"}, {"full_name": "noConfusionTypeEnum", "code": "abbrev noConfusionTypeEnum {\u03b1 : Sort u} {\u03b2 : Sort v} [inst : DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (P : Sort w) (x y : \u03b1) : Sort w :=\n  (inst (f x) (f y)).casesOn\n    (fun _ => P)\n    (fun _ => P \u2192 P)", "start": [833, 1], "end": [837, 21], "kind": "commanddeclaration"}, {"full_name": "noConfusionEnum", "code": "abbrev noConfusionEnum {\u03b1 : Sort u} {\u03b2 : Sort v} [inst : DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) {P : Sort w} {x y : \u03b1} (h : x = y) : noConfusionTypeEnum f P x y :=\n  Decidable.casesOn\n    (motive := fun (inst : Decidable (f x = f y)) => Decidable.casesOn (motive := fun _ => Sort w) inst (fun _ => P) (fun _ => P \u2192 P))\n    (inst (f x) (f y))\n    (fun h' => False.elim (h' (congrArg f h)))\n    (fun _ => fun x => x)", "start": [839, 1], "end": [845, 26], "kind": "commanddeclaration"}, {"full_name": "nonempty_of_exists", "code": "theorem nonempty_of_exists {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} : Exists (fun x => p x) \u2192 Nonempty \u03b1", "start": [854, 1], "end": [855, 18], "kind": "commanddeclaration"}, {"full_name": "Subsingleton", "code": "class Subsingleton (\u03b1 : Sort u) : Prop where\n  \n  intro ::\n  \n  allEq : (a b : \u03b1) \u2192 a = b", "start": [859, 1], "end": [871, 28], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.elim", "code": "protected theorem Subsingleton.elim {\u03b1 : Sort u} [h : Subsingleton \u03b1] : (a b : \u03b1) \u2192 a = b", "start": [873, 1], "end": [874, 10], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.helim", "code": "protected theorem Subsingleton.helim {\u03b1 \u03b2 : Sort u} [h\u2081 : Subsingleton \u03b1] (h\u2082 : \u03b1 = \u03b2) (a : \u03b1) (b : \u03b2) : HEq a b", "start": [876, 1], "end": [879, 26], "kind": "commanddeclaration"}, {"full_name": "recSubsingleton", "code": "theorem recSubsingleton\n     {p : Prop} [h : Decidable p]\n     {h\u2081 : p \u2192 Sort u}\n     {h\u2082 : \u00acp \u2192 Sort u}\n     [h\u2083 : \u2200 (h : p), Subsingleton (h\u2081 h)]\n     [h\u2084 : \u2200 (h : \u00acp), Subsingleton (h\u2082 h)]\n     : Subsingleton (h.casesOn h\u2082 h\u2081)", "start": [893, 1], "end": [902, 22], "kind": "commanddeclaration"}, {"full_name": "Equivalence", "code": "structure Equivalence {\u03b1 : Sort u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  \n  refl  : \u2200 x, r x x\n  \n  symm  : \u2200 {x y}, r x y \u2192 r y x\n  \n  trans : \u2200 {x y z}, r x y \u2192 r y z \u2192 r x z", "start": [904, 1], "end": [921, 43], "kind": "commanddeclaration"}, {"full_name": "emptyRelation", "code": "def emptyRelation {\u03b1 : Sort u} (_ _ : \u03b1) : Prop :=\n  False", "start": [923, 1], "end": [925, 8], "kind": "commanddeclaration"}, {"full_name": "Subrelation", "code": "def Subrelation {\u03b1 : Sort u} (q r : \u03b1 \u2192 \u03b1 \u2192 Prop) :=\n  \u2200 {x y}, q x y \u2192 r x y", "start": [927, 1], "end": [932, 25], "kind": "commanddeclaration"}, {"full_name": "InvImage", "code": "def InvImage {\u03b1 : Sort u} {\u03b2 : Sort v} (r : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2) : \u03b1 \u2192 \u03b1 \u2192 Prop :=\n  fun a\u2081 a\u2082 => r (f a\u2081) (f a\u2082)", "start": [934, 1], "end": [939, 31], "kind": "commanddeclaration"}, {"full_name": "TC", "code": "inductive TC {\u03b1 : Sort u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : \u03b1 \u2192 \u03b1 \u2192 Prop where\n  \n  | base  : \u2200 a b, r a b \u2192 TC r a b\n  \n  | trans : \u2200 a b c, TC r a b \u2192 TC r b c \u2192 TC r a c", "start": [941, 1], "end": [950, 52], "kind": "commanddeclaration"}, {"full_name": "Subtype.existsOfSubtype", "code": "theorem existsOfSubtype {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} : { x // p x } \u2192 Exists (fun x => p x)", "start": [955, 1], "end": [956, 21], "kind": "commanddeclaration"}, {"full_name": "Subtype.eq", "code": "protected theorem eq : \u2200 {a1 a2 : {x // p x}}, val a1 = val a2 \u2192 a1 = a2", "start": [960, 1], "end": [961, 31], "kind": "commanddeclaration"}, {"full_name": "Subtype.eta", "code": "theorem eta (a : {x // p x}) (h : p (val a)) : mk (val a) h = a", "start": [963, 1], "end": [965, 12], "kind": "commanddeclaration"}, {"full_name": "Sum.inhabitedLeft", "code": "instance Sum.inhabitedLeft [Inhabited \u03b1] : Inhabited (Sum \u03b1 \u03b2) where\n  default := Sum.inl default", "start": [982, 1], "end": [983, 29], "kind": "commanddeclaration"}, {"full_name": "Sum.inhabitedRight", "code": "instance Sum.inhabitedRight [Inhabited \u03b2] : Inhabited (Sum \u03b1 \u03b2) where\n  default := Sum.inr default", "start": [985, 1], "end": [986, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.lexLt", "code": "def Prod.lexLt [LT \u03b1] [LT \u03b2] (s : \u03b1 \u00d7 \u03b2) (t : \u03b1 \u00d7 \u03b2) : Prop :=\n  s.1 < t.1 \u2228 (s.1 = t.1 \u2227 s.2 < t.2)", "start": [1024, 1], "end": [1026, 38], "kind": "commanddeclaration"}, {"full_name": "Prod.lexLtDec", "code": "instance Prod.lexLtDec\n    [LT \u03b1] [LT \u03b2] [DecidableEq \u03b1] [DecidableEq \u03b2]\n    [(a b : \u03b1) \u2192 Decidable (a < b)] [(a b : \u03b2) \u2192 Decidable (a < b)]\n    : (s t : \u03b1 \u00d7 \u03b2) \u2192 Decidable (Prod.lexLt s t) :=\n  fun _ _ => inferInstanceAs (Decidable (_ \u2228 _))", "start": [1028, 1], "end": [1032, 49], "kind": "commanddeclaration"}, {"full_name": "Prod.lexLt_def", "code": "theorem Prod.lexLt_def [LT \u03b1] [LT \u03b2] (s t : \u03b1 \u00d7 \u03b2) : (Prod.lexLt s t) = (s.1 < t.1 \u2228 (s.1 = t.1 \u2227 s.2 < t.2))", "start": [1034, 1], "end": [1035, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.eta", "code": "theorem Prod.eta (p : \u03b1 \u00d7 \u03b2) : (p.1, p.2) = p", "start": [1037, 1], "end": [1037, 53], "kind": "commanddeclaration"}, {"full_name": "Prod.map", "code": "def Prod.map {\u03b1\u2081 : Type u\u2081} {\u03b1\u2082 : Type u\u2082} {\u03b2\u2081 : Type v\u2081} {\u03b2\u2082 : Type v\u2082}\n    (f : \u03b1\u2081 \u2192 \u03b1\u2082) (g : \u03b2\u2081 \u2192 \u03b2\u2082) : \u03b1\u2081 \u00d7 \u03b2\u2081 \u2192 \u03b1\u2082 \u00d7 \u03b2\u2082\n  | (a, b) => (f a, g b)", "start": [1039, 1], "end": [1045, 25], "kind": "commanddeclaration"}, {"full_name": "ex_of_PSigma", "code": "theorem ex_of_PSigma {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} : (PSigma (fun x => p x)) \u2192 Exists (fun x => p x)", "start": [1049, 1], "end": [1050, 23], "kind": "commanddeclaration"}, {"full_name": "PSigma.eta", "code": "protected theorem PSigma.eta {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {a\u2081 a\u2082 : \u03b1} {b\u2081 : \u03b2 a\u2081} {b\u2082 : \u03b2 a\u2082}\n    (h\u2081 : a\u2081 = a\u2082) (h\u2082 : Eq.ndrec b\u2081 h\u2081 = b\u2082) : PSigma.mk a\u2081 b\u2081 = PSigma.mk a\u2082 b\u2082", "start": [1052, 1], "end": [1056, 12], "kind": "commanddeclaration"}, {"full_name": "PUnit.subsingleton", "code": "theorem PUnit.subsingleton (a b : PUnit) : a = b", "start": [1060, 1], "end": [1061, 30], "kind": "commanddeclaration"}, {"full_name": "PUnit.eq_punit", "code": "theorem PUnit.eq_punit (a : PUnit) : a = \u27e8\u27e9", "start": [1063, 1], "end": [1064, 26], "kind": "commanddeclaration"}, {"full_name": "Setoid", "code": "class Setoid (\u03b1 : Sort u) where\n  \n  r : \u03b1 \u2192 \u03b1 \u2192 Prop\n  \n  iseqv : Equivalence r", "start": [1077, 1], "end": [1085, 24], "kind": "commanddeclaration"}, {"full_name": "Setoid.refl", "code": "theorem refl (a : \u03b1) : a \u2248 a", "start": [1094, 1], "end": [1095, 15], "kind": "commanddeclaration"}, {"full_name": "Setoid.symm", "code": "theorem symm {a b : \u03b1} (hab : a \u2248 b) : b \u2248 a", "start": [1097, 1], "end": [1098, 17], "kind": "commanddeclaration"}, {"full_name": "Setoid.trans", "code": "theorem trans {a b c : \u03b1} (hab : a \u2248 b) (hbc : b \u2248 c) : a \u2248 c", "start": [1100, 1], "end": [1101, 22], "kind": "commanddeclaration"}, {"full_name": "propext", "code": "axiom propext {a b : Prop} : (a \u2194 b) \u2192 a = b", "start": [1108, 1], "end": [1142, 45], "kind": "commanddeclaration"}, {"full_name": "Eq.propIntro", "code": "theorem Eq.propIntro {a b : Prop} (h\u2081 : a \u2192 b) (h\u2082 : b \u2192 a) : a = b", "start": [1144, 1], "end": [1145, 29], "kind": "commanddeclaration"}, {"full_name": "beq_iff_eq", "code": "@[simp] theorem beq_iff_eq [BEq \u03b1] [LawfulBEq \u03b1] (a b : \u03b1) : a == b \u2194 a = b", "start": [1169, 1], "end": [1170, 56], "kind": "commanddeclaration"}, {"full_name": "Iff.subst", "code": "theorem Iff.subst {a b : Prop} {p : Prop \u2192 Prop} (h\u2081 : a \u2194 b) (h\u2082 : p a) : p b", "start": [1174, 1], "end": [1176, 27], "kind": "commanddeclaration"}, {"full_name": "Quot.sound", "code": "axiom sound : \u2200 {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b : \u03b1}, r a b \u2192 Quot.mk r a = Quot.mk r b", "start": [1179, 1], "end": [1209, 93], "kind": "commanddeclaration"}, {"full_name": "Quot.liftBeta", "code": "protected theorem liftBeta {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {\u03b2 : Sort v}\n    (f : \u03b1 \u2192 \u03b2)\n    (c : (a b : \u03b1) \u2192 r a b \u2192 f a = f b)\n    (a : \u03b1)\n    : lift f c (Quot.mk r a) = f a", "start": [1211, 1], "end": [1216, 6], "kind": "commanddeclaration"}, {"full_name": "Quot.indBeta", "code": "protected theorem indBeta {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {motive : Quot r \u2192 Prop}\n    (p : (a : \u03b1) \u2192 motive (Quot.mk r a))\n    (a : \u03b1)\n    : (ind p (Quot.mk r a) : motive (Quot.mk r a)) = p a", "start": [1218, 1], "end": [1222, 6], "kind": "commanddeclaration"}, {"full_name": "Quot.liftOn", "code": "protected abbrev liftOn {\u03b1 : Sort u} {\u03b2 : Sort v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n  (q : Quot r) (f : \u03b1 \u2192 \u03b2) (c : (a b : \u03b1) \u2192 r a b \u2192 f a = f b) : \u03b2 :=\n  lift f c q", "start": [1224, 1], "end": [1230, 13], "kind": "commanddeclaration"}, {"full_name": "Quot.inductionOn", "code": "@[elab_as_elim]\nprotected theorem inductionOn {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {motive : Quot r \u2192 Prop}\n    (q : Quot r)\n    (h : (a : \u03b1) \u2192 motive (Quot.mk r a))\n    : motive q", "start": [1232, 1], "end": [1237, 10], "kind": "commanddeclaration"}, {"full_name": "Quot.exists_rep", "code": "theorem exists_rep {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (q : Quot r) : Exists (fun a => (Quot.mk r a) = q)", "start": [1239, 1], "end": [1240, 36], "kind": "commanddeclaration"}, {"full_name": "Quot.indep", "code": "@[reducible, macro_inline]\nprotected def indep (f : (a : \u03b1) \u2192 motive (Quot.mk r a)) (a : \u03b1) : PSigma motive :=\n  \u27e8Quot.mk r a, f a\u27e9", "start": [1247, 1], "end": [1250, 21], "kind": "commanddeclaration"}, {"full_name": "Quot.indepCoherent", "code": "protected theorem indepCoherent\n    (f : (a : \u03b1) \u2192 motive (Quot.mk r a))\n    (h : (a b : \u03b1) \u2192 (p : r a b) \u2192 Eq.ndrec (f a) (sound p) = f b)\n    : (a b : \u03b1) \u2192 r a b \u2192 Quot.indep f a = Quot.indep f b", "start": [1252, 1], "end": [1256, 46], "kind": "commanddeclaration"}, {"full_name": "Quot.liftIndepPr1", "code": "protected theorem liftIndepPr1\n    (f : (a : \u03b1) \u2192 motive (Quot.mk r a))\n    (h : \u2200 (a b : \u03b1) (p : r a b), Eq.ndrec (f a) (sound p) = f b)\n    (q : Quot r)\n    : (lift (Quot.indep f) (Quot.indepCoherent f h) q).1 = q", "start": [1258, 1], "end": [1264, 11], "kind": "commanddeclaration"}, {"full_name": "Quot.rec", "code": "protected abbrev rec\n    (f : (a : \u03b1) \u2192 motive (Quot.mk r a))\n    (h : (a b : \u03b1) \u2192 (p : r a b) \u2192 Eq.ndrec (f a) (sound p) = f b)\n    (q : Quot r) : motive q :=\n  Eq.ndrecOn (Quot.liftIndepPr1 f h q) ((lift (Quot.indep f) (Quot.indepCoherent f h) q).2)", "start": [1266, 1], "end": [1278, 92], "kind": "commanddeclaration"}, {"full_name": "Quot.recOn", "code": "@[inherit_doc Quot.rec] protected abbrev recOn\n    (q : Quot r)\n    (f : (a : \u03b1) \u2192 motive (Quot.mk r a))\n    (h : (a b : \u03b1) \u2192 (p : r a b) \u2192 Eq.ndrec (f a) (sound p) = f b)\n    : motive q :=\n q.rec f h", "start": [1280, 1], "end": [1285, 11], "kind": "commanddeclaration"}, {"full_name": "Quot.recOnSubsingleton", "code": "protected abbrev recOnSubsingleton\n    [h : (a : \u03b1) \u2192 Subsingleton (motive (Quot.mk r a))]\n    (q : Quot r)\n    (f : (a : \u03b1) \u2192 motive (Quot.mk r a))\n    : motive q := by\n  induction q using Quot.rec\n  apply f\n  apply Subsingleton.elim", "start": [1287, 1], "end": [1298, 26], "kind": "commanddeclaration"}, {"full_name": "Quot.hrecOn", "code": "protected abbrev hrecOn\n    (q : Quot r)\n    (f : (a : \u03b1) \u2192 motive (Quot.mk r a))\n    (c : (a b : \u03b1) \u2192 (p : r a b) \u2192 HEq (f a) (f b))\n    : motive q :=\n  Quot.recOn q f fun a b p => eq_of_heq <|\n    have p\u2081 : HEq (Eq.ndrec (f a) (sound p)) (f a) := eqRec_heq (sound p) (f a)\n    HEq.trans p\u2081 (c a b p)", "start": [1300, 1], "end": [1312, 27], "kind": "commanddeclaration"}, {"full_name": "Quotient", "code": "def Quotient {\u03b1 : Sort u} (s : Setoid \u03b1) :=\n  @Quot \u03b1 Setoid.r", "start": [1318, 1], "end": [1324, 19], "kind": "commanddeclaration"}, {"full_name": "Quotient.mk", "code": "@[inline]\nprotected def mk {\u03b1 : Sort u} (s : Setoid \u03b1) (a : \u03b1) : Quotient s :=\n  Quot.mk Setoid.r a", "start": [1328, 1], "end": [1331, 21], "kind": "commanddeclaration"}, {"full_name": "Quotient.mk'", "code": "protected def mk' {\u03b1 : Sort u} [s : Setoid \u03b1] (a : \u03b1) : Quotient s :=\n  Quotient.mk s a", "start": [1333, 1], "end": [1338, 18], "kind": "commanddeclaration"}, {"full_name": "Quotient.sound", "code": "def sound {\u03b1 : Sort u} {s : Setoid \u03b1} {a b : \u03b1} : a \u2248 b \u2192 Quotient.mk s a = Quotient.mk s b :=\n  Quot.sound", "start": [1340, 1], "end": [1345, 13], "kind": "commanddeclaration"}, {"full_name": "Quotient.lift", "code": "protected abbrev lift {\u03b1 : Sort u} {\u03b2 : Sort v} {s : Setoid \u03b1} (f : \u03b1 \u2192 \u03b2) : ((a b : \u03b1) \u2192 a \u2248 b \u2192 f a = f b) \u2192 Quotient s \u2192 \u03b2 :=\n  Quot.lift f", "start": [1347, 1], "end": [1352, 14], "kind": "commanddeclaration"}, {"full_name": "Quotient.ind", "code": "protected theorem ind {\u03b1 : Sort u} {s : Setoid \u03b1} {motive : Quotient s \u2192 Prop} : ((a : \u03b1) \u2192 motive (Quotient.mk s a)) \u2192 (q : Quotient s) \u2192 motive q", "start": [1354, 1], "end": [1356, 11], "kind": "commanddeclaration"}, {"full_name": "Quotient.liftOn", "code": "protected abbrev liftOn {\u03b1 : Sort u} {\u03b2 : Sort v} {s : Setoid \u03b1} (q : Quotient s) (f : \u03b1 \u2192 \u03b2) (c : (a b : \u03b1) \u2192 a \u2248 b \u2192 f a = f b) : \u03b2 :=\n  Quot.liftOn q f c", "start": [1358, 1], "end": [1363, 20], "kind": "commanddeclaration"}, {"full_name": "Quotient.inductionOn", "code": "@[elab_as_elim]\nprotected theorem inductionOn {\u03b1 : Sort u} {s : Setoid \u03b1} {motive : Quotient s \u2192 Prop}\n    (q : Quotient s)\n    (h : (a : \u03b1) \u2192 motive (Quotient.mk s a))\n    : motive q", "start": [1365, 1], "end": [1371, 23], "kind": "commanddeclaration"}, {"full_name": "Quotient.exists_rep", "code": "theorem exists_rep {\u03b1 : Sort u} {s : Setoid \u03b1} (q : Quotient s) : Exists (fun (a : \u03b1) => Quotient.mk s a = q)", "start": [1373, 1], "end": [1374, 20], "kind": "commanddeclaration"}, {"full_name": "Quotient.rec", "code": "@[inline, elab_as_elim]\nprotected def rec\n    (f : (a : \u03b1) \u2192 motive (Quotient.mk s a))\n    (h : (a b : \u03b1) \u2192 (p : a \u2248 b) \u2192 Eq.ndrec (f a) (Quotient.sound p) = f b)\n    (q : Quotient s)\n    : motive q :=\n  Quot.rec f h q", "start": [1381, 1], "end": [1388, 17], "kind": "commanddeclaration"}, {"full_name": "Quotient.recOn", "code": "@[elab_as_elim]\nprotected abbrev recOn\n    (q : Quotient s)\n    (f : (a : \u03b1) \u2192 motive (Quotient.mk s a))\n    (h : (a b : \u03b1) \u2192 (p : a \u2248 b) \u2192 Eq.ndrec (f a) (Quotient.sound p) = f b)\n    : motive q :=\n  Quot.recOn q f h", "start": [1390, 1], "end": [1397, 19], "kind": "commanddeclaration"}, {"full_name": "Quotient.recOnSubsingleton", "code": "@[elab_as_elim]\nprotected abbrev recOnSubsingleton\n    [h : (a : \u03b1) \u2192 Subsingleton (motive (Quotient.mk s a))]\n    (q : Quotient s)\n    (f : (a : \u03b1) \u2192 motive (Quotient.mk s a))\n    : motive q :=\n  Quot.recOnSubsingleton (h := h) q f", "start": [1399, 1], "end": [1406, 38], "kind": "commanddeclaration"}, {"full_name": "Quotient.hrecOn", "code": "@[elab_as_elim]\nprotected abbrev hrecOn\n    (q : Quotient s)\n    (f : (a : \u03b1) \u2192 motive (Quotient.mk s a))\n    (c : (a b : \u03b1) \u2192 (p : a \u2248 b) \u2192 HEq (f a) (f b))\n    : motive q :=\n  Quot.hrecOn q f c", "start": [1408, 1], "end": [1415, 20], "kind": "commanddeclaration"}, {"full_name": "Quotient.lift\u2082", "code": "protected abbrev lift\u2082\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03c6)\n    (c : (a\u2081 : \u03b1) \u2192 (b\u2081 : \u03b2) \u2192 (a\u2082 : \u03b1) \u2192 (b\u2082 : \u03b2) \u2192 a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 f a\u2081 b\u2081 = f a\u2082 b\u2082)\n    (q\u2081 : Quotient s\u2081) (q\u2082 : Quotient s\u2082)\n    : \u03c6 := by\n  apply Quotient.lift (fun (a\u2081 : \u03b1) => Quotient.lift (f a\u2081) (fun (a b : \u03b2) => c a\u2081 a a\u2081 b (Setoid.refl a\u2081)) q\u2082) _ q\u2081\n  intros\n  induction q\u2082 using Quotient.ind\n  apply c; assumption; apply Setoid.refl", "start": [1423, 1], "end": [1432, 41], "kind": "commanddeclaration"}, {"full_name": "Quotient.liftOn\u2082", "code": "protected abbrev liftOn\u2082\n    (q\u2081 : Quotient s\u2081)\n    (q\u2082 : Quotient s\u2082)\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03c6)\n    (c : (a\u2081 : \u03b1) \u2192 (b\u2081 : \u03b2) \u2192 (a\u2082 : \u03b1) \u2192 (b\u2082 : \u03b2) \u2192 a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 f a\u2081 b\u2081 = f a\u2082 b\u2082)\n    : \u03c6 :=\n  Quotient.lift\u2082 f c q\u2081 q\u2082", "start": [1434, 1], "end": [1441, 27], "kind": "commanddeclaration"}, {"full_name": "Quotient.ind\u2082", "code": "@[elab_as_elim]\nprotected theorem ind\u2082\n    {motive : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Prop}\n    (h : (a : \u03b1) \u2192 (b : \u03b2) \u2192 motive (Quotient.mk s\u2081 a) (Quotient.mk s\u2082 b))\n    (q\u2081 : Quotient s\u2081)\n    (q\u2082 : Quotient s\u2082)\n    : motive q\u2081 q\u2082", "start": [1443, 1], "end": [1452, 10], "kind": "commanddeclaration"}, {"full_name": "Quotient.inductionOn\u2082", "code": "@[elab_as_elim]\nprotected theorem inductionOn\u2082\n    {motive : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Prop}\n    (q\u2081 : Quotient s\u2081)\n    (q\u2082 : Quotient s\u2082)\n    (h : (a : \u03b1) \u2192 (b : \u03b2) \u2192 motive (Quotient.mk s\u2081 a) (Quotient.mk s\u2082 b))\n    : motive q\u2081 q\u2082", "start": [1454, 1], "end": [1463, 10], "kind": "commanddeclaration"}, {"full_name": "Quotient.inductionOn\u2083", "code": "@[elab_as_elim]\nprotected theorem inductionOn\u2083\n    {s\u2083 : Setoid \u03c6}\n    {motive : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Quotient s\u2083 \u2192 Prop}\n    (q\u2081 : Quotient s\u2081)\n    (q\u2082 : Quotient s\u2082)\n    (q\u2083 : Quotient s\u2083)\n    (h : (a : \u03b1) \u2192 (b : \u03b2) \u2192 (c : \u03c6) \u2192 motive (Quotient.mk s\u2081 a) (Quotient.mk s\u2082 b) (Quotient.mk s\u2083 c))\n    : motive q\u2081 q\u2082 q\u2083", "start": [1465, 1], "end": [1477, 10], "kind": "commanddeclaration"}, {"full_name": "Quotient.rel", "code": "private def rel {s : Setoid \u03b1} (q\u2081 q\u2082 : Quotient s) : Prop :=\n  Quotient.liftOn\u2082 q\u2081 q\u2082\n    (fun a\u2081 a\u2082 => a\u2081 \u2248 a\u2082)\n    (fun _ _ _ _ a\u2081b\u2081 a\u2082b\u2082 =>\n      propext (Iff.intro\n        (fun a\u2081a\u2082 => Setoid.trans (Setoid.symm a\u2081b\u2081) (Setoid.trans a\u2081a\u2082 a\u2082b\u2082))\n        (fun b\u2081b\u2082 => Setoid.trans a\u2081b\u2081 (Setoid.trans b\u2081b\u2082 (Setoid.symm a\u2082b\u2082)))))", "start": [1485, 1], "end": [1491, 81], "kind": "commanddeclaration"}, {"full_name": "Quotient.rel.refl", "code": "private theorem rel.refl {s : Setoid \u03b1} (q : Quotient s) : rel q q", "start": [1493, 1], "end": [1494, 28], "kind": "commanddeclaration"}, {"full_name": "Quotient.rel_of_eq", "code": "private theorem rel_of_eq {s : Setoid \u03b1} {q\u2081 q\u2082 : Quotient s} : q\u2081 = q\u2082 \u2192 rel q\u2081 q\u2082", "start": [1496, 1], "end": [1497, 38], "kind": "commanddeclaration"}, {"full_name": "Quotient.exact", "code": "theorem exact {s : Setoid \u03b1} {a b : \u03b1} : Quotient.mk s a = Quotient.mk s b \u2192 a \u2248 b", "start": [1499, 1], "end": [1500, 23], "kind": "commanddeclaration"}, {"full_name": "Quotient.recOnSubsingleton\u2082", "code": "@[elab_as_elim]\nprotected abbrev recOnSubsingleton\u2082\n    {motive : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Sort uC}\n    [s : (a : \u03b1) \u2192 (b : \u03b2) \u2192 Subsingleton (motive (Quotient.mk s\u2081 a) (Quotient.mk s\u2082 b))]\n    (q\u2081 : Quotient s\u2081)\n    (q\u2082 : Quotient s\u2082)\n    (g : (a : \u03b1) \u2192 (b : \u03b2) \u2192 motive (Quotient.mk s\u2081 a) (Quotient.mk s\u2082 b))\n    : motive q\u2081 q\u2082 := by\n  induction q\u2081 using Quot.recOnSubsingleton\n  induction q\u2082 using Quot.recOnSubsingleton\n  apply g\n  intro a; apply s\n  induction q\u2082 using Quot.recOnSubsingleton\n  intro a; apply s\n  infer_instance", "start": [1509, 1], "end": [1524, 17], "kind": "commanddeclaration"}, {"full_name": "funext", "code": "theorem funext {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {f g : (x : \u03b1) \u2192 \u03b2 x}\n    (h : \u2200 x, f x = g x) : f = g", "start": [1543, 1], "end": [1563, 42], "kind": "commanddeclaration"}, {"full_name": "Squash", "code": "def Squash (\u03b1 : Type u) := Quot (fun (_ _ : \u03b1) => True)", "start": [1570, 1], "end": [1584, 56], "kind": "commanddeclaration"}, {"full_name": "Squash.mk", "code": "def Squash.mk {\u03b1 : Type u} (x : \u03b1) : Squash \u03b1 := Quot.mk _ x", "start": [1586, 1], "end": [1587, 61], "kind": "commanddeclaration"}, {"full_name": "Squash.ind", "code": "theorem Squash.ind {\u03b1 : Type u} {motive : Squash \u03b1 \u2192 Prop} (h : \u2200 (a : \u03b1), motive (Squash.mk a)) : \u2200 (q : Squash \u03b1), motive q", "start": [1589, 1], "end": [1590, 13], "kind": "commanddeclaration"}, {"full_name": "Squash.lift", "code": "@[inline] def Squash.lift {\u03b1 \u03b2} [Subsingleton \u03b2] (s : Squash \u03b1) (f : \u03b1 \u2192 \u03b2) : \u03b2 :=\n  Quot.lift f (fun _ _ _ => Subsingleton.elim _ _) s", "start": [1592, 1], "end": [1594, 53], "kind": "commanddeclaration"}, {"full_name": "Antisymm", "code": "class Antisymm {\u03b1 : Sort u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) where\n  \n  antisymm {a b : \u03b1} : r a b \u2192 r b a \u2192 a = b", "start": [1605, 1], "end": [1610, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.trustCompiler", "code": "axiom trustCompiler : True", "start": [1615, 1], "end": [1618, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.reduceBool", "code": "opaque reduceBool (b : Bool) : Bool :=\n  have := trustCompiler\n  b", "start": [1620, 1], "end": [1642, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.reduceNat", "code": "opaque reduceNat (n : Nat) : Nat :=\n  have := trustCompiler\n  n", "start": [1644, 1], "end": [1654, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.ofReduceBool", "code": "axiom ofReduceBool (a b : Bool) (h : reduceBool a = b) : a = b", "start": [1657, 1], "end": [1670, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.ofReduceNat", "code": "axiom ofReduceNat (a b : Nat) (h : reduceNat a = b) : a = b", "start": [1672, 1], "end": [1681, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IsAssociative", "code": "class IsAssociative {\u03b1 : Sort u} (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) where\n  \n  assoc : (a b c : \u03b1) \u2192 op (op a b) c = op a (op b c)", "start": [1683, 1], "end": [1689, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.IsCommutative", "code": "class IsCommutative {\u03b1 : Sort u} (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) where\n  \n  comm : (a b : \u03b1) \u2192 op a b = op b a", "start": [1691, 1], "end": [1697, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IsIdempotent", "code": "class IsIdempotent {\u03b1 : Sort u} (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) where\n  \n  idempotent : (x : \u03b1) \u2192 op x x = x", "start": [1699, 1], "end": [1706, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IsNeutral", "code": "class IsNeutral {\u03b1 : Sort u} (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (neutral : \u03b1) where\n  \n  left_neutral : (a : \u03b1) \u2192 op neutral a = a\n  \n  right_neutral : (a : \u03b1) \u2192 op a neutral = a", "start": [1708, 1], "end": [1717, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "imports": ["lake-packages/lean4/src/lean/Init/Core.lean"], "premises": [{"full_name": "of_eq_true", "code": "theorem of_eq_true (h : p = True) : p", "start": [12, 1], "end": [12, 53], "kind": "commanddeclaration"}, {"full_name": "eq_true", "code": "theorem eq_true (h : p) : p = True", "start": [14, 1], "end": [15, 41], "kind": "commanddeclaration"}, {"full_name": "eq_false", "code": "theorem eq_false (h : \u00ac p) : p = False", "start": [17, 1], "end": [18, 59], "kind": "commanddeclaration"}, {"full_name": "eq_false'", "code": "theorem eq_false' (h : p \u2192 False) : p = False", "start": [20, 1], "end": [20, 60], "kind": "commanddeclaration"}, {"full_name": "eq_true_of_decide", "code": "theorem eq_true_of_decide {p : Prop} {_ : Decidable p} (h : decide p = true) : p = True", "start": [22, 1], "end": [23, 32], "kind": "commanddeclaration"}, {"full_name": "eq_false_of_decide", "code": "theorem eq_false_of_decide {p : Prop} {_ : Decidable p} (h : decide p = false) : p = False", "start": [25, 1], "end": [26, 34], "kind": "commanddeclaration"}, {"full_name": "eq_self", "code": "@[simp] theorem eq_self (a : \u03b1) : (a = a) = True", "start": [28, 1], "end": [28, 64], "kind": "commanddeclaration"}, {"full_name": "implies_congr", "code": "theorem implies_congr {p\u2081 p\u2082 : Sort u} {q\u2081 q\u2082 : Sort v} (h\u2081 : p\u2081 = p\u2082) (h\u2082 : q\u2081 = q\u2082) : (p\u2081 \u2192 q\u2081) = (p\u2082 \u2192 q\u2082)", "start": [30, 1], "end": [31, 16], "kind": "commanddeclaration"}, {"full_name": "implies_dep_congr_ctx", "code": "theorem implies_dep_congr_ctx {p\u2081 p\u2082 q\u2081 : Prop} (h\u2081 : p\u2081 = p\u2082) {q\u2082 : p\u2082 \u2192 Prop} (h\u2082 : (h : p\u2082) \u2192 q\u2081 = q\u2082 h) : (p\u2081 \u2192 q\u2081) = ((h : p\u2082) \u2192 q\u2082 h)", "start": [33, 1], "end": [36, 57], "kind": "commanddeclaration"}, {"full_name": "implies_congr_ctx", "code": "theorem implies_congr_ctx {p\u2081 p\u2082 q\u2081 q\u2082 : Prop} (h\u2081 : p\u2081 = p\u2082) (h\u2082 : p\u2082 \u2192 q\u2081 = q\u2082) : (p\u2081 \u2192 q\u2081) = (p\u2082 \u2192 q\u2082)", "start": [38, 1], "end": [39, 30], "kind": "commanddeclaration"}, {"full_name": "forall_congr", "code": "theorem forall_congr {\u03b1 : Sort u} {p q : \u03b1 \u2192 Prop} (h : \u2200 a, p a = q a) : (\u2200 a, p a) = (\u2200 a, q a)", "start": [41, 1], "end": [42, 27], "kind": "commanddeclaration"}, {"full_name": "let_congr", "code": "theorem let_congr {\u03b1 : Sort u} {\u03b2 : Sort v} {a a' : \u03b1} {b b' : \u03b1 \u2192 \u03b2}\n    (h\u2081 : a = a') (h\u2082 : \u2200 x, b x = b' x) : (let x := a; b x) = (let x := a'; b' x)", "start": [44, 1], "end": [46, 34], "kind": "commanddeclaration"}, {"full_name": "let_val_congr", "code": "theorem let_val_congr {\u03b1 : Sort u} {\u03b2 : Sort v} {a a' : \u03b1}\n    (b : \u03b1 \u2192 \u03b2) (h : a = a') : (let x := a; b x) = (let x := a'; b x)", "start": [48, 1], "end": [49, 81], "kind": "commanddeclaration"}, {"full_name": "let_body_congr", "code": "theorem let_body_congr {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {b b' : (a : \u03b1) \u2192 \u03b2 a}\n    (a : \u03b1) (h : \u2200 x, b x = b' x) : (let x := a; b x) = (let x := a; b' x)", "start": [51, 1], "end": [53, 28], "kind": "commanddeclaration"}, {"full_name": "ite_congr", "code": "@[congr]\ntheorem ite_congr {x y u v : \u03b1} {s : Decidable b} [Decidable c]\n    (h\u2081 : b = c) (h\u2082 : c \u2192 x = u) (h\u2083 : \u00ac c \u2192 y = v) : ite b x y = ite c u v", "start": [55, 1], "end": [60, 63], "kind": "commanddeclaration"}, {"full_name": "Eq.mpr_prop", "code": "theorem Eq.mpr_prop {p q : Prop} (h\u2081 : p = q) (h\u2082 : q)  : p", "start": [62, 1], "end": [62, 72], "kind": "commanddeclaration"}, {"full_name": "Eq.mpr_not", "code": "theorem Eq.mpr_not  {p q : Prop} (h\u2081 : p = q) (h\u2082 : \u00acq) : \u00acp", "start": [63, 1], "end": [63, 72], "kind": "commanddeclaration"}, {"full_name": "dite_congr", "code": "@[congr]\ntheorem dite_congr {_ : Decidable b} [Decidable c]\n    {x : b \u2192 \u03b1} {u : c \u2192 \u03b1} {y : \u00acb \u2192 \u03b1} {v : \u00acc \u2192 \u03b1}\n    (h\u2081 : b = c)\n    (h\u2082 : (h : c)  \u2192 x (h\u2081.mpr_prop h) = u h)\n    (h\u2083 : (h : \u00acc) \u2192 y (h\u2081.mpr_not h)  = v h) :\n    dite b x y = dite c u v", "start": [65, 1], "end": [74, 65], "kind": "commanddeclaration"}, {"full_name": "ne_eq", "code": "@[simp] theorem ne_eq (a b : \u03b1) : (a \u2260 b) = \u00ac(a = b)", "start": [76, 1], "end": [76, 60], "kind": "commanddeclaration"}, {"full_name": "ite_true", "code": "@[simp] theorem ite_true (a b : \u03b1) : (if True then a else b) = a", "start": [77, 1], "end": [77, 72], "kind": "commanddeclaration"}, {"full_name": "ite_false", "code": "@[simp] theorem ite_false (a b : \u03b1) : (if False then a else b) = b", "start": [78, 1], "end": [78, 74], "kind": "commanddeclaration"}, {"full_name": "dite_true", "code": "@[simp] theorem dite_true {\u03b1 : Sort u} {t : True \u2192 \u03b1} {e : \u00ac True \u2192 \u03b1} : (dite True t e) = t True.intro", "start": [79, 1], "end": [79, 111], "kind": "commanddeclaration"}, {"full_name": "dite_false", "code": "@[simp] theorem dite_false {\u03b1 : Sort u} {t : False \u2192 \u03b1} {e : \u00ac False \u2192 \u03b1} : (dite False t e) = e not_false", "start": [80, 1], "end": [80, 114], "kind": "commanddeclaration"}, {"full_name": "ite_self", "code": "@[simp] theorem ite_self {\u03b1 : Sort u} {c : Prop} {d : Decidable c} (a : \u03b1) : ite c a a = a", "start": [81, 1], "end": [81, 113], "kind": "commanddeclaration"}, {"full_name": "and_self", "code": "@[simp] theorem and_self (p : Prop) : (p \u2227 p) = p", "start": [82, 1], "end": [82, 86], "kind": "commanddeclaration"}, {"full_name": "and_true", "code": "@[simp] theorem and_true (p : Prop) : (p \u2227 True) = p", "start": [83, 1], "end": [83, 88], "kind": "commanddeclaration"}, {"full_name": "true_and", "code": "@[simp] theorem true_and (p : Prop) : (True \u2227 p) = p", "start": [84, 1], "end": [84, 88], "kind": "commanddeclaration"}, {"full_name": "and_false", "code": "@[simp] theorem and_false (p : Prop) : (p \u2227 False) = False", "start": [85, 1], "end": [85, 77], "kind": "commanddeclaration"}, {"full_name": "false_and", "code": "@[simp] theorem false_and (p : Prop) : (False \u2227 p) = False", "start": [86, 1], "end": [86, 77], "kind": "commanddeclaration"}, {"full_name": "or_self", "code": "@[simp] theorem or_self (p : Prop) : (p \u2228 p) = p", "start": [87, 1], "end": [87, 95], "kind": "commanddeclaration"}, {"full_name": "or_true", "code": "@[simp] theorem or_true (p : Prop) : (p \u2228 True) = True", "start": [88, 1], "end": [88, 81], "kind": "commanddeclaration"}, {"full_name": "true_or", "code": "@[simp] theorem true_or (p : Prop) : (True \u2228 p) = True", "start": [89, 1], "end": [89, 81], "kind": "commanddeclaration"}, {"full_name": "or_false", "code": "@[simp] theorem or_false (p : Prop) : (p \u2228 False) = p", "start": [90, 1], "end": [90, 91], "kind": "commanddeclaration"}, {"full_name": "false_or", "code": "@[simp] theorem false_or (p : Prop) : (False \u2228 p) = p", "start": [91, 1], "end": [91, 91], "kind": "commanddeclaration"}, {"full_name": "iff_self", "code": "@[simp] theorem iff_self (p : Prop) : (p \u2194 p) = True", "start": [92, 1], "end": [92, 69], "kind": "commanddeclaration"}, {"full_name": "iff_true", "code": "@[simp] theorem iff_true (p : Prop) : (p \u2194 True) = p", "start": [93, 1], "end": [93, 121], "kind": "commanddeclaration"}, {"full_name": "true_iff", "code": "@[simp] theorem true_iff (p : Prop) : (True \u2194 p) = p", "start": [94, 1], "end": [94, 121], "kind": "commanddeclaration"}, {"full_name": "iff_false", "code": "@[simp] theorem iff_false (p : Prop) : (p \u2194 False) = \u00acp", "start": [95, 1], "end": [95, 94], "kind": "commanddeclaration"}, {"full_name": "false_iff", "code": "@[simp] theorem false_iff (p : Prop) : (False \u2194 p) = \u00acp", "start": [96, 1], "end": [96, 94], "kind": "commanddeclaration"}, {"full_name": "false_implies", "code": "@[simp] theorem false_implies (p : Prop) : (False \u2192 p) = True", "start": [97, 1], "end": [97, 84], "kind": "commanddeclaration"}, {"full_name": "implies_true", "code": "@[simp] theorem implies_true (\u03b1 : Sort u) : (\u03b1 \u2192 True) = True", "start": [98, 1], "end": [98, 90], "kind": "commanddeclaration"}, {"full_name": "true_implies", "code": "@[simp] theorem true_implies (p : Prop) : (True \u2192 p) = p", "start": [99, 1], "end": [99, 96], "kind": "commanddeclaration"}, {"full_name": "not_false_eq_true", "code": "@[simp] theorem not_false_eq_true : (\u00ac False) = True", "start": [100, 1], "end": [100, 75], "kind": "commanddeclaration"}, {"full_name": "Bool.or_false", "code": "@[simp] theorem Bool.or_false (b : Bool) : (b || false) = b", "start": [102, 1], "end": [102, 83], "kind": "commanddeclaration"}, {"full_name": "Bool.or_true", "code": "@[simp] theorem Bool.or_true (b : Bool) : (b || true) = true", "start": [103, 1], "end": [103, 83], "kind": "commanddeclaration"}, {"full_name": "Bool.false_or", "code": "@[simp] theorem Bool.false_or (b : Bool) : (false || b) = b", "start": [104, 1], "end": [104, 83], "kind": "commanddeclaration"}, {"full_name": "Bool.true_or", "code": "@[simp] theorem Bool.true_or (b : Bool) : (true || b) = true", "start": [105, 1], "end": [105, 83], "kind": "commanddeclaration"}, {"full_name": "Bool.or_self", "code": "@[simp] theorem Bool.or_self (b : Bool) : (b || b) = b", "start": [106, 1], "end": [106, 83], "kind": "commanddeclaration"}, {"full_name": "Bool.or_eq_true", "code": "@[simp] theorem Bool.or_eq_true (a b : Bool) : ((a || b) = true) = (a = true \u2228 b = true)", "start": [107, 1], "end": [108, 33], "kind": "commanddeclaration"}, {"full_name": "Bool.and_false", "code": "@[simp] theorem Bool.and_false (b : Bool) : (b && false) = false", "start": [110, 1], "end": [110, 87], "kind": "commanddeclaration"}, {"full_name": "Bool.and_true", "code": "@[simp] theorem Bool.and_true (b : Bool) : (b && true) = b", "start": [111, 1], "end": [111, 87], "kind": "commanddeclaration"}, {"full_name": "Bool.false_and", "code": "@[simp] theorem Bool.false_and (b : Bool) : (false && b) = false", "start": [112, 1], "end": [112, 87], "kind": "commanddeclaration"}, {"full_name": "Bool.true_and", "code": "@[simp] theorem Bool.true_and (b : Bool) : (true && b) = b", "start": [113, 1], "end": [113, 87], "kind": "commanddeclaration"}, {"full_name": "Bool.and_self", "code": "@[simp] theorem Bool.and_self (b : Bool) : (b && b) = b", "start": [114, 1], "end": [114, 87], "kind": "commanddeclaration"}, {"full_name": "Bool.and_eq_true", "code": "@[simp] theorem Bool.and_eq_true (a b : Bool) : ((a && b) = true) = (a = true \u2227 b = true)", "start": [115, 1], "end": [116, 33], "kind": "commanddeclaration"}, {"full_name": "Bool.and_assoc", "code": "theorem Bool.and_assoc (a b c : Bool) : (a && b && c) = (a && (b && c))", "start": [118, 1], "end": [119, 45], "kind": "commanddeclaration"}, {"full_name": "Bool.or_assoc", "code": "theorem Bool.or_assoc (a b c : Bool) : (a || b || c) = (a || (b || c))", "start": [120, 1], "end": [121, 45], "kind": "commanddeclaration"}, {"full_name": "Bool.not_not", "code": "@[simp] theorem Bool.not_not (b : Bool) : (!!b) = b", "start": [123, 1], "end": [123, 74], "kind": "commanddeclaration"}, {"full_name": "Bool.not_true", "code": "@[simp] theorem Bool.not_true  : (!true) = false", "start": [124, 1], "end": [124, 62], "kind": "commanddeclaration"}, {"full_name": "Bool.not_false", "code": "@[simp] theorem Bool.not_false : (!false) = true", "start": [125, 1], "end": [125, 62], "kind": "commanddeclaration"}, {"full_name": "Bool.not_beq_true", "code": "@[simp] theorem Bool.not_beq_true (b : Bool) : (!(b == true)) = (b == false)", "start": [126, 1], "end": [126, 99], "kind": "commanddeclaration"}, {"full_name": "Bool.not_beq_false", "code": "@[simp] theorem Bool.not_beq_false (b : Bool) : (!(b == false)) = (b == true)", "start": [127, 1], "end": [127, 100], "kind": "commanddeclaration"}, {"full_name": "Bool.not_eq_true'", "code": "@[simp] theorem Bool.not_eq_true' (b : Bool) : ((!b) = true) = (b = false)", "start": [128, 1], "end": [128, 98], "kind": "commanddeclaration"}, {"full_name": "Bool.not_eq_false'", "code": "@[simp] theorem Bool.not_eq_false' (b : Bool) : ((!b) = false) = (b = true)", "start": [129, 1], "end": [129, 99], "kind": "commanddeclaration"}, {"full_name": "Bool.beq_to_eq", "code": "@[simp] theorem Bool.beq_to_eq (a b : Bool) :\n  (a == b) = (a = b)", "start": [131, 1], "end": [132, 58], "kind": "commanddeclaration"}, {"full_name": "Bool.not_beq_to_not_eq", "code": "@[simp] theorem Bool.not_beq_to_not_eq (a b : Bool) :\n  (!(a == b)) = \u00ac(a = b)", "start": [133, 1], "end": [134, 62], "kind": "commanddeclaration"}, {"full_name": "Bool.not_eq_true", "code": "@[simp] theorem Bool.not_eq_true (b : Bool) : (\u00ac(b = true)) = (b = false)", "start": [136, 1], "end": [136, 99], "kind": "commanddeclaration"}, {"full_name": "Bool.not_eq_false", "code": "@[simp] theorem Bool.not_eq_false (b : Bool) : (\u00ac(b = false)) = (b = true)", "start": [137, 1], "end": [137, 100], "kind": "commanddeclaration"}, {"full_name": "decide_eq_true_eq", "code": "@[simp] theorem decide_eq_true_eq [Decidable p] : (decide p = true) = p", "start": [139, 1], "end": [139, 129], "kind": "commanddeclaration"}, {"full_name": "decide_not", "code": "@[simp] theorem decide_not [h : Decidable p] : decide (\u00ac p) = !decide p", "start": [140, 1], "end": [140, 94], "kind": "commanddeclaration"}, {"full_name": "not_decide_eq_true", "code": "@[simp] theorem not_decide_eq_true [h : Decidable p] : ((!decide p) = true) = \u00ac p", "start": [141, 1], "end": [141, 117], "kind": "commanddeclaration"}, {"full_name": "heq_eq_eq", "code": "@[simp] theorem heq_eq_eq {\u03b1 : Sort u} (a b : \u03b1) : HEq a b = (a = b)", "start": [143, 1], "end": [143, 113], "kind": "commanddeclaration"}, {"full_name": "cond_true", "code": "@[simp] theorem cond_true (a b : \u03b1) : cond true a b = a", "start": [145, 1], "end": [145, 63], "kind": "commanddeclaration"}, {"full_name": "cond_false", "code": "@[simp] theorem cond_false (a b : \u03b1) : cond false a b = b", "start": [146, 1], "end": [146, 65], "kind": "commanddeclaration"}, {"full_name": "beq_self_eq_true", "code": "@[simp] theorem beq_self_eq_true [BEq \u03b1] [LawfulBEq \u03b1] (a : \u03b1) : (a == a) = true", "start": [148, 1], "end": [148, 98], "kind": "commanddeclaration"}, {"full_name": "beq_self_eq_true'", "code": "@[simp] theorem beq_self_eq_true' [DecidableEq \u03b1] (a : \u03b1) : (a == a) = true", "start": [149, 1], "end": [149, 97], "kind": "commanddeclaration"}, {"full_name": "bne_self_eq_false", "code": "@[simp] theorem bne_self_eq_false [BEq \u03b1] [LawfulBEq \u03b1] (a : \u03b1) : (a != a) = false", "start": [151, 1], "end": [151, 100], "kind": "commanddeclaration"}, {"full_name": "bne_self_eq_false'", "code": "@[simp] theorem bne_self_eq_false' [DecidableEq \u03b1] (a : \u03b1) : (a != a) = false", "start": [152, 1], "end": [152, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.le_zero_eq", "code": "@[simp] theorem Nat.le_zero_eq (a : Nat) : (a \u2264 0) = (a = 0)", "start": [154, 1], "end": [155, 78], "kind": "commanddeclaration"}, {"full_name": "decide_False", "code": "@[simp] theorem decide_False : decide False = false", "start": [157, 1], "end": [157, 59], "kind": "commanddeclaration"}, {"full_name": "decide_True", "code": "@[simp] theorem decide_True : decide True = true", "start": [158, 1], "end": [158, 56], "kind": "commanddeclaration"}, {"full_name": "bne_iff_ne", "code": "@[simp] theorem bne_iff_ne [BEq \u03b1] [LawfulBEq \u03b1] (a b : \u03b1) : a != b \u2194 a \u2260 b", "start": [160, 1], "end": [161, 56], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/SimpLemmas.lean"], "premises": [{"full_name": "Nat.fold", "code": "@[specialize] def fold {\u03b1 : Type u} (f : Nat \u2192 \u03b1 \u2192 \u03b1) : (n : Nat) \u2192 (init : \u03b1) \u2192 \u03b1\n  | 0,      a => a\n  | succ n, a => f n (fold f n a)", "start": [13, 1], "end": [19, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.foldTR", "code": "@[inline] def foldTR {\u03b1 : Type u} (f : Nat \u2192 \u03b1 \u2192 \u03b1) (n : Nat) (init : \u03b1) : \u03b1 :=\n  let rec @[specialize] loop\n    | 0,      a => a\n    | succ m, a => loop m (f (n - succ m) a)\n  loop n init", "start": [21, 1], "end": [26, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.foldRev", "code": "@[specialize] def foldRev {\u03b1 : Type u} (f : Nat \u2192 \u03b1 \u2192 \u03b1) : (n : Nat) \u2192 (init : \u03b1) \u2192 \u03b1\n  | 0,      a => a\n  | succ n, a => foldRev f n (f n a)", "start": [28, 1], "end": [34, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.any", "code": "@[specialize] def any (f : Nat \u2192 Bool) : Nat \u2192 Bool\n  | 0      => false\n  | succ n => any f n || f n", "start": [36, 1], "end": [39, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.anyTR", "code": "@[inline] def anyTR (f : Nat \u2192 Bool) (n : Nat) : Bool :=\n  let rec @[specialize] loop : Nat \u2192 Bool\n    | 0      => false\n    | succ m => f (n - succ m) || loop m\n  loop n", "start": [41, 1], "end": [46, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.all", "code": "@[specialize] def all (f : Nat \u2192 Bool) : Nat \u2192 Bool\n  | 0      => true\n  | succ n => all f n && f n", "start": [48, 1], "end": [51, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.allTR", "code": "@[inline] def allTR (f : Nat \u2192 Bool) (n : Nat) : Bool :=\n  let rec @[specialize] loop : Nat \u2192 Bool\n    | 0      => true\n    | succ m => f (n - succ m) && loop m\n  loop n", "start": [53, 1], "end": [58, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.repeat", "code": "@[specialize] def repeat {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1) : (n : Nat) \u2192 (a : \u03b1) \u2192 \u03b1\n  | 0,      a => a\n  | succ n, a => f (repeat f n a)", "start": [60, 1], "end": [66, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.repeatTR", "code": "@[inline] def repeatTR {\u03b1 : Type u} (f : \u03b1 \u2192 \u03b1) (n : Nat) (a : \u03b1) : \u03b1 :=\n  let rec @[specialize] loop\n    | 0,      a => a\n    | succ n, a => loop n (f a)\n  loop n a", "start": [68, 1], "end": [73, 11], "kind": "commanddeclaration"}, {"full_name": "Nat.blt", "code": "def blt (a b : Nat) : Bool :=\n  ble a.succ b", "start": [75, 1], "end": [77, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_eq", "code": "@[simp] theorem zero_eq : Nat.zero = 0", "start": [83, 1], "end": [83, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.add_eq", "code": "@[simp] theorem add_eq : Nat.add x y = x + y", "start": [84, 1], "end": [84, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_eq", "code": "@[simp] theorem mul_eq : Nat.mul x y = x * y", "start": [85, 1], "end": [85, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_eq", "code": "@[simp] theorem sub_eq : Nat.sub x y = x - y", "start": [86, 1], "end": [86, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_eq", "code": "@[simp] theorem lt_eq : Nat.lt x y = (x < y)", "start": [87, 1], "end": [87, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.le_eq", "code": "@[simp] theorem le_eq : Nat.le x y = (x \u2264 y)", "start": [88, 1], "end": [88, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.beq_refl", "code": "@[simp] theorem beq_refl (a : Nat) : Nat.beq a a = true", "start": [92, 1], "end": [94, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.beq_eq", "code": "@[simp] theorem beq_eq : (Nat.beq x y = true) = (x = y)", "start": [96, 1], "end": [96, 134], "kind": "commanddeclaration"}, {"full_name": "Nat.ble_eq", "code": "@[simp] theorem ble_eq : (Nat.ble x y = true) = (x \u2264 y)", "start": [97, 1], "end": [97, 124], "kind": "commanddeclaration"}, {"full_name": "Nat.blt_eq", "code": "@[simp] theorem blt_eq : (Nat.blt x y = true) = (x < y)", "start": [98, 1], "end": [98, 124], "kind": "commanddeclaration"}, {"full_name": "Nat.beq_eq_true_eq", "code": "@[simp] theorem beq_eq_true_eq (a b : Nat) : ((a == b) = true) = (a = b)", "start": [104, 1], "end": [104, 150], "kind": "commanddeclaration"}, {"full_name": "Nat.not_beq_eq_true_eq", "code": "@[simp] theorem not_beq_eq_true_eq (a b : Nat) : ((!(a == b)) = true) = \u00ac(a = b)", "start": [105, 1], "end": [110, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_add", "code": "@[simp] protected theorem zero_add : \u2200 (n : Nat), 0 + n = n", "start": [114, 1], "end": [116, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_add", "code": "theorem succ_add : \u2200 (n m : Nat), (succ n) + m = succ (n + m)", "start": [118, 1], "end": [120, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.add_succ", "code": "theorem add_succ (n m : Nat) : n + succ m = succ (n + m)", "start": [122, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.add_one", "code": "theorem add_one (n : Nat) : n + 1 = succ n", "start": [125, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_eq_add_one", "code": "theorem succ_eq_add_one (n : Nat) : succ n = n + 1", "start": [128, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.add_comm", "code": "protected theorem add_comm : \u2200 (n m : Nat), n + m = m + n", "start": [131, 1], "end": [136, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.add_assoc", "code": "protected theorem add_assoc : \u2200 (n m k : Nat), (n + m) + k = n + (m + k)", "start": [138, 1], "end": [140, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.add_left_comm", "code": "protected theorem add_left_comm (n m k : Nat) : n + (m + k) = m + (n + k)", "start": [142, 1], "end": [143, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.add_right_comm", "code": "protected theorem add_right_comm (n m k : Nat) : (n + m) + k = (n + k) + m", "start": [145, 1], "end": [146, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.add_left_cancel", "code": "protected theorem add_left_cancel {n m k : Nat} : n + m = n + k \u2192 m = k", "start": [148, 1], "end": [151, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.add_right_cancel", "code": "protected theorem add_right_cancel {n m k : Nat} (h : n + m = k + m) : n = k", "start": [153, 1], "end": [155, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_zero", "code": "@[simp] protected theorem mul_zero (n : Nat) : n * 0 = 0", "start": [159, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_succ", "code": "theorem mul_succ (n m : Nat) : n * succ m = n * m + n", "start": [162, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_mul", "code": "@[simp] protected theorem zero_mul : \u2200 (n : Nat), 0 * n = 0", "start": [165, 1], "end": [167, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_mul", "code": "theorem succ_mul (n m : Nat) : (succ n) * m = (n * m) + m", "start": [169, 1], "end": [172, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_comm", "code": "protected theorem mul_comm : \u2200 (n m : Nat), n * m = m * n", "start": [174, 1], "end": [176, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_one", "code": "@[simp] protected theorem mul_one : \u2200 (n : Nat), n * 1 = n", "start": [178, 1], "end": [179, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.one_mul", "code": "@[simp] protected theorem one_mul (n : Nat) : 1 * n = n", "start": [181, 1], "end": [182, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.left_distrib", "code": "protected theorem left_distrib (n m k : Nat) : n * (m + k) = n * m + n * k", "start": [184, 1], "end": [187, 119], "kind": "commanddeclaration"}, {"full_name": "Nat.right_distrib", "code": "protected theorem right_distrib (n m k : Nat) : (n + m) * k = n * k + m * k", "start": [189, 1], "end": [190, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_add", "code": "protected theorem mul_add (n m k : Nat) : n * (m + k) = n * m + n * k", "start": [192, 1], "end": [193, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mul", "code": "protected theorem add_mul (n m k : Nat) : (n + m) * k = n * k + m * k", "start": [195, 1], "end": [196, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_assoc", "code": "protected theorem mul_assoc : \u2200 (n m k : Nat), (n * m) * k = n * (m * k)", "start": [198, 1], "end": [200, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_left_comm", "code": "protected theorem mul_left_comm (n m k : Nat) : n * (m * k) = m * (n * k)", "start": [202, 1], "end": [203, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_lt_succ", "code": "theorem succ_lt_succ {n m : Nat} : n < m \u2192 succ n < succ m", "start": [209, 1], "end": [210, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_succ_of_le", "code": "theorem lt_succ_of_le {n m : Nat} : n \u2264 m \u2192 n < succ m", "start": [212, 1], "end": [213, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_zero", "code": "@[simp] protected theorem sub_zero (n : Nat) : n - 0 = n", "start": [215, 1], "end": [216, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_sub_succ_eq_sub", "code": "theorem succ_sub_succ_eq_sub (n m : Nat) : succ n - succ m = n - m", "start": [218, 1], "end": [221, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_le", "code": "theorem pred_le : \u2200 (n : Nat), pred n \u2264 n", "start": [223, 1], "end": [225, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_lt", "code": "theorem pred_lt : \u2200 {n : Nat}, n \u2260 0 \u2192 pred n < n", "start": [227, 1], "end": [229, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_le", "code": "theorem sub_le (n m : Nat) : n - m \u2264 n", "start": [231, 1], "end": [234, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_lt", "code": "theorem sub_lt : \u2200 {n m : Nat}, 0 < n \u2192 0 < m \u2192 n - m < n", "start": [236, 1], "end": [242, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_succ", "code": "theorem sub_succ (n m : Nat) : n - succ m = pred (n - m)", "start": [244, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_sub_succ", "code": "theorem succ_sub_succ (n m : Nat) : succ n - succ m = n - m", "start": [247, 1], "end": [248, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_self", "code": "@[simp] protected theorem sub_self : \u2200 (n : Nat), n - n = 0", "start": [250, 1], "end": [252, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_add_eq", "code": "theorem sub_add_eq (a b c : Nat) : a - (b + c) = a - b - c", "start": [254, 1], "end": [257, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_lt_of_le", "code": "protected theorem lt_of_lt_of_le {n m k : Nat} : n < m \u2192 m \u2264 k \u2192 n < k", "start": [259, 1], "end": [260, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_lt_of_eq", "code": "protected theorem lt_of_lt_of_eq {n m k : Nat} : n < m \u2192 m = k \u2192 n < k", "start": [262, 1], "end": [263, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_eq", "code": "protected theorem le_of_eq {n m : Nat} (p : n = m) : n \u2264 m", "start": [277, 1], "end": [278, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_succ_le", "code": "theorem le_of_succ_le {n m : Nat} (h : succ n \u2264 m) : n \u2264 m", "start": [280, 1], "end": [281, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_lt", "code": "protected theorem le_of_lt {n m : Nat} (h : n < m) : n \u2264 m", "start": [283, 1], "end": [284, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.lt.step", "code": "theorem lt.step {n m : Nat} : n < m \u2192 n < succ m", "start": [286, 1], "end": [286, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_or_pos", "code": "theorem eq_zero_or_pos : \u2200 (n : Nat), n = 0 \u2228 n > 0", "start": [288, 1], "end": [290, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.lt.base", "code": "theorem lt.base (n : Nat) : n < succ n", "start": [292, 1], "end": [292, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_succ_self", "code": "theorem lt_succ_self (n : Nat) : n < succ n", "start": [294, 1], "end": [294, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.le_total", "code": "protected theorem le_total (m n : Nat) : m \u2264 n \u2228 n \u2264 m", "start": [296, 1], "end": [299, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_le_zero", "code": "theorem eq_zero_of_le_zero {n : Nat} (h : n \u2264 0) : n = 0", "start": [301, 1], "end": [302, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_succ_lt", "code": "theorem lt_of_succ_lt {n m : Nat} : succ n < m \u2192 n < m", "start": [304, 1], "end": [305, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_succ_lt_succ", "code": "theorem lt_of_succ_lt_succ {n m : Nat} : succ n < succ m \u2192 n < m", "start": [307, 1], "end": [308, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_succ_le", "code": "theorem lt_of_succ_le {n m : Nat} (h : succ n \u2264 m) : n < m", "start": [310, 1], "end": [311, 4], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_le_of_lt", "code": "theorem succ_le_of_lt {n m : Nat} (h : n < m) : succ n \u2264 m", "start": [313, 1], "end": [314, 4], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_lt_of_lt", "code": "theorem zero_lt_of_lt : {a b : Nat} \u2192 a < b \u2192 0 < b", "start": [316, 1], "end": [320, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_lt_of_ne_zero", "code": "theorem zero_lt_of_ne_zero {a : Nat} (h : a \u2260 0) : 0 < a", "start": [322, 1], "end": [325, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.ne_of_lt", "code": "theorem ne_of_lt {a b : Nat} (h : a < b) : a \u2260 b", "start": [329, 1], "end": [330, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.le_or_eq_of_le_succ", "code": "theorem le_or_eq_of_le_succ {m n : Nat} (h : m \u2264 succ n) : m \u2264 n \u2228 m = succ n", "start": [332, 1], "end": [338, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.le_add_right", "code": "theorem le_add_right : \u2200 (n k : Nat), n \u2264 n + k", "start": [340, 1], "end": [342, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.le_add_left", "code": "theorem le_add_left (n m : Nat): n \u2264 m + n", "start": [344, 1], "end": [345, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.le.dest", "code": "theorem le.dest : \u2200 {n m : Nat}, n \u2264 m \u2192 Exists (fun k => n + k = m)", "start": [347, 1], "end": [355, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.le.intro", "code": "theorem le.intro {n m k : Nat} (h : n + k = m) : n \u2264 m", "start": [357, 1], "end": [358, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.not_le_of_gt", "code": "protected theorem not_le_of_gt {n m : Nat} (h : n > m) : \u00ac n \u2264 m", "start": [360, 1], "end": [365, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.gt_of_not_le", "code": "theorem gt_of_not_le {n m : Nat} (h : \u00ac n \u2264 m) : n > m", "start": [367, 1], "end": [370, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.ge_of_not_lt", "code": "theorem ge_of_not_lt {n m : Nat} (h : \u00ac n < m) : n \u2265 m", "start": [372, 1], "end": [375, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.add_le_add_left", "code": "protected theorem add_le_add_left {n m : Nat} (h : n \u2264 m) (k : Nat) : k + n \u2264 k + m", "start": [383, 1], "end": [388, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.add_le_add_right", "code": "protected theorem add_le_add_right {n m : Nat} (h : n \u2264 m) (k : Nat) : n + k \u2264 m + k", "start": [390, 1], "end": [393, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.add_lt_add_left", "code": "protected theorem add_lt_add_left {n m : Nat} (h : n < m) (k : Nat) : k + n < k + m", "start": [395, 1], "end": [396, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.add_lt_add_right", "code": "protected theorem add_lt_add_right {n m : Nat} (h : n < m) (k : Nat) : n + k < m + k", "start": [398, 1], "end": [399, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_lt_one", "code": "protected theorem zero_lt_one : 0 < (1:Nat)", "start": [401, 1], "end": [402, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.add_le_add", "code": "theorem add_le_add {a b c d : Nat} (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) : a + c \u2264 b + d", "start": [404, 1], "end": [405, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.add_lt_add", "code": "theorem add_lt_add {a b c d : Nat} (h\u2081 : a < b) (h\u2082 : c < d) : a + c < b + d", "start": [407, 1], "end": [408, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_add_le_add_left", "code": "protected theorem le_of_add_le_add_left {a b c : Nat} (h : a + b \u2264 a + c) : b \u2264 c", "start": [410, 1], "end": [415, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_add_le_add_right", "code": "protected theorem le_of_add_le_add_right {a b c : Nat} : a + b \u2264 c + b \u2192 a \u2264 c", "start": [417, 1], "end": [419, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.ctor_eq_zero", "code": "theorem ctor_eq_zero : Nat.zero = 0", "start": [423, 1], "end": [424, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.one_ne_zero", "code": "protected theorem one_ne_zero : 1 \u2260 (0 : Nat)", "start": [426, 1], "end": [427, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_ne_one", "code": "protected theorem zero_ne_one : 0 \u2260 (1 : Nat)", "start": [429, 1], "end": [430, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_ne_zero", "code": "theorem succ_ne_zero (n : Nat) : succ n \u2260 0", "start": [432, 1], "end": [433, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_le_mul_left", "code": "theorem mul_le_mul_left {n m : Nat} (k : Nat) (h : n \u2264 m) : k * n \u2264 k * m", "start": [437, 1], "end": [441, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_le_mul_right", "code": "theorem mul_le_mul_right {n m : Nat} (k : Nat) (h : n \u2264 m) : n * k \u2264 m * k", "start": [443, 1], "end": [444, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_le_mul", "code": "protected theorem mul_le_mul {n\u2081 m\u2081 n\u2082 m\u2082 : Nat} (h\u2081 : n\u2081 \u2264 n\u2082) (h\u2082 : m\u2081 \u2264 m\u2082) : n\u2081 * m\u2081 \u2264 n\u2082 * m\u2082", "start": [446, 1], "end": [447, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_lt_mul_of_pos_left", "code": "protected theorem mul_lt_mul_of_pos_left {n m k : Nat} (h : n < m) (hk : k > 0) : k * n < k * m", "start": [449, 1], "end": [450, 109], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_lt_mul_of_pos_right", "code": "protected theorem mul_lt_mul_of_pos_right {n m k : Nat} (h : n < m) (hk : k > 0) : n * k < m * k", "start": [452, 1], "end": [453, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_pos", "code": "protected theorem mul_pos {n m : Nat} (ha : n > 0) (hb : m > 0) : n * m > 0", "start": [455, 1], "end": [457, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_mul_le_mul_left", "code": "protected theorem le_of_mul_le_mul_left {a b c : Nat} (h : c * a \u2264 c * b) (hc : 0 < c) : a \u2264 b", "start": [459, 1], "end": [462, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_mul_eq_mul_left", "code": "protected theorem eq_of_mul_eq_mul_left {m k n : Nat} (hn : 0 < n) (h : n * m = n * k) : m = k", "start": [464, 1], "end": [466, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_mul_eq_mul_right", "code": "theorem eq_of_mul_eq_mul_right {n m k : Nat} (hm : 0 < m) (h : n * m = k * m) : n = k", "start": [468, 1], "end": [469, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_succ", "code": "theorem pow_succ (n m : Nat) : n^(succ m) = n^m * n", "start": [473, 1], "end": [474, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_zero", "code": "theorem pow_zero (n : Nat) : n^0 = 1", "start": [476, 1], "end": [476, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_le_pow_of_le_left", "code": "theorem pow_le_pow_of_le_left {n m : Nat} (h : n \u2264 m) : \u2200 (i : Nat), n^i \u2264 m^i", "start": [478, 1], "end": [480, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_le_pow_of_le_right", "code": "theorem pow_le_pow_of_le_right {n : Nat} (hx : n > 0) {i : Nat} : \u2200 {j}, i \u2264 j \u2192 n^i \u2264 n^j", "start": [482, 1], "end": [492, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_pow_of_pos", "code": "theorem pos_pow_of_pos {n : Nat} (m : Nat) (h : 0 < n) : 0 < n^m", "start": [494, 1], "end": [495, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.min", "code": "protected abbrev min (n m : Nat) := min n m", "start": [499, 1], "end": [504, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.min_def", "code": "protected theorem min_def {n m : Nat} : min n m = if n \u2264 m then n else m", "start": [506, 1], "end": [506, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.max", "code": "protected abbrev max (n m : Nat) := max n m", "start": [510, 1], "end": [515, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.max_def", "code": "protected theorem max_def {n m : Nat} : max n m = if n \u2264 m then m else n", "start": [517, 1], "end": [517, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.not_eq_zero_of_lt", "code": "theorem not_eq_zero_of_lt (h : b < a) : a \u2260 0", "start": [522, 1], "end": [525, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_lt'", "code": "theorem pred_lt' {n m : Nat} (h : m < n) : pred n < n", "start": [527, 1], "end": [528, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_self_left", "code": "theorem add_sub_self_left (a b : Nat) : (a + b) - a = b", "start": [532, 1], "end": [537, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_self_right", "code": "theorem add_sub_self_right (a b : Nat) : (a + b) - b = a", "start": [539, 1], "end": [540, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_le_succ_sub", "code": "theorem sub_le_succ_sub (a i : Nat) : a - i \u2264 a.succ - i", "start": [542, 1], "end": [545, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_lt_sub_of_lt", "code": "theorem zero_lt_sub_of_lt (h : i < a) : 0 < a - i", "start": [547, 1], "end": [555, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_succ_lt_self", "code": "theorem sub_succ_lt_self (a i : Nat) (h : i < a) : a - (i + 1) < a - i", "start": [557, 1], "end": [562, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_pred", "code": "theorem succ_pred {a : Nat} (h : a \u2260 0) : a.pred.succ = a", "start": [564, 1], "end": [567, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_ne_zero_of_lt", "code": "theorem sub_ne_zero_of_lt : {a b : Nat} \u2192 a < b \u2192 b - a \u2260 0", "start": [569, 1], "end": [573, 103], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_of_le", "code": "theorem add_sub_of_le {a b : Nat} (h : a \u2264 b) : a + (b - a) = b", "start": [575, 1], "end": [581, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_add_cancel", "code": "protected theorem sub_add_cancel {n m : Nat} (h : m \u2264 n) : n - m + m = n", "start": [583, 1], "end": [584, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_add_right", "code": "protected theorem add_sub_add_right (n k m : Nat) : (n + k) - (m + k) = n - m", "start": [586, 1], "end": [589, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_add_left", "code": "protected theorem add_sub_add_left (k n m : Nat) : (k + n) - (k + m) = n - m", "start": [591, 1], "end": [592, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_cancel", "code": "protected theorem add_sub_cancel (n m : Nat) : n + m - m = n", "start": [594, 1], "end": [596, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_cancel_left", "code": "protected theorem add_sub_cancel_left (n m : Nat) : n + m - n = m", "start": [598, 1], "end": [600, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_assoc", "code": "protected theorem add_sub_assoc {m k : Nat} (h : k \u2264 m) (n : Nat) : n + m - k = n + (m - k)", "start": [602, 1], "end": [605, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_add_of_sub_eq", "code": "protected theorem eq_add_of_sub_eq {a b c : Nat} (hle : b \u2264 a) (h : a - b = c) : a = c + b", "start": [607, 1], "end": [608, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_eq_of_eq_add", "code": "protected theorem sub_eq_of_eq_add {a b c : Nat} (h : a = c + b) : a - b = c", "start": [610, 1], "end": [611, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.le_add_of_sub_le", "code": "theorem le_add_of_sub_le {a b c : Nat} (h : a - b \u2264 c) : a \u2264 c + b", "start": [613, 1], "end": [621, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_lt_sub_left", "code": "protected theorem sub_lt_sub_left : \u2200 {k m n : Nat}, k < m \u2192 k < n \u2192 m - n < m - k", "start": [623, 1], "end": [627, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_sub", "code": "@[simp] protected theorem zero_sub (n : Nat) : 0 - n = 0", "start": [629, 1], "end": [632, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_self_add", "code": "protected theorem sub_self_add (n m : Nat) : n - (n + m) = 0", "start": [634, 1], "end": [636, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_eq_zero_of_le", "code": "protected theorem sub_eq_zero_of_le {n m : Nat} (h : n \u2264 m) : n - m = 0", "start": [638, 1], "end": [640, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_le_of_le_add", "code": "theorem sub_le_of_le_add {a b c : Nat} (h : a \u2264 c + b) : a - b \u2264 c", "start": [642, 1], "end": [651, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.add_le_of_le_sub", "code": "theorem add_le_of_le_sub {a b c : Nat} (hle : b \u2264 c) (h : a \u2264 c - b) : a + b \u2264 c", "start": [653, 1], "end": [658, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.le_sub_of_add_le", "code": "theorem le_sub_of_add_le {a b c : Nat} (h : a + b \u2264 c) : a \u2264 c - b", "start": [660, 1], "end": [666, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.add_lt_of_lt_sub", "code": "theorem add_lt_of_lt_sub {a b c : Nat} (h : a < c - b) : a + b < c", "start": [668, 1], "end": [677, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_sub_of_add_lt", "code": "theorem lt_sub_of_add_lt {a b c : Nat} (h : a + b < c) : a < c - b", "start": [679, 1], "end": [681, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_zero", "code": "@[simp] protected theorem pred_zero : pred 0 = 0", "start": [683, 1], "end": [684, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_succ", "code": "@[simp] protected theorem pred_succ (n : Nat) : pred n.succ = n", "start": [686, 1], "end": [687, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.sub.elim", "code": "theorem sub.elim {motive : Nat \u2192 Prop}\n    (x y : Nat)\n    (h\u2081 : y \u2264 x \u2192 (k : Nat) \u2192 x = y + k \u2192 motive k)\n    (h\u2082 : x < y \u2192 motive 0)\n    : motive (x - y)", "start": [689, 1], "end": [696, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_pred_left", "code": "theorem mul_pred_left (n m : Nat) : pred n * m = n * m - m", "start": [698, 1], "end": [701, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_pred_right", "code": "theorem mul_pred_right (n m : Nat) : n * pred m = n * m - n", "start": [703, 1], "end": [704, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_sub", "code": "protected theorem sub_sub (n m k : Nat) : n - m - k = n - (m + k)", "start": [706, 1], "end": [709, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_sub_right_distrib", "code": "protected theorem mul_sub_right_distrib (n m k : Nat) : (n - m) * k = n * k - m * k", "start": [711, 1], "end": [714, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_sub_left_distrib", "code": "protected theorem mul_sub_left_distrib (n m k : Nat) : n * (m - k) = n * m - n * k", "start": [716, 1], "end": [717, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.not_le_eq", "code": "theorem not_le_eq (a b : Nat) : (\u00ac (a \u2264 b)) = (b + 1 \u2264 a)", "start": [721, 1], "end": [722, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.not_ge_eq", "code": "theorem not_ge_eq (a b : Nat) : (\u00ac (a \u2265 b)) = (a + 1 \u2264 b)", "start": [724, 1], "end": [725, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.not_lt_eq", "code": "theorem not_lt_eq (a b : Nat) : (\u00ac (a < b)) = (b \u2264 a)", "start": [727, 1], "end": [728, 158], "kind": "commanddeclaration"}, {"full_name": "Nat.not_gt_eq", "code": "theorem not_gt_eq (a b : Nat) : (\u00ac (a > b)) = (a \u2264 b)", "start": [730, 1], "end": [731, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.fold_eq_foldTR", "code": "@[csimp] theorem fold_eq_foldTR : @fold = @foldTR", "start": [735, 1], "end": [740, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.any_eq_anyTR", "code": "@[csimp] theorem any_eq_anyTR : @any = @anyTR", "start": [742, 1], "end": [749, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.all_eq_allTR", "code": "@[csimp] theorem all_eq_allTR : @all = @allTR", "start": [751, 1], "end": [758, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.repeat_eq_repeatTR", "code": "@[csimp] theorem repeat_eq_repeatTR : @repeat = @repeatTR", "start": [760, 1], "end": [765, 16], "kind": "commanddeclaration"}, {"full_name": "Prod.foldI", "code": "@[inline] def foldI {\u03b1 : Type u} (f : Nat \u2192 \u03b1 \u2192 \u03b1) (i : Nat \u00d7 Nat) (a : \u03b1) : \u03b1 :=\n  Nat.foldTR.loop f i.2 (i.2 - i.1) a", "start": [771, 1], "end": [777, 38], "kind": "commanddeclaration"}, {"full_name": "Prod.anyI", "code": "@[inline] def anyI (f : Nat \u2192 Bool) (i : Nat \u00d7 Nat) : Bool :=\n  Nat.anyTR.loop f i.2 (i.2 - i.1)", "start": [779, 1], "end": [785, 35], "kind": "commanddeclaration"}, {"full_name": "Prod.allI", "code": "@[inline] def allI (f : Nat \u2192 Bool) (i : Nat \u00d7 Nat) : Bool :=\n  Nat.allTR.loop f i.2 (i.2 - i.1)", "start": [787, 1], "end": [793, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/WF.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init/SizeOf.lean"], "premises": [{"full_name": "Acc", "code": "inductive Acc {\u03b1 : Sort u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : \u03b1 \u2192 Prop where\n  | intro (x : \u03b1) (h : (y : \u03b1) \u2192 r y x \u2192 Acc r y) : Acc r x", "start": [12, 1], "end": [13, 60], "kind": "commanddeclaration"}, {"full_name": "Acc.ndrec", "code": "noncomputable abbrev Acc.ndrec.{u1, u2} {\u03b1 : Sort u2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {C : \u03b1 \u2192 Sort u1}\n    (m : (x : \u03b1) \u2192 ((y : \u03b1) \u2192 r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 C y) \u2192 C x)\n    {a : \u03b1} (n : Acc r a) : C a :=\n  n.rec m", "start": [15, 1], "end": [18, 10], "kind": "commanddeclaration"}, {"full_name": "Acc.ndrecOn", "code": "noncomputable abbrev Acc.ndrecOn.{u1, u2} {\u03b1 : Sort u2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {C : \u03b1 \u2192 Sort u1}\n    {a : \u03b1} (n : Acc r a)\n    (m : (x : \u03b1) \u2192 ((y : \u03b1) \u2192 r y x \u2192 Acc r y) \u2192 ((y : \u03b1) \u2192 (a : r y x) \u2192 C y) \u2192 C x)\n    : C a :=\n  n.rec m", "start": [20, 1], "end": [24, 10], "kind": "commanddeclaration"}, {"full_name": "Acc.inv", "code": "def inv {x y : \u03b1} (h\u2081 : Acc r x) (h\u2082 : r y x) : Acc r y :=\n  h\u2081.recOn (fun _ ac\u2081 _ h\u2082 => ac\u2081 y h\u2082) h\u2082", "start": [29, 1], "end": [30, 43], "kind": "commanddeclaration"}, {"full_name": "WellFounded", "code": "inductive WellFounded {\u03b1 : Sort u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  | intro (h : \u2200 a, Acc r a) : WellFounded r", "start": [34, 1], "end": [35, 45], "kind": "commanddeclaration"}, {"full_name": "WellFoundedRelation", "code": "class WellFoundedRelation (\u03b1 : Sort u) where\n  rel : \u03b1 \u2192 \u03b1 \u2192 Prop\n  wf  : WellFounded rel", "start": [37, 1], "end": [39, 24], "kind": "commanddeclaration"}, {"full_name": "WellFounded.apply", "code": "def apply {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (wf : WellFounded r) (a : \u03b1) : Acc r a :=\n  wf.rec (fun p => p) a", "start": [42, 1], "end": [43, 24], "kind": "commanddeclaration"}, {"full_name": "WellFounded.recursion", "code": "theorem recursion {C : \u03b1 \u2192 Sort v} (a : \u03b1) (h : \u2200 x, (\u2200 y, r y x \u2192 C y) \u2192 C x) : C a", "start": [48, 1], "end": [50, 35], "kind": "commanddeclaration"}, {"full_name": "WellFounded.induction", "code": "theorem induction {C : \u03b1 \u2192 Prop} (a : \u03b1) (h : \u2200 x, (\u2200 y, r y x \u2192 C y) \u2192 C x) : C a", "start": [52, 1], "end": [53, 20], "kind": "commanddeclaration"}, {"full_name": "WellFounded.fixF", "code": "noncomputable def fixF (x : \u03b1) (a : Acc r x) : C x := by\n  induction a with\n  | intro x\u2081 _ ih => exact F x\u2081 ih", "start": [58, 1], "end": [60, 35], "kind": "commanddeclaration"}, {"full_name": "WellFounded.fixFEq", "code": "def fixFEq (x : \u03b1) (acx : Acc r x) : fixF F x acx = F x (fun (y : \u03b1) (p : r y x) => fixF F y (Acc.inv acx p)) := by\n  induction acx with\n  | intro x r _ => exact rfl", "start": [62, 1], "end": [64, 29], "kind": "commanddeclaration"}, {"full_name": "WellFounded.fix", "code": "noncomputable def fix (hwf : WellFounded r) (F : \u2200 x, (\u2200 y, r y x \u2192 C y) \u2192 C x) (x : \u03b1) : C x :=\n  fixF F x (apply hwf x)", "start": [71, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "WellFounded.fix_eq", "code": "theorem fix_eq (hwf : WellFounded r) (F : \u2200 x, (\u2200 y, r y x \u2192 C y) \u2192 C x) (x : \u03b1) :\n    fix hwf F x = F x (fun y _ => fix hwf F y)", "start": [75, 1], "end": [77, 27], "kind": "commanddeclaration"}, {"full_name": "emptyWf", "code": "def emptyWf {\u03b1 : Sort u} : WellFoundedRelation \u03b1 where\n  rel := emptyRelation\n  wf  := by\n    apply WellFounded.intro\n    intro a\n    apply Acc.intro a\n    intro b h\n    cases h", "start": [83, 1], "end": [90, 12], "kind": "commanddeclaration"}, {"full_name": "Subrelation.accessible", "code": "def accessible {a : \u03b1} (h\u2081 : Subrelation q r) (ac : Acc r a) : Acc q a := by\n  induction ac with\n  | intro x _ ih =>\n    apply Acc.intro\n    intro y h\n    exact ih y (h\u2081 h)", "start": [96, 1], "end": [101, 22], "kind": "commanddeclaration"}, {"full_name": "Subrelation.wf", "code": "def wf (h\u2081 : Subrelation q r) (h\u2082 : WellFounded r) : WellFounded q :=\n  \u27e8fun a => accessible @h\u2081 (apply h\u2082 a)\u27e9", "start": [103, 1], "end": [104, 41], "kind": "commanddeclaration"}, {"full_name": "InvImage.accAux", "code": "private def accAux (f : \u03b1 \u2192 \u03b2) {b : \u03b2} (ac : Acc r b) : (x : \u03b1) \u2192 f x = b \u2192 Acc (InvImage r f) x := by\n  induction ac with\n  | intro x acx ih =>\n    intro z e\n    apply Acc.intro\n    intro y lt\n    subst x\n    apply ih (f y) lt y rfl", "start": [111, 1], "end": [118, 28], "kind": "commanddeclaration"}, {"full_name": "InvImage.accessible", "code": "def accessible {a : \u03b1} (f : \u03b1 \u2192 \u03b2) (ac : Acc r (f a)) : Acc (InvImage r f) a :=\n  accAux f ac a rfl", "start": [120, 1], "end": [121, 20], "kind": "commanddeclaration"}, {"full_name": "InvImage.wf", "code": "def wf (f : \u03b1 \u2192 \u03b2) (h : WellFounded r) : WellFounded (InvImage r f) :=\n  \u27e8fun a => accessible f (apply h (f a))\u27e9", "start": [123, 1], "end": [124, 42], "kind": "commanddeclaration"}, {"full_name": "invImage", "code": "@[reducible] def invImage (f : \u03b1 \u2192 \u03b2) (h : WellFoundedRelation \u03b2) : WellFoundedRelation \u03b1 where\n  rel := InvImage h.rel f\n  wf  := InvImage.wf f h.wf", "start": [127, 1], "end": [129, 28], "kind": "commanddeclaration"}, {"full_name": "TC.accessible", "code": "def accessible {z : \u03b1} (ac : Acc r z) : Acc (TC r) z := by\n  induction ac with\n  | intro x acx ih =>\n    apply Acc.intro x\n    intro y rel\n    induction rel with\n    | base a b rab => exact ih a rab\n    | trans a b c rab _ _ ih\u2082 => apply Acc.inv (ih\u2082 acx ih) rab", "start": [135, 1], "end": [142, 64], "kind": "commanddeclaration"}, {"full_name": "TC.wf", "code": "def wf (h : WellFounded r) : WellFounded (TC r) :=\n  \u27e8fun a => accessible (apply h a)\u27e9", "start": [144, 1], "end": [145, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_wfRel", "code": "def lt_wfRel : WellFoundedRelation Nat where\n  rel := Nat.lt\n  wf  := by\n    apply WellFounded.intro\n    intro n\n    induction n with\n    | zero      =>\n      apply Acc.intro 0\n      intro _ h\n      apply absurd h (Nat.not_lt_zero _)\n    | succ n ih =>\n      apply Acc.intro (Nat.succ n)\n      intro m h\n      have : m = n \u2228 m < n := Nat.eq_or_lt_of_le (Nat.le_of_succ_le_succ h)\n      match this with\n      | Or.inl e => subst e; assumption\n      | Or.inr e => exact Acc.inv ih e", "start": [151, 1], "end": [167, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.strongInductionOn", "code": "protected theorem strongInductionOn\n    {motive : Nat \u2192 Sort u}\n    (n : Nat)\n    (ind : \u2200 n, (\u2200 m, m < n \u2192 motive m) \u2192 motive n) : motive n", "start": [169, 1], "end": [173, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.caseStrongInductionOn", "code": "protected theorem caseStrongInductionOn\n    {motive : Nat \u2192 Sort u}\n    (a : Nat)\n    (zero : motive 0)\n    (ind : \u2200 n, (\u2200 m, m \u2264 n \u2192 motive m) \u2192 motive (succ n)) : motive a", "start": [175, 1], "end": [183, 65], "kind": "commanddeclaration"}, {"full_name": "measure", "code": "abbrev measure {\u03b1 : Sort u} (f : \u03b1 \u2192 Nat) : WellFoundedRelation \u03b1 :=\n  invImage f Nat.lt_wfRel", "start": [187, 1], "end": [188, 26], "kind": "commanddeclaration"}, {"full_name": "sizeOfWFRel", "code": "abbrev sizeOfWFRel {\u03b1 : Sort u} [SizeOf \u03b1] : WellFoundedRelation \u03b1 :=\n  measure sizeOf", "start": [190, 1], "end": [191, 17], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex", "code": "protected inductive Lex : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b2 \u2192 Prop where\n  | left  {a\u2081} (b\u2081) {a\u2082} (b\u2082) (h : ra a\u2081 a\u2082) : Prod.Lex (a\u2081, b\u2081) (a\u2082, b\u2082)\n  | right (a) {b\u2081 b\u2082} (h : rb b\u2081 b\u2082)         : Prod.Lex (a, b\u2081)  (a, b\u2082)", "start": [205, 1], "end": [207, 73], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.right'", "code": "def Lex.right' {a\u2081 : Nat} {b\u2081 : \u03b2} (h\u2081 : a\u2081 \u2264 a\u2082) (h\u2082 : rb b\u2081 b\u2082) : Prod.Lex Nat.lt rb (a\u2081, b\u2081) (a\u2082, b\u2082) :=\n  match Nat.eq_or_lt_of_le h\u2081 with\n  | Or.inl h => h \u25b8 Prod.Lex.right a\u2081 h\u2082\n  | Or.inr h => Prod.Lex.left b\u2081 _ h", "start": [210, 1], "end": [213, 37], "kind": "commanddeclaration"}, {"full_name": "Prod.RProd", "code": "inductive RProd : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b2 \u2192 Prop where\n  | intro {a\u2081 b\u2081 a\u2082 b\u2082} (h\u2081 : ra a\u2081 a\u2082) (h\u2082 : rb b\u2081 b\u2082) : RProd (a\u2081, b\u2081) (a\u2082, b\u2082)", "start": [216, 1], "end": [217, 82], "kind": "commanddeclaration"}, {"full_name": "Prod.lexAccessible", "code": "def lexAccessible {a : \u03b1} (aca : Acc ra a) (acb : (b : \u03b2) \u2192 Acc rb b) (b : \u03b2) : Acc (Prod.Lex ra rb) (a, b) := by\n  induction aca generalizing b with\n  | intro xa _ iha =>\n    induction (acb b) with\n    | intro xb _ ihb =>\n      apply Acc.intro (xa, xb)\n      intro p lt\n      cases lt with\n      | left  _ _ h => apply iha _ h\n      | right _ h   => apply ihb _ h", "start": [225, 1], "end": [234, 37], "kind": "commanddeclaration"}, {"full_name": "Prod.lex", "code": "@[reducible] def lex (ha : WellFoundedRelation \u03b1) (hb : WellFoundedRelation \u03b2) : WellFoundedRelation (\u03b1 \u00d7 \u03b2) where\n  rel := Prod.Lex ha.rel hb.rel\n  wf  := \u27e8fun (a, b) => lexAccessible (WellFounded.apply ha.wf a) (WellFounded.apply hb.wf) b\u27e9", "start": [237, 1], "end": [239, 95], "kind": "commanddeclaration"}, {"full_name": "Prod.RProdSubLex", "code": "def RProdSubLex (a : \u03b1 \u00d7 \u03b2) (b : \u03b1 \u00d7 \u03b2) (h : RProd ra rb a b) : Prod.Lex ra rb a b := by\n  cases h with\n  | intro h\u2081 h\u2082 => exact Prod.Lex.left _ _ h\u2081", "start": [245, 1], "end": [247, 46], "kind": "commanddeclaration"}, {"full_name": "Prod.rprod", "code": "def rprod (ha : WellFoundedRelation \u03b1) (hb : WellFoundedRelation \u03b2) : WellFoundedRelation (\u03b1 \u00d7 \u03b2) where\n  rel := RProd ha.rel hb.rel\n  wf  := by\n    apply Subrelation.wf (r := Prod.Lex ha.rel hb.rel) (h\u2082 := (lex ha hb).wf)\n    intro a b h\n    exact RProdSubLex a b h", "start": [250, 1], "end": [255, 28], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex", "code": "inductive Lex : PSigma \u03b2 \u2192 PSigma \u03b2 \u2192 Prop where\n  | left  : \u2200 {a\u2081 : \u03b1} (b\u2081 : \u03b2 a\u2081) {a\u2082 : \u03b1} (b\u2082 : \u03b2 a\u2082), r a\u2081 a\u2082 \u2192 Lex \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9\n  | right : \u2200 (a : \u03b1)  {b\u2081 b\u2082 : \u03b2 a}, s a b\u2081 b\u2082 \u2192 Lex \u27e8a, b\u2081\u27e9 \u27e8a, b\u2082\u27e9", "start": [268, 1], "end": [270, 70], "kind": "commanddeclaration"}, {"full_name": "PSigma.lexAccessible", "code": "def lexAccessible {a} (aca : Acc r a) (acb : (a : \u03b1) \u2192 WellFounded (s a)) (b : \u03b2 a) : Acc (Lex r s) \u27e8a, b\u27e9 := by\n  induction aca with\n  | intro xa _ iha =>\n    induction (WellFounded.apply (acb xa) b) with\n    | intro xb _ ihb =>\n      apply Acc.intro\n      intro p lt\n      cases lt with\n      | left  => apply iha; assumption\n      | right => apply ihb; assumption", "start": [277, 1], "end": [286, 39], "kind": "commanddeclaration"}, {"full_name": "PSigma.lex", "code": "@[reducible] def lex (ha : WellFoundedRelation \u03b1) (hb : (a : \u03b1) \u2192 WellFoundedRelation (\u03b2 a)) : WellFoundedRelation (PSigma \u03b2) where\n  rel := Lex ha.rel (fun a => hb a |>.rel)\n  wf  := WellFounded.intro fun \u27e8a, b\u27e9 => lexAccessible (WellFounded.apply ha.wf a) (fun a => hb a |>.wf) b", "start": [289, 1], "end": [291, 107], "kind": "commanddeclaration"}, {"full_name": "PSigma.lexNdep", "code": "def lexNdep (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) :=\n  Lex r (fun _ => s)", "start": [301, 1], "end": [302, 21], "kind": "commanddeclaration"}, {"full_name": "PSigma.lexNdepWf", "code": "def lexNdepWf {r  : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (ha : WellFounded r) (hb : WellFounded s) : WellFounded (lexNdep r s) :=\n  WellFounded.intro fun \u27e8a, b\u27e9 => lexAccessible (WellFounded.apply ha a) (fun _ => hb) b", "start": [304, 1], "end": [305, 89], "kind": "commanddeclaration"}, {"full_name": "PSigma.RevLex", "code": "inductive RevLex (r  : \u03b1 \u2192 \u03b1 \u2192 Prop) (s  : \u03b2 \u2192 \u03b2 \u2192 Prop) : @PSigma \u03b1 (fun _ => \u03b2) \u2192 @PSigma \u03b1 (fun _ => \u03b2) \u2192 Prop where\n  | left  : {a\u2081 a\u2082 : \u03b1} \u2192 (b : \u03b2) \u2192 r a\u2081 a\u2082 \u2192 RevLex r s \u27e8a\u2081, b\u27e9 \u27e8a\u2082, b\u27e9\n  | right : (a\u2081 : \u03b1) \u2192 {b\u2081 : \u03b2} \u2192 (a\u2082 : \u03b1) \u2192 {b\u2082 : \u03b2} \u2192 s b\u2081 b\u2082 \u2192 RevLex r s \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9", "start": [312, 1], "end": [314, 95], "kind": "commanddeclaration"}, {"full_name": "PSigma.revLexAccessible", "code": "def revLexAccessible {b} (acb : Acc s b) (aca : (a : \u03b1) \u2192 Acc r a): (a : \u03b1) \u2192 Acc (RevLex r s) \u27e8a, b\u27e9 := by\n  induction acb with\n  | intro xb _ ihb =>\n    intro a\n    induction (aca a) with\n    | intro xa _ iha =>\n      apply Acc.intro\n      intro p lt\n      cases lt with\n      | left  => apply iha; assumption\n      | right => apply ihb; assumption", "start": [322, 1], "end": [332, 39], "kind": "commanddeclaration"}, {"full_name": "PSigma.revLex", "code": "def revLex (ha : WellFounded r) (hb : WellFounded s) : WellFounded (RevLex r s) :=\n  WellFounded.intro fun \u27e8a, b\u27e9 => revLexAccessible (apply hb b) (WellFounded.apply ha) a", "start": [334, 1], "end": [335, 89], "kind": "commanddeclaration"}, {"full_name": "PSigma.SkipLeft", "code": "def SkipLeft (\u03b1 : Type u) {\u03b2 : Type v} (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : @PSigma \u03b1 (fun _ => \u03b2) \u2192 @PSigma \u03b1 (fun _ => \u03b2) \u2192 Prop :=\n  RevLex emptyRelation s", "start": [339, 1], "end": [340, 25], "kind": "commanddeclaration"}, {"full_name": "PSigma.skipLeft", "code": "def skipLeft (\u03b1 : Type u) {\u03b2 : Type v} (hb : WellFoundedRelation \u03b2) : WellFoundedRelation (PSigma fun _ : \u03b1 => \u03b2) where\n  rel := SkipLeft \u03b1 hb.rel\n  wf  := revLex emptyWf.wf hb.wf", "start": [342, 1], "end": [344, 33], "kind": "commanddeclaration"}, {"full_name": "PSigma.mkSkipLeft", "code": "def mkSkipLeft {\u03b1 : Type u} {\u03b2 : Type v} {b\u2081 b\u2082 : \u03b2} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (a\u2081 a\u2082 : \u03b1) (h : s b\u2081 b\u2082) : SkipLeft \u03b1 s \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9 :=\n  RevLex.right _ _ h", "start": [346, 1], "end": [347, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/WFTactics.lean", "imports": ["lake-packages/lean4/src/lean/Init/WF.lean", "lake-packages/lean4/src/lean/Init/SizeOf.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init/WF.lean", "lake-packages/lean4/src/lean/Init/WFTactics.lean"], "premises": [{"full_name": "Nat.div_rec_lemma", "code": "theorem div_rec_lemma {x y : Nat} : 0 < y \u2227 y \u2264 x \u2192 x - y < x", "start": [12, 1], "end": [13, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.div", "code": "@[extern \"lean_nat_div\"]\nprotected def div (x y : @& Nat) : Nat :=\n  if 0 < y \u2227 y \u2264 x then\n    Nat.div (x - y) y + 1\n  else\n    0\ndecreasing_by apply div_rec_lemma; assumption", "start": [15, 1], "end": [21, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq", "code": "theorem div_eq (x y : Nat) : x / y = if 0 < y \u2227 y \u2264 x then (x - y) / y + 1 else 0", "start": [25, 1], "end": [28, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.div.inductionOn", "code": "theorem div.inductionOn.{u}\n      {motive : Nat \u2192 Nat \u2192 Sort u}\n      (x y : Nat)\n      (ind  : \u2200 x y, 0 < y \u2227 y \u2264 x \u2192 motive (x - y) y \u2192 motive x y)\n      (base : \u2200 x y, \u00ac(0 < y \u2227 y \u2264 x) \u2192 motive x y)\n      : motive x y", "start": [30, 1], "end": [40, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.div_le_self", "code": "theorem div_le_self (n k : Nat) : n / k \u2264 n", "start": [42, 1], "end": [54, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.div_lt_self", "code": "theorem div_lt_self {n k : Nat} (hLtN : 0 < n) (hLtK : 1 < k) : n / k < n", "start": [56, 1], "end": [65, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.modCore", "code": "@[extern \"lean_nat_mod\"]\nprotected def modCore (x y : @& Nat) : Nat :=\n  if 0 < y \u2227 y \u2264 x then\n    Nat.modCore (x - y) y\n  else\n    x\ndecreasing_by apply div_rec_lemma; assumption", "start": [67, 1], "end": [73, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.mod", "code": "@[extern \"lean_nat_mod\"]\nprotected def mod : @& Nat \u2192 @& Nat \u2192 Nat\n  \n  | 0, _ => 0\n  | x@(_ + 1), y => Nat.modCore x y", "start": [75, 1], "end": [83, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.modCore_eq_mod", "code": "protected theorem modCore_eq_mod (x y : Nat) : Nat.modCore x y = x % y", "start": [87, 1], "end": [92, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_eq", "code": "theorem mod_eq (x y : Nat) : x % y = if 0 < y \u2227 y \u2264 x then (x - y) % y else x", "start": [94, 1], "end": [95, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.mod.inductionOn", "code": "theorem mod.inductionOn.{u}\n      {motive : Nat \u2192 Nat \u2192 Sort u}\n      (x y  : Nat)\n      (ind  : \u2200 x y, 0 < y \u2227 y \u2264 x \u2192 motive (x - y) y \u2192 motive x y)\n      (base : \u2200 x y, \u00ac(0 < y \u2227 y \u2264 x) \u2192 motive x y)\n      : motive x y", "start": [97, 1], "end": [103, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_zero", "code": "@[simp] theorem mod_zero (a : Nat) : a % 0 = a", "start": [105, 1], "end": [109, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_eq_of_lt", "code": "theorem mod_eq_of_lt {a b : Nat} (h : a < b) : a % b = a", "start": [111, 1], "end": [115, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_eq_sub_mod", "code": "theorem mod_eq_sub_mod {a b : Nat} (h : a \u2265 b) : a % b = (a - b) % b", "start": [117, 1], "end": [120, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_lt", "code": "theorem mod_lt (x : Nat) {y : Nat} : y > 0 \u2192 x % y < y", "start": [122, 1], "end": [138, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_le", "code": "theorem mod_le (x y : Nat) : x % y \u2264 x", "start": [140, 1], "end": [145, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_mod", "code": "@[simp] theorem zero_mod (b : Nat) : 0 % b = 0", "start": [147, 1], "end": [152, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_self", "code": "@[simp] theorem mod_self (n : Nat) : n % n = 0", "start": [154, 1], "end": [155, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_one", "code": "theorem mod_one (x : Nat) : x % 1 = 0", "start": [157, 1], "end": [164, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.div_add_mod", "code": "theorem div_add_mod (m n : Nat) : n * (m / n) + m % n = m", "start": [166, 1], "end": [175, 46], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat/Bitwise.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init/Coe.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean"], "premises": [{"full_name": "Nat.bitwise_rec_lemma", "code": "theorem bitwise_rec_lemma {n : Nat} (hNe : n \u2260 0) : n / 2 < n", "start": [13, 1], "end": [14, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.bitwise", "code": "def bitwise (f : Bool \u2192 Bool \u2192 Bool) (n m : Nat) : Nat :=\n  if n = 0 then\n    if f false true then m else 0\n  else if m = 0 then\n    if f true false then n else 0\n  else\n    let n' := n / 2\n    let m' := m / 2\n    let b\u2081 := n % 2 = 1\n    let b\u2082 := m % 2 = 1\n    let r  := bitwise f n' m'\n    if f b\u2081 b\u2082 then\n      r+r+1\n    else\n      r+r\ndecreasing_by apply bitwise_rec_lemma; assumption", "start": [16, 1], "end": [31, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.land", "code": "@[extern \"lean_nat_land\"]\ndef land : @& Nat \u2192 @& Nat \u2192 Nat := bitwise and", "start": [33, 1], "end": [34, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.lor", "code": "@[extern \"lean_nat_lor\"]\ndef lor  : @& Nat \u2192 @& Nat \u2192 Nat := bitwise or", "start": [35, 1], "end": [36, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.xor", "code": "@[extern \"lean_nat_lxor\"]\ndef xor  : @& Nat \u2192 @& Nat \u2192 Nat := bitwise bne", "start": [37, 1], "end": [38, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft", "code": "@[extern \"lean_nat_shiftl\"]\ndef shiftLeft : @& Nat \u2192 @& Nat \u2192 Nat\n  | n, 0 => n\n  | n, succ m => shiftLeft (2*n) m", "start": [39, 1], "end": [42, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftRight", "code": "@[extern \"lean_nat_shiftr\"]\ndef shiftRight : @& Nat \u2192 @& Nat \u2192 Nat\n  | n, 0 => n\n  | n, succ m => shiftRight n m / 2", "start": [43, 1], "end": [46, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/System/Platform.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean"], "premises": [{"full_name": "System.Platform.getIsWindows", "code": "@[extern \"lean_system_platform_windows\"] opaque getIsWindows : Unit \u2192 Bool", "start": [12, 1], "end": [12, 75], "kind": "commanddeclaration"}, {"full_name": "System.Platform.getIsOSX", "code": "@[extern \"lean_system_platform_osx\"] opaque getIsOSX : Unit \u2192 Bool", "start": [13, 1], "end": [13, 67], "kind": "commanddeclaration"}, {"full_name": "System.Platform.getIsEmscripten", "code": "@[extern \"lean_system_platform_emscripten\"] opaque getIsEmscripten : Unit \u2192 Bool", "start": [14, 1], "end": [14, 81], "kind": "commanddeclaration"}, {"full_name": "System.Platform.isWindows", "code": "def isWindows : Bool := getIsWindows ()", "start": [16, 1], "end": [16, 40], "kind": "commanddeclaration"}, {"full_name": "System.Platform.isOSX", "code": "def isOSX : Bool := getIsOSX ()", "start": [17, 1], "end": [17, 32], "kind": "commanddeclaration"}, {"full_name": "System.Platform.isEmscripten", "code": "def isEmscripten : Bool := getIsEmscripten ()", "start": [18, 1], "end": [18, 46], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Fin/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Bitwise.lean", "lake-packages/lean4/src/lean/Init/Coe.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean"], "premises": [{"full_name": "Fin.coeToNat", "code": "instance coeToNat : CoeOut (Fin n) Nat :=\n  \u27e8fun v => v.val\u27e9", "start": [15, 1], "end": [16, 19], "kind": "commanddeclaration"}, {"full_name": "Fin.elim0", "code": "def elim0.{u} {\u03b1 : Sort u} : Fin 0 \u2192 \u03b1\n  | \u27e8_, h\u27e9 => absurd h (not_lt_zero _)", "start": [18, 1], "end": [19, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.succ", "code": "def succ : Fin n \u2192 Fin n.succ\n  | \u27e8i, h\u27e9 => \u27e8i+1, Nat.succ_lt_succ h\u27e9", "start": [21, 1], "end": [22, 40], "kind": "commanddeclaration"}, {"full_name": "Fin.ofNat", "code": "protected def ofNat {n : Nat} (a : Nat) : Fin n.succ :=\n  \u27e8a % (n+1), Nat.mod_lt _ (Nat.zero_lt_succ _)\u27e9", "start": [26, 1], "end": [27, 49], "kind": "commanddeclaration"}, {"full_name": "Fin.ofNat'", "code": "protected def ofNat' {n : Nat} (a : Nat) (h : n > 0) : Fin n :=\n  \u27e8a % n, Nat.mod_lt _ h\u27e9", "start": [29, 1], "end": [30, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.mlt", "code": "private theorem mlt {b : Nat} : {a : Nat} \u2192 a < n \u2192 b % n < n", "start": [32, 1], "end": [36, 22], "kind": "commanddeclaration"}, {"full_name": "Fin.add", "code": "protected def add : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(a + b) % n, mlt h\u27e9", "start": [38, 1], "end": [39, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.mul", "code": "protected def mul : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(a * b) % n, mlt h\u27e9", "start": [41, 1], "end": [42, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.sub", "code": "protected def sub : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(a + (n - b)) % n, mlt h\u27e9", "start": [44, 1], "end": [45, 49], "kind": "commanddeclaration"}, {"full_name": "Fin.mod", "code": "protected def mod : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(a % b) % n, mlt h\u27e9", "start": [53, 1], "end": [54, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.div", "code": "protected def div : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(a / b) % n, mlt h\u27e9", "start": [56, 1], "end": [57, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.modn", "code": "def modn : Fin n \u2192 Nat \u2192 Fin n\n  | \u27e8a, h\u27e9, m => \u27e8(a % m) % n, mlt h\u27e9", "start": [59, 1], "end": [60, 38], "kind": "commanddeclaration"}, {"full_name": "Fin.land", "code": "def land : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(Nat.land a b) % n, mlt h\u27e9", "start": [62, 1], "end": [63, 50], "kind": "commanddeclaration"}, {"full_name": "Fin.lor", "code": "def lor : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(Nat.lor a b) % n, mlt h\u27e9", "start": [65, 1], "end": [66, 49], "kind": "commanddeclaration"}, {"full_name": "Fin.xor", "code": "def xor : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(Nat.xor a b) % n, mlt h\u27e9", "start": [68, 1], "end": [69, 49], "kind": "commanddeclaration"}, {"full_name": "Fin.shiftLeft", "code": "def shiftLeft : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(a <<< b) % n, mlt h\u27e9", "start": [71, 1], "end": [72, 45], "kind": "commanddeclaration"}, {"full_name": "Fin.shiftRight", "code": "def shiftRight : Fin n \u2192 Fin n \u2192 Fin n\n  | \u27e8a, h\u27e9, \u27e8b, _\u27e9 => \u27e8(a >>> b) % n, mlt h\u27e9", "start": [74, 1], "end": [75, 45], "kind": "commanddeclaration"}, {"full_name": "Fin.val_ne_of_ne", "code": "theorem val_ne_of_ne {i j : Fin n} (h : i \u2260 j) : val i \u2260 val j", "start": [109, 1], "end": [110, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.modn_lt", "code": "theorem modn_lt : \u2200 {m : Nat} (i : Fin n), m > 0 \u2192 (modn i m).val < m", "start": [112, 1], "end": [113, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.val_lt_of_le", "code": "theorem val_lt_of_le (i : Fin b) (h : b \u2264 n) : i.val < n", "start": [115, 1], "end": [116, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Core.lean"], "premises": [{"full_name": "Functor.mapRev", "code": "@[reducible]\ndef Functor.mapRev {f : Type u \u2192 Type v} [Functor f] {\u03b1 \u03b2 : Type u} : f \u03b1 \u2192 (\u03b1 \u2192 \u03b2) \u2192 f \u03b2 :=\n  fun a f => f <$> a", "start": [11, 1], "end": [13, 21], "kind": "commanddeclaration"}, {"full_name": "Functor.discard", "code": "@[always_inline, inline]\ndef Functor.discard {f : Type u \u2192 Type v} {\u03b1 : Type u} [Functor f] (x : f \u03b1) : f PUnit :=\n  Functor.mapConst PUnit.unit x", "start": [17, 1], "end": [19, 32], "kind": "commanddeclaration"}, {"full_name": "Alternative", "code": "class Alternative (f : Type u \u2192 Type v) extends Applicative f : Type (max (u+1) v) where\n  failure : {\u03b1 : Type u} \u2192 f \u03b1\n  orElse  : {\u03b1 : Type u} \u2192 f \u03b1 \u2192 (Unit \u2192 f \u03b1) \u2192 f \u03b1", "start": [23, 1], "end": [25, 52], "kind": "commanddeclaration"}, {"full_name": "guard", "code": "@[always_inline, inline] def guard {f : Type \u2192 Type v} [Alternative f] (p : Prop) [Decidable p] : f Unit :=\n  if p then pure () else failure", "start": [33, 1], "end": [34, 33], "kind": "commanddeclaration"}, {"full_name": "optional", "code": "@[always_inline, inline] def optional (x : f \u03b1) : f (Option \u03b1) :=\n  some <$> x <|> pure none", "start": [36, 1], "end": [37, 27], "kind": "commanddeclaration"}, {"full_name": "ToBool", "code": "class ToBool (\u03b1 : Type u) where\n  toBool : \u03b1 \u2192 Bool", "start": [39, 1], "end": [40, 20], "kind": "commanddeclaration"}, {"full_name": "bool", "code": "@[macro_inline] def bool {\u03b2 : Type u} {\u03b1 : Type v} [ToBool \u03b2] (f t : \u03b1) (b : \u03b2) : \u03b1 :=\n  match toBool b with\n  | true  => t\n  | false => f", "start": [47, 1], "end": [50, 15], "kind": "commanddeclaration"}, {"full_name": "orM", "code": "@[macro_inline] def orM {m : Type u \u2192 Type v} {\u03b2 : Type u} [Monad m] [ToBool \u03b2] (x y : m \u03b2) : m \u03b2 := do\n  let b \u2190 x\n  match toBool b with\n  | true  => pure b\n  | false => y", "start": [52, 1], "end": [56, 15], "kind": "commanddeclaration"}, {"full_name": "andM", "code": "@[macro_inline] def andM {m : Type u \u2192 Type v} {\u03b2 : Type u} [Monad m] [ToBool \u03b2] (x y : m \u03b2) : m \u03b2 := do\n  let b \u2190 x\n  match toBool b with\n  | true  => y\n  | false => pure b", "start": [60, 1], "end": [64, 20], "kind": "commanddeclaration"}, {"full_name": "notM", "code": "@[macro_inline] def notM {m : Type \u2192 Type v} [Applicative m] (x : m Bool) : m Bool :=\n  not <$> x", "start": [68, 1], "end": [69, 12], "kind": "commanddeclaration"}, {"full_name": "MonadControl", "code": "class MonadControl (m : semiOutParam (Type u \u2192 Type v)) (n : Type u \u2192 Type w) where\n  stM      : Type u \u2192 Type u\n  liftWith : {\u03b1 : Type u} \u2192 (({\u03b2 : Type u} \u2192 n \u03b2 \u2192 m (stM \u03b2)) \u2192 m \u03b1) \u2192 n \u03b1\n  restoreM : {\u03b1 : Type u} \u2192 m (stM \u03b1) \u2192 n \u03b1", "start": [183, 1], "end": [192, 44], "kind": "commanddeclaration"}, {"full_name": "MonadControlT", "code": "class MonadControlT (m : Type u \u2192 Type v) (n : Type u \u2192 Type w) where\n  stM      : Type u \u2192 Type u\n  liftWith : {\u03b1 : Type u} \u2192 (({\u03b2 : Type u} \u2192 n \u03b2 \u2192 m (stM \u03b2)) \u2192 m \u03b1) \u2192 n \u03b1\n  restoreM {\u03b1 : Type u} : stM \u03b1 \u2192 n \u03b1", "start": [194, 1], "end": [198, 38], "kind": "commanddeclaration"}, {"full_name": "controlAt", "code": "@[always_inline, inline]\ndef controlAt (m : Type u \u2192 Type v) {n : Type u \u2192 Type w} [MonadControlT m n] [Bind n] {\u03b1 : Type u}\n    (f : ({\u03b2 : Type u} \u2192 n \u03b2 \u2192 m (stM m n \u03b2)) \u2192 m (stM m n \u03b1)) : n \u03b1 :=\n  liftWith f >>= restoreM", "start": [213, 1], "end": [216, 26], "kind": "commanddeclaration"}, {"full_name": "control", "code": "@[always_inline, inline]\ndef control {m : Type u \u2192 Type v} {n : Type u \u2192 Type w} [MonadControlT m n] [Bind n] {\u03b1 : Type u}\n    (f : ({\u03b2 : Type u} \u2192 n \u03b2 \u2192 m (stM m n \u03b2)) \u2192 m (stM m n \u03b1)) : n \u03b1 :=\n  controlAt m f", "start": [218, 1], "end": [221, 16], "kind": "commanddeclaration"}, {"full_name": "ForM", "code": "class ForM (m : Type u \u2192 Type v) (\u03b3 : Type w\u2081) (\u03b1 : outParam (Type w\u2082)) where\n  forM [Monad m] : \u03b3 \u2192 (\u03b1 \u2192 m PUnit) \u2192 m PUnit", "start": [223, 1], "end": [231, 47], "kind": "commanddeclaration"}, {"full_name": "Bind.kleisliRight", "code": "@[always_inline]\ndef Bind.kleisliRight [Bind m] (f\u2081 : \u03b1 \u2192 m \u03b2) (f\u2082 : \u03b2 \u2192 m \u03b3) (a : \u03b1) : m \u03b3 :=\n  f\u2081 a >>= f\u2082", "start": [235, 1], "end": [238, 14], "kind": "commanddeclaration"}, {"full_name": "Bind.kleisliLeft", "code": "@[always_inline]\ndef Bind.kleisliLeft [Bind m] (f\u2082 : \u03b2 \u2192 m \u03b3) (f\u2081 : \u03b1 \u2192 m \u03b2) (a : \u03b1) : m \u03b3 :=\n  f\u2081 a >>= f\u2082", "start": [240, 1], "end": [243, 14], "kind": "commanddeclaration"}, {"full_name": "Bind.bindLeft", "code": "@[always_inline]\ndef Bind.bindLeft [Bind m] (f : \u03b1 \u2192 m \u03b2) (ma : m \u03b1) : m \u03b2 :=\n  ma >>= f", "start": [245, 1], "end": [248, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/UInt/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Fin/Basic.lean", "lake-packages/lean4/src/lean/Init/System/Platform.lean"], "premises": [{"full_name": "UInt8.ofNat", "code": "@[extern \"lean_uint8_of_nat\"]\ndef UInt8.ofNat (n : @& Nat) : UInt8 := \u27e8Fin.ofNat n\u27e9", "start": [12, 1], "end": [13, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.toUInt8", "code": "abbrev Nat.toUInt8 := UInt8.ofNat", "start": [14, 1], "end": [14, 34], "kind": "commanddeclaration"}, {"full_name": "UInt8.toNat", "code": "@[extern \"lean_uint8_to_nat\"]\ndef UInt8.toNat (n : UInt8) : Nat := n.val.val", "start": [15, 1], "end": [16, 47], "kind": "commanddeclaration"}, {"full_name": "UInt8.add", "code": "@[extern \"lean_uint8_add\"]\ndef UInt8.add (a b : UInt8) : UInt8 := \u27e8a.val + b.val\u27e9", "start": [17, 1], "end": [18, 55], "kind": "commanddeclaration"}, {"full_name": "UInt8.sub", "code": "@[extern \"lean_uint8_sub\"]\ndef UInt8.sub (a b : UInt8) : UInt8 := \u27e8a.val - b.val\u27e9", "start": [19, 1], "end": [20, 55], "kind": "commanddeclaration"}, {"full_name": "UInt8.mul", "code": "@[extern \"lean_uint8_mul\"]\ndef UInt8.mul (a b : UInt8) : UInt8 := \u27e8a.val * b.val\u27e9", "start": [21, 1], "end": [22, 55], "kind": "commanddeclaration"}, {"full_name": "UInt8.div", "code": "@[extern \"lean_uint8_div\"]\ndef UInt8.div (a b : UInt8) : UInt8 := \u27e8a.val / b.val\u27e9", "start": [23, 1], "end": [24, 55], "kind": "commanddeclaration"}, {"full_name": "UInt8.mod", "code": "@[extern \"lean_uint8_mod\"]\ndef UInt8.mod (a b : UInt8) : UInt8 := \u27e8a.val % b.val\u27e9", "start": [25, 1], "end": [26, 55], "kind": "commanddeclaration"}, {"full_name": "UInt8.modn", "code": "@[extern \"lean_uint8_modn\"]\ndef UInt8.modn (a : UInt8) (n : @& Nat) : UInt8 := \u27e8Fin.modn a.val n\u27e9", "start": [27, 1], "end": [28, 70], "kind": "commanddeclaration"}, {"full_name": "UInt8.land", "code": "@[extern \"lean_uint8_land\"]\ndef UInt8.land (a b : UInt8) : UInt8 := \u27e8Fin.land a.val b.val\u27e9", "start": [29, 1], "end": [30, 63], "kind": "commanddeclaration"}, {"full_name": "UInt8.lor", "code": "@[extern \"lean_uint8_lor\"]\ndef UInt8.lor (a b : UInt8) : UInt8 := \u27e8Fin.lor a.val b.val\u27e9", "start": [31, 1], "end": [32, 61], "kind": "commanddeclaration"}, {"full_name": "UInt8.xor", "code": "@[extern \"lean_uint8_xor\"]\ndef UInt8.xor (a b : UInt8) : UInt8 := \u27e8Fin.xor a.val b.val\u27e9", "start": [33, 1], "end": [34, 61], "kind": "commanddeclaration"}, {"full_name": "UInt8.shiftLeft", "code": "@[extern \"lean_uint8_shift_left\"]\ndef UInt8.shiftLeft (a b : UInt8) : UInt8 := \u27e8a.val <<< (modn b 8).val\u27e9", "start": [35, 1], "end": [36, 72], "kind": "commanddeclaration"}, {"full_name": "UInt8.shiftRight", "code": "@[extern \"lean_uint8_shift_right\"]\ndef UInt8.shiftRight (a b : UInt8) : UInt8 := \u27e8a.val >>> (modn b 8).val\u27e9", "start": [37, 1], "end": [38, 73], "kind": "commanddeclaration"}, {"full_name": "UInt8.lt", "code": "def UInt8.lt (a b : UInt8) : Prop := a.val < b.val", "start": [39, 1], "end": [39, 51], "kind": "commanddeclaration"}, {"full_name": "UInt8.le", "code": "def UInt8.le (a b : UInt8) : Prop := a.val \u2264 b.val", "start": [40, 1], "end": [40, 51], "kind": "commanddeclaration"}, {"full_name": "UInt8.complement", "code": "@[extern \"lean_uint8_complement\"]\ndef UInt8.complement (a:UInt8) : UInt8 := 0-(a+1)", "start": [52, 1], "end": [53, 50], "kind": "commanddeclaration"}, {"full_name": "UInt8.decLt", "code": "@[extern \"lean_uint8_dec_lt\"]\ndef UInt8.decLt (a b : UInt8) : Decidable (a < b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (n < m))", "start": [63, 1], "end": [66, 52], "kind": "commanddeclaration"}, {"full_name": "UInt8.decLe", "code": "@[extern \"lean_uint8_dec_le\"]\ndef UInt8.decLe (a b : UInt8) : Decidable (a \u2264 b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (n <= m))", "start": [69, 1], "end": [72, 53], "kind": "commanddeclaration"}, {"full_name": "UInt16.ofNat", "code": "@[extern \"lean_uint16_of_nat\"]\ndef UInt16.ofNat (n : @& Nat) : UInt16 := \u27e8Fin.ofNat n\u27e9", "start": [79, 1], "end": [80, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.toUInt16", "code": "abbrev Nat.toUInt16 := UInt16.ofNat", "start": [81, 1], "end": [81, 36], "kind": "commanddeclaration"}, {"full_name": "UInt16.toNat", "code": "@[extern \"lean_uint16_to_nat\"]\ndef UInt16.toNat (n : UInt16) : Nat := n.val.val", "start": [82, 1], "end": [83, 49], "kind": "commanddeclaration"}, {"full_name": "UInt16.add", "code": "@[extern \"lean_uint16_add\"]\ndef UInt16.add (a b : UInt16) : UInt16 := \u27e8a.val + b.val\u27e9", "start": [84, 1], "end": [85, 58], "kind": "commanddeclaration"}, {"full_name": "UInt16.sub", "code": "@[extern \"lean_uint16_sub\"]\ndef UInt16.sub (a b : UInt16) : UInt16 := \u27e8a.val - b.val\u27e9", "start": [86, 1], "end": [87, 58], "kind": "commanddeclaration"}, {"full_name": "UInt16.mul", "code": "@[extern \"lean_uint16_mul\"]\ndef UInt16.mul (a b : UInt16) : UInt16 := \u27e8a.val * b.val\u27e9", "start": [88, 1], "end": [89, 58], "kind": "commanddeclaration"}, {"full_name": "UInt16.div", "code": "@[extern \"lean_uint16_div\"]\ndef UInt16.div (a b : UInt16) : UInt16 := \u27e8a.val / b.val\u27e9", "start": [90, 1], "end": [91, 58], "kind": "commanddeclaration"}, {"full_name": "UInt16.mod", "code": "@[extern \"lean_uint16_mod\"]\ndef UInt16.mod (a b : UInt16) : UInt16 := \u27e8a.val % b.val\u27e9", "start": [92, 1], "end": [93, 58], "kind": "commanddeclaration"}, {"full_name": "UInt16.modn", "code": "@[extern \"lean_uint16_modn\"]\ndef UInt16.modn (a : UInt16) (n : @& Nat) : UInt16 := \u27e8Fin.modn a.val n\u27e9", "start": [94, 1], "end": [95, 73], "kind": "commanddeclaration"}, {"full_name": "UInt16.land", "code": "@[extern \"lean_uint16_land\"]\ndef UInt16.land (a b : UInt16) : UInt16 := \u27e8Fin.land a.val b.val\u27e9", "start": [96, 1], "end": [97, 66], "kind": "commanddeclaration"}, {"full_name": "UInt16.lor", "code": "@[extern \"lean_uint16_lor\"]\ndef UInt16.lor (a b : UInt16) : UInt16 := \u27e8Fin.lor a.val b.val\u27e9", "start": [98, 1], "end": [99, 64], "kind": "commanddeclaration"}, {"full_name": "UInt16.xor", "code": "@[extern \"lean_uint16_xor\"]\ndef UInt16.xor (a b : UInt16) : UInt16 := \u27e8Fin.xor a.val b.val\u27e9", "start": [100, 1], "end": [101, 64], "kind": "commanddeclaration"}, {"full_name": "UInt16.shiftLeft", "code": "@[extern \"lean_uint16_shift_left\"]\ndef UInt16.shiftLeft (a b : UInt16) : UInt16 := \u27e8a.val <<< (modn b 16).val\u27e9", "start": [102, 1], "end": [103, 76], "kind": "commanddeclaration"}, {"full_name": "UInt16.toUInt8", "code": "@[extern \"lean_uint16_to_uint8\"]\ndef UInt16.toUInt8 (a : UInt16) : UInt8 := a.toNat.toUInt8", "start": [104, 1], "end": [105, 59], "kind": "commanddeclaration"}, {"full_name": "UInt8.toUInt16", "code": "@[extern \"lean_uint8_to_uint16\"]\ndef UInt8.toUInt16 (a : UInt8) : UInt16 := a.toNat.toUInt16", "start": [106, 1], "end": [107, 60], "kind": "commanddeclaration"}, {"full_name": "UInt16.shiftRight", "code": "@[extern \"lean_uint16_shift_right\"]\ndef UInt16.shiftRight (a b : UInt16) : UInt16 := \u27e8a.val >>> (modn b 16).val\u27e9", "start": [108, 1], "end": [109, 77], "kind": "commanddeclaration"}, {"full_name": "UInt16.lt", "code": "def UInt16.lt (a b : UInt16) : Prop := a.val < b.val", "start": [110, 1], "end": [110, 53], "kind": "commanddeclaration"}, {"full_name": "UInt16.le", "code": "def UInt16.le (a b : UInt16) : Prop := a.val \u2264 b.val", "start": [111, 1], "end": [111, 53], "kind": "commanddeclaration"}, {"full_name": "UInt16.complement", "code": "@[extern \"lean_uint16_complement\"]\ndef UInt16.complement (a:UInt16) : UInt16 := 0-(a+1)", "start": [124, 1], "end": [125, 53], "kind": "commanddeclaration"}, {"full_name": "UInt16.decLt", "code": "@[extern \"lean_uint16_dec_lt\"]\ndef UInt16.decLt (a b : UInt16) : Decidable (a < b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (n < m))", "start": [135, 1], "end": [138, 52], "kind": "commanddeclaration"}, {"full_name": "UInt16.decLe", "code": "@[extern \"lean_uint16_dec_le\"]\ndef UInt16.decLe (a b : UInt16) : Decidable (a \u2264 b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (n <= m))", "start": [141, 1], "end": [144, 53], "kind": "commanddeclaration"}, {"full_name": "UInt32.ofNat", "code": "@[extern \"lean_uint32_of_nat\"]\ndef UInt32.ofNat (n : @& Nat) : UInt32 := \u27e8Fin.ofNat n\u27e9", "start": [151, 1], "end": [152, 56], "kind": "commanddeclaration"}, {"full_name": "UInt32.ofNat'", "code": "@[extern \"lean_uint32_of_nat\"]\ndef UInt32.ofNat' (n : Nat) (h : n < UInt32.size) : UInt32 := \u27e8\u27e8n, h\u27e9\u27e9", "start": [153, 1], "end": [154, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.toUInt32", "code": "abbrev Nat.toUInt32 := UInt32.ofNat", "start": [155, 1], "end": [155, 36], "kind": "commanddeclaration"}, {"full_name": "UInt32.add", "code": "@[extern \"lean_uint32_add\"]\ndef UInt32.add (a b : UInt32) : UInt32 := \u27e8a.val + b.val\u27e9", "start": [156, 1], "end": [157, 58], "kind": "commanddeclaration"}, {"full_name": "UInt32.sub", "code": "@[extern \"lean_uint32_sub\"]\ndef UInt32.sub (a b : UInt32) : UInt32 := \u27e8a.val - b.val\u27e9", "start": [158, 1], "end": [159, 58], "kind": "commanddeclaration"}, {"full_name": "UInt32.mul", "code": "@[extern \"lean_uint32_mul\"]\ndef UInt32.mul (a b : UInt32) : UInt32 := \u27e8a.val * b.val\u27e9", "start": [160, 1], "end": [161, 58], "kind": "commanddeclaration"}, {"full_name": "UInt32.div", "code": "@[extern \"lean_uint32_div\"]\ndef UInt32.div (a b : UInt32) : UInt32 := \u27e8a.val / b.val\u27e9", "start": [162, 1], "end": [163, 58], "kind": "commanddeclaration"}, {"full_name": "UInt32.mod", "code": "@[extern \"lean_uint32_mod\"]\ndef UInt32.mod (a b : UInt32) : UInt32 := \u27e8a.val % b.val\u27e9", "start": [164, 1], "end": [165, 58], "kind": "commanddeclaration"}, {"full_name": "UInt32.modn", "code": "@[extern \"lean_uint32_modn\"]\ndef UInt32.modn (a : UInt32) (n : @& Nat) : UInt32 := \u27e8Fin.modn a.val n\u27e9", "start": [166, 1], "end": [167, 73], "kind": "commanddeclaration"}, {"full_name": "UInt32.land", "code": "@[extern \"lean_uint32_land\"]\ndef UInt32.land (a b : UInt32) : UInt32 := \u27e8Fin.land a.val b.val\u27e9", "start": [168, 1], "end": [169, 66], "kind": "commanddeclaration"}, {"full_name": "UInt32.lor", "code": "@[extern \"lean_uint32_lor\"]\ndef UInt32.lor (a b : UInt32) : UInt32 := \u27e8Fin.lor a.val b.val\u27e9", "start": [170, 1], "end": [171, 64], "kind": "commanddeclaration"}, {"full_name": "UInt32.xor", "code": "@[extern \"lean_uint32_xor\"]\ndef UInt32.xor (a b : UInt32) : UInt32 := \u27e8Fin.xor a.val b.val\u27e9", "start": [172, 1], "end": [173, 64], "kind": "commanddeclaration"}, {"full_name": "UInt32.shiftLeft", "code": "@[extern \"lean_uint32_shift_left\"]\ndef UInt32.shiftLeft (a b : UInt32) : UInt32 := \u27e8a.val <<< (modn b 32).val\u27e9", "start": [174, 1], "end": [175, 76], "kind": "commanddeclaration"}, {"full_name": "UInt32.shiftRight", "code": "@[extern \"lean_uint32_shift_right\"]\ndef UInt32.shiftRight (a b : UInt32) : UInt32 := \u27e8a.val >>> (modn b 32).val\u27e9", "start": [176, 1], "end": [177, 77], "kind": "commanddeclaration"}, {"full_name": "UInt32.toUInt8", "code": "@[extern \"lean_uint32_to_uint8\"]\ndef UInt32.toUInt8 (a : UInt32) : UInt8 := a.toNat.toUInt8", "start": [178, 1], "end": [179, 59], "kind": "commanddeclaration"}, {"full_name": "UInt32.toUInt16", "code": "@[extern \"lean_uint32_to_uint16\"]\ndef UInt32.toUInt16 (a : UInt32) : UInt16 := a.toNat.toUInt16", "start": [180, 1], "end": [181, 62], "kind": "commanddeclaration"}, {"full_name": "UInt8.toUInt32", "code": "@[extern \"lean_uint8_to_uint32\"]\ndef UInt8.toUInt32 (a : UInt8) : UInt32 := a.toNat.toUInt32", "start": [182, 1], "end": [183, 60], "kind": "commanddeclaration"}, {"full_name": "UInt16.toUInt32", "code": "@[extern \"lean_uint16_to_uint32\"]\ndef UInt16.toUInt32 (a : UInt16) : UInt32 := a.toNat.toUInt32", "start": [184, 1], "end": [185, 62], "kind": "commanddeclaration"}, {"full_name": "UInt32.complement", "code": "@[extern \"lean_uint32_complement\"]\ndef UInt32.complement (a:UInt32) : UInt32 := 0-(a+1)", "start": [195, 1], "end": [196, 53], "kind": "commanddeclaration"}, {"full_name": "UInt64.ofNat", "code": "@[extern \"lean_uint64_of_nat\"]\ndef UInt64.ofNat (n : @& Nat) : UInt64 := \u27e8Fin.ofNat n\u27e9", "start": [205, 1], "end": [206, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.toUInt64", "code": "abbrev Nat.toUInt64 := UInt64.ofNat", "start": [207, 1], "end": [207, 36], "kind": "commanddeclaration"}, {"full_name": "UInt64.toNat", "code": "@[extern \"lean_uint64_to_nat\"]\ndef UInt64.toNat (n : UInt64) : Nat := n.val.val", "start": [208, 1], "end": [209, 49], "kind": "commanddeclaration"}, {"full_name": "UInt64.add", "code": "@[extern \"lean_uint64_add\"]\ndef UInt64.add (a b : UInt64) : UInt64 := \u27e8a.val + b.val\u27e9", "start": [210, 1], "end": [211, 58], "kind": "commanddeclaration"}, {"full_name": "UInt64.sub", "code": "@[extern \"lean_uint64_sub\"]\ndef UInt64.sub (a b : UInt64) : UInt64 := \u27e8a.val - b.val\u27e9", "start": [212, 1], "end": [213, 58], "kind": "commanddeclaration"}, {"full_name": "UInt64.mul", "code": "@[extern \"lean_uint64_mul\"]\ndef UInt64.mul (a b : UInt64) : UInt64 := \u27e8a.val * b.val\u27e9", "start": [214, 1], "end": [215, 58], "kind": "commanddeclaration"}, {"full_name": "UInt64.div", "code": "@[extern \"lean_uint64_div\"]\ndef UInt64.div (a b : UInt64) : UInt64 := \u27e8a.val / b.val\u27e9", "start": [216, 1], "end": [217, 58], "kind": "commanddeclaration"}, {"full_name": "UInt64.mod", "code": "@[extern \"lean_uint64_mod\"]\ndef UInt64.mod (a b : UInt64) : UInt64 := \u27e8a.val % b.val\u27e9", "start": [218, 1], "end": [219, 58], "kind": "commanddeclaration"}, {"full_name": "UInt64.modn", "code": "@[extern \"lean_uint64_modn\"]\ndef UInt64.modn (a : UInt64) (n : @& Nat) : UInt64 := \u27e8Fin.modn a.val n\u27e9", "start": [220, 1], "end": [221, 73], "kind": "commanddeclaration"}, {"full_name": "UInt64.land", "code": "@[extern \"lean_uint64_land\"]\ndef UInt64.land (a b : UInt64) : UInt64 := \u27e8Fin.land a.val b.val\u27e9", "start": [222, 1], "end": [223, 66], "kind": "commanddeclaration"}, {"full_name": "UInt64.lor", "code": "@[extern \"lean_uint64_lor\"]\ndef UInt64.lor (a b : UInt64) : UInt64 := \u27e8Fin.lor a.val b.val\u27e9", "start": [224, 1], "end": [225, 64], "kind": "commanddeclaration"}, {"full_name": "UInt64.xor", "code": "@[extern \"lean_uint64_xor\"]\ndef UInt64.xor (a b : UInt64) : UInt64 := \u27e8Fin.xor a.val b.val\u27e9", "start": [226, 1], "end": [227, 64], "kind": "commanddeclaration"}, {"full_name": "UInt64.shiftLeft", "code": "@[extern \"lean_uint64_shift_left\"]\ndef UInt64.shiftLeft (a b : UInt64) : UInt64 := \u27e8a.val <<< (modn b 64).val\u27e9", "start": [228, 1], "end": [229, 76], "kind": "commanddeclaration"}, {"full_name": "UInt64.shiftRight", "code": "@[extern \"lean_uint64_shift_right\"]\ndef UInt64.shiftRight (a b : UInt64) : UInt64 := \u27e8a.val >>> (modn b 64).val\u27e9", "start": [230, 1], "end": [231, 77], "kind": "commanddeclaration"}, {"full_name": "UInt64.lt", "code": "def UInt64.lt (a b : UInt64) : Prop := a.val < b.val", "start": [232, 1], "end": [232, 53], "kind": "commanddeclaration"}, {"full_name": "UInt64.le", "code": "def UInt64.le (a b : UInt64) : Prop := a.val \u2264 b.val", "start": [233, 1], "end": [233, 53], "kind": "commanddeclaration"}, {"full_name": "UInt64.toUInt8", "code": "@[extern \"lean_uint64_to_uint8\"]\ndef UInt64.toUInt8 (a : UInt64) : UInt8 := a.toNat.toUInt8", "start": [234, 1], "end": [235, 59], "kind": "commanddeclaration"}, {"full_name": "UInt64.toUInt16", "code": "@[extern \"lean_uint64_to_uint16\"]\ndef UInt64.toUInt16 (a : UInt64) : UInt16 := a.toNat.toUInt16", "start": [236, 1], "end": [237, 62], "kind": "commanddeclaration"}, {"full_name": "UInt64.toUInt32", "code": "@[extern \"lean_uint64_to_uint32\"]\ndef UInt64.toUInt32 (a : UInt64) : UInt32 := a.toNat.toUInt32", "start": [238, 1], "end": [239, 62], "kind": "commanddeclaration"}, {"full_name": "UInt8.toUInt64", "code": "@[extern \"lean_uint8_to_uint64\"]\ndef UInt8.toUInt64 (a : UInt8) : UInt64 := a.toNat.toUInt64", "start": [240, 1], "end": [241, 60], "kind": "commanddeclaration"}, {"full_name": "UInt16.toUInt64", "code": "@[extern \"lean_uint16_to_uint64\"]\ndef UInt16.toUInt64 (a : UInt16) : UInt64 := a.toNat.toUInt64", "start": [242, 1], "end": [243, 62], "kind": "commanddeclaration"}, {"full_name": "UInt32.toUInt64", "code": "@[extern \"lean_uint32_to_uint64\"]\ndef UInt32.toUInt64 (a : UInt32) : UInt64 := a.toNat.toUInt64", "start": [244, 1], "end": [245, 62], "kind": "commanddeclaration"}, {"full_name": "UInt64.complement", "code": "@[extern \"lean_uint64_complement\"]\ndef UInt64.complement (a:UInt64) : UInt64 := 0-(a+1)", "start": [257, 1], "end": [258, 53], "kind": "commanddeclaration"}, {"full_name": "Bool.toUInt64", "code": "@[extern \"lean_bool_to_uint64\"]\ndef Bool.toUInt64 (b : Bool) : UInt64 := if b then 1 else 0", "start": [267, 1], "end": [268, 60], "kind": "commanddeclaration"}, {"full_name": "UInt64.decLt", "code": "@[extern \"lean_uint64_dec_lt\"]\ndef UInt64.decLt (a b : UInt64) : Decidable (a < b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (n < m))", "start": [271, 1], "end": [274, 52], "kind": "commanddeclaration"}, {"full_name": "UInt64.decLe", "code": "@[extern \"lean_uint64_dec_le\"]\ndef UInt64.decLe (a b : UInt64) : Decidable (a \u2264 b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (n <= m))", "start": [277, 1], "end": [280, 53], "kind": "commanddeclaration"}, {"full_name": "usize_size_gt_zero", "code": "theorem usize_size_gt_zero : USize.size > 0", "start": [287, 1], "end": [288, 66], "kind": "commanddeclaration"}, {"full_name": "USize.ofNat", "code": "@[extern \"lean_usize_of_nat\"]\ndef USize.ofNat (n : @& Nat) : USize := \u27e8Fin.ofNat' n usize_size_gt_zero\u27e9", "start": [290, 1], "end": [291, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.toUSize", "code": "abbrev Nat.toUSize := USize.ofNat", "start": [292, 1], "end": [292, 34], "kind": "commanddeclaration"}, {"full_name": "USize.toNat", "code": "@[extern \"lean_usize_to_nat\"]\ndef USize.toNat (n : USize) : Nat := n.val.val", "start": [293, 1], "end": [294, 47], "kind": "commanddeclaration"}, {"full_name": "USize.add", "code": "@[extern \"lean_usize_add\"]\ndef USize.add (a b : USize) : USize := \u27e8a.val + b.val\u27e9", "start": [295, 1], "end": [296, 55], "kind": "commanddeclaration"}, {"full_name": "USize.sub", "code": "@[extern \"lean_usize_sub\"]\ndef USize.sub (a b : USize) : USize := \u27e8a.val - b.val\u27e9", "start": [297, 1], "end": [298, 55], "kind": "commanddeclaration"}, {"full_name": "USize.mul", "code": "@[extern \"lean_usize_mul\"]\ndef USize.mul (a b : USize) : USize := \u27e8a.val * b.val\u27e9", "start": [299, 1], "end": [300, 55], "kind": "commanddeclaration"}, {"full_name": "USize.div", "code": "@[extern \"lean_usize_div\"]\ndef USize.div (a b : USize) : USize := \u27e8a.val / b.val\u27e9", "start": [301, 1], "end": [302, 55], "kind": "commanddeclaration"}, {"full_name": "USize.mod", "code": "@[extern \"lean_usize_mod\"]\ndef USize.mod (a b : USize) : USize := \u27e8a.val % b.val\u27e9", "start": [303, 1], "end": [304, 55], "kind": "commanddeclaration"}, {"full_name": "USize.modn", "code": "@[extern \"lean_usize_modn\"]\ndef USize.modn (a : USize) (n : @& Nat) : USize := \u27e8Fin.modn a.val n\u27e9", "start": [305, 1], "end": [306, 70], "kind": "commanddeclaration"}, {"full_name": "USize.land", "code": "@[extern \"lean_usize_land\"]\ndef USize.land (a b : USize) : USize := \u27e8Fin.land a.val b.val\u27e9", "start": [307, 1], "end": [308, 63], "kind": "commanddeclaration"}, {"full_name": "USize.lor", "code": "@[extern \"lean_usize_lor\"]\ndef USize.lor (a b : USize) : USize := \u27e8Fin.lor a.val b.val\u27e9", "start": [309, 1], "end": [310, 61], "kind": "commanddeclaration"}, {"full_name": "USize.xor", "code": "@[extern \"lean_usize_xor\"]\ndef USize.xor (a b : USize) : USize := \u27e8Fin.xor a.val b.val\u27e9", "start": [311, 1], "end": [312, 61], "kind": "commanddeclaration"}, {"full_name": "USize.shiftLeft", "code": "@[extern \"lean_usize_shift_left\"]\ndef USize.shiftLeft (a b : USize) : USize := \u27e8a.val <<< (modn b System.Platform.numBits).val\u27e9", "start": [313, 1], "end": [314, 94], "kind": "commanddeclaration"}, {"full_name": "USize.shiftRight", "code": "@[extern \"lean_usize_shift_right\"]\ndef USize.shiftRight (a b : USize) : USize := \u27e8a.val >>> (modn b System.Platform.numBits).val\u27e9", "start": [315, 1], "end": [316, 95], "kind": "commanddeclaration"}, {"full_name": "UInt32.toUSize", "code": "@[extern \"lean_uint32_to_usize\"]\ndef UInt32.toUSize (a : UInt32) : USize := a.toNat.toUSize", "start": [317, 1], "end": [318, 59], "kind": "commanddeclaration"}, {"full_name": "USize.toUInt32", "code": "@[extern \"lean_usize_to_uint32\"]\ndef USize.toUInt32 (a : USize) : UInt32 := a.toNat.toUInt32", "start": [319, 1], "end": [320, 60], "kind": "commanddeclaration"}, {"full_name": "USize.lt", "code": "def USize.lt (a b : USize) : Prop := a.val < b.val", "start": [322, 1], "end": [322, 51], "kind": "commanddeclaration"}, {"full_name": "USize.le", "code": "def USize.le (a b : USize) : Prop := a.val \u2264 b.val", "start": [323, 1], "end": [323, 51], "kind": "commanddeclaration"}, {"full_name": "USize.complement", "code": "@[extern \"lean_usize_complement\"]\ndef USize.complement (a:USize) : USize := 0-(a+1)", "start": [335, 1], "end": [336, 50], "kind": "commanddeclaration"}, {"full_name": "USize.decLt", "code": "@[extern \"lean_usize_dec_lt\"]\ndef USize.decLt (a b : USize) : Decidable (a < b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (n < m))", "start": [346, 1], "end": [349, 52], "kind": "commanddeclaration"}, {"full_name": "USize.decLe", "code": "@[extern \"lean_usize_dec_le\"]\ndef USize.decLe (a b : USize) : Decidable (a \u2264 b) :=\n  match a, b with\n  | \u27e8n\u27e9, \u27e8m\u27e9 => inferInstanceAs (Decidable (n <= m))", "start": [352, 1], "end": [355, 53], "kind": "commanddeclaration"}, {"full_name": "USize.modn_lt", "code": "theorem USize.modn_lt {m : Nat} : \u2200 (u : USize), m > 0 \u2192 USize.toNat (u % m) < m", "start": [362, 1], "end": [363, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/Id.lean", "imports": ["lake-packages/lean4/src/lean/Init/Core.lean"], "premises": [{"full_name": "Id", "code": "def Id (type : Type u) : Type u := type", "start": [13, 1], "end": [13, 40], "kind": "commanddeclaration"}, {"full_name": "Id.hasBind", "code": "def hasBind : Bind Id :=\n  inferInstance", "start": [23, 1], "end": [24, 16], "kind": "commanddeclaration"}, {"full_name": "Id.run", "code": "@[always_inline, inline]\nprotected def run (x : Id \u03b1) : \u03b1 := x", "start": [26, 1], "end": [27, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init/SimpLemmas.lean"], "premises": [{"full_name": "List.cons_getElem_zero", "code": "@[simp] theorem cons_getElem_zero (a : \u03b1) (as : List \u03b1) (h : 0 < (a :: as).length) : getElem (a :: as) 0 h = a", "start": [21, 1], "end": [22, 6], "kind": "commanddeclaration"}, {"full_name": "List.cons_getElem_succ", "code": "@[simp] theorem cons_getElem_succ (a : \u03b1) (as : List \u03b1) (i : Nat) (h : i + 1 < (a :: as).length) : getElem (a :: as) (i+1) h = getElem as i (Nat.lt_of_succ_lt_succ h)", "start": [24, 1], "end": [25, 6], "kind": "commanddeclaration"}, {"full_name": "List.length_add_eq_lengthTRAux", "code": "theorem length_add_eq_lengthTRAux (as : List \u03b1) (n : Nat) : as.length + n = as.lengthTRAux n", "start": [27, 1], "end": [32, 8], "kind": "commanddeclaration"}, {"full_name": "List.length_eq_lengthTR", "code": "@[csimp] theorem length_eq_lengthTR : @List.length = @List.lengthTR", "start": [34, 1], "end": [36, 47], "kind": "commanddeclaration"}, {"full_name": "List.length_nil", "code": "@[simp] theorem length_nil : length ([] : List \u03b1) = 0", "start": [38, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "List.reverseAux", "code": "def reverseAux : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | [],   r => r\n  | a::l, r => reverseAux l (a::r)", "start": [41, 1], "end": [44, 35], "kind": "commanddeclaration"}, {"full_name": "List.reverse", "code": "def reverse (as : List \u03b1) : List \u03b1 :=\n  reverseAux as []", "start": [46, 1], "end": [55, 19], "kind": "commanddeclaration"}, {"full_name": "List.reverseAux_reverseAux_nil", "code": "theorem reverseAux_reverseAux_nil (as bs : List \u03b1) : reverseAux (reverseAux as bs) [] = reverseAux bs as", "start": [57, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "List.reverseAux_reverseAux", "code": "theorem reverseAux_reverseAux (as bs cs : List \u03b1) : reverseAux (reverseAux as bs) cs = reverseAux bs (reverseAux (reverseAux as []) cs)", "start": [62, 1], "end": [65, 58], "kind": "commanddeclaration"}, {"full_name": "List.reverse_reverse", "code": "@[simp] theorem reverse_reverse (as : List \u03b1) : as.reverse.reverse = as", "start": [67, 1], "end": [68, 54], "kind": "commanddeclaration"}, {"full_name": "List.append", "code": "protected def append : (xs ys : List \u03b1) \u2192 List \u03b1\n  | [],    bs => bs\n  | a::as, bs => a :: List.append as bs", "start": [70, 1], "end": [76, 40], "kind": "commanddeclaration"}, {"full_name": "List.appendTR", "code": "def appendTR (as bs : List \u03b1) : List \u03b1 :=\n  reverseAux as.reverse bs", "start": [78, 1], "end": [80, 27], "kind": "commanddeclaration"}, {"full_name": "List.append_eq_appendTR", "code": "@[csimp] theorem append_eq_appendTR : @List.append = @appendTR", "start": [82, 1], "end": [88, 62], "kind": "commanddeclaration"}, {"full_name": "List.nil_append", "code": "@[simp] theorem nil_append (as : List \u03b1) : [] ++ as = as", "start": [92, 1], "end": [92, 64], "kind": "commanddeclaration"}, {"full_name": "List.append_nil", "code": "@[simp] theorem append_nil (as : List \u03b1) : as ++ [] = as", "start": [93, 1], "end": [97, 59], "kind": "commanddeclaration"}, {"full_name": "List.cons_append", "code": "@[simp] theorem cons_append (a : \u03b1) (as bs : List \u03b1) : (a::as) ++ bs = a::(as ++ bs)", "start": [99, 1], "end": [99, 92], "kind": "commanddeclaration"}, {"full_name": "List.append_eq", "code": "@[simp] theorem append_eq (as bs : List \u03b1) : List.append as bs = as ++ bs", "start": [101, 1], "end": [101, 81], "kind": "commanddeclaration"}, {"full_name": "List.append_assoc", "code": "theorem append_assoc (as bs cs : List \u03b1) : (as ++ bs) ++ cs = as ++ (bs ++ cs)", "start": [103, 1], "end": [106, 30], "kind": "commanddeclaration"}, {"full_name": "List.append_cons", "code": "theorem append_cons (as : List \u03b1) (b : \u03b1) (bs : List \u03b1) : as ++ b :: bs = as ++ [b] ++ bs", "start": [108, 1], "end": [111, 30], "kind": "commanddeclaration"}, {"full_name": "List.erase", "code": "protected def erase {\u03b1} [BEq \u03b1] : List \u03b1 \u2192 \u03b1 \u2192 List \u03b1\n  | [],    _ => []\n  | a::as, b => match a == b with\n    | true  => as\n    | false => a :: List.erase as b", "start": [115, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "List.eraseIdx", "code": "def eraseIdx : List \u03b1 \u2192 Nat \u2192 List \u03b1\n  | [],    _   => []\n  | _::as, 0   => as\n  | a::as, n+1 => a :: eraseIdx as n", "start": [126, 1], "end": [135, 37], "kind": "commanddeclaration"}, {"full_name": "List.isEmpty", "code": "def isEmpty : List \u03b1 \u2192 Bool\n  | []     => true\n  | _ :: _ => false", "start": [137, 1], "end": [145, 20], "kind": "commanddeclaration"}, {"full_name": "List.map", "code": "@[specialize] def map (f : \u03b1 \u2192 \u03b2) : List \u03b1 \u2192 List \u03b2\n  | []    => []\n  | a::as => f a :: map f as", "start": [147, 1], "end": [153, 29], "kind": "commanddeclaration"}, {"full_name": "List.mapTR", "code": "@[inline] def mapTR (f : \u03b1 \u2192 \u03b2) (as : List \u03b1) : List \u03b2 :=\n  loop as []\nwhere\n  @[specialize] loop : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b2\n  | [],    bs => bs.reverse\n  | a::as, bs => loop as (f a :: bs)", "start": [155, 1], "end": [161, 37], "kind": "commanddeclaration"}, {"full_name": "List.reverseAux_eq_append", "code": "theorem reverseAux_eq_append (as bs : List \u03b1) : reverseAux as bs = reverseAux as [] ++ bs", "start": [163, 1], "end": [169, 8], "kind": "commanddeclaration"}, {"full_name": "List.reverse_nil", "code": "@[simp] theorem reverse_nil : reverse ([] : List \u03b1) = []", "start": [171, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "List.reverse_cons", "code": "@[simp] theorem reverse_cons (a : \u03b1) (as : List \u03b1) : reverse (a :: as) = reverse as ++ [a]", "start": [174, 1], "end": [176, 30], "kind": "commanddeclaration"}, {"full_name": "List.reverse_append", "code": "@[simp] theorem reverse_append (as bs : List \u03b1) : (as ++ bs).reverse = bs.reverse ++ as.reverse", "start": [178, 1], "end": [181, 49], "kind": "commanddeclaration"}, {"full_name": "List.mapTR_loop_eq", "code": "theorem mapTR_loop_eq (f : \u03b1 \u2192 \u03b2) (as : List \u03b1) (bs : List \u03b2) :\n    mapTR.loop f as bs = bs.reverse ++ map f as", "start": [183, 1], "end": [190, 8], "kind": "commanddeclaration"}, {"full_name": "List.map_eq_mapTR", "code": "@[csimp] theorem map_eq_mapTR : @map = @mapTR", "start": [192, 1], "end": [194, 32], "kind": "commanddeclaration"}, {"full_name": "List.join", "code": "def join : List (List \u03b1) \u2192 List \u03b1\n  | []      => []\n  | a :: as => a ++ join as", "start": [196, 1], "end": [202, 28], "kind": "commanddeclaration"}, {"full_name": "List.filterMap", "code": "@[specialize] def filterMap (f : \u03b1 \u2192 Option \u03b2) : List \u03b1 \u2192 List \u03b2\n  | []   => []\n  | a::as =>\n    match f a with\n    | none   => filterMap f as\n    | some b => b :: filterMap f as", "start": [204, 1], "end": [219, 36], "kind": "commanddeclaration"}, {"full_name": "List.filter", "code": "def filter (p : \u03b1 \u2192 Bool) : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | a::as => match p a with\n    | true => a :: filter p as\n    | false => filter p as", "start": [221, 1], "end": [231, 27], "kind": "commanddeclaration"}, {"full_name": "List.filterTR", "code": "@[inline] def filterTR (p : \u03b1 \u2192 Bool) (as : List \u03b1) : List \u03b1 :=\n  loop as []\nwhere\n  @[specialize] loop : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | [],    rs => rs.reverse\n  | a::as, rs => match p a with\n     | true  => loop as (a::rs)\n     | false => loop as rs", "start": [233, 1], "end": [241, 27], "kind": "commanddeclaration"}, {"full_name": "List.filterTR_loop_eq", "code": "theorem filterTR_loop_eq (p : \u03b1 \u2192 Bool) (as bs : List \u03b1) :\n    filterTR.loop p as bs = bs.reverse ++ filter p as", "start": [243, 1], "end": [251, 20], "kind": "commanddeclaration"}, {"full_name": "List.filter_eq_filterTR", "code": "@[csimp] theorem filter_eq_filterTR : @filter = @filterTR", "start": [253, 1], "end": [255, 36], "kind": "commanddeclaration"}, {"full_name": "List.partition", "code": "@[inline] def partition (p : \u03b1 \u2192 Bool) (as : List \u03b1) : List \u03b1 \u00d7 List \u03b1 :=\n  loop as ([], [])\nwhere\n  @[specialize] loop : List \u03b1 \u2192 List \u03b1 \u00d7 List \u03b1 \u2192 List \u03b1 \u00d7 List \u03b1\n  | [],    (bs, cs) => (bs.reverse, cs.reverse)\n  | a::as, (bs, cs) =>\n    match p a with\n    | true  => loop as (a::bs, cs)\n    | false => loop as (bs, a::cs)", "start": [257, 1], "end": [275, 35], "kind": "commanddeclaration"}, {"full_name": "List.dropWhile", "code": "def dropWhile (p : \u03b1 \u2192 Bool) : List \u03b1 \u2192 List \u03b1\n  | []   => []\n  | a::l => match p a with\n    | true  => dropWhile p l\n    | false => a::l", "start": [277, 1], "end": [288, 20], "kind": "commanddeclaration"}, {"full_name": "List.find?", "code": "def find? (p : \u03b1 \u2192 Bool) : List \u03b1 \u2192 Option \u03b1\n  | []    => none\n  | a::as => match p a with\n    | true  => some a\n    | false => find? p as", "start": [290, 1], "end": [301, 26], "kind": "commanddeclaration"}, {"full_name": "List.findSome?", "code": "def findSome? (f : \u03b1 \u2192 Option \u03b2) : List \u03b1 \u2192 Option \u03b2\n  | []    => none\n  | a::as => match f a with\n    | some b => some b\n    | none   => findSome? f as", "start": [303, 1], "end": [312, 31], "kind": "commanddeclaration"}, {"full_name": "List.replace", "code": "def replace [BEq \u03b1] : List \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 List \u03b1\n  | [],    _, _ => []\n  | a::as, b, c => match a == b with\n    | true  => c::as\n    | false => a :: replace as b c", "start": [314, 1], "end": [324, 35], "kind": "commanddeclaration"}, {"full_name": "List.elem", "code": "def elem [BEq \u03b1] (a : \u03b1) : List \u03b1 \u2192 Bool\n  | []    => false\n  | b::bs => match a == b with\n    | true  => true\n    | false => elem a bs", "start": [326, 1], "end": [336, 25], "kind": "commanddeclaration"}, {"full_name": "List.notElem", "code": "def notElem [BEq \u03b1] (a : \u03b1) (as : List \u03b1) : Bool :=\n  !(as.elem a)", "start": [338, 1], "end": [340, 15], "kind": "commanddeclaration"}, {"full_name": "List.contains", "code": "@[inherit_doc elem] abbrev contains [BEq \u03b1] (as : List \u03b1) (a : \u03b1) : Bool :=\n  elem a as", "start": [342, 1], "end": [343, 12], "kind": "commanddeclaration"}, {"full_name": "List.Mem", "code": "inductive Mem (a : \u03b1) : List \u03b1 \u2192 Prop\n  \n  | head (as : List \u03b1) : Mem a (a::as)\n  \n  | tail (b : \u03b1) {as : List \u03b1} : Mem a as \u2192 Mem a (b::as)", "start": [345, 1], "end": [354, 58], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_elem_eq_true", "code": "theorem mem_of_elem_eq_true [DecidableEq \u03b1] {a : \u03b1} {as : List \u03b1} : elem a as = true \u2192 a \u2208 as", "start": [359, 1], "end": [366, 64], "kind": "commanddeclaration"}, {"full_name": "List.elem_eq_true_of_mem", "code": "theorem elem_eq_true_of_mem [DecidableEq \u03b1] {a : \u03b1} {as : List \u03b1} (h : a \u2208 as) : elem a as = true", "start": [368, 1], "end": [371, 55], "kind": "commanddeclaration"}, {"full_name": "List.mem_append_of_mem_left", "code": "theorem mem_append_of_mem_left {a : \u03b1} {as : List \u03b1} (bs : List \u03b1) : a \u2208 as \u2192 a \u2208 as ++ bs", "start": [376, 1], "end": [380, 39], "kind": "commanddeclaration"}, {"full_name": "List.mem_append_of_mem_right", "code": "theorem mem_append_of_mem_right {b : \u03b1} {bs : List \u03b1} (as : List \u03b1) : b \u2208 bs \u2192 b \u2208 as ++ bs", "start": [382, 1], "end": [386, 39], "kind": "commanddeclaration"}, {"full_name": "List.eraseDups", "code": "def eraseDups {\u03b1} [BEq \u03b1] (as : List \u03b1) : List \u03b1 :=\n  loop as []\nwhere\n  loop : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | [],    bs => bs.reverse\n  | a::as, bs => match bs.elem a with\n    | true  => loop as bs\n    | false => loop as (a::bs)", "start": [388, 1], "end": [399, 31], "kind": "commanddeclaration"}, {"full_name": "List.eraseReps", "code": "def eraseReps {\u03b1} [BEq \u03b1] : List \u03b1 \u2192 List \u03b1\n  | []    => []\n  | a::as => loop a as []\nwhere\n  loop {\u03b1} [BEq \u03b1] : \u03b1 \u2192 List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | a, [], rs => (a::rs).reverse\n  | a, a'::as, rs => match a == a' with\n    | true  => loop a as rs\n    | false => loop a' as (a::rs)", "start": [401, 1], "end": [413, 34], "kind": "commanddeclaration"}, {"full_name": "List.span", "code": "@[inline] def span (p : \u03b1 \u2192 Bool) (as : List \u03b1) : List \u03b1 \u00d7 List \u03b1 :=\n  loop as []\nwhere\n  @[specialize] loop : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1 \u00d7 List \u03b1\n  | [],    rs => (rs.reverse, [])\n  | a::as, rs => match p a with\n    | true  => loop as (a::rs)\n    | false => (rs.reverse, a::as)", "start": [415, 1], "end": [430, 35], "kind": "commanddeclaration"}, {"full_name": "List.groupBy", "code": "@[specialize] def groupBy (R : \u03b1 \u2192 \u03b1 \u2192 Bool) : List \u03b1 \u2192 List (List \u03b1)\n  | []    => []\n  | a::as => loop as a [] []\nwhere\n  @[specialize] loop : List \u03b1 \u2192 \u03b1 \u2192 List \u03b1 \u2192 List (List \u03b1) \u2192 List (List \u03b1)\n  | a::as, ag, g, gs => match R ag a with\n    | true  => loop as a (ag::g) gs\n    | false => loop as a [] ((ag::g).reverse::gs)\n  | [], ag, g, gs => ((ag::g).reverse::gs).reverse", "start": [432, 1], "end": [447, 51], "kind": "commanddeclaration"}, {"full_name": "List.lookup", "code": "def lookup [BEq \u03b1] : \u03b1 \u2192 List (\u03b1 \u00d7 \u03b2) \u2192 Option \u03b2\n  | _, []        => none\n  | a, (k,b)::es => match a == k with\n    | true  => some b\n    | false => lookup a es", "start": [449, 1], "end": [460, 27], "kind": "commanddeclaration"}, {"full_name": "List.removeAll", "code": "def removeAll [BEq \u03b1] (xs ys : List \u03b1) : List \u03b1 :=\n  xs.filter (fun x => ys.notElem x)", "start": [462, 1], "end": [467, 36], "kind": "commanddeclaration"}, {"full_name": "List.drop", "code": "def drop : Nat \u2192 List \u03b1 \u2192 List \u03b1\n  | 0,   a     => a\n  | _+1, []    => []\n  | n+1, _::as => drop n as", "start": [469, 1], "end": [478, 28], "kind": "commanddeclaration"}, {"full_name": "List.drop_nil", "code": "@[simp] theorem drop_nil : ([] : List \u03b1).drop i = []", "start": [480, 1], "end": [481, 18], "kind": "commanddeclaration"}, {"full_name": "List.get_drop_eq_drop", "code": "theorem get_drop_eq_drop (as : List \u03b1) (i : Nat) (h : i < as.length) : as[i] :: as.drop (i+1) = as.drop i", "start": [483, 1], "end": [486, 40], "kind": "commanddeclaration"}, {"full_name": "List.take", "code": "def take : Nat \u2192 List \u03b1 \u2192 List \u03b1\n  | 0,   _     => []\n  | _+1, []    => []\n  | n+1, a::as => a :: take n as", "start": [488, 1], "end": [497, 33], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile", "code": "def takeWhile (p : \u03b1 \u2192 Bool) : (xs : List \u03b1) \u2192 List \u03b1\n  | []       => []\n  | hd :: tl => match p hd with\n   | true  => hd :: takeWhile p tl\n   | false => []", "start": [499, 1], "end": [508, 17], "kind": "commanddeclaration"}, {"full_name": "List.foldr", "code": "@[specialize] def foldr (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) : List \u03b1 \u2192 \u03b2\n  | []     => init\n  | a :: l => f a (foldr f init l)", "start": [510, 1], "end": [516, 35], "kind": "commanddeclaration"}, {"full_name": "List.any", "code": "@[inline] def any (l : List \u03b1) (p : \u03b1 \u2192 Bool) : Bool :=\n  foldr (fun a r => p a || r) false l", "start": [518, 1], "end": [523, 38], "kind": "commanddeclaration"}, {"full_name": "List.all", "code": "@[inline] def all (l : List \u03b1) (p : \u03b1 \u2192 Bool) : Bool :=\n  foldr (fun a r => p a && r) true l", "start": [525, 1], "end": [530, 37], "kind": "commanddeclaration"}, {"full_name": "List.or", "code": "def or  (bs : List Bool) : Bool := bs.any id", "start": [532, 1], "end": [536, 45], "kind": "commanddeclaration"}, {"full_name": "List.and", "code": "def and (bs : List Bool) : Bool := bs.all id", "start": [538, 1], "end": [542, 45], "kind": "commanddeclaration"}, {"full_name": "List.zipWith", "code": "@[specialize] def zipWith (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : (xs : List \u03b1) \u2192 (ys : List \u03b2) \u2192 List \u03b3\n  | x::xs, y::ys => f x y :: zipWith f xs ys\n  | _,     _     => []", "start": [544, 1], "end": [550, 23], "kind": "commanddeclaration"}, {"full_name": "List.zip", "code": "def zip : List \u03b1 \u2192 List \u03b2 \u2192 List (Prod \u03b1 \u03b2) :=\n  zipWith Prod.mk", "start": [552, 1], "end": [558, 18], "kind": "commanddeclaration"}, {"full_name": "List.unzip", "code": "def unzip : List (\u03b1 \u00d7 \u03b2) \u2192 List \u03b1 \u00d7 List \u03b2\n  | []          => ([], [])\n  | (a, b) :: t => match unzip t with | (al, bl) => (a::al, b::bl)", "start": [560, 1], "end": [566, 67], "kind": "commanddeclaration"}, {"full_name": "List.range", "code": "def range (n : Nat) : List Nat :=\n  loop n []\nwhere\n  loop : Nat \u2192 List Nat \u2192 List Nat\n  | 0,   ns => ns\n  | n+1, ns => loop n (n::ns)", "start": [568, 1], "end": [577, 30], "kind": "commanddeclaration"}, {"full_name": "List.iota", "code": "def iota : Nat \u2192 List Nat\n  | 0       => []\n  | m@(n+1) => m :: iota n", "start": [579, 1], "end": [585, 27], "kind": "commanddeclaration"}, {"full_name": "List.iotaTR", "code": "def iotaTR (n : Nat) : List Nat :=\n  let rec go : Nat \u2192 List Nat \u2192 List Nat\n    | 0, r => r.reverse\n    | m@(n+1), r => go n (m::r)\n  go n []", "start": [587, 1], "end": [592, 10], "kind": "commanddeclaration"}, {"full_name": "List.iota_eq_iotaTR", "code": "@[csimp]\ntheorem iota_eq_iotaTR : @iota = @iotaTR", "start": [594, 1], "end": [600, 40], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom", "code": "def enumFrom : Nat \u2192 List \u03b1 \u2192 List (Nat \u00d7 \u03b1)\n  | _, [] => nil\n  | n, x :: xs   => (n, x) :: enumFrom (n + 1) xs", "start": [602, 1], "end": [608, 50], "kind": "commanddeclaration"}, {"full_name": "List.enum", "code": "def enum : List \u03b1 \u2192 List (Nat \u00d7 \u03b1) := enumFrom 0", "start": [610, 1], "end": [614, 49], "kind": "commanddeclaration"}, {"full_name": "List.intersperse", "code": "def intersperse (sep : \u03b1) : List \u03b1 \u2192 List \u03b1\n  | []    => []\n  | [x]   => [x]\n  | x::xs => x :: sep :: intersperse sep xs", "start": [616, 1], "end": [626, 44], "kind": "commanddeclaration"}, {"full_name": "List.intercalate", "code": "def intercalate (sep : List \u03b1) (xs : List (List \u03b1)) : List \u03b1 :=\n  join (intersperse sep xs)", "start": [628, 1], "end": [636, 28], "kind": "commanddeclaration"}, {"full_name": "List.bind", "code": "@[inline] protected def bind {\u03b1 : Type u} {\u03b2 : Type v} (a : List \u03b1) (b : \u03b1 \u2192 List \u03b2) : List \u03b2 := join (map b a)", "start": [638, 1], "end": [643, 112], "kind": "commanddeclaration"}, {"full_name": "List.pure", "code": "@[inline] protected def pure {\u03b1 : Type u} (a : \u03b1) : List \u03b1 := [a]", "start": [645, 1], "end": [646, 66], "kind": "commanddeclaration"}, {"full_name": "List.lt", "code": "inductive lt [LT \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Prop where\n  \n  | nil  (b : \u03b1) (bs : List \u03b1) : lt [] (b::bs)\n  \n  | head {a : \u03b1} (as : List \u03b1) {b : \u03b1} (bs : List \u03b1) : a < b \u2192 lt (a::as) (b::bs)\n  \n  | tail {a : \u03b1} {as : List \u03b1} {b : \u03b1} {bs : List \u03b1} : \u00ac a < b \u2192 \u00ac b < a \u2192 lt as bs \u2192 lt (a::as) (b::bs)", "start": [648, 1], "end": [658, 105], "kind": "commanddeclaration"}, {"full_name": "List.hasDecidableLt", "code": "instance hasDecidableLt [LT \u03b1] [h : DecidableRel (\u03b1:=\u03b1) (\u00b7<\u00b7)] : (l\u2081 l\u2082 : List \u03b1) \u2192 Decidable (l\u2081 < l\u2082)\n  | [],    []    => isFalse (fun h => nomatch h)\n  | [],    _::_  => isTrue (List.lt.nil _ _)\n  | _::_, []     => isFalse (fun h => nomatch h)\n  | a::as, b::bs =>\n    match h a b with\n    | isTrue h\u2081  => isTrue (List.lt.head _ _ h\u2081)\n    | isFalse h\u2081 =>\n      match h b a with\n      | isTrue h\u2082  => isFalse (fun h => match h with\n         | List.lt.head _ _ h\u2081' => absurd h\u2081' h\u2081\n         | List.lt.tail _ h\u2082' _ => absurd h\u2082 h\u2082')\n      | isFalse h\u2082 =>\n        match hasDecidableLt as bs with\n        | isTrue h\u2083  => isTrue (List.lt.tail h\u2081 h\u2082 h\u2083)\n        | isFalse h\u2083 => isFalse (fun h => match h with\n           | List.lt.head _ _ h\u2081' => absurd h\u2081' h\u2081\n           | List.lt.tail _ _ h\u2083' => absurd h\u2083' h\u2083)", "start": [662, 1], "end": [679, 52], "kind": "commanddeclaration"}, {"full_name": "List.le", "code": "@[reducible] protected def le [LT \u03b1] (a b : List \u03b1) : Prop := \u00ac b < a", "start": [681, 1], "end": [682, 70], "kind": "commanddeclaration"}, {"full_name": "List.isPrefixOf", "code": "def isPrefixOf [BEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n  | [],    _     => true\n  | _,     []    => false\n  | a::as, b::bs => a == b && isPrefixOf as bs", "start": [689, 1], "end": [694, 47], "kind": "commanddeclaration"}, {"full_name": "List.isPrefixOf?", "code": "def isPrefixOf? [BEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Option (List \u03b1)\n  | [], l\u2082 => some l\u2082\n  | _, [] => none\n  | (x\u2081 :: l\u2081), (x\u2082 :: l\u2082) =>\n    if x\u2081 == x\u2082 then isPrefixOf? l\u2081 l\u2082 else none", "start": [696, 1], "end": [701, 49], "kind": "commanddeclaration"}, {"full_name": "List.isSuffixOf", "code": "def isSuffixOf [BEq \u03b1] (l\u2081 l\u2082 : List \u03b1) : Bool :=\n  isPrefixOf l\u2081.reverse l\u2082.reverse", "start": [703, 1], "end": [706, 35], "kind": "commanddeclaration"}, {"full_name": "List.isSuffixOf?", "code": "def isSuffixOf? [BEq \u03b1] (l\u2081 l\u2082 : List \u03b1) : Option (List \u03b1) :=\n  Option.map List.reverse <| isPrefixOf? l\u2081.reverse l\u2082.reverse", "start": [708, 1], "end": [710, 63], "kind": "commanddeclaration"}, {"full_name": "List.isEqv", "code": "@[specialize] def isEqv : (as bs : List \u03b1) \u2192 (eqv : \u03b1 \u2192 \u03b1 \u2192 Bool) \u2192 Bool\n  | [],    [],    _   => true\n  | a::as, b::bs, eqv => eqv a b && isEqv as bs eqv\n  | _,     _,     _   => false", "start": [712, 1], "end": [719, 31], "kind": "commanddeclaration"}, {"full_name": "List.beq", "code": "protected def beq [BEq \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 Bool\n  | [],    []    => true\n  | a::as, b::bs => a == b && List.beq as bs\n  | _,     _     => false", "start": [721, 1], "end": [728, 26], "kind": "commanddeclaration"}, {"full_name": "List.replicate", "code": "@[simp] def replicate : (n : Nat) \u2192 (a : \u03b1) \u2192 List \u03b1\n  | 0,   _ => []\n  | n+1, a => a :: replicate n a", "start": [732, 1], "end": [738, 33], "kind": "commanddeclaration"}, {"full_name": "List.replicateTR", "code": "def replicateTR {\u03b1 : Type u} (n : Nat) (a : \u03b1) : List \u03b1 :=\n  let rec loop : Nat \u2192 List \u03b1 \u2192 List \u03b1\n    | 0, as => as\n    | n+1, as => loop n (a::as)\n  loop n []", "start": [740, 1], "end": [745, 12], "kind": "commanddeclaration"}, {"full_name": "List.replicateTR_loop_replicate_eq", "code": "theorem replicateTR_loop_replicate_eq (a : \u03b1) (m n : Nat) :\n  replicateTR.loop a n (replicate m a) = replicate (n + m) a", "start": [747, 1], "end": [750, 53], "kind": "commanddeclaration"}, {"full_name": "List.replicate_eq_replicateTR", "code": "@[csimp] theorem replicate_eq_replicateTR : @List.replicate = @List.replicateTR", "start": [752, 1], "end": [754, 51], "kind": "commanddeclaration"}, {"full_name": "List.dropLast", "code": "def dropLast {\u03b1} : List \u03b1 \u2192 List \u03b1\n  | []    => []\n  | [_]   => []\n  | a::as => a :: dropLast as", "start": [756, 1], "end": [765, 30], "kind": "commanddeclaration"}, {"full_name": "List.length_replicate", "code": "@[simp] theorem length_replicate (n : Nat) (a : \u03b1) : (replicate n a).length = n", "start": [767, 1], "end": [768, 27], "kind": "commanddeclaration"}, {"full_name": "List.length_concat", "code": "@[simp] theorem length_concat (as : List \u03b1) (a : \u03b1) : (concat as a).length = as.length + 1", "start": [770, 1], "end": [773, 38], "kind": "commanddeclaration"}, {"full_name": "List.length_set", "code": "@[simp] theorem length_set (as : List \u03b1) (i : Nat) (a : \u03b1) : (as.set i a).length = as.length", "start": [775, 1], "end": [781, 31], "kind": "commanddeclaration"}, {"full_name": "List.length_dropLast_cons", "code": "@[simp] theorem length_dropLast_cons (a : \u03b1) (as : List \u03b1) : (a :: as).dropLast.length = as.length", "start": [783, 1], "end": [788, 23], "kind": "commanddeclaration"}, {"full_name": "List.length_append", "code": "@[simp] theorem length_append (as bs : List \u03b1) : (as ++ bs).length = as.length + bs.length", "start": [790, 1], "end": [793, 44], "kind": "commanddeclaration"}, {"full_name": "List.length_map", "code": "@[simp] theorem length_map (as : List \u03b1) (f : \u03b1 \u2192 \u03b2) : (as.map f).length = as.length", "start": [795, 1], "end": [798, 40], "kind": "commanddeclaration"}, {"full_name": "List.length_reverse", "code": "@[simp] theorem length_reverse (as : List \u03b1) : (as.reverse).length = as.length", "start": [800, 1], "end": [803, 30], "kind": "commanddeclaration"}, {"full_name": "List.maximum?", "code": "def maximum? [Max \u03b1] : List \u03b1 \u2192 Option \u03b1\n  | []    => none\n  | a::as => some <| as.foldl max a", "start": [805, 1], "end": [813, 36], "kind": "commanddeclaration"}, {"full_name": "List.minimum?", "code": "def minimum? [Min \u03b1] : List \u03b1 \u2192 Option \u03b1\n  | []    => none\n  | a::as => some <| as.foldl min a", "start": [815, 1], "end": [823, 36], "kind": "commanddeclaration"}, {"full_name": "List.of_concat_eq_concat", "code": "theorem of_concat_eq_concat {as bs : List \u03b1} {a b : \u03b1} (h : as.concat a = bs.concat b) : as = bs \u2227 a = b", "start": [841, 1], "end": [848, 78], "kind": "commanddeclaration"}, {"full_name": "List.concat_eq_append", "code": "theorem concat_eq_append (as : List \u03b1) (a : \u03b1) : as.concat a = as ++ [a]", "start": [850, 1], "end": [851, 36], "kind": "commanddeclaration"}, {"full_name": "List.drop_eq_nil_of_le", "code": "theorem drop_eq_nil_of_le {as : List \u03b1} {i : Nat} (h : as.length \u2264 i) : as.drop i = []", "start": [853, 1], "end": [857, 86], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Option/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Core.lean", "lake-packages/lean4/src/lean/Init/Coe.lean", "lake-packages/lean4/src/lean/Init/Control/Basic.lean"], "premises": [{"full_name": "Option.toMonad", "code": "def toMonad [Monad m] [Alternative m] : Option \u03b1 \u2192 m \u03b1\n  | none     => failure\n  | some a   => pure a", "start": [13, 1], "end": [15, 23], "kind": "commanddeclaration"}, {"full_name": "Option.toBool", "code": "@[inline] def toBool : Option \u03b1 \u2192 Bool\n  | some _ => true\n  | none   => false", "start": [17, 1], "end": [19, 20], "kind": "commanddeclaration"}, {"full_name": "Option.isSome", "code": "@[inline] def isSome : Option \u03b1 \u2192 Bool\n  | some _ => true\n  | none   => false", "start": [21, 1], "end": [23, 20], "kind": "commanddeclaration"}, {"full_name": "Option.isNone", "code": "@[inline] def isNone : Option \u03b1 \u2192 Bool\n  | some _ => false\n  | none   => true", "start": [25, 1], "end": [27, 19], "kind": "commanddeclaration"}, {"full_name": "Option.isEqSome", "code": "@[inline] def isEqSome [BEq \u03b1] : Option \u03b1 \u2192 \u03b1 \u2192 Bool\n  | some a, b => a == b\n  | none,   _ => false", "start": [29, 1], "end": [31, 23], "kind": "commanddeclaration"}, {"full_name": "Option.bind", "code": "@[inline] protected def bind : Option \u03b1 \u2192 (\u03b1 \u2192 Option \u03b2) \u2192 Option \u03b2\n  | none,   _ => none\n  | some a, b => b a", "start": [33, 1], "end": [35, 21], "kind": "commanddeclaration"}, {"full_name": "Option.mapM", "code": "@[inline] protected def mapM [Monad m] (f : \u03b1 \u2192 m \u03b2) (o : Option \u03b1) : m (Option \u03b2) := do\n  if let some a := o then\n    return some (\u2190 f a)\n  else\n    return none", "start": [37, 1], "end": [41, 16], "kind": "commanddeclaration"}, {"full_name": "Option.map_id", "code": "theorem map_id : (Option.map id : Option \u03b1 \u2192 Option \u03b1) = id", "start": [43, 1], "end": [44, 63], "kind": "commanddeclaration"}, {"full_name": "Option.filter", "code": "@[always_inline, inline] protected def filter (p : \u03b1 \u2192 Bool) : Option \u03b1 \u2192 Option \u03b1\n  | some a => if p a then some a else none\n  | none   => none", "start": [46, 1], "end": [48, 19], "kind": "commanddeclaration"}, {"full_name": "Option.all", "code": "@[always_inline, inline] protected def all (p : \u03b1 \u2192 Bool) : Option \u03b1 \u2192 Bool\n  | some a => p a\n  | none   => true", "start": [50, 1], "end": [52, 19], "kind": "commanddeclaration"}, {"full_name": "Option.any", "code": "@[always_inline, inline] protected def any (p : \u03b1 \u2192 Bool) : Option \u03b1 \u2192 Bool\n  | some a => p a\n  | none   => false", "start": [54, 1], "end": [56, 20], "kind": "commanddeclaration"}, {"full_name": "Option.orElse", "code": "@[always_inline, macro_inline] protected def orElse : Option \u03b1 \u2192 (Unit \u2192 Option \u03b1) \u2192 Option \u03b1\n  | some a, _ => some a\n  | none,   b => b ()", "start": [58, 1], "end": [60, 22], "kind": "commanddeclaration"}, {"full_name": "Option.lt", "code": "@[inline] protected def lt (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Option \u03b1 \u2192 Option \u03b1 \u2192 Prop\n  | none, some _     => True\n  | some x,   some y => r x y\n  | _, _             => False", "start": [65, 1], "end": [68, 30], "kind": "commanddeclaration"}, {"full_name": "Option.merge", "code": "def merge (fn : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Option \u03b1 \u2192 Option \u03b1 \u2192 Option \u03b1\n  | none  , none   => none\n  | some x, none   => some x\n  | none  , some y => some y\n  | some x, some y => some <| fn x y", "start": [76, 1], "end": [82, 37], "kind": "commanddeclaration"}, {"full_name": "liftOption", "code": "def liftOption [Alternative m] : Option \u03b1 \u2192 m \u03b1\n  | some a => pure a\n  | none   => failure", "start": [106, 1], "end": [108, 22], "kind": "commanddeclaration"}, {"full_name": "Option.tryCatch", "code": "@[always_inline, inline] protected def Option.tryCatch (x : Option \u03b1) (handle : Unit \u2192 Option \u03b1) : Option \u03b1 :=\n  match x with\n  | some _ => x\n  | none => handle ()", "start": [110, 1], "end": [113, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Char/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/UInt/Basic.lean"], "premises": [{"full_name": "isValidChar", "code": "@[inline, reducible] def isValidChar (n : UInt32) : Prop :=\n  n < 0xd800 \u2228 (0xdfff < n \u2227 n < 0x110000)", "start": [9, 1], "end": [14, 43], "kind": "commanddeclaration"}, {"full_name": "Char.lt", "code": "protected def lt (a b : Char) : Prop := a.val < b.val", "start": [18, 1], "end": [18, 54], "kind": "commanddeclaration"}, {"full_name": "Char.le", "code": "protected def le (a b : Char) : Prop := a.val \u2264 b.val", "start": [19, 1], "end": [19, 54], "kind": "commanddeclaration"}, {"full_name": "Char.isValidCharNat", "code": "abbrev isValidCharNat (n : Nat) : Prop :=\n  n < 0xd800 \u2228 (0xdfff < n \u2227 n < 0x110000)", "start": [30, 1], "end": [32, 43], "kind": "commanddeclaration"}, {"full_name": "Char.isValidUInt32", "code": "theorem isValidUInt32 (n : Nat) (h : isValidCharNat n) : n < UInt32.size", "start": [34, 1], "end": [41, 11], "kind": "commanddeclaration"}, {"full_name": "Char.isValidChar_of_isValidChar_Nat", "code": "theorem isValidChar_of_isValidChar_Nat (n : Nat) (h : isValidCharNat n) : isValidChar (UInt32.ofNat' n (isValidUInt32 n h))", "start": [43, 1], "end": [46, 39], "kind": "commanddeclaration"}, {"full_name": "Char.isValidChar_zero", "code": "theorem isValidChar_zero : isValidChar 0", "start": [48, 1], "end": [49, 21], "kind": "commanddeclaration"}, {"full_name": "Char.toNat", "code": "@[inline] def toNat (c : Char) : Nat :=\n  c.val.toNat", "start": [51, 1], "end": [53, 14], "kind": "commanddeclaration"}, {"full_name": "Char.isWhitespace", "code": "def isWhitespace (c : Char) : Bool :=\n  c = ' ' || c = '\\t' || c = '\\r' || c = '\\n'", "start": [58, 1], "end": [60, 46], "kind": "commanddeclaration"}, {"full_name": "Char.isUpper", "code": "def isUpper (c : Char) : Bool :=\n  c.val \u2265 65 && c.val \u2264 90", "start": [62, 1], "end": [64, 27], "kind": "commanddeclaration"}, {"full_name": "Char.isLower", "code": "def isLower (c : Char) : Bool :=\n  c.val \u2265 97 && c.val \u2264 122", "start": [66, 1], "end": [68, 28], "kind": "commanddeclaration"}, {"full_name": "Char.isAlpha", "code": "def isAlpha (c : Char) : Bool :=\n  c.isUpper || c.isLower", "start": [70, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "Char.isDigit", "code": "def isDigit (c : Char) : Bool :=\n  c.val \u2265 48 && c.val \u2264 57", "start": [74, 1], "end": [76, 27], "kind": "commanddeclaration"}, {"full_name": "Char.isAlphanum", "code": "def isAlphanum (c : Char) : Bool :=\n  c.isAlpha || c.isDigit", "start": [78, 1], "end": [80, 25], "kind": "commanddeclaration"}, {"full_name": "Char.toLower", "code": "def toLower (c : Char) : Char :=\n  let n := toNat c;\n  if n >= 65 \u2227 n <= 90 then ofNat (n + 32) else c", "start": [82, 1], "end": [88, 50], "kind": "commanddeclaration"}, {"full_name": "Char.toUpper", "code": "def toUpper (c : Char) : Char :=\n  let n := toNat c;\n  if n >= 97 \u2227 n <= 122 then ofNat (n - 32) else c", "start": [90, 1], "end": [96, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/Except.lean", "imports": ["lake-packages/lean4/src/lean/Init/Coe.lean", "lake-packages/lean4/src/lean/Init/Control/Id.lean", "lake-packages/lean4/src/lean/Init/Control/Basic.lean"], "premises": [{"full_name": "Except.pure", "code": "@[always_inline, inline]\nprotected def pure (a : \u03b1) : Except \u03b5 \u03b1 :=\n  Except.ok a", "start": [16, 1], "end": [18, 14], "kind": "commanddeclaration"}, {"full_name": "Except.map", "code": "@[always_inline, inline]\nprotected def map (f : \u03b1 \u2192 \u03b2) : Except \u03b5 \u03b1 \u2192 Except \u03b5 \u03b2\n  | Except.error err => Except.error err\n  | Except.ok v => Except.ok <| f v", "start": [20, 1], "end": [23, 36], "kind": "commanddeclaration"}, {"full_name": "Except.map_id", "code": "@[simp] theorem map_id : Except.map (\u03b5 := \u03b5) (\u03b1 := \u03b1) (\u03b2 := \u03b1) id = id", "start": [25, 1], "end": [28, 37], "kind": "commanddeclaration"}, {"full_name": "Except.mapError", "code": "@[always_inline, inline]\nprotected def mapError (f : \u03b5 \u2192 \u03b5') : Except \u03b5 \u03b1 \u2192 Except \u03b5' \u03b1\n  | Except.error err => Except.error <| f err\n  | Except.ok v      => Except.ok v", "start": [30, 1], "end": [33, 36], "kind": "commanddeclaration"}, {"full_name": "Except.bind", "code": "@[always_inline, inline]\nprotected def bind (ma : Except \u03b5 \u03b1) (f : \u03b1 \u2192 Except \u03b5 \u03b2) : Except \u03b5 \u03b2 :=\n  match ma with\n  | Except.error err => Except.error err\n  | Except.ok v      => f v", "start": [35, 1], "end": [39, 28], "kind": "commanddeclaration"}, {"full_name": "Except.toBool", "code": "@[always_inline, inline]\nprotected def toBool : Except \u03b5 \u03b1 \u2192 Bool\n  | Except.ok _    => true\n  | Except.error _ => false", "start": [41, 1], "end": [45, 28], "kind": "commanddeclaration"}, {"full_name": "Except.isOk", "code": "abbrev isOk : Except \u03b5 \u03b1 \u2192 Bool := Except.toBool", "start": [47, 1], "end": [47, 49], "kind": "commanddeclaration"}, {"full_name": "Except.toOption", "code": "@[always_inline, inline]\nprotected def toOption : Except \u03b5 \u03b1 \u2192 Option \u03b1\n  | Except.ok a    => some a\n  | Except.error _ => none", "start": [49, 1], "end": [52, 27], "kind": "commanddeclaration"}, {"full_name": "Except.tryCatch", "code": "@[always_inline, inline]\nprotected def tryCatch (ma : Except \u03b5 \u03b1) (handle : \u03b5 \u2192 Except \u03b5 \u03b1) : Except \u03b5 \u03b1 :=\n  match ma with\n  | Except.ok a    => Except.ok a\n  | Except.error e => handle e", "start": [54, 1], "end": [58, 31], "kind": "commanddeclaration"}, {"full_name": "Except.orElseLazy", "code": "def orElseLazy (x : Except \u03b5 \u03b1) (y : Unit \u2192 Except \u03b5 \u03b1) : Except \u03b5 \u03b1 :=\n  match x with\n  | Except.ok a    => Except.ok a\n  | Except.error _ => y ()", "start": [60, 1], "end": [63, 27], "kind": "commanddeclaration"}, {"full_name": "ExceptT", "code": "def ExceptT (\u03b5 : Type u) (m : Type u \u2192 Type v) (\u03b1 : Type u) : Type v :=\n  m (Except \u03b5 \u03b1)", "start": [73, 1], "end": [74, 17], "kind": "commanddeclaration"}, {"full_name": "ExceptT.mk", "code": "@[always_inline, inline]\ndef ExceptT.mk {\u03b5 : Type u} {m : Type u \u2192 Type v} {\u03b1 : Type u} (x : m (Except \u03b5 \u03b1)) : ExceptT \u03b5 m \u03b1 := x", "start": [76, 1], "end": [77, 105], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run", "code": "@[always_inline, inline]\ndef ExceptT.run {\u03b5 : Type u} {m : Type u \u2192 Type v} {\u03b1 : Type u} (x : ExceptT \u03b5 m \u03b1) : m (Except \u03b5 \u03b1) := x", "start": [79, 1], "end": [80, 106], "kind": "commanddeclaration"}, {"full_name": "ExceptT.pure", "code": "@[always_inline, inline]\nprotected def pure {\u03b1 : Type u} (a : \u03b1) : ExceptT \u03b5 m \u03b1 :=\n  ExceptT.mk <| pure (Except.ok a)", "start": [86, 1], "end": [88, 35], "kind": "commanddeclaration"}, {"full_name": "ExceptT.bindCont", "code": "@[always_inline, inline]\nprotected def bindCont {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 ExceptT \u03b5 m \u03b2) : Except \u03b5 \u03b1 \u2192 m (Except \u03b5 \u03b2)\n  | Except.ok a    => f a\n  | Except.error e => pure (Except.error e)", "start": [90, 1], "end": [93, 44], "kind": "commanddeclaration"}, {"full_name": "ExceptT.bind", "code": "@[always_inline, inline]\nprotected def bind {\u03b1 \u03b2 : Type u} (ma : ExceptT \u03b5 m \u03b1) (f : \u03b1 \u2192 ExceptT \u03b5 m \u03b2) : ExceptT \u03b5 m \u03b2 :=\n  ExceptT.mk <| ma >>= ExceptT.bindCont f", "start": [95, 1], "end": [97, 42], "kind": "commanddeclaration"}, {"full_name": "ExceptT.map", "code": "@[always_inline, inline]\nprotected def map {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (x : ExceptT \u03b5 m \u03b1) : ExceptT \u03b5 m \u03b2 :=\n  ExceptT.mk <| x >>= fun a => match a with\n    | (Except.ok a)    => pure <| Except.ok (f a)\n    | (Except.error e) => pure <| Except.error e", "start": [99, 1], "end": [103, 49], "kind": "commanddeclaration"}, {"full_name": "ExceptT.lift", "code": "@[always_inline, inline]\nprotected def lift {\u03b1 : Type u} (t : m \u03b1) : ExceptT \u03b5 m \u03b1 :=\n  ExceptT.mk <| Except.ok <$> t", "start": [105, 1], "end": [107, 32], "kind": "commanddeclaration"}, {"full_name": "ExceptT.tryCatch", "code": "@[always_inline, inline]\nprotected def tryCatch {\u03b1 : Type u} (ma : ExceptT \u03b5 m \u03b1) (handle : \u03b5 \u2192 ExceptT \u03b5 m \u03b1) : ExceptT \u03b5 m \u03b1 :=\n  ExceptT.mk <| ma >>= fun res => match res with\n   | Except.ok a    => pure (Except.ok a)\n   | Except.error e => (handle e)", "start": [113, 1], "end": [117, 34], "kind": "commanddeclaration"}, {"full_name": "ExceptT.adapt", "code": "@[always_inline, inline]\nprotected def adapt {\u03b5' \u03b1 : Type u} (f : \u03b5 \u2192 \u03b5') : ExceptT \u03b5 m \u03b1 \u2192 ExceptT \u03b5' m \u03b1 := fun x =>\n  ExceptT.mk <| Except.mapError f <$> x", "start": [127, 1], "end": [129, 40], "kind": "commanddeclaration"}, {"full_name": "MonadExcept.orelse'", "code": "@[always_inline, inline]\ndef orelse' [MonadExcept \u03b5 m] {\u03b1 : Type v} (t\u2081 t\u2082 : m \u03b1) (useFirstEx := true) : m \u03b1 :=\n  tryCatch t\u2081 fun e\u2081 => tryCatch t\u2082 fun e\u2082 => throw (if useFirstEx then e\u2081 else e\u2082)", "start": [153, 1], "end": [157, 84], "kind": "commanddeclaration"}, {"full_name": "observing", "code": "@[always_inline, inline]\ndef observing {\u03b5 \u03b1 : Type u} {m : Type u \u2192 Type v} [Monad m] [MonadExcept \u03b5 m] (x : m \u03b1) : m (Except \u03b5 \u03b1) :=\n  tryCatch (do let a \u2190 x; pure (Except.ok a)) (fun ex => pure (Except.error ex))", "start": [161, 1], "end": [163, 81], "kind": "commanddeclaration"}, {"full_name": "liftExcept", "code": "def liftExcept [MonadExceptOf \u03b5 m] [Pure m] : Except \u03b5 \u03b1 \u2192 m \u03b1\n  | Except.ok a    => pure a\n  | Except.error e => throw e", "start": [165, 1], "end": [167, 30], "kind": "commanddeclaration"}, {"full_name": "MonadFinally", "code": "class MonadFinally (m : Type u \u2192 Type v) where\n  \n  tryFinally' {\u03b1 \u03b2} : m \u03b1 \u2192 (Option \u03b1 \u2192 m \u03b2) \u2192 m (\u03b1 \u00d7 \u03b2)", "start": [174, 1], "end": [180, 57], "kind": "commanddeclaration"}, {"full_name": "tryFinally", "code": "@[always_inline, inline]\ndef tryFinally {m : Type u \u2192 Type v} {\u03b1 \u03b2 : Type u} [MonadFinally m] [Functor m] (x : m \u03b1) (finalizer : m \u03b2) : m \u03b1 :=\n  let y := tryFinally' x (fun _ => finalizer)\n  (\u00b7.1) <$> y", "start": [184, 1], "end": [188, 14], "kind": "commanddeclaration"}, {"full_name": "Id.finally", "code": "@[always_inline]\ninstance Id.finally : MonadFinally Id where\n  tryFinally' := fun x h =>\n   let a := x\n   let b := h (some x)\n   pure (a, b)", "start": [190, 1], "end": [195, 15], "kind": "commanddeclaration"}, {"full_name": "ExceptT.finally", "code": "@[always_inline]\ninstance ExceptT.finally {m : Type u \u2192 Type v} {\u03b5 : Type u} [MonadFinally m] [Monad m] : MonadFinally (ExceptT \u03b5 m) where\n  tryFinally' := fun x h => ExceptT.mk do\n    let r \u2190 tryFinally' x fun e? => match e? with\n        | some (.ok a) => h (some a)\n        | _            => h none\n    match r with\n    | (.ok a,    .ok b)    => pure (.ok (a, b))\n    | (_,        .error e) => pure (.error e)  | (.error e, _)        => pure (.error e)", "start": [197, 1], "end": [206, 46], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init/Coe.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean"], "premises": [{"full_name": "Int", "code": "inductive Int : Type where\n  \n  | ofNat   : Nat \u2192 Int\n  \n  | negSucc : Nat \u2192 Int", "start": [26, 1], "end": [45, 24], "kind": "commanddeclaration"}, {"full_name": "Int.negOfNat", "code": "def negOfNat : Nat \u2192 Int\n  | 0      => 0\n  | succ m => negSucc m", "start": [58, 1], "end": [61, 24], "kind": "commanddeclaration"}, {"full_name": "Int.neg", "code": "@[extern \"lean_int_neg\"]\nprotected def neg (n : @& Int) : Int :=\n  match n with\n  | ofNat n   => negOfNat n\n  | negSucc n => succ n", "start": [64, 1], "end": [71, 24], "kind": "commanddeclaration"}, {"full_name": "Int.subNatNat", "code": "def subNatNat (m n : Nat) : Int :=\n  match (n - m : Nat) with\n  | 0        => ofNat (m - n)  | (succ k) => negSucc k", "start": [85, 1], "end": [89, 26], "kind": "commanddeclaration"}, {"full_name": "Int.add", "code": "@[extern \"lean_int_add\"]\nprotected def add (m n : @& Int) : Int :=\n  match m, n with\n  | ofNat m,   ofNat n   => ofNat (m + n)\n  | ofNat m,   negSucc n => subNatNat m (succ n)\n  | negSucc m, ofNat n   => subNatNat n (succ m)\n  | negSucc m, negSucc n => negSucc (succ (m + n))", "start": [92, 1], "end": [106, 51], "kind": "commanddeclaration"}, {"full_name": "Int.mul", "code": "@[extern \"lean_int_mul\"]\nprotected def mul (m n : @& Int) : Int :=\n  match m, n with\n  | ofNat m,   ofNat n   => ofNat (m * n)\n  | ofNat m,   negSucc n => negOfNat (m * succ n)\n  | negSucc m, ofNat n   => negOfNat (succ m * n)\n  | negSucc m, negSucc n => ofNat (succ m * succ n)", "start": [112, 1], "end": [127, 52], "kind": "commanddeclaration"}, {"full_name": "Int.sub", "code": "@[extern \"lean_int_sub\"]\nprotected def sub (m n : @& Int) : Int :=\n  m + (- n)", "start": [132, 1], "end": [143, 12], "kind": "commanddeclaration"}, {"full_name": "Int.NonNeg", "code": "inductive NonNeg : Int \u2192 Prop where\n  \n  | mk (n : Nat) : NonNeg (ofNat n)", "start": [148, 1], "end": [151, 36], "kind": "commanddeclaration"}, {"full_name": "Int.le", "code": "protected def le (a b : Int) : Prop := NonNeg (b - a)", "start": [153, 1], "end": [154, 54], "kind": "commanddeclaration"}, {"full_name": "Int.lt", "code": "protected def lt (a b : Int) : Prop := (a + 1) \u2264 b", "start": [159, 1], "end": [160, 51], "kind": "commanddeclaration"}, {"full_name": "Int.decEq", "code": "@[extern \"lean_int_dec_eq\"]\nprotected def decEq (a b : @& Int) : Decidable (a = b) :=\n  match a, b with\n  | ofNat a, ofNat b => match decEq a b with\n    | isTrue h  => isTrue  <| h \u25b8 rfl\n    | isFalse h => isFalse <| fun h' => Int.noConfusion h' (fun h' => absurd h' h)\n  | negSucc a, negSucc b => match decEq a b with\n    | isTrue h  => isTrue  <| h \u25b8 rfl\n    | isFalse h => isFalse <| fun h' => Int.noConfusion h' (fun h' => absurd h' h)\n  | ofNat _, negSucc _ => isFalse <| fun h => Int.noConfusion h\n  | negSucc _, ofNat _ => isFalse <| fun h => Int.noConfusion h", "start": [166, 1], "end": [185, 64], "kind": "commanddeclaration"}, {"full_name": "Int.decNonneg", "code": "@[extern \"lean_int_dec_nonneg\"]\nprivate def decNonneg (m : @& Int) : Decidable (NonNeg m) :=\n  match m with\n  | ofNat m   => isTrue <| NonNeg.mk m\n  | negSucc _ => isFalse <| fun h => nomatch h", "start": [190, 1], "end": [203, 47], "kind": "commanddeclaration"}, {"full_name": "Int.decLe", "code": "@[extern \"lean_int_dec_le\"]\ninstance decLe (a b : @& Int) : Decidable (a \u2264 b) :=\n  decNonneg _", "start": [205, 1], "end": [216, 14], "kind": "commanddeclaration"}, {"full_name": "Int.decLt", "code": "@[extern \"lean_int_dec_lt\"]\ninstance decLt (a b : @& Int) : Decidable (a < b) :=\n  decNonneg _", "start": [218, 1], "end": [229, 14], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs", "code": "@[extern \"lean_nat_abs\"]\ndef natAbs (m : @& Int) : Nat :=\n  match m with\n  | ofNat m   => m\n  | negSucc m => m.succ", "start": [232, 1], "end": [245, 24], "kind": "commanddeclaration"}, {"full_name": "Int.div", "code": "@[extern \"lean_int_div\"]\ndef div : (@& Int) \u2192 (@& Int) \u2192 Int\n  | ofNat m,   ofNat n   => ofNat (m / n)\n  | ofNat m,   negSucc n => -ofNat (m / succ n)\n  | negSucc m, ofNat n   => -ofNat (succ m / n)\n  | negSucc m, negSucc n => ofNat (succ m / succ n)", "start": [247, 1], "end": [282, 52], "kind": "commanddeclaration"}, {"full_name": "Int.mod", "code": "@[extern \"lean_int_mod\"]\ndef mod : (@& Int) \u2192 (@& Int) \u2192 Int\n  | ofNat m,   ofNat n   => ofNat (m % n)\n  | ofNat m,   negSucc n => ofNat (m % succ n)\n  | negSucc m, ofNat n   => -ofNat (succ m % n)\n  | negSucc m, negSucc n => -ofNat (succ m % succ n)", "start": [287, 1], "end": [319, 53], "kind": "commanddeclaration"}, {"full_name": "Int.toNat", "code": "def toNat : Int \u2192 Nat\n  | ofNat n   => n\n  | negSucc _ => 0", "start": [324, 1], "end": [335, 19], "kind": "commanddeclaration"}, {"full_name": "Int.pow", "code": "protected def pow (m : Int) : Nat \u2192 Int\n  | 0      => 1\n  | succ n => Int.pow m n * m", "start": [337, 1], "end": [348, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Char/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Option/Basic.lean"], "premises": [{"full_name": "List.asString", "code": "def List.asString (s : List Char) : String :=\n  \u27e8s\u27e9", "start": [12, 1], "end": [13, 6], "kind": "commanddeclaration"}, {"full_name": "String.decLt", "code": "@[extern \"lean_string_dec_lt\"]\ninstance decLt (s\u2081 s\u2082 : @& String) : Decidable (s\u2081 < s\u2082) :=\n  List.hasDecidableLt s\u2081.data s\u2082.data", "start": [23, 1], "end": [25, 38], "kind": "commanddeclaration"}, {"full_name": "String.length", "code": "@[extern \"lean_string_length\"]\ndef length : (@& String) \u2192 Nat\n  | \u27e8s\u27e9 => s.length", "start": [27, 1], "end": [29, 20], "kind": "commanddeclaration"}, {"full_name": "String.push", "code": "@[extern \"lean_string_push\"]\ndef push : String \u2192 Char \u2192 String\n  | \u27e8s\u27e9, c => \u27e8s ++ [c]\u27e9", "start": [31, 1], "end": [35, 25], "kind": "commanddeclaration"}, {"full_name": "String.append", "code": "@[extern \"lean_string_append\"]\ndef append : String \u2192 (@& String) \u2192 String\n  | \u27e8a\u27e9, \u27e8b\u27e9 => \u27e8a ++ b\u27e9", "start": [37, 1], "end": [41, 25], "kind": "commanddeclaration"}, {"full_name": "String.toList", "code": "def toList (s : String) : List Char :=\n  s.data", "start": [43, 1], "end": [45, 9], "kind": "commanddeclaration"}, {"full_name": "String.utf8GetAux", "code": "def utf8GetAux : List Char \u2192 Pos \u2192 Pos \u2192 Char\n  | [],    _, _ => default\n  | c::cs, i, p => if i = p then c else utf8GetAux cs (i + c) p", "start": [47, 1], "end": [49, 64], "kind": "commanddeclaration"}, {"full_name": "String.get", "code": "@[extern \"lean_string_utf8_get\"]\ndef get (s : @& String) (p : @& Pos) : Char :=\n  match s with\n  | \u27e8s\u27e9 => utf8GetAux s 0 p", "start": [51, 1], "end": [59, 28], "kind": "commanddeclaration"}, {"full_name": "String.utf8GetAux?", "code": "def utf8GetAux? : List Char \u2192 Pos \u2192 Pos \u2192 Option Char\n  | [],    _, _ => none\n  | c::cs, i, p => if i = p then c else utf8GetAux? cs (i + c) p", "start": [61, 1], "end": [63, 65], "kind": "commanddeclaration"}, {"full_name": "String.get?", "code": "@[extern \"lean_string_utf8_get_opt\"]\ndef get? : (@& String) \u2192 (@& Pos) \u2192 Option Char\n  | \u27e8s\u27e9, p => utf8GetAux? s 0 p", "start": [65, 1], "end": [67, 32], "kind": "commanddeclaration"}, {"full_name": "String.get!", "code": "@[extern \"lean_string_utf8_get_bang\"]\ndef get! (s : @& String) (p : @& Pos) : Char :=\n  match s with\n  | \u27e8s\u27e9 => utf8GetAux s 0 p", "start": [69, 1], "end": [75, 28], "kind": "commanddeclaration"}, {"full_name": "String.utf8SetAux", "code": "def utf8SetAux (c' : Char) : List Char \u2192 Pos \u2192 Pos \u2192 List Char\n  | [],    _, _ => []\n  | c::cs, i, p =>\n    if i = p then (c'::cs) else c::(utf8SetAux c' cs (i + c) p)", "start": [77, 1], "end": [80, 64], "kind": "commanddeclaration"}, {"full_name": "String.set", "code": "@[extern \"lean_string_utf8_set\"]\ndef set : String \u2192 (@& Pos) \u2192 Char \u2192 String\n  | \u27e8s\u27e9, i, c => \u27e8utf8SetAux c s 0 i\u27e9", "start": [82, 1], "end": [84, 38], "kind": "commanddeclaration"}, {"full_name": "String.modify", "code": "def modify (s : String) (i : Pos) (f : Char \u2192 Char) : String :=\n  s.set i <| f <| s.get i", "start": [86, 1], "end": [87, 26], "kind": "commanddeclaration"}, {"full_name": "String.next", "code": "@[extern \"lean_string_utf8_next\"]\ndef next (s : @& String) (p : @& Pos) : Pos :=\n  let c := get s p\n  p + c", "start": [89, 1], "end": [92, 8], "kind": "commanddeclaration"}, {"full_name": "String.utf8PrevAux", "code": "def utf8PrevAux : List Char \u2192 Pos \u2192 Pos \u2192 Pos\n  | [],    _, _ => 0\n  | c::cs, i, p =>\n    let i' := i + c\n    if i' = p then i else utf8PrevAux cs i' p", "start": [94, 1], "end": [98, 46], "kind": "commanddeclaration"}, {"full_name": "String.prev", "code": "@[extern \"lean_string_utf8_prev\"]\ndef prev : (@& String) \u2192 (@& Pos) \u2192 Pos\n  | \u27e8s\u27e9, p => if p = 0 then 0 else utf8PrevAux s 0 p", "start": [100, 1], "end": [102, 53], "kind": "commanddeclaration"}, {"full_name": "String.front", "code": "def front (s : String) : Char :=\n  get s 0", "start": [104, 1], "end": [105, 10], "kind": "commanddeclaration"}, {"full_name": "String.back", "code": "def back (s : String) : Char :=\n  get s (prev s s.endPos)", "start": [107, 1], "end": [108, 26], "kind": "commanddeclaration"}, {"full_name": "String.atEnd", "code": "@[extern \"lean_string_utf8_at_end\"]\ndef atEnd : (@& String) \u2192 (@& Pos) \u2192 Bool\n  | s, p => p.byteIdx \u2265 utf8ByteSize s", "start": [110, 1], "end": [112, 39], "kind": "commanddeclaration"}, {"full_name": "String.get'", "code": "@[extern \"lean_string_utf8_get_fast\"]\ndef get' (s : @& String) (p : @& Pos) (h : \u00ac s.atEnd p) : Char :=\n  match s with\n  | \u27e8s\u27e9 => utf8GetAux s 0 p", "start": [114, 1], "end": [120, 28], "kind": "commanddeclaration"}, {"full_name": "String.next'", "code": "@[extern \"lean_string_utf8_next_fast\"]\ndef next' (s : @& String) (p : @& Pos) (h : \u00ac s.atEnd p) : Pos :=\n  let c := get s p\n  p + c", "start": [122, 1], "end": [128, 8], "kind": "commanddeclaration"}, {"full_name": "String.one_le_csize", "code": "theorem one_le_csize (c : Char) : 1 \u2264 csize c", "start": [130, 1], "end": [131, 89], "kind": "commanddeclaration"}, {"full_name": "String.pos_lt_eq", "code": "@[simp] theorem pos_lt_eq (p\u2081 p\u2082 : Pos) : (p\u2081 < p\u2082) = (p\u2081.1 < p\u2082.1)", "start": [133, 1], "end": [133, 75], "kind": "commanddeclaration"}, {"full_name": "String.pos_add_char", "code": "@[simp] theorem pos_add_char (p : Pos) (c : Char) : (p + c).byteIdx = p.byteIdx + csize c", "start": [135, 1], "end": [135, 97], "kind": "commanddeclaration"}, {"full_name": "String.lt_next", "code": "theorem lt_next (s : String) (i : Pos) : i.1 < (s.next i).1", "start": [137, 1], "end": [138, 41], "kind": "commanddeclaration"}, {"full_name": "String.utf8PrevAux_lt_of_pos", "code": "theorem utf8PrevAux_lt_of_pos : \u2200 (cs : List Char) (i p : Pos), p \u2260 0 \u2192\n    (utf8PrevAux cs i p).1 < p.1", "start": [140, 1], "end": [149, 48], "kind": "commanddeclaration"}, {"full_name": "String.prev_lt_of_pos", "code": "theorem prev_lt_of_pos (s : String) (i : Pos) (h : i \u2260 0) : (s.prev i).1 < i.1", "start": [151, 1], "end": [153, 38], "kind": "commanddeclaration"}, {"full_name": "String.posOfAux", "code": "def posOfAux (s : String) (c : Char) (stopPos : Pos) (pos : Pos) : Pos :=\n  if h : pos < stopPos then\n    if s.get pos == c then pos\n    else\n      have := Nat.sub_lt_sub_left h (lt_next s pos)\n      posOfAux s c stopPos (s.next pos)\n  else pos\ntermination_by _ => stopPos.1 - pos.1", "start": [155, 1], "end": [162, 38], "kind": "commanddeclaration"}, {"full_name": "String.posOf", "code": "@[inline] def posOf (s : String) (c : Char) : Pos :=\n  posOfAux s c s.endPos 0", "start": [164, 1], "end": [165, 26], "kind": "commanddeclaration"}, {"full_name": "String.revPosOfAux", "code": "def revPosOfAux (s : String) (c : Char) (pos : Pos) : Option Pos :=\n  if h : pos = 0 then none\n  else\n    have := prev_lt_of_pos s pos h\n    let pos := s.prev pos\n    if s.get pos == c then some pos\n    else revPosOfAux s c pos\ntermination_by _ => pos.1", "start": [167, 1], "end": [174, 26], "kind": "commanddeclaration"}, {"full_name": "String.revPosOf", "code": "def revPosOf (s : String) (c : Char) : Option Pos :=\n  revPosOfAux s c s.endPos", "start": [176, 1], "end": [177, 27], "kind": "commanddeclaration"}, {"full_name": "String.findAux", "code": "def findAux (s : String) (p : Char \u2192 Bool) (stopPos : Pos) (pos : Pos) : Pos :=\n  if h : pos < stopPos then\n    if p (s.get pos) then pos\n    else\n      have := Nat.sub_lt_sub_left h (lt_next s pos)\n      findAux s p stopPos (s.next pos)\n  else pos\ntermination_by _ => stopPos.1 - pos.1", "start": [179, 1], "end": [186, 38], "kind": "commanddeclaration"}, {"full_name": "String.find", "code": "@[inline] def find (s : String) (p : Char \u2192 Bool) : Pos :=\n  findAux s p s.endPos 0", "start": [188, 1], "end": [189, 25], "kind": "commanddeclaration"}, {"full_name": "String.revFindAux", "code": "def revFindAux (s : String) (p : Char \u2192 Bool) (pos : Pos) : Option Pos :=\n  if h : pos = 0 then none\n  else\n    have := prev_lt_of_pos s pos h\n    let pos := s.prev pos\n    if p (s.get pos) then some pos\n    else revFindAux s p pos\ntermination_by _ => pos.1", "start": [191, 1], "end": [198, 26], "kind": "commanddeclaration"}, {"full_name": "String.revFind", "code": "def revFind (s : String) (p : Char \u2192 Bool) : Option Pos :=\n  revFindAux s p s.endPos", "start": [200, 1], "end": [201, 26], "kind": "commanddeclaration"}, {"full_name": "String.Pos.min", "code": "abbrev Pos.min (p\u2081 p\u2082 : Pos) : Pos :=\n  { byteIdx := p\u2081.byteIdx.min p\u2082.byteIdx }", "start": [203, 1], "end": [204, 43], "kind": "commanddeclaration"}, {"full_name": "String.firstDiffPos", "code": "def firstDiffPos (a b : String) : Pos :=\n  let stopPos := a.endPos.min b.endPos\n  let rec loop (i : Pos) : Pos :=\n    if h : i < stopPos then\n      if a.get i != b.get i then i\n      else\n        have := Nat.sub_lt_sub_left h (lt_next a i)\n        loop (a.next i)\n    else i\n  loop 0\ntermination_by loop => stopPos.1 - i.1", "start": [206, 1], "end": [217, 39], "kind": "commanddeclaration"}, {"full_name": "String.extract", "code": "@[extern \"lean_string_utf8_extract\"]\ndef extract : (@& String) \u2192 (@& Pos) \u2192 (@& Pos) \u2192 String\n  | \u27e8s\u27e9, b, e => if b.byteIdx \u2265 e.byteIdx then \"\" else \u27e8go\u2081 s 0 b e\u27e9\nwhere\n  go\u2081 : List Char \u2192 Pos \u2192 Pos \u2192 Pos \u2192 List Char\n    | [],        _, _, _ => []\n    | s@(c::cs), i, b, e => if i = b then go\u2082 s i e else go\u2081 cs (i + c) b e\n\n  go\u2082 : List Char \u2192 Pos \u2192 Pos \u2192 List Char\n    | [],    _, _ => []\n    | c::cs, i, e => if i = e then [] else c :: go\u2082 cs (i + c) e", "start": [219, 1], "end": [229, 65], "kind": "commanddeclaration"}, {"full_name": "String.splitAux", "code": "@[specialize] def splitAux (s : String) (p : Char \u2192 Bool) (b : Pos) (i : Pos) (r : List String) : List String :=\n  if h : s.atEnd i then\n    let r := (s.extract b i)::r\n    r.reverse\n  else\n    have := Nat.sub_lt_sub_left (Nat.gt_of_not_le (mt decide_eq_true h)) (lt_next s _)\n    if p (s.get i) then\n      let i' := s.next i\n      splitAux s p i' i' (s.extract b i :: r)\n    else\n      splitAux s p b (s.next i) r\ntermination_by _ => s.endPos.1 - i.1", "start": [232, 1], "end": [243, 37], "kind": "commanddeclaration"}, {"full_name": "String.split", "code": "@[specialize] def split (s : String) (p : Char \u2192 Bool) : List String :=\n  splitAux s p 0 0 []", "start": [245, 1], "end": [246, 22], "kind": "commanddeclaration"}, {"full_name": "String.splitOnAux", "code": "def splitOnAux (s sep : String) (b : Pos) (i : Pos) (j : Pos) (r : List String) : List String :=\n  if h : s.atEnd i then\n    let r := (s.extract b i)::r\n    r.reverse\n  else\n    have := Nat.sub_lt_sub_left (Nat.gt_of_not_le (mt decide_eq_true h)) (lt_next s _)\n    if s.get i == sep.get j then\n      let i := s.next i\n      let j := sep.next j\n      if sep.atEnd j then\n        splitOnAux s sep i i 0 (s.extract b (i - j)::r)\n      else\n        splitOnAux s sep b i j r\n    else\n      splitOnAux s sep b (s.next i) 0 r\ntermination_by _ => s.endPos.1 - i.1", "start": [248, 1], "end": [263, 37], "kind": "commanddeclaration"}, {"full_name": "String.splitOn", "code": "def splitOn (s : String) (sep : String := \" \") : List String :=\n  if sep == \"\" then [s] else splitOnAux s sep 0 0 0 []", "start": [265, 1], "end": [266, 55], "kind": "commanddeclaration"}, {"full_name": "String.str", "code": "def str : String \u2192 Char \u2192 String := push", "start": [272, 1], "end": [272, 41], "kind": "commanddeclaration"}, {"full_name": "String.pushn", "code": "def pushn (s : String) (c : Char) (n : Nat) : String :=\n  n.repeat (fun s => s.push c) s", "start": [274, 1], "end": [275, 33], "kind": "commanddeclaration"}, {"full_name": "String.isEmpty", "code": "def isEmpty (s : String) : Bool :=\n  s.endPos == 0", "start": [277, 1], "end": [278, 16], "kind": "commanddeclaration"}, {"full_name": "String.join", "code": "def join (l : List String) : String :=\n  l.foldl (fun r s => r ++ s) \"\"", "start": [280, 1], "end": [281, 33], "kind": "commanddeclaration"}, {"full_name": "String.singleton", "code": "def singleton (c : Char) : String :=\n  \"\".push c", "start": [283, 1], "end": [284, 12], "kind": "commanddeclaration"}, {"full_name": "String.intercalate", "code": "def intercalate (s : String) : List String \u2192 String\n  | []      => \"\"\n  | a :: as => go a s as\nwhere go (acc : String) (s : String) : List String \u2192 String\n  | a :: as => go (acc ++ s ++ a) s as\n  | []      => acc", "start": [286, 1], "end": [291, 19], "kind": "commanddeclaration"}, {"full_name": "String.Iterator", "code": "structure Iterator where\n  s : String\n  i : Pos\n  deriving DecidableEq", "start": [293, 1], "end": [297, 23], "kind": "commanddeclaration"}, {"full_name": "String.mkIterator", "code": "def mkIterator (s : String) : Iterator :=\n  \u27e8s, 0\u27e9", "start": [299, 1], "end": [300, 9], "kind": "commanddeclaration"}, {"full_name": "String.iter", "code": "abbrev iter := mkIterator", "start": [302, 1], "end": [302, 26], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.sizeOf_eq", "code": "theorem Iterator.sizeOf_eq (i : String.Iterator) : sizeOf i = i.1.utf8ByteSize - i.2.byteIdx", "start": [307, 1], "end": [308, 6], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.toString", "code": "def toString : Iterator \u2192 String\n  | \u27e8s, _\u27e9 => s", "start": [311, 1], "end": [312, 16], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.remainingBytes", "code": "def remainingBytes : Iterator \u2192 Nat\n  | \u27e8s, i\u27e9 => s.endPos.byteIdx - i.byteIdx", "start": [314, 1], "end": [315, 43], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.pos", "code": "def pos : Iterator \u2192 Pos\n  | \u27e8_, i\u27e9 => i", "start": [317, 1], "end": [318, 16], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.curr", "code": "def curr : Iterator \u2192 Char\n  | \u27e8s, i\u27e9 => get s i", "start": [320, 1], "end": [321, 22], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.next", "code": "def next : Iterator \u2192 Iterator\n  | \u27e8s, i\u27e9 => \u27e8s, s.next i\u27e9", "start": [323, 1], "end": [324, 28], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.prev", "code": "def prev : Iterator \u2192 Iterator\n  | \u27e8s, i\u27e9 => \u27e8s, s.prev i\u27e9", "start": [326, 1], "end": [327, 28], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.atEnd", "code": "def atEnd : Iterator \u2192 Bool\n  | \u27e8s, i\u27e9 => i.byteIdx \u2265 s.endPos.byteIdx", "start": [329, 1], "end": [330, 43], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.hasNext", "code": "def hasNext : Iterator \u2192 Bool\n  | \u27e8s, i\u27e9 => i.byteIdx < s.endPos.byteIdx", "start": [332, 1], "end": [333, 43], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.hasPrev", "code": "def hasPrev : Iterator \u2192 Bool\n  | \u27e8_, i\u27e9 => i.byteIdx > 0", "start": [335, 1], "end": [336, 28], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.setCurr", "code": "def setCurr : Iterator \u2192 Char \u2192 Iterator\n  | \u27e8s, i\u27e9, c => \u27e8s.set i c, i\u27e9", "start": [338, 1], "end": [339, 32], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.toEnd", "code": "def toEnd : Iterator \u2192 Iterator\n  | \u27e8s, _\u27e9 => \u27e8s, s.endPos\u27e9", "start": [341, 1], "end": [342, 28], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.extract", "code": "def extract : Iterator \u2192 Iterator \u2192 String\n  | \u27e8s\u2081, b\u27e9, \u27e8s\u2082, e\u27e9 =>\n    if s\u2081 \u2260 s\u2082 || b > e then \"\"\n    else s\u2081.extract b e", "start": [344, 1], "end": [347, 24], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.forward", "code": "def forward : Iterator \u2192 Nat \u2192 Iterator\n  | it, 0   => it\n  | it, n+1 => forward it.next n", "start": [349, 1], "end": [351, 33], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.remainingToString", "code": "def remainingToString : Iterator \u2192 String\n  | \u27e8s, i\u27e9 => s.extract i s.endPos", "start": [353, 1], "end": [354, 35], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.nextn", "code": "def nextn : Iterator \u2192 Nat \u2192 Iterator\n  | it, 0   => it\n  | it, i+1 => nextn it.next i", "start": [356, 1], "end": [358, 31], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.prevn", "code": "def prevn : Iterator \u2192 Nat \u2192 Iterator\n  | it, 0   => it\n  | it, i+1 => prevn it.prev i", "start": [360, 1], "end": [362, 31], "kind": "commanddeclaration"}, {"full_name": "String.offsetOfPosAux", "code": "def offsetOfPosAux (s : String) (pos : Pos) (i : Pos) (offset : Nat) : Nat :=\n  if i >= pos then offset\n  else if h : s.atEnd i then\n    offset\n  else\n    have := Nat.sub_lt_sub_left (Nat.gt_of_not_le (mt decide_eq_true h)) (lt_next s _)\n    offsetOfPosAux s pos (s.next i) (offset+1)\ntermination_by _ => s.endPos.1 - i.1", "start": [365, 1], "end": [372, 37], "kind": "commanddeclaration"}, {"full_name": "String.offsetOfPos", "code": "def offsetOfPos (s : String) (pos : Pos) : Nat :=\n  offsetOfPosAux s pos 0 0", "start": [374, 1], "end": [375, 27], "kind": "commanddeclaration"}, {"full_name": "String.foldlAux", "code": "@[specialize] def foldlAux {\u03b1 : Type u} (f : \u03b1 \u2192 Char \u2192 \u03b1) (s : String) (stopPos : Pos) (i : Pos) (a : \u03b1) : \u03b1 :=\n  if h : i < stopPos then\n    have := Nat.sub_lt_sub_left h (lt_next s i)\n    foldlAux f s stopPos (s.next i) (f a (s.get i))\n  else a\ntermination_by _ => stopPos.1 - i.1", "start": [377, 1], "end": [382, 36], "kind": "commanddeclaration"}, {"full_name": "String.foldl", "code": "@[inline] def foldl {\u03b1 : Type u} (f : \u03b1 \u2192 Char \u2192 \u03b1) (init : \u03b1) (s : String) : \u03b1 :=\n  foldlAux f s s.endPos 0 init", "start": [384, 1], "end": [385, 31], "kind": "commanddeclaration"}, {"full_name": "String.foldrAux", "code": "@[specialize] def foldrAux {\u03b1 : Type u} (f : Char \u2192 \u03b1 \u2192 \u03b1) (a : \u03b1) (s : String) (i begPos : Pos) : \u03b1 :=\n  if h : begPos < i then\n    have := String.prev_lt_of_pos s i <| mt (congrArg String.Pos.byteIdx) <|\n      Ne.symm <| Nat.ne_of_lt <| Nat.lt_of_le_of_lt (Nat.zero_le _) h\n    let i := s.prev i\n    let a := f (s.get i) a\n    foldrAux f a s i begPos\n  else a\ntermination_by _ => i.1", "start": [387, 1], "end": [395, 24], "kind": "commanddeclaration"}, {"full_name": "String.foldr", "code": "@[inline] def foldr {\u03b1 : Type u} (f : Char \u2192 \u03b1 \u2192 \u03b1) (init : \u03b1) (s : String) : \u03b1 :=\n  foldrAux f init s s.endPos 0", "start": [397, 1], "end": [398, 31], "kind": "commanddeclaration"}, {"full_name": "String.anyAux", "code": "@[specialize] def anyAux (s : String) (stopPos : Pos) (p : Char \u2192 Bool) (i : Pos) : Bool :=\n  if h : i < stopPos then\n    if p (s.get i) then true\n    else\n      have := Nat.sub_lt_sub_left h (lt_next s i)\n      anyAux s stopPos p (s.next i)\n  else false\ntermination_by _ => stopPos.1 - i.1", "start": [400, 1], "end": [407, 36], "kind": "commanddeclaration"}, {"full_name": "String.any", "code": "@[inline] def any (s : String) (p : Char \u2192 Bool) : Bool :=\n  anyAux s s.endPos p 0", "start": [409, 1], "end": [410, 24], "kind": "commanddeclaration"}, {"full_name": "String.all", "code": "@[inline] def all (s : String) (p : Char \u2192 Bool) : Bool :=\n  !s.any (fun c => !p c)", "start": [412, 1], "end": [413, 25], "kind": "commanddeclaration"}, {"full_name": "String.contains", "code": "def contains (s : String) (c : Char) : Bool :=\ns.any (fun a => a == c)", "start": [415, 1], "end": [416, 24], "kind": "commanddeclaration"}, {"full_name": "String.utf8SetAux_of_gt", "code": "theorem utf8SetAux_of_gt (c' : Char) : \u2200 (cs : List Char) {i p : Pos}, i > p \u2192 utf8SetAux c' cs i p = cs", "start": [418, 1], "end": [422, 53], "kind": "commanddeclaration"}, {"full_name": "String.set_next_add", "code": "theorem set_next_add (s : String) (i : Pos) (c : Char) (b\u2081 b\u2082)\n    (h : (s.next i).1 + b\u2081 = s.endPos.1 + b\u2082) :\n    ((s.set i c).next i).1 + b\u2081 = (s.set i c).endPos.1 + b\u2082", "start": [424, 1], "end": [442, 24], "kind": "commanddeclaration"}, {"full_name": "String.mapAux_lemma", "code": "theorem mapAux_lemma (s : String) (i : Pos) (c : Char) (h : \u00acs.atEnd i) :\n    (s.set i c).endPos.1 - ((s.set i c).next i).1 < s.endPos.1 - i.1", "start": [444, 1], "end": [457, 64], "kind": "commanddeclaration"}, {"full_name": "String.mapAux", "code": "@[specialize] def mapAux (f : Char \u2192 Char) (i : Pos) (s : String) : String :=\n  if h : s.atEnd i then s\n  else\n    let c := f (s.get i)\n    have := mapAux_lemma s i c h\n    let s := s.set i c\n    mapAux f (s.next i) s\ntermination_by _ => s.endPos.1 - i.1", "start": [459, 1], "end": [466, 37], "kind": "commanddeclaration"}, {"full_name": "String.map", "code": "@[inline] def map (f : Char \u2192 Char) (s : String) : String :=\n  mapAux f 0 s", "start": [468, 1], "end": [469, 15], "kind": "commanddeclaration"}, {"full_name": "String.isNat", "code": "def isNat (s : String) : Bool :=\n  !s.isEmpty && s.all (\u00b7.isDigit)", "start": [471, 1], "end": [472, 34], "kind": "commanddeclaration"}, {"full_name": "String.toNat?", "code": "def toNat? (s : String) : Option Nat :=\n  if s.isNat then\n    some <| s.foldl (fun n c => n*10 + (c.toNat - '0'.toNat)) 0\n  else\n    none", "start": [474, 1], "end": [478, 9], "kind": "commanddeclaration"}, {"full_name": "String.substrEq", "code": "def substrEq (s1 : String) (off1 : String.Pos) (s2 : String) (off2 : String.Pos) (sz : Nat) : Bool :=\n  off1.byteIdx + sz \u2264 s1.endPos.byteIdx && off2.byteIdx + sz \u2264 s2.endPos.byteIdx && loop off1 off2 { byteIdx := off1.byteIdx + sz }\nwhere\n  loop (off1 off2 stop1 : Pos) :=\n    if h : off1.byteIdx < stop1.byteIdx then\n      let c\u2081 := s1.get off1\n      let c\u2082 := s2.get off2\n      have := Nat.sub_lt_sub_left h (Nat.add_lt_add_left (one_le_csize c\u2081) off1.1)\n      c\u2081 == c\u2082 && loop (off1 + c\u2081) (off2 + c\u2082) stop1\n    else true\ntermination_by loop => stop1.1 - off1.1", "start": [480, 1], "end": [493, 40], "kind": "commanddeclaration"}, {"full_name": "String.isPrefixOf", "code": "def isPrefixOf (p : String) (s : String) : Bool :=\n  substrEq p 0 s 0 p.endPos.byteIdx", "start": [495, 1], "end": [497, 36], "kind": "commanddeclaration"}, {"full_name": "String.replace", "code": "def replace (s pattern replacement : String) : String :=\n  if h : pattern.endPos.1 = 0 then s\n  else\n    have hPatt := Nat.zero_lt_of_ne_zero h\n    let rec loop (acc : String) (accStop pos : String.Pos) :=\n      if h : pos.byteIdx + pattern.endPos.byteIdx > s.endPos.byteIdx then\n        acc ++ s.extract accStop s.endPos\n      else\n        have := Nat.lt_of_lt_of_le (Nat.add_lt_add_left hPatt _) (Nat.ge_of_not_lt h)\n        if s.substrEq pos pattern 0 pattern.endPos.byteIdx then\n          have := Nat.sub_lt_sub_left this (Nat.add_lt_add_left hPatt _)\n          loop (acc ++ s.extract accStop pos ++ replacement) (pos + pattern) (pos + pattern)\n        else\n          have := Nat.sub_lt_sub_left this (lt_next s pos)\n          loop acc accStop (s.next pos)\n    loop \"\" 0 0\ntermination_by loop => s.endPos.1 - pos.1", "start": [499, 1], "end": [516, 42], "kind": "commanddeclaration"}, {"full_name": "Substring.isEmpty", "code": "@[inline] def isEmpty (ss : Substring) : Bool :=\n  ss.bsize == 0", "start": [522, 1], "end": [523, 16], "kind": "commanddeclaration"}, {"full_name": "Substring.toString", "code": "@[inline] def toString : Substring \u2192 String\n  | \u27e8s, b, e\u27e9 => s.extract b e", "start": [525, 1], "end": [526, 31], "kind": "commanddeclaration"}, {"full_name": "Substring.toIterator", "code": "@[inline] def toIterator : Substring \u2192 String.Iterator\n  | \u27e8s, b, _\u27e9 => \u27e8s, b\u27e9", "start": [528, 1], "end": [529, 24], "kind": "commanddeclaration"}, {"full_name": "Substring.get", "code": "@[inline] def get : Substring \u2192 String.Pos \u2192 Char\n  | \u27e8s, b, _\u27e9, p => s.get (b+p)", "start": [531, 1], "end": [533, 32], "kind": "commanddeclaration"}, {"full_name": "Substring.next", "code": "@[inline] def next : Substring \u2192 String.Pos \u2192 String.Pos\n  | \u27e8s, b, e\u27e9, p =>\n    let absP := b+p\n    if absP = e then p else { byteIdx := (s.next absP).byteIdx - b.byteIdx }", "start": [535, 1], "end": [540, 77], "kind": "commanddeclaration"}, {"full_name": "Substring.lt_next", "code": "theorem lt_next (s : Substring) (i : String.Pos) (h : i.1 < s.bsize) :\n    i.1 < (s.next i).1", "start": [542, 1], "end": [549, 42], "kind": "commanddeclaration"}, {"full_name": "Substring.prev", "code": "@[inline] def prev : Substring \u2192 String.Pos \u2192 String.Pos\n  | \u27e8s, b, _\u27e9, p =>\n    let absP := b+p\n    if absP = b then p else { byteIdx := (s.prev absP).byteIdx - b.byteIdx }", "start": [551, 1], "end": [556, 77], "kind": "commanddeclaration"}, {"full_name": "Substring.nextn", "code": "def nextn : Substring \u2192 Nat \u2192 String.Pos \u2192 String.Pos\n  | _,  0,   p => p\n  | ss, i+1, p => ss.nextn i (ss.next p)", "start": [558, 1], "end": [560, 41], "kind": "commanddeclaration"}, {"full_name": "Substring.prevn", "code": "def prevn : Substring \u2192 Nat \u2192 String.Pos \u2192 String.Pos\n  | _,  0,   p => p\n  | ss, i+1, p => ss.prevn i (ss.prev p)", "start": [562, 1], "end": [564, 41], "kind": "commanddeclaration"}, {"full_name": "Substring.front", "code": "@[inline] def front (s : Substring) : Char :=\n  s.get 0", "start": [566, 1], "end": [567, 10], "kind": "commanddeclaration"}, {"full_name": "Substring.posOf", "code": "@[inline] def posOf (s : Substring) (c : Char) : String.Pos :=\n  match s with\n  | \u27e8s, b, e\u27e9 => { byteIdx := (String.posOfAux s c e b).byteIdx - b.byteIdx }", "start": [569, 1], "end": [573, 78], "kind": "commanddeclaration"}, {"full_name": "Substring.drop", "code": "@[inline] def drop : Substring \u2192 Nat \u2192 Substring\n  | ss@\u27e8s, b, e\u27e9, n => \u27e8s, b + ss.nextn n 0, e\u27e9", "start": [575, 1], "end": [576, 48], "kind": "commanddeclaration"}, {"full_name": "Substring.dropRight", "code": "@[inline] def dropRight : Substring \u2192 Nat \u2192 Substring\n  | ss@\u27e8s, b, _\u27e9, n => \u27e8s, b, b + ss.prevn n \u27e8ss.bsize\u27e9\u27e9", "start": [578, 1], "end": [579, 57], "kind": "commanddeclaration"}, {"full_name": "Substring.take", "code": "@[inline] def take : Substring \u2192 Nat \u2192 Substring\n  | ss@\u27e8s, b, _\u27e9, n => \u27e8s, b, b + ss.nextn n 0\u27e9", "start": [581, 1], "end": [582, 48], "kind": "commanddeclaration"}, {"full_name": "Substring.takeRight", "code": "@[inline] def takeRight : Substring \u2192 Nat \u2192 Substring\n  | ss@\u27e8s, b, e\u27e9, n => \u27e8s, b + ss.prevn n \u27e8ss.bsize\u27e9, e\u27e9", "start": [584, 1], "end": [585, 57], "kind": "commanddeclaration"}, {"full_name": "Substring.atEnd", "code": "@[inline] def atEnd : Substring \u2192 String.Pos \u2192 Bool\n  | \u27e8_, b, e\u27e9, p => b + p == e", "start": [587, 1], "end": [588, 31], "kind": "commanddeclaration"}, {"full_name": "Substring.extract", "code": "@[inline] def extract : Substring \u2192 String.Pos \u2192 String.Pos \u2192 Substring\n  | \u27e8s, b, e\u27e9, b', e' => if b' \u2265 e' then \u27e8\"\", 0, 0\u27e9 else \u27e8s, e.min (b+b'), e.min (b+e')\u27e9", "start": [590, 1], "end": [591, 89], "kind": "commanddeclaration"}, {"full_name": "Substring.splitOn", "code": "def splitOn (s : Substring) (sep : String := \" \") : List Substring :=\n  if sep == \"\" then\n    [s]\n  else\n    let rec loop (b i j : String.Pos) (r : List Substring) : List Substring :=\n      if h : i.byteIdx < s.bsize then\n        have := Nat.sub_lt_sub_left h (lt_next s i h)\n        if s.get i == sep.get j then\n          let i := s.next i\n          let j := sep.next j\n          if sep.atEnd j then\n            loop i i 0 (s.extract b (i-j) :: r)\n          else\n            loop b i j r\n        else\n          loop b (s.next i) 0 r\n      else\n        let r := if sep.atEnd j then\n          \"\".toSubstring :: s.extract b (i-j) :: r\n        else\n          s.extract b i :: r\n        r.reverse\n    loop 0 0 0 []\ntermination_by loop => s.bsize - i.1", "start": [593, 1], "end": [616, 37], "kind": "commanddeclaration"}, {"full_name": "Substring.foldl", "code": "@[inline] def foldl {\u03b1 : Type u} (f : \u03b1 \u2192 Char \u2192 \u03b1) (init : \u03b1) (s : Substring) : \u03b1 :=\n  match s with\n  | \u27e8s, b, e\u27e9 => String.foldlAux f s e b init", "start": [618, 1], "end": [620, 46], "kind": "commanddeclaration"}, {"full_name": "Substring.foldr", "code": "@[inline] def foldr {\u03b1 : Type u} (f : Char \u2192 \u03b1 \u2192 \u03b1) (init : \u03b1) (s : Substring) : \u03b1 :=\n  match s with\n  | \u27e8s, b, e\u27e9 => String.foldrAux f init s e b", "start": [622, 1], "end": [624, 46], "kind": "commanddeclaration"}, {"full_name": "Substring.any", "code": "@[inline] def any (s : Substring) (p : Char \u2192 Bool) : Bool :=\n  match s with\n  | \u27e8s, b, e\u27e9 => String.anyAux s e p b", "start": [626, 1], "end": [628, 39], "kind": "commanddeclaration"}, {"full_name": "Substring.all", "code": "@[inline] def all (s : Substring) (p : Char \u2192 Bool) : Bool :=\n  !s.any (fun c => !p c)", "start": [630, 1], "end": [631, 25], "kind": "commanddeclaration"}, {"full_name": "Substring.contains", "code": "def contains (s : Substring) (c : Char) : Bool :=\n  s.any (fun a => a == c)", "start": [633, 1], "end": [634, 26], "kind": "commanddeclaration"}, {"full_name": "Substring.takeWhileAux", "code": "@[specialize] def takeWhileAux (s : String) (stopPos : String.Pos) (p : Char \u2192 Bool) (i : String.Pos) : String.Pos :=\n  if h : i < stopPos then\n    if p (s.get i) then\n      have := Nat.sub_lt_sub_left h (String.lt_next s i)\n      takeWhileAux s stopPos p (s.next i)\n    else i\n  else i\ntermination_by _ => stopPos.1 - i.1", "start": [636, 1], "end": [643, 36], "kind": "commanddeclaration"}, {"full_name": "Substring.takeWhile", "code": "@[inline] def takeWhile : Substring \u2192 (Char \u2192 Bool) \u2192 Substring\n  | \u27e8s, b, e\u27e9, p =>\n    let e := takeWhileAux s e p b;\n    \u27e8s, b, e\u27e9", "start": [645, 1], "end": [648, 14], "kind": "commanddeclaration"}, {"full_name": "Substring.dropWhile", "code": "@[inline] def dropWhile : Substring \u2192 (Char \u2192 Bool) \u2192 Substring\n  | \u27e8s, b, e\u27e9, p =>\n    let b := takeWhileAux s e p b;\n    \u27e8s, b, e\u27e9", "start": [650, 1], "end": [653, 14], "kind": "commanddeclaration"}, {"full_name": "Substring.takeRightWhileAux", "code": "@[specialize] def takeRightWhileAux (s : String) (begPos : String.Pos) (p : Char \u2192 Bool) (i : String.Pos) : String.Pos :=\n  if h : begPos < i then\n    have := String.prev_lt_of_pos s i <| mt (congrArg String.Pos.byteIdx) <|\n      Ne.symm <| Nat.ne_of_lt <| Nat.lt_of_le_of_lt (Nat.zero_le _) h\n    let i' := s.prev i\n    let c  := s.get i'\n    if !p c then i\n    else takeRightWhileAux s begPos p i'\n  else i\ntermination_by _ => i.1", "start": [655, 1], "end": [664, 24], "kind": "commanddeclaration"}, {"full_name": "Substring.takeRightWhile", "code": "@[inline] def takeRightWhile : Substring \u2192 (Char \u2192 Bool) \u2192 Substring\n  | \u27e8s, b, e\u27e9, p =>\n    let b := takeRightWhileAux s b p e\n    \u27e8s, b, e\u27e9", "start": [666, 1], "end": [669, 14], "kind": "commanddeclaration"}, {"full_name": "Substring.dropRightWhile", "code": "@[inline] def dropRightWhile : Substring \u2192 (Char \u2192 Bool) \u2192 Substring\n  | \u27e8s, b, e\u27e9, p =>\n    let e := takeRightWhileAux s b p e\n    \u27e8s, b, e\u27e9", "start": [671, 1], "end": [674, 14], "kind": "commanddeclaration"}, {"full_name": "Substring.trimLeft", "code": "@[inline] def trimLeft (s : Substring) : Substring :=\n  s.dropWhile Char.isWhitespace", "start": [676, 1], "end": [677, 32], "kind": "commanddeclaration"}, {"full_name": "Substring.trimRight", "code": "@[inline] def trimRight (s : Substring) : Substring :=\n  s.dropRightWhile Char.isWhitespace", "start": [679, 1], "end": [680, 37], "kind": "commanddeclaration"}, {"full_name": "Substring.trim", "code": "@[inline] def trim : Substring \u2192 Substring\n  | \u27e8s, b, e\u27e9 =>\n    let b := takeWhileAux s e Char.isWhitespace b\n    let e := takeRightWhileAux s b Char.isWhitespace e\n    \u27e8s, b, e\u27e9", "start": [682, 1], "end": [686, 14], "kind": "commanddeclaration"}, {"full_name": "Substring.isNat", "code": "def isNat (s : Substring) : Bool :=\n  s.all fun c => c.isDigit", "start": [688, 1], "end": [689, 27], "kind": "commanddeclaration"}, {"full_name": "Substring.toNat?", "code": "def toNat? (s : Substring) : Option Nat :=\n  if s.isNat then\n    some <| s.foldl (fun n c => n*10 + (c.toNat - '0'.toNat)) 0\n  else\n    none", "start": [691, 1], "end": [695, 9], "kind": "commanddeclaration"}, {"full_name": "Substring.beq", "code": "def beq (ss1 ss2 : Substring) : Bool :=\n  ss1.bsize == ss2.bsize && ss1.str.substrEq ss1.startPos ss2.str ss2.startPos ss1.bsize", "start": [697, 1], "end": [698, 89], "kind": "commanddeclaration"}, {"full_name": "Substring.hasBeq", "code": "instance hasBeq : BEq Substring := \u27e8beq\u27e9", "start": [700, 1], "end": [700, 41], "kind": "commanddeclaration"}, {"full_name": "String.drop", "code": "def drop (s : String) (n : Nat) : String :=\n  (s.toSubstring.drop n).toString", "start": [706, 1], "end": [707, 34], "kind": "commanddeclaration"}, {"full_name": "String.dropRight", "code": "def dropRight (s : String) (n : Nat) : String :=\n  (s.toSubstring.dropRight n).toString", "start": [709, 1], "end": [710, 39], "kind": "commanddeclaration"}, {"full_name": "String.take", "code": "def take (s : String) (n : Nat) : String :=\n  (s.toSubstring.take n).toString", "start": [712, 1], "end": [713, 34], "kind": "commanddeclaration"}, {"full_name": "String.takeRight", "code": "def takeRight (s : String) (n : Nat) : String :=\n  (s.toSubstring.takeRight n).toString", "start": [715, 1], "end": [716, 39], "kind": "commanddeclaration"}, {"full_name": "String.takeWhile", "code": "def takeWhile (s : String) (p : Char \u2192 Bool) : String :=\n  (s.toSubstring.takeWhile p).toString", "start": [718, 1], "end": [719, 39], "kind": "commanddeclaration"}, {"full_name": "String.dropWhile", "code": "def dropWhile (s : String) (p : Char \u2192 Bool) : String :=\n  (s.toSubstring.dropWhile p).toString", "start": [721, 1], "end": [722, 39], "kind": "commanddeclaration"}, {"full_name": "String.takeRightWhile", "code": "def takeRightWhile (s : String) (p : Char \u2192 Bool) : String :=\n  (s.toSubstring.takeRightWhile p).toString", "start": [724, 1], "end": [725, 44], "kind": "commanddeclaration"}, {"full_name": "String.dropRightWhile", "code": "def dropRightWhile (s : String) (p : Char \u2192 Bool) : String :=\n  (s.toSubstring.dropRightWhile p).toString", "start": [727, 1], "end": [728, 44], "kind": "commanddeclaration"}, {"full_name": "String.startsWith", "code": "def startsWith (s pre : String) : Bool :=\n  s.toSubstring.take pre.length == pre.toSubstring", "start": [730, 1], "end": [731, 51], "kind": "commanddeclaration"}, {"full_name": "String.endsWith", "code": "def endsWith (s post : String) : Bool :=\n  s.toSubstring.takeRight post.length == post.toSubstring", "start": [733, 1], "end": [734, 58], "kind": "commanddeclaration"}, {"full_name": "String.trimRight", "code": "def trimRight (s : String) : String :=\n  s.toSubstring.trimRight.toString", "start": [736, 1], "end": [737, 35], "kind": "commanddeclaration"}, {"full_name": "String.trimLeft", "code": "def trimLeft (s : String) : String :=\n  s.toSubstring.trimLeft.toString", "start": [739, 1], "end": [740, 34], "kind": "commanddeclaration"}, {"full_name": "String.trim", "code": "def trim (s : String) : String :=\n  s.toSubstring.trim.toString", "start": [742, 1], "end": [743, 30], "kind": "commanddeclaration"}, {"full_name": "String.nextWhile", "code": "@[inline] def nextWhile (s : String) (p : Char \u2192 Bool) (i : String.Pos) : String.Pos :=\n  Substring.takeWhileAux s s.endPos p i", "start": [745, 1], "end": [746, 40], "kind": "commanddeclaration"}, {"full_name": "String.nextUntil", "code": "@[inline] def nextUntil (s : String) (p : Char \u2192 Bool) (i : String.Pos) : String.Pos :=\n  nextWhile s (fun c => !p c) i", "start": [748, 1], "end": [749, 32], "kind": "commanddeclaration"}, {"full_name": "String.toUpper", "code": "def toUpper (s : String) : String :=\n  s.map Char.toUpper", "start": [751, 1], "end": [752, 21], "kind": "commanddeclaration"}, {"full_name": "String.toLower", "code": "def toLower (s : String) : String :=\n  s.map Char.toLower", "start": [754, 1], "end": [755, 21], "kind": "commanddeclaration"}, {"full_name": "String.capitalize", "code": "def capitalize (s : String) :=\n  s.set 0 <| s.get 0 |>.toUpper", "start": [757, 1], "end": [758, 32], "kind": "commanddeclaration"}, {"full_name": "String.decapitalize", "code": "def decapitalize (s : String) :=\n  s.set 0 <| s.get 0 |>.toLower", "start": [760, 1], "end": [761, 32], "kind": "commanddeclaration"}, {"full_name": "Char.toString", "code": "protected def Char.toString (c : Char) : String :=\n  String.singleton c", "start": [765, 1], "end": [766, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/State.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/Except.lean", "lake-packages/lean4/src/lean/Init/Control/Id.lean", "lake-packages/lean4/src/lean/Init/Control/Basic.lean"], "premises": [{"full_name": "StateT", "code": "def StateT (\u03c3 : Type u) (m : Type u \u2192 Type v) (\u03b1 : Type u) : Type (max u v) :=\n  \u03c3 \u2192 m (\u03b1 \u00d7 \u03c3)", "start": [14, 1], "end": [15, 16], "kind": "commanddeclaration"}, {"full_name": "StateT.run", "code": "@[always_inline, inline]\ndef StateT.run {\u03c3 : Type u} {m : Type u \u2192 Type v} {\u03b1 : Type u} (x : StateT \u03c3 m \u03b1) (s : \u03c3) : m (\u03b1 \u00d7 \u03c3) :=\n  x s", "start": [17, 1], "end": [19, 6], "kind": "commanddeclaration"}, {"full_name": "StateT.run'", "code": "@[always_inline, inline]\ndef StateT.run' {\u03c3 : Type u} {m : Type u \u2192 Type v} [Functor m] {\u03b1 : Type u} (x : StateT \u03c3 m \u03b1) (s : \u03c3) : m \u03b1 :=\n  (\u00b7.1) <$> x s", "start": [21, 1], "end": [23, 16], "kind": "commanddeclaration"}, {"full_name": "StateM", "code": "@[reducible]\ndef StateM (\u03c3 \u03b1 : Type u) : Type u := StateT \u03c3 Id \u03b1", "start": [25, 1], "end": [26, 52], "kind": "commanddeclaration"}, {"full_name": "StateT.pure", "code": "@[always_inline, inline]\nprotected def pure (a : \u03b1) : StateT \u03c3 m \u03b1 :=\n  fun s => pure (a, s)", "start": [41, 1], "end": [43, 23], "kind": "commanddeclaration"}, {"full_name": "StateT.bind", "code": "@[always_inline, inline]\nprotected def bind (x : StateT \u03c3 m \u03b1) (f : \u03b1 \u2192 StateT \u03c3 m \u03b2) : StateT \u03c3 m \u03b2 :=\n  fun s => do let (a, s) \u2190 x s; f a s", "start": [45, 1], "end": [47, 38], "kind": "commanddeclaration"}, {"full_name": "StateT.map", "code": "@[always_inline, inline]\nprotected def map (f : \u03b1 \u2192 \u03b2) (x : StateT \u03c3 m \u03b1) : StateT \u03c3 m \u03b2 :=\n  fun s => do let (a, s) \u2190 x s; pure (f a, s)", "start": [49, 1], "end": [51, 46], "kind": "commanddeclaration"}, {"full_name": "StateT.orElse", "code": "@[always_inline, inline]\nprotected def orElse [Alternative m] {\u03b1 : Type u} (x\u2081 : StateT \u03c3 m \u03b1) (x\u2082 : Unit \u2192 StateT \u03c3 m \u03b1) : StateT \u03c3 m \u03b1 :=\n  fun s => x\u2081 s <|> x\u2082 () s", "start": [59, 1], "end": [61, 28], "kind": "commanddeclaration"}, {"full_name": "StateT.failure", "code": "@[always_inline, inline]\nprotected def failure [Alternative m] {\u03b1 : Type u} : StateT \u03c3 m \u03b1 :=\n  fun _ => failure", "start": [63, 1], "end": [65, 19], "kind": "commanddeclaration"}, {"full_name": "StateT.get", "code": "@[always_inline, inline]\nprotected def get : StateT \u03c3 m \u03c3 :=\n  fun s => pure (s, s)", "start": [71, 1], "end": [73, 23], "kind": "commanddeclaration"}, {"full_name": "StateT.set", "code": "@[always_inline, inline]\nprotected def set : \u03c3 \u2192 StateT \u03c3 m PUnit :=\n  fun s' _ => pure (\u27e8\u27e9, s')", "start": [75, 1], "end": [77, 28], "kind": "commanddeclaration"}, {"full_name": "StateT.modifyGet", "code": "@[always_inline, inline]\nprotected def modifyGet (f : \u03c3 \u2192 \u03b1 \u00d7 \u03c3) : StateT \u03c3 m \u03b1 :=\n  fun s => pure (f s)", "start": [79, 1], "end": [81, 22], "kind": "commanddeclaration"}, {"full_name": "StateT.lift", "code": "@[always_inline, inline]\nprotected def lift {\u03b1 : Type u} (t : m \u03b1) : StateT \u03c3 m \u03b1 :=\n  fun s => do let a \u2190 t; pure (a, s)", "start": [83, 1], "end": [85, 37], "kind": "commanddeclaration"}, {"full_name": "ForM.forIn", "code": "@[always_inline, inline]\ndef ForM.forIn [Monad m] [ForM (StateT \u03b2 (ExceptT \u03b2 m)) \u03c1 \u03b1]\n    (x : \u03c1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 := do\n  let g a b := .mk do\n    match \u2190 f a b with\n    | .yield b' => pure (.ok (\u27e8\u27e9, b'))\n    | .done b' => pure (.error b')\n  match \u2190 forM (m := StateT \u03b2 (ExceptT \u03b2 m)) (\u03b1 := \u03b1) x g |>.run b |>.run with\n  | .ok a => pure a.2\n  | .error a => pure a", "start": [101, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "StateT.monadControl", "code": "@[always_inline]\ninstance StateT.monadControl (\u03c3 : Type u) (m : Type u \u2192 Type v) [Monad m] : MonadControl m (StateT \u03c3 m) where\n  stM      := fun \u03b1   => \u03b1 \u00d7 \u03c3\n  liftWith := fun f => do let s \u2190 get; liftM (f (fun x => x.run s))\n  restoreM := fun x => do let (a, s) \u2190 liftM x; set s; pure a", "start": [123, 1], "end": [127, 62], "kind": "commanddeclaration"}, {"full_name": "StateT.tryFinally", "code": "@[always_inline]\ninstance StateT.tryFinally {m : Type u \u2192 Type v} {\u03c3 : Type u} [MonadFinally m] [Monad m] : MonadFinally (StateT \u03c3 m) where\n  tryFinally' := fun x h s => do\n    let ((a, _), (b, s'')) \u2190 tryFinally' (x s) fun\n      | some (a, s') => h (some a) s'\n      | none         => h none s\n    pure ((a, b), s'')", "start": [129, 1], "end": [135, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Format/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/State.lean", "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean"], "premises": [{"full_name": "Std.Format.FlattenBehavior", "code": "inductive Format.FlattenBehavior where\n  | allOrNone\n  | fill\n  deriving Inhabited, BEq", "start": [13, 1], "end": [31, 26], "kind": "commanddeclaration"}, {"full_name": "Std.Format", "code": "inductive Format where\n  \n  | nil                 : Format\n  \n  | line                : Format\n  \n  | align (force : Bool) : Format\n  \n  | text                : String \u2192 Format\n  \n  | nest (indent : Int) : Format \u2192 Format\n  \n  | append              : Format \u2192 Format \u2192 Format\n  \n  | group               : Format \u2192 (behavior : FlattenBehavior := FlattenBehavior.allOrNone) \u2192 Format\n  \n  | tag                 : Nat \u2192 Format \u2192 Format\n  deriving Inhabited", "start": [34, 1], "end": [78, 21], "kind": "commanddeclaration"}, {"full_name": "Std.Format.isEmpty", "code": "def isEmpty : Format \u2192 Bool\n  | nil          => true\n  | line         => false\n  | align _      => true\n  | text msg     => msg == \"\"\n  | nest _ f     => f.isEmpty\n  | append f\u2081 f\u2082 => f\u2081.isEmpty && f\u2082.isEmpty\n  | group f _    => f.isEmpty\n  | tag _ f      => f.isEmpty", "start": [82, 1], "end": [91, 30], "kind": "commanddeclaration"}, {"full_name": "Std.Format.fill", "code": "def fill (f : Format) : Format :=\n  group f (behavior := FlattenBehavior.fill)", "start": [93, 1], "end": [95, 45], "kind": "commanddeclaration"}, {"full_name": "Std.Format.join", "code": "def join (xs : List Format) : Format :=\n  xs.foldl (\u00b7++\u00b7) \"\"", "start": [100, 1], "end": [101, 21], "kind": "commanddeclaration"}, {"full_name": "Std.Format.isNil", "code": "def isNil : Format \u2192 Bool\n  | nil => true\n  | _   => false", "start": [103, 1], "end": [105, 17], "kind": "commanddeclaration"}, {"full_name": "Std.Format.SpaceResult", "code": "private structure SpaceResult where\n  foundLine              : Bool := false\n  foundFlattenedHardLine : Bool := false\n  space                  : Nat  := 0\n  deriving Inhabited", "start": [107, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "Std.Format.merge", "code": "@[inline] private def merge (w : Nat) (r\u2081 : SpaceResult) (r\u2082 : Nat \u2192 SpaceResult) : SpaceResult :=\n  if r\u2081.space > w || r\u2081.foundLine then\n    r\u2081\n  else\n    let r\u2082 := r\u2082 (w - r\u2081.space);\n    { r\u2082 with space := r\u2081.space + r\u2082.space }", "start": [113, 1], "end": [118, 45], "kind": "commanddeclaration"}, {"full_name": "Std.Format.spaceUptoLine", "code": "private def spaceUptoLine : Format \u2192 Bool \u2192 Int \u2192 Nat \u2192 SpaceResult\n  | nil,          _,       _, _ => {}\n  | line,         flatten, _, _ => if flatten then { space := 1 } else { foundLine := true }\n  | align force,  flatten, m, w =>\n    if flatten && !force then {}\n    else if w < m then\n      { space := (m - w).toNat }\n    else\n      { foundLine := true }\n  | text s,       flatten, _, _ =>\n    let p := s.posOf '\\n'\n    let off := s.offsetOfPos p\n    { foundLine := p != s.endPos, foundFlattenedHardLine := flatten && p != s.endPos, space := off }\n  | append f\u2081 f\u2082, flatten, m, w => merge w (spaceUptoLine f\u2081 flatten m w) (spaceUptoLine f\u2082 flatten m)\n  | nest n f,     flatten, m, w => spaceUptoLine f flatten (m - n) w\n  | group f _,    _,       m, w => spaceUptoLine f true m w\n  | tag _ f,      flatten, m, w => spaceUptoLine f flatten m w", "start": [120, 1], "end": [136, 63], "kind": "commanddeclaration"}, {"full_name": "Std.Format.WorkItem", "code": "private structure WorkItem where\n  f : Format\n  indent : Int\n  activeTags : Nat", "start": [138, 1], "end": [141, 19], "kind": "commanddeclaration"}, {"full_name": "Std.Format.WorkGroup", "code": "private structure WorkGroup where\n  flatten : Bool\n  flb     : FlattenBehavior\n  items   : List WorkItem", "start": [143, 1], "end": [146, 26], "kind": "commanddeclaration"}, {"full_name": "Std.Format.spaceUptoLine'", "code": "private partial def spaceUptoLine' : List WorkGroup \u2192 Nat \u2192 Nat \u2192 SpaceResult\n  |   [],                         _,   _ => {}\n  |   { items := [],    .. }::gs, col, w => spaceUptoLine' gs col w\n  | g@{ items := i::is, .. }::gs, col, w =>\n    merge w\n      (spaceUptoLine i.f g.flatten (w + col - i.indent) w)\n      (spaceUptoLine' ({ g with items := is }::gs) col)", "start": [148, 1], "end": [154, 56], "kind": "commanddeclaration"}, {"full_name": "Std.Format.MonadPrettyFormat", "code": "class MonadPrettyFormat (m : Type \u2192 Type) where\n  pushOutput (s : String)    : m Unit\n  pushNewline (indent : Nat) : m Unit\n  currColumn                 : m Nat\n  \n  startTag                   : Nat \u2192 m Unit\n  \n  endTags                    : Nat \u2192 m Unit", "start": [156, 1], "end": [164, 44], "kind": "commanddeclaration"}, {"full_name": "Std.Format.pushGroup", "code": "private def pushGroup (flb : FlattenBehavior) (items : List WorkItem) (gs : List WorkGroup) (w : Nat) [Monad m] [MonadPrettyFormat m] : m (List WorkGroup) := do\n  let k  \u2190 currColumn\n  let g  := { flatten := flb == FlattenBehavior.allOrNone, flb := flb, items := items : WorkGroup }\n  let r  := spaceUptoLine' [g] k (w-k)\n  let r' := merge (w-k) r (spaceUptoLine' gs k)\n  return { g with flatten := !r.foundFlattenedHardLine && r'.space <= w-k }::gs", "start": [167, 1], "end": [174, 80], "kind": "commanddeclaration"}, {"full_name": "Std.Format.be", "code": "private partial def be (w : Nat) [Monad m] [MonadPrettyFormat m] : List WorkGroup \u2192 m Unit\n  | []                           => pure ()\n  |   { items := [],    .. }::gs => be w gs\n  | g@{ items := i::is, .. }::gs => do\n    let gs' (is' : List WorkItem) := { g with items := is' }::gs;\n    match i.f with\n    | nil =>\n      endTags i.activeTags\n      be w (gs' is)\n    | tag t f =>\n      startTag t\n      be w (gs' ({ i with f, activeTags := i.activeTags + 1 }::is))\n    | append f\u2081 f\u2082 => be w (gs' ({ i with f := f\u2081, activeTags := 0 }::{ i with f := f\u2082 }::is))\n    | nest n f => be w (gs' ({ i with f, indent := i.indent + n }::is))\n    | text s =>\n      let p := s.posOf '\\n'\n      if p == s.endPos then\n        pushOutput s\n        endTags i.activeTags\n        be w (gs' is)\n      else\n        pushOutput (s.extract {} p)\n        pushNewline i.indent.toNat\n        let is := { i with f := text (s.extract (s.next p) s.endPos) }::is\n        pushGroup g.flb is gs w >>= be w\n    | line =>\n      match g.flb with\n      | FlattenBehavior.allOrNone =>\n        if g.flatten then\n          pushOutput \" \"\n          endTags i.activeTags\n          be w (gs' is)\n        else\n          pushNewline i.indent.toNat\n          endTags i.activeTags\n          be w (gs' is)\n      | FlattenBehavior.fill =>\n        let breakHere := do\n          pushNewline i.indent.toNat\n          endTags i.activeTags\n          pushGroup FlattenBehavior.fill is gs w >>= be w\n        if g.flatten then\n          let gs'@(g'::_) \u2190 pushGroup FlattenBehavior.fill is gs (w - \" \".length)\n            | panic \"unreachable\"\n          if g'.flatten then\n            pushOutput \" \"\n            endTags i.activeTags\n            be w gs'  else\n            breakHere\n        else\n          breakHere\n    | align force =>\n      if g.flatten && !force then\n        endTags i.activeTags\n        be w (gs' is)\n      else\n        let k \u2190 currColumn\n        if k < i.indent then\n          pushOutput (\"\".pushn ' ' (i.indent - k).toNat)\n          endTags i.activeTags\n          be w (gs' is)\n        else\n          pushNewline i.indent.toNat\n          endTags i.activeTags\n          be w (gs' is)\n    | group f flb =>\n      if g.flatten then\n        be w (gs' ({ i with f }::is))\n      else\n        pushGroup flb [{ i with f }] (gs' is) w >>= be w", "start": [176, 1], "end": [252, 57], "kind": "commanddeclaration"}, {"full_name": "Std.Format.prettyM", "code": "def prettyM (f : Format) (w : Nat) (indent : Nat := 0) [Monad m] [MonadPrettyFormat m] : m Unit :=\n  be w [{ flb := FlattenBehavior.allOrNone, flatten := false, items := [{ f := f, indent, activeTags := 0 }]}]", "start": [254, 1], "end": [257, 111], "kind": "commanddeclaration"}, {"full_name": "Std.Format.bracket", "code": "@[inline] def bracket (l : String) (f : Format) (r : String) : Format :=\n  group (nest l.length $ l ++ f ++ r)", "start": [259, 1], "end": [262, 38], "kind": "commanddeclaration"}, {"full_name": "Std.Format.paren", "code": "@[inline] def paren (f : Format) : Format :=\n  bracket \"(\" f \")\"", "start": [264, 1], "end": [266, 20], "kind": "commanddeclaration"}, {"full_name": "Std.Format.sbracket", "code": "@[inline] def sbracket (f : Format) : Format :=\n  bracket \"[\" f \"]\"", "start": [268, 1], "end": [270, 20], "kind": "commanddeclaration"}, {"full_name": "Std.Format.bracketFill", "code": "@[inline] def bracketFill (l : String) (f : Format) (r : String) : Format :=\n  fill (nest l.length $ l ++ f ++ r)", "start": [272, 1], "end": [274, 37], "kind": "commanddeclaration"}, {"full_name": "Std.Format.defIndent", "code": "def defIndent  := 2", "start": [276, 1], "end": [277, 20], "kind": "commanddeclaration"}, {"full_name": "Std.Format.defUnicode", "code": "def defUnicode := true", "start": [278, 1], "end": [278, 23], "kind": "commanddeclaration"}, {"full_name": "Std.Format.defWidth", "code": "def defWidth   := 120", "start": [279, 1], "end": [280, 22], "kind": "commanddeclaration"}, {"full_name": "Std.Format.nestD", "code": "def nestD (f : Format) : Format :=\n  nest defIndent f", "start": [282, 1], "end": [284, 19], "kind": "commanddeclaration"}, {"full_name": "Std.Format.indentD", "code": "def indentD (f : Format) : Format :=\n  nestD (Format.line ++ f)", "start": [286, 1], "end": [288, 27], "kind": "commanddeclaration"}, {"full_name": "Std.Format.State", "code": "private structure State where\n  out    : String := \"\"\n  column : Nat    := 0", "start": [290, 1], "end": [293, 23], "kind": "commanddeclaration"}, {"full_name": "Std.Format.pretty", "code": "@[export lean_format_pretty]\ndef pretty (f : Format) (w : Nat := defWidth) : String :=\n  let act: StateM State Unit := prettyM f w\n  act {} |>.snd.out", "start": [303, 1], "end": [307, 20], "kind": "commanddeclaration"}, {"full_name": "Std.ToFormat", "code": "class ToFormat (\u03b1 : Type u) where\n  format : \u03b1 \u2192 Format", "start": [311, 1], "end": [314, 22], "kind": "commanddeclaration"}, {"full_name": "Std.Format.joinSep", "code": "def Format.joinSep {\u03b1 : Type u} [ToFormat \u03b1] : List \u03b1 \u2192 Format \u2192 Format\n  | [],    _   => nil\n  | [a],   _   => format a\n  | a::as, sep => as.foldl (\u00b7 ++ sep ++ format \u00b7) (format a)", "start": [325, 1], "end": [329, 61], "kind": "commanddeclaration"}, {"full_name": "Std.Format.prefixJoin", "code": "def Format.prefixJoin {\u03b1 : Type u} [ToFormat \u03b1] (pre : Format) : List \u03b1 \u2192 Format\n  | []    => nil\n  | a::as => as.foldl (\u00b7 ++ pre ++ format \u00b7) (pre ++ format a)", "start": [331, 1], "end": [334, 63], "kind": "commanddeclaration"}, {"full_name": "Std.Format.joinSuffix", "code": "def Format.joinSuffix {\u03b1 : Type u} [ToFormat \u03b1] : List \u03b1 \u2192 Format \u2192 Format\n  | [],    _      => nil\n  | a::as, suffix => as.foldl (\u00b7 ++ format \u00b7 ++ suffix) (format a ++ suffix)", "start": [336, 1], "end": [339, 77], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Repr.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/UInt/Basic.lean", "lake-packages/lean4/src/lean/Init/Control/Id.lean", "lake-packages/lean4/src/lean/Init/Data/Format/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean"], "premises": [{"full_name": "Repr", "code": "class Repr (\u03b1 : Type u) where\n  reprPrec : \u03b1 \u2192 Nat \u2192 Format", "start": [16, 1], "end": [17, 30], "kind": "commanddeclaration"}, {"full_name": "repr", "code": "abbrev repr [Repr \u03b1] (a : \u03b1) : Format :=\n  reprPrec a 0", "start": [21, 1], "end": [22, 15], "kind": "commanddeclaration"}, {"full_name": "reprStr", "code": "abbrev reprStr [Repr \u03b1] (a : \u03b1) : String :=\n  reprPrec a 0 |>.pretty", "start": [24, 1], "end": [25, 25], "kind": "commanddeclaration"}, {"full_name": "reprArg", "code": "abbrev reprArg [Repr \u03b1] (a : \u03b1) : Format :=\n  reprPrec a max_prec", "start": [27, 1], "end": [28, 22], "kind": "commanddeclaration"}, {"full_name": "ReprAtom", "code": "class ReprAtom (\u03b1 : Type u)", "start": [30, 1], "end": [32, 28], "kind": "commanddeclaration"}, {"full_name": "Repr.addAppParen", "code": "def Repr.addAppParen (f : Format) (prec : Nat) : Format :=\n  if prec >= max_prec then\n    Format.paren f\n  else\n    f", "start": [46, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "Option.repr", "code": "protected def Option.repr [Repr \u03b1] : Option \u03b1 \u2192 Nat \u2192 Format\n  | none,    _   => \"none\"\n  | some a, prec => Repr.addAppParen (\"some \" ++ reprArg a) prec", "start": [67, 1], "end": [69, 65], "kind": "commanddeclaration"}, {"full_name": "Sum.repr", "code": "protected def Sum.repr [Repr \u03b1] [Repr \u03b2] : Sum \u03b1 \u03b2 \u2192 Nat \u2192 Format\n  | Sum.inl a, prec => Repr.addAppParen (\"Sum.inl \" ++ reprArg a) prec\n  | Sum.inr b, prec => Repr.addAppParen (\"Sum.inr \" ++ reprArg b) prec", "start": [74, 1], "end": [76, 71], "kind": "commanddeclaration"}, {"full_name": "ReprTuple", "code": "class ReprTuple (\u03b1 : Type u) where\n  reprTuple : \u03b1 \u2192 List Format \u2192 List Format", "start": [81, 1], "end": [82, 44], "kind": "commanddeclaration"}, {"full_name": "Prod.repr", "code": "protected def Prod.repr [Repr \u03b1] [ReprTuple \u03b2] : \u03b1 \u00d7 \u03b2 \u2192 Nat \u2192 Format\n  | (a, b), _ => Format.bracket \"(\" (Format.joinSep (reprTuple b [repr a]).reverse (\",\" ++ Format.line)) \")\"", "start": [92, 1], "end": [93, 109], "kind": "commanddeclaration"}, {"full_name": "Nat.digitChar", "code": "def digitChar (n : Nat) : Char :=\n  if n = 0 then '0' else\n  if n = 1 then '1' else\n  if n = 2 then '2' else\n  if n = 3 then '3' else\n  if n = 4 then '4' else\n  if n = 5 then '5' else\n  if n = 6 then '6' else\n  if n = 7 then '7' else\n  if n = 8 then '8' else\n  if n = 9 then '9' else\n  if n = 0xa then 'a' else\n  if n = 0xb then 'b' else\n  if n = 0xc then 'c' else\n  if n = 0xd then 'd' else\n  if n = 0xe then 'e' else\n  if n = 0xf then 'f' else\n  '*'", "start": [106, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.toDigitsCore", "code": "def toDigitsCore (base : Nat) : Nat \u2192 Nat \u2192 List Char \u2192 List Char\n  | 0,      _, ds => ds\n  | fuel+1, n, ds =>\n    let d  := digitChar <| n % base;\n    let n' := n / base;\n    if n' = 0 then d::ds\n    else toDigitsCore base fuel n' (d::ds)", "start": [125, 1], "end": [131, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.toDigits", "code": "def toDigits (base : Nat) (n : Nat) : List Char :=\n  toDigitsCore base (n+1) n []", "start": [133, 1], "end": [134, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.repr", "code": "protected def repr (n : Nat) : String :=\n  (toDigits 10 n).asString", "start": [136, 1], "end": [137, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.superDigitChar", "code": "def superDigitChar (n : Nat) : Char :=\n  if n = 0 then '\u2070' else\n  if n = 1 then '\u00b9' else\n  if n = 2 then '\u00b2' else\n  if n = 3 then '\u00b3' else\n  if n = 4 then '\u2074' else\n  if n = 5 then '\u2075' else\n  if n = 6 then '\u2076' else\n  if n = 7 then '\u2077' else\n  if n = 8 then '\u2078' else\n  if n = 9 then '\u2079' else\n  '*'", "start": [139, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.toSuperDigitsAux", "code": "partial def toSuperDigitsAux : Nat \u2192 List Char \u2192 List Char\n  | n, ds =>\n    let d  := superDigitChar <| n % 10;\n    let n' := n / 10;\n    if n' = 0 then d::ds\n    else toSuperDigitsAux n' (d::ds)", "start": [152, 1], "end": [157, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.toSuperDigits", "code": "def toSuperDigits (n : Nat) : List Char :=\n  toSuperDigitsAux n []", "start": [159, 1], "end": [160, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.toSuperscriptString", "code": "def toSuperscriptString (n : Nat) : String :=\n  (toSuperDigits n).asString", "start": [162, 1], "end": [163, 29], "kind": "commanddeclaration"}, {"full_name": "Int.repr", "code": "protected def Int.repr : Int \u2192 String\n    | ofNat m   => Nat.repr m\n    | negSucc m => \"-\" ++ Nat.repr (succ m)", "start": [170, 1], "end": [172, 44], "kind": "commanddeclaration"}, {"full_name": "hexDigitRepr", "code": "def hexDigitRepr (n : Nat) : String :=\n  String.singleton <| Nat.digitChar n", "start": [177, 1], "end": [178, 38], "kind": "commanddeclaration"}, {"full_name": "Char.quoteCore", "code": "def Char.quoteCore (c : Char) : String :=\n  if       c = '\\n' then \"\\\\n\"\n  else if  c = '\\t' then \"\\\\t\"\n  else if  c = '\\\\' then \"\\\\\\\\\"\n  else if  c = '\\\"' then \"\\\\\\\"\"\n  else if  c.toNat <= 31 \u2228 c = '\\x7f' then \"\\\\x\" ++ smallCharToHex c\n  else String.singleton c\nwhere\n  smallCharToHex (c : Char) : String :=\n    let n  := Char.toNat c;\n    let d2 := n / 16;\n    let d1 := n % 16;\n    hexDigitRepr d2 ++ hexDigitRepr d1", "start": [180, 1], "end": [192, 39], "kind": "commanddeclaration"}, {"full_name": "Char.quote", "code": "def Char.quote (c : Char) : String :=\n  \"'\" ++ Char.quoteCore c ++ \"'\"", "start": [194, 1], "end": [195, 33], "kind": "commanddeclaration"}, {"full_name": "Char.repr", "code": "protected def Char.repr (c : Char) : String :=\n  c.quote", "start": [200, 1], "end": [201, 10], "kind": "commanddeclaration"}, {"full_name": "String.quote", "code": "def String.quote (s : String) : String :=\n  if s.isEmpty then \"\\\"\\\"\"\n  else s.foldl (fun s c => s ++ c.quoteCore) \"\\\"\" ++ \"\\\"\"", "start": [203, 1], "end": [205, 58], "kind": "commanddeclaration"}, {"full_name": "List.repr", "code": "protected def List.repr [Repr \u03b1] (a : List \u03b1) (n : Nat) : Format :=\n  let _ : ToFormat \u03b1 := \u27e8repr\u27e9\n  match a, n with\n  | [], _ => \"[]\"\n  | as, _ => Format.bracket \"[\" (Format.joinSep as (\",\" ++ Format.line)) \"]\"", "start": [237, 1], "end": [241, 77], "kind": "commanddeclaration"}, {"full_name": "List.repr'", "code": "protected def List.repr' [Repr \u03b1] [ReprAtom \u03b1] (a : List \u03b1) (n : Nat) : Format :=\n  let _ : ToFormat \u03b1 := \u27e8repr\u27e9\n  match a, n with\n  | [], _ => \"[]\"\n  | as, _ => Format.bracketFill \"[\" (Format.joinSep as (\",\" ++ Format.line)) \"]\"", "start": [246, 1], "end": [250, 81], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/Option.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Option/Basic.lean", "lake-packages/lean4/src/lean/Init/Control/Except.lean", "lake-packages/lean4/src/lean/Init/Control/Basic.lean"], "premises": [{"full_name": "OptionT", "code": "def OptionT (m : Type u \u2192 Type v) (\u03b1 : Type u) : Type v :=\n  m (Option \u03b1)", "start": [15, 1], "end": [16, 15], "kind": "commanddeclaration"}, {"full_name": "OptionT.run", "code": "@[always_inline, inline]\ndef OptionT.run {m : Type u \u2192 Type v} {\u03b1 : Type u} (x : OptionT m \u03b1) : m (Option \u03b1) :=\n  x", "start": [18, 1], "end": [20, 4], "kind": "commanddeclaration"}, {"full_name": "OptionT.mk", "code": "protected def mk (x : m (Option \u03b1)) : OptionT m \u03b1 :=\n  x", "start": [25, 1], "end": [26, 4], "kind": "commanddeclaration"}, {"full_name": "OptionT.bind", "code": "@[always_inline, inline]\nprotected def bind (x : OptionT m \u03b1) (f : \u03b1 \u2192 OptionT m \u03b2) : OptionT m \u03b2 := OptionT.mk do\n  match (\u2190 x) with\n  | some a => f a\n  | none   => pure none", "start": [28, 1], "end": [32, 24], "kind": "commanddeclaration"}, {"full_name": "OptionT.pure", "code": "@[always_inline, inline]\nprotected def pure (a : \u03b1) : OptionT m \u03b1 := OptionT.mk do\n  pure (some a)", "start": [34, 1], "end": [36, 16], "kind": "commanddeclaration"}, {"full_name": "OptionT.orElse", "code": "@[always_inline, inline] protected def orElse (x : OptionT m \u03b1) (y : Unit \u2192 OptionT m \u03b1) : OptionT m \u03b1 := OptionT.mk do\n  match (\u2190 x) with\n  | some a => pure (some a)\n  | _      => y ()", "start": [43, 1], "end": [46, 19], "kind": "commanddeclaration"}, {"full_name": "OptionT.fail", "code": "@[always_inline, inline] protected def fail : OptionT m \u03b1 := OptionT.mk do\n  pure none", "start": [48, 1], "end": [49, 12], "kind": "commanddeclaration"}, {"full_name": "OptionT.lift", "code": "@[always_inline, inline] protected def lift (x : m \u03b1) : OptionT m \u03b1 := OptionT.mk do\n  return some (\u2190 x)", "start": [55, 1], "end": [56, 20], "kind": "commanddeclaration"}, {"full_name": "OptionT.tryCatch", "code": "@[always_inline, inline] protected def tryCatch (x : OptionT m \u03b1) (handle : Unit \u2192 OptionT m \u03b1) : OptionT m \u03b1 := OptionT.mk do\n  let some a \u2190 x | handle ()\n  pure a", "start": [62, 1], "end": [64, 9], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/UInt/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Format/Basic.lean", "lake-packages/lean4/src/lean/Init/Control/Id.lean", "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "lake-packages/lean4/src/lean/Init/Control/Option.lean", "lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Repr.lean"], "premises": [{"full_name": "ToString", "code": "class ToString (\u03b1 : Type u) where\n  toString : \u03b1 \u2192 String", "start": [19, 1], "end": [20, 24], "kind": "commanddeclaration"}, {"full_name": "List.toString", "code": "protected def List.toString [ToString \u03b1] : List \u03b1 \u2192 String\n  | [] => \"[]\"\n  | [x] => \"[\" ++ toString x ++ \"]\"\n  | x::xs => xs.foldl (\u00b7 ++ \", \" ++ toString \u00b7) (\"[\" ++ toString x) |>.push ']'", "start": [48, 1], "end": [51, 80], "kind": "commanddeclaration"}, {"full_name": "addParenHeuristic", "code": "def addParenHeuristic (s : String) : String :=\n  if \"(\".isPrefixOf s || \"[\".isPrefixOf s || \"{\".isPrefixOf s || \"#[\".isPrefixOf s then s\n  else if !s.any Char.isWhitespace then s\n  else \"(\" ++ s ++ \")\"", "start": [100, 1], "end": [103, 23], "kind": "commanddeclaration"}, {"full_name": "String.toInt?", "code": "def String.toInt? (s : String) : Option Int := do\n  if s.get 0 = '-' then do\n    let v \u2190 (s.toSubstring.drop 1).toNat?;\n    pure <| - Int.ofNat v\n  else\n   Int.ofNat <$> s.toNat?", "start": [122, 1], "end": [127, 26], "kind": "commanddeclaration"}, {"full_name": "String.isInt", "code": "def String.isInt (s : String) : Bool :=\n  if s.get 0 = '-' then\n    (s.toSubstring.drop 1).isNat\n  else\n    s.isNat", "start": [129, 1], "end": [133, 12], "kind": "commanddeclaration"}, {"full_name": "String.toInt!", "code": "def String.toInt! (s : String) : Int :=\n  match s.toInt? with\n  | some v => v\n  | none   => panic \"Int expected\"", "start": [135, 1], "end": [138, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Util.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean"], "premises": [{"full_name": "dbgTrace", "code": "@[never_extract, extern \"lean_dbg_trace\"]\ndef dbgTrace {\u03b1 : Type u} (s : String) (f : Unit \u2192 \u03b1) : \u03b1 := f ()", "start": [15, 1], "end": [16, 66], "kind": "commanddeclaration"}, {"full_name": "dbgTraceVal", "code": "def dbgTraceVal {\u03b1 : Type u} [ToString \u03b1] (a : \u03b1) : \u03b1 :=\n  dbgTrace (toString a) (fun _ => a)", "start": [18, 1], "end": [19, 37], "kind": "commanddeclaration"}, {"full_name": "dbgTraceIfShared", "code": "@[never_extract, extern \"lean_dbg_trace_if_shared\"]\ndef dbgTraceIfShared {\u03b1 : Type u} (s : String) (a : \u03b1) : \u03b1 := a", "start": [22, 1], "end": [24, 64], "kind": "commanddeclaration"}, {"full_name": "dbgStackTrace", "code": "@[never_extract, extern \"lean_dbg_stack_trace\"]\ndef dbgStackTrace {\u03b1 : Type u} (f : Unit \u2192 \u03b1) : \u03b1 := f ()", "start": [26, 1], "end": [28, 58], "kind": "commanddeclaration"}, {"full_name": "dbgSleep", "code": "@[extern \"lean_dbg_sleep\"]\ndef dbgSleep {\u03b1 : Type u} (ms : UInt32) (f : Unit \u2192 \u03b1) : \u03b1 := f ()", "start": [30, 1], "end": [31, 67], "kind": "commanddeclaration"}, {"full_name": "mkPanicMessage", "code": "@[noinline] private def mkPanicMessage (modName : String) (line col : Nat) (msg : String) : String :=\n  \"PANIC at \" ++ modName ++ \":\" ++ toString line ++ \":\" ++ toString col ++ \": \" ++ msg", "start": [33, 1], "end": [34, 87], "kind": "commanddeclaration"}, {"full_name": "panicWithPos", "code": "@[never_extract, inline] def panicWithPos {\u03b1 : Type u} [Inhabited \u03b1] (modName : String) (line col : Nat) (msg : String) : \u03b1 :=\n  panic (mkPanicMessage modName line col msg)", "start": [36, 1], "end": [37, 46], "kind": "commanddeclaration"}, {"full_name": "mkPanicMessageWithDecl", "code": "@[noinline] private def mkPanicMessageWithDecl (modName : String) (declName : String) (line col : Nat) (msg : String) : String :=\n  \"PANIC at \" ++ declName ++ \" \" ++ modName ++ \":\" ++ toString line ++ \":\" ++ toString col ++ \": \" ++ msg", "start": [39, 1], "end": [40, 106], "kind": "commanddeclaration"}, {"full_name": "panicWithPosWithDecl", "code": "@[never_extract, inline] def panicWithPosWithDecl {\u03b1 : Type u} [Inhabited \u03b1] (modName : String) (declName : String) (line col : Nat) (msg : String) : \u03b1 :=\n  panic (mkPanicMessageWithDecl modName declName line col msg)", "start": [42, 1], "end": [43, 63], "kind": "commanddeclaration"}, {"full_name": "ptrAddrUnsafe", "code": "@[extern \"lean_ptr_addr\"]\nunsafe opaque ptrAddrUnsafe {\u03b1 : Type u} (a : @& \u03b1) : USize", "start": [45, 1], "end": [46, 60], "kind": "commanddeclaration"}, {"full_name": "withPtrAddrUnsafe", "code": "@[inline] unsafe def withPtrAddrUnsafe {\u03b1 : Type u} {\u03b2 : Type v} (a : \u03b1) (k : USize \u2192 \u03b2) (h : \u2200 u\u2081 u\u2082, k u\u2081 = k u\u2082) : \u03b2 :=\n  k (ptrAddrUnsafe a)", "start": [49, 1], "end": [50, 22], "kind": "commanddeclaration"}, {"full_name": "ptrEq", "code": "@[inline] unsafe def ptrEq (a b : \u03b1) : Bool := ptrAddrUnsafe a == ptrAddrUnsafe b", "start": [52, 1], "end": [52, 82], "kind": "commanddeclaration"}, {"full_name": "ptrEqList", "code": "unsafe def ptrEqList : (as bs : List \u03b1) \u2192 Bool\n  | [], [] => true\n  | a::as, b::bs => if ptrEq a b then ptrEqList as bs else false\n  | _, _ => false", "start": [54, 1], "end": [57, 18], "kind": "commanddeclaration"}, {"full_name": "withPtrEqUnsafe", "code": "@[inline] unsafe def withPtrEqUnsafe {\u03b1 : Type u} (a b : \u03b1) (k : Unit \u2192 Bool) (h : a = b \u2192 k () = true) : Bool :=\n  if ptrEq a b then true else k ()", "start": [60, 1], "end": [61, 35], "kind": "commanddeclaration"}, {"full_name": "withPtrEq", "code": "@[implemented_by withPtrEqUnsafe]\ndef withPtrEq {\u03b1 : Type u} (a b : \u03b1) (k : Unit \u2192 Bool) (h : a = b \u2192 k () = true) : Bool := k ()", "start": [63, 1], "end": [64, 96], "kind": "commanddeclaration"}, {"full_name": "withPtrEqDecEq", "code": "@[inline] def withPtrEqDecEq {\u03b1 : Type u} (a b : \u03b1) (k : Unit \u2192 Decidable (a = b)) : Decidable (a = b) :=\n  let b := withPtrEq a b (fun _ => toBoolUsing (k ())) (toBoolUsing_eq_true (k ()));\n  match h:b with\n  | true  => isTrue (ofBoolUsing_eq_true h)\n  | false => isFalse (ofBoolUsing_eq_false h)", "start": [66, 1], "end": [71, 46], "kind": "commanddeclaration"}, {"full_name": "withPtrAddr", "code": "@[implemented_by withPtrAddrUnsafe]\ndef withPtrAddr {\u03b1 : Type u} {\u03b2 : Type v} (a : \u03b1) (k : USize \u2192 \u03b2) (h : \u2200 u\u2081 u\u2082, k u\u2081 = k u\u2082) : \u03b2 := k 0", "start": [73, 1], "end": [74, 104], "kind": "commanddeclaration"}, {"full_name": "outOfBounds", "code": "@[never_extract]\nprivate def outOfBounds [Inhabited \u03b1] : \u03b1 :=\n  panic! \"index out of bounds\"", "start": [76, 1], "end": [78, 31], "kind": "commanddeclaration"}, {"full_name": "getElem!", "code": "@[inline] def getElem! [GetElem cont idx elem dom] [Inhabited elem] (xs : cont) (i : idx) [Decidable (dom xs i)] : elem :=\n  if h : _ then getElem xs i h else outOfBounds", "start": [80, 1], "end": [81, 48], "kind": "commanddeclaration"}, {"full_name": "getElem?", "code": "@[inline] def getElem? [GetElem cont idx elem dom] (xs : cont) (i : idx) [Decidable (dom xs i)] : Option elem :=\n  if h : _ then some (getElem xs i h) else none", "start": [83, 1], "end": [84, 48], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/UInt/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Fin/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean", "lake-packages/lean4/src/lean/Init/Util.lean", "lake-packages/lean4/src/lean/Init/Data/Repr.lean", "lake-packages/lean4/src/lean/Init/WFTactics.lean"], "premises": [{"full_name": "Array.mkArray", "code": "@[extern \"lean_mk_array\"]\ndef mkArray {\u03b1 : Type u} (n : Nat) (v : \u03b1) : Array \u03b1 := {\n  data := List.replicate n v\n}", "start": [19, 1], "end": [22, 2], "kind": "commanddeclaration"}, {"full_name": "Array.size_mkArray", "code": "@[simp] theorem size_mkArray (n : Nat) (v : \u03b1) : (mkArray n v).size = n", "start": [24, 1], "end": [25, 27], "kind": "commanddeclaration"}, {"full_name": "Array.isEmpty", "code": "def isEmpty (a : Array \u03b1) : Bool :=\n  a.size = 0", "start": [31, 1], "end": [32, 13], "kind": "commanddeclaration"}, {"full_name": "Array.singleton", "code": "def singleton (v : \u03b1) : Array \u03b1 :=\n  mkArray 1 v", "start": [34, 1], "end": [35, 14], "kind": "commanddeclaration"}, {"full_name": "Array.uget", "code": "@[extern \"lean_array_uget\"]\ndef uget (a : @& Array \u03b1) (i : USize) (h : i.toNat < a.size) : \u03b1 :=\n  a[i.toNat]", "start": [37, 1], "end": [42, 13], "kind": "commanddeclaration"}, {"full_name": "Array.back", "code": "def back [Inhabited \u03b1] (a : Array \u03b1) : \u03b1 :=\n  a.get! (a.size - 1)", "start": [47, 1], "end": [48, 22], "kind": "commanddeclaration"}, {"full_name": "Array.get?", "code": "def get? (a : Array \u03b1) (i : Nat) : Option \u03b1 :=\n  if h : i < a.size then some a[i] else none", "start": [50, 1], "end": [51, 45], "kind": "commanddeclaration"}, {"full_name": "Array.back?", "code": "def back? (a : Array \u03b1) : Option \u03b1 :=\n  a.get? (a.size - 1)", "start": [53, 1], "end": [54, 22], "kind": "commanddeclaration"}, {"full_name": "Array.getLit", "code": "abbrev getLit {\u03b1 : Type u} {n : Nat} (a : Array \u03b1) (i : Nat) (h\u2081 : a.size = n) (h\u2082 : i < n) : \u03b1 :=\n  have := h\u2081.symm \u25b8 h\u2082\n  a[i]", "start": [57, 1], "end": [59, 7], "kind": "commanddeclaration"}, {"full_name": "Array.size_set", "code": "@[simp] theorem size_set (a : Array \u03b1) (i : Fin a.size) (v : \u03b1) : (set a i v).size = a.size", "start": [61, 1], "end": [62, 21], "kind": "commanddeclaration"}, {"full_name": "Array.size_push", "code": "@[simp] theorem size_push (a : Array \u03b1) (v : \u03b1) : (push a v).size = a.size + 1", "start": [64, 1], "end": [65, 24], "kind": "commanddeclaration"}, {"full_name": "Array.uset", "code": "@[extern \"lean_array_uset\"]\ndef uset (a : Array \u03b1) (i : USize) (v : \u03b1) (h : i.toNat < a.size) : Array \u03b1 :=\n  a.set \u27e8i.toNat, h\u27e9 v", "start": [67, 1], "end": [72, 23], "kind": "commanddeclaration"}, {"full_name": "Array.swap", "code": "@[extern \"lean_array_fswap\"]\ndef swap (a : Array \u03b1) (i j : @& Fin a.size) : Array \u03b1 :=\n  let v\u2081 := a.get i\n  let v\u2082 := a.get j\n  let a'  := a.set i v\u2082\n  a'.set (size_set a i v\u2082 \u25b8 j) v\u2081", "start": [74, 1], "end": [79, 34], "kind": "commanddeclaration"}, {"full_name": "Array.swap!", "code": "@[extern \"lean_array_swap\"]\ndef swap! (a : Array \u03b1) (i j : @& Nat) : Array \u03b1 :=\n  if h\u2081 : i < a.size then\n  if h\u2082 : j < a.size then swap a \u27e8i, h\u2081\u27e9 \u27e8j, h\u2082\u27e9\n  else panic! \"index out of bounds\"\n  else panic! \"index out of bounds\"", "start": [81, 1], "end": [86, 36], "kind": "commanddeclaration"}, {"full_name": "Array.swapAt", "code": "@[inline] def swapAt (a : Array \u03b1) (i : Fin a.size) (v : \u03b1) : \u03b1 \u00d7 Array \u03b1 :=\n  let e := a.get i\n  let a := a.set i v\n  (e, a)", "start": [88, 1], "end": [91, 9], "kind": "commanddeclaration"}, {"full_name": "Array.swapAt!", "code": "@[inline]\ndef swapAt! (a : Array \u03b1) (i : Nat) (v : \u03b1) : \u03b1 \u00d7 Array \u03b1 :=\n  if h : i < a.size then\n    swapAt a \u27e8i, h\u27e9 v\n  else\n    have : Inhabited \u03b1 := \u27e8v\u27e9\n    panic! (\"index \" ++ toString i ++ \" out of bounds\")", "start": [93, 1], "end": [99, 56], "kind": "commanddeclaration"}, {"full_name": "Array.pop", "code": "@[extern \"lean_array_pop\"]\ndef pop (a : Array \u03b1) : Array \u03b1 := {\n  data := a.data.dropLast\n}", "start": [101, 1], "end": [104, 2], "kind": "commanddeclaration"}, {"full_name": "Array.shrink", "code": "def shrink (a : Array \u03b1) (n : Nat) : Array \u03b1 :=\n  let rec loop\n    | 0,   a => a\n    | n+1, a => loop n a.pop\n  loop (a.size - n) a", "start": [106, 1], "end": [110, 22], "kind": "commanddeclaration"}, {"full_name": "Array.modifyMUnsafe", "code": "@[inline]\nunsafe def modifyMUnsafe [Monad m] (a : Array \u03b1) (i : Nat) (f : \u03b1 \u2192 m \u03b1) : m (Array \u03b1) := do\n  if h : i < a.size then\n    let idx : Fin a.size := \u27e8i, h\u27e9\n    let v                := a.get idx\n    let a'               := a.set idx (unsafeCast ())\n    let v \u2190 f v\n    pure <| a'.set (size_set a .. \u25b8 idx) v\n  else\n    pure a", "start": [112, 1], "end": [124, 11], "kind": "commanddeclaration"}, {"full_name": "Array.modifyM", "code": "@[implemented_by modifyMUnsafe]\ndef modifyM [Monad m] (a : Array \u03b1) (i : Nat) (f : \u03b1 \u2192 m \u03b1) : m (Array \u03b1) := do\n  if h : i < a.size then\n    let idx := \u27e8i, h\u27e9\n    let v   := a.get idx\n    let v \u2190 f v\n    pure <| a.set idx v\n  else\n    pure a", "start": [126, 1], "end": [134, 11], "kind": "commanddeclaration"}, {"full_name": "Array.modify", "code": "@[inline]\ndef modify (a : Array \u03b1) (i : Nat) (f : \u03b1 \u2192 \u03b1) : Array \u03b1 :=\n  Id.run <| modifyM a i f", "start": [136, 1], "end": [138, 26], "kind": "commanddeclaration"}, {"full_name": "Array.modifyOp", "code": "@[inline]\ndef modifyOp (self : Array \u03b1) (idx : Nat) (f : \u03b1 \u2192 \u03b1) : Array \u03b1 :=\n  self.modify idx f", "start": [140, 1], "end": [142, 20], "kind": "commanddeclaration"}, {"full_name": "Array.forInUnsafe", "code": "@[inline] unsafe def forInUnsafe {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : Array \u03b1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let sz := USize.ofNat as.size\n  let rec @[specialize] loop (i : USize) (b : \u03b2) : m \u03b2 := do\n    if i < sz then\n      let a := as.uget i lcProof\n      match (\u2190 f a b) with\n      | ForInStep.done  b => pure b\n      | ForInStep.yield b => loop (i+1) b\n    else\n      pure b\n  loop 0 b", "start": [144, 1], "end": [158, 11], "kind": "commanddeclaration"}, {"full_name": "Array.forIn", "code": "@[implemented_by Array.forInUnsafe]\nprotected def forIn {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : Array \u03b1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let rec loop (i : Nat) (h : i \u2264 as.size) (b : \u03b2) : m \u03b2 := do\n    match i, h with\n    | 0,   _ => pure b\n    | i+1, h =>\n      have h' : i < as.size            := Nat.lt_of_lt_of_le (Nat.lt_succ_self i) h\n      have : as.size - 1 < as.size     := Nat.sub_lt (Nat.zero_lt_of_lt h') (by decide)\n      have : as.size - 1 - i < as.size := Nat.lt_of_le_of_lt (Nat.sub_le (as.size - 1) i) this\n      match (\u2190 f as[as.size - 1 - i] b) with\n      | ForInStep.done b  => pure b\n      | ForInStep.yield b => loop i (Nat.le_of_lt h') b\n  loop as.size (Nat.le_refl _) b", "start": [160, 1], "end": [173, 33], "kind": "commanddeclaration"}, {"full_name": "Array.foldlMUnsafe", "code": "@[inline]\nunsafe def foldlMUnsafe {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (init : \u03b2) (as : Array \u03b1) (start := 0) (stop := as.size) : m \u03b2 :=\n  let rec @[specialize] fold (i : USize) (stop : USize) (b : \u03b2) : m \u03b2 := do\n    if i == stop then\n      pure b\n    else\n      fold (i+1) stop (\u2190 f b (as.uget i lcProof))\n  if start < stop then\n    if stop \u2264 as.size then\n      fold (USize.ofNat start) (USize.ofNat stop) init\n    else\n      pure init\n  else\n    pure init", "start": [178, 1], "end": [192, 14], "kind": "commanddeclaration"}, {"full_name": "Array.foldlM", "code": "@[implemented_by foldlMUnsafe]\ndef foldlM {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (init : \u03b2) (as : Array \u03b1) (start := 0) (stop := as.size) : m \u03b2 :=\n  let fold (stop : Nat) (h : stop \u2264 as.size) :=\n    let rec loop (i : Nat) (j : Nat) (b : \u03b2) : m \u03b2 := do\n      if hlt : j < stop then\n        match i with\n        | 0    => pure b\n        | i'+1 =>\n          have : j < as.size := Nat.lt_of_lt_of_le hlt h\n          loop i' (j+1) (\u2190 f b as[j])\n      else\n        pure b\n    loop (stop - start) start init\n  if h : stop \u2264 as.size then\n    fold stop h\n  else\n    fold as.size (Nat.le_refl _)", "start": [194, 1], "end": [211, 33], "kind": "commanddeclaration"}, {"full_name": "Array.foldrMUnsafe", "code": "@[inline]\nunsafe def foldrMUnsafe {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (init : \u03b2) (as : Array \u03b1) (start := as.size) (stop := 0) : m \u03b2 :=\n  let rec @[specialize] fold (i : USize) (stop : USize) (b : \u03b2) : m \u03b2 := do\n    if i == stop then\n      pure b\n    else\n      fold (i-1) stop (\u2190 f (as.uget (i-1) lcProof) b)\n  if start \u2264 as.size then\n    if stop < start then\n      fold (USize.ofNat start) (USize.ofNat stop) init\n    else\n      pure init\n  else if stop < as.size then\n    fold (USize.ofNat as.size) (USize.ofNat stop) init\n  else\n    pure init", "start": [213, 1], "end": [229, 14], "kind": "commanddeclaration"}, {"full_name": "Array.foldrM", "code": "@[implemented_by foldrMUnsafe]\ndef foldrM {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (init : \u03b2) (as : Array \u03b1) (start := as.size) (stop := 0) : m \u03b2 :=\n  let rec fold (i : Nat) (h : i \u2264 as.size) (b : \u03b2) : m \u03b2 := do\n    if i == stop then\n      pure b\n    else match i, h with\n      | 0, _   => pure b\n      | i+1, h =>\n        have : i < as.size := Nat.lt_of_lt_of_le (Nat.lt_succ_self _) h\n        fold i (Nat.le_of_lt this) (\u2190 f as[i] b)\n  if h : start \u2264 as.size then\n    if stop < start then\n      fold start h init\n    else\n      pure init\n  else if stop < as.size then\n    fold as.size (Nat.le_refl _) init\n  else\n    pure init", "start": [231, 1], "end": [250, 14], "kind": "commanddeclaration"}, {"full_name": "Array.mapMUnsafe", "code": "@[inline]\nunsafe def mapMUnsafe {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 m \u03b2) (as : Array \u03b1) : m (Array \u03b2) :=\n  let sz := USize.ofNat as.size\n  let rec @[specialize] map (i : USize) (r : Array NonScalar) : m (Array PNonScalar.{v}) := do\n    if i < sz then\n     let v    := r.uget i lcProof\n     let r    := r.uset i default lcProof\n     let vNew \u2190 f (unsafeCast v)\n     map (i+1) (r.uset i (unsafeCast vNew) lcProof)\n    else\n     pure (unsafeCast r)\n  unsafeCast <| map 0 (unsafeCast as)", "start": [252, 1], "end": [267, 38], "kind": "commanddeclaration"}, {"full_name": "Array.mapM", "code": "@[implemented_by mapMUnsafe]\ndef mapM {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 m \u03b2) (as : Array \u03b1) : m (Array \u03b2) :=\n  let rec map (i : Nat) (r : Array \u03b2) : m (Array \u03b2) := do\n    if hlt : i < as.size then\n      map (i+1) (r.push (\u2190 f as[i]))\n    else\n      pure r\n  map 0 (mkEmpty as.size)\ntermination_by map => as.size - i", "start": [269, 1], "end": [280, 34], "kind": "commanddeclaration"}, {"full_name": "Array.mapIdxM", "code": "@[inline]\ndef mapIdxM {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : Array \u03b1) (f : Fin as.size \u2192 \u03b1 \u2192 m \u03b2) : m (Array \u03b2) :=\n  let rec @[specialize] map (i : Nat) (j : Nat) (inv : i + j = as.size) (bs : Array \u03b2) : m (Array \u03b2) := do\n    match i, inv with\n    | 0,    _  => pure bs\n    | i+1, inv =>\n      have : j < as.size := by\n        rw [\u2190 inv, Nat.add_assoc, Nat.add_comm 1 j, Nat.add_comm]\n        apply Nat.le_add_right\n      let idx : Fin as.size := \u27e8j, this\u27e9\n      have : i + (j + 1) = as.size := by rw [\u2190 inv, Nat.add_comm j 1, Nat.add_assoc]\n      map i (j+1) this (bs.push (\u2190 f idx (as.get idx)))\n  map as.size 0 rfl (mkEmpty as.size)", "start": [282, 1], "end": [294, 38], "kind": "commanddeclaration"}, {"full_name": "Array.findSomeM?", "code": "@[inline]\ndef findSomeM? {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : Array \u03b1) (f : \u03b1 \u2192 m (Option \u03b2)) : m (Option \u03b2) := do\n  for a in as do\n    match (\u2190 f a) with\n    | some b => return b\n    | _      => pure \u27e8\u27e9\n  return none", "start": [296, 1], "end": [302, 14], "kind": "commanddeclaration"}, {"full_name": "Array.findM?", "code": "@[inline]\ndef findM? {\u03b1 : Type} {m : Type \u2192 Type} [Monad m] (as : Array \u03b1) (p : \u03b1 \u2192 m Bool) : m (Option \u03b1) := do\n  for a in as do\n    if (\u2190 p a) then\n      return a\n  return none", "start": [304, 1], "end": [309, 14], "kind": "commanddeclaration"}, {"full_name": "Array.findIdxM?", "code": "@[inline]\ndef findIdxM? [Monad m] (as : Array \u03b1) (p : \u03b1 \u2192 m Bool) : m (Option Nat) := do\n  let mut i := 0\n  for a in as do\n    if (\u2190 p a) then\n      return some i\n    i := i + 1\n  return none", "start": [311, 1], "end": [318, 14], "kind": "commanddeclaration"}, {"full_name": "Array.anyMUnsafe", "code": "@[inline]\nunsafe def anyMUnsafe {\u03b1 : Type u} {m : Type \u2192 Type w} [Monad m] (p : \u03b1 \u2192 m Bool) (as : Array \u03b1) (start := 0) (stop := as.size) : m Bool :=\n  let rec @[specialize] any (i : USize) (stop : USize) : m Bool := do\n    if i == stop then\n      pure false\n    else\n      if (\u2190 p (as.uget i lcProof)) then\n        pure true\n      else\n        any (i+1) stop\n  if start < stop then\n    let stop' := min stop as.size\n    if start < stop' then\n      any (USize.ofNat start) (USize.ofNat stop')\n    else\n      pure false\n  else\n    pure false", "start": [320, 1], "end": [337, 15], "kind": "commanddeclaration"}, {"full_name": "Array.anyM", "code": "@[implemented_by anyMUnsafe]\ndef anyM {\u03b1 : Type u} {m : Type \u2192 Type w} [Monad m] (p : \u03b1 \u2192 m Bool) (as : Array \u03b1) (start := 0) (stop := as.size) : m Bool :=\n  let any (stop : Nat) (h : stop \u2264 as.size) :=\n    let rec loop (j : Nat) : m Bool := do\n      if hlt : j < stop then\n        have : j < as.size := Nat.lt_of_lt_of_le hlt h\n        if (\u2190 p as[j]) then\n          pure true\n        else\n          loop (j+1)\n      else\n        pure false\n    loop start\n  if h : stop \u2264 as.size then\n    any stop h\n  else\n    any as.size (Nat.le_refl _)\ntermination_by loop i j => stop - j", "start": [339, 1], "end": [356, 36], "kind": "commanddeclaration"}, {"full_name": "Array.allM", "code": "@[inline]\ndef allM {\u03b1 : Type u} {m : Type \u2192 Type w} [Monad m] (p : \u03b1 \u2192 m Bool) (as : Array \u03b1) (start := 0) (stop := as.size) : m Bool :=\n  return !(\u2190 as.anyM (start := start) (stop := stop) fun v => return !(\u2190 p v))", "start": [358, 1], "end": [360, 79], "kind": "commanddeclaration"}, {"full_name": "Array.findSomeRevM?", "code": "@[inline]\ndef findSomeRevM? {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : Array \u03b1) (f : \u03b1 \u2192 m (Option \u03b2)) : m (Option \u03b2) :=\n  let rec @[specialize] find : (i : Nat) \u2192 i \u2264 as.size \u2192 m (Option \u03b2)\n    | 0,   _ => pure none\n    | i+1, h => do\n      have : i < as.size := Nat.lt_of_lt_of_le (Nat.lt_succ_self _) h\n      let r \u2190 f as[i]\n      match r with\n      | some _ => pure r\n      | none   =>\n        have : i \u2264 as.size := Nat.le_of_lt this\n        find i this\n  find as.size (Nat.le_refl _)", "start": [362, 1], "end": [374, 31], "kind": "commanddeclaration"}, {"full_name": "Array.findRevM?", "code": "@[inline]\ndef findRevM? {\u03b1 : Type} {m : Type \u2192 Type w} [Monad m] (as : Array \u03b1) (p : \u03b1 \u2192 m Bool) : m (Option \u03b1) :=\n  as.findSomeRevM? fun a => return if (\u2190 p a) then some a else none", "start": [376, 1], "end": [378, 68], "kind": "commanddeclaration"}, {"full_name": "Array.forM", "code": "@[inline]\ndef forM {\u03b1 : Type u} {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 m PUnit) (as : Array \u03b1) (start := 0) (stop := as.size) : m PUnit :=\n  as.foldlM (fun _ => f) \u27e8\u27e9 start stop", "start": [380, 1], "end": [382, 39], "kind": "commanddeclaration"}, {"full_name": "Array.forRevM", "code": "@[inline]\ndef forRevM {\u03b1 : Type u} {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 m PUnit) (as : Array \u03b1) (start := as.size) (stop := 0) : m PUnit :=\n  as.foldrM (fun a _ => f a) \u27e8\u27e9 start stop", "start": [384, 1], "end": [386, 43], "kind": "commanddeclaration"}, {"full_name": "Array.foldl", "code": "@[inline]\ndef foldl {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (init : \u03b2) (as : Array \u03b1) (start := 0) (stop := as.size) : \u03b2 :=\n  Id.run <| as.foldlM f init start stop", "start": [388, 1], "end": [390, 40], "kind": "commanddeclaration"}, {"full_name": "Array.foldr", "code": "@[inline]\ndef foldr {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) (as : Array \u03b1) (start := as.size) (stop := 0) : \u03b2 :=\n  Id.run <| as.foldrM f init start stop", "start": [392, 1], "end": [394, 40], "kind": "commanddeclaration"}, {"full_name": "Array.map", "code": "@[inline]\ndef map {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (as : Array \u03b1) : Array \u03b2 :=\n  Id.run <| as.mapM f", "start": [396, 1], "end": [398, 22], "kind": "commanddeclaration"}, {"full_name": "Array.mapIdx", "code": "@[inline]\ndef mapIdx {\u03b1 : Type u} {\u03b2 : Type v} (as : Array \u03b1) (f : Fin as.size \u2192 \u03b1 \u2192 \u03b2) : Array \u03b2 :=\n  Id.run <| as.mapIdxM f", "start": [400, 1], "end": [402, 25], "kind": "commanddeclaration"}, {"full_name": "Array.find?", "code": "@[inline]\ndef find? {\u03b1 : Type} (as : Array \u03b1) (p : \u03b1 \u2192 Bool) : Option \u03b1 :=\n  Id.run <| as.findM? p", "start": [404, 1], "end": [406, 24], "kind": "commanddeclaration"}, {"full_name": "Array.findSome?", "code": "@[inline]\ndef findSome? {\u03b1 : Type u} {\u03b2 : Type v} (as : Array \u03b1) (f : \u03b1 \u2192 Option \u03b2) : Option \u03b2 :=\n  Id.run <| as.findSomeM? f", "start": [408, 1], "end": [410, 28], "kind": "commanddeclaration"}, {"full_name": "Array.findSome!", "code": "@[inline]\ndef findSome! {\u03b1 : Type u} {\u03b2 : Type v} [Inhabited \u03b2] (a : Array \u03b1) (f : \u03b1 \u2192 Option \u03b2) : \u03b2 :=\n  match findSome? a f with\n  | some b => b\n  | none   => panic! \"failed to find element\"", "start": [412, 1], "end": [416, 46], "kind": "commanddeclaration"}, {"full_name": "Array.findSomeRev?", "code": "@[inline]\ndef findSomeRev? {\u03b1 : Type u} {\u03b2 : Type v} (as : Array \u03b1) (f : \u03b1 \u2192 Option \u03b2) : Option \u03b2 :=\n  Id.run <| as.findSomeRevM? f", "start": [418, 1], "end": [420, 31], "kind": "commanddeclaration"}, {"full_name": "Array.findRev?", "code": "@[inline]\ndef findRev? {\u03b1 : Type} (as : Array \u03b1) (p : \u03b1 \u2192 Bool) : Option \u03b1 :=\n  Id.run <| as.findRevM? p", "start": [422, 1], "end": [424, 27], "kind": "commanddeclaration"}, {"full_name": "Array.findIdx?", "code": "@[inline]\ndef findIdx? {\u03b1 : Type u} (as : Array \u03b1) (p : \u03b1 \u2192 Bool) : Option Nat :=\n  let rec loop (i : Nat) (j : Nat) (inv : i + j = as.size) : Option Nat :=\n    if hlt : j < as.size then\n      match i, inv with\n      | 0, inv => by\n        apply False.elim\n        rw [Nat.zero_add] at inv\n        rw [inv] at hlt\n        exact absurd hlt (Nat.lt_irrefl _)\n      | i+1, inv =>\n        if p as[j] then\n          some j\n        else\n          have : i + (j+1) = as.size := by\n            rw [\u2190 inv, Nat.add_comm j 1, Nat.add_assoc]\n          loop i (j+1) this\n    else\n      none\n  loop as.size 0 rfl", "start": [426, 1], "end": [445, 21], "kind": "commanddeclaration"}, {"full_name": "Array.getIdx?", "code": "def getIdx? [BEq \u03b1] (a : Array \u03b1) (v : \u03b1) : Option Nat :=\na.findIdx? fun a => a == v", "start": [447, 1], "end": [448, 27], "kind": "commanddeclaration"}, {"full_name": "Array.any", "code": "@[inline]\ndef any (as : Array \u03b1) (p : \u03b1 \u2192 Bool) (start := 0) (stop := as.size) : Bool :=\n  Id.run <| as.anyM p start stop", "start": [450, 1], "end": [452, 33], "kind": "commanddeclaration"}, {"full_name": "Array.all", "code": "@[inline]\ndef all (as : Array \u03b1) (p : \u03b1 \u2192 Bool) (start := 0) (stop := as.size) : Bool :=\n  Id.run <| as.allM p start stop", "start": [454, 1], "end": [456, 33], "kind": "commanddeclaration"}, {"full_name": "Array.contains", "code": "def contains [BEq \u03b1] (as : Array \u03b1) (a : \u03b1) : Bool :=\n  as.any fun b => a == b", "start": [458, 1], "end": [459, 25], "kind": "commanddeclaration"}, {"full_name": "Array.elem", "code": "def elem [BEq \u03b1] (a : \u03b1) (as : Array \u03b1) : Bool :=\n  as.contains a", "start": [461, 1], "end": [462, 16], "kind": "commanddeclaration"}, {"full_name": "Array.getEvenElems", "code": "@[inline] def getEvenElems (as : Array \u03b1) : Array \u03b1 :=\n  (\u00b7.2) <| as.foldl (init := (true, Array.empty)) fun (even, r) a =>\n    if even then\n      (false, r.push a)\n    else\n      (true, r)", "start": [464, 1], "end": [469, 16], "kind": "commanddeclaration"}, {"full_name": "Array.toList", "code": "@[export lean_array_to_list]\ndef toList (as : Array \u03b1) : List \u03b1 :=\n  as.foldr List.cons []", "start": [471, 1], "end": [473, 24], "kind": "commanddeclaration"}, {"full_name": "Array.append", "code": "protected def append (as : Array \u03b1) (bs : Array \u03b1) : Array \u03b1 :=\n  bs.foldl (init := as) fun r v => r.push v", "start": [486, 1], "end": [487, 44], "kind": "commanddeclaration"}, {"full_name": "Array.appendList", "code": "protected def appendList (as : Array \u03b1) (bs : List \u03b1) : Array \u03b1 :=\n  bs.foldl (init := as) fun r v => r.push v", "start": [491, 1], "end": [492, 44], "kind": "commanddeclaration"}, {"full_name": "Array.concatMapM", "code": "@[inline]\ndef concatMapM [Monad m] (f : \u03b1 \u2192 m (Array \u03b2)) (as : Array \u03b1) : m (Array \u03b2) :=\n  as.foldlM (init := empty) fun bs a => do return bs ++ (\u2190 f a)", "start": [496, 1], "end": [498, 64], "kind": "commanddeclaration"}, {"full_name": "Array.concatMap", "code": "@[inline]\ndef concatMap (f : \u03b1 \u2192 Array \u03b2) (as : Array \u03b1) : Array \u03b2 :=\n  as.foldl (init := empty) fun bs a => bs ++ f a", "start": [500, 1], "end": [502, 49], "kind": "commanddeclaration"}, {"full_name": "Array.isEqvAux", "code": "@[specialize]\ndef isEqvAux (a b : Array \u03b1) (hsz : a.size = b.size) (p : \u03b1 \u2192 \u03b1 \u2192 Bool) (i : Nat) : Bool :=\n  if h : i < a.size then\n     have : i < b.size := hsz \u25b8 h\n     p a[i] b[i] && isEqvAux a b hsz p (i+1)\n  else\n    true\ntermination_by _ => a.size - i", "start": [516, 1], "end": [523, 31], "kind": "commanddeclaration"}, {"full_name": "Array.isEqv", "code": "@[inline] def isEqv (a b : Array \u03b1) (p : \u03b1 \u2192 \u03b1 \u2192 Bool) : Bool :=\n  if h : a.size = b.size then\n    isEqvAux a b h p 0\n  else\n    false", "start": [525, 1], "end": [529, 10], "kind": "commanddeclaration"}, {"full_name": "Array.filter", "code": "@[inline]\ndef filter (p : \u03b1 \u2192 Bool) (as : Array \u03b1) (start := 0) (stop := as.size) : Array \u03b1 :=\n  as.foldl (init := #[]) (start := start) (stop := stop) fun r a =>\n    if p a then r.push a else r", "start": [534, 1], "end": [537, 32], "kind": "commanddeclaration"}, {"full_name": "Array.filterM", "code": "@[inline]\ndef filterM [Monad m] (p : \u03b1 \u2192 m Bool) (as : Array \u03b1) (start := 0) (stop := as.size) : m (Array \u03b1) :=\n  as.foldlM (init := #[]) (start := start) (stop := stop) fun r a => do\n    if (\u2190 p a) then return r.push a else return r", "start": [539, 1], "end": [542, 50], "kind": "commanddeclaration"}, {"full_name": "Array.filterMapM", "code": "@[specialize]\ndef filterMapM [Monad m] (f : \u03b1 \u2192 m (Option \u03b2)) (as : Array \u03b1) (start := 0) (stop := as.size) : m (Array \u03b2) :=\n  as.foldlM (init := #[]) (start := start) (stop := stop) fun bs a => do\n    match (\u2190 f a) with\n    | some b => pure (bs.push b)\n    | none   => pure bs", "start": [544, 1], "end": [549, 24], "kind": "commanddeclaration"}, {"full_name": "Array.filterMap", "code": "@[inline]\ndef filterMap (f : \u03b1 \u2192 Option \u03b2) (as : Array \u03b1) (start := 0) (stop := as.size) : Array \u03b2 :=\n  Id.run <| as.filterMapM f (start := start) (stop := stop)", "start": [551, 1], "end": [553, 60], "kind": "commanddeclaration"}, {"full_name": "Array.getMax?", "code": "@[specialize]\ndef getMax? (as : Array \u03b1) (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) : Option \u03b1 :=\n  if h : 0 < as.size then\n    let a0 := as[0]\n    some <| as.foldl (init := a0) (start := 1) fun best a =>\n      if lt best a then a else best\n  else\n    none", "start": [555, 1], "end": [562, 9], "kind": "commanddeclaration"}, {"full_name": "Array.partition", "code": "@[inline]\ndef partition (p : \u03b1 \u2192 Bool) (as : Array \u03b1) : Array \u03b1 \u00d7 Array \u03b1 := Id.run do\n  let mut bs := #[]\n  let mut cs := #[]\n  for a in as do\n    if p a then\n      bs := bs.push a\n    else\n      cs := cs.push a\n  return (bs, cs)", "start": [564, 1], "end": [573, 18], "kind": "commanddeclaration"}, {"full_name": "Array.ext", "code": "theorem ext (a b : Array \u03b1)\n    (h\u2081 : a.size = b.size)\n    (h\u2082 : (i : Nat) \u2192 (hi\u2081 : i < a.size) \u2192 (hi\u2082 : i < b.size) \u2192 a[i] = b[i])\n    : a = b", "start": [575, 1], "end": [608, 13], "kind": "commanddeclaration"}, {"full_name": "Array.extLit", "code": "theorem extLit {n : Nat}\n    (a b : Array \u03b1)\n    (hsz\u2081 : a.size = n) (hsz\u2082 : b.size = n)\n    (h : (i : Nat) \u2192 (hi : i < n) \u2192 a.getLit i hsz\u2081 hi = b.getLit i hsz\u2082 hi) : a = b", "start": [610, 1], "end": [614, 71], "kind": "commanddeclaration"}, {"full_name": "Array.indexOfAux", "code": "def indexOfAux [BEq \u03b1] (a : Array \u03b1) (v : \u03b1) (i : Nat) : Option (Fin a.size) :=\n  if h : i < a.size then\n    let idx : Fin a.size := \u27e8i, h\u27e9;\n    if a.get idx == v then some idx\n    else indexOfAux a v (i+1)\n  else none\ntermination_by _ => a.size - i", "start": [621, 1], "end": [627, 31], "kind": "commanddeclaration"}, {"full_name": "Array.indexOf?", "code": "def indexOf? [BEq \u03b1] (a : Array \u03b1) (v : \u03b1) : Option (Fin a.size) :=\n  indexOfAux a v 0", "start": [629, 1], "end": [630, 19], "kind": "commanddeclaration"}, {"full_name": "Array.size_swap", "code": "@[simp] theorem size_swap (a : Array \u03b1) (i j : Fin a.size) : (a.swap i j).size = a.size", "start": [632, 1], "end": [634, 26], "kind": "commanddeclaration"}, {"full_name": "Array.size_pop", "code": "@[simp] theorem size_pop (a : Array \u03b1) : a.pop.size = a.size - 1", "start": [636, 1], "end": [639, 58], "kind": "commanddeclaration"}, {"full_name": "Array.reverse.termination", "code": "theorem reverse.termination {i j : Nat} (h : i < j) : j - 1 - (i + 1) < j - i", "start": [641, 1], "end": [643, 72], "kind": "commanddeclaration"}, {"full_name": "Array.reverse", "code": "def reverse (as : Array \u03b1) : Array \u03b1 :=\n  if h : as.size \u2264 1 then\n    as\n  else\n    loop as 0 \u27e8as.size - 1, Nat.pred_lt (mt (fun h : as.size = 0 => h \u25b8 by decide) h)\u27e9\nwhere\n  loop (as : Array \u03b1) (i : Nat) (j : Fin as.size) :=\n    if h : i < j then\n      have := reverse.termination h\n      let as := as.swap \u27e8i, Nat.lt_trans h j.2\u27e9 j\n      have : j-1 < as.size := by rw [size_swap]; exact Nat.lt_of_le_of_lt (Nat.pred_le _) j.2\n      loop as (i+1) \u27e8j-1, this\u27e9\n    else\n      as\ntermination_by _ => j - i", "start": [645, 1], "end": [659, 26], "kind": "commanddeclaration"}, {"full_name": "Array.popWhile", "code": "def popWhile (p : \u03b1 \u2192 Bool) (as : Array \u03b1) : Array \u03b1 :=\n  if h : as.size > 0 then\n    if p (as.get \u27e8as.size - 1, Nat.sub_lt h (by decide)\u27e9) then\n      popWhile p as.pop\n    else\n      as\n  else\n    as\ntermination_by popWhile as => as.size", "start": [661, 1], "end": [669, 38], "kind": "commanddeclaration"}, {"full_name": "Array.takeWhile", "code": "def takeWhile (p : \u03b1 \u2192 Bool) (as : Array \u03b1) : Array \u03b1 :=\n  let rec go (i : Nat) (r : Array \u03b1) : Array \u03b1 :=\n    if h : i < as.size then\n      let a := as.get \u27e8i, h\u27e9\n      if p a then\n        go (i+1) (r.push a)\n      else\n        r\n    else\n      r\n  go 0 #[]\ntermination_by go i r => as.size - i", "start": [671, 1], "end": [682, 37], "kind": "commanddeclaration"}, {"full_name": "Array.eraseIdxAux", "code": "def eraseIdxAux (i : Nat) (a : Array \u03b1) : Array \u03b1 :=\n  if h : i < a.size then\n    let idx  : Fin a.size := \u27e8i, h\u27e9;\n    let idx1 : Fin a.size := \u27e8i - 1, by exact Nat.lt_of_le_of_lt (Nat.pred_le i) h\u27e9;\n    let a' := a.swap idx idx1\n    eraseIdxAux (i+1) a'\n  else\n    a.pop\ntermination_by _ => a.size - i", "start": [684, 1], "end": [692, 31], "kind": "commanddeclaration"}, {"full_name": "Array.feraseIdx", "code": "def feraseIdx (a : Array \u03b1) (i : Fin a.size) : Array \u03b1 :=\n  eraseIdxAux (i.val + 1) a", "start": [694, 1], "end": [695, 28], "kind": "commanddeclaration"}, {"full_name": "Array.eraseIdx", "code": "def eraseIdx (a : Array \u03b1) (i : Nat) : Array \u03b1 :=\n  if i < a.size then eraseIdxAux (i+1) a else a", "start": [697, 1], "end": [698, 48], "kind": "commanddeclaration"}, {"full_name": "Array.eraseIdxSzAux", "code": "def eraseIdxSzAux (a : Array \u03b1) (i : Nat) (r : Array \u03b1) (heq : r.size = a.size) : { r : Array \u03b1 // r.size = a.size - 1 } :=\n  if h : i < r.size then\n    let idx  : Fin r.size := \u27e8i, h\u27e9;\n    let idx1 : Fin r.size := \u27e8i - 1, by exact Nat.lt_of_le_of_lt (Nat.pred_le i) h\u27e9;\n    eraseIdxSzAux a (i+1) (r.swap idx idx1) ((size_swap r idx idx1).trans heq)\n  else\n    \u27e8r.pop, (size_pop r).trans (heq \u25b8 rfl)\u27e9\ntermination_by _ => r.size - i", "start": [700, 1], "end": [707, 31], "kind": "commanddeclaration"}, {"full_name": "Array.eraseIdx'", "code": "def eraseIdx' (a : Array \u03b1) (i : Fin a.size) : { r : Array \u03b1 // r.size = a.size - 1 } :=\n  eraseIdxSzAux a (i.val + 1) a rfl", "start": [709, 1], "end": [710, 36], "kind": "commanddeclaration"}, {"full_name": "Array.erase", "code": "def erase [BEq \u03b1] (as : Array \u03b1) (a : \u03b1) : Array \u03b1 :=\n  match as.indexOf? a with\n  | none   => as\n  | some i => as.feraseIdx i", "start": [712, 1], "end": [715, 29], "kind": "commanddeclaration"}, {"full_name": "Array.insertAt", "code": "@[inline] def insertAt (as : Array \u03b1) (i : Fin (as.size + 1)) (a : \u03b1) : Array \u03b1 :=\n  let rec loop (as : Array \u03b1) (j : Fin as.size) :=\n    if i.1 < j then\n      let j' := \u27e8j-1, Nat.lt_of_le_of_lt (Nat.pred_le _) j.2\u27e9\n      let as := as.swap j' j\n      loop as \u27e8j', by rw [size_swap]; exact j'.2\u27e9\n    else\n      as\n  let j := as.size\n  let as := as.push a\n  loop as \u27e8j, size_push .. \u25b8 j.lt_succ_self\u27e9\ntermination_by loop j => j.1", "start": [717, 1], "end": [729, 29], "kind": "commanddeclaration"}, {"full_name": "Array.insertAt!", "code": "def insertAt! (as : Array \u03b1) (i : Nat) (a : \u03b1) : Array \u03b1 :=\n  if h : i \u2264 as.size then\n    insertAt as \u27e8i, Nat.lt_succ_of_le h\u27e9 a\n  else panic! \"invalid index\"", "start": [731, 1], "end": [735, 30], "kind": "commanddeclaration"}, {"full_name": "Array.toListLitAux", "code": "def toListLitAux (a : Array \u03b1) (n : Nat) (hsz : a.size = n) : \u2200 (i : Nat), i \u2264 a.size \u2192 List \u03b1 \u2192 List \u03b1\n  | 0,     _,  acc => acc\n  | (i+1), hi, acc => toListLitAux a n hsz i (Nat.le_of_succ_le hi) (a.getLit i hsz (Nat.lt_of_lt_of_eq (Nat.lt_of_lt_of_le (Nat.lt_succ_self i) hi) hsz) :: acc)", "start": [737, 1], "end": [739, 162], "kind": "commanddeclaration"}, {"full_name": "Array.toArrayLit", "code": "def toArrayLit (a : Array \u03b1) (n : Nat) (hsz : a.size = n) : Array \u03b1 :=\n  List.toArray <| toListLitAux a n hsz n (hsz \u25b8 Nat.le_refl _) []", "start": [741, 1], "end": [742, 66], "kind": "commanddeclaration"}, {"full_name": "Array.ext'", "code": "theorem ext' {as bs : Array \u03b1} (h : as.data = bs.data) : as = bs", "start": [744, 1], "end": [745, 40], "kind": "commanddeclaration"}, {"full_name": "Array.toArrayAux_eq", "code": "theorem toArrayAux_eq (as : List \u03b1) (acc : Array \u03b1) : (as.toArrayAux acc).data = acc.data ++ as", "start": [747, 1], "end": [748, 116], "kind": "commanddeclaration"}, {"full_name": "Array.data_toArray", "code": "theorem data_toArray (as : List \u03b1) : as.toArray.data = as", "start": [750, 1], "end": [751, 52], "kind": "commanddeclaration"}, {"full_name": "Array.toArrayLit_eq", "code": "theorem toArrayLit_eq (as : Array \u03b1) (n : Nat) (hsz : as.size = n) : as = toArrayLit as n hsz", "start": [753, 1], "end": [766, 85], "kind": "commanddeclaration"}, {"full_name": "Array.isPrefixOfAux", "code": "def isPrefixOfAux [BEq \u03b1] (as bs : Array \u03b1) (hle : as.size \u2264 bs.size) (i : Nat) : Bool :=\n  if h : i < as.size then\n    let a := as[i]\n    have : i < bs.size := Nat.lt_of_lt_of_le h hle\n    let b := bs[i]\n    if a == b then\n      isPrefixOfAux as bs hle (i+1)\n    else\n      false\n  else\n    true\ntermination_by _ => as.size - i", "start": [768, 1], "end": [779, 32], "kind": "commanddeclaration"}, {"full_name": "Array.isPrefixOf", "code": "def isPrefixOf [BEq \u03b1] (as bs : Array \u03b1) : Bool :=\n  if h : as.size \u2264 bs.size then\n    isPrefixOfAux as bs h 0\n  else\n    false", "start": [781, 1], "end": [787, 10], "kind": "commanddeclaration"}, {"full_name": "Array.allDiffAuxAux", "code": "private def allDiffAuxAux [BEq \u03b1] (as : Array \u03b1) (a : \u03b1) : forall (i : Nat), i < as.size \u2192 Bool\n  | 0,   _ => true\n  | i+1, h =>\n    have : i < as.size := Nat.lt_trans (Nat.lt_succ_self _) h;\n    a != as[i] && allDiffAuxAux as a i this", "start": [789, 1], "end": [793, 44], "kind": "commanddeclaration"}, {"full_name": "Array.allDiffAux", "code": "private def allDiffAux [BEq \u03b1] (as : Array \u03b1) (i : Nat) : Bool :=\n  if h : i < as.size then\n    allDiffAuxAux as as[i] i h && allDiffAux as (i+1)\n  else\n    true\ntermination_by _ => as.size - i", "start": [795, 1], "end": [800, 32], "kind": "commanddeclaration"}, {"full_name": "Array.allDiff", "code": "def allDiff [BEq \u03b1] (as : Array \u03b1) : Bool :=\n  allDiffAux as 0", "start": [802, 1], "end": [803, 18], "kind": "commanddeclaration"}, {"full_name": "Array.zipWithAux", "code": "@[specialize] def zipWithAux (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (as : Array \u03b1) (bs : Array \u03b2) (i : Nat) (cs : Array \u03b3) : Array \u03b3 :=\n  if h : i < as.size then\n    let a := as[i]\n    if h : i < bs.size then\n      let b := bs[i]\n      zipWithAux f as bs (i+1) <| cs.push <| f a b\n    else\n      cs\n  else\n    cs\ntermination_by _ => as.size - i", "start": [805, 1], "end": [815, 32], "kind": "commanddeclaration"}, {"full_name": "Array.zipWith", "code": "@[inline] def zipWith (as : Array \u03b1) (bs : Array \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Array \u03b3 :=\n  zipWithAux f as bs 0 #[]", "start": [817, 1], "end": [818, 27], "kind": "commanddeclaration"}, {"full_name": "Array.zip", "code": "def zip (as : Array \u03b1) (bs : Array \u03b2) : Array (\u03b1 \u00d7 \u03b2) :=\n  zipWith as bs Prod.mk", "start": [820, 1], "end": [821, 24], "kind": "commanddeclaration"}, {"full_name": "Array.unzip", "code": "def unzip (as : Array (\u03b1 \u00d7 \u03b2)) : Array \u03b1 \u00d7 Array \u03b2 :=\n  as.foldl (init := (#[], #[])) fun (as, bs) (a, b) => (as.push a, bs.push b)", "start": [823, 1], "end": [824, 78], "kind": "commanddeclaration"}, {"full_name": "Array.split", "code": "def split (as : Array \u03b1) (p : \u03b1 \u2192 Bool) : Array \u03b1 \u00d7 Array \u03b1 :=\n  as.foldl (init := (#[], #[])) fun (as, bs) a =>\n    if p a then (as.push a, bs) else (as, bs.push a)", "start": [826, 1], "end": [828, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Option/BasicAux.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Option/Basic.lean", "lake-packages/lean4/src/lean/Init/Util.lean"], "premises": [{"full_name": "Option.get!", "code": "@[inline] def get! {\u03b1 : Type u} [Inhabited \u03b1] : Option \u03b1 \u2192 \u03b1\n  | some x => x\n  | none   => panic! \"value is none\"", "start": [14, 1], "end": [16, 37], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Meta.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Option/BasicAux.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean"], "premises": [{"full_name": "Lean.version.getMajor", "code": "@[extern \"lean_version_get_major\"]\nprivate opaque version.getMajor (u : Unit) : Nat", "start": [14, 1], "end": [15, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.version.major", "code": "def version.major : Nat := version.getMajor ()", "start": [16, 1], "end": [16, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.version.getMinor", "code": "@[extern \"lean_version_get_minor\"]\nprivate opaque version.getMinor (u : Unit) : Nat", "start": [18, 1], "end": [19, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.version.minor", "code": "def version.minor : Nat := version.getMinor ()", "start": [20, 1], "end": [20, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.version.getPatch", "code": "@[extern \"lean_version_get_patch\"]\nprivate opaque version.getPatch (u : Unit) : Nat", "start": [22, 1], "end": [23, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.version.patch", "code": "def version.patch : Nat := version.getPatch ()", "start": [24, 1], "end": [24, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.getGithash", "code": "@[extern \"lean_get_githash\"]\nopaque getGithash (u : Unit) : String", "start": [26, 1], "end": [27, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.githash", "code": "def githash : String := getGithash ()", "start": [28, 1], "end": [28, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.version.getIsRelease", "code": "@[extern \"lean_version_get_is_release\"]\nopaque version.getIsRelease (u : Unit) : Bool", "start": [30, 1], "end": [31, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.version.isRelease", "code": "def version.isRelease : Bool := version.getIsRelease ()", "start": [32, 1], "end": [32, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.version.getSpecialDesc", "code": "@[extern \"lean_version_get_special_desc\"]\nopaque version.getSpecialDesc (u : Unit) : String", "start": [34, 1], "end": [36, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.version.specialDesc", "code": "def version.specialDesc : String := version.getSpecialDesc ()", "start": [37, 1], "end": [37, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.versionStringCore", "code": "def versionStringCore :=\n  toString version.major ++ \".\" ++ toString version.minor ++ \".\" ++ toString version.patch", "start": [39, 1], "end": [40, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.versionString", "code": "def versionString :=\n  if version.specialDesc \u2260 \"\" then\n    versionStringCore ++ \"-\" ++ version.specialDesc\n  else if version.isRelease then\n    versionStringCore\n  else\n    versionStringCore ++ \", commit \" ++ githash", "start": [42, 1], "end": [48, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.origin", "code": "def origin :=\n  \"leanprover/lean4\"", "start": [50, 1], "end": [51, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.toolchain", "code": "def toolchain :=\n  if version.specialDesc \u2260 \"\"  then\n    if version.isRelease then\n      origin ++ \":\" ++ versionStringCore ++ \"-\" ++ version.specialDesc\n    else\n      origin ++ \":\" ++ version.specialDesc\n  else if version.isRelease then\n    origin ++ \":\" ++ versionStringCore\n  else\n    \"\"", "start": [53, 1], "end": [62, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Internal.isStage0", "code": "@[extern \"lean_internal_is_stage0\"]\nopaque Internal.isStage0 (u : Unit) : Bool", "start": [64, 1], "end": [65, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.isGreek", "code": "def isGreek (c : Char) : Bool :=\n  0x391 \u2264 c.val && c.val \u2264 0x3dd", "start": [67, 1], "end": [69, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.isLetterLike", "code": "def isLetterLike (c : Char) : Bool :=\n  (0x3b1  \u2264 c.val && c.val \u2264 0x3c9 && c.val \u2260 0x3bb) ||                  (0x391  \u2264 c.val && c.val \u2264 0x3A9 && c.val \u2260 0x3A0 && c.val \u2260 0x3A3) || (0x3ca  \u2264 c.val && c.val \u2264 0x3fb) ||                                   (0x1f00 \u2264 c.val && c.val \u2264 0x1ffe) ||                                  (0x2100 \u2264 c.val && c.val \u2264 0x214f) ||                                  (0x1d49c \u2264 c.val && c.val \u2264 0x1d59f)", "start": [71, 1], "end": [77, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.isNumericSubscript", "code": "def isNumericSubscript (c : Char) : Bool :=\n  0x2080 \u2264 c.val && c.val \u2264 0x2089", "start": [79, 1], "end": [80, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.isSubScriptAlnum", "code": "def isSubScriptAlnum (c : Char) : Bool :=\n  isNumericSubscript c ||\n  (0x2090 \u2264 c.val && c.val \u2264 0x209c) ||\n  (0x1d62 \u2264 c.val && c.val \u2264 0x1d6a)", "start": [82, 1], "end": [85, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.isIdFirst", "code": "def isIdFirst (c : Char) : Bool :=\n  c.isAlpha || c = '_' || isLetterLike c", "start": [87, 1], "end": [88, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.isIdRest", "code": "def isIdRest (c : Char) : Bool :=\n  c.isAlphanum || c = '_' || c = '\\'' || c == '!' || c == '?' || isLetterLike c || isSubScriptAlnum c", "start": [90, 1], "end": [91, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.idBeginEscape", "code": "def idBeginEscape := '\u00ab'", "start": [93, 1], "end": [93, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.idEndEscape", "code": "def idEndEscape   := '\u00bb'", "start": [94, 1], "end": [94, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.isIdBeginEscape", "code": "def isIdBeginEscape (c : Char) : Bool := c = idBeginEscape", "start": [95, 1], "end": [95, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.isIdEndEscape", "code": "def isIdEndEscape (c : Char) : Bool := c = idEndEscape", "start": [96, 1], "end": [96, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.getRoot", "code": "def getRoot : Name \u2192 Name\n  | anonymous             => anonymous\n  | n@(str anonymous _) => n\n  | n@(num anonymous _) => n\n  | str n _             => getRoot n\n  | num n _             => getRoot n", "start": [100, 1], "end": [105, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isInaccessibleUserName", "code": "@[export lean_is_inaccessible_user_name]\ndef isInaccessibleUserName : Name \u2192 Bool\n  | Name.str _ s   => s.contains '\u271d' || s == \"_inaccessible\"\n  | Name.num p _   => isInaccessibleUserName p\n  | _              => false", "start": [107, 1], "end": [111, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.escapePart", "code": "def escapePart (s : String) : Option String :=\n  if s.length > 0 && isIdFirst (s.get 0) && (s.toSubstring.drop 1).all isIdRest then s\n  else if s.any isIdEndEscape then none\n  else some <| idBeginEscape.toString ++ s ++ idEndEscape.toString", "start": [113, 1], "end": [116, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.toStringWithSep", "code": "def toStringWithSep : Name \u2192 String\n  | anonymous       => \"[anonymous]\"\n  | str anonymous s => maybeEscape s\n  | num anonymous v => toString v\n  | str n s         => toStringWithSep n ++ sep ++ maybeEscape s\n  | num n v         => toStringWithSep n ++ sep ++ Nat.repr v\nwhere\n  maybeEscape s := if escape then escapePart s |>.getD s else s", "start": [120, 1], "end": [127, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.toString", "code": "protected def toString (n : Name) (escape := true) : String :=\n  toStringWithSep \".\" (escape && !n.isInaccessibleUserName && !n.hasMacroScopes && !maybePseudoSyntax) n\nwhere\n  maybePseudoSyntax :=\n    if let .str _ s := n.getRoot then\n      \"#\".isPrefixOf s || \"?\".isPrefixOf s\n    else\n      false", "start": [129, 1], "end": [138, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.hasNum", "code": "private def hasNum : Name \u2192 Bool\n  | anonymous => false\n  | num ..    => true\n  | str p ..  => hasNum p", "start": [143, 1], "end": [146, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.reprPrec", "code": "protected def reprPrec (n : Name) (prec : Nat) : Std.Format :=\n  match n with\n  | anonymous => Std.Format.text \"Lean.Name.anonymous\"\n  | num p i => Repr.addAppParen (\"Lean.Name.mkNum \" ++ Name.reprPrec p max_prec ++ \" \" ++ repr i) prec\n  | str p s =>\n    if p.hasNum then\n      Repr.addAppParen (\"Lean.Name.mkStr \" ++ Name.reprPrec p max_prec ++ \" \" ++ repr s) prec\n    else\n      Std.Format.text \"`\" ++ n.toString", "start": [148, 1], "end": [156, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.capitalize", "code": "def capitalize : Name \u2192 Name\n  | .str p s => .str p s.capitalize\n  | n        => n", "start": [161, 1], "end": [163, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.replacePrefix", "code": "def replacePrefix : Name \u2192 Name \u2192 Name \u2192 Name\n  | anonymous,   anonymous, newP => newP\n  | anonymous,   _,         _    => anonymous\n  | n@(str p s), queryP,    newP => if n == queryP then newP else Name.mkStr (p.replacePrefix queryP newP) s\n  | n@(num p s), queryP,    newP => if n == queryP then newP else Name.mkNum (p.replacePrefix queryP newP) s", "start": [165, 1], "end": [169, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.eraseSuffix?", "code": "def eraseSuffix? : Name \u2192 Name \u2192 Option Name\n  | n,       anonymous => some n\n  | str p s, str p' s' => if s == s' then eraseSuffix? p p' else none\n  | num p s, num p' s' => if s == s' then eraseSuffix? p p' else none\n  | _,       _         => none", "start": [171, 1], "end": [178, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.modifyBase", "code": "@[inline] def modifyBase (n : Name) (f : Name \u2192 Name) : Name :=\n  if n.hasMacroScopes then\n    let view := extractMacroScopes n\n    { view with name := f view.name }.review\n  else\n    f n", "start": [180, 1], "end": [186, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.appendAfter", "code": "@[export lean_name_append_after]\ndef appendAfter (n : Name) (suffix : String) : Name :=\n  n.modifyBase fun\n    | str p s => Name.mkStr p (s ++ suffix)\n    | n       => Name.mkStr n suffix", "start": [188, 1], "end": [192, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.appendIndexAfter", "code": "@[export lean_name_append_index_after]\ndef appendIndexAfter (n : Name) (idx : Nat) : Name :=\n  n.modifyBase fun\n    | str p s => Name.mkStr p (s ++ \"_\" ++ toString idx)\n    | n       => Name.mkStr n (\"_\" ++ toString idx)", "start": [194, 1], "end": [198, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.appendBefore", "code": "@[export lean_name_append_before]\ndef appendBefore (n : Name) (pre : String) : Name :=\n  n.modifyBase fun\n    | anonymous => Name.mkStr anonymous pre\n    | str p s => Name.mkStr p (pre ++ s)\n    | num p n => Name.mkNum (Name.mkStr p pre) n", "start": [200, 1], "end": [205, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.beq_iff_eq", "code": "protected theorem beq_iff_eq {m n : Name} : m == n \u2194 m = n", "start": [207, 1], "end": [209, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.NameGenerator", "code": "structure NameGenerator where\n  namePrefix : Name := `_uniq\n  idx        : Nat  := 1\n  deriving Inhabited", "start": [220, 1], "end": [223, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.NameGenerator.curr", "code": "@[inline] def curr (g : NameGenerator) : Name :=\n  Name.mkNum g.namePrefix g.idx", "start": [227, 1], "end": [228, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.NameGenerator.next", "code": "@[inline] def next (g : NameGenerator) : NameGenerator :=\n  { g with idx := g.idx + 1 }", "start": [230, 1], "end": [231, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.NameGenerator.mkChild", "code": "@[inline] def mkChild (g : NameGenerator) : NameGenerator \u00d7 NameGenerator :=\n  ({ namePrefix := Name.mkNum g.namePrefix g.idx, idx := 1 },\n   { g with idx := g.idx + 1 })", "start": [233, 1], "end": [235, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadNameGenerator", "code": "class MonadNameGenerator (m : Type \u2192 Type) where\n  getNGen : m NameGenerator\n  setNGen : NameGenerator \u2192 m Unit", "start": [239, 1], "end": [241, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.mkFreshId", "code": "def mkFreshId {m : Type \u2192 Type} [Monad m] [MonadNameGenerator m] : m Name := do\n  let ngen \u2190 getNGen\n  let r := ngen.curr\n  setNGen ngen.next\n  pure r", "start": [245, 1], "end": [249, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.monadNameGeneratorLift", "code": "instance monadNameGeneratorLift (m n : Type \u2192 Type) [MonadLift m n] [MonadNameGenerator m] : MonadNameGenerator n := {\n  getNGen := liftM (getNGen : m _),\n  setNGen := fun ngen => liftM (setNGen ngen : m _)\n}", "start": [251, 1], "end": [254, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Term", "code": "abbrev Term := TSyntax `term", "start": [262, 1], "end": [262, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Command", "code": "abbrev Command := TSyntax `command", "start": [263, 1], "end": [263, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Level", "code": "protected abbrev Level := TSyntax `level", "start": [264, 1], "end": [264, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Tactic", "code": "protected abbrev Tactic := TSyntax `tactic", "start": [265, 1], "end": [265, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Prec", "code": "abbrev Prec := TSyntax `prec", "start": [266, 1], "end": [266, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Prio", "code": "abbrev Prio := TSyntax `prio", "start": [267, 1], "end": [267, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Ident", "code": "abbrev Ident := TSyntax identKind", "start": [268, 1], "end": [268, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.StrLit", "code": "abbrev StrLit := TSyntax strLitKind", "start": [269, 1], "end": [269, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.CharLit", "code": "abbrev CharLit := TSyntax charLitKind", "start": [270, 1], "end": [270, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.NameLit", "code": "abbrev NameLit := TSyntax nameLitKind", "start": [271, 1], "end": [271, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.ScientificLit", "code": "abbrev ScientificLit := TSyntax scientificLitKind", "start": [272, 1], "end": [272, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.NumLit", "code": "abbrev NumLit := TSyntax numLitKind", "start": [273, 1], "end": [273, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.HygieneInfo", "code": "abbrev HygieneInfo := TSyntax hygieneInfoKind", "start": [274, 1], "end": [274, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.structEq", "code": "partial def structEq : Syntax \u2192 Syntax \u2192 Bool\n  | Syntax.missing, Syntax.missing => true\n  | Syntax.node _ k args, Syntax.node _ k' args' => k == k' && args.isEqv args' structEq\n  | Syntax.atom _ val, Syntax.atom _ val' => val == val'\n  | Syntax.ident _ rawVal val preresolved, Syntax.ident _ rawVal' val' preresolved' => rawVal == rawVal' && val == val' && preresolved == preresolved'\n  | _, _ => false", "start": [334, 1], "end": [340, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getTailInfo?", "code": "partial def getTailInfo? : Syntax \u2192 Option SourceInfo\n  | atom info _   => info\n  | ident info .. => info\n  | node SourceInfo.none _ args =>\n      args.findSomeRev? getTailInfo?\n  | node info _ _    => info\n  | _             => none", "start": [345, 1], "end": [351, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getTailInfo", "code": "def getTailInfo (stx : Syntax) : SourceInfo :=\n  stx.getTailInfo?.getD SourceInfo.none", "start": [353, 1], "end": [354, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getTrailingSize", "code": "def getTrailingSize (stx : Syntax) : Nat :=\n  match stx.getTailInfo? with\n  | some (SourceInfo.original (trailing := trailing) ..) => trailing.bsize\n  | _ => 0", "start": [356, 1], "end": [359, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getSubstring?", "code": "def getSubstring? (stx : Syntax) (withLeading := true) (withTrailing := true) : Option Substring :=\n  match stx.getHeadInfo, stx.getTailInfo with\n  | SourceInfo.original lead startPos _ _, SourceInfo.original _ _ trail stopPos =>\n    some {\n      str      := lead.str\n      startPos := if withLeading then lead.startPos else startPos\n      stopPos  := if withTrailing then trail.stopPos else stopPos\n    }\n  | _, _ => none", "start": [361, 1], "end": [372, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.updateLast", "code": "@[specialize] private partial def updateLast {\u03b1} [Inhabited \u03b1] (a : Array \u03b1) (f : \u03b1 \u2192 Option \u03b1) (i : Nat) : Option (Array \u03b1) :=\n  if i == 0 then\n    none\n  else\n    let i := i - 1\n    let v := a[i]!\n    match f v with\n    | some v => some <| a.set! i v\n    | none   => updateLast a f i", "start": [374, 1], "end": [382, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.setTailInfoAux", "code": "partial def setTailInfoAux (info : SourceInfo) : Syntax \u2192 Option Syntax\n  | atom _ val             => some <| atom info val\n  | ident _ rawVal val pre => some <| ident info rawVal val pre\n  | node info k args       =>\n    match updateLast args (setTailInfoAux info) args.size with\n    | some args => some <| node info k args\n    | none      => none\n  | _                      => none", "start": [384, 1], "end": [391, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.setTailInfo", "code": "def setTailInfo (stx : Syntax) (info : SourceInfo) : Syntax :=\n  match setTailInfoAux info stx with\n  | some stx => stx\n  | none     => stx", "start": [393, 1], "end": [396, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.unsetTrailing", "code": "def unsetTrailing (stx : Syntax) : Syntax :=\n  match stx.getTailInfo with\n  | SourceInfo.original lead pos _ endPos => stx.setTailInfo (SourceInfo.original lead pos \"\".toSubstring endPos)\n  | _                                     => stx", "start": [398, 1], "end": [401, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.updateFirst", "code": "@[specialize] private partial def updateFirst {\u03b1} [Inhabited \u03b1] (a : Array \u03b1) (f : \u03b1 \u2192 Option \u03b1) (i : Nat) : Option (Array \u03b1) :=\n  if h : i < a.size then\n    let v := a[i]\n    match f v with\n    | some v => some <| a.set \u27e8i, h\u27e9 v\n    | none   => updateFirst a f (i+1)\n  else\n    none", "start": [403, 1], "end": [410, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.setHeadInfoAux", "code": "partial def setHeadInfoAux (info : SourceInfo) : Syntax \u2192 Option Syntax\n  | atom _ val             => some <| atom info val\n  | ident _ rawVal val pre => some <| ident info rawVal val pre\n  | node i k args          =>\n    match updateFirst args (setHeadInfoAux info) 0 with\n    | some args => some <| node i k args\n    | _         => none\n  | _                      => none", "start": [412, 1], "end": [419, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.setHeadInfo", "code": "def setHeadInfo (stx : Syntax) (info : SourceInfo) : Syntax :=\n  match setHeadInfoAux info stx with\n  | some stx => stx\n  | none     => stx", "start": [421, 1], "end": [424, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.setInfo", "code": "def setInfo (info : SourceInfo) : Syntax \u2192 Syntax\n  | atom _ val             => atom info val\n  | ident _ rawVal val pre => ident info rawVal val pre\n  | node _ kind args       => node info kind args\n  | missing                => missing", "start": [426, 1], "end": [430, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getHead?", "code": "partial def getHead? : Syntax \u2192 Option Syntax\n  | stx@(atom info ..)  => info.getPos?.map fun _ => stx\n  | stx@(ident info ..) => info.getPos?.map fun _ => stx\n  | node SourceInfo.none _ args => args.findSome? getHead?\n  | stx@(node ..) => stx\n  | _ => none", "start": [432, 1], "end": [438, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.copyHeadTailInfoFrom", "code": "def copyHeadTailInfoFrom (target source : Syntax) : Syntax :=\n  target.setHeadInfo source.getHeadInfo |>.setTailInfo source.getTailInfo", "start": [440, 1], "end": [441, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkSynthetic", "code": "def mkSynthetic (stx : Syntax) : Syntax :=\n  stx.setHeadInfo (SourceInfo.fromRef stx)", "start": [443, 1], "end": [445, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.withHeadRefOnly", "code": "@[inline] def withHeadRefOnly {m : Type \u2192 Type} [Monad m] [MonadRef m] {\u03b1} (x : m \u03b1) : m \u03b1 := do\n  match (\u2190 getRef).getHead? with\n  | none => x\n  | some ref => withRef ref x", "start": [449, 1], "end": [453, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Module", "code": "structure Module where\n  header   : Syntax\n  commands : Array Syntax", "start": [455, 1], "end": [458, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.expandMacros", "code": "partial def expandMacros (stx : Syntax) (p : SyntaxNodeKind \u2192 Bool := fun k => k != `Lean.Parser.Term.byTactic) : MacroM Syntax :=\n  withRef stx do\n    match stx with\n    | .node info k args => do\n      if p k then\n        match (\u2190 expandMacro? stx) with\n        | some stxNew => expandMacros stxNew\n        | none        => do\n          let args \u2190 Macro.withIncRecDepth stx <| args.mapM expandMacros\n          return .node info k args\n      else\n        return stx\n    | stx => return stx", "start": [460, 1], "end": [497, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.mkIdentFrom", "code": "def mkIdentFrom (src : Syntax) (val : Name) (canonical := false) : Ident :=\n  \u27e8Syntax.ident (SourceInfo.fromRef src canonical) (toString val).toSubstring val []\u27e9", "start": [501, 1], "end": [505, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.mkIdentFromRef", "code": "def mkIdentFromRef [Monad m] [MonadRef m] (val : Name) (canonical := false) : m Ident := do\n  return mkIdentFrom (\u2190 getRef) val canonical", "start": [507, 1], "end": [508, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.mkCIdentFrom", "code": "def mkCIdentFrom (src : Syntax) (c : Name) (canonical := false) : Ident :=\n  let id   := addMacroScope `_internal c reservedMacroScope\n  \u27e8Syntax.ident (SourceInfo.fromRef src canonical) (toString id).toSubstring id [.decl c []]\u27e9", "start": [510, 1], "end": [517, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.mkCIdentFromRef", "code": "def mkCIdentFromRef [Monad m] [MonadRef m] (c : Name) (canonical := false) : m Syntax := do\n  return mkCIdentFrom (\u2190 getRef) c canonical", "start": [519, 1], "end": [520, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.mkCIdent", "code": "def mkCIdent (c : Name) : Ident :=\n  mkCIdentFrom Syntax.missing c", "start": [522, 1], "end": [523, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.mkIdent", "code": "@[export lean_mk_syntax_ident]\ndef mkIdent (val : Name) : Ident :=\n  \u27e8Syntax.ident SourceInfo.none (toString val).toSubstring val []\u27e9", "start": [525, 1], "end": [527, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.mkGroupNode", "code": "@[inline] def mkGroupNode (args : Array Syntax := #[]) : Syntax :=\n  mkNode groupKind args", "start": [529, 1], "end": [530, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.mkSepArray", "code": "def mkSepArray (as : Array Syntax) (sep : Syntax) : Array Syntax := Id.run do\n  let mut i := 0\n  let mut r := #[]\n  for a in as do\n    if i > 0 then\n      r := r.push sep |>.push a\n    else\n      r := r.push a\n    i := i + 1\n  return r", "start": [532, 1], "end": [541, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.mkOptionalNode", "code": "def mkOptionalNode (arg : Option Syntax) : Syntax :=\n  match arg with\n  | some arg => mkNullNode #[arg]\n  | none     => mkNullNode #[]", "start": [543, 1], "end": [546, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.mkHole", "code": "def mkHole (ref : Syntax) (canonical := false) : Syntax :=\n  mkNode `Lean.Parser.Term.hole #[mkAtomFrom ref \"_\" canonical]", "start": [548, 1], "end": [549, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkSep", "code": "def mkSep (a : Array Syntax) (sep : Syntax) : Syntax :=\n  mkNullNode <| mkSepArray a sep", "start": [553, 1], "end": [554, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.SepArray.ofElems", "code": "def SepArray.ofElems {sep} (elems : Array Syntax) : SepArray sep :=\n\u27e8mkSepArray elems (if sep.isEmpty then mkNullNode else mkAtom sep)\u27e9", "start": [556, 1], "end": [557, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.SepArray.ofElemsUsingRef", "code": "def SepArray.ofElemsUsingRef [Monad m] [MonadRef m] {sep} (elems : Array Syntax) : m (SepArray sep) := do\n  let ref \u2190 getRef;\n  return \u27e8mkSepArray elems (if sep.isEmpty then mkNullNode else mkAtomFrom ref sep)\u27e9", "start": [559, 1], "end": [561, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkApp", "code": "def mkApp (fn : Term) : (args : TSyntaxArray `term) \u2192 Term\n  | #[]  => fn\n  | args => \u27e8mkNode `Lean.Parser.Term.app #[fn, mkNullNode args.raw]\u27e9", "start": [569, 1], "end": [572, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkCApp", "code": "def mkCApp (fn : Name) (args : TSyntaxArray `term) : Term :=\n  mkApp (mkCIdent fn) args", "start": [574, 1], "end": [575, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkLit", "code": "def mkLit (kind : SyntaxNodeKind) (val : String) (info := SourceInfo.none) : TSyntax kind :=\n  let atom : Syntax := Syntax.atom info val\n  mkNode kind #[atom]", "start": [577, 1], "end": [579, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkStrLit", "code": "def mkStrLit (val : String) (info := SourceInfo.none) : StrLit :=\n  mkLit strLitKind (String.quote val) info", "start": [581, 1], "end": [582, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkNumLit", "code": "def mkNumLit (val : String) (info := SourceInfo.none) : NumLit :=\n  mkLit numLitKind val info", "start": [584, 1], "end": [585, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkScientificLit", "code": "def mkScientificLit (val : String) (info := SourceInfo.none) : TSyntax scientificLitKind :=\n  mkLit scientificLitKind val info", "start": [587, 1], "end": [588, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkNameLit", "code": "def mkNameLit (val : String) (info := SourceInfo.none) : NameLit :=\n  mkLit nameLitKind val info", "start": [590, 1], "end": [591, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeBinLitAux", "code": "private partial def decodeBinLitAux (s : String) (i : String.Pos) (val : Nat) : Option Nat :=\n  if s.atEnd i then some val\n  else\n    let c := s.get i\n    if c == '0' then decodeBinLitAux s (s.next i) (2*val)\n    else if c == '1' then decodeBinLitAux s (s.next i) (2*val + 1)\n    else none", "start": [600, 1], "end": [606, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeOctalLitAux", "code": "private partial def decodeOctalLitAux (s : String) (i : String.Pos) (val : Nat) : Option Nat :=\n  if s.atEnd i then some val\n  else\n    let c := s.get i\n    if '0' \u2264 c && c \u2264 '7' then decodeOctalLitAux s (s.next i) (8*val + c.toNat - '0'.toNat)\n    else none", "start": [608, 1], "end": [613, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeHexDigit", "code": "private def decodeHexDigit (s : String) (i : String.Pos) : Option (Nat \u00d7 String.Pos) :=\n  let c := s.get i\n  let i := s.next i\n  if '0' \u2264 c && c \u2264 '9' then some (c.toNat - '0'.toNat, i)\n  else if 'a' \u2264 c && c \u2264 'f' then some (10 + c.toNat - 'a'.toNat, i)\n  else if 'A' \u2264 c && c \u2264 'F' then some (10 + c.toNat - 'A'.toNat, i)\n  else none", "start": [615, 1], "end": [621, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeHexLitAux", "code": "private partial def decodeHexLitAux (s : String) (i : String.Pos) (val : Nat) : Option Nat :=\n  if s.atEnd i then some val\n  else match decodeHexDigit s i with\n    | some (d, i) => decodeHexLitAux s i (16*val + d)\n    | none        => none", "start": [623, 1], "end": [627, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeDecimalLitAux", "code": "private partial def decodeDecimalLitAux (s : String) (i : String.Pos) (val : Nat) : Option Nat :=\n  if s.atEnd i then some val\n  else\n    let c := s.get i\n    if '0' \u2264 c && c \u2264 '9' then decodeDecimalLitAux s (s.next i) (10*val + c.toNat - '0'.toNat)\n    else none", "start": [629, 1], "end": [634, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeNatLitVal?", "code": "def decodeNatLitVal? (s : String) : Option Nat :=\n  let len := s.length\n  if len == 0 then none\n  else\n    let c := s.get 0\n    if c == '0' then\n      if len == 1 then some 0\n      else\n        let c := s.get \u27e81\u27e9\n        if c == 'x' || c == 'X' then decodeHexLitAux s \u27e82\u27e9 0\n        else if c == 'b' || c == 'B' then decodeBinLitAux s \u27e82\u27e9 0\n        else if c == 'o' || c == 'O' then decodeOctalLitAux s \u27e82\u27e9 0\n        else if c.isDigit then decodeDecimalLitAux s 0 0\n        else none\n    else if c.isDigit then decodeDecimalLitAux s 0 0\n    else none", "start": [636, 1], "end": [651, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isLit?", "code": "def isLit? (litKind : SyntaxNodeKind) (stx : Syntax) : Option String :=\n  match stx with\n  | Syntax.node _ k args =>\n    if k == litKind && args.size == 1 then\n      match args.get! 0 with\n      | (Syntax.atom _ val) => some val\n      | _ => none\n    else\n      none\n  | _ => none", "start": [653, 1], "end": [662, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isNatLitAux", "code": "private def isNatLitAux (litKind : SyntaxNodeKind) (stx : Syntax) : Option Nat :=\n  match isLit? litKind stx with\n  | some val => decodeNatLitVal? val\n  | _        => none", "start": [664, 1], "end": [667, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isNatLit?", "code": "def isNatLit? (s : Syntax) : Option Nat :=\n  isNatLitAux numLitKind s", "start": [669, 1], "end": [670, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isFieldIdx?", "code": "def isFieldIdx? (s : Syntax) : Option Nat :=\n  isNatLitAux fieldIdxKind s", "start": [672, 1], "end": [673, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeScientificLitVal?", "code": "partial def decodeScientificLitVal? (s : String) : Option (Nat \u00d7 Bool \u00d7 Nat) :=\n  let len := s.length\n  if len == 0 then none\n  else\n    let c := s.get 0\n    if c.isDigit then\n      decode 0 0\n    else none\nwhere\n  decodeAfterExp (i : String.Pos) (val : Nat) (e : Nat) (sign : Bool) (exp : Nat) : Option (Nat \u00d7 Bool \u00d7 Nat) :=\n    if s.atEnd i then\n      if sign then\n        some (val, sign, exp + e)\n      else if exp >= e then\n        some (val, sign, exp - e)\n      else\n        some (val, true, e - exp)\n    else\n      let c := s.get i\n      if '0' \u2264 c && c \u2264 '9' then\n        decodeAfterExp (s.next i) val e sign (10*exp + c.toNat - '0'.toNat)\n      else\n        none\n\n  decodeExp (i : String.Pos) (val : Nat) (e : Nat) : Option (Nat \u00d7 Bool \u00d7 Nat) :=\n    if s.atEnd i then none else\n    let c := s.get i\n    if c == '-' then\n       decodeAfterExp (s.next i) val e true 0\n    else if c == '+' then\n       decodeAfterExp (s.next i) val e false 0\n    else\n       decodeAfterExp i val e false 0\n\n  decodeAfterDot (i : String.Pos) (val : Nat) (e : Nat) : Option (Nat \u00d7 Bool \u00d7 Nat) :=\n    if s.atEnd i then\n      some (val, true, e)\n    else\n      let c := s.get i\n      if '0' \u2264 c && c \u2264 '9' then\n        decodeAfterDot (s.next i) (10*val + c.toNat - '0'.toNat) (e+1)\n      else if c == 'e' || c == 'E' then\n        decodeExp (s.next i) val e\n      else\n        none\n\n  decode (i : String.Pos) (val : Nat) : Option (Nat \u00d7 Bool \u00d7 Nat) :=\n    if s.atEnd i then\n      none\n    else\n      let c := s.get i\n      if '0' \u2264 c && c \u2264 '9' then\n        decode (s.next i) (10*val + c.toNat - '0'.toNat)\n      else if c == '.' then\n        decodeAfterDot (s.next i) val 0\n      else if c == 'e' || c == 'E' then\n        decodeExp (s.next i) val 0\n      else\n        none", "start": [675, 1], "end": [737, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isScientificLit?", "code": "def isScientificLit? (stx : Syntax) : Option (Nat \u00d7 Bool \u00d7 Nat) :=\n  match isLit? scientificLitKind stx with\n  | some val => decodeScientificLitVal? val\n  | _        => none", "start": [739, 1], "end": [742, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isIdOrAtom?", "code": "def isIdOrAtom? : Syntax \u2192 Option String\n  | Syntax.atom _ val           => some val\n  | Syntax.ident _ rawVal _ _   => some rawVal.toString\n  | _ => none", "start": [744, 1], "end": [747, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.toNat", "code": "def toNat (stx : Syntax) : Nat :=\n  match stx.isNatLit? with\n  | some val => val\n  | none     => 0", "start": [749, 1], "end": [752, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeQuotedChar", "code": "def decodeQuotedChar (s : String) (i : String.Pos) : Option (Char \u00d7 String.Pos) := do\n  let c := s.get i\n  let i := s.next i\n  if c == '\\\\' then pure ('\\\\', i)\n  else if c = '\\\"' then pure ('\\\"', i)\n  else if c = '\\'' then pure ('\\'', i)\n  else if c = 'r'  then pure ('\\r', i)\n  else if c = 'n'  then pure ('\\n', i)\n  else if c = 't'  then pure ('\\t', i)\n  else if c = 'x'  then\n    let (d\u2081, i) \u2190 decodeHexDigit s i\n    let (d\u2082, i) \u2190 decodeHexDigit s i\n    pure (Char.ofNat (16*d\u2081 + d\u2082), i)\n  else if c = 'u'  then do\n    let (d\u2081, i) \u2190 decodeHexDigit s i\n    let (d\u2082, i) \u2190 decodeHexDigit s i\n    let (d\u2083, i) \u2190 decodeHexDigit s i\n    let (d\u2084, i) \u2190 decodeHexDigit s i\n    pure (Char.ofNat (16*(16*(16*d\u2081 + d\u2082) + d\u2083) + d\u2084), i)\n  else\n    none", "start": [754, 1], "end": [774, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeStrLitAux", "code": "partial def decodeStrLitAux (s : String) (i : String.Pos) (acc : String) : Option String := do\n  let c := s.get i\n  let i := s.next i\n  if c == '\\\"' then\n    pure acc\n  else if s.atEnd i then\n    none\n  else if c == '\\\\' then do\n    let (c, i) \u2190 decodeQuotedChar s i\n    decodeStrLitAux s i (acc.push c)\n  else\n    decodeStrLitAux s i (acc.push c)", "start": [776, 1], "end": [787, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeStrLit", "code": "def decodeStrLit (s : String) : Option String :=\n  decodeStrLitAux s \u27e81\u27e9 \"\"", "start": [789, 1], "end": [790, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isStrLit?", "code": "def isStrLit? (stx : Syntax) : Option String :=\n  match isLit? strLitKind stx with\n  | some val => decodeStrLit val\n  | _        => none", "start": [792, 1], "end": [795, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeCharLit", "code": "def decodeCharLit (s : String) : Option Char := do\n  let c := s.get \u27e81\u27e9\n  if c == '\\\\' then do\n    let (c, _) \u2190 decodeQuotedChar s \u27e82\u27e9\n    pure c\n  else\n    pure c", "start": [797, 1], "end": [803, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isCharLit?", "code": "def isCharLit? (stx : Syntax) : Option Char :=\n  match isLit? charLitKind stx with\n  | some val => decodeCharLit val\n  | _        => none", "start": [805, 1], "end": [808, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.splitNameLitAux", "code": "private partial def splitNameLitAux (ss : Substring) (acc : List Substring) : List Substring :=\n  let splitRest (ss : Substring) (acc : List Substring) : List Substring :=\n    if ss.front == '.' then\n      splitNameLitAux (ss.drop 1) acc\n    else if ss.isEmpty then\n      acc\n    else\n      []\n  if ss.isEmpty then []\n  else\n    let curr := ss.front\n    if isIdBeginEscape curr then\n      let escapedPart := ss.takeWhile (!isIdEndEscape \u00b7)\n      let escapedPart := { escapedPart with stopPos := ss.stopPos.min (escapedPart.str.next escapedPart.stopPos) }\n      if !isIdEndEscape (escapedPart.get <| escapedPart.prev \u27e8escapedPart.bsize\u27e9) then []\n      else splitRest (ss.extract \u27e8escapedPart.bsize\u27e9 \u27e8ss.bsize\u27e9) (escapedPart :: acc)\n    else if isIdFirst curr then\n      let idPart := ss.takeWhile isIdRest\n      splitRest (ss.extract \u27e8idPart.bsize\u27e9 \u27e8ss.bsize\u27e9) (idPart :: acc)\n    else if curr.isDigit then\n      let idPart := ss.takeWhile Char.isDigit\n      splitRest (ss.extract \u27e8idPart.bsize\u27e9 \u27e8ss.bsize\u27e9) (idPart :: acc)\n    else\n      []", "start": [810, 1], "end": [833, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.splitNameLit", "code": "def splitNameLit (ss : Substring) : List Substring :=\n  splitNameLitAux ss [] |>.reverse", "start": [835, 1], "end": [838, 35], "kind": "commanddeclaration"}, {"full_name": "Substring.toName", "code": "def _root_.Substring.toName (s : Substring) : Name :=\n  match splitNameLitAux s [] with\n  | [] => .anonymous\n  | comps => comps.foldr (init := Name.anonymous)\n    fun comp n =>\n      let comp := comp.toString\n      if isIdBeginEscape comp.front then\n        Name.mkStr n (comp.drop 1 |>.dropRight 1)\n      else if comp.front.isDigit then\n        if let some k := decodeNatLitVal? comp then\n          Name.mkNum n k\n        else\n          unreachable!\n      else\n        Name.mkStr n comp", "start": [840, 1], "end": [854, 26], "kind": "commanddeclaration"}, {"full_name": "String.toName", "code": "def _root_.String.toName (s : String) : Name :=\n  s.toSubstring.toName", "start": [856, 1], "end": [857, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeNameLit", "code": "def decodeNameLit (s : String) : Option Name :=\n  if s.get 0 == '`' then\n    match (s.toSubstring.drop 1).toName with\n    | .anonymous => none\n    | name => some name\n  else\n    none", "start": [859, 1], "end": [865, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isNameLit?", "code": "def isNameLit? (stx : Syntax) : Option Name :=\n  match isLit? nameLitKind stx with\n  | some val => decodeNameLit val\n  | _        => none", "start": [867, 1], "end": [870, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.hasArgs", "code": "def hasArgs : Syntax \u2192 Bool\n  | Syntax.node _ _ args => args.size > 0\n  | _                    => false", "start": [872, 1], "end": [874, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isAtom", "code": "def isAtom : Syntax \u2192 Bool\n  | atom _ _ => true\n  | _        => false", "start": [876, 1], "end": [878, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isToken", "code": "def isToken (token : String) : Syntax \u2192 Bool\n  | atom _ val => val.trim == token.trim\n  | _          => false", "start": [880, 1], "end": [882, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isNone", "code": "def isNone (stx : Syntax) : Bool :=\n  match stx with\n  | Syntax.node _ k args => k == nullKind && args.size == 0\n  | Syntax.missing     => true\n  | _                  => false", "start": [884, 1], "end": [889, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getOptionalIdent?", "code": "def getOptionalIdent? (stx : Syntax) : Option Name :=\n  match stx.getOptional? with\n  | some stx => some stx.getId\n  | none     => none", "start": [891, 1], "end": [894, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.findAux", "code": "partial def findAux (p : Syntax \u2192 Bool) : Syntax \u2192 Option Syntax\n  | stx@(Syntax.node _ _ args) => if p stx then some stx else args.findSome? (findAux p)\n  | stx                        => if p stx then some stx else none", "start": [896, 1], "end": [898, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.find?", "code": "def find? (stx : Syntax) (p : Syntax \u2192 Bool) : Option Syntax :=\n  findAux p stx", "start": [900, 1], "end": [901, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntax.getNat", "code": "def getNat (s : NumLit) : Nat :=\n  s.raw.isNatLit?.getD 0", "start": [907, 1], "end": [908, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntax.getId", "code": "def getId (s : Ident) : Name :=\n  s.raw.getId", "start": [910, 1], "end": [911, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntax.getScientific", "code": "def getScientific (s : ScientificLit) : Nat \u00d7 Bool \u00d7 Nat :=\n  s.raw.isScientificLit?.getD (0, false, 0)", "start": [913, 1], "end": [914, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntax.getString", "code": "def getString (s : StrLit) : String :=\n  s.raw.isStrLit?.getD \"\"", "start": [916, 1], "end": [917, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntax.getChar", "code": "def getChar (s : CharLit) : Char :=\n  s.raw.isCharLit?.getD default", "start": [919, 1], "end": [920, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntax.getName", "code": "def getName (s : NameLit) : Name :=\n  s.raw.isNameLit?.getD .anonymous", "start": [922, 1], "end": [923, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntax.getHygieneInfo", "code": "def getHygieneInfo (s : HygieneInfo) : Name :=\n  s.raw[0].getId", "start": [925, 1], "end": [926, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.HygieneInfo.mkIdent", "code": "def HygieneInfo.mkIdent (s : HygieneInfo) (val : Name) (canonical := false) : Ident :=\n  let src := s.raw[0]\n  let id := { extractMacroScopes src.getId with name := val.eraseMacroScopes }.review\n  \u27e8Syntax.ident (SourceInfo.fromRef src canonical) (toString val).toSubstring id []\u27e9", "start": [937, 1], "end": [940, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Quote", "code": "class Quote (\u03b1 : Type) (k : SyntaxNodeKind := `term) where\n  quote : \u03b1 \u2192 TSyntax k", "start": [942, 1], "end": [944, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.getEscapedNameParts?", "code": "private def getEscapedNameParts? (acc : List String) : Name \u2192 Option (List String)\n  | Name.anonymous => if acc.isEmpty then none else some acc\n  | Name.str n s => do\n    let s \u2190 Name.escapePart s\n    getEscapedNameParts? (s::acc) n\n  | Name.num _ _ => none", "start": [958, 1], "end": [963, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.quoteNameMk", "code": "def quoteNameMk : Name \u2192 Term\n  | .anonymous => mkCIdent ``Name.anonymous\n  | .str n s => Syntax.mkCApp ``Name.mkStr #[quoteNameMk n, quote s]\n  | .num n i => Syntax.mkCApp ``Name.mkNum #[quoteNameMk n, quote i]", "start": [965, 1], "end": [968, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.quoteList", "code": "private def quoteList [Quote \u03b1 `term] : List \u03b1 \u2192 Term\n  | []      => mkCIdent ``List.nil\n  | (x::xs) => Syntax.mkCApp ``List.cons #[quote x, quoteList xs]", "start": [979, 1], "end": [981, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.quoteArray", "code": "private def quoteArray [Quote \u03b1 `term] (xs : Array \u03b1) : Term :=\n  if xs.size <= 8 then\n    go 0 #[]\n  else\n    Syntax.mkCApp ``List.toArray #[quote xs.toList]\nwhere\n  go (i : Nat) (args : Array Term) : Term :=\n    if h : i < xs.size then\n      go (i+1) (args.push (quote xs[i]))\n    else\n      Syntax.mkCApp (Name.mkStr2 \"Array\" (\"mkArray\" ++ toString xs.size)) args\ntermination_by go i _ => xs.size - i", "start": [986, 1], "end": [997, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Option.hasQuote", "code": "instance Option.hasQuote {\u03b1 : Type} [Quote \u03b1 `term] : Quote (Option \u03b1) `term where\n  quote\n    | none     => mkIdent ``none\n    | (some x) => Syntax.mkCApp ``some #[quote x]", "start": [1002, 1], "end": [1005, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.evalPrec", "code": "def evalPrec (stx : Syntax) : MacroM Nat :=\n  Macro.withIncRecDepth stx do\n    let stx \u2190 expandMacros stx\n    match stx with\n    | `(prec| $num:num) => return num.getNat\n    | _ => Macro.throwErrorAt stx \"unexpected precedence\"", "start": [1008, 1], "end": [1014, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.evalPrio", "code": "def evalPrio (stx : Syntax) : MacroM Nat :=\n  Macro.withIncRecDepth stx do\n    let stx \u2190 expandMacros stx\n    match stx with\n    | `(prio| $num:num) => return num.getNat\n    | _ => Macro.throwErrorAt stx \"unexpected priority\"", "start": [1024, 1], "end": [1030, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.evalOptPrio", "code": "def evalOptPrio : Option (TSyntax `prio) \u2192 MacroM Nat\n  | some prio => evalPrio prio\n  | none      => return 1000", "start": [1040, 1], "end": [1042, 29], "kind": "commanddeclaration"}, {"full_name": "Array.getSepElems", "code": "abbrev getSepElems := @getEvenElems", "start": [1048, 1], "end": [1048, 36], "kind": "commanddeclaration"}, {"full_name": "Array.filterSepElemsMAux", "code": "private partial def filterSepElemsMAux {m : Type \u2192 Type} [Monad m] (a : Array Syntax) (p : Syntax \u2192 m Bool) (i : Nat) (acc : Array Syntax) : m (Array Syntax) := do\n  if h : i < a.size then\n    let stx := a[i]\n    if (\u2190 p stx) then\n      if acc.isEmpty then\n        filterSepElemsMAux a p (i+2) (acc.push stx)\n      else if hz : i \u2260 0 then\n        have : i.pred < i := Nat.pred_lt hz\n        have : i.pred < a.size := Nat.lt_trans this h\n        let sepStx := a[i.pred]\n        filterSepElemsMAux a p (i+2) ((acc.push sepStx).push stx)\n      else\n        filterSepElemsMAux a p (i+2) (acc.push stx)\n    else\n      filterSepElemsMAux a p (i+2) acc\n  else\n    pure acc", "start": [1052, 1], "end": [1068, 13], "kind": "commanddeclaration"}, {"full_name": "Array.filterSepElemsM", "code": "def filterSepElemsM {m : Type \u2192 Type} [Monad m] (a : Array Syntax) (p : Syntax \u2192 m Bool) : m (Array Syntax) :=\n  filterSepElemsMAux a p 0 #[]", "start": [1070, 1], "end": [1071, 31], "kind": "commanddeclaration"}, {"full_name": "Array.filterSepElems", "code": "def filterSepElems (a : Array Syntax) (p : Syntax \u2192 Bool) : Array Syntax :=\n  Id.run <| a.filterSepElemsM p", "start": [1073, 1], "end": [1074, 32], "kind": "commanddeclaration"}, {"full_name": "Array.mapSepElemsMAux", "code": "private partial def mapSepElemsMAux {m : Type \u2192 Type} [Monad m] (a : Array Syntax) (f : Syntax \u2192 m Syntax) (i : Nat) (acc : Array Syntax) : m (Array Syntax) := do\n  if h : i < a.size then\n    let stx := a[i]\n    if i % 2 == 0 then do\n      let stx \u2190 f stx\n      mapSepElemsMAux a f (i+1) (acc.push stx)\n    else\n      mapSepElemsMAux a f (i+1) (acc.push stx)\n  else\n    pure acc", "start": [1076, 1], "end": [1085, 13], "kind": "commanddeclaration"}, {"full_name": "Array.mapSepElemsM", "code": "def mapSepElemsM {m : Type \u2192 Type} [Monad m] (a : Array Syntax) (f : Syntax \u2192 m Syntax) : m (Array Syntax) :=\n  mapSepElemsMAux a f 0 #[]", "start": [1087, 1], "end": [1088, 28], "kind": "commanddeclaration"}, {"full_name": "Array.mapSepElems", "code": "def mapSepElems (a : Array Syntax) (f : Syntax \u2192 Syntax) : Array Syntax :=\n  Id.run <| a.mapSepElemsM f", "start": [1090, 1], "end": [1091, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.SepArray.getElems", "code": "def SepArray.getElems (sa : SepArray sep) : Array Syntax :=\n  sa.elemsAndSeps.getSepElems", "start": [1097, 1], "end": [1098, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.TSepArray.getElems", "code": "def TSepArray.getElems (sa : TSepArray k sep) : TSyntaxArray k :=\n  .mk sa.elemsAndSeps.getSepElems", "start": [1100, 1], "end": [1101, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.TSepArray.push", "code": "def TSepArray.push (sa : TSepArray k sep) (e : TSyntax k) : TSepArray k sep :=\n  if sa.elemsAndSeps.isEmpty then\n    { elemsAndSeps := #[e] }\n  else\n    { elemsAndSeps := sa.elemsAndSeps.push (mkAtom sep) |>.push e }", "start": [1103, 1], "end": [1107, 68], "kind": "commanddeclaration"}, {"full_name": "autoParam", "code": "abbrev autoParam.{u} (\u03b1 : Sort u) (tactic : Lean.Syntax) : Sort u := \u03b1", "start": [1136, 1], "end": [1141, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeInterpStrQuotedChar", "code": "private def decodeInterpStrQuotedChar (s : String) (i : String.Pos) : Option (Char \u00d7 String.Pos) := do\n  match decodeQuotedChar s i with\n  | some r => some r\n  | none   =>\n    let c := s.get i\n    let i := s.next i\n    if c == '{' then pure ('{', i)\n    else none", "start": [1147, 1], "end": [1154, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.decodeInterpStrLit", "code": "private partial def decodeInterpStrLit (s : String) : Option String :=\n  let rec loop (i : String.Pos) (acc : String) : Option String :=\n    let c := s.get i\n    let i := s.next i\n    if c == '\\\"' || c == '{' then\n      pure acc\n    else if s.atEnd i then\n      none\n    else if c == '\\\\' then do\n      let (c, i) \u2190 decodeInterpStrQuotedChar s i\n      loop i (acc.push c)\n    else\n      loop i (acc.push c)\n  loop \u27e81\u27e9 \"\"", "start": [1156, 1], "end": [1169, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isInterpolatedStrLit?", "code": "partial def isInterpolatedStrLit? (stx : Syntax) : Option String :=\n  match isLit? interpolatedStrLitKind stx with\n  | none     => none\n  | some val => decodeInterpStrLit val", "start": [1171, 1], "end": [1174, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getSepArgs", "code": "def getSepArgs (stx : Syntax) : Array Syntax :=\n  stx.getArgs.getSepElems", "start": [1176, 1], "end": [1177, 26], "kind": "commanddeclaration"}, {"full_name": "TSyntax.expandInterpolatedStrChunks", "code": "def expandInterpolatedStrChunks (chunks : Array Syntax) (mkAppend : Syntax \u2192 Syntax \u2192 MacroM Syntax) (mkElem : Syntax \u2192 MacroM Syntax) : MacroM Syntax := do\n  let mut i := 0\n  let mut result := Syntax.missing\n  for elem in chunks do\n    let elem \u2190 match elem.isInterpolatedStrLit? with\n      | none     => mkElem elem\n      | some str => mkElem (Syntax.mkStrLit str)\n    if i == 0 then\n      result := elem\n    else\n      result \u2190 mkAppend result elem\n    i := i+1\n  return result", "start": [1183, 1], "end": [1195, 16], "kind": "commanddeclaration"}, {"full_name": "TSyntax.expandInterpolatedStr", "code": "def expandInterpolatedStr (interpStr : TSyntax interpolatedStrKind) (type : Term) (toTypeFn : Term) : MacroM Term := do\n  let r \u2190 expandInterpolatedStrChunks interpStr.raw.getArgs (fun a b => `($a ++ $b)) (fun a => `($toTypeFn $a))\n  `(($r : $type))", "start": [1198, 1], "end": [1200, 18], "kind": "commanddeclaration"}, {"full_name": "Meta.TransparencyMode", "code": "inductive TransparencyMode where\n  | all | default | reducible | instances\n  deriving Inhabited, BEq, Repr", "start": [1206, 1], "end": [1208, 32], "kind": "commanddeclaration"}, {"full_name": "Meta.EtaStructMode", "code": "inductive EtaStructMode where\n  \n  | all\n  \n  | notClasses\n  \n  | none\n  deriving Inhabited, BEq, Repr", "start": [1210, 1], "end": [1217, 32], "kind": "commanddeclaration"}, {"full_name": "Meta.DSimp.Config", "code": "structure Config where\n  zeta              : Bool := true\n  beta              : Bool := true\n  eta               : Bool := true\n  etaStruct         : EtaStructMode := .all\n  iota              : Bool := true\n  proj              : Bool := true\n  decide            : Bool := false\n  autoUnfold        : Bool := false\n  \n  failIfUnchanged   : Bool := true\n  deriving Inhabited, BEq, Repr", "start": [1221, 1], "end": [1233, 32], "kind": "commanddeclaration"}, {"full_name": "Meta.Simp.defaultMaxSteps", "code": "def defaultMaxSteps := 100000", "start": [1239, 1], "end": [1239, 30], "kind": "commanddeclaration"}, {"full_name": "Meta.Simp.Config", "code": "structure Config where\n  maxSteps          : Nat  := defaultMaxSteps\n  maxDischargeDepth : Nat  := 2\n  contextual        : Bool := false\n  memoize           : Bool := true\n  singlePass        : Bool := false\n  zeta              : Bool := true\n  beta              : Bool := true\n  eta               : Bool := true\n  etaStruct         : EtaStructMode := .all\n  iota              : Bool := true\n  proj              : Bool := true\n  decide            : Bool := true\n  arith             : Bool := false\n  autoUnfold        : Bool := false\n  \n  dsimp             : Bool := true\n  \n  failIfUnchanged   : Bool := true\n  deriving Inhabited, BEq, Repr", "start": [1241, 1], "end": [1264, 32], "kind": "commanddeclaration"}, {"full_name": "Meta.Simp.ConfigCtx", "code": "structure ConfigCtx extends Config where\n  contextual := true", "start": [1267, 1], "end": [1268, 21], "kind": "commanddeclaration"}, {"full_name": "Meta.Simp.neutralConfig", "code": "def neutralConfig : Simp.Config := {\n  zeta              := false\n  beta              := false\n  eta               := false\n  iota              := false\n  proj              := false\n  decide            := false\n  arith             := false\n  autoUnfold        := false\n}", "start": [1270, 1], "end": [1279, 2], "kind": "commanddeclaration"}, {"full_name": "Meta.Occurrences", "code": "inductive Occurrences where\n  | all\n  | pos (idxs : List Nat)\n  | neg (idxs : List Nat)\n  deriving Inhabited, BEq", "start": [1283, 1], "end": [1287, 26], "kind": "commanddeclaration"}, {"full_name": "Meta.Occurrences.contains", "code": "def Occurrences.contains : Occurrences \u2192 Nat \u2192 Bool\n  | all,      _   => true\n  | pos idxs, idx => idxs.contains idx\n  | neg idxs, idx => !idxs.contains idx", "start": [1289, 1], "end": [1292, 40], "kind": "commanddeclaration"}, {"full_name": "Meta.Occurrences.isAll", "code": "def Occurrences.isAll : Occurrences \u2192 Bool\n  | all => true\n  | _   => false", "start": [1294, 1], "end": [1296, 17], "kind": "commanddeclaration"}, {"full_name": "Meta.Rewrite.Config", "code": "structure Config where\n  transparency : TransparencyMode := TransparencyMode.reducible\n  offsetCnstrs : Bool := true\n  occs : Occurrences := Occurrences.all", "start": [1300, 1], "end": [1303, 40], "kind": "commanddeclaration"}, {"full_name": "Parser.Tactic.expandSimp", "code": "@[macro $tacName] def expandSimp : Macro := fun s => do\n      let c \u2190 match s[1][0] with\n        | `(config| (config := $$c)) => `(config| (config := $updateCfg $$c))\n        | _ => `(config| (config := $updateCfg {}))\n      let s := s.setKind $kind\n      let s := s.setArg 0 (mkAtomFrom s[0] $tkn (canonical := true))\n      let r := s.setArg 1 (mkNullNode #[c])\n      return r", "start": [1331, 5], "end": [1338, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/ToString/Macro.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean", "lake-packages/lean4/src/lean/Init/Meta.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Array/Subarray.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean"], "premises": [{"full_name": "Subarray", "code": "structure Subarray (\u03b1 : Type u)  where\n  as : Array \u03b1\n  start : Nat\n  stop : Nat\n  h\u2081 : start \u2264 stop\n  h\u2082 : stop \u2264 as.size", "start": [11, 1], "end": [16, 22], "kind": "commanddeclaration"}, {"full_name": "Subarray.size", "code": "def size (s : Subarray \u03b1) : Nat :=\n  s.stop - s.start", "start": [20, 1], "end": [21, 19], "kind": "commanddeclaration"}, {"full_name": "Subarray.get", "code": "def get (s : Subarray \u03b1) (i : Fin s.size) : \u03b1 :=\n  have : s.start + i.val < s.as.size := by\n   apply Nat.lt_of_lt_of_le _ s.h\u2082\n   have := i.isLt\n   simp [size] at this\n   rw [Nat.add_comm]\n   exact Nat.add_lt_of_lt_sub this\n  s.as[s.start + i.val]", "start": [23, 1], "end": [30, 24], "kind": "commanddeclaration"}, {"full_name": "Subarray.getD", "code": "@[inline] def getD (s : Subarray \u03b1) (i : Nat) (v\u2080 : \u03b1) : \u03b1 :=\n  if h : i < s.size then s.get \u27e8i, h\u27e9 else v\u2080", "start": [35, 1], "end": [36, 46], "kind": "commanddeclaration"}, {"full_name": "Subarray.get!", "code": "abbrev get! [Inhabited \u03b1] (s : Subarray \u03b1) (i : Nat) : \u03b1 :=\n  getD s i default", "start": [38, 1], "end": [39, 19], "kind": "commanddeclaration"}, {"full_name": "Subarray.popFront", "code": "def popFront (s : Subarray \u03b1) : Subarray \u03b1 :=\n  if h : s.start < s.stop then\n    { s with start := s.start + 1, h\u2081 := Nat.le_of_lt_succ (Nat.add_lt_add_right h 1) }\n  else\n    s", "start": [41, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "Subarray.forInUnsafe", "code": "@[inline] unsafe def forInUnsafe {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (s : Subarray \u03b1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let sz := USize.ofNat s.stop\n  let rec @[specialize] loop (i : USize) (b : \u03b2) : m \u03b2 := do\n    if i < sz then\n      let a := s.as.uget i lcProof\n      match (\u2190 f a b) with\n      | ForInStep.done  b => pure b\n      | ForInStep.yield b => loop (i+1) b\n    else\n      pure b\n  loop (USize.ofNat s.start) b", "start": [47, 1], "end": [57, 31], "kind": "commanddeclaration"}, {"full_name": "Subarray.forIn", "code": "@[implemented_by Subarray.forInUnsafe]\nprotected opaque forIn {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (s : Subarray \u03b1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  pure b", "start": [60, 1], "end": [62, 9], "kind": "commanddeclaration"}, {"full_name": "Subarray.foldlM", "code": "@[inline]\ndef foldlM {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (init : \u03b2) (as : Subarray \u03b1) : m \u03b2 :=\n  as.as.foldlM f (init := init) (start := as.start) (stop := as.stop)", "start": [67, 1], "end": [69, 70], "kind": "commanddeclaration"}, {"full_name": "Subarray.foldrM", "code": "@[inline]\ndef foldrM {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (init : \u03b2) (as : Subarray \u03b1) : m \u03b2 :=\n  as.as.foldrM f (init := init) (start := as.stop) (stop := as.start)", "start": [71, 1], "end": [73, 70], "kind": "commanddeclaration"}, {"full_name": "Subarray.anyM", "code": "@[inline]\ndef anyM {\u03b1 : Type u} {m : Type \u2192 Type w} [Monad m] (p : \u03b1 \u2192 m Bool) (as : Subarray \u03b1) : m Bool :=\n  as.as.anyM p (start := as.start) (stop := as.stop)", "start": [75, 1], "end": [77, 53], "kind": "commanddeclaration"}, {"full_name": "Subarray.allM", "code": "@[inline]\ndef allM {\u03b1 : Type u} {m : Type \u2192 Type w} [Monad m] (p : \u03b1 \u2192 m Bool) (as : Subarray \u03b1) : m Bool :=\n  as.as.allM p (start := as.start) (stop := as.stop)", "start": [79, 1], "end": [81, 53], "kind": "commanddeclaration"}, {"full_name": "Subarray.forM", "code": "@[inline]\ndef forM {\u03b1 : Type u} {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 m PUnit) (as : Subarray \u03b1) : m PUnit :=\n  as.as.forM f (start := as.start) (stop := as.stop)", "start": [83, 1], "end": [85, 53], "kind": "commanddeclaration"}, {"full_name": "Subarray.forRevM", "code": "@[inline]\ndef forRevM {\u03b1 : Type u} {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 m PUnit) (as : Subarray \u03b1) : m PUnit :=\n  as.as.forRevM f (start := as.stop) (stop := as.start)", "start": [87, 1], "end": [89, 56], "kind": "commanddeclaration"}, {"full_name": "Subarray.foldl", "code": "@[inline]\ndef foldl {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (init : \u03b2) (as : Subarray \u03b1) : \u03b2 :=\n  Id.run <| as.foldlM f (init := init)", "start": [91, 1], "end": [93, 39], "kind": "commanddeclaration"}, {"full_name": "Subarray.foldr", "code": "@[inline]\ndef foldr {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) (as : Subarray \u03b1) : \u03b2 :=\n  Id.run <| as.foldrM f (init := init)", "start": [95, 1], "end": [97, 39], "kind": "commanddeclaration"}, {"full_name": "Subarray.any", "code": "@[inline]\ndef any {\u03b1 : Type u} (p : \u03b1 \u2192 Bool) (as : Subarray \u03b1) : Bool :=\n  Id.run <| as.anyM p", "start": [99, 1], "end": [101, 22], "kind": "commanddeclaration"}, {"full_name": "Subarray.all", "code": "@[inline]\ndef all {\u03b1 : Type u} (p : \u03b1 \u2192 Bool) (as : Subarray \u03b1) : Bool :=\n  Id.run <| as.allM p", "start": [103, 1], "end": [105, 22], "kind": "commanddeclaration"}, {"full_name": "Subarray.findSomeRevM?", "code": "@[inline]\ndef findSomeRevM? {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : Subarray \u03b1) (f : \u03b1 \u2192 m (Option \u03b2)) : m (Option \u03b2) :=\n  let rec @[specialize] find : (i : Nat) \u2192 i \u2264 as.size \u2192 m (Option \u03b2)\n    | 0,   _ => pure none\n    | i+1, h => do\n      have : i < as.size := Nat.lt_of_lt_of_le (Nat.lt_succ_self _) h\n      let r \u2190 f as[i]\n      match r with\n      | some _ => pure r\n      | none   =>\n        have : i \u2264 as.size := Nat.le_of_lt this\n        find i this\n  find as.size (Nat.le_refl _)", "start": [107, 1], "end": [119, 31], "kind": "commanddeclaration"}, {"full_name": "Subarray.findRevM?", "code": "@[inline]\ndef findRevM? {\u03b1 : Type} {m : Type \u2192 Type w} [Monad m] (as : Subarray \u03b1) (p : \u03b1 \u2192 m Bool) : m (Option \u03b1) :=\n  as.findSomeRevM? fun a => return if (\u2190 p a) then some a else none", "start": [121, 1], "end": [123, 68], "kind": "commanddeclaration"}, {"full_name": "Subarray.findRev?", "code": "@[inline]\ndef findRev? {\u03b1 : Type} (as : Subarray \u03b1) (p : \u03b1 \u2192 Bool) : Option \u03b1 :=\n  Id.run <| as.findRevM? p", "start": [125, 1], "end": [127, 27], "kind": "commanddeclaration"}, {"full_name": "Array.toSubarray", "code": "def toSubarray (as : Array \u03b1) (start : Nat := 0) (stop : Nat := as.size) : Subarray \u03b1 :=\n  if h\u2082 : stop \u2264 as.size then\n     if h\u2081 : start \u2264 stop then\n       { as := as, start := start, stop := stop, h\u2081 := h\u2081, h\u2082 := h\u2082 }\n     else\n       { as := as, start := stop, stop := stop, h\u2081 := Nat.le_refl _, h\u2082 := h\u2082 }\n  else\n     if h\u2081 : start \u2264 as.size then\n       { as := as, start := start, stop := as.size, h\u2081 := h\u2081, h\u2082 := Nat.le_refl _ }\n     else\n       { as := as, start := as.size, stop := as.size, h\u2081 := Nat.le_refl _, h\u2082 := Nat.le_refl _ }", "start": [134, 1], "end": [144, 97], "kind": "commanddeclaration"}, {"full_name": "Array.ofSubarray", "code": "def ofSubarray (s : Subarray \u03b1) : Array \u03b1 := Id.run do\n  let mut as := mkEmpty (s.stop - s.start)\n  for a in s do\n    as := as.push a\n  return as", "start": [146, 1], "end": [150, 12], "kind": "commanddeclaration"}, {"full_name": "Subarray.toArray", "code": "def Subarray.toArray (s : Subarray \u03b1) : Array \u03b1 :=\n  Array.ofSubarray s", "start": [165, 1], "end": [166, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/ToString.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Macro.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/NotationExtra.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/ToString.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Subarray.lean", "lake-packages/lean4/src/lean/Init/Meta.lean"], "premises": [{"full_name": "Lean.expandExplicitBindersAux", "code": "def expandExplicitBindersAux (combinator : Syntax) (idents : Array Syntax) (type? : Option Syntax) (body : Syntax) : MacroM Syntax :=\n  let rec loop (i : Nat) (acc : Syntax) := do\n    match i with\n    | 0   => pure acc\n    | i+1 =>\n      let ident := idents[i]![0]\n      let acc \u2190 match ident.isIdent, type? with\n        | true,  none      => `($combinator fun $ident => $acc)\n        | true,  some type => `($combinator fun $ident : $type => $acc)\n        | false, none      => `($combinator fun _ => $acc)\n        | false, some type => `($combinator fun _ : $type => $acc)\n      loop i acc\n  loop idents.size body", "start": [24, 1], "end": [36, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.expandBrackedBindersAux", "code": "def expandBrackedBindersAux (combinator : Syntax) (binders : Array Syntax) (body : Syntax) : MacroM Syntax :=\n  let rec loop (i : Nat) (acc : Syntax) := do\n    match i with\n    | 0   => pure acc\n    | i+1 =>\n      let idents := binders[i]![1].getArgs\n      let type   := binders[i]![3]\n      loop i (\u2190 expandExplicitBindersAux combinator idents (some type) acc)\n  loop binders.size body", "start": [38, 1], "end": [46, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.expandExplicitBinders", "code": "def expandExplicitBinders (combinatorDeclName : Name) (explicitBinders : Syntax) (body : Syntax) : MacroM Syntax := do\n  let combinator := mkCIdentFrom (\u2190 getRef) combinatorDeclName\n  let explicitBinders := explicitBinders[0]\n  if explicitBinders.getKind == ``Lean.unbracketedExplicitBinders then\n    let idents   := explicitBinders[0].getArgs\n    let type? := if explicitBinders[1].isNone then none else some explicitBinders[1][1]\n    expandExplicitBindersAux combinator idents type? body\n  else if explicitBinders.getArgs.all (\u00b7.getKind == ``Lean.bracketedExplicitBinders) then\n    expandBrackedBindersAux combinator explicitBinders.getArgs body\n  else\n    Macro.throwError \"unexpected explicit binder\"", "start": [48, 1], "end": [58, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.expandBrackedBinders", "code": "def expandBrackedBinders (combinatorDeclName : Name) (bracketedExplicitBinders : Syntax) (body : Syntax) : MacroM Syntax := do\n  let combinator := mkCIdentFrom (\u2190 getRef) combinatorDeclName\n  expandBrackedBindersAux combinator #[bracketedExplicitBinders] body", "start": [60, 1], "end": [62, 70], "kind": "commanddeclaration"}, {"full_name": "unexpandUnit", "code": "@[app_unexpander Unit.unit] def unexpandUnit : Lean.PrettyPrinter.Unexpander\n  | `($(_)) => `(())", "start": [173, 1], "end": [174, 21], "kind": "commanddeclaration"}, {"full_name": "unexpandListNil", "code": "@[app_unexpander List.nil] def unexpandListNil : Lean.PrettyPrinter.Unexpander\n  | `($(_)) => `([])", "start": [176, 1], "end": [177, 21], "kind": "commanddeclaration"}, {"full_name": "unexpandListCons", "code": "@[app_unexpander List.cons] def unexpandListCons : Lean.PrettyPrinter.Unexpander\n  | `($(_) $x [])      => `([$x])\n  | `($(_) $x [$xs,*]) => `([$x, $xs,*])\n  | _                  => throw ()", "start": [179, 1], "end": [182, 35], "kind": "commanddeclaration"}, {"full_name": "unexpandListToArray", "code": "@[app_unexpander List.toArray] def unexpandListToArray : Lean.PrettyPrinter.Unexpander\n  | `($(_) [$xs,*]) => `(#[$xs,*])\n  | _               => throw ()", "start": [184, 1], "end": [186, 32], "kind": "commanddeclaration"}, {"full_name": "unexpandProdMk", "code": "@[app_unexpander Prod.mk] def unexpandProdMk : Lean.PrettyPrinter.Unexpander\n  | `($(_) $x ($y, $ys,*)) => `(($x, $y, $ys,*))\n  | `($(_) $x $y)          => `(($x, $y))\n  | _                      => throw ()", "start": [188, 1], "end": [191, 39], "kind": "commanddeclaration"}, {"full_name": "unexpandIte", "code": "@[app_unexpander ite] def unexpandIte : Lean.PrettyPrinter.Unexpander\n  | `($(_) $c $t $e) => `(if $c then $t else $e)\n  | _                => throw ()", "start": [193, 1], "end": [195, 33], "kind": "commanddeclaration"}, {"full_name": "unexpandSorryAx", "code": "@[app_unexpander sorryAx] def unexpandSorryAx : Lean.PrettyPrinter.Unexpander\n  | `($(_) _)   => `(sorry)\n  | `($(_) _ _) => `(sorry)\n  | _           => throw ()", "start": [197, 1], "end": [200, 28], "kind": "commanddeclaration"}, {"full_name": "unexpandEqNDRec", "code": "@[app_unexpander Eq.ndrec] def unexpandEqNDRec : Lean.PrettyPrinter.Unexpander\n  | `($(_) $m $h) => `($h \u25b8 $m)\n  | _             => throw ()", "start": [202, 1], "end": [204, 30], "kind": "commanddeclaration"}, {"full_name": "unexpandEqRec", "code": "@[app_unexpander Eq.rec] def unexpandEqRec : Lean.PrettyPrinter.Unexpander\n  | `($(_) $m $h) => `($h \u25b8 $m)\n  | _             => throw ()", "start": [206, 1], "end": [208, 30], "kind": "commanddeclaration"}, {"full_name": "unexpandExists", "code": "@[app_unexpander Exists] def unexpandExists : Lean.PrettyPrinter.Unexpander\n  | `($(_) fun $x:ident => \u2203 $xs:binderIdent*, $b) => `(\u2203 $x:ident $xs:binderIdent*, $b)\n  | `($(_) fun $x:ident => $b)                     => `(\u2203 $x:ident, $b)\n  | `($(_) fun ($x:ident : $t) => $b)              => `(\u2203 ($x:ident : $t), $b)\n  | _                                              => throw ()", "start": [210, 1], "end": [214, 63], "kind": "commanddeclaration"}, {"full_name": "unexpandSigma", "code": "@[app_unexpander Sigma] def unexpandSigma : Lean.PrettyPrinter.Unexpander\n  | `($(_) fun ($x:ident : $t) => $b) => `(($x:ident : $t) \u00d7 $b)\n  | _                                  => throw ()", "start": [216, 1], "end": [218, 51], "kind": "commanddeclaration"}, {"full_name": "unexpandPSigma", "code": "@[app_unexpander PSigma] def unexpandPSigma : Lean.PrettyPrinter.Unexpander\n  | `($(_) fun ($x:ident : $t) => $b) => `(($x:ident : $t) \u00d7' $b)\n  | _                                 => throw ()", "start": [220, 1], "end": [222, 50], "kind": "commanddeclaration"}, {"full_name": "unexpandSubtype", "code": "@[app_unexpander Subtype] def unexpandSubtype : Lean.PrettyPrinter.Unexpander\n  | `($(_) fun ($x:ident : $type) => $p)  => `({ $x : $type // $p })\n  | `($(_) fun $x:ident => $p)            => `({ $x // $p })\n  | _                                     => throw ()", "start": [224, 1], "end": [227, 54], "kind": "commanddeclaration"}, {"full_name": "unexpandTSyntax", "code": "@[app_unexpander TSyntax] def unexpandTSyntax : Lean.PrettyPrinter.Unexpander\n  | `($f [$k])  => `($f $k)\n  | _           => throw ()", "start": [229, 1], "end": [231, 28], "kind": "commanddeclaration"}, {"full_name": "unexpandTSyntaxArray", "code": "@[app_unexpander TSyntaxArray] def unexpandTSyntaxArray : Lean.PrettyPrinter.Unexpander\n  | `($f [$k])  => `($f $k)\n  | _           => throw ()", "start": [233, 1], "end": [235, 28], "kind": "commanddeclaration"}, {"full_name": "unexpandTSepArray", "code": "@[app_unexpander Syntax.TSepArray] def unexpandTSepArray : Lean.PrettyPrinter.Unexpander\n  | `($f [$k] $sep)  => `($f $k $sep)\n  | _                => throw ()", "start": [237, 1], "end": [239, 33], "kind": "commanddeclaration"}, {"full_name": "unexpandGetElem", "code": "@[app_unexpander GetElem.getElem] def unexpandGetElem : Lean.PrettyPrinter.Unexpander\n  | `($_ $array $index $_) => `($array[$index])\n  | _ => throw ()", "start": [241, 1], "end": [243, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandGetElem!", "code": "@[app_unexpander getElem!] def unexpandGetElem! : Lean.PrettyPrinter.Unexpander\n  | `($_ $array $index) => `($array[$index]!)\n  | _ => throw ()", "start": [245, 1], "end": [247, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandGetElem?", "code": "@[app_unexpander getElem?] def unexpandGetElem? : Lean.PrettyPrinter.Unexpander\n  | `($_ $array $index) => `($array[$index]?)\n  | _ => throw ()", "start": [249, 1], "end": [251, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandMkStr1", "code": "@[app_unexpander Name.mkStr1] def unexpandMkStr1 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a:str) => return mkNode `Lean.Parser.Term.quotedName #[Syntax.mkNameLit s!\"`{a.getString}\"]\n  | _  => throw ()", "start": [253, 1], "end": [255, 19], "kind": "commanddeclaration"}, {"full_name": "unexpandMkStr2", "code": "@[app_unexpander Name.mkStr2] def unexpandMkStr2 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1:str $a2:str) => return mkNode `Lean.Parser.Term.quotedName #[Syntax.mkNameLit s!\"`{a1.getString}.{a2.getString}\"]\n  | _  => throw ()", "start": [257, 1], "end": [259, 19], "kind": "commanddeclaration"}, {"full_name": "unexpandMkStr3", "code": "@[app_unexpander Name.mkStr3] def unexpandMkStr3 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1:str $a2:str $a3:str) => return mkNode `Lean.Parser.Term.quotedName #[Syntax.mkNameLit s!\"`{a1.getString}.{a2.getString}.{a3.getString}\"]\n  | _  => throw ()", "start": [261, 1], "end": [263, 19], "kind": "commanddeclaration"}, {"full_name": "unexpandMkStr4", "code": "@[app_unexpander Name.mkStr4] def unexpandMkStr4 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1:str $a2:str $a3:str $a4:str) => return mkNode `Lean.Parser.Term.quotedName #[Syntax.mkNameLit s!\"`{a1.getString}.{a2.getString}.{a3.getString}.{a4.getString}\"]\n  | _  => throw ()", "start": [265, 1], "end": [267, 19], "kind": "commanddeclaration"}, {"full_name": "unexpandMkStr5", "code": "@[app_unexpander Name.mkStr5] def unexpandMkStr5 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1:str $a2:str $a3:str $a4:str $a5:str) => return mkNode `Lean.Parser.Term.quotedName #[Syntax.mkNameLit s!\"`{a1.getString}.{a2.getString}.{a3.getString}.{a4.getString}.{a5.getString}\"]\n  | _  => throw ()", "start": [269, 1], "end": [271, 19], "kind": "commanddeclaration"}, {"full_name": "unexpandMkStr6", "code": "@[app_unexpander Name.mkStr6] def unexpandMkStr6 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1:str $a2:str $a3:str $a4:str $a5:str $a6:str) => return mkNode `Lean.Parser.Term.quotedName #[Syntax.mkNameLit s!\"`{a1.getString}.{a2.getString}.{a3.getString}.{a4.getString}.{a5.getString}.{a6.getString}\"]\n  | _  => throw ()", "start": [273, 1], "end": [275, 19], "kind": "commanddeclaration"}, {"full_name": "unexpandMkStr7", "code": "@[app_unexpander Name.mkStr7] def unexpandMkStr7 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1:str $a2:str $a3:str $a4:str $a5:str $a6:str $a7:str) => return mkNode `Lean.Parser.Term.quotedName #[Syntax.mkNameLit s!\"`{a1.getString}.{a2.getString}.{a3.getString}.{a4.getString}.{a5.getString}.{a6.getString}.{a7.getString}\"]\n  | _  => throw ()", "start": [277, 1], "end": [279, 19], "kind": "commanddeclaration"}, {"full_name": "unexpandMkStr8", "code": "@[app_unexpander Name.mkStr8] def unexpandMkStr8 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1:str $a2:str $a3:str $a4:str $a5:str $a6:str $a7:str $a8:str) => return mkNode `Lean.Parser.Term.quotedName #[Syntax.mkNameLit s!\"`{a1.getString}.{a2.getString}.{a3.getString}.{a4.getString}.{a5.getString}.{a6.getString}.{a7.getString}.{a8.getString}\"]\n  | _  => throw ()", "start": [281, 1], "end": [283, 19], "kind": "commanddeclaration"}, {"full_name": "unexpandArrayEmpty", "code": "@[app_unexpander Array.empty] def unexpandArrayEmpty : Lean.PrettyPrinter.Unexpander\n  | _ => `(#[])", "start": [285, 1], "end": [286, 16], "kind": "commanddeclaration"}, {"full_name": "unexpandMkArray0", "code": "@[app_unexpander Array.mkArray0] def unexpandMkArray0 : Lean.PrettyPrinter.Unexpander\n  | _ => `(#[])", "start": [288, 1], "end": [289, 16], "kind": "commanddeclaration"}, {"full_name": "unexpandMkArray1", "code": "@[app_unexpander Array.mkArray1] def unexpandMkArray1 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1) => `(#[$a1])\n  | _ => throw ()", "start": [291, 1], "end": [293, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandMkArray2", "code": "@[app_unexpander Array.mkArray2] def unexpandMkArray2 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1 $a2) => `(#[$a1, $a2])\n  | _ => throw ()", "start": [295, 1], "end": [297, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandMkArray3", "code": "@[app_unexpander Array.mkArray3] def unexpandMkArray3 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1 $a2 $a3) => `(#[$a1, $a2, $a3])\n  | _ => throw ()", "start": [299, 1], "end": [301, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandMkArray4", "code": "@[app_unexpander Array.mkArray4] def unexpandMkArray4 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1 $a2 $a3 $a4) => `(#[$a1, $a2, $a3, $a4])\n  | _ => throw ()", "start": [303, 1], "end": [305, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandMkArray5", "code": "@[app_unexpander Array.mkArray5] def unexpandMkArray5 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1 $a2 $a3 $a4 $a5) => `(#[$a1, $a2, $a3, $a4, $a5])\n  | _ => throw ()", "start": [307, 1], "end": [309, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandMkArray6", "code": "@[app_unexpander Array.mkArray6] def unexpandMkArray6 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1 $a2 $a3 $a4 $a5 $a6) => `(#[$a1, $a2, $a3, $a4, $a5, $a6])\n  | _ => throw ()", "start": [311, 1], "end": [313, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandMkArray7", "code": "@[app_unexpander Array.mkArray7] def unexpandMkArray7 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1 $a2 $a3 $a4 $a5 $a6 $a7) => `(#[$a1, $a2, $a3, $a4, $a5, $a6, $a7])\n  | _ => throw ()", "start": [315, 1], "end": [317, 18], "kind": "commanddeclaration"}, {"full_name": "unexpandMkArray8", "code": "@[app_unexpander Array.mkArray8] def unexpandMkArray8 : Lean.PrettyPrinter.Unexpander\n  | `($(_) $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8) => `(#[$a1, $a2, $a3, $a4, $a5, $a6, $a7, $a8])\n  | _ => throw ()", "start": [319, 1], "end": [321, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Loop", "code": "inductive Loop where\n  | mk", "start": [391, 1], "end": [392, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Loop.forIn", "code": "@[inline]\npartial def Loop.forIn {\u03b2 : Type u} {m : Type u \u2192 Type v} [Monad m] (_ : Loop) (init : \u03b2) (f : Unit \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let rec @[specialize] loop (b : \u03b2) : m \u03b2 := do\n    match \u2190 f () b with\n      | ForInStep.done b  => pure b\n      | ForInStep.yield b => loop b\n  loop init", "start": [394, 1], "end": [400, 12], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/ByteArray/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/UInt/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Subarray.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Option/Basic.lean"], "premises": [{"full_name": "ByteArray", "code": "structure ByteArray where\n  data : Array UInt8", "start": [13, 1], "end": [14, 21], "kind": "commanddeclaration"}, {"full_name": "ByteArray.mkEmpty", "code": "@[extern \"lean_mk_empty_byte_array\"]\ndef mkEmpty (c : @& Nat) : ByteArray :=\n  { data := #[] }", "start": [20, 1], "end": [22, 18], "kind": "commanddeclaration"}, {"full_name": "ByteArray.empty", "code": "def empty : ByteArray := mkEmpty 0", "start": [24, 1], "end": [24, 35], "kind": "commanddeclaration"}, {"full_name": "ByteArray.push", "code": "@[extern \"lean_byte_array_push\"]\ndef push : ByteArray \u2192 UInt8 \u2192 ByteArray\n  | \u27e8bs\u27e9, b => \u27e8bs.push b\u27e9", "start": [32, 1], "end": [34, 27], "kind": "commanddeclaration"}, {"full_name": "ByteArray.size", "code": "@[extern \"lean_byte_array_size\"]\ndef size : (@& ByteArray) \u2192 Nat\n  | \u27e8bs\u27e9 => bs.size", "start": [36, 1], "end": [38, 20], "kind": "commanddeclaration"}, {"full_name": "ByteArray.uget", "code": "@[extern \"lean_byte_array_uget\"]\ndef uget : (a : @& ByteArray) \u2192 (i : USize) \u2192 i.toNat < a.size \u2192 UInt8\n  | \u27e8bs\u27e9, i, h => bs[i]", "start": [40, 1], "end": [42, 24], "kind": "commanddeclaration"}, {"full_name": "ByteArray.get!", "code": "@[extern \"lean_byte_array_get\"]\ndef get! : (@& ByteArray) \u2192 (@& Nat) \u2192 UInt8\n  | \u27e8bs\u27e9, i => bs.get! i", "start": [44, 1], "end": [46, 25], "kind": "commanddeclaration"}, {"full_name": "ByteArray.get", "code": "@[extern \"lean_byte_array_fget\"]\ndef get : (a : @& ByteArray) \u2192 (@& Fin a.size) \u2192 UInt8\n  | \u27e8bs\u27e9, i => bs.get i", "start": [48, 1], "end": [50, 24], "kind": "commanddeclaration"}, {"full_name": "ByteArray.set!", "code": "@[extern \"lean_byte_array_set\"]\ndef set! : ByteArray \u2192 (@& Nat) \u2192 UInt8 \u2192 ByteArray\n  | \u27e8bs\u27e9, i, b => \u27e8bs.set! i b\u27e9", "start": [58, 1], "end": [60, 32], "kind": "commanddeclaration"}, {"full_name": "ByteArray.set", "code": "@[extern \"lean_byte_array_fset\"]\ndef set : (a : ByteArray) \u2192 (@& Fin a.size) \u2192 UInt8 \u2192 ByteArray\n  | \u27e8bs\u27e9, i, b => \u27e8bs.set i b\u27e9", "start": [62, 1], "end": [64, 31], "kind": "commanddeclaration"}, {"full_name": "ByteArray.uset", "code": "@[extern \"lean_byte_array_uset\"]\ndef uset : (a : ByteArray) \u2192 (i : USize) \u2192 UInt8 \u2192 i.toNat < a.size \u2192 ByteArray\n  | \u27e8bs\u27e9, i, v, h => \u27e8bs.uset i v h\u27e9", "start": [66, 1], "end": [68, 37], "kind": "commanddeclaration"}, {"full_name": "ByteArray.hash", "code": "@[extern \"lean_byte_array_hash\"]\nprotected opaque hash (a : @& ByteArray) : UInt64", "start": [70, 1], "end": [71, 50], "kind": "commanddeclaration"}, {"full_name": "ByteArray.isEmpty", "code": "def isEmpty (s : ByteArray) : Bool :=\n  s.size == 0", "start": [76, 1], "end": [77, 14], "kind": "commanddeclaration"}, {"full_name": "ByteArray.copySlice", "code": "@[extern \"lean_byte_array_copy_slice\"]\ndef copySlice (src : @& ByteArray) (srcOff : Nat) (dest : ByteArray) (destOff len : Nat) (exact : Bool := true) : ByteArray :=\n  \u27e8dest.data.extract 0 destOff ++ src.data.extract srcOff (srcOff + len) ++ dest.data.extract (destOff + len) dest.data.size\u27e9", "start": [79, 1], "end": [84, 126], "kind": "commanddeclaration"}, {"full_name": "ByteArray.extract", "code": "def extract (a : ByteArray) (b e : Nat) : ByteArray :=\n  a.copySlice b empty 0 (e - b)", "start": [86, 1], "end": [87, 32], "kind": "commanddeclaration"}, {"full_name": "ByteArray.append", "code": "protected def append (a : ByteArray) (b : ByteArray) : ByteArray :=\n  b.copySlice 0 a a.size b.size false", "start": [89, 1], "end": [91, 38], "kind": "commanddeclaration"}, {"full_name": "ByteArray.toList", "code": "partial def toList (bs : ByteArray) : List UInt8 :=\n  let rec loop (i : Nat) (r : List UInt8) :=\n    if i < bs.size then\n      loop (i+1) (bs.get! i :: r)\n    else\n      r.reverse\n  loop 0 []", "start": [95, 1], "end": [101, 12], "kind": "commanddeclaration"}, {"full_name": "ByteArray.findIdx?", "code": "@[inline] partial def findIdx? (a : ByteArray) (p : UInt8 \u2192 Bool) (start := 0) : Option Nat :=\n  let rec @[specialize] loop (i : Nat) :=\n    if i < a.size then\n      if p (a.get! i) then some i else loop (i+1)\n    else\n      none\n  loop start", "start": [103, 1], "end": [109, 13], "kind": "commanddeclaration"}, {"full_name": "ByteArray.forInUnsafe", "code": "@[inline] unsafe def forInUnsafe {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : ByteArray) (b : \u03b2) (f : UInt8 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let sz := USize.ofNat as.size\n  let rec @[specialize] loop (i : USize) (b : \u03b2) : m \u03b2 := do\n    if i < sz then\n      let a := as.uget i lcProof\n      match (\u2190 f a b) with\n      | ForInStep.done  b => pure b\n      | ForInStep.yield b => loop (i+1) b\n    else\n      pure b\n  loop 0 b", "start": [111, 1], "end": [127, 11], "kind": "commanddeclaration"}, {"full_name": "ByteArray.forIn", "code": "@[implemented_by ByteArray.forInUnsafe]\nprotected def forIn {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : ByteArray) (b : \u03b2) (f : UInt8 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let rec loop (i : Nat) (h : i \u2264 as.size) (b : \u03b2) : m \u03b2 := do\n    match i, h with\n    | 0,   _ => pure b\n    | i+1, h =>\n      have h' : i < as.size            := Nat.lt_of_lt_of_le (Nat.lt_succ_self i) h\n      have : as.size - 1 < as.size     := Nat.sub_lt (Nat.zero_lt_of_lt h') (by decide)\n      have : as.size - 1 - i < as.size := Nat.lt_of_le_of_lt (Nat.sub_le (as.size - 1) i) this\n      match (\u2190 f (as.get \u27e8as.size - 1 - i, this\u27e9) b) with\n      | ForInStep.done b  => pure b\n      | ForInStep.yield b => loop i (Nat.le_of_lt h') b\n  loop as.size (Nat.le_refl _) b", "start": [129, 1], "end": [142, 33], "kind": "commanddeclaration"}, {"full_name": "ByteArray.foldlMUnsafe", "code": "@[inline]\nunsafe def foldlMUnsafe {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b2 \u2192 UInt8 \u2192 m \u03b2) (init : \u03b2) (as : ByteArray) (start := 0) (stop := as.size) : m \u03b2 :=\n  let rec @[specialize] fold (i : USize) (stop : USize) (b : \u03b2) : m \u03b2 := do\n    if i == stop then\n      pure b\n    else\n      fold (i+1) stop (\u2190 f b (as.uget i lcProof))\n  if start < stop then\n    if stop \u2264 as.size then\n      fold (USize.ofNat start) (USize.ofNat stop) init\n    else\n      pure init\n  else\n    pure init", "start": [147, 1], "end": [162, 14], "kind": "commanddeclaration"}, {"full_name": "ByteArray.foldlM", "code": "@[implemented_by foldlMUnsafe]\ndef foldlM {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b2 \u2192 UInt8 \u2192 m \u03b2) (init : \u03b2) (as : ByteArray) (start := 0) (stop := as.size) : m \u03b2 :=\n  let fold (stop : Nat) (h : stop \u2264 as.size) :=\n    let rec loop (i : Nat) (j : Nat) (b : \u03b2) : m \u03b2 := do\n      if hlt : j < stop then\n        match i with\n        | 0    => pure b\n        | i'+1 =>\n          loop i' (j+1) (\u2190 f b (as.get \u27e8j, Nat.lt_of_lt_of_le hlt h\u27e9))\n      else\n        pure b\n    loop (stop - start) start init\n  if h : stop \u2264 as.size then\n    fold stop h\n  else\n    fold as.size (Nat.le_refl _)", "start": [164, 1], "end": [180, 33], "kind": "commanddeclaration"}, {"full_name": "ByteArray.foldl", "code": "@[inline]\ndef foldl {\u03b2 : Type v} (f : \u03b2 \u2192 UInt8 \u2192 \u03b2) (init : \u03b2) (as : ByteArray) (start := 0) (stop := as.size) : \u03b2 :=\n  Id.run <| as.foldlM f init start stop", "start": [182, 1], "end": [184, 40], "kind": "commanddeclaration"}, {"full_name": "List.toByteArray", "code": "def List.toByteArray (bs : List UInt8) : ByteArray :=\n  let rec loop\n    | [],    r => r\n    | b::bs, r => loop bs (r.push b)\n  loop bs ByteArray.empty", "start": [188, 1], "end": [192, 26], "kind": "commanddeclaration"}, {"full_name": "ByteArray.toUInt64LE!", "code": "def ByteArray.toUInt64LE! (bs : ByteArray) : UInt64 :=\n  assert! bs.size == 8\n  (bs.get! 0).toUInt64 <<< 0x38 |||\n  (bs.get! 1).toUInt64 <<< 0x30 |||\n  (bs.get! 2).toUInt64 <<< 0x28 |||\n  (bs.get! 3).toUInt64 <<< 0x20 |||\n  (bs.get! 4).toUInt64 <<< 0x18 |||\n  (bs.get! 5).toUInt64 <<< 0x10 |||\n  (bs.get! 6).toUInt64 <<< 0x8  |||\n  (bs.get! 7).toUInt64", "start": [196, 1], "end": [206, 23], "kind": "commanddeclaration"}, {"full_name": "ByteArray.toUInt64BE!", "code": "def ByteArray.toUInt64BE! (bs : ByteArray) : UInt64 :=\n  assert! bs.size == 8\n  (bs.get! 7).toUInt64 <<< 0x38 |||\n  (bs.get! 6).toUInt64 <<< 0x30 |||\n  (bs.get! 5).toUInt64 <<< 0x28 |||\n  (bs.get! 4).toUInt64 <<< 0x20 |||\n  (bs.get! 3).toUInt64 <<< 0x18 |||\n  (bs.get! 2).toUInt64 <<< 0x10 |||\n  (bs.get! 1).toUInt64 <<< 0x8  |||\n  (bs.get! 0).toUInt64", "start": [208, 1], "end": [218, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Prod.lean", "imports": ["lake-packages/lean4/src/lean/Init/SimpLemmas.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Classical.lean", "imports": ["lake-packages/lean4/src/lean/Init/Core.lean", "lake-packages/lean4/src/lean/Init/NotationExtra.lean"], "premises": [{"full_name": "Classical.indefiniteDescription", "code": "noncomputable def indefiniteDescription {\u03b1 : Sort u} (p : \u03b1 \u2192 Prop) (h : \u2203 x, p x) : {x // p x} :=\n  choice <| let \u27e8x, px\u27e9 := h; \u27e8\u27e8x, px\u27e9\u27e9", "start": [16, 1], "end": [17, 40], "kind": "commanddeclaration"}, {"full_name": "Classical.choose", "code": "noncomputable def choose {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} (h : \u2203 x, p x) : \u03b1 :=\n  (indefiniteDescription p h).val", "start": [19, 1], "end": [20, 34], "kind": "commanddeclaration"}, {"full_name": "Classical.choose_spec", "code": "theorem choose_spec {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} (h : \u2203 x, p x) : p (choose h)", "start": [22, 1], "end": [23, 39], "kind": "commanddeclaration"}, {"full_name": "Classical.em", "code": "theorem em (p : Prop) : p \u2228 \u00acp", "start": [25, 1], "end": [57, 27], "kind": "commanddeclaration"}, {"full_name": "Classical.exists_true_of_nonempty", "code": "theorem exists_true_of_nonempty {\u03b1 : Sort u} : Nonempty \u03b1 \u2192 \u2203 _ : \u03b1, True", "start": [59, 1], "end": [60, 24], "kind": "commanddeclaration"}, {"full_name": "Classical.inhabited_of_nonempty", "code": "noncomputable def inhabited_of_nonempty {\u03b1 : Sort u} (h : Nonempty \u03b1) : Inhabited \u03b1 :=\n  \u27e8choice h\u27e9", "start": [62, 1], "end": [63, 13], "kind": "commanddeclaration"}, {"full_name": "Classical.inhabited_of_exists", "code": "noncomputable def inhabited_of_exists {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} (h : \u2203 x, p x) : Inhabited \u03b1 :=\n  inhabited_of_nonempty (Exists.elim h (fun w _ => \u27e8w\u27e9))", "start": [65, 1], "end": [66, 57], "kind": "commanddeclaration"}, {"full_name": "Classical.propDecidable", "code": "noncomputable scoped instance (priority := low) propDecidable (a : Prop) : Decidable a :=\n  choice <| match em a with\n    | Or.inl h => \u27e8isTrue h\u27e9\n    | Or.inr h => \u27e8isFalse h\u27e9", "start": [68, 1], "end": [72, 30], "kind": "commanddeclaration"}, {"full_name": "Classical.decidableInhabited", "code": "noncomputable def decidableInhabited (a : Prop) : Inhabited (Decidable a) where\n  default := inferInstance", "start": [74, 1], "end": [75, 27], "kind": "commanddeclaration"}, {"full_name": "Classical.typeDecidableEq", "code": "noncomputable def typeDecidableEq (\u03b1 : Sort u) : DecidableEq \u03b1 :=\n  fun _ _ => inferInstance", "start": [77, 1], "end": [78, 27], "kind": "commanddeclaration"}, {"full_name": "Classical.typeDecidable", "code": "noncomputable def typeDecidable (\u03b1 : Sort u) : PSum \u03b1 (\u03b1 \u2192 False) :=\n  match (propDecidable (Nonempty \u03b1)) with\n  | (isTrue hp)  => PSum.inl (@default _ (inhabited_of_nonempty hp))\n  | (isFalse hn) => PSum.inr (fun a => absurd (Nonempty.intro a) hn)", "start": [80, 1], "end": [83, 69], "kind": "commanddeclaration"}, {"full_name": "Classical.strongIndefiniteDescription", "code": "noncomputable def strongIndefiniteDescription {\u03b1 : Sort u} (p : \u03b1 \u2192 Prop) (h : Nonempty \u03b1) : {x : \u03b1 // (\u2203 y : \u03b1, p y) \u2192 p x} :=\n  @dite _ (\u2203 x : \u03b1, p x) (propDecidable _)\n    (fun (hp : \u2203 x : \u03b1, p x) =>\n      show {x : \u03b1 // (\u2203 y : \u03b1, p y) \u2192 p x} from\n      let xp := indefiniteDescription _ hp;\n      \u27e8xp.val, fun _ => xp.property\u27e9)\n    (fun hp => \u27e8choice h, fun h => absurd h hp\u27e9)", "start": [85, 1], "end": [91, 49], "kind": "commanddeclaration"}, {"full_name": "Classical.epsilon", "code": "noncomputable def epsilon {\u03b1 : Sort u} [h : Nonempty \u03b1] (p : \u03b1 \u2192 Prop) : \u03b1 :=\n  (strongIndefiniteDescription p h).val", "start": [93, 1], "end": [95, 40], "kind": "commanddeclaration"}, {"full_name": "Classical.epsilon_spec_aux", "code": "theorem epsilon_spec_aux {\u03b1 : Sort u} (h : Nonempty \u03b1) (p : \u03b1 \u2192 Prop) : (\u2203 y, p y) \u2192 p (@epsilon \u03b1 h p)", "start": [97, 1], "end": [98, 45], "kind": "commanddeclaration"}, {"full_name": "Classical.epsilon_spec", "code": "theorem epsilon_spec {\u03b1 : Sort u} {p : \u03b1 \u2192 Prop} (hex : \u2203 y, p y) : p (@epsilon \u03b1 (nonempty_of_exists hex) p)", "start": [100, 1], "end": [101, 50], "kind": "commanddeclaration"}, {"full_name": "Classical.epsilon_singleton", "code": "theorem epsilon_singleton {\u03b1 : Sort u} (x : \u03b1) : @epsilon \u03b1 \u27e8x\u27e9 (fun y => y = x) = x", "start": [103, 1], "end": [104, 44], "kind": "commanddeclaration"}, {"full_name": "Classical.axiomOfChoice", "code": "theorem axiomOfChoice {\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {r : \u2200 x, \u03b2 x \u2192 Prop} (h : \u2200 x, \u2203 y, r x y) : \u2203 (f : \u2200 x, \u03b2 x), \u2200 x, r x (f x)", "start": [106, 1], "end": [108, 34], "kind": "commanddeclaration"}, {"full_name": "Classical.skolem", "code": "theorem skolem {\u03b1 : Sort u} {b : \u03b1 \u2192 Sort v} {p : \u2200 x, b x \u2192 Prop} : (\u2200 x, \u2203 y, p x y) \u2194 \u2203 (f : \u2200 x, b x), \u2200 x, p x (f x)", "start": [110, 1], "end": [111, 50], "kind": "commanddeclaration"}, {"full_name": "Classical.propComplete", "code": "theorem propComplete (a : Prop) : a = True \u2228 a = False", "start": [113, 1], "end": [116, 86], "kind": "commanddeclaration"}, {"full_name": "Classical.byCases", "code": "theorem byCases {p q : Prop} (hpq : p \u2192 q) (hnpq : \u00acp \u2192 q) : q", "start": [119, 1], "end": [120, 54], "kind": "commanddeclaration"}, {"full_name": "Classical.byContradiction", "code": "theorem byContradiction {p : Prop} (h : \u00acp \u2192 False) : p", "start": [123, 1], "end": [124, 55], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/ByteArray.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/ByteArray/Basic.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init/Classical.lean", "lake-packages/lean4/src/lean/Init/Data/Prod.lean", "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "lake-packages/lean4/src/lean/Init/Coe.lean"], "premises": [{"full_name": "Nat.Linear.Var", "code": "abbrev Var := Nat", "start": [20, 1], "end": [20, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Context", "code": "abbrev Context := List Nat", "start": [22, 1], "end": [22, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.fixedVar", "code": "def fixedVar := 100000000", "start": [24, 1], "end": [27, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Var.denote", "code": "def Var.denote (ctx : Context) (v : Var) : Nat :=\n  bif v == fixedVar then 1 else go ctx v\nwhere\n  go : List Nat \u2192 Nat \u2192 Nat\n   | [],    _   => 0\n   | a::_,  0   => a\n   | _::as, i+1 => go as i", "start": [29, 1], "end": [35, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr", "code": "inductive Expr where\n  | num  (v : Nat)\n  | var  (i : Var)\n  | add  (a b : Expr)\n  | mulL (k : Nat) (a : Expr)\n  | mulR (a : Expr) (k : Nat)\n  deriving Inhabited", "start": [37, 1], "end": [43, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.denote", "code": "def Expr.denote (ctx : Context) : Expr \u2192 Nat\n  | Expr.add a b  => Nat.add (denote ctx a) (denote ctx b)\n  | Expr.num k    => k\n  | Expr.var v    => v.denote ctx\n  | Expr.mulL k e => Nat.mul k (denote ctx e)\n  | Expr.mulR e k => Nat.mul (denote ctx e) k", "start": [45, 1], "end": [50, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly", "code": "abbrev Poly := List (Nat \u00d7 Var)", "start": [52, 1], "end": [52, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote", "code": "def Poly.denote (ctx : Context) (p : Poly) : Nat :=\n  match p with\n  | [] => 0\n  | (k, v) :: p => Nat.add (Nat.mul k (v.denote ctx)) (denote ctx p)", "start": [54, 1], "end": [57, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.insertSorted", "code": "def Poly.insertSorted (k : Nat) (v : Var) (p : Poly) : Poly :=\n  match p with\n  | [] => [(k, v)]\n  | (k', v') :: p => bif Nat.blt v v' then (k, v) :: (k', v') :: p else (k', v') :: insertSorted k v p", "start": [59, 1], "end": [62, 103], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.sort", "code": "def Poly.sort (p : Poly) : Poly :=\n  let rec go (p : Poly) (r : Poly) : Poly :=\n    match p with\n    | [] => r\n    | (k, v) :: p => go p (r.insertSorted k v)\n  go p []", "start": [64, 1], "end": [69, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.fuse", "code": "def Poly.fuse (p : Poly) : Poly :=\n  match p with\n  | []  => []\n  | (k, v) :: p =>\n    match fuse p with\n    | [] => [(k, v)]\n    | (k', v') :: p' => bif v == v' then (Nat.add k k', v)::p' else (k, v) :: (k', v') :: p'", "start": [71, 1], "end": [77, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.mul", "code": "def Poly.mul (k : Nat) (p : Poly) : Poly :=\n  bif k == 0 then\n    []\n  else bif k == 1 then\n    p\n  else\n    go p\nwhere\n  go : Poly \u2192 Poly\n  | [] => []\n  | (k', v) :: p => (Nat.mul k k', v) :: go p", "start": [79, 1], "end": [89, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.cancelAux", "code": "def Poly.cancelAux (fuel : Nat) (m\u2081 m\u2082 r\u2081 r\u2082 : Poly) : Poly \u00d7 Poly :=\n  match fuel with\n  | 0 => (r\u2081.reverse ++ m\u2081, r\u2082.reverse ++ m\u2082)\n  | fuel + 1 =>\n    match m\u2081, m\u2082 with\n    | m\u2081, [] => (r\u2081.reverse ++ m\u2081, r\u2082.reverse)\n    | [], m\u2082 => (r\u2081.reverse, r\u2082.reverse ++ m\u2082)\n    | (k\u2081, v\u2081) :: m\u2081, (k\u2082, v\u2082) :: m\u2082 =>\n      bif Nat.blt v\u2081 v\u2082 then\n        cancelAux fuel m\u2081 ((k\u2082, v\u2082) :: m\u2082) ((k\u2081, v\u2081) :: r\u2081) r\u2082\n      else bif Nat.blt v\u2082 v\u2081 then\n        cancelAux fuel ((k\u2081, v\u2081) :: m\u2081) m\u2082 r\u2081 ((k\u2082, v\u2082) :: r\u2082)\n      else bif Nat.blt k\u2081 k\u2082 then\n        cancelAux fuel m\u2081 m\u2082 r\u2081 ((Nat.sub k\u2082 k\u2081, v\u2081) :: r\u2082)\n      else bif Nat.blt k\u2082 k\u2081 then\n        cancelAux fuel m\u2081 m\u2082 ((Nat.sub k\u2081 k\u2082, v\u2081) :: r\u2081) r\u2082\n      else\n        cancelAux fuel m\u2081 m\u2082 r\u2081 r\u2082", "start": [91, 1], "end": [108, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.hugeFuel", "code": "def hugeFuel := 1000000", "start": [110, 1], "end": [110, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.cancel", "code": "def Poly.cancel (p\u2081 p\u2082 : Poly) : Poly \u00d7 Poly :=\n  cancelAux hugeFuel p\u2081 p\u2082 [] []", "start": [112, 1], "end": [113, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.isNum?", "code": "def Poly.isNum? (p : Poly) : Option Nat :=\n  match p with\n  | [] => some 0\n  | [(k, v)] => bif v == fixedVar then some k else none\n  | _ => none", "start": [115, 1], "end": [119, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.isZero", "code": "def Poly.isZero (p : Poly) : Bool :=\n  match p with\n  | [] => true\n  | _  => false", "start": [121, 1], "end": [124, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.isNonZero", "code": "def Poly.isNonZero (p : Poly) : Bool :=\n  match p with\n  | [] => false\n  | (k, v) :: p => bif v == fixedVar then k > 0 else isNonZero p", "start": [126, 1], "end": [129, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_eq", "code": "def Poly.denote_eq (ctx : Context) (mp : Poly \u00d7 Poly) : Prop := mp.1.denote ctx = mp.2.denote ctx", "start": [131, 1], "end": [131, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_le", "code": "def Poly.denote_le (ctx : Context) (mp : Poly \u00d7 Poly) : Prop := mp.1.denote ctx \u2264 mp.2.denote ctx", "start": [133, 1], "end": [133, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.combineAux", "code": "def Poly.combineAux (fuel : Nat) (p\u2081 p\u2082 : Poly) : Poly :=\n  match fuel with\n  | 0 => p\u2081 ++ p\u2082\n  | fuel + 1 =>\n    match p\u2081, p\u2082 with\n    | p\u2081, [] => p\u2081\n    | [], p\u2082 => p\u2082\n    | (k\u2081, v\u2081) :: p\u2081, (k\u2082, v\u2082) :: p\u2082 =>\n      bif Nat.blt v\u2081 v\u2082 then\n        (k\u2081, v\u2081) :: combineAux fuel p\u2081 ((k\u2082, v\u2082) :: p\u2082)\n      else bif Nat.blt v\u2082 v\u2081 then\n        (k\u2082, v\u2082) :: combineAux fuel ((k\u2081, v\u2081) :: p\u2081) p\u2082\n      else\n        (Nat.add k\u2081 k\u2082, v\u2081) :: combineAux fuel p\u2081 p\u2082", "start": [135, 1], "end": [148, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.combine", "code": "def Poly.combine (p\u2081 p\u2082 : Poly) : Poly :=\n  combineAux hugeFuel p\u2081 p\u2082", "start": [150, 1], "end": [151, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.toPoly", "code": "def Expr.toPoly : Expr \u2192 Poly\n  | Expr.num k    => bif k == 0 then [] else [ (k, fixedVar) ]\n  | Expr.var i    => [(1, i)]\n  | Expr.add a b  => a.toPoly ++ b.toPoly\n  | Expr.mulL k a => a.toPoly.mul k\n  | Expr.mulR a k => a.toPoly.mul k", "start": [153, 1], "end": [158, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.norm", "code": "def Poly.norm (p : Poly) : Poly :=\n  p.sort.fuse", "start": [160, 1], "end": [161, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.toNormPoly", "code": "def Expr.toNormPoly (e : Expr) : Poly :=\n  e.toPoly.norm", "start": [163, 1], "end": [164, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.inc", "code": "def Expr.inc (e : Expr) : Expr :=\n   Expr.add e (Expr.num 1)", "start": [166, 1], "end": [167, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr", "code": "structure PolyCnstr  where\n  eq  : Bool\n  lhs : Poly\n  rhs : Poly\n  deriving BEq", "start": [169, 1], "end": [173, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.mul", "code": "def PolyCnstr.mul (k : Nat) (c : PolyCnstr) : PolyCnstr :=\n  { c with lhs := c.lhs.mul k, rhs := c.rhs.mul k }", "start": [189, 1], "end": [190, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.combine", "code": "def PolyCnstr.combine (c\u2081 c\u2082 : PolyCnstr) : PolyCnstr :=\n  let (lhs, rhs) := Poly.cancel (c\u2081.lhs.combine c\u2082.lhs) (c\u2081.rhs.combine c\u2082.rhs)\n  { eq := c\u2081.eq && c\u2082.eq, lhs, rhs }", "start": [192, 1], "end": [194, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr", "code": "structure ExprCnstr where\n  eq  : Bool\n  lhs : Expr\n  rhs : Expr", "start": [196, 1], "end": [199, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.denote", "code": "def PolyCnstr.denote (ctx : Context) (c : PolyCnstr) : Prop :=\n  bif c.eq then\n    Poly.denote_eq ctx (c.lhs, c.rhs)\n  else\n    Poly.denote_le ctx (c.lhs, c.rhs)", "start": [201, 1], "end": [205, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.norm", "code": "def PolyCnstr.norm (c : PolyCnstr) : PolyCnstr :=\n  let (lhs, rhs) := Poly.cancel c.lhs.sort.fuse c.rhs.sort.fuse\n  { eq := c.eq, lhs, rhs }", "start": [207, 1], "end": [209, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.isUnsat", "code": "def PolyCnstr.isUnsat (c : PolyCnstr) : Bool :=\n  bif c.eq then\n    (c.lhs.isZero && c.rhs.isNonZero) || (c.lhs.isNonZero && c.rhs.isZero)\n  else\n    c.lhs.isNonZero && c.rhs.isZero", "start": [211, 1], "end": [215, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.isValid", "code": "def PolyCnstr.isValid (c : PolyCnstr) : Bool :=\n  bif c.eq then\n    c.lhs.isZero && c.rhs.isZero\n  else\n    c.lhs.isZero", "start": [217, 1], "end": [221, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr.denote", "code": "def ExprCnstr.denote (ctx : Context) (c : ExprCnstr) : Prop :=\n  bif c.eq then\n    c.lhs.denote ctx = c.rhs.denote ctx\n  else\n    c.lhs.denote ctx \u2264 c.rhs.denote ctx", "start": [223, 1], "end": [227, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr.toPoly", "code": "def ExprCnstr.toPoly (c : ExprCnstr) : PolyCnstr :=\n  { c with lhs := c.lhs.toPoly, rhs := c.rhs.toPoly }", "start": [229, 1], "end": [230, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr.toNormPoly", "code": "def ExprCnstr.toNormPoly (c : ExprCnstr) : PolyCnstr :=\n  let (lhs, rhs) := Poly.cancel c.lhs.toNormPoly c.rhs.toNormPoly\n  { c with lhs, rhs }", "start": [232, 1], "end": [234, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Certificate", "code": "abbrev Certificate := List (Nat \u00d7 ExprCnstr)", "start": [236, 1], "end": [236, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Certificate.combineHyps", "code": "def Certificate.combineHyps (c : PolyCnstr) (hs : Certificate) : PolyCnstr :=\n  match hs with\n  | [] => c\n  | (k, c') :: hs => combineHyps (PolyCnstr.combine c (c'.toNormPoly.mul (Nat.add k 1))) hs", "start": [238, 1], "end": [241, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Certificate.combine", "code": "def Certificate.combine (hs : Certificate) : PolyCnstr :=\n  match hs with\n  | [] => { eq := true, lhs := [], rhs := [] }\n  | (k, c) :: hs => combineHyps (c.toNormPoly.mul (Nat.add k 1)) hs", "start": [243, 1], "end": [246, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Certificate.denote", "code": "def Certificate.denote (ctx : Context) (c : Certificate) : Prop :=\n  match c with\n  | [] => False\n  | (_, c)::hs => c.denote ctx \u2192 denote ctx hs", "start": [248, 1], "end": [251, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.monomialToExpr", "code": "def monomialToExpr (k : Nat) (v : Var) : Expr :=\n  bif v == fixedVar then\n    Expr.num k\n  else bif k == 1 then\n    Expr.var v\n  else\n    Expr.mulL k (Expr.var v)", "start": [253, 1], "end": [259, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.toExpr", "code": "def Poly.toExpr (p : Poly) : Expr :=\n  match p with\n  | [] => Expr.num 0\n  | (k, v) :: p => go (monomialToExpr k v) p\nwhere\n  go (e : Expr) (p : Poly) : Expr :=\n    match p with\n    | [] => e\n    | (k, v) :: p => go (Expr.add e (monomialToExpr k v)) p", "start": [261, 1], "end": [269, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.toExpr", "code": "def PolyCnstr.toExpr (c : PolyCnstr) : ExprCnstr :=\n  { c with lhs := c.lhs.toExpr, rhs := c.rhs.toExpr }", "start": [271, 1], "end": [272, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_insertSorted", "code": "theorem Poly.denote_insertSorted (ctx : Context) (k : Nat) (v : Var) (p : Poly) : (p.insertSorted k v).denote ctx = p.denote ctx + k * v.denote ctx", "start": [278, 1], "end": [281, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_sort_go", "code": "theorem Poly.denote_sort_go (ctx : Context) (p : Poly) (r : Poly) : (sort.go p r).denote ctx = p.denote ctx + r.denote ctx", "start": [285, 1], "end": [288, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_sort", "code": "theorem Poly.denote_sort (ctx : Context) (m : Poly) : m.sort.denote ctx = m.denote ctx", "start": [292, 1], "end": [293, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_append", "code": "theorem Poly.denote_append (ctx : Context) (p q : Poly) : (p ++ q).denote ctx = p.denote ctx + q.denote ctx", "start": [297, 1], "end": [300, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_cons", "code": "theorem Poly.denote_cons (ctx : Context) (k : Nat) (v : Var) (p : Poly) : denote ctx ((k, v) :: p) = k * v.denote ctx + p.denote ctx", "start": [304, 1], "end": [307, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_reverseAux", "code": "theorem Poly.denote_reverseAux (ctx : Context) (p q : Poly) : denote ctx (List.reverseAux p q) = denote ctx (p ++ q)", "start": [311, 1], "end": [314, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_reverse", "code": "theorem Poly.denote_reverse (ctx : Context) (p : Poly) : denote ctx (List.reverse p) = denote ctx p", "start": [318, 1], "end": [319, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_fuse", "code": "theorem Poly.denote_fuse (ctx : Context) (p : Poly) : p.fuse.denote ctx = p.denote ctx", "start": [323, 1], "end": [331, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_mul", "code": "theorem Poly.denote_mul (ctx : Context) (k : Nat) (p : Poly) : (p.mul k).denote ctx = k * p.denote ctx", "start": [335, 1], "end": [341, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.eq_of_not_blt_eq_true", "code": "private theorem eq_of_not_blt_eq_true (h\u2081 : \u00ac (Nat.blt x y = true)) (h\u2082 : \u00ac (Nat.blt y x = true)) : x = y", "start": [343, 1], "end": [346, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_eq_cancelAux", "code": "theorem Poly.denote_eq_cancelAux (ctx : Context) (fuel : Nat) (m\u2081 m\u2082 r\u2081 r\u2082 : Poly)\n    (h : denote_eq ctx (r\u2081.reverse ++ m\u2081, r\u2082.reverse ++ m\u2082)) : denote_eq ctx (cancelAux fuel m\u2081 m\u2082 r\u2081 r\u2082)", "start": [350, 1], "end": [382, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.of_denote_eq_cancelAux", "code": "theorem Poly.of_denote_eq_cancelAux (ctx : Context) (fuel : Nat) (m\u2081 m\u2082 r\u2081 r\u2082 : Poly)\n    (h : denote_eq ctx (cancelAux fuel m\u2081 m\u2082 r\u2081 r\u2082)) : denote_eq ctx (r\u2081.reverse ++ m\u2081, r\u2082.reverse ++ m\u2082)", "start": [384, 1], "end": [413, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_eq_cancel", "code": "theorem Poly.denote_eq_cancel {ctx : Context} {m\u2081 m\u2082 : Poly} (h : denote_eq ctx (m\u2081, m\u2082)) : denote_eq ctx (cancel m\u2081 m\u2082)", "start": [415, 1], "end": [416, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.of_denote_eq_cancel", "code": "theorem Poly.of_denote_eq_cancel {ctx : Context} {m\u2081 m\u2082 : Poly} (h : denote_eq ctx (cancel m\u2081 m\u2082)) : denote_eq ctx (m\u2081, m\u2082)", "start": [418, 1], "end": [421, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_eq_cancel_eq", "code": "theorem Poly.denote_eq_cancel_eq (ctx : Context) (m\u2081 m\u2082 : Poly) : denote_eq ctx (cancel m\u2081 m\u2082) = denote_eq ctx (m\u2081, m\u2082)", "start": [423, 1], "end": [424, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_le_cancelAux", "code": "theorem Poly.denote_le_cancelAux (ctx : Context) (fuel : Nat) (m\u2081 m\u2082 r\u2081 r\u2082 : Poly)\n    (h : denote_le ctx (r\u2081.reverse ++ m\u2081, r\u2082.reverse ++ m\u2082)) : denote_le ctx (cancelAux fuel m\u2081 m\u2082 r\u2081 r\u2082)", "start": [428, 1], "end": [460, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.of_denote_le_cancelAux", "code": "theorem Poly.of_denote_le_cancelAux (ctx : Context) (fuel : Nat) (m\u2081 m\u2082 r\u2081 r\u2082 : Poly)\n    (h : denote_le ctx (cancelAux fuel m\u2081 m\u2082 r\u2081 r\u2082)) : denote_le ctx (r\u2081.reverse ++ m\u2081, r\u2082.reverse ++ m\u2082)", "start": [462, 1], "end": [493, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_le_cancel", "code": "theorem Poly.denote_le_cancel {ctx : Context} {m\u2081 m\u2082 : Poly} (h : denote_le ctx (m\u2081, m\u2082)) : denote_le ctx (cancel m\u2081 m\u2082)", "start": [495, 1], "end": [496, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.of_denote_le_cancel", "code": "theorem Poly.of_denote_le_cancel {ctx : Context} {m\u2081 m\u2082 : Poly} (h : denote_le ctx (cancel m\u2081 m\u2082)) : denote_le ctx (m\u2081, m\u2082)", "start": [498, 1], "end": [501, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_le_cancel_eq", "code": "theorem Poly.denote_le_cancel_eq (ctx : Context) (m\u2081 m\u2082 : Poly) : denote_le ctx (cancel m\u2081 m\u2082) = denote_le ctx (m\u2081, m\u2082)", "start": [503, 1], "end": [504, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_combineAux", "code": "theorem Poly.denote_combineAux (ctx : Context) (fuel : Nat) (p\u2081 p\u2082 : Poly) : (p\u2081.combineAux fuel p\u2082).denote ctx = p\u2081.denote ctx + p\u2082.denote ctx", "start": [508, 1], "end": [516, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_combine", "code": "theorem Poly.denote_combine (ctx : Context) (p\u2081 p\u2082 : Poly) : (p\u2081.combine p\u2082).denote ctx = p\u2081.denote ctx + p\u2082.denote ctx", "start": [518, 1], "end": [519, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.denote_toPoly", "code": "theorem Expr.denote_toPoly (ctx : Context) (e : Expr) : e.toPoly.denote ctx = e.denote ctx", "start": [523, 1], "end": [529, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.eq_of_toNormPoly", "code": "theorem Expr.eq_of_toNormPoly (ctx : Context) (a b : Expr) (h : a.toNormPoly = b.toNormPoly) : a.denote ctx = b.denote ctx", "start": [533, 1], "end": [537, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.of_cancel_eq", "code": "theorem Expr.of_cancel_eq (ctx : Context) (a b c d : Expr) (h : Poly.cancel a.toNormPoly b.toNormPoly = (c.toPoly, d.toPoly)) : (a.denote ctx = b.denote ctx) = (c.denote ctx = d.denote ctx)", "start": [539, 1], "end": [543, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.of_cancel_le", "code": "theorem Expr.of_cancel_le (ctx : Context) (a b c d : Expr) (h : Poly.cancel a.toNormPoly b.toNormPoly = (c.toPoly, d.toPoly)) : (a.denote ctx \u2264 b.denote ctx) = (c.denote ctx \u2264 d.denote ctx)", "start": [545, 1], "end": [549, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.of_cancel_lt", "code": "theorem Expr.of_cancel_lt (ctx : Context) (a b c d : Expr) (h : Poly.cancel a.inc.toNormPoly b.toNormPoly = (c.inc.toPoly, d.toPoly)) : (a.denote ctx < b.denote ctx) = (c.denote ctx < d.denote ctx)", "start": [551, 1], "end": [552, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr.toPoly_norm_eq", "code": "theorem ExprCnstr.toPoly_norm_eq (c : ExprCnstr) : c.toPoly.norm = c.toNormPoly", "start": [554, 1], "end": [555, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr.denote_toPoly", "code": "theorem ExprCnstr.denote_toPoly (ctx : Context) (c : ExprCnstr) : c.toPoly.denote ctx = c.denote ctx", "start": [557, 1], "end": [562, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr.denote_toNormPoly", "code": "theorem ExprCnstr.denote_toNormPoly (ctx : Context) (c : ExprCnstr) : c.toNormPoly.denote ctx = c.denote ctx", "start": [566, 1], "end": [571, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.mul.go_denote", "code": "theorem Poly.mul.go_denote (ctx : Context) (k : Nat) (p : Poly) : (Poly.mul.go k p).denote ctx = k * p.denote ctx", "start": [575, 1], "end": [578, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.denote_mul", "code": "theorem PolyCnstr.denote_mul (ctx : Context) (k : Nat) (c : PolyCnstr) : (c.mul (k+1)).denote ctx = c.denote ctx", "start": [585, 1], "end": [597, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.denote_combine", "code": "theorem PolyCnstr.denote_combine {ctx : Context} {c\u2081 c\u2082 : PolyCnstr} (h\u2081 : c\u2081.denote ctx) (h\u2082 : c\u2082.denote ctx) : (c\u2081.combine c\u2082).denote ctx", "start": [603, 1], "end": [611, 113], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.isNum?_eq_some", "code": "theorem Poly.isNum?_eq_some (ctx : Context) {p : Poly} {k : Nat} : p.isNum? = some k \u2192 p.denote ctx = k", "start": [615, 1], "end": [620, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.of_isZero", "code": "theorem Poly.of_isZero (ctx : Context) {p : Poly} (h : isZero p = true) : p.denote ctx = 0", "start": [622, 1], "end": [626, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.of_isNonZero", "code": "theorem Poly.of_isNonZero (ctx : Context) {p : Poly} (h : isNonZero p = true) : p.denote ctx > 0", "start": [628, 1], "end": [635, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.eq_false_of_isUnsat", "code": "theorem PolyCnstr.eq_false_of_isUnsat (ctx : Context) {c : PolyCnstr} : c.isUnsat \u2192 c.denote ctx = False", "start": [637, 1], "end": [648, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.PolyCnstr.eq_true_of_isValid", "code": "theorem PolyCnstr.eq_true_of_isValid (ctx : Context) {c : PolyCnstr} : c.isValid \u2192 c.denote ctx = True", "start": [650, 1], "end": [657, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr.eq_false_of_isUnsat", "code": "theorem ExprCnstr.eq_false_of_isUnsat (ctx : Context) (c : ExprCnstr) (h : c.toNormPoly.isUnsat) : c.denote ctx = False", "start": [659, 1], "end": [662, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr.eq_true_of_isValid", "code": "theorem ExprCnstr.eq_true_of_isValid (ctx : Context) (c : ExprCnstr) (h : c.toNormPoly.isValid) : c.denote ctx = True", "start": [664, 1], "end": [667, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Certificate.of_combineHyps", "code": "theorem Certificate.of_combineHyps (ctx : Context) (c : PolyCnstr) (cs : Certificate) (h : (combineHyps c cs).denote ctx \u2192 False) : c.denote ctx \u2192 cs.denote ctx", "start": [669, 1], "end": [678, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Certificate.of_combine", "code": "theorem Certificate.of_combine (ctx : Context) (cs : Certificate) (h : cs.combine.denote ctx \u2192 False) : cs.denote ctx", "start": [680, 1], "end": [687, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Certificate.of_combine_isUnsat", "code": "theorem Certificate.of_combine_isUnsat (ctx : Context) (cs : Certificate) (h : cs.combine.isUnsat) : cs.denote ctx", "start": [689, 1], "end": [691, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.denote_monomialToExpr", "code": "theorem denote_monomialToExpr (ctx : Context) (k : Nat) (v : Var) : (monomialToExpr k v).denote ctx = k * v.denote ctx", "start": [693, 1], "end": [697, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_toExpr_go", "code": "theorem Poly.denote_toExpr_go (ctx : Context) (e : Expr) (p : Poly) : (toExpr.go e p).denote ctx = e.denote ctx + p.denote ctx", "start": [701, 1], "end": [704, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Poly.denote_toExpr", "code": "theorem Poly.denote_toExpr (ctx : Context) (p : Poly) : p.toExpr.denote ctx = p.denote ctx", "start": [708, 1], "end": [711, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq", "code": "theorem ExprCnstr.eq_of_toNormPoly_eq (ctx : Context) (c d : ExprCnstr) (h : c.toNormPoly == d.toPoly) : c.denote ctx = d.denote ctx", "start": [713, 1], "end": [716, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Linear.Expr.eq_of_toNormPoly_eq", "code": "theorem Expr.eq_of_toNormPoly_eq (ctx : Context) (e e' : Expr) (h : e.toNormPoly == e'.toPoly) : e.denote ctx = e'.denote ctx", "start": [718, 1], "end": [721, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/String/Extra.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/Except.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean", "lake-packages/lean4/src/lean/Init/Util.lean", "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "lake-packages/lean4/src/lean/Init/Data/ByteArray.lean", "lake-packages/lean4/src/lean/Init/WFTactics.lean"], "premises": [{"full_name": "String.toNat!", "code": "def toNat! (s : String) : Nat :=\n  if s.isNat then\n    s.foldl (fun n c => n*10 + (c.toNat - '0'.toNat)) 0\n  else\n    panic! \"Nat expected\"", "start": [16, 1], "end": [23, 26], "kind": "commanddeclaration"}, {"full_name": "String.fromUTF8Unchecked", "code": "@[extern \"lean_string_from_utf8_unchecked\"]\nopaque fromUTF8Unchecked (a : @& ByteArray) : String", "start": [25, 1], "end": [30, 53], "kind": "commanddeclaration"}, {"full_name": "String.toUTF8", "code": "@[extern \"lean_string_to_utf8\"]\nopaque toUTF8 (a : @& String) : ByteArray", "start": [32, 1], "end": [34, 42], "kind": "commanddeclaration"}, {"full_name": "String.getUtf8Byte", "code": "@[extern \"lean_string_get_byte_fast\"]\nopaque getUtf8Byte (s : @& String) (n : Nat) (h : n < s.utf8ByteSize) : UInt8", "start": [36, 1], "end": [38, 78], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.sizeOf_next_lt_of_hasNext", "code": "theorem Iterator.sizeOf_next_lt_of_hasNext (i : String.Iterator) (h : i.hasNext) : sizeOf i.next < sizeOf i", "start": [40, 1], "end": [42, 53], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.sizeOf_next_lt_of_atEnd", "code": "theorem Iterator.sizeOf_next_lt_of_atEnd (i : String.Iterator) (h : \u00ac i.atEnd = true) : sizeOf i.next < sizeOf i", "start": [46, 1], "end": [48, 32], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.find", "code": "@[specialize] def find (it : Iterator) (p : Char \u2192 Bool) : Iterator :=\n  if it.atEnd then it\n  else if p it.curr then it\n  else find it.next p", "start": [54, 1], "end": [58, 22], "kind": "commanddeclaration"}, {"full_name": "String.Iterator.foldUntil", "code": "@[specialize] def foldUntil (it : Iterator) (init : \u03b1) (f : \u03b1 \u2192 Char \u2192 Option \u03b1) : \u03b1 \u00d7 Iterator :=\n  if it.atEnd then\n    (init, it)\n  else if let some a := f init it.curr then\n    foldUntil it.next a f\n  else\n    (init, it)", "start": [60, 1], "end": [66, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/String.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/String/Extra.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Int.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Control/Reader.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/Except.lean", "lake-packages/lean4/src/lean/Init/Control/Id.lean", "lake-packages/lean4/src/lean/Init/Control/Basic.lean"], "premises": [{"full_name": "ReaderT.orElse", "code": "@[always_inline, inline]\nprotected def orElse [Alternative m] (x\u2081 : ReaderT \u03c1 m \u03b1) (x\u2082 : Unit \u2192 ReaderT \u03c1 m \u03b1) : ReaderT \u03c1 m \u03b1 :=\n  fun s => x\u2081 s <|> x\u2082 () s", "start": [15, 1], "end": [17, 28], "kind": "commanddeclaration"}, {"full_name": "ReaderT.failure", "code": "@[always_inline, inline]\nprotected def failure [Alternative m] : ReaderT \u03c1 m \u03b1 :=\n  fun _ => failure", "start": [19, 1], "end": [21, 19], "kind": "commanddeclaration"}, {"full_name": "ReaderT.tryFinally", "code": "@[always_inline]\ninstance ReaderT.tryFinally [MonadFinally m] [Monad m] : MonadFinally (ReaderT \u03c1 m) where\n  tryFinally' x h ctx := tryFinally' (x ctx) (fun a? => h a? ctx)", "start": [34, 1], "end": [36, 66], "kind": "commanddeclaration"}, {"full_name": "ReaderM", "code": "@[reducible] def ReaderM (\u03c1 : Type u) := ReaderT \u03c1 Id", "start": [38, 1], "end": [38, 54], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/EState.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/State.lean", "lake-packages/lean4/src/lean/Init/Control/Except.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean"], "premises": [{"full_name": "EStateM.orElse'", "code": "@[always_inline, inline]\nprotected def orElse' {\u03b4} [Backtrackable \u03b4 \u03c3] (x\u2081 x\u2082 : EStateM \u03b5 \u03c3 \u03b1) (useFirstEx := true) : EStateM \u03b5 \u03c3 \u03b1 := fun s =>\n  let d := Backtrackable.save s;\n  match x\u2081 s with\n  | Result.error e\u2081 s\u2081 =>\n    match x\u2082 (Backtrackable.restore s\u2081 d) with\n    | Result.error e\u2082 s\u2082 => Result.error (if useFirstEx then e\u2081 else e\u2082) s\u2082\n    | ok                 => ok\n  | ok                 => ok", "start": [32, 1], "end": [42, 29], "kind": "commanddeclaration"}, {"full_name": "EStateM.fromStateM", "code": "@[always_inline, inline] def fromStateM {\u03b5 \u03c3 \u03b1 : Type} (x : StateM \u03c3 \u03b1) : EStateM \u03b5 \u03c3 \u03b1 := fun s =>\n  match x.run s with\n  | (a, s') => EStateM.Result.ok a s'", "start": [57, 1], "end": [59, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat/Log2.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean", "lake-packages/lean4/src/lean/Init/NotationExtra.lean"], "premises": [{"full_name": "Nat.log2_terminates", "code": "theorem log2_terminates : \u2200 n, n \u2265 2 \u2192 n / 2 < n", "start": [12, 1], "end": [19, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.log2", "code": "@[extern \"lean_nat_log2\"]\ndef log2 (n : @& Nat) : Nat :=\n  if n \u2265 2 then log2 (n / 2) + 1 else 0\ndecreasing_by exact log2_terminates _ \u2039_\u203a", "start": [21, 1], "end": [29, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.log2_le_self", "code": "theorem log2_le_self (n : Nat) : Nat.log2 n \u2264 n", "start": [31, 1], "end": [37, 46], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/System/IOError.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/UInt/Basic.lean", "lake-packages/lean4/src/lean/Init/Core.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean"], "premises": [{"full_name": "IO.Error", "code": "inductive IO.Error where\n  | alreadyExists (filename : Option String) (osCode : UInt32) (details : String) | otherError (osCode : UInt32) (details : String)    | resourceBusy (osCode : UInt32) (details : String)\n      | resourceVanished (osCode : UInt32) (details : String)\n      | unsupportedOperation (osCode : UInt32) (details : String)\n      | hardwareFault (osCode : UInt32) (details : String)          | unsatisfiedConstraints (osCode : UInt32) (details : String) | illegalOperation (osCode : UInt32) (details : String)       | protocolError (osCode : UInt32) (details : String)\n      | timeExpired (osCode : UInt32) (details : String)\n      | interrupted (filename : String) (osCode : UInt32) (details : String)       | noFileOrDirectory (filename : String) (osCode : UInt32) (details : String) | invalidArgument (filename : Option String) (osCode : UInt32) (details : String)\n      | permissionDenied (filename : Option String) (osCode : UInt32) (details : String)\n      | resourceExhausted (filename : Option String) (osCode : UInt32) (details : String)\n      | inappropriateType (filename : Option String) (osCode : UInt32) (details : String)\n      | noSuchThing (filename : Option String) (osCode : UInt32) (details : String)\n      | unexpectedEof\n  | userError (msg : String)\n  deriving Inhabited", "start": [13, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "IO.userError", "code": "@[export lean_mk_io_user_error]\ndef IO.userError (s : String) : IO.Error :=\n  IO.Error.userError s", "start": [56, 1], "end": [58, 23], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkAlreadyExistsFile", "code": "@[export lean_mk_io_error_already_exists_file]\ndef mkAlreadyExistsFile : String \u2192 UInt32 \u2192 String \u2192 IO.Error :=\n  alreadyExists \u2218 some", "start": [64, 1], "end": [66, 23], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkEofError", "code": "@[export lean_mk_io_error_eof]\ndef mkEofError : Unit \u2192 IO.Error := fun _ =>\n  unexpectedEof", "start": [68, 1], "end": [70, 16], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkInappropriateTypeFile", "code": "@[export lean_mk_io_error_inappropriate_type_file]\ndef mkInappropriateTypeFile : String \u2192 UInt32 \u2192 String \u2192 IO.Error :=\n  inappropriateType \u2218 some", "start": [72, 1], "end": [74, 27], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkInterrupted", "code": "@[export lean_mk_io_error_interrupted]\ndef mkInterrupted : String \u2192 UInt32 \u2192 String \u2192 IO.Error :=\n  interrupted", "start": [76, 1], "end": [78, 14], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkInvalidArgumentFile", "code": "@[export lean_mk_io_error_invalid_argument_file]\ndef mkInvalidArgumentFile : String \u2192 UInt32 \u2192 String \u2192 IO.Error :=\n  invalidArgument \u2218 some", "start": [80, 1], "end": [82, 25], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkNoFileOrDirectory", "code": "@[export lean_mk_io_error_no_file_or_directory]\ndef mkNoFileOrDirectory : String \u2192 UInt32 \u2192 String \u2192 IO.Error :=\n  noFileOrDirectory", "start": [84, 1], "end": [86, 20], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkNoSuchThingFile", "code": "@[export lean_mk_io_error_no_such_thing_file]\ndef mkNoSuchThingFile : String \u2192 UInt32 \u2192 String \u2192 IO.Error :=\n  noSuchThing \u2218 some", "start": [88, 1], "end": [90, 21], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkPermissionDeniedFile", "code": "@[export lean_mk_io_error_permission_denied_file]\ndef mkPermissionDeniedFile : String \u2192 UInt32 \u2192 String \u2192 IO.Error :=\n  permissionDenied \u2218 some", "start": [92, 1], "end": [94, 26], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkResourceExhaustedFile", "code": "@[export lean_mk_io_error_resource_exhausted_file]\ndef mkResourceExhaustedFile : String \u2192 UInt32 \u2192 String \u2192 IO.Error :=\n  resourceExhausted \u2218 some", "start": [96, 1], "end": [98, 27], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkUnsupportedOperation", "code": "@[export lean_mk_io_error_unsupported_operation]\ndef mkUnsupportedOperation : UInt32 \u2192 String \u2192 IO.Error :=\n  unsupportedOperation", "start": [100, 1], "end": [102, 23], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkResourceExhausted", "code": "@[export lean_mk_io_error_resource_exhausted]\ndef mkResourceExhausted : UInt32 \u2192 String \u2192 IO.Error :=\n  resourceExhausted none", "start": [104, 1], "end": [106, 25], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkAlreadyExists", "code": "@[export lean_mk_io_error_already_exists]\ndef mkAlreadyExists : UInt32 \u2192 String \u2192 IO.Error :=\n  alreadyExists none", "start": [108, 1], "end": [110, 21], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkInappropriateType", "code": "@[export lean_mk_io_error_inappropriate_type]\ndef mkInappropriateType : UInt32 \u2192 String \u2192 IO.Error :=\n  inappropriateType none", "start": [112, 1], "end": [114, 25], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkNoSuchThing", "code": "@[export lean_mk_io_error_no_such_thing]\ndef mkNoSuchThing : UInt32 \u2192 String \u2192 IO.Error :=\n  noSuchThing none", "start": [116, 1], "end": [118, 19], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkResourceVanished", "code": "@[export lean_mk_io_error_resource_vanished]\ndef mkResourceVanished : UInt32 \u2192 String \u2192 IO.Error :=\n  resourceVanished", "start": [120, 1], "end": [122, 19], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkResourceBusy", "code": "@[export lean_mk_io_error_resource_busy]\ndef mkResourceBusy : UInt32 \u2192 String \u2192 IO.Error :=\n  resourceBusy", "start": [124, 1], "end": [126, 15], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkInvalidArgument", "code": "@[export lean_mk_io_error_invalid_argument]\ndef mkInvalidArgument : UInt32 \u2192 String \u2192 IO.Error :=\n  invalidArgument none", "start": [128, 1], "end": [130, 23], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkOtherError", "code": "@[export lean_mk_io_error_other_error]\ndef mkOtherError : UInt32 \u2192 String \u2192 IO.Error :=\n  otherError", "start": [132, 1], "end": [134, 13], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkPermissionDenied", "code": "@[export lean_mk_io_error_permission_denied]\ndef mkPermissionDenied : UInt32 \u2192 String \u2192 IO.Error :=\n  permissionDenied none", "start": [136, 1], "end": [138, 24], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkHardwareFault", "code": "@[export lean_mk_io_error_hardware_fault]\ndef mkHardwareFault : UInt32 \u2192 String \u2192 IO.Error :=\n  hardwareFault", "start": [140, 1], "end": [142, 16], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkUnsatisfiedConstraints", "code": "@[export lean_mk_io_error_unsatisfied_constraints]\ndef mkUnsatisfiedConstraints : UInt32 \u2192 String \u2192 IO.Error :=\n  unsatisfiedConstraints", "start": [144, 1], "end": [146, 25], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkIllegalOperation", "code": "@[export lean_mk_io_error_illegal_operation]\ndef mkIllegalOperation : UInt32 \u2192 String \u2192 IO.Error :=\n  illegalOperation", "start": [148, 1], "end": [150, 19], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkProtocolError", "code": "@[export lean_mk_io_error_protocol_error]\ndef mkProtocolError : UInt32 \u2192 String \u2192 IO.Error :=\n  protocolError", "start": [152, 1], "end": [154, 16], "kind": "commanddeclaration"}, {"full_name": "IO.Error.mkTimeExpired", "code": "@[export lean_mk_io_error_time_expired]\ndef mkTimeExpired : UInt32 \u2192 String \u2192 IO.Error :=\n  timeExpired", "start": [156, 1], "end": [158, 14], "kind": "commanddeclaration"}, {"full_name": "IO.Error.downCaseFirst", "code": "private def downCaseFirst (s : String) : String := s.modify 0 Char.toLower", "start": [160, 1], "end": [160, 75], "kind": "commanddeclaration"}, {"full_name": "IO.Error.fopenErrorToString", "code": "def fopenErrorToString (gist fn : String) (code : UInt32) : Option String \u2192 String\n  | some details => downCaseFirst gist ++ \" (error code: \" ++ toString code ++ \", \" ++ downCaseFirst details ++ \")\\n  file: \" ++ fn\n  | none => downCaseFirst gist ++ \" (error code: \" ++ toString code ++ \")\\n  file: \" ++ fn", "start": [162, 1], "end": [164, 91], "kind": "commanddeclaration"}, {"full_name": "IO.Error.otherErrorToString", "code": "def otherErrorToString (gist : String) (code : UInt32) : Option String \u2192 String\n  | some details => downCaseFirst gist ++ \" (error code: \" ++ toString code ++ \", \" ++ downCaseFirst details ++ \")\"\n  | none => downCaseFirst gist ++ \" (error code: \" ++ toString code ++ \")\"", "start": [166, 1], "end": [168, 75], "kind": "commanddeclaration"}, {"full_name": "IO.Error.toString", "code": "@[export lean_io_error_to_string]\ndef toString : IO.Error \u2192 String\n  | unexpectedEof                            => \"end of file\"\n  | inappropriateType (some fn) code details => fopenErrorToString \"inappropriate type\" fn code details\n  | inappropriateType none code details      => otherErrorToString \"inappropriate type\" code details\n  | interrupted fn code details              => fopenErrorToString \"interrupted system call\" fn code details\n  | invalidArgument (some fn) code details   => fopenErrorToString \"invalid argument\" fn code details\n  | invalidArgument none code details        => otherErrorToString \"invalid argument\" code details\n  | noFileOrDirectory fn code _              => fopenErrorToString \"no such file or directory\" fn code none\n  | noSuchThing (some fn) code details       => fopenErrorToString \"no such thing\" fn code details\n  | noSuchThing none code details            => otherErrorToString \"no such thing\" code details\n  | permissionDenied (some fn) code details  => fopenErrorToString details fn code none\n  | permissionDenied none code details       => otherErrorToString details code none\n  | resourceExhausted (some fn) code details => fopenErrorToString \"resource exhausted\" fn code details\n  | resourceExhausted none code details      => otherErrorToString \"resource exhausted\" code details\n  | alreadyExists none code details          => otherErrorToString \"already exists\" code details\n  | alreadyExists (some fn) code details     => fopenErrorToString \"already exists\" fn code details\n  | otherError code details                  => otherErrorToString details code none\n  | resourceBusy code details                => otherErrorToString \"resource busy\" code details\n  | resourceVanished code details            => otherErrorToString \"resource vanished\" code details\n  | hardwareFault code _                     => otherErrorToString \"hardware fault\" code none\n  | illegalOperation code details            => otherErrorToString \"illegal operation\" code details\n  | protocolError code details               => otherErrorToString \"protocol error\" code details\n  | timeExpired code details                 => otherErrorToString \"time expired\" code details\n  | unsatisfiedConstraints code _            => otherErrorToString \"directory not empty\" code none\n  | unsupportedOperation code details        => otherErrorToString \"unsupported operation\" code details\n  | userError msg                            => msg", "start": [170, 1], "end": [196, 52], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Ord.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Int.lean", "lake-packages/lean4/src/lean/Init/Data/String.lean"], "premises": [{"full_name": "Ordering", "code": "inductive Ordering where\n  | lt | eq | gt\nderiving Inhabited, BEq", "start": [11, 1], "end": [13, 24], "kind": "commanddeclaration"}, {"full_name": "Ord", "code": "class Ord (\u03b1 : Type u) where\n  compare : \u03b1 \u2192 \u03b1 \u2192 Ordering", "start": [16, 1], "end": [17, 29], "kind": "commanddeclaration"}, {"full_name": "compareOfLessAndEq", "code": "@[inline] def compareOfLessAndEq {\u03b1} (x y : \u03b1) [LT \u03b1] [Decidable (x < y)] [DecidableEq \u03b1] : Ordering :=\n  if x < y then Ordering.lt\n  else if x = y then Ordering.eq\n  else Ordering.gt", "start": [21, 1], "end": [24, 19], "kind": "commanddeclaration"}, {"full_name": "lexOrd", "code": "def lexOrd [Ord \u03b1] [Ord \u03b2] : Ord (\u03b1 \u00d7 \u03b2) where\n  compare p1 p2 := match compare p1.1 p2.1 with\n    | .eq => compare p1.2 p2.2\n    | o   => o", "start": [62, 1], "end": [66, 15], "kind": "commanddeclaration"}, {"full_name": "ltOfOrd", "code": "def ltOfOrd [Ord \u03b1] : LT \u03b1 where\n  lt a b := compare a b == Ordering.lt", "start": [68, 1], "end": [69, 39], "kind": "commanddeclaration"}, {"full_name": "Ordering.isLE", "code": "def Ordering.isLE : Ordering \u2192 Bool\n  | Ordering.lt => true\n  | Ordering.eq => true\n  | Ordering.gt => false", "start": [74, 1], "end": [77, 25], "kind": "commanddeclaration"}, {"full_name": "leOfOrd", "code": "def leOfOrd [Ord \u03b1] : LE \u03b1 where\n  le a b := (compare a b).isLE", "start": [79, 1], "end": [80, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/System/FilePath.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Repr.lean", "lake-packages/lean4/src/lean/Init/System/Platform.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean"], "premises": [{"full_name": "System.FilePath", "code": "structure FilePath where\n  toString : String\n  deriving Inhabited, DecidableEq, Hashable", "start": [15, 1], "end": [17, 44], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.pathSeparator", "code": "def pathSeparator : Char :=\n  if isWindows then '\\\\' else '/'", "start": [27, 1], "end": [29, 34], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.pathSeparators", "code": "def pathSeparators : List Char :=\n  if isWindows then ['\\\\', '/'] else ['/']", "start": [31, 1], "end": [33, 43], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.extSeparator", "code": "def extSeparator : Char := '.'", "start": [35, 1], "end": [36, 31], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.exeExtension", "code": "def exeExtension : String :=\n  if isWindows then \"exe\" else \"\"", "start": [38, 1], "end": [39, 34], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.normalize", "code": "def normalize (p : FilePath) : FilePath := Id.run do\n  let mut p := p\n  if isWindows && p.toString.length >= 2 && (p.toString.get 0).isLower && p.toString.get \u27e81\u27e9 == ':' then\n    p := \u27e8p.toString.set 0 (p.toString.get 0).toUpper\u27e9\n  unless pathSeparators.length == 1 do\n    p := \u27e8p.toString.map fun c => if pathSeparators.contains c then pathSeparator else c\u27e9\n  return p", "start": [42, 1], "end": [50, 11], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.isAbsolute", "code": "def isAbsolute (p : FilePath) : Bool :=\n  pathSeparators.contains p.toString.front || (isWindows && p.toString.length > 1 && p.toString.iter.next.curr == ':')", "start": [54, 1], "end": [55, 119], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.isRelative", "code": "def isRelative (p : FilePath) : Bool :=\n  !p.isAbsolute", "start": [57, 1], "end": [58, 16], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.join", "code": "def join (p sub : FilePath) : FilePath :=\n  if sub.isAbsolute then\n    sub\n  else\n    \u27e8p.toString ++ pathSeparator.toString ++ sub.toString\u27e9", "start": [60, 1], "end": [64, 59], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.posOfLastSep", "code": "private def posOfLastSep (p : FilePath) : Option String.Pos :=\n  p.toString.revFind pathSeparators.contains", "start": [72, 1], "end": [73, 45], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.parent", "code": "def parent (p : FilePath) : Option FilePath :=\n  FilePath.mk <$> p.toString.extract {} <$> posOfLastSep p", "start": [75, 1], "end": [76, 59], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.fileName", "code": "def fileName (p : FilePath) : Option String :=\n  let lastPart := match posOfLastSep p with\n    | some sepPos => p.toString.extract (sepPos + '/') p.toString.endPos\n    | none        => p.toString\n  if lastPart.isEmpty || lastPart == \".\" || lastPart == \"..\" then none else some lastPart", "start": [78, 1], "end": [82, 90], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.fileStem", "code": "def fileStem (p : FilePath) : Option String :=\n  p.fileName.map fun fname =>\n    match fname.revPosOf '.' with\n    | some \u27e80\u27e9 => fname\n    | some pos => fname.extract 0 pos\n    | none     => fname", "start": [84, 1], "end": [90, 24], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.extension", "code": "def extension (p : FilePath) : Option String :=\n  p.fileName.bind fun fname =>\n    match fname.revPosOf '.' with\n    | some 0   => none\n    | some pos => fname.extract (pos + '.') fname.endPos\n    | none     => none", "start": [92, 1], "end": [97, 23], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.withFileName", "code": "def withFileName (p : FilePath) (fname : String) : FilePath :=\n  match p.parent with\n  | none => \u27e8fname\u27e9\n  | some p => p / fname", "start": [99, 1], "end": [102, 24], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.withExtension", "code": "def withExtension (p : FilePath) (ext : String) : FilePath :=\n  match p.fileStem with\n  | none => p\n  | some stem => p.withFileName (if ext.isEmpty then stem else stem ++ \".\" ++ ext)", "start": [104, 1], "end": [107, 83], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.components", "code": "def components (p : FilePath) : List String :=\n  p.normalize |>.toString.splitOn pathSeparator.toString", "start": [109, 1], "end": [110, 57], "kind": "commanddeclaration"}, {"full_name": "System.mkFilePath", "code": "def mkFilePath (parts : List String) : FilePath :=\n  \u27e8String.intercalate FilePath.pathSeparator.toString parts\u27e9", "start": [114, 1], "end": [115, 61], "kind": "commanddeclaration"}, {"full_name": "System.SearchPath", "code": "abbrev SearchPath := List FilePath", "start": [120, 1], "end": [120, 35], "kind": "commanddeclaration"}, {"full_name": "System.SearchPath.separator", "code": "protected def separator : Char :=\n  if isWindows then ';' else ':'", "start": [124, 1], "end": [126, 33], "kind": "commanddeclaration"}, {"full_name": "System.SearchPath.parse", "code": "def parse (s : String) : SearchPath :=\n  s.split (fun c => SearchPath.separator == c) |>.map FilePath.mk", "start": [128, 1], "end": [129, 66], "kind": "commanddeclaration"}, {"full_name": "System.SearchPath.toString", "code": "def toString (path : SearchPath) : String :=\n  SearchPath.separator.toString.intercalate (path.map FilePath.toString)", "start": [131, 1], "end": [132, 73], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/System/ST.lean", "imports": ["lake-packages/lean4/src/lean/Init/Classical.lean", "lake-packages/lean4/src/lean/Init/Control/EState.lean", "lake-packages/lean4/src/lean/Init/Control/Reader.lean"], "premises": [{"full_name": "EST", "code": "def EST (\u03b5 : Type) (\u03c3 : Type) : Type \u2192 Type := EStateM \u03b5 \u03c3", "start": [11, 1], "end": [11, 59], "kind": "commanddeclaration"}, {"full_name": "ST", "code": "abbrev ST (\u03c3 : Type) := EST Empty \u03c3", "start": [12, 1], "end": [12, 36], "kind": "commanddeclaration"}, {"full_name": "STWorld", "code": "class STWorld (\u03c3 : outParam Type) (m : Type \u2192 Type)", "start": [20, 1], "end": [20, 52], "kind": "commanddeclaration"}, {"full_name": "runEST", "code": "@[noinline, nospecialize]\ndef runEST {\u03b5 \u03b1 : Type} (x : (\u03c3 : Type) \u2192 EST \u03b5 \u03c3 \u03b1) : Except \u03b5 \u03b1 :=\n  match x Unit () with\n  | EStateM.Result.ok a _     => Except.ok a\n  | EStateM.Result.error ex _ => Except.error ex", "start": [25, 1], "end": [29, 49], "kind": "commanddeclaration"}, {"full_name": "runST", "code": "@[noinline, nospecialize]\ndef runST {\u03b1 : Type} (x : (\u03c3 : Type) \u2192 ST \u03c3 \u03b1) : \u03b1 :=\n  match x Unit () with\n  | EStateM.Result.ok a _     => a\n  | EStateM.Result.error ex _ => nomatch ex", "start": [31, 1], "end": [35, 44], "kind": "commanddeclaration"}, {"full_name": "ST.RefPointed", "code": "opaque RefPointed : NonemptyType.{0}", "start": [45, 1], "end": [46, 37], "kind": "commanddeclaration"}, {"full_name": "ST.Ref", "code": "structure Ref (\u03c3 : Type) (\u03b1 : Type) : Type where\n  ref : RefPointed.type\n  h   : Nonempty \u03b1", "start": [48, 1], "end": [50, 19], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.inhabitedFromRef", "code": "private noncomputable def inhabitedFromRef {\u03c3 \u03b1} (r : Ref \u03c3 \u03b1) : ST \u03c3 \u03b1 :=\n  let _ : Inhabited \u03b1 := Classical.inhabited_of_nonempty r.h\n  pure default", "start": [57, 1], "end": [60, 15], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.mkRef", "code": "@[extern \"lean_st_mk_ref\"]\nopaque mkRef {\u03c3 \u03b1} (a : \u03b1) : ST \u03c3 (Ref \u03c3 \u03b1) := pure { ref := Classical.choice RefPointed.property, h := Nonempty.intro a }", "start": [62, 1], "end": [63, 123], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.Ref.get", "code": "@[extern \"lean_st_ref_get\"]\nopaque Ref.get {\u03c3 \u03b1} (r : @& Ref \u03c3 \u03b1) : ST \u03c3 \u03b1 := inhabitedFromRef r", "start": [64, 1], "end": [65, 69], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.Ref.set", "code": "@[extern \"lean_st_ref_set\"]\nopaque Ref.set {\u03c3 \u03b1} (r : @& Ref \u03c3 \u03b1) (a : \u03b1) : ST \u03c3 Unit", "start": [66, 1], "end": [67, 58], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.Ref.swap", "code": "@[extern \"lean_st_ref_swap\"]\nopaque Ref.swap {\u03c3 \u03b1} (r : @& Ref \u03c3 \u03b1) (a : \u03b1) : ST \u03c3 \u03b1 := inhabitedFromRef r", "start": [68, 1], "end": [69, 78], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.Ref.take", "code": "@[extern \"lean_st_ref_take\"]\nunsafe opaque Ref.take {\u03c3 \u03b1} (r : @& Ref \u03c3 \u03b1) : ST \u03c3 \u03b1 := inhabitedFromRef r", "start": [70, 1], "end": [71, 77], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.Ref.ptrEq", "code": "@[extern \"lean_st_ref_ptr_eq\"]\nopaque Ref.ptrEq {\u03c3 \u03b1} (r1 r2 : @& Ref \u03c3 \u03b1) : ST \u03c3 Bool", "start": [72, 1], "end": [73, 56], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.Ref.modifyUnsafe", "code": "@[inline] unsafe def Ref.modifyUnsafe {\u03c3 \u03b1 : Type} (r : Ref \u03c3 \u03b1) (f : \u03b1 \u2192 \u03b1) : ST \u03c3 Unit := do\n  let v \u2190 Ref.take r\n  Ref.set r (f v)", "start": [75, 1], "end": [77, 18], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.Ref.modifyGetUnsafe", "code": "@[inline] unsafe def Ref.modifyGetUnsafe {\u03c3 \u03b1 \u03b2 : Type} (r : Ref \u03c3 \u03b1) (f : \u03b1 \u2192 \u03b2 \u00d7 \u03b1) : ST \u03c3 \u03b2 := do\n  let v \u2190 Ref.take r\n  let (b, a) := f v\n  Ref.set r a\n  pure b", "start": [79, 1], "end": [83, 9], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.Ref.modify", "code": "@[implemented_by Ref.modifyUnsafe]\ndef Ref.modify {\u03c3 \u03b1 : Type} (r : Ref \u03c3 \u03b1) (f : \u03b1 \u2192 \u03b1) : ST \u03c3 Unit := do\n  let v \u2190 Ref.get r\n  Ref.set r (f v)", "start": [85, 1], "end": [88, 18], "kind": "commanddeclaration"}, {"full_name": "ST.Prim.Ref.modifyGet", "code": "@[implemented_by Ref.modifyGetUnsafe]\ndef Ref.modifyGet {\u03c3 \u03b1 \u03b2 : Type} (r : Ref \u03c3 \u03b1) (f : \u03b1 \u2192 \u03b2 \u00d7 \u03b1) : ST \u03c3 \u03b2 := do\n  let v \u2190 Ref.get r\n  let (b, a) := f v\n  Ref.set r a\n  pure b", "start": [90, 1], "end": [95, 9], "kind": "commanddeclaration"}, {"full_name": "ST.mkRef", "code": "@[inline] def mkRef {\u03b1 : Type} (a : \u03b1) : m (Ref \u03c3 \u03b1) :=  liftM <| Prim.mkRef a", "start": [102, 1], "end": [102, 79], "kind": "commanddeclaration"}, {"full_name": "ST.Ref.get", "code": "@[inline] def Ref.get {\u03b1 : Type} (r : Ref \u03c3 \u03b1) : m \u03b1 := liftM <| Prim.Ref.get r", "start": [103, 1], "end": [103, 80], "kind": "commanddeclaration"}, {"full_name": "ST.Ref.set", "code": "@[inline] def Ref.set {\u03b1 : Type} (r : Ref \u03c3 \u03b1) (a : \u03b1) : m Unit := liftM <| Prim.Ref.set r a", "start": [104, 1], "end": [104, 93], "kind": "commanddeclaration"}, {"full_name": "ST.Ref.swap", "code": "@[inline] def Ref.swap {\u03b1 : Type} (r : Ref \u03c3 \u03b1) (a : \u03b1) : m \u03b1 := liftM <| Prim.Ref.swap r a", "start": [105, 1], "end": [105, 92], "kind": "commanddeclaration"}, {"full_name": "ST.Ref.take", "code": "@[inline] unsafe def Ref.take {\u03b1 : Type} (r : Ref \u03c3 \u03b1) : m \u03b1 := liftM <| Prim.Ref.take r", "start": [106, 1], "end": [106, 89], "kind": "commanddeclaration"}, {"full_name": "ST.Ref.ptrEq", "code": "@[inline] def Ref.ptrEq {\u03b1 : Type} (r1 r2 : Ref \u03c3 \u03b1) : m Bool := liftM <| Prim.Ref.ptrEq r1 r2", "start": [107, 1], "end": [107, 95], "kind": "commanddeclaration"}, {"full_name": "ST.Ref.modify", "code": "@[inline] def Ref.modify {\u03b1 : Type} (r : Ref \u03c3 \u03b1) (f : \u03b1 \u2192 \u03b1) : m Unit := liftM <| Prim.Ref.modify r f", "start": [108, 1], "end": [108, 103], "kind": "commanddeclaration"}, {"full_name": "ST.Ref.modifyGet", "code": "@[inline] def Ref.modifyGet {\u03b1 : Type} {\u03b2 : Type} (r : Ref \u03c3 \u03b1) (f : \u03b1 \u2192 \u03b2 \u00d7 \u03b1) : m \u03b2 := liftM <| Prim.Ref.modifyGet r f", "start": [109, 1], "end": [109, 121], "kind": "commanddeclaration"}, {"full_name": "ST.Ref.toMonadStateOf", "code": "def Ref.toMonadStateOf (r : Ref \u03c3 \u03b1) : MonadStateOf \u03b1 m where\n  get := r.get\n  set := r.set\n  modifyGet := r.modifyGet", "start": [111, 1], "end": [114, 27], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Fin/Log2.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Log2.lean"], "premises": [{"full_name": "Fin.log2", "code": "def Fin.log2 (n : Fin m) : Fin m := \u27e8Nat.log2 n.val, Nat.lt_of_le_of_lt (Nat.log2_le_self n.val) n.isLt\u27e9", "start": [9, 1], "end": [9, 105], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/List/BasicAux.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init/Util.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean"], "premises": [{"full_name": "List.get!", "code": "def get! [Inhabited \u03b1] : List \u03b1 \u2192 Nat \u2192 \u03b1\n  | a::_,  0   => a\n  | _::as, n+1 => get! as n\n  | _,     _   => panic! \"invalid index\"", "start": [17, 1], "end": [20, 41], "kind": "commanddeclaration"}, {"full_name": "List.get?", "code": "def get? : List \u03b1 \u2192 Nat \u2192 Option \u03b1\n  | a::_,  0   => some a\n  | _::as, n+1 => get? as n\n  | _,     _   => none", "start": [22, 1], "end": [25, 23], "kind": "commanddeclaration"}, {"full_name": "List.getD", "code": "def getD (as : List \u03b1) (idx : Nat) (a\u2080 : \u03b1) : \u03b1 :=\n  (as.get? idx).getD a\u2080", "start": [27, 1], "end": [28, 24], "kind": "commanddeclaration"}, {"full_name": "List.head!", "code": "def head! [Inhabited \u03b1] : List \u03b1 \u2192 \u03b1\n  | []   => panic! \"empty list\"\n  | a::_ => a", "start": [30, 1], "end": [32, 14], "kind": "commanddeclaration"}, {"full_name": "List.head?", "code": "def head? : List \u03b1 \u2192 Option \u03b1\n  | []   => none\n  | a::_ => some a", "start": [34, 1], "end": [36, 19], "kind": "commanddeclaration"}, {"full_name": "List.headD", "code": "def headD : List \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  | [],   a\u2080 => a\u2080\n  | a::_, _  => a", "start": [38, 1], "end": [40, 18], "kind": "commanddeclaration"}, {"full_name": "List.head", "code": "def head : (as : List \u03b1) \u2192 as \u2260 [] \u2192 \u03b1\n  | a::_, _ => a", "start": [42, 1], "end": [43, 17], "kind": "commanddeclaration"}, {"full_name": "List.tail!", "code": "def tail! : List \u03b1 \u2192 List \u03b1\n  | []    => panic! \"empty list\"\n  | _::as => as", "start": [45, 1], "end": [47, 16], "kind": "commanddeclaration"}, {"full_name": "List.tail?", "code": "def tail? : List \u03b1 \u2192 Option (List \u03b1)\n  | []    => none\n  | _::as => some as", "start": [49, 1], "end": [51, 21], "kind": "commanddeclaration"}, {"full_name": "List.tailD", "code": "def tailD : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | [],   as\u2080 => as\u2080\n  | _::as, _  => as", "start": [53, 1], "end": [55, 20], "kind": "commanddeclaration"}, {"full_name": "List.getLast", "code": "def getLast : \u2200 (as : List \u03b1), as \u2260 [] \u2192 \u03b1\n  | [],       h => absurd rfl h\n  | [a],      _ => a\n  | _::b::as, _ => getLast (b::as) (fun h => List.noConfusion h)", "start": [57, 1], "end": [60, 65], "kind": "commanddeclaration"}, {"full_name": "List.getLast!", "code": "def getLast! [Inhabited \u03b1] : List \u03b1 \u2192 \u03b1\n  | []    => panic! \"empty list\"\n  | a::as => getLast (a::as) (fun h => List.noConfusion h)", "start": [62, 1], "end": [64, 59], "kind": "commanddeclaration"}, {"full_name": "List.getLast?", "code": "def getLast? : List \u03b1 \u2192 Option \u03b1\n  | []    => none\n  | a::as => some (getLast (a::as) (fun h => List.noConfusion h))", "start": [66, 1], "end": [68, 66], "kind": "commanddeclaration"}, {"full_name": "List.getLastD", "code": "def getLastD : List \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  | [],   a\u2080 => a\u2080\n  | a::as, _ => getLast (a::as) (fun h => List.noConfusion h)", "start": [70, 1], "end": [72, 62], "kind": "commanddeclaration"}, {"full_name": "List.rotateLeft", "code": "def rotateLeft (xs : List \u03b1) (n : Nat := 1) : List \u03b1 :=\n  let len := xs.length\n  if len \u2264 1 then\n    xs\n  else\n    let n := n % len\n    let b := xs.take n\n    let e := xs.drop n\n    e ++ b", "start": [74, 1], "end": [82, 11], "kind": "commanddeclaration"}, {"full_name": "List.rotateRight", "code": "def rotateRight (xs : List \u03b1) (n : Nat := 1) : List \u03b1 :=\n  let len := xs.length\n  if len \u2264 1 then\n    xs\n  else\n    let n := len - n % len\n    let b := xs.take n\n    let e := xs.drop n\n    e ++ b", "start": [84, 1], "end": [92, 11], "kind": "commanddeclaration"}, {"full_name": "List.get_append_left", "code": "theorem get_append_left (as bs : List \u03b1) (h : i < as.length) {h'} : (as ++ bs).get \u27e8i, h'\u27e9 = as.get \u27e8i, h\u27e9", "start": [94, 1], "end": [100, 25], "kind": "commanddeclaration"}, {"full_name": "List.get_append_right", "code": "theorem get_append_right (as bs : List \u03b1) (h : \u00ac i < as.length) {h' h''} : (as ++ bs).get \u27e8i, h'\u27e9 = bs.get \u27e8i - as.length, h''\u27e9", "start": [102, 1], "end": [107, 41], "kind": "commanddeclaration"}, {"full_name": "List.get_last", "code": "theorem get_last {as : List \u03b1} {i : Fin (length (as ++ [a]))} (h : \u00ac i.1 < as.length) : (as ++ [a] : List _).get i = a", "start": [109, 1], "end": [117, 41], "kind": "commanddeclaration"}, {"full_name": "List.sizeOf_lt_of_mem", "code": "theorem sizeOf_lt_of_mem [SizeOf \u03b1] {as : List \u03b1} (h : a \u2208 as) : sizeOf a < sizeOf as", "start": [119, 1], "end": [122, 57], "kind": "commanddeclaration"}, {"full_name": "List.append_cancel_left", "code": "theorem append_cancel_left {as bs cs : List \u03b1} (h : as ++ bs = as ++ cs) : bs = cs", "start": [136, 1], "end": [141, 15], "kind": "commanddeclaration"}, {"full_name": "List.append_cancel_right", "code": "theorem append_cancel_right {as bs cs : List \u03b1} (h : as ++ bs = cs ++ bs) : as = cs", "start": [143, 1], "end": [148, 82], "kind": "commanddeclaration"}, {"full_name": "List.append_cancel_left_eq", "code": "@[simp] theorem append_cancel_left_eq (as bs cs : List \u03b1) : (as ++ bs = as ++ cs) = (bs = cs)", "start": [150, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "List.append_cancel_right_eq", "code": "@[simp] theorem append_cancel_right_eq (as bs cs : List \u03b1) : (as ++ bs = cs ++ bs) = (as = cs)", "start": [155, 1], "end": [158, 28], "kind": "commanddeclaration"}, {"full_name": "List.sizeOf_get", "code": "@[simp] theorem sizeOf_get [SizeOf \u03b1] (as : List \u03b1) (i : Fin as.length) : sizeOf (as.get i) < sizeOf as", "start": [160, 1], "end": [166, 15], "kind": "commanddeclaration"}, {"full_name": "List.le_antisymm", "code": "theorem le_antisymm [LT \u03b1] [s : Antisymm (\u00ac \u00b7 < \u00b7 : \u03b1 \u2192 \u03b1 \u2192 Prop)] {as bs : List \u03b1} (h\u2081 : as \u2264 bs) (h\u2082 : bs \u2264 as) : as = bs", "start": [168, 1], "end": [182, 24], "kind": "commanddeclaration"}, {"full_name": "List.mapMonoMImp", "code": "@[specialize] private unsafe def mapMonoMImp [Monad m] (as : List \u03b1) (f : \u03b1 \u2192 m \u03b1) : m (List \u03b1) := do\n  match as with\n  | [] => return as\n  | b :: bs =>\n    let b'  \u2190 f b\n    let bs' \u2190 mapMonoMImp bs f\n    if ptrEq b' b && ptrEq bs' bs then\n      return as\n    else\n      return b' :: bs'", "start": [187, 1], "end": [196, 23], "kind": "commanddeclaration"}, {"full_name": "List.mapMonoM", "code": "@[implemented_by mapMonoMImp] def mapMonoM [Monad m] (as : List \u03b1) (f : \u03b1 \u2192 m \u03b1) : m (List \u03b1) :=\n  match as with\n  | [] => return []\n  | a :: as => return (\u2190 f a) :: (\u2190 mapMonoM as f)", "start": [198, 1], "end": [205, 51], "kind": "commanddeclaration"}, {"full_name": "List.mapMono", "code": "def mapMono (as : List \u03b1) (f : \u03b1 \u2192 \u03b1) : List \u03b1 :=\n  Id.run <| as.mapMonoM f", "start": [207, 1], "end": [208, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/System/IO.lean", "imports": ["lake-packages/lean4/src/lean/Init/System/ST.lean", "lake-packages/lean4/src/lean/Init/System/FilePath.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Macro.lean", "lake-packages/lean4/src/lean/Init/Control/EState.lean", "lake-packages/lean4/src/lean/Init/Control/Reader.lean", "lake-packages/lean4/src/lean/Init/Data/Ord.lean", "lake-packages/lean4/src/lean/Init/Data/ByteArray.lean", "lake-packages/lean4/src/lean/Init/System/IOError.lean", "lake-packages/lean4/src/lean/Init/Data/String.lean"], "premises": [{"full_name": "IO.RealWorld", "code": "def IO.RealWorld : Type := Unit", "start": [19, 1], "end": [23, 32], "kind": "commanddeclaration"}, {"full_name": "EIO", "code": "def EIO (\u03b5 : Type) : Type \u2192 Type := EStateM \u03b5 IO.RealWorld", "start": [32, 1], "end": [32, 59], "kind": "commanddeclaration"}, {"full_name": "BaseIO", "code": "def BaseIO := EIO Empty", "start": [40, 1], "end": [41, 24], "kind": "commanddeclaration"}, {"full_name": "BaseIO.toEIO", "code": "@[always_inline, inline]\ndef BaseIO.toEIO (act : BaseIO \u03b1) : EIO \u03b5 \u03b1 :=\n  fun s => match act s with\n  | EStateM.Result.ok a s => EStateM.Result.ok a s", "start": [46, 1], "end": [49, 51], "kind": "commanddeclaration"}, {"full_name": "EIO.toBaseIO", "code": "@[always_inline, inline]\ndef EIO.toBaseIO (act : EIO \u03b5 \u03b1) : BaseIO (Except \u03b5 \u03b1) :=\n  fun s => match act s with\n  | EStateM.Result.ok a s     => EStateM.Result.ok (Except.ok a) s\n  | EStateM.Result.error ex s => EStateM.Result.ok (Except.error ex) s", "start": [53, 1], "end": [57, 71], "kind": "commanddeclaration"}, {"full_name": "EIO.catchExceptions", "code": "@[always_inline, inline]\ndef EIO.catchExceptions (act : EIO \u03b5 \u03b1) (h : \u03b5 \u2192 BaseIO \u03b1) : BaseIO \u03b1 :=\n  fun s => match act s with\n  | EStateM.Result.ok a s     => EStateM.Result.ok a s\n  | EStateM.Result.error ex s => h ex s", "start": [59, 1], "end": [63, 40], "kind": "commanddeclaration"}, {"full_name": "IO", "code": "abbrev IO : Type \u2192 Type := EIO Error", "start": [66, 1], "end": [66, 37], "kind": "commanddeclaration"}, {"full_name": "BaseIO.toIO", "code": "@[inline] def BaseIO.toIO (act : BaseIO \u03b1) : IO \u03b1 :=\n  act", "start": [68, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "EIO.toIO", "code": "@[inline] def EIO.toIO (f : \u03b5 \u2192 IO.Error) (act : EIO \u03b5 \u03b1) : IO \u03b1 :=\n  act.adaptExcept f", "start": [71, 1], "end": [72, 20], "kind": "commanddeclaration"}, {"full_name": "EIO.toIO'", "code": "@[inline] def EIO.toIO' (act : EIO \u03b5 \u03b1) : IO (Except \u03b5 \u03b1) :=\n  act.toBaseIO", "start": [74, 1], "end": [75, 15], "kind": "commanddeclaration"}, {"full_name": "IO.toEIO", "code": "@[inline] def IO.toEIO (f : IO.Error \u2192 \u03b5) (act : IO \u03b1) : EIO \u03b5 \u03b1 :=\n  act.adaptExcept f", "start": [77, 1], "end": [78, 20], "kind": "commanddeclaration"}, {"full_name": "unsafeBaseIO", "code": "@[inline] unsafe def unsafeBaseIO (fn : BaseIO \u03b1) : \u03b1 :=\n  match fn.run () with\n  | EStateM.Result.ok a _ => a", "start": [84, 1], "end": [86, 31], "kind": "commanddeclaration"}, {"full_name": "unsafeEIO", "code": "@[inline] unsafe def unsafeEIO (fn : EIO \u03b5 \u03b1) : Except \u03b5 \u03b1 :=\n  unsafeBaseIO fn.toBaseIO", "start": [88, 1], "end": [89, 27], "kind": "commanddeclaration"}, {"full_name": "unsafeIO", "code": "@[inline] unsafe def unsafeIO (fn : IO \u03b1) : Except IO.Error \u03b1 :=\n  unsafeEIO fn", "start": [91, 1], "end": [92, 15], "kind": "commanddeclaration"}, {"full_name": "timeit", "code": "@[extern \"lean_io_timeit\"] opaque timeit (msg : @& String) (fn : IO \u03b1) : IO \u03b1", "start": [94, 1], "end": [94, 78], "kind": "commanddeclaration"}, {"full_name": "allocprof", "code": "@[extern \"lean_io_allocprof\"] opaque allocprof (msg : @& String) (fn : IO \u03b1) : IO \u03b1", "start": [95, 1], "end": [95, 84], "kind": "commanddeclaration"}, {"full_name": "IO.initializing", "code": "@[extern \"lean_io_initializing\"] opaque IO.initializing : BaseIO Bool", "start": [97, 1], "end": [102, 70], "kind": "commanddeclaration"}, {"full_name": "BaseIO.asTask", "code": "@[extern \"lean_io_as_task\"]\nopaque asTask (act : BaseIO \u03b1) (prio := Task.Priority.default) : BaseIO (Task \u03b1) :=\n  Task.pure <$> act", "start": [106, 1], "end": [116, 20], "kind": "commanddeclaration"}, {"full_name": "BaseIO.mapTask", "code": "@[extern \"lean_io_map_task\"]\nopaque mapTask (f : \u03b1 \u2192 BaseIO \u03b2) (t : Task \u03b1) (prio := Task.Priority.default) : BaseIO (Task \u03b2) :=\n  Task.pure <$> f t.get", "start": [118, 1], "end": [121, 24], "kind": "commanddeclaration"}, {"full_name": "BaseIO.bindTask", "code": "@[extern \"lean_io_bind_task\"]\nopaque bindTask (t : Task \u03b1) (f : \u03b1 \u2192 BaseIO (Task \u03b2)) (prio := Task.Priority.default) : BaseIO (Task \u03b2) :=\n  f t.get", "start": [123, 1], "end": [126, 10], "kind": "commanddeclaration"}, {"full_name": "BaseIO.mapTasks", "code": "def mapTasks (f : List \u03b1 \u2192 BaseIO \u03b2) (tasks : List (Task \u03b1)) (prio := Task.Priority.default) : BaseIO (Task \u03b2) :=\n  go tasks []\nwhere\n  go\n    | t::ts, as =>\n      BaseIO.bindTask t (fun a => go ts (a :: as)) prio\n    | [], as => f as.reverse |>.asTask prio", "start": [128, 1], "end": [134, 44], "kind": "commanddeclaration"}, {"full_name": "EIO.asTask", "code": "@[inline] def asTask (act : EIO \u03b5 \u03b1) (prio := Task.Priority.default) : BaseIO (Task (Except \u03b5 \u03b1)) :=\n  act.toBaseIO.asTask prio", "start": [140, 1], "end": [142, 27], "kind": "commanddeclaration"}, {"full_name": "EIO.mapTask", "code": "@[inline] def mapTask (f : \u03b1 \u2192 EIO \u03b5 \u03b2) (t : Task \u03b1) (prio := Task.Priority.default) : BaseIO (Task (Except \u03b5 \u03b2)) :=\n  BaseIO.mapTask (fun a => f a |>.toBaseIO) t prio", "start": [144, 1], "end": [146, 51], "kind": "commanddeclaration"}, {"full_name": "EIO.bindTask", "code": "@[inline] def bindTask (t : Task \u03b1) (f : \u03b1 \u2192 EIO \u03b5 (Task (Except \u03b5 \u03b2))) (prio := Task.Priority.default) : BaseIO (Task (Except \u03b5 \u03b2)) :=\n  BaseIO.bindTask t (fun a => f a |>.catchExceptions fun e => return Task.pure <| Except.error e) prio", "start": [148, 1], "end": [150, 103], "kind": "commanddeclaration"}, {"full_name": "EIO.mapTasks", "code": "@[inline] def mapTasks (f : List \u03b1 \u2192 EIO \u03b5 \u03b2) (tasks : List (Task \u03b1)) (prio := Task.Priority.default) : BaseIO (Task (Except \u03b5 \u03b2)) :=\n  BaseIO.mapTasks (fun as => f as |>.toBaseIO) tasks prio", "start": [152, 1], "end": [154, 58], "kind": "commanddeclaration"}, {"full_name": "IO.ofExcept", "code": "def ofExcept [ToString \u03b5] (e : Except \u03b5 \u03b1) : IO \u03b1 :=\n  match e with\n  | Except.ok a    => pure a\n  | Except.error e => throw (IO.userError (toString e))", "start": [160, 1], "end": [163, 56], "kind": "commanddeclaration"}, {"full_name": "IO.lazyPure", "code": "def lazyPure (fn : Unit \u2192 \u03b1) : IO \u03b1 :=\n  pure (fn ())", "start": [165, 1], "end": [166, 15], "kind": "commanddeclaration"}, {"full_name": "IO.monoMsNow", "code": "@[extern \"lean_io_mono_ms_now\"] opaque monoMsNow : BaseIO Nat", "start": [168, 1], "end": [169, 62], "kind": "commanddeclaration"}, {"full_name": "IO.monoNanosNow", "code": "@[extern \"lean_io_mono_nanos_now\"] opaque monoNanosNow : BaseIO Nat", "start": [171, 1], "end": [172, 68], "kind": "commanddeclaration"}, {"full_name": "IO.getRandomBytes", "code": "@[extern \"lean_io_get_random_bytes\"] opaque getRandomBytes (nBytes : USize) : IO ByteArray", "start": [174, 1], "end": [176, 91], "kind": "commanddeclaration"}, {"full_name": "IO.sleep", "code": "def sleep (ms : UInt32) : BaseIO Unit :=\n  fun s => dbgSleep ms fun _ => EStateM.Result.ok () s", "start": [178, 1], "end": [180, 55], "kind": "commanddeclaration"}, {"full_name": "IO.asTask", "code": "@[inline] def asTask (act : IO \u03b1) (prio := Task.Priority.default) : BaseIO (Task (Except IO.Error \u03b1)) :=\n  EIO.asTask act prio", "start": [182, 1], "end": [184, 22], "kind": "commanddeclaration"}, {"full_name": "IO.mapTask", "code": "@[inline] def mapTask (f : \u03b1 \u2192 IO \u03b2) (t : Task \u03b1) (prio := Task.Priority.default) : BaseIO (Task (Except IO.Error \u03b2)) :=\n  EIO.mapTask f t prio", "start": [186, 1], "end": [188, 23], "kind": "commanddeclaration"}, {"full_name": "IO.bindTask", "code": "@[inline] def bindTask (t : Task \u03b1) (f : \u03b1 \u2192 IO (Task (Except IO.Error \u03b2))) (prio := Task.Priority.default) : BaseIO (Task (Except IO.Error \u03b2)) :=\n  EIO.bindTask t f prio", "start": [190, 1], "end": [192, 24], "kind": "commanddeclaration"}, {"full_name": "IO.mapTasks", "code": "@[inline] def mapTasks (f : List \u03b1 \u2192 IO \u03b2) (tasks : List (Task \u03b1)) (prio := Task.Priority.default) : BaseIO (Task (Except IO.Error \u03b2)) :=\n  EIO.mapTasks f tasks prio", "start": [194, 1], "end": [196, 28], "kind": "commanddeclaration"}, {"full_name": "IO.checkCanceled", "code": "@[extern \"lean_io_check_canceled\"] opaque checkCanceled : BaseIO Bool", "start": [198, 1], "end": [199, 70], "kind": "commanddeclaration"}, {"full_name": "IO.cancel", "code": "@[extern \"lean_io_cancel\"] opaque cancel : @& Task \u03b1 \u2192 BaseIO Unit", "start": [201, 1], "end": [202, 67], "kind": "commanddeclaration"}, {"full_name": "IO.hasFinished", "code": "@[extern \"lean_io_has_finished\"] opaque hasFinished : @& Task \u03b1 \u2192 BaseIO Bool", "start": [204, 1], "end": [205, 78], "kind": "commanddeclaration"}, {"full_name": "IO.wait", "code": "@[extern \"lean_io_wait\"] opaque wait (t : Task \u03b1) : BaseIO \u03b1 :=\n  return t.get", "start": [207, 1], "end": [209, 15], "kind": "commanddeclaration"}, {"full_name": "IO.waitAny", "code": "@[extern \"lean_io_wait_any\"] opaque waitAny (tasks : @& List (Task \u03b1))\n    (h : tasks.length > 0 := by nonempty_list) : BaseIO \u03b1 :=\n  return tasks[0].get", "start": [214, 1], "end": [217, 22], "kind": "commanddeclaration"}, {"full_name": "IO.getNumHeartbeats", "code": "@[extern \"lean_io_get_num_heartbeats\"] opaque getNumHeartbeats : BaseIO Nat", "start": [219, 1], "end": [220, 76], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Mode", "code": "inductive FS.Mode where\n  \n  | read\n  \n  | write\n  \n  | writeNew\n  \n  | readWrite\n  \n  | append", "start": [222, 1], "end": [282, 11], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle", "code": "opaque FS.Handle : Type := Unit", "start": [284, 1], "end": [284, 32], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream", "code": "structure FS.Stream where\n  flush   : IO Unit\n  \n  read    : USize \u2192 IO ByteArray\n  write   : ByteArray \u2192 IO Unit\n  \n  getLine : IO String\n  putStr  : String \u2192 IO Unit\n  deriving Inhabited", "start": [286, 1], "end": [305, 21], "kind": "commanddeclaration"}, {"full_name": "IO.getStdin", "code": "@[extern \"lean_get_stdin\"] opaque getStdin  : BaseIO FS.Stream", "start": [309, 1], "end": [309, 63], "kind": "commanddeclaration"}, {"full_name": "IO.getStdout", "code": "@[extern \"lean_get_stdout\"] opaque getStdout : BaseIO FS.Stream", "start": [310, 1], "end": [310, 64], "kind": "commanddeclaration"}, {"full_name": "IO.getStderr", "code": "@[extern \"lean_get_stderr\"] opaque getStderr : BaseIO FS.Stream", "start": [311, 1], "end": [311, 64], "kind": "commanddeclaration"}, {"full_name": "IO.setStdin", "code": "@[extern \"lean_get_set_stdin\"] opaque setStdin  : FS.Stream \u2192 BaseIO FS.Stream", "start": [313, 1], "end": [314, 79], "kind": "commanddeclaration"}, {"full_name": "IO.setStdout", "code": "@[extern \"lean_get_set_stdout\"] opaque setStdout : FS.Stream \u2192 BaseIO FS.Stream", "start": [315, 1], "end": [316, 80], "kind": "commanddeclaration"}, {"full_name": "IO.setStderr", "code": "@[extern \"lean_get_set_stderr\"] opaque setStderr : FS.Stream \u2192 BaseIO FS.Stream", "start": [317, 1], "end": [318, 80], "kind": "commanddeclaration"}, {"full_name": "IO.iterate", "code": "@[specialize] partial def iterate (a : \u03b1) (f : \u03b1 \u2192 IO (Sum \u03b1 \u03b2)) : IO \u03b2 := do\n  let v \u2190 f a\n  match v with\n  | Sum.inl a => iterate a f\n  | Sum.inr b => pure b", "start": [320, 1], "end": [324, 24], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle.mk", "code": "@[extern \"lean_io_prim_handle_mk\"] opaque mk (fn : @& FilePath) (mode : FS.Mode) : IO Handle", "start": [330, 1], "end": [330, 93], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle.flush", "code": "@[extern \"lean_io_prim_handle_flush\"] opaque flush (h : @& Handle) : IO Unit", "start": [331, 1], "end": [331, 77], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle.read", "code": "@[extern \"lean_io_prim_handle_read\"] opaque read (h : @& Handle) (bytes : USize) : IO ByteArray", "start": [332, 1], "end": [337, 96], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle.write", "code": "@[extern \"lean_io_prim_handle_write\"] opaque write (h : @& Handle) (buffer : @& ByteArray) : IO Unit", "start": [338, 1], "end": [338, 101], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle.getLine", "code": "@[extern \"lean_io_prim_handle_get_line\"] opaque getLine (h : @& Handle) : IO String", "start": [340, 1], "end": [345, 84], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle.putStr", "code": "@[extern \"lean_io_prim_handle_put_str\"] opaque putStr (h : @& Handle) (s : @& String) : IO Unit", "start": [346, 1], "end": [346, 96], "kind": "commanddeclaration"}, {"full_name": "IO.FS.realPath", "code": "@[extern \"lean_io_realpath\"] opaque realPath (fname : FilePath) : IO FilePath", "start": [350, 1], "end": [350, 78], "kind": "commanddeclaration"}, {"full_name": "IO.FS.removeFile", "code": "@[extern \"lean_io_remove_file\"] opaque removeFile (fname : @& FilePath) : IO Unit", "start": [351, 1], "end": [351, 82], "kind": "commanddeclaration"}, {"full_name": "IO.FS.removeDir", "code": "@[extern \"lean_io_remove_dir\"] opaque removeDir : @& FilePath \u2192 IO Unit", "start": [352, 1], "end": [353, 72], "kind": "commanddeclaration"}, {"full_name": "IO.FS.createDir", "code": "@[extern \"lean_io_create_dir\"] opaque createDir : @& FilePath \u2192 IO Unit", "start": [354, 1], "end": [354, 72], "kind": "commanddeclaration"}, {"full_name": "IO.FS.rename", "code": "@[extern \"lean_io_rename\"] opaque rename (old new : @& FilePath) : IO Unit", "start": [356, 1], "end": [362, 75], "kind": "commanddeclaration"}, {"full_name": "IO.getEnv", "code": "@[extern \"lean_io_getenv\"] opaque getEnv (var : @& String) : BaseIO (Option String)", "start": [366, 1], "end": [366, 84], "kind": "commanddeclaration"}, {"full_name": "IO.appPath", "code": "@[extern \"lean_io_app_path\"] opaque appPath : IO FilePath", "start": [367, 1], "end": [367, 58], "kind": "commanddeclaration"}, {"full_name": "IO.currentDir", "code": "@[extern \"lean_io_current_dir\"] opaque currentDir : IO FilePath", "start": [368, 1], "end": [368, 64], "kind": "commanddeclaration"}, {"full_name": "IO.FS.withFile", "code": "@[inline]\ndef withFile (fn : FilePath) (mode : Mode) (f : Handle \u2192 IO \u03b1) : IO \u03b1 :=\n  Handle.mk fn mode >>= f", "start": [372, 1], "end": [374, 26], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle.putStrLn", "code": "def Handle.putStrLn (h : Handle) (s : String) : IO Unit :=\n  h.putStr (s.push '\\n')", "start": [376, 1], "end": [377, 25], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle.readBinToEnd", "code": "partial def Handle.readBinToEnd (h : Handle) : IO ByteArray := do\n  let rec loop (acc : ByteArray) : IO ByteArray := do\n    let buf \u2190 h.read 1024\n    if buf.isEmpty then\n      return acc\n    else\n      loop (acc ++ buf)\n  loop ByteArray.empty", "start": [379, 1], "end": [386, 23], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Handle.readToEnd", "code": "partial def Handle.readToEnd (h : Handle) : IO String := do\n  let rec loop (s : String) := do\n    let line \u2190 h.getLine\n    if line.isEmpty then\n      return s\n    else\n      loop (s ++ line)\n  loop \"\"", "start": [388, 1], "end": [395, 10], "kind": "commanddeclaration"}, {"full_name": "IO.FS.readBinFile", "code": "def readBinFile (fname : FilePath) : IO ByteArray := do\n  let h \u2190 Handle.mk fname Mode.read\n  h.readBinToEnd", "start": [397, 1], "end": [399, 17], "kind": "commanddeclaration"}, {"full_name": "IO.FS.readFile", "code": "def readFile (fname : FilePath) : IO String := do\n  let h \u2190 Handle.mk fname Mode.read\n  h.readToEnd", "start": [401, 1], "end": [403, 14], "kind": "commanddeclaration"}, {"full_name": "IO.FS.lines", "code": "partial def lines (fname : FilePath) : IO (Array String) := do\n  let h \u2190 Handle.mk fname Mode.read\n  let rec read (lines : Array String) := do\n    let line \u2190 h.getLine\n    if line.length == 0 then\n      pure lines\n    else if line.back == '\\n' then\n      let line := line.dropRight 1\n      let line := if System.Platform.isWindows && line.back == '\\x0d' then line.dropRight 1 else line\n      read <| lines.push line\n    else\n      pure <| lines.push line\n  read #[]", "start": [405, 1], "end": [417, 11], "kind": "commanddeclaration"}, {"full_name": "IO.FS.writeBinFile", "code": "def writeBinFile (fname : FilePath) (content : ByteArray) : IO Unit := do\n  let h \u2190 Handle.mk fname Mode.write\n  h.write content", "start": [419, 1], "end": [421, 18], "kind": "commanddeclaration"}, {"full_name": "IO.FS.writeFile", "code": "def writeFile (fname : FilePath) (content : String) : IO Unit := do\n  let h \u2190 Handle.mk fname Mode.write\n  h.putStr content", "start": [423, 1], "end": [425, 19], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.putStrLn", "code": "def Stream.putStrLn (strm : FS.Stream) (s : String) : IO Unit :=\n  strm.putStr (s.push '\\n')", "start": [427, 1], "end": [428, 28], "kind": "commanddeclaration"}, {"full_name": "IO.FS.DirEntry", "code": "structure DirEntry where\n  root     : FilePath\n  fileName : String\n  deriving Repr", "start": [430, 1], "end": [433, 16], "kind": "commanddeclaration"}, {"full_name": "IO.FS.DirEntry.path", "code": "def DirEntry.path (entry : DirEntry) : FilePath :=\n  entry.root / entry.fileName", "start": [435, 1], "end": [436, 30], "kind": "commanddeclaration"}, {"full_name": "IO.FS.FileType", "code": "inductive FileType where\n  | dir\n  | file\n  | symlink\n  | other\n  deriving Repr, BEq", "start": [438, 1], "end": [443, 21], "kind": "commanddeclaration"}, {"full_name": "IO.FS.SystemTime", "code": "structure SystemTime where\n  sec  : Int\n  nsec : UInt32\n  deriving Repr, BEq, Ord, Inhabited", "start": [445, 1], "end": [448, 37], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Metadata", "code": "structure Metadata where\n  accessed : SystemTime\n  modified : SystemTime\n  byteSize : UInt64\n  type     : FileType\n  deriving Repr", "start": [453, 1], "end": [459, 16], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.readDir", "code": "@[extern \"lean_io_read_dir\"]\nopaque readDir : @& FilePath \u2192 IO (Array IO.FS.DirEntry)", "start": [467, 1], "end": [468, 57], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.metadata", "code": "@[extern \"lean_io_metadata\"]\nopaque metadata : @& FilePath \u2192 IO IO.FS.Metadata", "start": [470, 1], "end": [471, 50], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.isDir", "code": "def isDir (p : FilePath) : BaseIO Bool := do\n  match (\u2190 p.metadata.toBaseIO) with\n  | Except.ok m => return m.type == IO.FS.FileType.dir\n  | Except.error _ => return false", "start": [473, 1], "end": [476, 35], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.pathExists", "code": "def pathExists (p : FilePath) : BaseIO Bool :=\n  return (\u2190 p.metadata.toBaseIO).toBool", "start": [478, 1], "end": [479, 40], "kind": "commanddeclaration"}, {"full_name": "System.FilePath.walkDir", "code": "partial def walkDir (p : FilePath) (enter : FilePath \u2192 IO Bool := fun _ => pure true) : IO (Array FilePath) :=\n  Prod.snd <$> StateT.run (go p) #[]\nwhere\n  go p := do\n    if !(\u2190 enter p) then\n      return ()\n    for d in (\u2190 p.readDir) do\n      modify (\u00b7.push d.path)\n      match (\u2190 d.path.metadata.toBaseIO) with\n      | .ok { type := .symlink, .. } =>\n        let p' \u2190 FS.realPath d.path\n        if (\u2190 p'.isDir) then\n          if (\u2190 enter p) then\n            go p'\n      | .ok { type := .dir, .. } => go d.path\n      | .ok _ => pure ()\n      | .error (.noFileOrDirectory ..) => pure ()\n      | .error e => throw e", "start": [481, 1], "end": [503, 28], "kind": "commanddeclaration"}, {"full_name": "IO.withStdin", "code": "def withStdin [Monad m] [MonadFinally m] [MonadLiftT BaseIO m] (h : FS.Stream) (x : m \u03b1) : m \u03b1 := do\n  let prev \u2190 setStdin h\n  try x finally discard <| setStdin prev", "start": [509, 1], "end": [511, 41], "kind": "commanddeclaration"}, {"full_name": "IO.withStdout", "code": "def withStdout [Monad m] [MonadFinally m] [MonadLiftT BaseIO m] (h : FS.Stream) (x : m \u03b1) : m \u03b1 := do\n  let prev \u2190 setStdout h\n  try\n    x\n  finally\n    discard <| setStdout prev", "start": [513, 1], "end": [518, 30], "kind": "commanddeclaration"}, {"full_name": "IO.withStderr", "code": "def withStderr [Monad m] [MonadFinally m] [MonadLiftT BaseIO m] (h : FS.Stream) (x : m \u03b1) : m \u03b1 := do\n  let prev \u2190 setStderr h\n  try x finally discard <| setStderr prev", "start": [520, 1], "end": [522, 42], "kind": "commanddeclaration"}, {"full_name": "IO.print", "code": "def print [ToString \u03b1] (s : \u03b1) : IO Unit := do\n  let out \u2190 getStdout\n  out.putStr <| toString s", "start": [524, 1], "end": [526, 27], "kind": "commanddeclaration"}, {"full_name": "IO.println", "code": "def println [ToString \u03b1] (s : \u03b1) : IO Unit :=\n  print ((toString s).push '\\n')", "start": [528, 1], "end": [529, 33], "kind": "commanddeclaration"}, {"full_name": "IO.eprint", "code": "def eprint [ToString \u03b1] (s : \u03b1) : IO Unit := do\n  let out \u2190 getStderr\n  out.putStr <| toString s", "start": [531, 1], "end": [533, 27], "kind": "commanddeclaration"}, {"full_name": "IO.eprintln", "code": "def eprintln [ToString \u03b1] (s : \u03b1) : IO Unit :=\n  eprint <| toString s |>.push '\\n'", "start": [535, 1], "end": [536, 36], "kind": "commanddeclaration"}, {"full_name": "IO.eprintAux", "code": "@[export lean_io_eprint]\nprivate def eprintAux (s : String) : IO Unit :=\n  eprint s", "start": [538, 1], "end": [540, 11], "kind": "commanddeclaration"}, {"full_name": "IO.eprintlnAux", "code": "@[export lean_io_eprintln]\nprivate def eprintlnAux (s : String) : IO Unit :=\n  eprintln s", "start": [542, 1], "end": [544, 13], "kind": "commanddeclaration"}, {"full_name": "IO.appDir", "code": "def appDir : IO FilePath := do\n  let p \u2190 appPath\n  let some p \u2190 pure p.parent\n    | throw <| IO.userError s!\"System.IO.appDir: unexpected filename '{p}'\"\n  FS.realPath p", "start": [546, 1], "end": [550, 16], "kind": "commanddeclaration"}, {"full_name": "IO.FS.createDirAll", "code": "partial def FS.createDirAll (p : FilePath) : IO Unit := do\n  if \u2190 p.isDir then\n    return ()\n  if let some parent := p.parent then\n    createDirAll parent\n  try\n    createDir p\n  catch\n    | e =>\n      if \u2190 p.isDir then\n        pure ()  else\n        throw e", "start": [552, 1], "end": [565, 16], "kind": "commanddeclaration"}, {"full_name": "IO.FS.removeDirAll", "code": "partial def FS.removeDirAll (p : FilePath) : IO Unit := do\n  for ent in (\u2190 p.readDir) do\n    if (\u2190 ent.path.isDir : Bool) then\n      removeDirAll ent.path\n    else\n      removeFile ent.path\n  removeDir p", "start": [567, 1], "end": [576, 14], "kind": "commanddeclaration"}, {"full_name": "IO.Process.getPID", "code": "@[extern \"lean_io_process_get_pid\"] opaque getPID : BaseIO UInt32", "start": [580, 1], "end": [581, 66], "kind": "commanddeclaration"}, {"full_name": "IO.Process.Stdio", "code": "inductive Stdio where\n  | piped\n  | inherit\n  | null", "start": [583, 1], "end": [586, 9], "kind": "commanddeclaration"}, {"full_name": "IO.Process.Stdio.toHandleType", "code": "def Stdio.toHandleType : Stdio \u2192 Type\n  | Stdio.piped   => FS.Handle\n  | Stdio.inherit => Unit\n  | Stdio.null    => Unit", "start": [588, 1], "end": [591, 26], "kind": "commanddeclaration"}, {"full_name": "IO.Process.StdioConfig", "code": "structure StdioConfig where\n  \n  stdin := Stdio.inherit\n  \n  stdout := Stdio.inherit\n  \n  stderr := Stdio.inherit", "start": [593, 1], "end": [599, 26], "kind": "commanddeclaration"}, {"full_name": "IO.Process.SpawnArgs", "code": "structure SpawnArgs extends StdioConfig where\n  \n  cmd : String\n  \n  args : Array String := #[]\n  \n  cwd : Option FilePath := none\n  \n  env : Array (String \u00d7 Option String) := #[]\n  \n  setsid : Bool := false", "start": [601, 1], "end": [611, 25], "kind": "commanddeclaration"}, {"full_name": "IO.Process.Child", "code": "structure Child (cfg : StdioConfig) where\n  stdin  : cfg.stdin.toHandleType\n  stdout : cfg.stdout.toHandleType\n  stderr : cfg.stderr.toHandleType", "start": [614, 1], "end": [617, 35], "kind": "commanddeclaration"}, {"full_name": "IO.Process.spawn", "code": "@[extern \"lean_io_process_spawn\"] opaque spawn (args : SpawnArgs) : IO (Child args.toStdioConfig)", "start": [619, 1], "end": [619, 98], "kind": "commanddeclaration"}, {"full_name": "IO.Process.Child.wait", "code": "@[extern \"lean_io_process_child_wait\"] opaque Child.wait {cfg : @& StdioConfig} : @& Child cfg \u2192 IO UInt32", "start": [621, 1], "end": [621, 107], "kind": "commanddeclaration"}, {"full_name": "IO.Process.Child.kill", "code": "@[extern \"lean_io_process_child_kill\"] opaque Child.kill {cfg : @& StdioConfig} : @& Child cfg \u2192 IO Unit", "start": [623, 1], "end": [625, 105], "kind": "commanddeclaration"}, {"full_name": "IO.Process.Child.takeStdin", "code": "@[extern \"lean_io_process_child_take_stdin\"] opaque Child.takeStdin {cfg : @& StdioConfig} : Child cfg \u2192\n    IO (cfg.stdin.toHandleType \u00d7 Child { cfg with stdin := Stdio.null })", "start": [627, 1], "end": [634, 73], "kind": "commanddeclaration"}, {"full_name": "IO.Process.Output", "code": "structure Output where\n  exitCode : UInt32\n  stdout   : String\n  stderr   : String", "start": [636, 1], "end": [639, 20], "kind": "commanddeclaration"}, {"full_name": "IO.Process.output", "code": "def output (args : SpawnArgs) : IO Output := do\n  let child \u2190 spawn { args with stdout := .piped, stderr := .piped, stdin := .null }\n  let stdout \u2190 IO.asTask child.stdout.readToEnd Task.Priority.dedicated\n  let stderr \u2190 child.stderr.readToEnd\n  let exitCode \u2190 child.wait\n  let stdout \u2190 IO.ofExcept stdout.get\n  pure { exitCode := exitCode, stdout := stdout, stderr := stderr }", "start": [641, 1], "end": [651, 68], "kind": "commanddeclaration"}, {"full_name": "IO.Process.run", "code": "def run (args : SpawnArgs) : IO String := do\n  let out \u2190 output args\n  if out.exitCode != 0 then\n    throw <| IO.userError <| \"process '\" ++ args.cmd ++ \"' exited with code \" ++ toString out.exitCode\n  pure out.stdout", "start": [653, 1], "end": [658, 18], "kind": "commanddeclaration"}, {"full_name": "IO.Process.exit", "code": "@[extern \"lean_io_exit\"] opaque exit : UInt8 \u2192 IO \u03b1", "start": [660, 1], "end": [660, 52], "kind": "commanddeclaration"}, {"full_name": "IO.AccessRight", "code": "structure AccessRight where\n  read : Bool := false\n  write : Bool := false\n  execution : Bool := false", "start": [664, 1], "end": [667, 28], "kind": "commanddeclaration"}, {"full_name": "IO.AccessRight.flags", "code": "def AccessRight.flags (acc : AccessRight) : UInt32 :=\n  let r : UInt32 := if acc.read      then 0x4 else 0\n  let w : UInt32 := if acc.write     then 0x2 else 0\n  let x : UInt32 := if acc.execution then 0x1 else 0\n  r.lor <| w.lor x", "start": [669, 1], "end": [673, 19], "kind": "commanddeclaration"}, {"full_name": "IO.FileRight", "code": "structure FileRight where\n  user  : AccessRight := {}\n  group : AccessRight := {}\n  other : AccessRight := {}", "start": [675, 1], "end": [678, 28], "kind": "commanddeclaration"}, {"full_name": "IO.FileRight.flags", "code": "def FileRight.flags (acc : FileRight) : UInt32 :=\n  let u : UInt32 := acc.user.flags.shiftLeft 6\n  let g : UInt32 := acc.group.flags.shiftLeft 3\n  let o : UInt32 := acc.other.flags\n  u.lor <| g.lor o", "start": [680, 1], "end": [684, 19], "kind": "commanddeclaration"}, {"full_name": "IO.Prim.setAccessRights", "code": "@[extern \"lean_chmod\"] opaque Prim.setAccessRights (filename : @& FilePath) (mode : UInt32) : IO Unit", "start": [686, 1], "end": [686, 102], "kind": "commanddeclaration"}, {"full_name": "IO.setAccessRights", "code": "def setAccessRights (filename : FilePath) (mode : FileRight) : IO Unit :=\n  Prim.setAccessRights filename mode.flags", "start": [688, 1], "end": [689, 43], "kind": "commanddeclaration"}, {"full_name": "IO.Ref", "code": "abbrev Ref (\u03b1 : Type) := ST.Ref IO.RealWorld \u03b1", "start": [691, 1], "end": [692, 47], "kind": "commanddeclaration"}, {"full_name": "IO.mkRef", "code": "def mkRef (a : \u03b1) : BaseIO (IO.Ref \u03b1) :=\n  ST.mkRef a", "start": [696, 1], "end": [697, 13], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.ofHandle", "code": "@[export lean_stream_of_handle]\ndef ofHandle (h : Handle) : Stream := {\n  flush   := Handle.flush h,\n  read    := Handle.read h,\n  write   := Handle.write h,\n  getLine := Handle.getLine h,\n  putStr  := Handle.putStr h,\n}", "start": [702, 1], "end": [709, 2], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.Buffer", "code": "structure Buffer where\n  data : ByteArray := ByteArray.empty\n  pos  : Nat := 0", "start": [711, 1], "end": [713, 18], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.ofBuffer", "code": "def ofBuffer (r : Ref Buffer) : Stream := {\n  flush   := pure (),\n  read    := fun n => r.modifyGet fun b =>\n    let data := b.data.extract b.pos (b.pos + n.toNat)\n    (data, { b with pos := b.pos + data.size }),\n  write   := fun data => r.modify fun b =>\n    { b with data := data.copySlice 0 b.data b.pos data.size false, pos := b.pos + data.size },\n  getLine := r.modifyGet fun b =>\n    let pos := match b.data.findIdx? (start := b.pos) fun u => u == 0 || u = '\\n'.toNat.toUInt8 with\n      | some pos => if b.data.get! pos == 0 then pos else pos + 1\n      | none     => b.data.size\n    (String.fromUTF8Unchecked <| b.data.extract b.pos pos, { b with pos := pos }),\n  putStr  := fun s => r.modify fun b =>\n    let data := s.toUTF8\n    { b with data := data.copySlice 0 b.data b.pos data.size false, pos := b.pos + data.size },\n}", "start": [715, 1], "end": [732, 2], "kind": "commanddeclaration"}, {"full_name": "IO.FS.withIsolatedStreams", "code": "def withIsolatedStreams [Monad m] [MonadFinally m] [MonadLiftT BaseIO m] (x : m \u03b1)\n    (isolateStderr := true) : m (String \u00d7 \u03b1) := do\n  let bIn \u2190 mkRef { : Stream.Buffer }\n  let bOut \u2190 mkRef { : Stream.Buffer }\n  let r \u2190 withStdin (Stream.ofBuffer bIn) <|\n    withStdout (Stream.ofBuffer bOut) <|\n      (if isolateStderr then withStderr (Stream.ofBuffer bOut) else id) <|\n        x\n  let bOut \u2190 liftM (m := BaseIO) bOut.get\n  let out := String.fromUTF8Unchecked bOut.data\n  pure (out, r)", "start": [735, 1], "end": [746, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Eval", "code": "class Eval (\u03b1 : Type u) where\n  eval : (Unit \u2192 \u03b1) \u2192 (hideUnit : Bool := true) \u2192 IO Unit", "start": [755, 1], "end": [760, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.runEval", "code": "def runEval [Eval \u03b1] (a : Unit \u2192 \u03b1) : IO (String \u00d7 Except IO.Error Unit) :=\n  IO.FS.withIsolatedStreams (Eval.eval a false |>.toBaseIO)", "start": [781, 1], "end": [782, 60], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/List/Control.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init/Control/Basic.lean"], "premises": [{"full_name": "List.mapM", "code": "@[inline]\ndef mapM {m : Type u \u2192 Type v} [Monad m] {\u03b1 : Type w} {\u03b2 : Type u} (f : \u03b1 \u2192 m \u03b2) (as : List \u03b1) : m (List \u03b2) :=\n  let rec @[specialize] loop\n    | [],      bs => pure bs.reverse\n    | a :: as, bs => do loop as ((\u2190 f a)::bs)\n  loop as []", "start": [43, 1], "end": [48, 13], "kind": "commanddeclaration"}, {"full_name": "List.mapA", "code": "@[specialize]\ndef mapA {m : Type u \u2192 Type v} [Applicative m] {\u03b1 : Type w} {\u03b2 : Type u} (f : \u03b1 \u2192 m \u03b2) : List \u03b1 \u2192 m (List \u03b2)\n  | []    => pure []\n  | a::as => List.cons <$> f a <*> mapA f as", "start": [50, 1], "end": [53, 45], "kind": "commanddeclaration"}, {"full_name": "List.forM", "code": "@[specialize]\nprotected def forM {m : Type u \u2192 Type v} [Monad m] {\u03b1 : Type w} (as : List \u03b1) (f : \u03b1 \u2192 m PUnit) : m PUnit :=\n  match as with\n  | []      => pure \u27e8\u27e9\n  | a :: as => do f a; List.forM as f", "start": [55, 1], "end": [59, 38], "kind": "commanddeclaration"}, {"full_name": "List.forA", "code": "@[specialize]\ndef forA {m : Type u \u2192 Type v} [Applicative m] {\u03b1 : Type w} (as : List \u03b1) (f : \u03b1 \u2192 m PUnit) : m PUnit :=\n  match as with\n  | []      => pure \u27e8\u27e9\n  | a :: as => f a *> forA as f", "start": [61, 1], "end": [65, 32], "kind": "commanddeclaration"}, {"full_name": "List.filterAuxM", "code": "@[specialize]\ndef filterAuxM {m : Type \u2192 Type v} [Monad m] {\u03b1 : Type} (f : \u03b1 \u2192 m Bool) : List \u03b1 \u2192 List \u03b1 \u2192 m (List \u03b1)\n  | [],     acc => pure acc\n  | h :: t, acc => do\n    let b \u2190 f h\n    filterAuxM f t (cond b (h :: acc) acc)", "start": [67, 1], "end": [72, 43], "kind": "commanddeclaration"}, {"full_name": "List.filterM", "code": "@[inline]\ndef filterM {m : Type \u2192 Type v} [Monad m] {\u03b1 : Type} (f : \u03b1 \u2192 m Bool) (as : List \u03b1) : m (List \u03b1) := do\n  let as \u2190 filterAuxM f as []\n  pure as.reverse", "start": [74, 1], "end": [77, 18], "kind": "commanddeclaration"}, {"full_name": "List.filterRevM", "code": "@[inline]\ndef filterRevM {m : Type \u2192 Type v} [Monad m] {\u03b1 : Type} (f : \u03b1 \u2192 m Bool) (as : List \u03b1) : m (List \u03b1) :=\n  filterAuxM f as.reverse []", "start": [79, 1], "end": [81, 29], "kind": "commanddeclaration"}, {"full_name": "List.filterMapM", "code": "@[inline]\ndef filterMapM {m : Type u \u2192 Type v} [Monad m] {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 m (Option \u03b2)) (as : List \u03b1) : m (List \u03b2) :=\n  let rec @[specialize] loop\n    | [],     bs => pure bs\n    | a :: as, bs => do\n      match (\u2190 f a) with\n      | none   => loop as bs\n      | some b => loop as (b::bs)\n  loop as.reverse []", "start": [83, 1], "end": [91, 21], "kind": "commanddeclaration"}, {"full_name": "List.foldlM", "code": "@[specialize]\nprotected def foldlM {m : Type u \u2192 Type v} [Monad m] {s : Type u} {\u03b1 : Type w} : (f : s \u2192 \u03b1 \u2192 m s) \u2192 (init : s) \u2192 List \u03b1 \u2192 m s\n  | _, s, []      => pure s\n  | f, s, a :: as => do\n    let s' \u2190 f s a\n    List.foldlM f s' as", "start": [93, 1], "end": [98, 24], "kind": "commanddeclaration"}, {"full_name": "List.foldrM", "code": "@[inline]\ndef foldrM {m : Type u \u2192 Type v} [Monad m] {s : Type u} {\u03b1 : Type w} (f : \u03b1 \u2192 s \u2192 m s) (init : s) (l : List \u03b1) : m s :=\n  l.reverse.foldlM (fun s a => f a s) init", "start": [100, 1], "end": [102, 43], "kind": "commanddeclaration"}, {"full_name": "List.firstM", "code": "@[specialize]\ndef firstM {m : Type u \u2192 Type v} [Alternative m] {\u03b1 : Type w} {\u03b2 : Type u} (f : \u03b1 \u2192 m \u03b2) : List \u03b1 \u2192 m \u03b2\n  | []    => failure\n  | a::as => f a <|> firstM f as", "start": [104, 1], "end": [107, 33], "kind": "commanddeclaration"}, {"full_name": "List.anyM", "code": "@[specialize]\ndef anyM {m : Type \u2192 Type u} [Monad m] {\u03b1 : Type v} (f : \u03b1 \u2192 m Bool) : List \u03b1 \u2192 m Bool\n  | []    => pure false\n  | a::as => do\n    match (\u2190 f a) with\n    | true  => pure true\n    | false => anyM f as", "start": [109, 1], "end": [115, 25], "kind": "commanddeclaration"}, {"full_name": "List.allM", "code": "@[specialize]\ndef allM {m : Type \u2192 Type u} [Monad m] {\u03b1 : Type v} (f : \u03b1 \u2192 m Bool) : List \u03b1 \u2192 m Bool\n  | []    => pure true\n  | a::as => do\n    match (\u2190 f a) with\n    | true  => allM f as\n    | false => pure false", "start": [117, 1], "end": [123, 26], "kind": "commanddeclaration"}, {"full_name": "List.findM?", "code": "@[specialize]\ndef findM? {m : Type \u2192 Type u} [Monad m] {\u03b1 : Type} (p : \u03b1 \u2192 m Bool) : List \u03b1 \u2192 m (Option \u03b1)\n  | []    => pure none\n  | a::as => do\n    match (\u2190 p a) with\n    | true  => pure (some a)\n    | false => findM? p as", "start": [125, 1], "end": [131, 27], "kind": "commanddeclaration"}, {"full_name": "List.findSomeM?", "code": "@[specialize]\ndef findSomeM? {m : Type u \u2192 Type v} [Monad m] {\u03b1 : Type w} {\u03b2 : Type u} (f : \u03b1 \u2192 m (Option \u03b2)) : List \u03b1 \u2192 m (Option \u03b2)\n  | []    => pure none\n  | a::as => do\n    match (\u2190 f a) with\n    | some b => pure (some b)\n    | none   => findSomeM? f as", "start": [133, 1], "end": [139, 32], "kind": "commanddeclaration"}, {"full_name": "List.forIn", "code": "@[inline] protected def forIn {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : List \u03b1) (init : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let rec @[specialize] loop\n    | [], b    => pure b\n    | a::as, b => do\n      match (\u2190 f a b) with\n      | ForInStep.done b  => pure b\n      | ForInStep.yield b => loop as b\n  loop as init", "start": [141, 1], "end": [148, 15], "kind": "commanddeclaration"}, {"full_name": "List.forIn_nil", "code": "@[simp] theorem forIn_nil [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (b : \u03b2) : forIn [] b f = pure b", "start": [153, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "List.forIn_cons", "code": "@[simp] theorem forIn_cons [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (a : \u03b1) (as : List \u03b1) (b : \u03b2)\n    : forIn (a::as) b f = f a b >>= fun | ForInStep.done b => pure b | ForInStep.yield b => forIn as b f", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "List.forIn'", "code": "@[inline] protected def forIn' {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : List \u03b1) (init : \u03b2) (f : (a : \u03b1) \u2192 a \u2208 as \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let rec @[specialize] loop : (as' : List \u03b1) \u2192 (b : \u03b2) \u2192 Exists (fun bs => bs ++ as' = as) \u2192 m \u03b2\n    | [], b, _    => pure b\n    | a::as', b, h => do\n      have : a \u2208 as := by\n        have \u27e8bs, h\u27e9 := h\n        subst h\n        exact mem_append_of_mem_right _ (Mem.head ..)\n      match (\u2190 f a this b) with\n      | ForInStep.done b  => pure b\n      | ForInStep.yield b =>\n        have : Exists (fun bs => bs ++ as' = as) := have \u27e8bs, h\u27e9 := h; \u27e8bs ++ [a], by rw [\u2190 h, append_cons bs a as']\u27e9\n        loop as' b this\n  loop as init \u27e8[], rfl\u27e9", "start": [160, 1], "end": [173, 25], "kind": "commanddeclaration"}, {"full_name": "List.forIn'_eq_forIn", "code": "@[simp] theorem forIn'_eq_forIn {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : List \u03b1) (init : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : forIn' as init (fun a _ b => f a b) = forIn as init f", "start": [178, 1], "end": [185, 13], "kind": "commanddeclaration"}, {"full_name": "List.forM_nil", "code": "@[simp] theorem forM_nil  [Monad m] (f : \u03b1 \u2192 m PUnit) : forM [] f = pure \u27e8\u27e9", "start": [190, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "List.forM_cons", "code": "@[simp] theorem forM_cons [Monad m] (f : \u03b1 \u2192 m PUnit) (a : \u03b1) (as : List \u03b1) : forM (a::as) f = f a >>= fun _ => forM as f", "start": [192, 1], "end": [193, 6], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Float.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Int/Basic.lean", "lake-packages/lean4/src/lean/Init/Core.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean"], "premises": [{"full_name": "FloatSpec", "code": "structure FloatSpec where\n  float : Type\n  val   : float\n  lt    : float \u2192 float \u2192 Prop\n  le    : float \u2192 float \u2192 Prop\n  decLt : DecidableRel lt\n  decLe : DecidableRel le", "start": [11, 1], "end": [17, 26], "kind": "commanddeclaration"}, {"full_name": "floatSpec", "code": "opaque floatSpec : FloatSpec := {\n  float := Unit,\n  val   := (),\n  lt    := fun _ _ => True,\n  le    := fun _ _ => True,\n  decLt := fun _ _ => inferInstanceAs (Decidable True),\n  decLe := fun _ _ => inferInstanceAs (Decidable True)\n}", "start": [20, 1], "end": [27, 2], "kind": "commanddeclaration"}, {"full_name": "Float", "code": "structure Float where\n  val : floatSpec.float", "start": [29, 1], "end": [30, 24], "kind": "commanddeclaration"}, {"full_name": "Float.add", "code": "@[extern \"lean_float_add\"] opaque Float.add : Float \u2192 Float \u2192 Float", "start": [34, 1], "end": [34, 68], "kind": "commanddeclaration"}, {"full_name": "Float.sub", "code": "@[extern \"lean_float_sub\"] opaque Float.sub : Float \u2192 Float \u2192 Float", "start": [35, 1], "end": [35, 68], "kind": "commanddeclaration"}, {"full_name": "Float.mul", "code": "@[extern \"lean_float_mul\"] opaque Float.mul : Float \u2192 Float \u2192 Float", "start": [36, 1], "end": [36, 68], "kind": "commanddeclaration"}, {"full_name": "Float.div", "code": "@[extern \"lean_float_div\"] opaque Float.div : Float \u2192 Float \u2192 Float", "start": [37, 1], "end": [37, 68], "kind": "commanddeclaration"}, {"full_name": "Float.neg", "code": "@[extern \"lean_float_negate\"] opaque Float.neg : Float \u2192 Float", "start": [38, 1], "end": [38, 63], "kind": "commanddeclaration"}, {"full_name": "Float.lt", "code": "def Float.lt : Float \u2192 Float \u2192 Prop := fun a b =>\n  match a, b with\n  | \u27e8a\u27e9, \u27e8b\u27e9 => floatSpec.lt a b", "start": [41, 1], "end": [43, 33], "kind": "commanddeclaration"}, {"full_name": "Float.le", "code": "def Float.le : Float \u2192 Float \u2192 Prop := fun a b =>\n  floatSpec.le a.val b.val", "start": [45, 1], "end": [46, 27], "kind": "commanddeclaration"}, {"full_name": "Float.beq", "code": "@[extern \"lean_float_beq\"] opaque Float.beq (a b : Float) : Bool", "start": [56, 1], "end": [57, 65], "kind": "commanddeclaration"}, {"full_name": "Float.decLt", "code": "@[extern \"lean_float_decLt\"] opaque Float.decLt (a b : Float) : Decidable (a < b) :=\n  match a, b with\n  | \u27e8a\u27e9, \u27e8b\u27e9 => floatSpec.decLt a b", "start": [61, 1], "end": [63, 36], "kind": "commanddeclaration"}, {"full_name": "Float.decLe", "code": "@[extern \"lean_float_decLe\"] opaque Float.decLe (a b : Float) : Decidable (a \u2264 b) :=\n  match a, b with\n  | \u27e8a\u27e9, \u27e8b\u27e9 => floatSpec.decLe a b", "start": [65, 1], "end": [67, 36], "kind": "commanddeclaration"}, {"full_name": "floatDecLt", "code": "instance floatDecLt (a b : Float) : Decidable (a < b) := Float.decLt a b", "start": [69, 1], "end": [69, 73], "kind": "commanddeclaration"}, {"full_name": "floatDecLe", "code": "instance floatDecLe (a b : Float) : Decidable (a \u2264 b) := Float.decLe a b", "start": [70, 1], "end": [70, 73], "kind": "commanddeclaration"}, {"full_name": "Float.toString", "code": "@[extern \"lean_float_to_string\"] opaque Float.toString : Float \u2192 String", "start": [72, 1], "end": [72, 72], "kind": "commanddeclaration"}, {"full_name": "Float.toUInt8", "code": "@[extern \"lean_float_to_uint8\"] opaque Float.toUInt8 : Float \u2192 UInt8", "start": [74, 1], "end": [76, 69], "kind": "commanddeclaration"}, {"full_name": "Float.toUInt16", "code": "@[extern \"lean_float_to_uint16\"] opaque Float.toUInt16 : Float \u2192 UInt16", "start": [77, 1], "end": [79, 72], "kind": "commanddeclaration"}, {"full_name": "Float.toUInt32", "code": "@[extern \"lean_float_to_uint32\"] opaque Float.toUInt32 : Float \u2192 UInt32", "start": [80, 1], "end": [82, 72], "kind": "commanddeclaration"}, {"full_name": "Float.toUInt64", "code": "@[extern \"lean_float_to_uint64\"] opaque Float.toUInt64 : Float \u2192 UInt64", "start": [83, 1], "end": [85, 72], "kind": "commanddeclaration"}, {"full_name": "Float.toUSize", "code": "@[extern \"lean_float_to_usize\"] opaque Float.toUSize : Float \u2192 USize", "start": [86, 1], "end": [88, 69], "kind": "commanddeclaration"}, {"full_name": "Float.isNaN", "code": "@[extern \"lean_float_isnan\"] opaque Float.isNaN : Float \u2192 Bool", "start": [90, 1], "end": [90, 63], "kind": "commanddeclaration"}, {"full_name": "Float.isFinite", "code": "@[extern \"lean_float_isfinite\"] opaque Float.isFinite : Float \u2192 Bool", "start": [91, 1], "end": [91, 69], "kind": "commanddeclaration"}, {"full_name": "Float.isInf", "code": "@[extern \"lean_float_isinf\"] opaque Float.isInf : Float \u2192 Bool", "start": [92, 1], "end": [92, 63], "kind": "commanddeclaration"}, {"full_name": "Float.frExp", "code": "@[extern \"lean_float_frexp\"] opaque Float.frExp : Float \u2192 Float \u00d7 Int", "start": [93, 1], "end": [97, 70], "kind": "commanddeclaration"}, {"full_name": "UInt64.toFloat", "code": "@[extern \"lean_uint64_to_float\"] opaque UInt64.toFloat (n : UInt64) : Float", "start": [107, 1], "end": [107, 76], "kind": "commanddeclaration"}, {"full_name": "Float.sin", "code": "@[extern \"sin\"] opaque Float.sin : Float \u2192 Float", "start": [109, 1], "end": [109, 49], "kind": "commanddeclaration"}, {"full_name": "Float.cos", "code": "@[extern \"cos\"] opaque Float.cos : Float \u2192 Float", "start": [110, 1], "end": [110, 49], "kind": "commanddeclaration"}, {"full_name": "Float.tan", "code": "@[extern \"tan\"] opaque Float.tan : Float \u2192 Float", "start": [111, 1], "end": [111, 49], "kind": "commanddeclaration"}, {"full_name": "Float.asin", "code": "@[extern \"asin\"] opaque Float.asin : Float \u2192 Float", "start": [112, 1], "end": [112, 51], "kind": "commanddeclaration"}, {"full_name": "Float.acos", "code": "@[extern \"acos\"] opaque Float.acos : Float \u2192 Float", "start": [113, 1], "end": [113, 51], "kind": "commanddeclaration"}, {"full_name": "Float.atan", "code": "@[extern \"atan\"] opaque Float.atan : Float \u2192 Float", "start": [114, 1], "end": [114, 51], "kind": "commanddeclaration"}, {"full_name": "Float.atan2", "code": "@[extern \"atan2\"] opaque Float.atan2 : Float \u2192 Float \u2192 Float", "start": [115, 1], "end": [115, 61], "kind": "commanddeclaration"}, {"full_name": "Float.sinh", "code": "@[extern \"sinh\"] opaque Float.sinh : Float \u2192 Float", "start": [116, 1], "end": [116, 51], "kind": "commanddeclaration"}, {"full_name": "Float.cosh", "code": "@[extern \"cosh\"] opaque Float.cosh : Float \u2192 Float", "start": [117, 1], "end": [117, 51], "kind": "commanddeclaration"}, {"full_name": "Float.tanh", "code": "@[extern \"tanh\"] opaque Float.tanh : Float \u2192 Float", "start": [118, 1], "end": [118, 51], "kind": "commanddeclaration"}, {"full_name": "Float.asinh", "code": "@[extern \"asinh\"] opaque Float.asinh : Float \u2192 Float", "start": [119, 1], "end": [119, 53], "kind": "commanddeclaration"}, {"full_name": "Float.acosh", "code": "@[extern \"acosh\"] opaque Float.acosh : Float \u2192 Float", "start": [120, 1], "end": [120, 53], "kind": "commanddeclaration"}, {"full_name": "Float.atanh", "code": "@[extern \"atanh\"] opaque Float.atanh : Float \u2192 Float", "start": [121, 1], "end": [121, 53], "kind": "commanddeclaration"}, {"full_name": "Float.exp", "code": "@[extern \"exp\"] opaque Float.exp : Float \u2192 Float", "start": [122, 1], "end": [122, 49], "kind": "commanddeclaration"}, {"full_name": "Float.exp2", "code": "@[extern \"exp2\"] opaque Float.exp2 : Float \u2192 Float", "start": [123, 1], "end": [123, 51], "kind": "commanddeclaration"}, {"full_name": "Float.log", "code": "@[extern \"log\"] opaque Float.log : Float \u2192 Float", "start": [124, 1], "end": [124, 49], "kind": "commanddeclaration"}, {"full_name": "Float.log2", "code": "@[extern \"log2\"] opaque Float.log2 : Float \u2192 Float", "start": [125, 1], "end": [125, 51], "kind": "commanddeclaration"}, {"full_name": "Float.log10", "code": "@[extern \"log10\"] opaque Float.log10 : Float \u2192 Float", "start": [126, 1], "end": [126, 53], "kind": "commanddeclaration"}, {"full_name": "Float.pow", "code": "@[extern \"pow\"] opaque Float.pow : Float \u2192 Float \u2192 Float", "start": [127, 1], "end": [127, 57], "kind": "commanddeclaration"}, {"full_name": "Float.sqrt", "code": "@[extern \"sqrt\"] opaque Float.sqrt : Float \u2192 Float", "start": [128, 1], "end": [128, 51], "kind": "commanddeclaration"}, {"full_name": "Float.cbrt", "code": "@[extern \"cbrt\"] opaque Float.cbrt : Float \u2192 Float", "start": [129, 1], "end": [129, 51], "kind": "commanddeclaration"}, {"full_name": "Float.ceil", "code": "@[extern \"ceil\"] opaque Float.ceil : Float \u2192 Float", "start": [130, 1], "end": [130, 51], "kind": "commanddeclaration"}, {"full_name": "Float.floor", "code": "@[extern \"floor\"] opaque Float.floor : Float \u2192 Float", "start": [131, 1], "end": [131, 53], "kind": "commanddeclaration"}, {"full_name": "Float.round", "code": "@[extern \"round\"] opaque Float.round : Float \u2192 Float", "start": [132, 1], "end": [132, 53], "kind": "commanddeclaration"}, {"full_name": "Float.abs", "code": "@[extern \"fabs\"] opaque Float.abs : Float \u2192 Float", "start": [133, 1], "end": [133, 50], "kind": "commanddeclaration"}, {"full_name": "Float.scaleB", "code": "@[extern \"lean_float_scaleb\"]\nopaque Float.scaleB (x : Float) (i : @& Int) : Float", "start": [141, 1], "end": [145, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/UInt/Log2.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Fin/Log2.lean"], "premises": [{"full_name": "UInt8.log2", "code": "@[extern \"lean_uint8_log2\"]\ndef UInt8.log2 (a : UInt8) : UInt8 := \u27e8Fin.log2 a.val\u27e9", "start": [9, 1], "end": [10, 55], "kind": "commanddeclaration"}, {"full_name": "UInt16.log2", "code": "@[extern \"lean_uint16_log2\"]\ndef UInt16.log2 (a : UInt16) : UInt16 := \u27e8Fin.log2 a.val\u27e9", "start": [12, 1], "end": [13, 58], "kind": "commanddeclaration"}, {"full_name": "UInt32.log2", "code": "@[extern \"lean_uint32_log2\"]\ndef UInt32.log2 (a : UInt32) : UInt32 := \u27e8Fin.log2 a.val\u27e9", "start": [15, 1], "end": [16, 58], "kind": "commanddeclaration"}, {"full_name": "UInt64.log2", "code": "@[extern \"lean_uint64_log2\"]\ndef UInt64.log2 (a : UInt64) : UInt64 := \u27e8Fin.log2 a.val\u27e9", "start": [18, 1], "end": [19, 58], "kind": "commanddeclaration"}, {"full_name": "USize.log2", "code": "@[extern \"lean_usize_log2\"]\ndef USize.log2 (a : USize) : USize := \u27e8Fin.log2 a.val\u27e9", "start": [21, 1], "end": [22, 55], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Format/Macro.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Format/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Macro.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Format/Instances.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Format/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean"], "premises": [{"full_name": "List.format", "code": "def List.format [ToFormat \u03b1] : List \u03b1 \u2192 Format\n  | [] => \"[]\"\n  | xs => Format.sbracket <| Format.joinSep xs (\",\" ++ Format.line)", "start": [16, 1], "end": [18, 68], "kind": "commanddeclaration"}, {"full_name": "Option.format", "code": "def Option.format {\u03b1 : Type u} [ToFormat \u03b1] : Option \u03b1 \u2192 Format\n  | none   => \"none\"\n  | some a => \"some \" ++ Std.format a", "start": [26, 1], "end": [28, 38], "kind": "commanddeclaration"}, {"full_name": "String.toFormat", "code": "def String.toFormat (s : String) : Std.Format :=\n  Std.Format.joinSep (s.splitOn \"\\n\") Std.Format.line", "start": [36, 1], "end": [37, 54], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat/Gcd.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean"], "premises": [{"full_name": "Nat.gcdF", "code": "private def gcdF (x : Nat) : (\u2200 x\u2081, x\u2081 < x \u2192 Nat \u2192 Nat) \u2192 Nat \u2192 Nat :=\n  match x with\n  | 0      => fun _ y => y\n  | succ x => fun f y => f (y % succ x) (mod_lt _ (zero_lt_succ  _)) (succ x)", "start": [11, 1], "end": [14, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd", "code": "@[extern \"lean_nat_gcd\"]\ndef gcd (a b : @& Nat) : Nat :=\n  WellFounded.fix (measure id).wf gcdF a b", "start": [16, 1], "end": [18, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_zero_left", "code": "@[simp] theorem gcd_zero_left (y : Nat) : gcd 0 y = y", "start": [20, 1], "end": [21, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_succ", "code": "theorem gcd_succ (x y : Nat) : gcd (succ x) y = gcd (y % succ x) (succ x)", "start": [23, 1], "end": [24, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_one_left", "code": "@[simp] theorem gcd_one_left (n : Nat) : gcd 1 n = 1", "start": [26, 1], "end": [28, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_zero_right", "code": "@[simp] theorem gcd_zero_right (n : Nat) : gcd n 0 = n", "start": [30, 1], "end": [36, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_self", "code": "@[simp] theorem gcd_self (n : Nat) : gcd n n = n", "start": [38, 1], "end": [39, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat/Power2.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean"], "premises": [{"full_name": "Nat.nextPowerOfTwo_dec", "code": "theorem nextPowerOfTwo_dec {n power : Nat} (h\u2081 : power > 0) (h\u2082 : power < n) : n - power * 2 < n - power", "start": [11, 1], "end": [14, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.nextPowerOfTwo", "code": "def nextPowerOfTwo (n : Nat) : Nat :=\n  go 1 (by decide)\nwhere\n  go (power : Nat) (h : power > 0) : Nat :=\n    if power < n then\n      go (power * 2) (Nat.mul_pos h (by decide))\n    else\n      power\ntermination_by go p h => n - p\ndecreasing_by simp_wf; apply nextPowerOfTwo_dec <;> assumption", "start": [16, 1], "end": [25, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.isPowerOfTwo", "code": "def isPowerOfTwo (n : Nat) := \u2203 k, n = 2 ^ k", "start": [27, 1], "end": [27, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.one_isPowerOfTwo", "code": "theorem one_isPowerOfTwo : isPowerOfTwo 1", "start": [29, 1], "end": [30, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.mul2_isPowerOfTwo_of_isPowerOfTwo", "code": "theorem mul2_isPowerOfTwo_of_isPowerOfTwo (h : isPowerOfTwo n) : isPowerOfTwo (n * 2)", "start": [32, 1], "end": [34, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_isPowerOfTwo", "code": "theorem pos_of_isPowerOfTwo (h : isPowerOfTwo n) : n > 0", "start": [36, 1], "end": [40, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.isPowerOfTwo_nextPowerOfTwo", "code": "theorem isPowerOfTwo_nextPowerOfTwo (n : Nat) : n.nextPowerOfTwo.isPowerOfTwo", "start": [42, 1], "end": [52, 63], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat/SOM.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean", "lake-packages/lean4/src/lean/Init/Data/List/BasicAux.lean"], "premises": [{"full_name": "Nat.SOM.Expr", "code": "inductive Expr where\n  | num (i : Nat)\n  | var (v : Var)\n  | add (a b : Expr)\n  | mul (a b : Expr)\n  deriving Inhabited", "start": [14, 1], "end": [19, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Expr.denote", "code": "def Expr.denote (ctx : Context) : Expr \u2192 Nat\n  | num n   => n\n  | var v   => v.denote ctx\n  | add a b => Nat.add (a.denote ctx) (b.denote ctx)\n  | mul a b => Nat.mul (a.denote ctx) (b.denote ctx)", "start": [21, 1], "end": [25, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Mon", "code": "abbrev Mon := List Var", "start": [27, 1], "end": [27, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Mon.denote", "code": "def Mon.denote (ctx : Context) : Mon \u2192 Nat\n  | [] => 1\n  | v::vs => Nat.mul (v.denote ctx) (denote ctx vs)", "start": [29, 1], "end": [31, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Mon.mul", "code": "def Mon.mul (m\u2081 m\u2082 : Mon) : Mon :=\n  go hugeFuel m\u2081 m\u2082\nwhere\n  go (fuel : Nat) (m\u2081 m\u2082 : Mon) : Mon :=\n    match fuel with\n    | 0 => m\u2081 ++ m\u2082\n    | fuel + 1 =>\n      match m\u2081, m\u2082 with\n      | m\u2081, [] => m\u2081\n      | [], m\u2082 => m\u2082\n      | v\u2081 :: m\u2081, v\u2082 :: m\u2082 =>\n        bif Nat.blt v\u2081 v\u2082 then\n          v\u2081 :: go fuel m\u2081 (v\u2082 :: m\u2082)\n        else bif Nat.blt v\u2082 v\u2081 then\n          v\u2082 :: go fuel (v\u2081 :: m\u2081) m\u2082\n        else\n          v\u2081 :: v\u2082 :: go fuel m\u2081 m\u2082", "start": [33, 1], "end": [49, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly", "code": "abbrev Poly := List (Nat \u00d7 Mon)", "start": [51, 1], "end": [51, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.denote", "code": "def Poly.denote (ctx : Context) : Poly \u2192 Nat\n  | [] => 0\n  | (k, m) :: p => Nat.add (Nat.mul k (m.denote ctx)) (denote ctx p)", "start": [53, 1], "end": [55, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.add", "code": "def Poly.add (p\u2081 p\u2082 : Poly) : Poly :=\n  go hugeFuel p\u2081 p\u2082\nwhere\n  go (fuel : Nat) (p\u2081 p\u2082 : Poly) : Poly :=\n    match fuel with\n    | 0 => p\u2081 ++ p\u2082\n    | fuel + 1 =>\n      match p\u2081, p\u2082 with\n      | p\u2081, [] => p\u2081\n      | [], p\u2082 => p\u2082\n      | (k\u2081, m\u2081) :: p\u2081, (k\u2082, m\u2082) :: p\u2082 =>\n        bif m\u2081 < m\u2082 then\n          (k\u2081, m\u2081) :: go fuel p\u2081 ((k\u2082, m\u2082) :: p\u2082)\n        else bif m\u2082 < m\u2081 then\n          (k\u2082, m\u2082) :: go fuel ((k\u2081, m\u2081) :: p\u2081) p\u2082\n        else bif k\u2081 + k\u2082 == 0 then\n          go fuel p\u2081 p\u2082\n        else\n          (k\u2081 + k\u2082, m\u2081) :: go fuel p\u2081 p\u2082", "start": [57, 1], "end": [75, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.insertSorted", "code": "def Poly.insertSorted (k : Nat) (m : Mon) (p : Poly) : Poly :=\n  match p with\n  | [] => [(k, m)]\n  | (k', m') :: p => bif m < m' then (k, m) :: (k', m') :: p else (k', m') :: insertSorted k m p", "start": [77, 1], "end": [80, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.mulMon", "code": "def Poly.mulMon (p : Poly) (k : Nat) (m : Mon) : Poly :=\n  go p []\nwhere\n  go (p : Poly) (acc : Poly) : Poly :=\n    match p with\n    | [] => acc\n    | (k', m') :: p => go p (acc.insertSorted (k*k') (m.mul m'))", "start": [82, 1], "end": [88, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.mul", "code": "def Poly.mul (p\u2081 : Poly) (p\u2082 : Poly) : Poly :=\n  go p\u2081 []\nwhere\n  go (p\u2081 : Poly) (acc : Poly) : Poly :=\n    match p\u2081 with\n    | [] => acc\n    | (k, m) :: p\u2081 => go p\u2081 (acc.add (p\u2082.mulMon k m))", "start": [90, 1], "end": [96, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Expr.toPoly", "code": "def Expr.toPoly : Expr \u2192 Poly\n  | num k   => bif k == 0 then [] else [(k, [])]\n  | var v   => [(1, [v])]\n  | add a b => a.toPoly.add b.toPoly\n  | mul a b => a.toPoly.mul b.toPoly", "start": [98, 1], "end": [102, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Mon.append_denote", "code": "theorem Mon.append_denote (ctx : Context) (m\u2081 m\u2082 : Mon) : (m\u2081 ++ m\u2082).denote ctx = m\u2081.denote ctx * m\u2082.denote ctx", "start": [104, 1], "end": [107, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Mon.mul_denote", "code": "theorem Mon.mul_denote (ctx : Context) (m\u2081 m\u2082 : Mon) : (m\u2081.mul m\u2082).denote ctx = m\u2081.denote ctx * m\u2082.denote ctx", "start": [109, 1], "end": [120, 105], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.append_denote", "code": "theorem Poly.append_denote (ctx : Context) (p\u2081 p\u2082 : Poly) : (p\u2081 ++ p\u2082).denote ctx = p\u2081.denote ctx + p\u2082.denote ctx", "start": [122, 1], "end": [125, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.add_denote", "code": "theorem Poly.add_denote (ctx : Context) (p\u2081 p\u2082 : Poly) : (p\u2081.add p\u2082).denote ctx = p\u2081.denote ctx + p\u2082.denote ctx", "start": [127, 1], "end": [143, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.denote_insertSorted", "code": "theorem Poly.denote_insertSorted (ctx : Context) (k : Nat) (m : Mon) (p : Poly) : (p.insertSorted k m).denote ctx = p.denote ctx + k * m.denote ctx", "start": [145, 1], "end": [149, 117], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.mulMon_denote", "code": "theorem Poly.mulMon_denote (ctx : Context) (p : Poly) (k : Nat) (m : Mon) : (p.mulMon k m).denote ctx = p.denote ctx * k * m.denote ctx", "start": [151, 1], "end": [158, 136], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Poly.mul_denote", "code": "theorem Poly.mul_denote (ctx : Context) (p\u2081 p\u2082 : Poly) : (p\u2081.mul p\u2082).denote ctx = p\u2081.denote ctx * p\u2082.denote ctx", "start": [160, 1], "end": [169, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Expr.toPoly_denote", "code": "theorem Expr.toPoly_denote (ctx : Context) (e : Expr) : e.toPoly.denote ctx = e.denote ctx", "start": [171, 1], "end": [178, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.SOM.Expr.eq_of_toPoly_eq", "code": "theorem Expr.eq_of_toPoly_eq (ctx : Context) (a b : Expr) (h : a.toPoly == b.toPoly) : a.denote ctx = b.denote ctx", "start": [180, 1], "end": [183, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat/Control.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init/Control/Basic.lean"], "premises": [{"full_name": "Nat.forM", "code": "@[inline] def forM {m} [Monad m] (n : Nat) (f : Nat \u2192 m Unit) : m Unit :=\n  let rec @[specialize] loop\n    | 0   => pure ()\n    | i+1 => do f (n-i-1); loop i\n  loop n", "start": [13, 1], "end": [17, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.forRevM", "code": "@[inline] def forRevM {m} [Monad m] (n : Nat) (f : Nat \u2192 m Unit) : m Unit :=\n  let rec @[specialize] loop\n    | 0   => pure ()\n    | i+1 => do f i; loop i\n  loop n", "start": [19, 1], "end": [23, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.foldM", "code": "@[inline] def foldM {\u03b1 : Type u} {m : Type u \u2192 Type v} [Monad m] (f : Nat \u2192 \u03b1 \u2192 m \u03b1) (init : \u03b1) (n : Nat) : m \u03b1 :=\n  let rec @[specialize] loop\n    | 0,   a => pure a\n    | i+1, a => f (n-i-1) a >>= loop i\n  loop n init", "start": [25, 1], "end": [29, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.foldRevM", "code": "@[inline] def foldRevM {\u03b1 : Type u} {m : Type u \u2192 Type v} [Monad m] (f : Nat \u2192 \u03b1 \u2192 m \u03b1) (init : \u03b1) (n : Nat) : m \u03b1 :=\n  let rec @[specialize] loop\n    | 0,   a => pure a\n    | i+1, a => f i a >>= loop i\n  loop n init", "start": [31, 1], "end": [35, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.allM", "code": "@[inline] def allM {m} [Monad m] (n : Nat) (p : Nat \u2192 m Bool) : m Bool :=\n  let rec @[specialize] loop\n    | 0   => pure true\n    | i+1 => do\n      match (\u2190 p (n-i-1)) with\n      | true  => loop i\n      | false => pure false\n  loop n", "start": [37, 1], "end": [44, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.anyM", "code": "@[inline] def anyM {m} [Monad m] (n : Nat) (p : Nat \u2192 m Bool) : m Bool :=\n  let rec @[specialize] loop\n    | 0   => pure false\n    | i+1 => do\n      match (\u2190 p (n-i-1)) with\n      | true  => pure true\n      | false => loop i\n  loop n", "start": [46, 1], "end": [53, 9], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/StateRef.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/State.lean", "lake-packages/lean4/src/lean/Init/System/IO.lean"], "premises": [{"full_name": "StateRefT'", "code": "def StateRefT' (\u03c9 : Type) (\u03c3 : Type) (m : Type \u2192 Type) (\u03b1 : Type) : Type := ReaderT (ST.Ref \u03c9 \u03c3) m \u03b1", "start": [12, 1], "end": [12, 101], "kind": "commanddeclaration"}, {"full_name": "StateRefT'.run", "code": "@[always_inline, inline]\ndef StateRefT'.run {\u03c9 \u03c3 : Type} {m : Type \u2192 Type} [Monad m] [MonadLiftT (ST \u03c9) m] {\u03b1 : Type} (x : StateRefT' \u03c9 \u03c3 m \u03b1) (s : \u03c3) : m (\u03b1 \u00d7 \u03c3) := do\n  let ref \u2190 ST.mkRef s\n  let a \u2190 x ref\n  let s \u2190 ref.get\n  pure (a, s)", "start": [16, 1], "end": [21, 14], "kind": "commanddeclaration"}, {"full_name": "StateRefT'.run'", "code": "@[always_inline, inline]\ndef StateRefT'.run' {\u03c9 \u03c3 : Type} {m : Type \u2192 Type} [Monad m] [MonadLiftT (ST \u03c9) m] {\u03b1 : Type} (x : StateRefT' \u03c9 \u03c3 m \u03b1) (s : \u03c3) : m \u03b1 := do\n  let (a, _) \u2190 x.run s\n  pure a", "start": [23, 1], "end": [26, 9], "kind": "commanddeclaration"}, {"full_name": "StateRefT'.lift", "code": "@[always_inline, inline]\nprotected def lift (x : m \u03b1) : StateRefT' \u03c9 \u03c3 m \u03b1 :=\n  fun _ => x", "start": [31, 1], "end": [33, 13], "kind": "commanddeclaration"}, {"full_name": "StateRefT'.get", "code": "@[inline]\nprotected def get [Monad m] [MonadLiftT (ST \u03c9) m] : StateRefT' \u03c9 \u03c3 m \u03c3 :=\n  fun ref => ref.get", "start": [40, 1], "end": [42, 21], "kind": "commanddeclaration"}, {"full_name": "StateRefT'.set", "code": "@[inline]\nprotected def set [Monad m] [MonadLiftT (ST \u03c9) m] (s : \u03c3) : StateRefT' \u03c9 \u03c3 m PUnit :=\n  fun ref => ref.set s", "start": [44, 1], "end": [46, 23], "kind": "commanddeclaration"}, {"full_name": "StateRefT'.modifyGet", "code": "@[inline]\nprotected def modifyGet [Monad m] [MonadLiftT (ST \u03c9) m] (f : \u03c3 \u2192 \u03b1 \u00d7 \u03c3) : StateRefT' \u03c9 \u03c3 m \u03b1 :=\n  fun ref => ref.modifyGet f", "start": [48, 1], "end": [50, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/List.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/List/Control.lean", "lake-packages/lean4/src/lean/Init/Data/List/BasicAux.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Array/BasicAux.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean", "lake-packages/lean4/src/lean/Init/NotationExtra.lean"], "premises": [{"full_name": "Array.of_push_eq_push", "code": "theorem Array.of_push_eq_push {as bs : Array \u03b1} (h : as.push a = bs.push b) : as = bs \u2227 a = b", "start": [11, 1], "end": [15, 11], "kind": "commanddeclaration"}, {"full_name": "List.size_toArrayAux", "code": "private theorem List.size_toArrayAux (as : List \u03b1) (bs : Array \u03b1) : (as.toArrayAux bs).size = as.length + bs.size", "start": [17, 1], "end": [20, 47], "kind": "commanddeclaration"}, {"full_name": "List.of_toArrayAux_eq_toArrayAux", "code": "private theorem List.of_toArrayAux_eq_toArrayAux {as bs : List \u03b1} {cs ds : Array \u03b1} (h : as.toArrayAux cs = bs.toArrayAux ds) (hlen : cs.size = ds.size) : as = bs \u2227 cs = ds", "start": [22, 1], "end": [33, 16], "kind": "commanddeclaration"}, {"full_name": "List.toArray_eq_toArray_eq", "code": "@[simp] theorem List.toArray_eq_toArray_eq (as bs : List \u03b1) : (as.toArray = bs.toArray) = (as = bs)", "start": [35, 1], "end": [38, 20], "kind": "commanddeclaration"}, {"full_name": "Array.mapM'", "code": "def Array.mapM' [Monad m] (f : \u03b1 \u2192 m \u03b2) (as : Array \u03b1) : m { bs : Array \u03b2 // bs.size = as.size } :=\n  go 0 \u27e8mkEmpty as.size, rfl\u27e9 (by simp_arith)\nwhere\n  go (i : Nat) (acc : { bs : Array \u03b2 // bs.size = i }) (hle : i \u2264 as.size) : m { bs : Array \u03b2 // bs.size = as.size } := do\n    if h : i = as.size then\n      return h \u25b8 acc\n    else\n      have hlt : i < as.size := Nat.lt_of_le_of_ne hle h\n      let b \u2190 f as[i]\n      go (i+1) \u27e8acc.val.push b, by simp [acc.property]\u27e9 hlt\ntermination_by go i _ _ => as.size - i", "start": [40, 1], "end": [50, 39], "kind": "commanddeclaration"}, {"full_name": "mapMonoMImp", "code": "@[inline] private unsafe def mapMonoMImp [Monad m] (as : Array \u03b1) (f : \u03b1 \u2192 m \u03b1) : m (Array \u03b1) :=\n  go 0 as\nwhere\n  @[specialize] go (i : Nat) (as : Array \u03b1) : m (Array \u03b1) := do\n    if h : i < as.size then\n      let a := as[i]\n      let b \u2190 f a\n      if ptrEq a b then\n        go (i+1) as\n      else\n        go (i+1) (as.set \u27e8i, h\u27e9 b)\n    else\n      return as", "start": [52, 1], "end": [64, 16], "kind": "commanddeclaration"}, {"full_name": "Array.mapMonoM", "code": "@[implemented_by mapMonoMImp] def Array.mapMonoM [Monad m] (as : Array \u03b1) (f : \u03b1 \u2192 m \u03b1) : m (Array \u03b1) :=\n  as.mapM f", "start": [66, 1], "end": [71, 12], "kind": "commanddeclaration"}, {"full_name": "Array.mapMono", "code": "@[inline] def Array.mapMono (as : Array \u03b1) (f : \u03b1 \u2192 \u03b1) : Array \u03b1 :=\n  Id.run <| as.mapMonoM f", "start": [73, 1], "end": [74, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Array/Mem.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/List/BasicAux.lean"], "premises": [{"full_name": "List.sizeOf_get_lt", "code": "theorem List.sizeOf_get_lt [SizeOf \u03b1] (as : List \u03b1) (i : Fin as.length) : sizeOf (as.get i) < sizeOf as", "start": [11, 1], "end": [19, 53], "kind": "commanddeclaration"}, {"full_name": "Array.sizeOf_get_lt", "code": "theorem sizeOf_get_lt [SizeOf \u03b1] (as : Array \u03b1) (i : Fin as.size) : sizeOf (as.get i) < sizeOf as", "start": [26, 1], "end": [30, 40], "kind": "commanddeclaration"}, {"full_name": "Array.sizeOf_lt_of_mem", "code": "theorem sizeOf_lt_of_mem [DecidableEq \u03b1] [SizeOf \u03b1] {as : Array \u03b1} (h : a \u2208 as) : sizeOf a < sizeOf as", "start": [32, 1], "end": [42, 38], "kind": "commanddeclaration"}, {"full_name": "Array.sizeOf_get", "code": "@[simp] theorem sizeOf_get [SizeOf \u03b1] (as : Array \u03b1) (i : Fin as.size) : sizeOf (as.get i) < sizeOf as", "start": [44, 1], "end": [48, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Array/InsertionSort.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean"], "premises": [{"full_name": "Array.insertionSort", "code": "@[inline] def Array.insertionSort (a : Array \u03b1) (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) : Array \u03b1 :=\n  traverse a 0 a.size\nwhere\n  @[specialize] traverse (a : Array \u03b1) (i : Nat) (fuel : Nat) : Array \u03b1 :=\n    match fuel with\n    | 0      => a\n    | fuel+1 =>\n      if h : i < a.size then\n        traverse (swapLoop a i h) (i+1) fuel\n      else\n        a\n  @[specialize] swapLoop (a : Array \u03b1) (j : Nat) (h : j < a.size) : Array \u03b1 :=\n    match (generalizing := false) he:j with | 0    => a\n    | j'+1 =>\n      have h' : j' < a.size := by subst j; exact Nat.lt_trans (Nat.lt_succ_self _) h\n      if lt a[j] a[j'] then\n        swapLoop (a.swap \u27e8j, h\u27e9 \u27e8j', h'\u27e9) j' (by rw [size_swap]; assumption; done)\n      else\n        a", "start": [9, 1], "end": [28, 10], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Array/DecidableEq.lean", "imports": ["lake-packages/lean4/src/lean/Init/Classical.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean"], "premises": [{"full_name": "Array.eq_of_isEqvAux", "code": "theorem eq_of_isEqvAux [DecidableEq \u03b1] (a b : Array \u03b1) (hsz : a.size = b.size) (i : Nat) (hi : i \u2264 a.size) (heqv : Array.isEqvAux a b hsz (fun x y => x = y) i) (j : Nat) (low : i \u2264 j) (high : j < a.size) : a[j] = b[j]'(hsz \u25b8 high)", "start": [12, 1], "end": [23, 31], "kind": "commanddeclaration"}, {"full_name": "Array.eq_of_isEqv", "code": "theorem eq_of_isEqv [DecidableEq \u03b1] (a b : Array \u03b1) : Array.isEqv a b (fun x y => x = y) \u2192 a = b", "start": [25, 1], "end": [32, 59], "kind": "commanddeclaration"}, {"full_name": "Array.isEqvAux_self", "code": "theorem isEqvAux_self [DecidableEq \u03b1] (a : Array \u03b1) (i : Nat) : Array.isEqvAux a a rfl (fun x y => x = y) i = true", "start": [34, 1], "end": [39, 31], "kind": "commanddeclaration"}, {"full_name": "Array.isEqv_self", "code": "theorem isEqv_self [DecidableEq \u03b1] (a : Array \u03b1) : Array.isEqv a a (fun x y => x = y) = true", "start": [41, 1], "end": [42, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Array/BinSearch.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean"], "premises": [{"full_name": "Array.binSearchAux", "code": "@[specialize] partial def binSearchAux {\u03b1 : Type u} {\u03b2 : Type v} [Inhabited \u03b2] (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (found : Option \u03b1 \u2192 \u03b2) (as : Array \u03b1) (k : \u03b1) : Nat \u2192 Nat \u2192 \u03b2\n  | lo, hi =>\n    if lo <= hi then\n      let _ := Inhabited.mk k\n      let m := (lo + hi)/2\n      let a := as.get! m\n      if lt a k then binSearchAux lt found as k (m+1) hi\n      else if lt k a then\n        if m == 0 then found none\n        else binSearchAux lt found as k lo (m-1)\n      else found (some a)\n    else found none", "start": [16, 1], "end": [27, 20], "kind": "commanddeclaration"}, {"full_name": "Array.binSearch", "code": "@[inline] def binSearch {\u03b1 : Type} (as : Array \u03b1) (k : \u03b1) (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (lo := 0) (hi := as.size - 1) : Option \u03b1 :=\n  if lo < as.size then\n    let hi := if hi < as.size then hi else as.size - 1\n    binSearchAux lt id as k lo hi\n  else\n    none", "start": [29, 1], "end": [34, 9], "kind": "commanddeclaration"}, {"full_name": "Array.binSearchContains", "code": "@[inline] def binSearchContains {\u03b1 : Type} (as : Array \u03b1) (k : \u03b1) (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (lo := 0) (hi := as.size - 1) : Bool :=\n  if lo < as.size then\n    let hi := if hi < as.size then hi else as.size - 1\n    binSearchAux lt Option.isSome as k lo hi\n  else\n    false", "start": [36, 1], "end": [41, 10], "kind": "commanddeclaration"}, {"full_name": "Array.binInsertAux", "code": "@[specialize] private partial def binInsertAux {\u03b1 : Type u} {m : Type u \u2192 Type v} [Monad m]\n    (lt : \u03b1 \u2192 \u03b1 \u2192 Bool)\n    (merge : \u03b1 \u2192 m \u03b1)\n    (add : Unit \u2192 m \u03b1)\n    (as : Array \u03b1)\n    (k : \u03b1) : Nat \u2192 Nat \u2192 m (Array \u03b1)\n  | lo, hi =>\n    let _ := Inhabited.mk k\n    let mid    := (lo + hi)/2\n    let midVal := as.get! mid\n    if lt midVal k then\n      if mid == lo then do let v \u2190 add (); pure <| as.insertAt! (lo+1) v\n      else binInsertAux lt merge add as k mid hi\n    else if lt k midVal then\n      binInsertAux lt merge add as k lo mid\n    else do\n      as.modifyM mid <| fun v => merge v", "start": [43, 1], "end": [60, 41], "kind": "commanddeclaration"}, {"full_name": "Array.binInsertM", "code": "@[specialize] def binInsertM {\u03b1 : Type u} {m : Type u \u2192 Type v} [Monad m]\n    (lt : \u03b1 \u2192 \u03b1 \u2192 Bool)\n    (merge : \u03b1 \u2192 m \u03b1)\n    (add : Unit \u2192 m \u03b1)\n    (as : Array \u03b1)\n    (k : \u03b1) : m (Array \u03b1) :=\n  let _ := Inhabited.mk k\n  if as.isEmpty then do let v \u2190 add (); pure <| as.push v\n  else if lt k (as.get! 0) then do let v \u2190 add (); pure <| as.insertAt! 0 v\n  else if !lt (as.get! 0) k then as.modifyM 0 <| merge\n  else if lt as.back k then do let v \u2190 add (); pure <| as.push v\n  else if !lt k as.back then as.modifyM (as.size - 1) <| merge\n  else binInsertAux lt merge add as k 0 (as.size - 1)", "start": [62, 1], "end": [74, 54], "kind": "commanddeclaration"}, {"full_name": "Array.binInsert", "code": "@[inline] def binInsert {\u03b1 : Type u} (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (as : Array \u03b1) (k : \u03b1) : Array \u03b1 :=\n  Id.run <| binInsertM lt (fun _ => k) (fun _ => k) as k", "start": [76, 1], "end": [77, 57], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Array/QSort.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean"], "premises": [{"full_name": "Array.qpartition", "code": "def qpartition (as : Array \u03b1) (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (lo hi : Nat) : Nat \u00d7 Array \u03b1 :=\n  if h : as.size = 0 then (0, as) else have : Inhabited \u03b1 := \u27e8as[0]'(by revert h; cases as.size <;> simp [Nat.zero_lt_succ])\u27e9 let mid := (lo + hi) / 2\n  let as  := if lt (as.get! mid) (as.get! lo) then as.swap! lo mid else as\n  let as  := if lt (as.get! hi)  (as.get! lo) then as.swap! lo hi  else as\n  let as  := if lt (as.get! mid) (as.get! hi) then as.swap! mid hi else as\n  let pivot := as.get! hi\n  let rec loop (as : Array \u03b1) (i j : Nat) :=\n    if h : j < hi then\n      if lt (as.get! j) pivot then\n        let as := as.swap! i j\n        loop as (i+1) (j+1)\n      else\n        loop as i (j+1)\n    else\n      let as := as.swap! i hi\n      (i, as)\n  loop as lo lo\ntermination_by _ => hi - j", "start": [12, 1], "end": [30, 27], "kind": "commanddeclaration"}, {"full_name": "Array.qsort", "code": "@[inline] partial def qsort (as : Array \u03b1) (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (low := 0) (high := as.size - 1) : Array \u03b1 :=\n  let rec @[specialize] sort (as : Array \u03b1) (low high : Nat) :=\n    if low < high then\n      let p := qpartition as lt low high;\n      let mid := p.1\n      let as  := p.2\n      if mid >= high then as\n      else\n        let as := sort as low mid\n        sort as (mid+1) high\n    else as\n  sort as low high", "start": [32, 1], "end": [44, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Range.lean", "imports": ["lake-packages/lean4/src/lean/Init/Meta.lean"], "premises": [{"full_name": "Std.Range", "code": "structure Range where\n  start : Nat := 0\n  stop  : Nat\n  step  : Nat := 1", "start": [12, 1], "end": [15, 19], "kind": "commanddeclaration"}, {"full_name": "Std.Range.forIn", "code": "@[inline] protected def forIn {\u03b2 : Type u} {m : Type u \u2192 Type v} [Monad m] (range : Range) (init : \u03b2) (f : Nat \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let rec @[specialize] loop (fuel i stop step : Nat) (b : \u03b2) : m \u03b2 := do\n    if i \u2265 stop then\n      return b\n    else match fuel with\n     | 0   => pure b\n     | fuel+1 => match (\u2190 f i b) with\n        | ForInStep.done b  => pure b\n        | ForInStep.yield b => loop fuel (i + step) stop step b\n  loop range.stop range.start range.stop range.step init", "start": [23, 1], "end": [33, 57], "kind": "commanddeclaration"}, {"full_name": "Std.Range.forIn'", "code": "@[inline] protected def forIn' {\u03b2 : Type u} {m : Type u \u2192 Type v} [Monad m] (range : Range) (init : \u03b2) (f : (i : Nat) \u2192 i \u2208 range \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let rec @[specialize] loop (start stop step : Nat) (f : (i : Nat) \u2192 start \u2264 i \u2227 i < stop \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (fuel i : Nat) (hl : start \u2264 i) (b : \u03b2) : m \u03b2 := do\n    if hu : i < stop then\n      match fuel with\n      | 0   => pure b\n      | fuel+1 => match (\u2190 f i \u27e8hl, hu\u27e9 b) with\n         | ForInStep.done b  => pure b\n         | ForInStep.yield b => loop start stop step f fuel (i + step) (Nat.le_trans hl (Nat.le_add_right ..)) b\n    else\n      return b\n  loop range.start range.stop range.step f range.stop range.start (Nat.le_refl ..) init", "start": [38, 1], "end": [48, 88], "kind": "commanddeclaration"}, {"full_name": "Std.Range.forM", "code": "@[inline] protected def forM {m : Type u \u2192 Type v} [Monad m] (range : Range) (f : Nat \u2192 m PUnit) : m PUnit :=\n  let rec @[specialize] loop (fuel i stop step : Nat) : m PUnit := do\n    if i \u2265 stop then\n      pure \u27e8\u27e9\n    else match fuel with\n     | 0   => pure \u27e8\u27e9\n     | fuel+1 => f i; loop fuel (i + step) stop step\n  loop range.stop range.start range.stop range.step", "start": [53, 1], "end": [60, 52], "kind": "commanddeclaration"}, {"full_name": "Membership.mem.upper", "code": "theorem Membership.mem.upper {i : Nat} {r : Std.Range} (h : i \u2208 r) : i < r.stop", "start": [79, 1], "end": [81, 12], "kind": "commanddeclaration"}, {"full_name": "Membership.mem.lower", "code": "theorem Membership.mem.lower {i : Nat} {r : Std.Range} (h : i \u2208 r) : r.start \u2264 i", "start": [83, 1], "end": [85, 12], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/FloatArray/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Option/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Float.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean"], "premises": [{"full_name": "FloatArray", "code": "structure FloatArray where\n  data : Array Float", "start": [12, 1], "end": [13, 21], "kind": "commanddeclaration"}, {"full_name": "FloatArray.mkEmpty", "code": "@[extern \"lean_mk_empty_float_array\"]\ndef mkEmpty (c : @& Nat) : FloatArray :=\n  { data := #[] }", "start": [19, 1], "end": [21, 18], "kind": "commanddeclaration"}, {"full_name": "FloatArray.empty", "code": "def empty : FloatArray :=\n  mkEmpty 0", "start": [23, 1], "end": [24, 12], "kind": "commanddeclaration"}, {"full_name": "FloatArray.push", "code": "@[extern \"lean_float_array_push\"]\ndef push : FloatArray \u2192 Float \u2192 FloatArray\n  | \u27e8ds\u27e9, b => \u27e8ds.push b\u27e9", "start": [32, 1], "end": [34, 27], "kind": "commanddeclaration"}, {"full_name": "FloatArray.size", "code": "@[extern \"lean_float_array_size\"]\ndef size : (@& FloatArray) \u2192 Nat\n  | \u27e8ds\u27e9 => ds.size", "start": [36, 1], "end": [38, 20], "kind": "commanddeclaration"}, {"full_name": "FloatArray.uget", "code": "@[extern \"lean_float_array_uget\"]\ndef uget : (a : @& FloatArray) \u2192 (i : USize) \u2192 i.toNat < a.size \u2192 Float\n  | \u27e8ds\u27e9, i, h => ds[i]", "start": [40, 1], "end": [42, 24], "kind": "commanddeclaration"}, {"full_name": "FloatArray.get", "code": "@[extern \"lean_float_array_fget\"]\ndef get : (ds : @& FloatArray) \u2192 (@& Fin ds.size) \u2192 Float\n  | \u27e8ds\u27e9, i => ds.get i", "start": [44, 1], "end": [46, 24], "kind": "commanddeclaration"}, {"full_name": "FloatArray.get!", "code": "@[extern \"lean_float_array_get\"]\ndef get! : (@& FloatArray) \u2192 (@& Nat) \u2192 Float\n  | \u27e8ds\u27e9, i => ds.get! i", "start": [48, 1], "end": [50, 25], "kind": "commanddeclaration"}, {"full_name": "FloatArray.get?", "code": "def get? (ds : FloatArray) (i : Nat) : Option Float :=\n  if h : i < ds.size then\n    ds.get \u27e8i, h\u27e9\n  else\n    none", "start": [52, 1], "end": [56, 9], "kind": "commanddeclaration"}, {"full_name": "FloatArray.uset", "code": "@[extern \"lean_float_array_uset\"]\ndef uset : (a : FloatArray) \u2192 (i : USize) \u2192 Float \u2192 i.toNat < a.size \u2192 FloatArray\n  | \u27e8ds\u27e9, i, v, h => \u27e8ds.uset i v h\u27e9", "start": [64, 1], "end": [66, 37], "kind": "commanddeclaration"}, {"full_name": "FloatArray.set", "code": "@[extern \"lean_float_array_fset\"]\ndef set : (ds : FloatArray) \u2192 (@& Fin ds.size) \u2192 Float \u2192 FloatArray\n  | \u27e8ds\u27e9, i, d => \u27e8ds.set i d\u27e9", "start": [68, 1], "end": [70, 31], "kind": "commanddeclaration"}, {"full_name": "FloatArray.set!", "code": "@[extern \"lean_float_array_set\"]\ndef set! : FloatArray \u2192 (@& Nat) \u2192 Float \u2192 FloatArray\n  | \u27e8ds\u27e9, i, d => \u27e8ds.set! i d\u27e9", "start": [72, 1], "end": [74, 32], "kind": "commanddeclaration"}, {"full_name": "FloatArray.isEmpty", "code": "def isEmpty (s : FloatArray) : Bool :=\n  s.size == 0", "start": [76, 1], "end": [77, 14], "kind": "commanddeclaration"}, {"full_name": "FloatArray.toList", "code": "partial def toList (ds : FloatArray) : List Float :=\n  let rec loop (i r) :=\n    if h : i < ds.size then\n      loop (i+1) (ds.get \u27e8i, h\u27e9 :: r)\n    else\n      r.reverse\n  loop 0 []", "start": [79, 1], "end": [85, 12], "kind": "commanddeclaration"}, {"full_name": "FloatArray.forInUnsafe", "code": "@[inline] unsafe def forInUnsafe {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : FloatArray) (b : \u03b2) (f : Float \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let sz := USize.ofNat as.size\n  let rec @[specialize] loop (i : USize) (b : \u03b2) : m \u03b2 := do\n    if i < sz then\n      let a := as.uget i lcProof\n      match (\u2190 f a b) with\n      | ForInStep.done  b => pure b\n      | ForInStep.yield b => loop (i+1) b\n    else\n      pure b\n  loop 0 b", "start": [87, 1], "end": [102, 11], "kind": "commanddeclaration"}, {"full_name": "FloatArray.forIn", "code": "@[implemented_by FloatArray.forInUnsafe]\nprotected def forIn {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (as : FloatArray) (b : \u03b2) (f : Float \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 :=\n  let rec loop (i : Nat) (h : i \u2264 as.size) (b : \u03b2) : m \u03b2 := do\n    match i, h with\n    | 0,   _ => pure b\n    | i+1, h =>\n      have h' : i < as.size            := Nat.lt_of_lt_of_le (Nat.lt_succ_self i) h\n      have : as.size - 1 < as.size     := Nat.sub_lt (Nat.zero_lt_of_lt h') (by decide)\n      have : as.size - 1 - i < as.size := Nat.lt_of_le_of_lt (Nat.sub_le (as.size - 1) i) this\n      match (\u2190 f (as.get \u27e8as.size - 1 - i, this\u27e9) b) with\n      | ForInStep.done b  => pure b\n      | ForInStep.yield b => loop i (Nat.le_of_lt h') b\n  loop as.size (Nat.le_refl _) b", "start": [104, 1], "end": [117, 33], "kind": "commanddeclaration"}, {"full_name": "FloatArray.foldlMUnsafe", "code": "@[inline]\nunsafe def foldlMUnsafe {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b2 \u2192 Float \u2192 m \u03b2) (init : \u03b2) (as : FloatArray) (start := 0) (stop := as.size) : m \u03b2 :=\n  let rec @[specialize] fold (i : USize) (stop : USize) (b : \u03b2) : m \u03b2 := do\n    if i == stop then\n      pure b\n    else\n      fold (i+1) stop (\u2190 f b (as.uget i lcProof))\n  if start < stop then\n    if stop \u2264 as.size then\n      fold (USize.ofNat start) (USize.ofNat stop) init\n    else\n      pure init\n  else\n    pure init", "start": [122, 1], "end": [137, 14], "kind": "commanddeclaration"}, {"full_name": "FloatArray.foldlM", "code": "@[implemented_by foldlMUnsafe]\ndef foldlM {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] (f : \u03b2 \u2192 Float \u2192 m \u03b2) (init : \u03b2) (as : FloatArray) (start := 0) (stop := as.size) : m \u03b2 :=\n  let fold (stop : Nat) (h : stop \u2264 as.size) :=\n    let rec loop (i : Nat) (j : Nat) (b : \u03b2) : m \u03b2 := do\n      if hlt : j < stop then\n        match i with\n        | 0    => pure b\n        | i'+1 =>\n          loop i' (j+1) (\u2190 f b (as.get \u27e8j, Nat.lt_of_lt_of_le hlt h\u27e9))\n      else\n        pure b\n    loop (stop - start) start init\n  if h : stop \u2264 as.size then\n    fold stop h\n  else\n    fold as.size (Nat.le_refl _)", "start": [139, 1], "end": [155, 33], "kind": "commanddeclaration"}, {"full_name": "FloatArray.foldl", "code": "@[inline]\ndef foldl {\u03b2 : Type v} (f : \u03b2 \u2192 Float \u2192 \u03b2) (init : \u03b2) (as : FloatArray) (start := 0) (stop := as.size) : \u03b2 :=\n  Id.run <| as.foldlM f init start stop", "start": [157, 1], "end": [159, 40], "kind": "commanddeclaration"}, {"full_name": "List.toFloatArray", "code": "def List.toFloatArray (ds : List Float) : FloatArray :=\n  let rec loop\n    | [],    r => r\n    | b::ds, r => loop ds (r.push b)\n  loop ds FloatArray.empty", "start": [163, 1], "end": [167, 27], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Option/Instances.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Option/Basic.lean"], "premises": [{"full_name": "Option.eq_of_eq_some", "code": "theorem Option.eq_of_eq_some {\u03b1 : Type u} : \u2200 {x y : Option \u03b1}, (\u2200z, x = some z \u2194 y = some z) \u2192 x = y", "start": [11, 1], "end": [15, 74], "kind": "commanddeclaration"}, {"full_name": "Option.eq_none_of_isNone", "code": "theorem Option.eq_none_of_isNone {\u03b1 : Type u} : \u2200 {o : Option \u03b1}, o.isNone \u2192 o = none", "start": [17, 1], "end": [18, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/UInt.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/UInt/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/UInt/Log2.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Format/Syntax.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Format/Instances.lean", "lake-packages/lean4/src/lean/Init/Data/Format/Macro.lean", "lake-packages/lean4/src/lean/Init/Meta.lean"], "premises": [{"full_name": "Lean.Syntax.formatInfo", "code": "private def formatInfo (showInfo : Bool) (info : SourceInfo) (f : Format) : Format :=\n  match showInfo, info with\n  | true, SourceInfo.original lead pos trail endPos => f!\"{repr lead.toString}:{pos}:{f}:{endPos}:{repr trail.toString}\"\n  | true, SourceInfo.synthetic pos endPos true      => f!\"{pos}!:{f}:{endPos}\"\n  | true, SourceInfo.synthetic pos endPos false     => f!\"{pos}:{f}:{endPos}\"\n  | _,    _                                         => f", "start": [16, 1], "end": [21, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.formatStxAux", "code": "partial def formatStxAux (maxDepth : Option Nat) (showInfo : Bool) : Nat \u2192 Syntax \u2192 Format\n  | _,     atom info val     => formatInfo showInfo info $ format (repr val)\n  | _,     ident info _ val _   => formatInfo showInfo info $ format \"`\" ++ format val\n  | _,     missing           => \"<missing>\"\n  | depth, node _ kind args  =>\n    let depth := depth + 1;\n    if kind == nullKind then\n      sbracket $\n        if args.size > 0 && depth > maxDepth.getD depth then\n          \"..\"\n        else\n          joinSep (args.toList.map (formatStxAux maxDepth showInfo depth)) line\n    else\n      let shorterName := kind.replacePrefix `Lean.Parser Name.anonymous;\n      let header      := format shorterName;\n      let body : List Format :=\n        if args.size > 0 && depth > maxDepth.getD depth then [\"..\"] else args.toList.map (formatStxAux maxDepth showInfo depth);\n      paren $ joinSep (header :: body) line", "start": [23, 1], "end": [40, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.formatStx", "code": "def formatStx (stx : Syntax) (maxDepth : Option Nat := none) (showInfo := false) : Format :=\n  formatStxAux maxDepth showInfo 0 stx", "start": [42, 1], "end": [46, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Nat.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Control.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Bitwise.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Log2.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/SOM.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Div.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Power2.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Gcd.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/System/Mutex.lean", "imports": ["lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Init/Control/StateRef.lean"], "premises": [{"full_name": "IO.BaseMutexImpl", "code": "private opaque BaseMutexImpl : NonemptyType.{0}", "start": [12, 1], "end": [12, 48], "kind": "commanddeclaration"}, {"full_name": "IO.BaseMutex", "code": "def BaseMutex : Type := BaseMutexImpl.type", "start": [14, 1], "end": [19, 43], "kind": "commanddeclaration"}, {"full_name": "IO.BaseMutex.new", "code": "@[extern \"lean_io_basemutex_new\"]\nopaque BaseMutex.new : BaseIO BaseMutex", "start": [23, 1], "end": [25, 40], "kind": "commanddeclaration"}, {"full_name": "IO.BaseMutex.lock", "code": "@[extern \"lean_io_basemutex_lock\"]\nopaque BaseMutex.lock (mutex : @& BaseMutex) : BaseIO Unit", "start": [27, 1], "end": [34, 59], "kind": "commanddeclaration"}, {"full_name": "IO.BaseMutex.unlock", "code": "@[extern \"lean_io_basemutex_unlock\"]\nopaque BaseMutex.unlock (mutex : @& BaseMutex) : BaseIO Unit", "start": [36, 1], "end": [43, 61], "kind": "commanddeclaration"}, {"full_name": "IO.CondvarImpl", "code": "private opaque CondvarImpl : NonemptyType.{0}", "start": [45, 1], "end": [45, 46], "kind": "commanddeclaration"}, {"full_name": "IO.Condvar", "code": "def Condvar : Type := CondvarImpl.type", "start": [47, 1], "end": [48, 39], "kind": "commanddeclaration"}, {"full_name": "IO.Condvar.new", "code": "@[extern \"lean_io_condvar_new\"]\nopaque Condvar.new : BaseIO Condvar", "start": [52, 1], "end": [54, 36], "kind": "commanddeclaration"}, {"full_name": "IO.Condvar.wait", "code": "@[extern \"lean_io_condvar_wait\"]\nopaque Condvar.wait (condvar : @& Condvar) (mutex : @& BaseMutex) : BaseIO Unit", "start": [56, 1], "end": [58, 80], "kind": "commanddeclaration"}, {"full_name": "IO.Condvar.notifyOne", "code": "@[extern \"lean_io_condvar_notify_one\"]\nopaque Condvar.notifyOne (condvar : @& Condvar) : BaseIO Unit", "start": [60, 1], "end": [62, 62], "kind": "commanddeclaration"}, {"full_name": "IO.Condvar.notifyAll", "code": "@[extern \"lean_io_condvar_notify_all\"]\nopaque Condvar.notifyAll (condvar : @& Condvar) : BaseIO Unit", "start": [64, 1], "end": [66, 62], "kind": "commanddeclaration"}, {"full_name": "IO.Condvar.waitUntil", "code": "def Condvar.waitUntil [Monad m] [MonadLift BaseIO m]\n    (condvar : Condvar) (mutex : BaseMutex) (pred : m Bool) : m Unit := do\n  while !(\u2190 pred) do\n    condvar.wait mutex", "start": [68, 1], "end": [72, 23], "kind": "commanddeclaration"}, {"full_name": "IO.Mutex", "code": "structure Mutex (\u03b1 : Type) where private mk ::\n  private ref : IO.Ref \u03b1\n  mutex : BaseMutex\n  deriving Nonempty", "start": [74, 1], "end": [84, 20], "kind": "commanddeclaration"}, {"full_name": "IO.Mutex.new", "code": "def Mutex.new (a : \u03b1) : BaseIO (Mutex \u03b1) :=\n  return { ref := \u2190 mkRef a, mutex := \u2190 BaseMutex.new }", "start": [88, 1], "end": [90, 56], "kind": "commanddeclaration"}, {"full_name": "IO.AtomicT", "code": "abbrev AtomicT := StateRefT' IO.RealWorld", "start": [92, 1], "end": [97, 42], "kind": "commanddeclaration"}, {"full_name": "IO.Mutex.atomically", "code": "def Mutex.atomically [Monad m] [MonadLiftT BaseIO m] [MonadFinally m]\n    (mutex : Mutex \u03b1) (k : AtomicT \u03b1 m \u03b2) : m \u03b2 := do\n  try\n    mutex.mutex.lock\n    k mutex.ref\n  finally\n    mutex.mutex.unlock", "start": [99, 1], "end": [106, 23], "kind": "commanddeclaration"}, {"full_name": "IO.Mutex.atomicallyOnce", "code": "def Mutex.atomicallyOnce [Monad m] [MonadLiftT BaseIO m] [MonadFinally m]\n    (mutex : Mutex \u03b1) (condvar : Condvar)\n    (pred : AtomicT \u03b1 m Bool) (k : AtomicT \u03b1 m \u03b2) : m \u03b2 :=\n  let _ : MonadLift BaseIO (AtomicT \u03b1 m) := \u27e8liftM\u27e9\n  mutex.atomically do\n    condvar.waitUntil mutex pred\n    k", "start": [108, 1], "end": [119, 6], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/System/Promise.lean", "imports": ["lake-packages/lean4/src/lean/Init/System/IO.lean"], "premises": [{"full_name": "IO.PromiseImpl", "code": "private opaque PromiseImpl (\u03b1 : Type) : { P : Type // Nonempty \u03b1 \u2194 Nonempty P } :=\n  \u27e8Task \u03b1, fun \u27e8_\u27e9 => \u27e8\u27e8\u2039_\u203a\u27e9\u27e9, fun \u27e8\u27e8_\u27e9\u27e9 => \u27e8\u2039_\u203a\u27e9\u27e9", "start": [11, 1], "end": [13, 51], "kind": "commanddeclaration"}, {"full_name": "IO.Promise", "code": "def Promise (\u03b1 : Type) : Type := (PromiseImpl \u03b1).1", "start": [15, 1], "end": [29, 51], "kind": "commanddeclaration"}, {"full_name": "IO.Promise.new", "code": "@[extern \"lean_io_promise_new\"]\nopaque Promise.new [Nonempty \u03b1] : BaseIO (Promise \u03b1)", "start": [34, 1], "end": [36, 53], "kind": "commanddeclaration"}, {"full_name": "IO.Promise.resolve", "code": "@[extern \"lean_io_promise_resolve\"]\nopaque Promise.resolve (value : \u03b1) (promise : @& Promise \u03b1) : BaseIO Unit", "start": [38, 1], "end": [44, 74], "kind": "commanddeclaration"}, {"full_name": "IO.Promise.resultImpl", "code": "private unsafe def Promise.resultImpl (promise : Promise \u03b1) : Task \u03b1 :=\n  unsafeCast promise", "start": [46, 1], "end": [47, 21], "kind": "commanddeclaration"}, {"full_name": "IO.Promise.result", "code": "@[implemented_by Promise.resultImpl]\nopaque Promise.result (promise : Promise \u03b1) : Task \u03b1 :=\n  have : Nonempty \u03b1 := (PromiseImpl \u03b1).2.2 \u27e8promise\u27e9\n  Classical.choice inferInstance", "start": [49, 1], "end": [57, 33], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Queue.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/List.lean"], "premises": [{"full_name": "Std.Queue", "code": "structure Queue (\u03b1 : Type u) where\n  \n  eList : List \u03b1 := []\n  \n  dList : List \u03b1 := []", "start": [14, 1], "end": [25, 23], "kind": "commanddeclaration"}, {"full_name": "Std.Queue.empty", "code": "def empty : Queue \u03b1 := {}", "start": [31, 1], "end": [32, 26], "kind": "commanddeclaration"}, {"full_name": "Std.Queue.isEmpty", "code": "def isEmpty (q : Queue \u03b1) : Bool :=\n  q.dList.isEmpty && q.eList.isEmpty", "start": [37, 1], "end": [39, 37], "kind": "commanddeclaration"}, {"full_name": "Std.Queue.enqueue", "code": "def enqueue (v : \u03b1) (q : Queue \u03b1) : Queue \u03b1 :=\n  { q with eList := v::q.eList }", "start": [41, 1], "end": [43, 33], "kind": "commanddeclaration"}, {"full_name": "Std.Queue.enqueueAll", "code": "def enqueueAll (vs : List \u03b1) (q : Queue \u03b1) : Queue \u03b1 :=\n  { q with eList := vs ++ q.eList }", "start": [45, 1], "end": [47, 36], "kind": "commanddeclaration"}, {"full_name": "Std.Queue.dequeue?", "code": "def dequeue? (q : Queue \u03b1) : Option (\u03b1 \u00d7 Queue \u03b1) :=\n  match q.dList with\n  | d::ds => some (d, { q with dList := ds })\n  | []    =>\n    match q.eList.reverse with\n    | []    => none\n    | d::ds => some (d, { eList := [], dList := ds })", "start": [49, 1], "end": [59, 54], "kind": "commanddeclaration"}, {"full_name": "Std.Queue.toArray", "code": "def toArray (q : Queue \u03b1) : Array \u03b1 :=\n  q.dList.toArray ++ q.eList.toArray.reverse", "start": [61, 1], "end": [62, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/Except.lean", "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "lake-packages/lean4/src/lean/Init/Control/StateRef.lean"], "premises": [{"full_name": "monadLift_self", "code": "@[simp] theorem monadLift_self [Monad m] (x : m \u03b1) : monadLift x = x", "start": [13, 1], "end": [14, 6], "kind": "commanddeclaration"}, {"full_name": "LawfulFunctor", "code": "class LawfulFunctor (f : Type u \u2192 Type v) [Functor f] : Prop where\n  map_const          : (Functor.mapConst : \u03b1 \u2192 f \u03b2 \u2192 f \u03b1) = Functor.map \u2218 const \u03b2\n  id_map   (x : f \u03b1) : id <$> x = x\n  comp_map (g : \u03b1 \u2192 \u03b2) (h : \u03b2 \u2192 \u03b3) (x : f \u03b1) : (h \u2218 g) <$> x = h <$> g <$> x", "start": [16, 1], "end": [19, 77], "kind": "commanddeclaration"}, {"full_name": "id_map'", "code": "@[simp] theorem id_map' [Functor m] [LawfulFunctor m] (x : m \u03b1) : (fun a => a) <$> x = x", "start": [25, 1], "end": [26, 11], "kind": "commanddeclaration"}, {"full_name": "LawfulApplicative", "code": "class LawfulApplicative (f : Type u \u2192 Type v) [Applicative f] extends LawfulFunctor f : Prop where\n  seqLeft_eq  (x : f \u03b1) (y : f \u03b2)     : x <* y = const \u03b2 <$> x <*> y\n  seqRight_eq (x : f \u03b1) (y : f \u03b2)     : x *> y = const \u03b1 id <$> x <*> y\n  pure_seq    (g : \u03b1 \u2192 \u03b2) (x : f \u03b1)   : pure g <*> x = g <$> x\n  map_pure    (g : \u03b1 \u2192 \u03b2) (x : \u03b1)     : g <$> (pure x : f \u03b1) = pure (g x)\n  seq_pure    {\u03b1 \u03b2 : Type u} (g : f (\u03b1 \u2192 \u03b2)) (x : \u03b1) : g <*> pure x = (fun h => h x) <$> g\n  seq_assoc   {\u03b1 \u03b2 \u03b3 : Type u} (x : f \u03b1) (g : f (\u03b1 \u2192 \u03b2)) (h : f (\u03b2 \u2192 \u03b3)) : h <*> (g <*> x) = ((@comp \u03b1 \u03b2 \u03b3) <$> h) <*> g <*> x\n  comp_map g h x := (by\n    repeat rw [\u2190 pure_seq]\n    simp [seq_assoc, map_pure, seq_pure])", "start": [28, 1], "end": [37, 42], "kind": "commanddeclaration"}, {"full_name": "pure_id_seq", "code": "@[simp] theorem pure_id_seq [Applicative f] [LawfulApplicative f] (x : f \u03b1) : pure id <*> x = x", "start": [43, 1], "end": [44, 18], "kind": "commanddeclaration"}, {"full_name": "LawfulMonad", "code": "class LawfulMonad (m : Type u \u2192 Type v) [Monad m] extends LawfulApplicative m : Prop where\n  bind_pure_comp (f : \u03b1 \u2192 \u03b2) (x : m \u03b1) : x >>= (fun a => pure (f a)) = f <$> x\n  bind_map       {\u03b1 \u03b2 : Type u} (f : m (\u03b1 \u2192 \u03b2)) (x : m \u03b1) : f >>= (. <$> x) = f <*> x\n  pure_bind      (x : \u03b1) (f : \u03b1 \u2192 m \u03b2) : pure x >>= f = f x\n  bind_assoc     (x : m \u03b1) (f : \u03b1 \u2192 m \u03b2) (g : \u03b2 \u2192 m \u03b3) : x >>= f >>= g = x >>= fun x => f x >>= g\n  map_pure g x    := (by rw [\u2190 bind_pure_comp, pure_bind])\n  seq_pure g x    := (by rw [\u2190 bind_map]; simp [map_pure, bind_pure_comp])\n  seq_assoc x g h := (by simp [\u2190 bind_pure_comp, \u2190 bind_map, bind_assoc, pure_bind])", "start": [46, 1], "end": [53, 85], "kind": "commanddeclaration"}, {"full_name": "bind_pure", "code": "@[simp] theorem bind_pure [Monad m] [LawfulMonad m] (x : m \u03b1) : x >>= pure = x", "start": [58, 1], "end": [60, 30], "kind": "commanddeclaration"}, {"full_name": "map_eq_pure_bind", "code": "theorem map_eq_pure_bind [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 \u03b2) (x : m \u03b1) : f <$> x = x >>= fun a => pure (f a)", "start": [62, 1], "end": [63, 24], "kind": "commanddeclaration"}, {"full_name": "seq_eq_bind_map", "code": "theorem seq_eq_bind_map {\u03b1 \u03b2 : Type u} [Monad m] [LawfulMonad m] (f : m (\u03b1 \u2192 \u03b2)) (x : m \u03b1) : f <*> x = f >>= (. <$> x)", "start": [65, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "bind_congr", "code": "theorem bind_congr [Bind m] {x : m \u03b1} {f g : \u03b1 \u2192 m \u03b2} (h : \u2200 a, f a = g a) : x >>= f = x >>= g", "start": [68, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "bind_pure_unit", "code": "@[simp] theorem bind_pure_unit [Monad m] [LawfulMonad m] {x : m PUnit} : (x >>= fun _ => pure \u27e8\u27e9) = x", "start": [71, 1], "end": [72, 17], "kind": "commanddeclaration"}, {"full_name": "map_congr", "code": "theorem map_congr [Functor m] {x : m \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : \u2200 a, f a = g a) : (f <$> x : m \u03b2) = g <$> x", "start": [74, 1], "end": [75, 18], "kind": "commanddeclaration"}, {"full_name": "seq_eq_bind", "code": "theorem seq_eq_bind {\u03b1 \u03b2 : Type u} [Monad m] [LawfulMonad m] (mf : m (\u03b1 \u2192 \u03b2)) (x : m \u03b1) : mf <*> x = mf >>= fun f => f <$> x", "start": [77, 1], "end": [78, 16], "kind": "commanddeclaration"}, {"full_name": "seqRight_eq_bind", "code": "theorem seqRight_eq_bind [Monad m] [LawfulMonad m] (x : m \u03b1) (y : m \u03b2) : x *> y = x >>= fun _ => y", "start": [80, 1], "end": [82, 50], "kind": "commanddeclaration"}, {"full_name": "seqLeft_eq_bind", "code": "theorem seqLeft_eq_bind [Monad m] [LawfulMonad m] (x : m \u03b1) (y : m \u03b2) : x <* y = x >>= fun a => y >>= fun _ => pure a", "start": [84, 1], "end": [85, 60], "kind": "commanddeclaration"}, {"full_name": "Id.map_eq", "code": "@[simp] theorem map_eq (x : Id \u03b1) (f : \u03b1 \u2192 \u03b2) : f <$> x = f x", "start": [91, 1], "end": [91, 69], "kind": "commanddeclaration"}, {"full_name": "Id.bind_eq", "code": "@[simp] theorem bind_eq (x : Id \u03b1) (f : \u03b1 \u2192 id \u03b2) : x >>= f = f x", "start": [92, 1], "end": [92, 73], "kind": "commanddeclaration"}, {"full_name": "Id.pure_eq", "code": "@[simp] theorem pure_eq (a : \u03b1) : (pure a : Id \u03b1) = a", "start": [93, 1], "end": [93, 61], "kind": "commanddeclaration"}, {"full_name": "ExceptT.ext", "code": "theorem ext [Monad m] {x y : ExceptT \u03b5 m \u03b1} (h : x.run = y.run) : x = y", "start": [104, 1], "end": [106, 13], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run_pure", "code": "@[simp] theorem run_pure [Monad m] (x : \u03b1) : run (pure x : ExceptT \u03b5 m \u03b1) = pure (Except.ok x)", "start": [108, 1], "end": [108, 102], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run_lift", "code": "@[simp] theorem run_lift  [Monad.{u, v} m] (x : m \u03b1) : run (ExceptT.lift x : ExceptT \u03b5 m \u03b1) = (Except.ok <$> x : m (Except \u03b5 \u03b1))", "start": [110, 1], "end": [110, 136], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run_throw", "code": "@[simp] theorem run_throw [Monad m] : run (throw e : ExceptT \u03b5 m \u03b2) = pure (Except.error e)", "start": [112, 1], "end": [112, 99], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run_bind_lift", "code": "@[simp] theorem run_bind_lift [Monad m] [LawfulMonad m] (x : m \u03b1) (f : \u03b1 \u2192 ExceptT \u03b5 m \u03b2) : run (ExceptT.lift x >>= f : ExceptT \u03b5 m \u03b2) = x >>= fun a => run (f a)", "start": [114, 1], "end": [115, 102], "kind": "commanddeclaration"}, {"full_name": "ExceptT.bind_throw", "code": "@[simp] theorem bind_throw [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 ExceptT \u03b5 m \u03b2) : (throw e >>= f) = throw e", "start": [117, 1], "end": [118, 96], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run_bind", "code": "theorem run_bind [Monad m] (x : ExceptT \u03b5 m \u03b1)\n        : run (x >>= f : ExceptT \u03b5 m \u03b2)\n          =\n          run x >>= fun\n                     | Except.ok x => run (f x)\n                     | Except.error e => pure (Except.error e)", "start": [120, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "ExceptT.lift_pure", "code": "@[simp] theorem lift_pure [Monad m] [LawfulMonad m] (a : \u03b1) : ExceptT.lift (pure a) = (pure a : ExceptT \u03b5 m \u03b1)", "start": [128, 1], "end": [129, 42], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run_map", "code": "@[simp] theorem run_map [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 \u03b2) (x : ExceptT \u03b5 m \u03b1)\n    : (f <$> x).run = Except.map f <$> x.run", "start": [131, 1], "end": [135, 41], "kind": "commanddeclaration"}, {"full_name": "ExceptT.seq_eq", "code": "protected theorem seq_eq {\u03b1 \u03b2 \u03b5 : Type u} [Monad m] (mf : ExceptT \u03b5 m (\u03b1 \u2192 \u03b2)) (x : ExceptT \u03b5 m \u03b1) : mf <*> x = mf >>= fun f => f <$> x", "start": [137, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "ExceptT.bind_pure_comp", "code": "protected theorem bind_pure_comp [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 \u03b2) (x : ExceptT \u03b5 m \u03b1) : x >>= pure \u2218 f = f <$> x", "start": [140, 1], "end": [141, 14], "kind": "commanddeclaration"}, {"full_name": "ExceptT.seqLeft_eq", "code": "protected theorem seqLeft_eq {\u03b1 \u03b2 \u03b5 : Type u} {m : Type u \u2192 Type v} [Monad m] [LawfulMonad m] (x : ExceptT \u03b5 m \u03b1) (y : ExceptT \u03b5 m \u03b2) : x <* y = const \u03b2 <$> x <*> y", "start": [143, 1], "end": [153, 47], "kind": "commanddeclaration"}, {"full_name": "ExceptT.seqRight_eq", "code": "protected theorem seqRight_eq [Monad m] [LawfulMonad m] (x : ExceptT \u03b5 m \u03b1) (y : ExceptT \u03b5 m \u03b2) : x *> y = const \u03b1 id <$> x <*> y", "start": [155, 1], "end": [161, 28], "kind": "commanddeclaration"}, {"full_name": "ReaderT.ext", "code": "theorem ext {x y : ReaderT \u03c1 m \u03b1} (h : \u2200 ctx, x.run ctx = y.run ctx) : x = y", "start": [180, 1], "end": [182, 17], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_pure", "code": "@[simp] theorem run_pure [Monad m] (a : \u03b1) (ctx : \u03c1) : (pure a : ReaderT \u03c1 m \u03b1).run ctx = pure a", "start": [184, 1], "end": [184, 104], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_bind", "code": "@[simp] theorem run_bind [Monad m] (x : ReaderT \u03c1 m \u03b1) (f : \u03b1 \u2192 ReaderT \u03c1 m \u03b2) (ctx : \u03c1)\n    : (x >>= f).run ctx = x.run ctx >>= \u03bb a => (f a).run ctx", "start": [186, 1], "end": [187, 68], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_mapConst", "code": "@[simp] theorem run_mapConst [Monad m] (a : \u03b1) (x : ReaderT \u03c1 m \u03b2) (ctx : \u03c1)\n    : (Functor.mapConst a x).run ctx = Functor.mapConst a (x.run ctx)", "start": [189, 1], "end": [190, 77], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_map", "code": "@[simp] theorem run_map [Monad m] (f : \u03b1 \u2192 \u03b2) (x : ReaderT \u03c1 m \u03b1) (ctx : \u03c1)\n    : (f <$> x).run ctx = f <$> x.run ctx", "start": [192, 1], "end": [193, 49], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_monadLift", "code": "@[simp] theorem run_monadLift [MonadLiftT n m] (x : n \u03b1) (ctx : \u03c1)\n    : (monadLift x : ReaderT \u03c1 m \u03b1).run ctx = (monadLift x : m \u03b1)", "start": [195, 1], "end": [196, 73], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_monadMap", "code": "@[simp] theorem run_monadMap [MonadFunctor n m] (f : {\u03b2 : Type u} \u2192 n \u03b2 \u2192 n \u03b2) (x : ReaderT \u03c1 m \u03b1) (ctx : \u03c1)\n    : (monadMap @f x : ReaderT \u03c1 m \u03b1).run ctx = monadMap @f (x.run ctx)", "start": [198, 1], "end": [199, 79], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_read", "code": "@[simp] theorem run_read [Monad m] (ctx : \u03c1) : (ReaderT.read : ReaderT \u03c1 m \u03c1).run ctx = pure ctx", "start": [201, 1], "end": [201, 104], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_seq", "code": "@[simp] theorem run_seq {\u03b1 \u03b2 : Type u} [Monad m] (f : ReaderT \u03c1 m (\u03b1 \u2192 \u03b2)) (x : ReaderT \u03c1 m \u03b1) (ctx : \u03c1)\n    : (f <*> x).run ctx = (f.run ctx <*> x.run ctx)", "start": [203, 1], "end": [204, 59], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_seqRight", "code": "@[simp] theorem run_seqRight [Monad m] (x : ReaderT \u03c1 m \u03b1) (y : ReaderT \u03c1 m \u03b2) (ctx : \u03c1)\n    : (x *> y).run ctx = (x.run ctx *> y.run ctx)", "start": [206, 1], "end": [207, 57], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_seqLeft", "code": "@[simp] theorem run_seqLeft [Monad m] (x : ReaderT \u03c1 m \u03b1) (y : ReaderT \u03c1 m \u03b2) (ctx : \u03c1)\n    : (x <* y).run ctx = (x.run ctx <* y.run ctx)", "start": [209, 1], "end": [210, 57], "kind": "commanddeclaration"}, {"full_name": "StateT.ext", "code": "theorem ext {x y : StateT \u03c3 m \u03b1} (h : \u2200 s, x.run s = y.run s) : x = y", "start": [242, 1], "end": [243, 11], "kind": "commanddeclaration"}, {"full_name": "StateT.run'_eq", "code": "@[simp] theorem run'_eq [Monad m] (x : StateT \u03c3 m \u03b1) (s : \u03c3) : run' x s = (\u00b7.1) <$> run x s", "start": [245, 1], "end": [246, 6], "kind": "commanddeclaration"}, {"full_name": "StateT.run_pure", "code": "@[simp] theorem run_pure [Monad m] (a : \u03b1) (s : \u03c3) : (pure a : StateT \u03c3 m \u03b1).run s = pure (a, s)", "start": [248, 1], "end": [248, 104], "kind": "commanddeclaration"}, {"full_name": "StateT.run_bind", "code": "@[simp] theorem run_bind [Monad m] (x : StateT \u03c3 m \u03b1) (f : \u03b1 \u2192 StateT \u03c3 m \u03b2) (s : \u03c3)\n    : (x >>= f).run s = x.run s >>= \u03bb p => (f p.1).run p.2", "start": [250, 1], "end": [252, 32], "kind": "commanddeclaration"}, {"full_name": "StateT.run_map", "code": "@[simp] theorem run_map {\u03b1 \u03b2 \u03c3 : Type u} [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 \u03b2) (x : StateT \u03c3 m \u03b1) (s : \u03c3) : (f <$> x).run s = (fun (p : \u03b1 \u00d7 \u03c3) => (f p.1, p.2)) <$> x.run s", "start": [254, 1], "end": [255, 56], "kind": "commanddeclaration"}, {"full_name": "StateT.run_get", "code": "@[simp] theorem run_get [Monad m] (s : \u03c3)    : (get : StateT \u03c3 m \u03c3).run s = pure (s, s)", "start": [257, 1], "end": [257, 95], "kind": "commanddeclaration"}, {"full_name": "StateT.run_set", "code": "@[simp] theorem run_set [Monad m] (s s' : \u03c3) : (set s' : StateT \u03c3 m PUnit).run s = pure (\u27e8\u27e9, s')", "start": [259, 1], "end": [259, 104], "kind": "commanddeclaration"}, {"full_name": "StateT.run_modify", "code": "@[simp] theorem run_modify [Monad m] (f : \u03c3 \u2192 \u03c3) (s : \u03c3) : (modify f : StateT \u03c3 m PUnit).run s = pure (\u27e8\u27e9, f s)", "start": [261, 1], "end": [261, 119], "kind": "commanddeclaration"}, {"full_name": "StateT.run_modifyGet", "code": "@[simp] theorem run_modifyGet [Monad m] (f : \u03c3 \u2192 \u03b1 \u00d7 \u03c3) (s : \u03c3) : (modifyGet f : StateT \u03c3 m \u03b1).run s = pure ((f s).1, (f s).2)", "start": [263, 1], "end": [264, 66], "kind": "commanddeclaration"}, {"full_name": "StateT.run_lift", "code": "@[simp] theorem run_lift {\u03b1 \u03c3 : Type u} [Monad m] (x : m \u03b1) (s : \u03c3) : (StateT.lift x : StateT \u03c3 m \u03b1).run s = x >>= fun a => pure (a, s)", "start": [266, 1], "end": [266, 143], "kind": "commanddeclaration"}, {"full_name": "StateT.run_bind_lift", "code": "@[simp] theorem run_bind_lift {\u03b1 \u03c3 : Type u} [Monad m] [LawfulMonad m] (x : m \u03b1) (f : \u03b1 \u2192 StateT \u03c3 m \u03b2) (s : \u03c3) : (StateT.lift x >>= f).run s = x >>= fun a => (f a).run s", "start": [268, 1], "end": [269, 52], "kind": "commanddeclaration"}, {"full_name": "StateT.run_monadLift", "code": "@[simp] theorem run_monadLift {\u03b1 \u03c3 : Type u} [Monad m] [MonadLiftT n m] (x : n \u03b1) (s : \u03c3) : (monadLift x : StateT \u03c3 m \u03b1).run s = (monadLift x : m \u03b1) >>= fun a => pure (a, s)", "start": [271, 1], "end": [271, 181], "kind": "commanddeclaration"}, {"full_name": "StateT.run_monadMap", "code": "@[simp] theorem run_monadMap [Monad m] [MonadFunctor n m] (f : {\u03b2 : Type u} \u2192 n \u03b2 \u2192 n \u03b2) (x : StateT \u03c3 m \u03b1) (s : \u03c3)\n    : (monadMap @f x : StateT \u03c3 m \u03b1).run s = monadMap @f (x.run s)", "start": [273, 1], "end": [274, 74], "kind": "commanddeclaration"}, {"full_name": "StateT.run_seq", "code": "@[simp] theorem run_seq {\u03b1 \u03b2 \u03c3 : Type u} [Monad m] [LawfulMonad m] (f : StateT \u03c3 m (\u03b1 \u2192 \u03b2)) (x : StateT \u03c3 m \u03b1) (s : \u03c3) : (f <*> x).run s = (f.run s >>= fun fs => (fun (p : \u03b1 \u00d7 \u03c3) => (fs.1 p.1, p.2)) <$> x.run fs.2)", "start": [276, 1], "end": [278, 7], "kind": "commanddeclaration"}, {"full_name": "StateT.run_seqRight", "code": "@[simp] theorem run_seqRight [Monad m] [LawfulMonad m] (x : StateT \u03c3 m \u03b1) (y : StateT \u03c3 m \u03b2) (s : \u03c3) : (x *> y).run s = (x.run s >>= fun p => y.run p.2)", "start": [280, 1], "end": [282, 7], "kind": "commanddeclaration"}, {"full_name": "StateT.run_seqLeft", "code": "@[simp] theorem run_seqLeft {\u03b1 \u03b2 \u03c3 : Type u} [Monad m] [LawfulMonad m] (x : StateT \u03c3 m \u03b1) (y : StateT \u03c3 m \u03b2) (s : \u03c3) : (x <* y).run s = (x.run s >>= fun p => y.run p.2 >>= fun p' => pure (p.1, p'.2))", "start": [284, 1], "end": [286, 7], "kind": "commanddeclaration"}, {"full_name": "StateT.seqRight_eq", "code": "theorem seqRight_eq [Monad m] [LawfulMonad m] (x : StateT \u03c3 m \u03b1) (y : StateT \u03c3 m \u03b2) : x *> y = const \u03b1 id <$> x <*> y", "start": [288, 1], "end": [292, 18], "kind": "commanddeclaration"}, {"full_name": "StateT.seqLeft_eq", "code": "theorem seqLeft_eq [Monad m] [LawfulMonad m] (x : StateT \u03c3 m \u03b1) (y : StateT \u03c3 m \u03b2) : x <* y = const \u03b2 <$> x <*> y", "start": [294, 1], "end": [296, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/System/Uri.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/String/Extra.lean", "lake-packages/lean4/src/lean/Init/System/FilePath.lean"], "premises": [{"full_name": "System.Uri.UriEscape.zero", "code": "@[inline] def zero : UInt8 := '0'.toNat.toUInt8", "start": [15, 1], "end": [15, 48], "kind": "commanddeclaration"}, {"full_name": "System.Uri.UriEscape.nine", "code": "@[inline] def nine : UInt8 := '9'.toNat.toUInt8", "start": [16, 1], "end": [16, 48], "kind": "commanddeclaration"}, {"full_name": "System.Uri.UriEscape.lettera", "code": "@[inline] def lettera : UInt8 := 'a'.toNat.toUInt8", "start": [17, 1], "end": [17, 51], "kind": "commanddeclaration"}, {"full_name": "System.Uri.UriEscape.letterf", "code": "@[inline] def letterf : UInt8 := 'f'.toNat.toUInt8", "start": [18, 1], "end": [18, 51], "kind": "commanddeclaration"}, {"full_name": "System.Uri.UriEscape.letterA", "code": "@[inline] def letterA : UInt8 := 'A'.toNat.toUInt8", "start": [19, 1], "end": [19, 51], "kind": "commanddeclaration"}, {"full_name": "System.Uri.UriEscape.letterF", "code": "@[inline] def letterF : UInt8 := 'F'.toNat.toUInt8", "start": [20, 1], "end": [20, 51], "kind": "commanddeclaration"}, {"full_name": "System.Uri.UriEscape.decodeUri", "code": "def decodeUri (uri : String) : String := Id.run do\n  let mut decoded : ByteArray := ByteArray.empty\n  let rawBytes := uri.toUTF8\n  let len := rawBytes.size\n  let mut i := 0\n  let percent := '%'.toNat.toUInt8\n  while i < len do\n    let c := rawBytes[i]!\n    (decoded, i) := if c == percent && i + 1 < len then\n      let h1 := rawBytes[i + 1]!\n      if let some hd1 := hexDigitToUInt8? h1 then\n        if i + 2 < len then\n          let h2 := rawBytes[i + 2]!\n          if let some hd2 := hexDigitToUInt8? h2 then\n            (decoded.push (hd1 * 16 + hd2), i + 3)\n          else\n            (((decoded.push c).push h1).push h2, i + 3)\n        else\n          ((decoded.push c).push h1, i + 2)\n      else\n        ((decoded.push c).push h1, i + 2)\n    else\n      (decoded.push c, i + 1)\n  return String.fromUTF8Unchecked decoded\nwhere hexDigitToUInt8? (c : UInt8) : Option UInt8 :=\n  if zero \u2264 c \u2227 c \u2264 nine then some (c - zero)\n  else if lettera \u2264 c \u2227 c \u2264 letterf then some (c - lettera + 10)\n  else if letterA \u2264 c \u2227 c \u2264 letterF then some (c - letterA + 10)\n  else none", "start": [22, 1], "end": [57, 12], "kind": "commanddeclaration"}, {"full_name": "System.Uri.UriEscape.rfc3986ReservedChars", "code": "def rfc3986ReservedChars : List Char := [ ';', ':', '?', '#', '[', ']', '@', '&', '=', '+', '$', ',', '!', '\\'', '(', ')', '*', '%', ' ' ]", "start": [59, 1], "end": [59, 139], "kind": "commanddeclaration"}, {"full_name": "System.Uri.UriEscape.uriEscapeAsciiChar", "code": "def uriEscapeAsciiChar (c : Char) : String :=\n  if rfc3986ReservedChars.contains c || c < ' ' then\n    \"%\" ++ uInt8ToHex c.toNat.toUInt8\n  else if (Char.toNat c) < 127 then\n    c.toString\n  else\n    c.toString.toUTF8.foldl (fun s b => s ++ \"%\" ++ (uInt8ToHex b)) \"\"\nwhere\n  uInt8ToHex (c : UInt8) : String :=\n    let d2 := c / 16;\n    let d1 := c % 16;\n    (hexDigitRepr d2.toNat ++ hexDigitRepr d1.toNat).toUpper", "start": [61, 1], "end": [72, 61], "kind": "commanddeclaration"}, {"full_name": "System.Uri.escapeUri", "code": "def escapeUri (uri: String) : String :=\n  uri.foldl (fun s c => s ++ UriEscape.uriEscapeAsciiChar c) \"\"", "start": [75, 1], "end": [77, 64], "kind": "commanddeclaration"}, {"full_name": "System.Uri.unescapeUri", "code": "def unescapeUri (s: String) : String :=\n  UriEscape.decodeUri s", "start": [79, 1], "end": [84, 24], "kind": "commanddeclaration"}, {"full_name": "System.Uri.pathToUri", "code": "def pathToUri (fname : System.FilePath) : String := Id.run do\n  let mut uri := fname.normalize.toString\n  if System.Platform.isWindows then\n    if uri.length >= 2 && (uri.get 0).isUpper && uri.get \u27e81\u27e9 == ':' then\n      uri := uri.set 0 (uri.get 0).toLower\n    uri := uri.map (fun c => if c == '\\\\' then '/' else c)\n  uri := uri.foldl (fun s c => s ++ UriEscape.uriEscapeAsciiChar c) \"\"\n  let result := if uri.startsWith \"/\" then \"file://\" ++ uri else \"file:///\" ++ uri\n  result", "start": [86, 1], "end": [97, 9], "kind": "commanddeclaration"}, {"full_name": "System.Uri.fileUriToPath?", "code": "def fileUriToPath? (uri : String) : Option System.FilePath := Id.run do\n  if !uri.startsWith \"file://\" then\n    none\n  else\n    let mut p := (unescapeUri uri).drop \"file://\".length\n    p := p.dropWhile (\u03bb c => c != '/') if System.Platform.isWindows && p.length >= 2 &&\n        p.get 0 == '/' && (p.get \u27e81\u27e9).isAlpha && p.get \u27e82\u27e9 == ':' then\n      p := p.drop 1 |>.modify 0 .toUpper\n    some p", "start": [99, 1], "end": [112, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Hashable.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/UInt/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/String.lean"], "premises": [{"full_name": "hash64", "code": "@[always_inline, inline] def hash64 (u : UInt64) : UInt64 :=\n  mixHash u 11", "start": [62, 1], "end": [64, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Fin.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Fin/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Fin/Log2.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Char.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Char/Basic.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Array.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Array/QSort.lean", "lake-packages/lean4/src/lean/Init/Data/Array/BinSearch.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Array/DecidableEq.lean", "lake-packages/lean4/src/lean/Init/Data/Array/InsertionSort.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Mem.lean", "lake-packages/lean4/src/lean/Init/Data/Array/BasicAux.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Stream.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Range.lean", "lake-packages/lean4/src/lean/Init/Data/Array/Subarray.lean"], "premises": [{"full_name": "ToStream", "code": "class ToStream (collection : Type u) (stream : outParam (Type u)) : Type u where\n  toStream : collection \u2192 stream", "start": [25, 1], "end": [44, 33], "kind": "commanddeclaration"}, {"full_name": "Stream", "code": "class Stream (stream : Type u) (value : outParam (Type v)) : Type (max u v) where\n  next? : stream \u2192 Option (value \u00d7 stream)", "start": [48, 1], "end": [49, 43], "kind": "commanddeclaration"}, {"full_name": "Stream.forIn", "code": "protected partial def Stream.forIn [Stream \u03c1 \u03b1] [Monad m] (s : \u03c1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 := do\n  let _ : Inhabited (m \u03b2) := \u27e8pure b\u27e9\n  let rec visit (s : \u03c1) (b : \u03b2) : m \u03b2 := do\n    match Stream.next? s with\n    | some (a, s) => match (\u2190 f a b) with\n      | ForInStep.done b  => return b\n      | ForInStep.yield b => visit s b\n    | none => return b\n  visit s b", "start": [51, 1], "end": [59, 12], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/AC.lean", "imports": ["lake-packages/lean4/src/lean/Init/Classical.lean", "lake-packages/lean4/src/lean/Init/Data/List.lean"], "premises": [{"full_name": "Lean.Data.AC.Expr", "code": "inductive Expr\n  | var (x : Nat)\n  | op (lhs rhs : Expr)\n  deriving Inhabited, Repr, BEq", "start": [12, 1], "end": [15, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Variable", "code": "structure Variable {\u03b1 : Sort u} (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Type u where\n  value : \u03b1\n  neutral : Option $ IsNeutral op value", "start": [17, 1], "end": [19, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context", "code": "structure Context (\u03b1 : Sort u) where\n  op : \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  assoc : IsAssociative op\n  comm : Option $ IsCommutative op\n  idem : Option $ IsIdempotent op\n  vars : List (Variable op)\n  arbitrary : \u03b1", "start": [21, 1], "end": [27, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.ContextInformation", "code": "class ContextInformation (\u03b1 : Sort u) where\n  isNeutral : \u03b1 \u2192 Nat \u2192 Bool\n  isComm : \u03b1 \u2192 Bool\n  isIdem : \u03b1 \u2192 Bool", "start": [29, 1], "end": [32, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.EvalInformation", "code": "class EvalInformation (\u03b1 : Sort u) (\u03b2 : Sort v) where\n  arbitrary : \u03b1 \u2192 \u03b2\n  evalOp : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2\n  evalVar : \u03b1 \u2192 Nat \u2192 \u03b2", "start": [34, 1], "end": [37, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.var", "code": "def Context.var (ctx : Context \u03b1) (idx : Nat) : Variable ctx.op :=\n  ctx.vars.getD idx \u27e8ctx.arbitrary, none\u27e9", "start": [39, 1], "end": [40, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.eval", "code": "def eval (\u03b2 : Sort u) [EvalInformation \u03b1 \u03b2] (ctx : \u03b1) : (ex : Expr) \u2192 \u03b2\n  | Expr.var idx => EvalInformation.evalVar ctx idx\n  | Expr.op l r => EvalInformation.evalOp ctx (eval \u03b2 ctx l) (eval \u03b2 ctx r)", "start": [52, 1], "end": [54, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Expr.toList", "code": "def Expr.toList : Expr \u2192 List Nat\n  | Expr.var idx => [idx]\n  | Expr.op l r => l.toList.append r.toList", "start": [56, 1], "end": [58, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.evalList", "code": "def evalList (\u03b2 : Sort u) [EvalInformation \u03b1 \u03b2] (ctx : \u03b1) : List Nat \u2192 \u03b2\n  | [] => EvalInformation.arbitrary ctx\n  | [x] => EvalInformation.evalVar ctx x\n  | x :: xs => EvalInformation.evalOp ctx (EvalInformation.evalVar ctx x) (evalList \u03b2 ctx xs)", "start": [60, 1], "end": [63, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.insert", "code": "def insert (x : Nat) : List Nat \u2192 List Nat\n  | [] => [x]\n  | a :: as => if x < a then x :: a :: as else a :: insert x as", "start": [65, 1], "end": [67, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.sort", "code": "def sort (xs : List Nat) : List Nat :=\n  let rec loop : List Nat \u2192 List Nat \u2192 List Nat\n    | acc, [] => acc\n    | acc, x :: xs => loop (insert x acc) xs\n  loop [] xs", "start": [69, 1], "end": [73, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.mergeIdem", "code": "def mergeIdem (xs : List Nat) : List Nat :=\n  let rec loop : Nat \u2192 List Nat \u2192 List Nat\n    | curr, next :: rest =>\n      if curr = next then\n        loop curr rest\n      else\n        curr :: loop next rest\n    | curr, [] => [curr]\n\n  match xs with\n  | [] => []\n  | x :: xs => loop x xs", "start": [75, 1], "end": [86, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.removeNeutrals", "code": "def removeNeutrals [info : ContextInformation \u03b1] (ctx : \u03b1) : List Nat \u2192 List Nat\n  | x :: xs =>\n    match loop (x :: xs) with\n    | [] => [x]\n    | ys => ys\n  | [] => []\n  where loop : List Nat \u2192 List Nat\n    | x :: xs =>\n      match info.isNeutral ctx x with\n      | true => loop xs\n      | false => x :: loop xs\n    | [] => []", "start": [88, 1], "end": [99, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.norm", "code": "def norm [info : ContextInformation \u03b1] (ctx : \u03b1) (e : Expr) : List Nat :=\n  let xs := e.toList\n  let xs := removeNeutrals ctx xs\n  let xs := if info.isComm ctx then sort xs else xs\n  if info.isIdem ctx then mergeIdem xs else xs", "start": [101, 1], "end": [105, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.List.two_step_induction", "code": "theorem List.two_step_induction\n  {motive : List Nat \u2192 Sort u}\n  (l : List Nat)\n  (empty : motive [])\n  (single : \u2200 a, motive [a])\n  (step : \u2200 a b l, motive (b :: l) \u2192 motive (a :: b :: l))\n  : motive l", "start": [107, 1], "end": [116, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.mergeIdem_nonEmpty", "code": "theorem Context.mergeIdem_nonEmpty (e : List Nat) (h : e \u2260 []) : mergeIdem e \u2260 []", "start": [118, 1], "end": [122, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.mergeIdem_head", "code": "theorem Context.mergeIdem_head : mergeIdem (x :: x :: xs) = mergeIdem (x :: xs)", "start": [124, 1], "end": [125, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.mergeIdem_head2", "code": "theorem Context.mergeIdem_head2 (h : x \u2260 y) : mergeIdem (x :: y :: ys) = x :: mergeIdem (y :: ys)", "start": [127, 1], "end": [128, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.evalList_mergeIdem", "code": "theorem Context.evalList_mergeIdem (ctx : Context \u03b1) (h : ContextInformation.isIdem ctx) (e : List Nat) : evalList \u03b1 ctx (mergeIdem e) = evalList \u03b1 ctx e", "start": [130, 1], "end": [158, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.insert_nonEmpty", "code": "theorem insert_nonEmpty : insert x xs \u2260 []", "start": [160, 1], "end": [163, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.sort_loop_nonEmpty", "code": "theorem Context.sort_loop_nonEmpty (xs : List Nat) (h : xs \u2260 []) : sort.loop xs ys \u2260 []", "start": [165, 1], "end": [168, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.evalList_insert", "code": "theorem Context.evalList_insert\n  (ctx : Context \u03b1)\n  (h : IsCommutative ctx.op)\n  (x : Nat)\n  (xs : List Nat)\n  : evalList \u03b1 ctx (insert x xs) = evalList \u03b1 ctx (x::xs)", "start": [170, 1], "end": [189, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.evalList_sort_congr", "code": "theorem Context.evalList_sort_congr\n  (ctx : Context \u03b1)\n  (h : IsCommutative ctx.op)\n  (h\u2082 : evalList \u03b1 ctx a = evalList \u03b1 ctx b)\n  (h\u2083 : a \u2260 [])\n  (h\u2084 : b \u2260 [])\n  : evalList \u03b1 ctx (sort.loop a c) = evalList \u03b1 ctx (sort.loop b c)", "start": [191, 1], "end": [208, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.evalList_sort_loop_swap", "code": "theorem Context.evalList_sort_loop_swap\n  (ctx : Context \u03b1)\n  (h : IsCommutative ctx.op)\n  (xs ys : List Nat)\n  : evalList \u03b1 ctx (sort.loop xs (y::ys)) = evalList \u03b1 ctx (sort.loop (y::xs) ys)", "start": [210, 1], "end": [223, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.evalList_sort_cons", "code": "theorem Context.evalList_sort_cons\n  (ctx : Context \u03b1)\n  (h : IsCommutative ctx.op)\n  (x : Nat)\n  (xs : List Nat)\n  : evalList \u03b1 ctx (sort (x :: xs)) = evalList \u03b1 ctx (x :: sort xs)", "start": [225, 1], "end": [247, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.evalList_sort", "code": "theorem Context.evalList_sort (ctx : Context \u03b1) (h : ContextInformation.isComm ctx) (e : List Nat) : evalList \u03b1 ctx (sort e) = evalList \u03b1 ctx e", "start": [249, 1], "end": [258, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.toList_nonEmpty", "code": "theorem Context.toList_nonEmpty (e : Expr) : e.toList \u2260 []", "start": [260, 1], "end": [267, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.unwrap_isNeutral", "code": "theorem Context.unwrap_isNeutral\n  {ctx : Context \u03b1}\n  {x : Nat}\n  : ContextInformation.isNeutral ctx x = true \u2192 IsNeutral (EvalInformation.evalOp ctx) (EvalInformation.evalVar (\u03b2 := \u03b1) ctx x)", "start": [269, 1], "end": [276, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.evalList_removeNeutrals", "code": "theorem Context.evalList_removeNeutrals (ctx : Context \u03b1) (e : List Nat) : evalList \u03b1 ctx (removeNeutrals ctx e) = evalList \u03b1 ctx e", "start": [278, 1], "end": [289, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.evalList_append", "code": "theorem Context.evalList_append\n  (ctx : Context \u03b1)\n  (l r : List Nat)\n  (h\u2081 : l \u2260 [])\n  (h\u2082 : r \u2260 [])\n  : evalList \u03b1 ctx (l.append r) = ctx.op (evalList \u03b1 ctx l) (evalList \u03b1 ctx r)", "start": [291, 1], "end": [303, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.eval_toList", "code": "theorem Context.eval_toList (ctx : Context \u03b1) (e : Expr) : evalList \u03b1 ctx e.toList = eval \u03b1 ctx e", "start": [305, 1], "end": [310, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.eval_norm", "code": "theorem Context.eval_norm (ctx : Context \u03b1) (e : Expr) : evalList \u03b1 ctx (norm ctx e) = eval \u03b1 ctx e", "start": [312, 1], "end": [315, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.AC.Context.eq_of_norm", "code": "theorem Context.eq_of_norm (ctx : Context \u03b1) (a b : Expr) (h : norm ctx a == norm ctx b) : eval \u03b1 ctx a = eval \u03b1 ctx b", "start": [317, 1], "end": [320, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/FloatArray.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/FloatArray/Basic.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Option.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Option/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Option/BasicAux.lean", "lake-packages/lean4/src/lean/Init/Data/Option/Instances.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Fin/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/String/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/String/Extra.lean", "lake-packages/lean4/src/lean/Init/Data/Char/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/ToString/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Option/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/UInt.lean", "lake-packages/lean4/src/lean/Init/Data/Repr.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/Format.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Format/Instances.lean", "lake-packages/lean4/src/lean/Init/Data/Format/Macro.lean", "lake-packages/lean4/src/lean/Init/Data/Format/Syntax.lean", "lake-packages/lean4/src/lean/Init/Data/Format/Basic.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Data/OfScientific.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Float.lean", "lake-packages/lean4/src/lean/Init/Data/Nat.lean", "lake-packages/lean4/src/lean/Init/Meta.lean"], "premises": [{"full_name": "OfScientific", "code": "class OfScientific (\u03b1 : Type u) where\n  ofScientific (mantissa : Nat) (exponentSign : Bool) (decimalExponent : Nat) : \u03b1", "start": [11, 1], "end": [17, 82], "kind": "commanddeclaration"}, {"full_name": "Float.ofBinaryScientific", "code": "def Float.ofBinaryScientific (m : Nat) (e : Int) : Float :=\n  let s := m.log2 - 63\n  let m := (m >>> s).toUInt64\n  let e := e + s\n  m.toFloat.scaleB e", "start": [19, 1], "end": [24, 21], "kind": "commanddeclaration"}, {"full_name": "Float.ofScientific", "code": "protected opaque Float.ofScientific (m : Nat) (s : Bool) (e : Nat) : Float :=\n  if s then\n    let s := 64 - m.log2 let m := (m <<< (3 * e + s)) / 5^e\n    Float.ofBinaryScientific m (-4 * e - s)\n  else\n    Float.ofBinaryScientific (m * 5^e) e", "start": [26, 1], "end": [32, 41], "kind": "commanddeclaration"}, {"full_name": "Float.ofNat", "code": "@[export lean_float_of_nat]\ndef Float.ofNat (n : Nat) : Float :=\n  OfScientific.ofScientific n false 0", "start": [45, 1], "end": [47, 38], "kind": "commanddeclaration"}, {"full_name": "Float.ofInt", "code": "def Float.ofInt : Int \u2192 Float\n  | Int.ofNat n => Float.ofNat n\n  | Int.negSucc n => Float.neg (Float.ofNat (Nat.succ n))", "start": [49, 1], "end": [51, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.toFloat", "code": "abbrev Nat.toFloat (n : Nat) : Float :=\n  Float.ofNat n", "start": [55, 1], "end": [56, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Channel.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Queue.lean", "lake-packages/lean4/src/lean/Init/System/Promise.lean", "lake-packages/lean4/src/lean/Init/System/Mutex.lean"], "premises": [{"full_name": "IO.Channel.State", "code": "structure Channel.State (\u03b1 : Type) where\n  values : Std.Queue \u03b1 := \u2205\n  consumers : Std.Queue (Promise (Option \u03b1)) := \u2205\n  closed := false\n  deriving Inhabited", "start": [13, 1], "end": [22, 21], "kind": "commanddeclaration"}, {"full_name": "IO.Channel", "code": "def Channel (\u03b1 : Type) : Type := Mutex (Channel.State \u03b1)", "start": [24, 1], "end": [30, 57], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.new", "code": "def Channel.new : BaseIO (Channel \u03b1) :=\n  Mutex.new {}", "start": [35, 1], "end": [37, 15], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.send", "code": "def Channel.send (v : \u03b1) (ch : Channel \u03b1) : BaseIO Unit :=\n  ch.atomically do\n    let st \u2190 get\n    if st.closed then return\n    if let some (consumer, consumers) := st.consumers.dequeue? then\n      consumer.resolve (some v)\n      set { st with consumers }\n    else\n      set { st with values := st.values.enqueue v }", "start": [39, 1], "end": [52, 52], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.close", "code": "def Channel.close (ch : Channel \u03b1) : BaseIO Unit :=\n  ch.atomically do\n    let st \u2190 get\n    for consumer in st.consumers.toArray do consumer.resolve none\n    set { st with closed := true, consumers := \u2205 }", "start": [54, 1], "end": [61, 51], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.recv?", "code": "def Channel.recv? (ch : Channel \u03b1) : BaseIO (Task (Option \u03b1)) :=\n  ch.atomically do\n    let st \u2190 get\n    if let some (a, values) := st.values.dequeue? then\n      set { st with values }\n      return .pure a\n    else if !st.closed then\n      let promise \u2190 Promise.new\n      set { st with consumers := st.consumers.enqueue promise }\n      return promise.result\n    else\n      return .pure none", "start": [63, 1], "end": [81, 24], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.forAsync", "code": "partial def Channel.forAsync (f : \u03b1 \u2192 BaseIO Unit) (ch : Channel \u03b1)\n    (prio : Task.Priority := .default) : BaseIO (Task Unit) := do\n  BaseIO.bindTask (prio := prio) (\u2190 ch.recv?) fun\n    | none => return .pure ()\n    | some v => do f v; ch.forAsync f prio", "start": [83, 1], "end": [92, 43], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.recvAllCurrent", "code": "def Channel.recvAllCurrent (ch : Channel \u03b1) : BaseIO (Array \u03b1) :=\n  ch.atomically do\n    modifyGet fun st => (st.values.toArray, { st with values := \u2205 })", "start": [94, 1], "end": [101, 69], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.Sync", "code": "def Channel.Sync := Channel", "start": [103, 1], "end": [104, 28], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.sync", "code": "def Channel.sync (ch : Channel \u03b1) : Channel.Sync \u03b1 := ch", "start": [106, 1], "end": [113, 57], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.Sync.recv?", "code": "def Channel.Sync.recv? (ch : Channel.Sync \u03b1) : BaseIO (Option \u03b1) := do\n  IO.wait (\u2190 Channel.recv? ch)", "start": [115, 1], "end": [122, 31], "kind": "commanddeclaration"}, {"full_name": "IO.Channel.Sync.forIn", "code": "private partial def Channel.Sync.forIn [Monad m] [MonadLiftT BaseIO m]\n    (ch : Channel.Sync \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : \u03b2 \u2192 m \u03b2 := fun b => do\n  match \u2190 ch.recv? with\n    | some a =>\n      match \u2190 f a b with\n        | .done b => pure b\n        | .yield b => ch.forIn f b\n    | none => pure b", "start": [124, 1], "end": [131, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data/Random.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Int.lean", "lake-packages/lean4/src/lean/Init/System/IO.lean"], "premises": [{"full_name": "RandomGen", "code": "class RandomGen (g : Type u) where\n  \n  range : g \u2192 Nat \u00d7 Nat\n  \n  next  : g \u2192 Nat \u00d7 g\n  \n  split : g \u2192 g \u00d7 g", "start": [16, 1], "end": [29, 20], "kind": "commanddeclaration"}, {"full_name": "StdGen", "code": "structure StdGen where\n  s1 : Nat\n  s2 : Nat", "start": [31, 1], "end": [34, 11], "kind": "commanddeclaration"}, {"full_name": "stdRange", "code": "def stdRange := (1, 2147483562)", "start": [38, 1], "end": [38, 32], "kind": "commanddeclaration"}, {"full_name": "stdNext", "code": "def stdNext : StdGen \u2192 Nat \u00d7 StdGen\n  | \u27e8s1, s2\u27e9 =>\n    let s1   : Int := s1\n    let s2   : Int := s2\n    let k    : Int := s1 / 53668\n    let s1'  : Int := 40014 * ((s1 : Int) - k * 53668) - k * 12211\n    let s1'' : Int := if s1' < 0 then s1' + 2147483563 else s1'\n    let k'   : Int := s2 / 52774\n    let s2'  : Int := 40692 * ((s2 : Int) - k' * 52774) - k' * 3791\n    let s2'' : Int := if s2' < 0 then s2' + 2147483399 else s2'\n    let z    : Int := s1'' - s2''\n    let z'   : Int := if z < 1 then z + 2147483562 else z % 2147483562\n    (z'.toNat, \u27e8s1''.toNat, s2''.toNat\u27e9)", "start": [43, 1], "end": [55, 41], "kind": "commanddeclaration"}, {"full_name": "stdSplit", "code": "def stdSplit : StdGen \u2192 StdGen \u00d7 StdGen\n  | g@\u27e8s1, s2\u27e9 =>\n    let newS1  := if s1 = 2147483562 then 1 else s1 + 1\n    let newS2  := if s2 = 1          then 2147483398 else s2 - 1\n    let newG   := (stdNext g).2\n    let leftG  := StdGen.mk newS1 newG.2\n    let rightG := StdGen.mk newG.1 newS2\n    (leftG, rightG)", "start": [57, 1], "end": [64, 20], "kind": "commanddeclaration"}, {"full_name": "mkStdGen", "code": "def mkStdGen (s : Nat := 0) : StdGen :=\n  let q  := s / 2147483562\n  let s1 := s % 2147483562\n  let s2 := q % 2147483398\n  \u27e8s1 + 1, s2 + 1\u27e9", "start": [72, 1], "end": [77, 19], "kind": "commanddeclaration"}, {"full_name": "randNatAux", "code": "private partial def randNatAux {gen : Type u} [RandomGen gen] (genLo genMag : Nat) : Nat \u2192 (Nat \u00d7 gen) \u2192 Nat \u00d7 gen\n  | 0,        (v, g) => (v, g)\n  | r'@(_+1), (v, g) =>\n    let (x, g') := RandomGen.next g\n    let v'      := v*genMag + (x - genLo)\n    randNatAux genLo genMag (r' / genMag - 1) (v', g')", "start": [79, 1], "end": [90, 55], "kind": "commanddeclaration"}, {"full_name": "randNat", "code": "def randNat {gen : Type u} [RandomGen gen] (g : gen) (lo hi : Nat) : Nat \u00d7 gen :=\n  let lo'            := if lo > hi then hi else lo\n  let hi'            := if lo > hi then lo else hi\n  let (genLo, genHi) := RandomGen.range g\n  let genMag         := genHi - genLo + 1\n      \n  let q       := 1000\n  let k       := hi' - lo' + 1\n  let tgtMag  := k * q\n  let (v, g') := randNatAux genLo genMag tgtMag (0, g)\n  let v'      := lo' + (v % k)\n  (v', g')", "start": [92, 1], "end": [108, 11], "kind": "commanddeclaration"}, {"full_name": "randBool", "code": "def randBool {gen : Type u} [RandomGen gen] (g : gen) : Bool \u00d7 gen :=\n  let (v, g') := randNat g 0 1\n  (v = 1, g')", "start": [110, 1], "end": [113, 14], "kind": "commanddeclaration"}, {"full_name": "IO.setRandSeed", "code": "def IO.setRandSeed (n : Nat) : IO Unit :=\n  IO.stdGenRef.set (mkStdGen n)", "start": [119, 1], "end": [120, 32], "kind": "commanddeclaration"}, {"full_name": "IO.rand", "code": "def IO.rand (lo hi : Nat) : IO Nat := do\n  let gen \u2190 IO.stdGenRef.get\n  let (r, gen) := randNat gen lo hi\n  IO.stdGenRef.set gen\n  pure r", "start": [122, 1], "end": [126, 9], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/StateCps.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/Lawful.lean"], "premises": [{"full_name": "StateCpsT", "code": "def StateCpsT (\u03c3 : Type u) (m : Type u \u2192 Type v) (\u03b1 : Type u) := (\u03b4 : Type u) \u2192 \u03c3 \u2192 (\u03b1 \u2192 \u03c3 \u2192 m \u03b4) \u2192 m \u03b4", "start": [13, 1], "end": [13, 104], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK", "code": "@[always_inline, inline]\ndef runK {\u03b1 \u03c3 : Type u} {m : Type u \u2192 Type v}  (x : StateCpsT \u03c3 m \u03b1) (s : \u03c3) (k : \u03b1 \u2192 \u03c3 \u2192 m \u03b2) : m \u03b2 :=\n  x _ s k", "start": [17, 1], "end": [19, 10], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.run", "code": "@[always_inline, inline]\ndef run {\u03b1 \u03c3 : Type u} {m : Type u \u2192 Type v} [Monad m] (x : StateCpsT \u03c3 m \u03b1) (s : \u03c3) : m (\u03b1 \u00d7 \u03c3) :=\n  runK x s (fun a s => pure (a, s))", "start": [21, 1], "end": [23, 36], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.run'", "code": "@[always_inline, inline]\ndef run' {\u03b1 \u03c3 : Type u} {m : Type u \u2192 Type v}  [Monad m] (x : StateCpsT \u03c3 m \u03b1) (s : \u03c3) : m \u03b1 :=\n  runK x s (fun a _ => pure a)", "start": [25, 1], "end": [27, 31], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.lift", "code": "@[always_inline, inline]\nprotected def lift [Monad m] (x : m \u03b1) : StateCpsT \u03c3 m \u03b1 :=\n  fun _ s k => x >>= (k . s)", "start": [44, 1], "end": [46, 29], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_pure", "code": "@[simp] theorem runK_pure {m : Type u \u2192 Type v} (a : \u03b1) (s : \u03c3) (k : \u03b1 \u2192 \u03c3 \u2192 m \u03b2) : (pure a : StateCpsT \u03c3 m \u03b1).runK s k = k a s", "start": [51, 1], "end": [51, 135], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_get", "code": "@[simp] theorem runK_get {m : Type u \u2192 Type v} (s : \u03c3) (k : \u03c3 \u2192 \u03c3 \u2192 m \u03b2) : (get : StateCpsT \u03c3 m \u03c3).runK s k = k s s", "start": [53, 1], "end": [53, 123], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_set", "code": "@[simp] theorem runK_set {m : Type u \u2192 Type v} (s s' : \u03c3) (k : PUnit \u2192 \u03c3 \u2192 m \u03b2) : (set s' : StateCpsT \u03c3 m PUnit).runK s k = k \u27e8\u27e9 s'", "start": [55, 1], "end": [55, 139], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_modify", "code": "@[simp] theorem runK_modify {m : Type u \u2192 Type v} (f : \u03c3 \u2192 \u03c3) (s : \u03c3) (k : PUnit \u2192 \u03c3 \u2192 m \u03b2) : (modify f : StateCpsT \u03c3 m PUnit).runK s k = k \u27e8\u27e9 (f s)", "start": [57, 1], "end": [57, 156], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_lift", "code": "@[simp] theorem runK_lift {\u03b1 \u03c3 : Type u} [Monad m] (x : m \u03b1) (s : \u03c3) (k : \u03b1 \u2192 \u03c3 \u2192 m \u03b2) : (StateCpsT.lift x : StateCpsT \u03c3 m \u03b1).runK s k = x >>= (k . s)", "start": [59, 1], "end": [59, 158], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_monadLift", "code": "@[simp] theorem runK_monadLift {\u03c3 : Type u} [Monad m] [MonadLiftT n m] (x : n \u03b1) (s : \u03c3) (k : \u03b1 \u2192 \u03c3 \u2192 m \u03b2)\n    : (monadLift x : StateCpsT \u03c3 m \u03b1).runK s k = (monadLift x : m \u03b1) >>= (k . s)", "start": [61, 1], "end": [62, 88], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_bind_pure", "code": "@[simp] theorem runK_bind_pure {\u03b1 \u03c3 : Type u} [Monad m] (a : \u03b1) (f : \u03b1 \u2192 StateCpsT \u03c3 m \u03b2) (s : \u03c3) (k : \u03b2 \u2192 \u03c3 \u2192 m \u03b3) : (pure a >>= f).runK s k = (f a).runK s k", "start": [64, 1], "end": [64, 166], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_bind_lift", "code": "@[simp] theorem runK_bind_lift {\u03b1 \u03c3 : Type u} [Monad m] (x : m \u03b1) (f : \u03b1 \u2192 StateCpsT \u03c3 m \u03b2) (s : \u03c3) (k : \u03b2 \u2192 \u03c3 \u2192 m \u03b3)\n    : (StateCpsT.lift x >>= f).runK s k = x >>= fun a => (f a).runK s k", "start": [66, 1], "end": [67, 79], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_bind_get", "code": "@[simp] theorem runK_bind_get {\u03c3 : Type u} [Monad m] (f : \u03c3 \u2192 StateCpsT \u03c3 m \u03b2) (s : \u03c3) (k : \u03b2 \u2192 \u03c3 \u2192 m \u03b3) : (get >>= f).runK s k = (f s).runK s k", "start": [69, 1], "end": [69, 152], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_bind_set", "code": "@[simp] theorem runK_bind_set {\u03c3 : Type u} [Monad m] (f : PUnit \u2192 StateCpsT \u03c3 m \u03b2) (s s' : \u03c3) (k : \u03b2 \u2192 \u03c3 \u2192 m \u03b3) : (set s' >>= f).runK s k = (f \u27e8\u27e9).runK s' k", "start": [71, 1], "end": [71, 164], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.runK_bind_modify", "code": "@[simp] theorem runK_bind_modify {\u03c3 : Type u} [Monad m] (f : \u03c3 \u2192 \u03c3) (g : PUnit \u2192 StateCpsT \u03c3 m \u03b2) (s : \u03c3) (k : \u03b2 \u2192 \u03c3 \u2192 m \u03b3) : (modify f >>= g).runK s k = (g \u27e8\u27e9).runK (f s) k", "start": [73, 1], "end": [73, 181], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.run_eq", "code": "@[simp] theorem run_eq [Monad m] (x : StateCpsT \u03c3 m \u03b1) (s : \u03c3) : x.run s = x.runK s (fun a s => pure (a, s))", "start": [75, 1], "end": [75, 116], "kind": "commanddeclaration"}, {"full_name": "StateCpsT.run'_eq", "code": "@[simp] theorem run'_eq [Monad m] (x : StateCpsT \u03c3 m \u03b1) (s : \u03c3) : x.run' s = x.runK s (fun a _ => pure a)", "start": [77, 1], "end": [77, 113], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Control/ExceptCps.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/Lawful.lean"], "premises": [{"full_name": "ExceptCpsT", "code": "def ExceptCpsT (\u03b5 : Type u) (m : Type u \u2192 Type v) (\u03b1 : Type u) := (\u03b2 : Type u) \u2192 (\u03b1 \u2192 m \u03b2) \u2192 (\u03b5 \u2192 m \u03b2) \u2192 m \u03b2", "start": [13, 1], "end": [13, 109], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.run", "code": "@[always_inline, inline]\ndef run {\u03b5 \u03b1 : Type u} [Monad m] (x : ExceptCpsT \u03b5 m \u03b1) : m (Except \u03b5 \u03b1) :=\n  x _ (fun a => pure (Except.ok a)) (fun e => pure (Except.error e))", "start": [17, 1], "end": [19, 69], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.runK", "code": "@[always_inline, inline]\ndef runK {\u03b5 \u03b1 : Type u} (x : ExceptCpsT \u03b5 m \u03b1) (s : \u03b5) (ok : \u03b1 \u2192 m \u03b2) (error : \u03b5 \u2192 m \u03b2) : m \u03b2 :=\n  x _ ok error", "start": [21, 1], "end": [23, 15], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.runCatch", "code": "@[always_inline, inline]\ndef runCatch [Monad m] (x : ExceptCpsT \u03b1 m \u03b1) : m \u03b1 :=\n  x \u03b1 pure pure", "start": [25, 1], "end": [27, 16], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.lift", "code": "@[always_inline, inline]\ndef lift [Monad m] (x : m \u03b1) : ExceptCpsT \u03b5 m \u03b1 :=\n  fun _ k _ => x >>= k", "start": [42, 1], "end": [44, 23], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.run_pure", "code": "@[simp] theorem run_pure [Monad m] : run (pure x : ExceptCpsT \u03b5 m \u03b1) = pure (Except.ok x)", "start": [52, 1], "end": [52, 97], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.run_lift", "code": "@[simp] theorem run_lift {\u03b1 \u03b5 : Type u} [Monad m] (x : m \u03b1) : run (ExceptCpsT.lift x : ExceptCpsT \u03b5 m \u03b1) = (x >>= fun a => pure (Except.ok a) : m (Except \u03b5 \u03b1))", "start": [54, 1], "end": [54, 167], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.run_throw", "code": "@[simp] theorem run_throw [Monad m] : run (throw e : ExceptCpsT \u03b5 m \u03b2) = pure (Except.error e)", "start": [56, 1], "end": [56, 102], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.run_bind_lift", "code": "@[simp] theorem run_bind_lift [Monad m] (x : m \u03b1) (f : \u03b1 \u2192 ExceptCpsT \u03b5 m \u03b2) : run (ExceptCpsT.lift x >>= f : ExceptCpsT \u03b5 m \u03b2) = x >>= fun a => run (f a)", "start": [58, 1], "end": [58, 162], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.run_bind_throw", "code": "@[simp] theorem run_bind_throw [Monad m] (e : \u03b5) (f : \u03b1 \u2192 ExceptCpsT \u03b5 m \u03b2) : run (throw e >>= f : ExceptCpsT \u03b5 m \u03b2) = run (throw e)", "start": [60, 1], "end": [60, 140], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.runCatch_pure", "code": "@[simp] theorem runCatch_pure [Monad m] : runCatch (pure x : ExceptCpsT \u03b1 m \u03b1) = pure x", "start": [62, 1], "end": [62, 95], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.runCatch_lift", "code": "@[simp] theorem runCatch_lift {\u03b1 : Type u} [Monad m] [LawfulMonad m] (x : m \u03b1) : runCatch (ExceptCpsT.lift x : ExceptCpsT \u03b1 m \u03b1) = x", "start": [64, 1], "end": [65, 24], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.runCatch_throw", "code": "@[simp] theorem runCatch_throw [Monad m] : runCatch (throw a : ExceptCpsT \u03b1 m \u03b1) = pure a", "start": [67, 1], "end": [67, 97], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.runCatch_bind_lift", "code": "@[simp] theorem runCatch_bind_lift [Monad m] (x : m \u03b1) (f : \u03b1 \u2192 ExceptCpsT \u03b2 m \u03b2) : runCatch (ExceptCpsT.lift x >>= f : ExceptCpsT \u03b2 m \u03b2) = x >>= fun a => runCatch (f a)", "start": [69, 1], "end": [69, 177], "kind": "commanddeclaration"}, {"full_name": "ExceptCpsT.runCatch_bind_throw", "code": "@[simp] theorem runCatch_bind_throw [Monad m] (e : \u03b2) (f : \u03b1 \u2192 ExceptCpsT \u03b2 m \u03b2) : runCatch (throw e >>= f : ExceptCpsT \u03b2 m \u03b2) = pure e", "start": [71, 1], "end": [71, 143], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Hints.lean", "imports": ["lake-packages/lean4/src/lean/Init/NotationExtra.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/ShareCommon.lean", "imports": ["lake-packages/lean4/src/lean/Init/Util.lean"], "premises": [{"full_name": "ShareCommon.Object", "code": "abbrev Object : Type := NonScalar", "start": [17, 1], "end": [17, 34], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.Object.ptrEq", "code": "unsafe def Object.ptrEq (a b : Object) : Bool :=\n  ptrAddrUnsafe a == ptrAddrUnsafe b", "start": [19, 1], "end": [20, 37], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.Object.ptrHash", "code": "unsafe abbrev Object.ptrHash (a : Object) : UInt64 :=\n  ptrAddrUnsafe a |>.toUInt64", "start": [22, 1], "end": [23, 30], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.StateFactoryImpl", "code": "structure StateFactoryImpl where\n  (Map Set : Type)\n  mkState : Unit \u2192 Map \u00d7 Set\n  mapFind? (m : Map) (k : Object) : Option Object\n  mapInsert (m : Map) (k v : Object) : Map\n  setFind? (m : Set) (k : Object) : Option Object\n  setInsert (m : Set) (o : Object) : Set", "start": [25, 1], "end": [31, 41], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.StateFactoryPointed", "code": "opaque StateFactoryPointed : NonemptyType", "start": [33, 1], "end": [33, 42], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.StateFactory", "code": "abbrev StateFactory : Type := StateFactoryPointed.type", "start": [34, 1], "end": [34, 55], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.Object.eq", "code": "@[extern \"lean_sharecommon_eq\"]\nunsafe opaque Object.eq (a b : @& Object) : Bool", "start": [37, 1], "end": [38, 49], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.Object.hash", "code": "@[extern \"lean_sharecommon_hash\"]\nunsafe opaque Object.hash (a : @& Object) : UInt64", "start": [40, 1], "end": [41, 51], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.StateFactoryBuilder", "code": "structure StateFactoryBuilder where\n  Map (\u03b1 _\u03b2 : Type) [BEq \u03b1] [Hashable \u03b1] : Type\n  mkMap {\u03b1 \u03b2 : Type} [BEq \u03b1] [Hashable \u03b1] (capacity : Nat) : Map \u03b1 \u03b2\n  mapFind? {\u03b1 \u03b2 : Type} [BEq \u03b1] [Hashable \u03b1] : Map \u03b1 \u03b2 \u2192 \u03b1 \u2192 Option \u03b2\n  mapInsert {\u03b1 \u03b2 : Type} [BEq \u03b1] [Hashable \u03b1] : Map \u03b1 \u03b2 \u2192 \u03b1 \u2192 \u03b2 \u2192 Map \u03b1 \u03b2\n  Set (\u03b1 : Type) [BEq \u03b1] [Hashable \u03b1] : Type\n  mkSet {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] (capacity : Nat) : Set \u03b1\n  setFind? {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] : Set \u03b1 \u2192 \u03b1 \u2192 Option \u03b1\n  setInsert {\u03b1 : Type} [BEq \u03b1] [Hashable \u03b1] : Set \u03b1 \u2192 \u03b1 \u2192 Set \u03b1", "start": [43, 1], "end": [51, 64], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.StateFactory.mkImpl", "code": "unsafe def StateFactory.mkImpl : StateFactoryBuilder \u2192 StateFactory\n  | { Map, mkMap, mapFind?, mapInsert, Set, mkSet, setFind?, setInsert } =>\n    unsafeCast {\n      Map := @Map Object Object \u27e8Object.ptrEq\u27e9 \u27e8Object.ptrHash\u27e9\n      Set := @Set Object \u27e8Object.eq\u27e9 \u27e8Object.hash\u27e9\n      mkState := fun _ => (\n        @mkMap Object Object \u27e8Object.ptrEq\u27e9 \u27e8Object.ptrHash\u27e9 1024,\n        @mkSet Object \u27e8Object.eq\u27e9 \u27e8Object.hash\u27e9 1024)\n      mapFind? := @mapFind? Object Object \u27e8Object.ptrEq\u27e9 \u27e8Object.ptrHash\u27e9\n      mapInsert := @mapInsert Object Object \u27e8Object.ptrEq\u27e9 \u27e8Object.ptrHash\u27e9\n      setFind? := @setFind? Object \u27e8Object.eq\u27e9 \u27e8Object.hash\u27e9\n      setInsert := @setInsert Object \u27e8Object.eq\u27e9 \u27e8Object.hash\u27e9\n    : StateFactoryImpl }", "start": [53, 1], "end": [65, 25], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.StateFactory.mk", "code": "@[implemented_by StateFactory.mkImpl]\nopaque StateFactory.mk : StateFactoryBuilder \u2192 StateFactory", "start": [67, 1], "end": [68, 60], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.StateFactory.get", "code": "unsafe def StateFactory.get : StateFactory \u2192 StateFactoryImpl := unsafeCast", "start": [70, 1], "end": [70, 76], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.StatePointed", "code": "opaque StatePointed (\u03c3 : StateFactory) : NonemptyType", "start": [72, 1], "end": [73, 54], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.State", "code": "abbrev State (\u03c3 : StateFactory) : Type u := (StatePointed \u03c3).type", "start": [74, 1], "end": [74, 66], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.mkStateImpl", "code": "unsafe def mkStateImpl (\u03c3 : StateFactory) : State \u03c3 := unsafeCast (\u03c3.get.mkState ())", "start": [77, 1], "end": [77, 85], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.State.mk", "code": "@[implemented_by mkStateImpl] opaque State.mk (\u03c3 : StateFactory) : State \u03c3", "start": [78, 1], "end": [78, 75], "kind": "commanddeclaration"}, {"full_name": "ShareCommon.State.shareCommon", "code": "@[extern \"lean_state_sharecommon\"]\ndef State.shareCommon {\u03c3 : @& StateFactory} (s : State \u03c3) (a : \u03b1) : \u03b1 \u00d7 State \u03c3 := (a, s)", "start": [81, 1], "end": [82, 90], "kind": "commanddeclaration"}, {"full_name": "MonadShareCommon", "code": "class MonadShareCommon (m : Type u \u2192 Type v) where\n  withShareCommon {\u03b1 : Type u} : \u03b1 \u2192 m \u03b1", "start": [86, 1], "end": [87, 41], "kind": "commanddeclaration"}, {"full_name": "withShareCommon", "code": "abbrev withShareCommon := @MonadShareCommon.withShareCommon", "start": [89, 1], "end": [89, 60], "kind": "commanddeclaration"}, {"full_name": "shareCommonM", "code": "abbrev shareCommonM [MonadShareCommon m] (a : \u03b1) : m \u03b1 :=\n  withShareCommon a", "start": [91, 1], "end": [92, 20], "kind": "commanddeclaration"}, {"full_name": "ShareCommonT", "code": "abbrev ShareCommonT (\u03c3) (m : Type u \u2192 Type v) := StateT (ShareCommon.State \u03c3) m", "start": [94, 1], "end": [94, 80], "kind": "commanddeclaration"}, {"full_name": "ShareCommonM", "code": "abbrev ShareCommonM (\u03c3) := ShareCommonT \u03c3 Id", "start": [95, 1], "end": [95, 45], "kind": "commanddeclaration"}, {"full_name": "ShareCommonT.withShareCommon", "code": "@[specialize] def ShareCommonT.withShareCommon [Monad m] (a : \u03b1) : ShareCommonT \u03c3 m \u03b1 :=\n  modifyGet fun s => s.shareCommon a", "start": [97, 1], "end": [98, 37], "kind": "commanddeclaration"}, {"full_name": "ShareCommonT.monadShareCommon", "code": "instance ShareCommonT.monadShareCommon [Monad m] : MonadShareCommon (ShareCommonT \u03c3 m) where\n  withShareCommon := ShareCommonT.withShareCommon", "start": [100, 1], "end": [101, 50], "kind": "commanddeclaration"}, {"full_name": "ShareCommonT.run", "code": "@[inline] def ShareCommonT.run [Monad m] (x : ShareCommonT \u03c3 m \u03b1) : m \u03b1 := x.run' default", "start": [103, 1], "end": [103, 90], "kind": "commanddeclaration"}, {"full_name": "ShareCommonM.run", "code": "@[inline] def ShareCommonM.run (x : ShareCommonM \u03c3 \u03b1) : \u03b1 := ShareCommonT.run x", "start": [104, 1], "end": [104, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Conv.lean", "imports": ["lake-packages/lean4/src/lean/Init/NotationExtra.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/System.lean", "imports": ["lake-packages/lean4/src/lean/Init/System/Promise.lean", "lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Init/System/Uri.lean", "lake-packages/lean4/src/lean/Init/System/Mutex.lean", "lake-packages/lean4/src/lean/Init/System/Platform.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/SizeOfLemmas.lean", "imports": ["lake-packages/lean4/src/lean/Init/SizeOf.lean", "lake-packages/lean4/src/lean/Init/Data/Nat/Linear.lean", "lake-packages/lean4/src/lean/Init/Meta.lean"], "premises": [{"full_name": "Fin.sizeOf", "code": "@[simp] protected theorem Fin.sizeOf (a : Fin n) : sizeOf a = a.val + 1", "start": [11, 1], "end": [12, 22], "kind": "commanddeclaration"}, {"full_name": "UInt8.sizeOf", "code": "@[simp] protected theorem UInt8.sizeOf (a : UInt8) : sizeOf a = a.toNat + 2", "start": [14, 1], "end": [15, 36], "kind": "commanddeclaration"}, {"full_name": "UInt16.sizeOf", "code": "@[simp] protected theorem UInt16.sizeOf (a : UInt16) : sizeOf a = a.toNat + 2", "start": [17, 1], "end": [18, 37], "kind": "commanddeclaration"}, {"full_name": "UInt32.sizeOf", "code": "@[simp] protected theorem UInt32.sizeOf (a : UInt32) : sizeOf a = a.toNat + 2", "start": [20, 1], "end": [21, 37], "kind": "commanddeclaration"}, {"full_name": "UInt64.sizeOf", "code": "@[simp] protected theorem UInt64.sizeOf (a : UInt64) : sizeOf a = a.toNat + 2", "start": [23, 1], "end": [24, 37], "kind": "commanddeclaration"}, {"full_name": "USize.sizeOf", "code": "@[simp] protected theorem USize.sizeOf (a : USize) : sizeOf a = a.toNat + 2", "start": [26, 1], "end": [27, 36], "kind": "commanddeclaration"}, {"full_name": "Char.sizeOf", "code": "@[simp] protected theorem Char.sizeOf (a : Char) : sizeOf a = a.toNat + 3", "start": [29, 1], "end": [30, 35], "kind": "commanddeclaration"}, {"full_name": "Subtype.sizeOf", "code": "@[simp] protected theorem Subtype.sizeOf {\u03b1 : Sort u_1} {p : \u03b1 \u2192 Prop} (s : Subtype p) : sizeOf s = sizeOf s.val + 1", "start": [32, 1], "end": [33, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init/Data.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Int.lean", "lake-packages/lean4/src/lean/Init/Data/Nat.lean", "lake-packages/lean4/src/lean/Init/Data/ToString.lean", "lake-packages/lean4/src/lean/Init/Data/List.lean", "lake-packages/lean4/src/lean/Init/Data/ByteArray.lean", "lake-packages/lean4/src/lean/Init/Data/Random.lean", "lake-packages/lean4/src/lean/Init/Data/UInt.lean", "lake-packages/lean4/src/lean/Init/Data/Channel.lean", "lake-packages/lean4/src/lean/Init/Data/OfScientific.lean", "lake-packages/lean4/src/lean/Init/Data/Format.lean", "lake-packages/lean4/src/lean/Init/Data/Basic.lean", "lake-packages/lean4/src/lean/Init/Data/Option.lean", "lake-packages/lean4/src/lean/Init/Data/String.lean", "lake-packages/lean4/src/lean/Init/Data/FloatArray.lean", "lake-packages/lean4/src/lean/Init/Data/Prod.lean", "lake-packages/lean4/src/lean/Init/Data/Queue.lean", "lake-packages/lean4/src/lean/Init/Data/Float.lean", "lake-packages/lean4/src/lean/Init/Data/AC.lean", "lake-packages/lean4/src/lean/Init/Data/Stream.lean", "lake-packages/lean4/src/lean/Init/Data/Array.lean", "lake-packages/lean4/src/lean/Init/Data/Char.lean", "lake-packages/lean4/src/lean/Init/Data/Fin.lean", "lake-packages/lean4/src/lean/Init/Data/Range.lean", "lake-packages/lean4/src/lean/Init/Data/Ord.lean", "lake-packages/lean4/src/lean/Init/Data/Hashable.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Control.lean", "imports": ["lake-packages/lean4/src/lean/Init/Control/Except.lean", "lake-packages/lean4/src/lean/Init/Control/Id.lean", "lake-packages/lean4/src/lean/Init/Control/ExceptCps.lean", "lake-packages/lean4/src/lean/Init/Control/State.lean", "lake-packages/lean4/src/lean/Init/Control/StateCps.lean", "lake-packages/lean4/src/lean/Init/Control/Reader.lean", "lake-packages/lean4/src/lean/Init/Control/Option.lean", "lake-packages/lean4/src/lean/Init/Control/Basic.lean", "lake-packages/lean4/src/lean/Init/Control/Lawful.lean", "lake-packages/lean4/src/lean/Init/Control/StateRef.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Init/Dynamic.lean", "imports": ["lake-packages/lean4/src/lean/Init/Core.lean"], "premises": [{"full_name": "TypeNameData", "code": "private opaque TypeNameData (\u03b1 : Type u) : NonemptyType.{0} :=\n  \u27e8Name, inferInstance\u27e9", "start": [13, 1], "end": [14, 24], "kind": "commanddeclaration"}, {"full_name": "TypeName", "code": "@[nospecialize]\nclass TypeName (\u03b1 : Type u) where private mk' ::\n  private data : (TypeNameData \u03b1).type", "start": [16, 1], "end": [34, 39], "kind": "commanddeclaration"}, {"full_name": "TypeName.mk", "code": "unsafe def TypeName.mk (\u03b1 : Type u) (typeName : Name) : TypeName \u03b1 :=\n  \u27e8unsafeCast typeName\u27e9", "start": [38, 1], "end": [45, 24], "kind": "commanddeclaration"}, {"full_name": "TypeName.typeNameImpl", "code": "private unsafe def TypeName.typeNameImpl (\u03b1) [TypeName \u03b1] : Name :=\n  unsafeCast (@TypeName.data \u03b1 _)", "start": [47, 1], "end": [48, 34], "kind": "commanddeclaration"}, {"full_name": "TypeName.typeName", "code": "@[implemented_by TypeName.typeNameImpl]\nopaque TypeName.typeName (\u03b1) [TypeName \u03b1] : Name", "start": [50, 1], "end": [54, 49], "kind": "commanddeclaration"}, {"full_name": "DynamicPointed", "code": "private opaque DynamicPointed : NonemptyType.{0} :=\n  \u27e8Name \u00d7 NonScalar, inferInstance\u27e9", "start": [56, 1], "end": [57, 36], "kind": "commanddeclaration"}, {"full_name": "Dynamic", "code": "def Dynamic : Type := DynamicPointed.type", "start": [59, 1], "end": [65, 42], "kind": "commanddeclaration"}, {"full_name": "Dynamic.typeNameImpl", "code": "private unsafe def Dynamic.typeNameImpl (any : Dynamic) : Name :=\n  (unsafeCast any : Name \u00d7 NonScalar).1", "start": [69, 1], "end": [70, 40], "kind": "commanddeclaration"}, {"full_name": "Dynamic.typeName", "code": "@[implemented_by Dynamic.typeNameImpl]\nopaque Dynamic.typeName (any : Dynamic) : Name", "start": [72, 1], "end": [76, 47], "kind": "commanddeclaration"}, {"full_name": "Dynamic.get?Impl", "code": "private unsafe def Dynamic.get?Impl (\u03b1) (any : Dynamic) [TypeName \u03b1] : Option \u03b1 :=\n  let ((typeName, obj) : Name \u00d7 NonScalar) := unsafeCast any\n  if typeName == TypeName.typeName \u03b1 then\n    some (unsafeCast obj)\n  else\n    none", "start": [78, 1], "end": [83, 9], "kind": "commanddeclaration"}, {"full_name": "Dynamic.get?", "code": "@[implemented_by Dynamic.get?Impl]\nopaque Dynamic.get? (\u03b1) (any : Dynamic) [TypeName \u03b1] : Option \u03b1", "start": [85, 1], "end": [90, 64], "kind": "commanddeclaration"}, {"full_name": "Dynamic.mkImpl", "code": "private unsafe def Dynamic.mkImpl [TypeName \u03b1] (obj : \u03b1) : Dynamic :=\n  unsafeCast (TypeName.typeName \u03b1, (unsafeCast obj : NonScalar))", "start": [92, 1], "end": [93, 65], "kind": "commanddeclaration"}, {"full_name": "Dynamic.mk", "code": "@[implemented_by Dynamic.mkImpl]\nopaque Dynamic.mk [TypeName \u03b1] (obj : \u03b1) : Dynamic", "start": [95, 1], "end": [96, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Init.lean", "imports": ["lake-packages/lean4/src/lean/Init/Dynamic.lean", "lake-packages/lean4/src/lean/Init/NotationExtra.lean", "lake-packages/lean4/src/lean/Init/Tactics.lean", "lake-packages/lean4/src/lean/Init/Util.lean", "lake-packages/lean4/src/lean/Init/Control.lean", "lake-packages/lean4/src/lean/Init/Data/Basic.lean", "lake-packages/lean4/src/lean/Init/Data.lean", "lake-packages/lean4/src/lean/Init/SizeOfLemmas.lean", "lake-packages/lean4/src/lean/Init/System.lean", "lake-packages/lean4/src/lean/Init/Meta.lean", "lake-packages/lean4/src/lean/Init/Core.lean", "lake-packages/lean4/src/lean/Init/Notation.lean", "lake-packages/lean4/src/lean/Init/SimpLemmas.lean", "lake-packages/lean4/src/lean/Init/Conv.lean", "lake-packages/lean4/src/lean/Init/ShareCommon.lean", "lake-packages/lean4/src/lean/Init/WFTactics.lean", "lake-packages/lean4/src/lean/Init/WF.lean", "lake-packages/lean4/src/lean/Init/Hints.lean", "lake-packages/lean4/src/lean/Init/Prelude.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Data/AssocList.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.AssocList", "code": "inductive AssocList (\u03b1 : Type u) (\u03b2 : Type v) where\n  | nil : AssocList \u03b1 \u03b2\n  | cons (key : \u03b1) (value : \u03b2) (tail : AssocList \u03b1 \u03b2) : AssocList \u03b1 \u03b2\n  deriving Inhabited", "start": [9, 1], "end": [13, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.empty", "code": "abbrev empty : AssocList \u03b1 \u03b2 :=\n  nil", "start": [18, 1], "end": [19, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.insert", "code": "abbrev insert (m : AssocList \u03b1 \u03b2) (k : \u03b1) (v : \u03b2) : AssocList \u03b1 \u03b2 :=\n  m.cons k v", "start": [23, 1], "end": [24, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.isEmpty", "code": "def isEmpty : AssocList \u03b1 \u03b2 \u2192 Bool\n  | nil => true\n  | _   => false", "start": [26, 1], "end": [28, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.foldlM", "code": "@[specialize] def foldlM (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b4) : (init : \u03b4) \u2192 AssocList \u03b1 \u03b2 \u2192 m \u03b4\n  | d, nil         => pure d\n  | d, cons a b es => do\n    let d \u2190 f d a b\n    foldlM f d es", "start": [30, 1], "end": [34, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.foldl", "code": "@[inline] def foldl (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b4) (init : \u03b4) (as : AssocList \u03b1 \u03b2) : \u03b4 :=\n  Id.run (foldlM f init as)", "start": [36, 1], "end": [37, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.toList", "code": "def toList (as : AssocList \u03b1 \u03b2) : List (\u03b1 \u00d7 \u03b2) :=\n  as.foldl (init := []) (fun r a b => (a, b)::r) |>.reverse", "start": [39, 1], "end": [40, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.forM", "code": "@[specialize] def forM (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) : AssocList \u03b1 \u03b2 \u2192 m PUnit\n  | nil         => pure \u27e8\u27e9\n  | cons a b es => do f a b; forM f es", "start": [42, 1], "end": [44, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.mapKey", "code": "def mapKey (f : \u03b1 \u2192 \u03b4) : AssocList \u03b1 \u03b2 \u2192 AssocList \u03b4 \u03b2\n  | nil        => nil\n  | cons k v t => cons (f k) v (mapKey f t)", "start": [46, 1], "end": [48, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.mapVal", "code": "def mapVal (f : \u03b2 \u2192 \u03b4) : AssocList \u03b1 \u03b2 \u2192 AssocList \u03b1 \u03b4\n  | nil        => nil\n  | cons k v t => cons k (f v) (mapVal f t)", "start": [50, 1], "end": [52, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.findEntry?", "code": "def findEntry? [BEq \u03b1] (a : \u03b1) : AssocList \u03b1 \u03b2 \u2192 Option (\u03b1 \u00d7 \u03b2)\n  | nil         => none\n  | cons k v es => match k == a with\n    | true  => some (k, v)\n    | false => findEntry? a es", "start": [54, 1], "end": [58, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.find?", "code": "def find? [BEq \u03b1] (a : \u03b1) : AssocList \u03b1 \u03b2 \u2192 Option \u03b2\n  | nil         => none\n  | cons k v es => match k == a with\n    | true  => some v\n    | false => find? a es", "start": [60, 1], "end": [64, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.contains", "code": "def contains [BEq \u03b1] (a : \u03b1) : AssocList \u03b1 \u03b2 \u2192 Bool\n  | nil         => false\n  | cons k _ es => k == a || contains a es", "start": [66, 1], "end": [68, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.replace", "code": "def replace [BEq \u03b1] (a : \u03b1) (b : \u03b2) : AssocList \u03b1 \u03b2 \u2192 AssocList \u03b1 \u03b2\n  | nil         => nil\n  | cons k v es => match k == a with\n    | true  => cons a b es\n    | false => cons k v (replace a b es)", "start": [70, 1], "end": [74, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.erase", "code": "def erase [BEq \u03b1] (a : \u03b1) : AssocList \u03b1 \u03b2 \u2192 AssocList \u03b1 \u03b2\n  | nil         => nil\n  | cons k v es => match k == a with\n    | true  => es\n    | false => cons k v (erase a es)", "start": [76, 1], "end": [80, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.any", "code": "def any (p : \u03b1 \u2192 \u03b2 \u2192 Bool) : AssocList \u03b1 \u03b2 \u2192 Bool\n  | nil         => false\n  | cons k v es => p k v || any p es", "start": [82, 1], "end": [84, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.all", "code": "def all (p : \u03b1 \u2192 \u03b2 \u2192 Bool) : AssocList \u03b1 \u03b2 \u2192 Bool\n  | nil         => true\n  | cons k v es => p k v && all p es", "start": [86, 1], "end": [88, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.AssocList.forIn", "code": "@[inline] protected def forIn {\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w} {m : Type w \u2192 Type w'} [Monad m]\n    (as : AssocList \u03b1 \u03b2) (init : \u03b4) (f : (\u03b1 \u00d7 \u03b2) \u2192 \u03b4 \u2192 m (ForInStep \u03b4)) : m \u03b4 :=\n  let rec @[specialize] loop\n    | d, nil => pure d\n    | d, cons k v es => do\n      match (\u2190 f (k, v) d) with\n      | ForInStep.done d  => pure d\n      | ForInStep.yield d => loop d es\n  loop init as", "start": [90, 1], "end": [98, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.List.toAssocList'", "code": "def List.toAssocList' {\u03b1 : Type u} {\u03b2 : Type v} : List (\u03b1 \u00d7 \u03b2) \u2192 Lean.AssocList \u03b1 \u03b2\n  | []          => Lean.AssocList.nil\n  | (a,b) :: es => Lean.AssocList.cons a b (toAssocList' es)", "start": [105, 1], "end": [107, 61], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/PersistentHashMap.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PersistentHashMap.Entry", "code": "inductive Entry (\u03b1 : Type u) (\u03b2 : Type v) (\u03c3 : Type w) where\n  | entry (key : \u03b1) (val : \u03b2) : Entry \u03b1 \u03b2 \u03c3\n  | ref   (node : \u03c3) : Entry \u03b1 \u03b2 \u03c3\n  | null  : Entry \u03b1 \u03b2 \u03c3", "start": [11, 1], "end": [14, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.Node", "code": "inductive Node (\u03b1 : Type u) (\u03b2 : Type v) : Type (max u v) where\n  | entries   (es : Array (Entry \u03b1 \u03b2 (Node \u03b1 \u03b2))) : Node \u03b1 \u03b2\n  | collision (ks : Array \u03b1) (vs : Array \u03b2) (h : ks.size = vs.size) : Node \u03b1 \u03b2", "start": [18, 1], "end": [20, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.shift", "code": "abbrev shift         : USize  := 5", "start": [24, 1], "end": [24, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.branching", "code": "abbrev branching     : USize  := USize.ofNat (2 ^ shift.toNat)", "start": [25, 1], "end": [25, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.maxDepth", "code": "abbrev maxDepth      : USize  := 7", "start": [26, 1], "end": [26, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.maxCollisions", "code": "abbrev maxCollisions : Nat    := 4", "start": [27, 1], "end": [27, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.mkEmptyEntriesArray", "code": "def mkEmptyEntriesArray {\u03b1 \u03b2} : Array (Entry \u03b1 \u03b2 (Node \u03b1 \u03b2)) :=\n  (Array.mkArray PersistentHashMap.branching.toNat PersistentHashMap.Entry.null)", "start": [29, 1], "end": [30, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap", "code": "structure PersistentHashMap (\u03b1 : Type u) (\u03b2 : Type v) [BEq \u03b1] [Hashable \u03b1] where\n  root    : PersistentHashMap.Node \u03b1 \u03b2 := PersistentHashMap.Node.entries PersistentHashMap.mkEmptyEntriesArray\n  size    : Nat                        := 0", "start": [34, 1], "end": [36, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.PHashMap", "code": "abbrev PHashMap (\u03b1 : Type u) (\u03b2 : Type v) [BEq \u03b1] [Hashable \u03b1] := PersistentHashMap \u03b1 \u03b2", "start": [38, 1], "end": [38, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.empty", "code": "def empty [BEq \u03b1] [Hashable \u03b1] : PersistentHashMap \u03b1 \u03b2 := {}", "start": [42, 1], "end": [42, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.isEmpty", "code": "def isEmpty [BEq \u03b1] [Hashable \u03b1] (m : PersistentHashMap \u03b1 \u03b2) : Bool :=\n  m.size == 0", "start": [44, 1], "end": [45, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.mkEmptyEntries", "code": "def mkEmptyEntries {\u03b1 \u03b2} : Node \u03b1 \u03b2 :=\n  Node.entries mkEmptyEntriesArray", "start": [49, 1], "end": [50, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.mul2Shift", "code": "abbrev mul2Shift (i : USize) (shift : USize) : USize := i.shiftLeft shift", "start": [52, 1], "end": [52, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.div2Shift", "code": "abbrev div2Shift (i : USize) (shift : USize) : USize := i.shiftRight shift", "start": [53, 1], "end": [53, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.mod2Shift", "code": "abbrev mod2Shift (i : USize) (shift : USize) : USize := USize.land i ((USize.shiftLeft 1 shift) - 1)", "start": [54, 1], "end": [54, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.IsCollisionNode", "code": "inductive IsCollisionNode : Node \u03b1 \u03b2 \u2192 Prop where\n  | mk (keys : Array \u03b1) (vals : Array \u03b2) (h : keys.size = vals.size) : IsCollisionNode (Node.collision keys vals h)", "start": [56, 1], "end": [57, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.CollisionNode", "code": "abbrev CollisionNode (\u03b1 \u03b2) := { n : Node \u03b1 \u03b2 // IsCollisionNode n }", "start": [59, 1], "end": [59, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.IsEntriesNode", "code": "inductive IsEntriesNode : Node \u03b1 \u03b2 \u2192 Prop where\n  | mk (entries : Array (Entry \u03b1 \u03b2 (Node \u03b1 \u03b2))) : IsEntriesNode (Node.entries entries)", "start": [61, 1], "end": [62, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.EntriesNode", "code": "abbrev EntriesNode (\u03b1 \u03b2) := { n : Node \u03b1 \u03b2 // IsEntriesNode n }", "start": [64, 1], "end": [64, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.size_set", "code": "private theorem size_set {ks : Array \u03b1} {vs : Array \u03b2} (h : ks.size = vs.size) (i : Fin ks.size) (j : Fin vs.size) (k : \u03b1) (v : \u03b2)\n                           : (ks.set i k).size = (vs.set j v).size", "start": [66, 1], "end": [68, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.size_push", "code": "private theorem size_push {ks : Array \u03b1} {vs : Array \u03b2} (h : ks.size = vs.size) (k : \u03b1) (v : \u03b2) : (ks.push k).size = (vs.push v).size", "start": [70, 1], "end": [71, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.insertAtCollisionNodeAux", "code": "partial def insertAtCollisionNodeAux [BEq \u03b1] : CollisionNode \u03b1 \u03b2 \u2192 Nat \u2192 \u03b1 \u2192 \u03b2 \u2192 CollisionNode \u03b1 \u03b2\n  | n@\u27e8Node.collision keys vals heq, _\u27e9, i, k, v =>\n    if h : i < keys.size then\n      let idx : Fin keys.size := \u27e8i, h\u27e9;\n      let k' := keys.get idx;\n      if k == k' then\n         let j : Fin vals.size := \u27e8i, by rw [\u2190heq]; assumption\u27e9\n         \u27e8Node.collision (keys.set idx k) (vals.set j v) (size_set heq idx j k v), IsCollisionNode.mk _ _ _\u27e9\n      else insertAtCollisionNodeAux n (i+1) k v\n    else\n      \u27e8Node.collision (keys.push k) (vals.push v) (size_push heq k v), IsCollisionNode.mk _ _ _\u27e9\n  | \u27e8Node.entries _, h\u27e9, _, _, _ => False.elim (nomatch h)", "start": [73, 1], "end": [84, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.insertAtCollisionNode", "code": "def insertAtCollisionNode [BEq \u03b1] : CollisionNode \u03b1 \u03b2 \u2192 \u03b1 \u2192 \u03b2 \u2192 CollisionNode \u03b1 \u03b2 :=\n  fun n k v => insertAtCollisionNodeAux n 0 k v", "start": [86, 1], "end": [87, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.getCollisionNodeSize", "code": "def getCollisionNodeSize : CollisionNode \u03b1 \u03b2 \u2192 Nat\n  | \u27e8Node.collision keys _ _, _\u27e9 => keys.size\n  | \u27e8Node.entries _, h\u27e9          => False.elim (nomatch h)", "start": [89, 1], "end": [91, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.mkCollisionNode", "code": "def mkCollisionNode (k\u2081 : \u03b1) (v\u2081 : \u03b2) (k\u2082 : \u03b1) (v\u2082 : \u03b2) : Node \u03b1 \u03b2 :=\n  let ks : Array \u03b1 := Array.mkEmpty maxCollisions\n  let ks := (ks.push k\u2081).push k\u2082\n  let vs : Array \u03b2 := Array.mkEmpty maxCollisions\n  let vs := (vs.push v\u2081).push v\u2082\n  Node.collision ks vs rfl", "start": [93, 1], "end": [98, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.insertAux", "code": "partial def insertAux [BEq \u03b1] [Hashable \u03b1] : Node \u03b1 \u03b2 \u2192 USize \u2192 USize \u2192 \u03b1 \u2192 \u03b2 \u2192 Node \u03b1 \u03b2\n  | Node.collision keys vals heq, _, depth, k, v =>\n    let newNode := insertAtCollisionNode \u27e8Node.collision keys vals heq, IsCollisionNode.mk _ _ _\u27e9 k v\n    if depth >= maxDepth || getCollisionNodeSize newNode < maxCollisions then newNode.val\n    else match newNode with\n      | \u27e8Node.entries _, h\u27e9 => False.elim (nomatch h)\n      | \u27e8Node.collision keys vals heq, _\u27e9 =>\n        let rec traverse (i : Nat) (entries : Node \u03b1 \u03b2) : Node \u03b1 \u03b2 :=\n          if h : i < keys.size then\n            let k := keys[i]\n            have : i < vals.size := heq \u25b8 h\n            let v := vals[i]\n            let h := hash k |>.toUSize\n            let h := div2Shift h (shift * (depth - 1))\n            traverse (i+1) (insertAux entries h depth k v)\n          else\n            entries\n        traverse 0 mkEmptyEntries\n  | Node.entries entries, h, depth, k, v =>\n    let j     := (mod2Shift h shift).toNat\n    Node.entries $ entries.modify j fun entry =>\n      match entry with\n      | Entry.null        => Entry.entry k v\n      | Entry.ref node    => Entry.ref $ insertAux node (div2Shift h shift) (depth+1) k v\n      | Entry.entry k' v' =>\n        if k == k' then Entry.entry k v\n        else Entry.ref $ mkCollisionNode k' v' k v", "start": [100, 1], "end": [126, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.insert", "code": "def insert {_ : BEq \u03b1} {_ : Hashable \u03b1} : PersistentHashMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 \u03b2 \u2192 PersistentHashMap \u03b1 \u03b2\n  | { root := n, size := sz }, k, v => { root := insertAux n (hash k |>.toUSize) 1 k v, size := sz + 1 }", "start": [128, 1], "end": [129, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.findAtAux", "code": "partial def findAtAux [BEq \u03b1] (keys : Array \u03b1) (vals : Array \u03b2) (heq : keys.size = vals.size) (i : Nat) (k : \u03b1) : Option \u03b2 :=\n  if h : i < keys.size then\n    let k' := keys[i]\n    have : i < vals.size := by rw [\u2190heq]; assumption\n    if k == k' then some vals[i]\n    else findAtAux keys vals heq (i+1) k\n  else none", "start": [131, 1], "end": [137, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.findAux", "code": "partial def findAux [BEq \u03b1] : Node \u03b1 \u03b2 \u2192 USize \u2192 \u03b1 \u2192 Option \u03b2\n  | Node.entries entries, h, k =>\n    let j     := (mod2Shift h shift).toNat\n    match entries.get! j with\n    | Entry.null       => none\n    | Entry.ref node   => findAux node (div2Shift h shift) k\n    | Entry.entry k' v => if k == k' then some v else none\n  | Node.collision keys vals heq, _, k => findAtAux keys vals heq 0 k", "start": [139, 1], "end": [146, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.find?", "code": "def find? {_ : BEq \u03b1} {_ : Hashable \u03b1} : PersistentHashMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 Option \u03b2\n  | { root := n, .. }, k => findAux n (hash k |>.toUSize) k", "start": [148, 1], "end": [149, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.findD", "code": "@[inline] def findD {_ : BEq \u03b1} {_ : Hashable \u03b1} (m : PersistentHashMap \u03b1 \u03b2) (a : \u03b1) (b\u2080 : \u03b2) : \u03b2 :=\n  (m.find? a).getD b\u2080", "start": [154, 1], "end": [155, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.find!", "code": "@[inline] def find! {_ : BEq \u03b1} {_ : Hashable \u03b1} [Inhabited \u03b2] (m : PersistentHashMap \u03b1 \u03b2) (a : \u03b1) : \u03b2 :=\n  match m.find? a with\n  | some b => b\n  | none   => panic! \"key is not in the map\"", "start": [157, 1], "end": [160, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.findEntryAtAux", "code": "partial def findEntryAtAux [BEq \u03b1] (keys : Array \u03b1) (vals : Array \u03b2) (heq : keys.size = vals.size) (i : Nat) (k : \u03b1) : Option (\u03b1 \u00d7 \u03b2) :=\n  if h : i < keys.size then\n    let k' := keys[i]\n    have : i < vals.size := by rw [\u2190heq]; assumption\n    if k == k' then some (k', vals[i])\n    else findEntryAtAux keys vals heq (i+1) k\n  else none", "start": [162, 1], "end": [168, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.findEntryAux", "code": "partial def findEntryAux [BEq \u03b1] : Node \u03b1 \u03b2 \u2192 USize \u2192 \u03b1 \u2192 Option (\u03b1 \u00d7 \u03b2)\n  | Node.entries entries, h, k =>\n    let j     := (mod2Shift h shift).toNat\n    match entries.get! j with\n    | Entry.null       => none\n    | Entry.ref node   => findEntryAux node (div2Shift h shift) k\n    | Entry.entry k' v => if k == k' then some (k', v) else none\n  | Node.collision keys vals heq, _, k => findEntryAtAux keys vals heq 0 k", "start": [170, 1], "end": [177, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.findEntry?", "code": "def findEntry? {_ : BEq \u03b1} {_ : Hashable \u03b1} : PersistentHashMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 Option (\u03b1 \u00d7 \u03b2)\n  | { root := n, .. }, k => findEntryAux n (hash k |>.toUSize) k", "start": [179, 1], "end": [180, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.containsAtAux", "code": "partial def containsAtAux [BEq \u03b1] (keys : Array \u03b1) (vals : Array \u03b2) (heq : keys.size = vals.size) (i : Nat) (k : \u03b1) : Bool :=\n  if h : i < keys.size then\n    let k' := keys[i]\n    if k == k' then true\n    else containsAtAux keys vals heq (i+1) k\n  else false", "start": [182, 1], "end": [187, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.containsAux", "code": "partial def containsAux [BEq \u03b1] : Node \u03b1 \u03b2 \u2192 USize \u2192 \u03b1 \u2192 Bool\n  | Node.entries entries, h, k =>\n    let j     := (mod2Shift h shift).toNat\n    match entries.get! j with\n    | Entry.null       => false\n    | Entry.ref node   => containsAux node (div2Shift h shift) k\n    | Entry.entry k' _ => k == k'\n  | Node.collision keys vals heq, _, k => containsAtAux keys vals heq 0 k", "start": [189, 1], "end": [196, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.contains", "code": "def contains [BEq \u03b1] [Hashable \u03b1] : PersistentHashMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 Bool\n  | { root := n, .. }, k => containsAux n (hash k |>.toUSize) k", "start": [198, 1], "end": [199, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.isUnaryEntries", "code": "partial def isUnaryEntries (a : Array (Entry \u03b1 \u03b2 (Node \u03b1 \u03b2))) (i : Nat) (acc : Option (\u03b1 \u00d7 \u03b2)) : Option (\u03b1 \u00d7 \u03b2) :=\n  if h : i < a.size then\n    match a[i] with\n    | Entry.null      => isUnaryEntries a (i+1) acc\n    | Entry.ref _     => none\n    | Entry.entry k v =>\n      match acc with\n      | none   => isUnaryEntries a (i+1) (some (k, v))\n      | some _ => none\n  else acc", "start": [201, 1], "end": [210, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.isUnaryNode", "code": "def isUnaryNode : Node \u03b1 \u03b2 \u2192 Option (\u03b1 \u00d7 \u03b2)\n  | Node.entries entries         => isUnaryEntries entries 0 none\n  | Node.collision keys vals heq =>\n    if h : 1 = keys.size then\n      have : 0 < keys.size := by rw [\u2190h]; decide\n      have : 0 < vals.size := by rw [\u2190heq]; assumption\n      some (keys[0], vals[0])\n    else\n      none", "start": [212, 1], "end": [220, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.eraseAux", "code": "partial def eraseAux [BEq \u03b1] : Node \u03b1 \u03b2 \u2192 USize \u2192 \u03b1 \u2192 Node \u03b1 \u03b2 \u00d7 Bool\n  | n@(Node.collision keys vals heq), _, k =>\n    match keys.indexOf? k with\n    | some idx =>\n      let \u27e8keys', keq\u27e9 := keys.eraseIdx' idx\n      let \u27e8vals', veq\u27e9 := vals.eraseIdx' (Eq.ndrec idx heq)\n      have : keys.size - 1 = vals.size - 1 := by rw [heq]\n      (Node.collision keys' vals' (keq.trans (this.trans veq.symm)), true)\n    | none     => (n, false)\n  | n@(Node.entries entries), h, k =>\n    let j       := (mod2Shift h shift).toNat\n    let entry   := entries.get! j\n    match entry with\n    | Entry.null       => (n, false)\n    | Entry.entry k' _ =>\n      if k == k' then (Node.entries (entries.set! j Entry.null), true) else (n, false)\n    | Entry.ref node   =>\n      let entries := entries.set! j Entry.null\n      let (newNode, deleted) := eraseAux node (div2Shift h shift) k\n      if !deleted then (n, false)\n      else match isUnaryNode newNode with\n        | none        => (Node.entries (entries.set! j (Entry.ref newNode)), true)\n        | some (k, v) => (Node.entries (entries.set! j (Entry.entry k v)), true)", "start": [222, 1], "end": [244, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.erase", "code": "def erase {_ : BEq \u03b1} {_ : Hashable \u03b1} : PersistentHashMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 PersistentHashMap \u03b1 \u03b2\n  | { root := n, size := sz }, k =>\n    let h := hash k |>.toUSize\n    let (n, del) := eraseAux n h k\n    { root := n, size := if del then sz - 1 else sz }", "start": [246, 1], "end": [250, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.foldlMAux", "code": "partial def foldlMAux (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03c3) : Node \u03b1 \u03b2 \u2192 \u03c3 \u2192 m \u03c3\n  | Node.collision keys vals heq, acc =>\n    let rec traverse (i : Nat) (acc : \u03c3) : m \u03c3 := do\n      if h : i < keys.size then\n        let k := keys[i]\n        have : i < vals.size := heq \u25b8 h\n        let v := vals[i]\n        traverse (i+1) (\u2190 f acc k v)\n      else\n        pure acc\n    traverse 0 acc\n  | Node.entries entries, acc => entries.foldlM (fun acc entry =>\n    match entry with\n    | Entry.null      => pure acc\n    | Entry.entry k v => f acc k v\n    | Entry.ref node  => foldlMAux f node acc)\n    acc", "start": [256, 1], "end": [272, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.foldlM", "code": "def foldlM {_ : BEq \u03b1} {_ : Hashable \u03b1} (map : PersistentHashMap \u03b1 \u03b2) (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03c3) (init : \u03c3) : m \u03c3 :=\n  foldlMAux f map.root init", "start": [274, 1], "end": [275, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.forM", "code": "def forM {_ : BEq \u03b1} {_ : Hashable \u03b1} (map : PersistentHashMap \u03b1 \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) : m PUnit :=\n  map.foldlM (fun _ => f) \u27e8\u27e9", "start": [277, 1], "end": [278, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.foldl", "code": "def foldl {_ : BEq \u03b1} {_ : Hashable \u03b1} (map : PersistentHashMap \u03b1 \u03b2) (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03c3) (init : \u03c3) : \u03c3 :=\n  Id.run <| map.foldlM f init", "start": [280, 1], "end": [281, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.forIn", "code": "protected def forIn {_ : BEq \u03b1} {_ : Hashable \u03b1} [Monad m]\n    (map : PersistentHashMap \u03b1 \u03b2) (init : \u03c3) (f : \u03b1 \u00d7 \u03b2 \u2192 \u03c3 \u2192 m (ForInStep \u03c3)) : m \u03c3 := do\n  let intoError : ForInStep \u03c3 \u2192 Except \u03c3 \u03c3\n  | .done s => .error s\n  | .yield s => .ok s\n  let result \u2190 foldlM (m := ExceptT \u03c3 m) map (init := init) fun s a b =>\n    (intoError <$> f (a, b) s : m _)\n  match result with\n  | .ok s | .error s => pure s", "start": [283, 1], "end": [291, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.mapMAux", "code": "partial def mapMAux {\u03b1 : Type u} {\u03b2 : Type v} {\u03c3 : Type u} {m : Type u \u2192 Type w} [Monad m] (f : \u03b2 \u2192 m \u03c3) (n : Node \u03b1 \u03b2) : m (Node \u03b1 \u03c3) := do\n  match n with\n  | .collision keys vals heq =>\n    let \u27e8vals', h\u27e9 \u2190 vals.mapM' f\n    return .collision keys vals' (h \u25b8 heq)\n  | .entries entries =>\n    let entries' \u2190 entries.mapM fun\n      | .null      => return .null\n      | .entry k v => return .entry k (\u2190 f v)\n      | .ref node  => return .ref (\u2190 mapMAux f node)\n    return .entries entries'", "start": [298, 1], "end": [308, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.mapM", "code": "def mapM {\u03b1 : Type u} {\u03b2 : Type v} {\u03c3 : Type u} {m : Type u \u2192 Type w} [Monad m] {_ : BEq \u03b1} {_ : Hashable \u03b1} (pm : PersistentHashMap \u03b1 \u03b2) (f : \u03b2 \u2192 m \u03c3) : m (PersistentHashMap \u03b1 \u03c3) := do\n  let root \u2190 mapMAux f pm.root\n  return { pm with root }", "start": [310, 1], "end": [312, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.map", "code": "def map {\u03b1 : Type u} {\u03b2 : Type v} {\u03c3 : Type u} {_ : BEq \u03b1} {_ : Hashable \u03b1} (pm : PersistentHashMap \u03b1 \u03b2) (f : \u03b2 \u2192 \u03c3) : PersistentHashMap \u03b1 \u03c3 :=\n  Id.run <| pm.mapM f", "start": [314, 1], "end": [315, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.toList", "code": "def toList {_ : BEq \u03b1} {_ : Hashable \u03b1} (m : PersistentHashMap \u03b1 \u03b2) : List (\u03b1 \u00d7 \u03b2) :=\n  m.foldl (init := []) fun ps k v => (k, v) :: ps", "start": [317, 1], "end": [318, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.Stats", "code": "structure Stats where\n  numNodes      : Nat := 0\n  numNull       : Nat := 0\n  numCollisions : Nat := 0\n  maxDepth      : Nat := 0", "start": [320, 1], "end": [324, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.collectStats", "code": "partial def collectStats : Node \u03b1 \u03b2 \u2192 Stats \u2192 Nat \u2192 Stats\n  | Node.collision keys _ _, stats, depth =>\n    { stats with\n      numNodes      := stats.numNodes + 1,\n      numCollisions := stats.numCollisions + keys.size - 1,\n      maxDepth      := Nat.max stats.maxDepth depth }\n  | Node.entries entries, stats, depth =>\n    let stats :=\n      { stats with\n        numNodes      := stats.numNodes + 1,\n        maxDepth      := Nat.max stats.maxDepth depth }\n    entries.foldl (fun stats entry =>\n      match entry with\n      | Entry.null      => { stats with numNull := stats.numNull + 1 }\n      | Entry.ref node  => collectStats node stats (depth + 1)\n      | Entry.entry _ _ => stats)\n      stats", "start": [326, 1], "end": [342, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.stats", "code": "def stats {_ : BEq \u03b1} {_ : Hashable \u03b1} (m : PersistentHashMap \u03b1 \u03b2) : Stats :=\n  collectStats m.root {} 1", "start": [344, 1], "end": [345, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashMap.Stats.toString", "code": "def Stats.toString (s : Stats) : String :=\n  s!\"\\{ nodes := {s.numNodes}, null := {s.numNull}, collisions := {s.numCollisions}, depth := {s.maxDepth}}\"", "start": [347, 1], "end": [348, 109], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/AssocList.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.HashMapBucket", "code": "def HashMapBucket (\u03b1 : Type u) (\u03b2 : Type v) :=\n  { b : Array (AssocList \u03b1 \u03b2) // b.size.isPowerOfTwo }", "start": [9, 1], "end": [10, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapBucket.update", "code": "def HashMapBucket.update {\u03b1 : Type u} {\u03b2 : Type v} (data : HashMapBucket \u03b1 \u03b2) (i : USize) (d : AssocList \u03b1 \u03b2) (h : i.toNat < data.val.size) : HashMapBucket \u03b1 \u03b2 :=\n  \u27e8 data.val.uset i d h,\n    by erw [Array.size_set]; apply data.property \u27e9", "start": [12, 1], "end": [14, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp", "code": "structure HashMapImp (\u03b1 : Type u) (\u03b2 : Type v) where\n  size       : Nat\n  buckets    : HashMapBucket \u03b1 \u03b2", "start": [16, 1], "end": [18, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.numBucketsForCapacity", "code": "private def numBucketsForCapacity (capacity : Nat) : Nat :=\n  capacity * 4 / 3", "start": [20, 1], "end": [22, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.mkHashMapImp", "code": "def mkHashMapImp {\u03b1 : Type u} {\u03b2 : Type v} (capacity := 8) : HashMapImp \u03b1 \u03b2 :=\n  { size       := 0\n    buckets    :=\n    \u27e8mkArray (numBucketsForCapacity capacity).nextPowerOfTwo AssocList.nil,\n     by simp; apply Nat.isPowerOfTwo_nextPowerOfTwo\u27e9 }", "start": [24, 1], "end": [28, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.mkIdx", "code": "@[extern \"lean_hashmap_mk_idx\"]\nprivate def mkIdx {sz : Nat} (hash : UInt64) (h : sz.isPowerOfTwo) : { u : USize // u.toNat < sz } :=\n  let u := hash.toUSize &&& (sz.toUSize - 1)\n  if h' : u.toNat < sz then\n    \u27e8u, h'\u27e9\n  else\n    \u27e80, by simp [USize.toNat, OfNat.ofNat, USize.ofNat, Fin.ofNat']; apply Nat.pos_of_isPowerOfTwo h\u27e9", "start": [34, 1], "end": [41, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.reinsertAux", "code": "@[inline] def reinsertAux (hashFn : \u03b1 \u2192 UInt64) (data : HashMapBucket \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) : HashMapBucket \u03b1 \u03b2 :=\n  let \u27e8i, h\u27e9 := mkIdx (hashFn a) data.property\n  data.update i (AssocList.cons a b data.val[i]) h", "start": [43, 1], "end": [45, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.foldBucketsM", "code": "@[inline] def foldBucketsM {\u03b4 : Type w} {m : Type w \u2192 Type w} [Monad m] (data : HashMapBucket \u03b1 \u03b2) (d : \u03b4) (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b4) : m \u03b4 :=\n  data.val.foldlM (init := d) fun d b => b.foldlM f d", "start": [47, 1], "end": [48, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.foldBuckets", "code": "@[inline] def foldBuckets {\u03b4 : Type w} (data : HashMapBucket \u03b1 \u03b2) (d : \u03b4) (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b4) : \u03b4 :=\n  Id.run $ foldBucketsM data d f", "start": [50, 1], "end": [51, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.foldM", "code": "@[inline] def foldM {\u03b4 : Type w} {m : Type w \u2192 Type w} [Monad m] (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b4) (d : \u03b4) (h : HashMapImp \u03b1 \u03b2) : m \u03b4 :=\n  foldBucketsM h.buckets d f", "start": [53, 1], "end": [54, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.fold", "code": "@[inline] def fold {\u03b4 : Type w} (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b4) (d : \u03b4) (m : HashMapImp \u03b1 \u03b2) : \u03b4 :=\n  foldBuckets m.buckets d f", "start": [56, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.forBucketsM", "code": "@[inline] def forBucketsM {m : Type w \u2192 Type w} [Monad m] (data : HashMapBucket \u03b1 \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) : m PUnit :=\n  data.val.forM fun b => b.forM f", "start": [59, 1], "end": [60, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.forM", "code": "@[inline] def forM {m : Type w \u2192 Type w} [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) (h : HashMapImp \u03b1 \u03b2) : m PUnit :=\n  forBucketsM h.buckets f", "start": [62, 1], "end": [63, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.findEntry?", "code": "def findEntry? [BEq \u03b1] [Hashable \u03b1] (m : HashMapImp \u03b1 \u03b2) (a : \u03b1) : Option (\u03b1 \u00d7 \u03b2) :=\n  match m with\n  | \u27e8_, buckets\u27e9 =>\n    let \u27e8i, h\u27e9 := mkIdx (hash a) buckets.property\n    buckets.val[i].findEntry? a", "start": [65, 1], "end": [69, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.find?", "code": "def find? [beq : BEq \u03b1] [Hashable \u03b1] (m : HashMapImp \u03b1 \u03b2) (a : \u03b1) : Option \u03b2 :=\n  match m with\n  | \u27e8_, buckets\u27e9 =>\n    let \u27e8i, h\u27e9 := mkIdx (hash a) buckets.property\n    buckets.val[i].find? a", "start": [71, 1], "end": [75, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.contains", "code": "def contains [BEq \u03b1] [Hashable \u03b1] (m : HashMapImp \u03b1 \u03b2) (a : \u03b1) : Bool :=\n  match m with\n  | \u27e8_, buckets\u27e9 =>\n    let \u27e8i, h\u27e9 := mkIdx (hash a) buckets.property\n    buckets.val[i].contains a", "start": [77, 1], "end": [81, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.moveEntries", "code": "def moveEntries [Hashable \u03b1] (i : Nat) (source : Array (AssocList \u03b1 \u03b2)) (target : HashMapBucket \u03b1 \u03b2) : HashMapBucket \u03b1 \u03b2 :=\n  if h : i < source.size then\n     let idx : Fin source.size := \u27e8i, h\u27e9\n     let es  : AssocList \u03b1 \u03b2   := source.get idx\n     let source                := source.set idx AssocList.nil\n     let target                := es.foldl (reinsertAux hash) target\n     moveEntries (i+1) source target\n  else target\ntermination_by _ i source _ => source.size - i", "start": [83, 1], "end": [92, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.expand", "code": "def expand [Hashable \u03b1] (size : Nat) (buckets : HashMapBucket \u03b1 \u03b2) : HashMapImp \u03b1 \u03b2 :=\n  let bucketsNew : HashMapBucket \u03b1 \u03b2 := \u27e8\n    mkArray (buckets.val.size * 2) AssocList.nil,\n    by simp; apply Nat.mul2_isPowerOfTwo_of_isPowerOfTwo buckets.property\n  \u27e9\n  { size    := size,\n    buckets := moveEntries 0 buckets.val bucketsNew }", "start": [94, 1], "end": [100, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.insert", "code": "@[inline] def insert [beq : BEq \u03b1] [Hashable \u03b1] (m : HashMapImp \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) : HashMapImp \u03b1 \u03b2 \u00d7 Bool :=\n  match m with\n  | \u27e8size, buckets\u27e9 =>\n    let \u27e8i, h\u27e9 := mkIdx (hash a) buckets.property\n    let bkt    := buckets.val[i]\n    if bkt.contains a then\n      (\u27e8size, buckets.update i (bkt.replace a b) h\u27e9, true)\n    else\n      let size'    := size + 1\n      let buckets' := buckets.update i (AssocList.cons a b bkt) h\n      if numBucketsForCapacity size' \u2264 buckets.val.size then\n        ({ size := size', buckets := buckets' }, false)\n      else\n        (expand size' buckets', false)", "start": [102, 1], "end": [115, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.erase", "code": "def erase [BEq \u03b1] [Hashable \u03b1] (m : HashMapImp \u03b1 \u03b2) (a : \u03b1) : HashMapImp \u03b1 \u03b2 :=\n  match m with\n  | \u27e8 size, buckets \u27e9 =>\n    let \u27e8i, h\u27e9 := mkIdx (hash a) buckets.property\n    let bkt    := buckets.val[i]\n    if bkt.contains a then \u27e8size - 1, buckets.update i (bkt.erase a) h\u27e9\n    else m", "start": [117, 1], "end": [123, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMapImp.WellFormed", "code": "inductive WellFormed [BEq \u03b1] [Hashable \u03b1] : HashMapImp \u03b1 \u03b2 \u2192 Prop where\n  | mkWff     : \u2200 n,                    WellFormed (mkHashMapImp n)\n  | insertWff : \u2200 m a b, WellFormed m \u2192 WellFormed (insert m a b |>.1)\n  | eraseWff  : \u2200 m a,   WellFormed m \u2192 WellFormed (erase m a)", "start": [125, 1], "end": [128, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap", "code": "def HashMap (\u03b1 : Type u) (\u03b2 : Type v) [BEq \u03b1] [Hashable \u03b1] :=\n  { m : HashMapImp \u03b1 \u03b2 // m.WellFormed }", "start": [132, 1], "end": [133, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.mkHashMap", "code": "def mkHashMap {\u03b1 : Type u} {\u03b2 : Type v} [BEq \u03b1] [Hashable \u03b1] (capacity := 8) : HashMap \u03b1 \u03b2 :=\n  \u27e8 mkHashMapImp capacity, WellFormed.mkWff capacity \u27e9", "start": [137, 1], "end": [138, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.empty", "code": "@[inline] def empty [BEq \u03b1] [Hashable \u03b1] : HashMap \u03b1 \u03b2 :=\n  mkHashMap", "start": [146, 1], "end": [147, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.insert", "code": "def insert (m : HashMap \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) : HashMap \u03b1 \u03b2 :=\n  match m with\n  | \u27e8 m, hw \u27e9 =>\n    match h:m.insert a b with\n    | (m', _) => \u27e8 m', by have aux := WellFormed.insertWff m a b hw; rw [h] at aux; assumption \u27e9", "start": [151, 1], "end": [155, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.insert'", "code": "def insert' (m : HashMap \u03b1 \u03b2) (a : \u03b1) (b : \u03b2) : HashMap \u03b1 \u03b2 \u00d7 Bool :=\n  match m with\n  | \u27e8 m, hw \u27e9 =>\n    match h:m.insert a b with\n    | (m', replaced) => (\u27e8 m', by have aux := WellFormed.insertWff m a b hw; rw [h] at aux; assumption \u27e9, replaced)", "start": [157, 1], "end": [162, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.erase", "code": "@[inline] def erase (m : HashMap \u03b1 \u03b2) (a : \u03b1) : HashMap \u03b1 \u03b2 :=\n  match m with\n  | \u27e8 m, hw \u27e9 => \u27e8 m.erase a, WellFormed.eraseWff m a hw \u27e9", "start": [164, 1], "end": [166, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.findEntry?", "code": "@[inline] def findEntry? (m : HashMap \u03b1 \u03b2) (a : \u03b1) : Option (\u03b1 \u00d7 \u03b2) :=\n  match m with\n  | \u27e8 m, _ \u27e9 => m.findEntry? a", "start": [168, 1], "end": [170, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.find?", "code": "@[inline] def find? (m : HashMap \u03b1 \u03b2) (a : \u03b1) : Option \u03b2 :=\n  match m with\n  | \u27e8 m, _ \u27e9 => m.find? a", "start": [172, 1], "end": [174, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.findD", "code": "@[inline] def findD (m : HashMap \u03b1 \u03b2) (a : \u03b1) (b\u2080 : \u03b2) : \u03b2 :=\n  (m.find? a).getD b\u2080", "start": [176, 1], "end": [177, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.find!", "code": "@[inline] def find! [Inhabited \u03b2] (m : HashMap \u03b1 \u03b2) (a : \u03b1) : \u03b2 :=\n  match m.find? a with\n  | some b => b\n  | none   => panic! \"key is not in the map\"", "start": [179, 1], "end": [182, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.contains", "code": "@[inline] def contains (m : HashMap \u03b1 \u03b2) (a : \u03b1) : Bool :=\n  match m with\n  | \u27e8 m, _ \u27e9 => m.contains a", "start": [187, 1], "end": [189, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.foldM", "code": "@[inline] def foldM {\u03b4 : Type w} {m : Type w \u2192 Type w} [Monad m] (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b4) (init : \u03b4) (h : HashMap \u03b1 \u03b2) : m \u03b4 :=\n  match h with\n  | \u27e8 h, _ \u27e9 => h.foldM f init", "start": [191, 1], "end": [193, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.fold", "code": "@[inline] def fold {\u03b4 : Type w} (f : \u03b4 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b4) (init : \u03b4) (m : HashMap \u03b1 \u03b2) : \u03b4 :=\n  match m with\n  | \u27e8 m, _ \u27e9 => m.fold f init", "start": [195, 1], "end": [197, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.forM", "code": "@[inline] def forM {m : Type w \u2192 Type w} [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) (h : HashMap \u03b1 \u03b2) : m PUnit :=\n  match h with\n  | \u27e8 h, _ \u27e9 => h.forM f", "start": [199, 1], "end": [201, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.size", "code": "@[inline] def size (m : HashMap \u03b1 \u03b2) : Nat :=\n  match m with\n  | \u27e8 {size := sz, ..}, _ \u27e9 => sz", "start": [203, 1], "end": [205, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.isEmpty", "code": "@[inline] def isEmpty (m : HashMap \u03b1 \u03b2) : Bool :=\n  m.size = 0", "start": [207, 1], "end": [208, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.toList", "code": "def toList (m : HashMap \u03b1 \u03b2) : List (\u03b1 \u00d7 \u03b2) :=\n  m.fold (init := []) fun r k v => (k, v)::r", "start": [210, 1], "end": [211, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.toArray", "code": "def toArray (m : HashMap \u03b1 \u03b2) : Array (\u03b1 \u00d7 \u03b2) :=\n  m.fold (init := #[]) fun r k v => r.push (k, v)", "start": [213, 1], "end": [214, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.numBuckets", "code": "def numBuckets (m : HashMap \u03b1 \u03b2) : Nat :=\n  m.val.buckets.val.size", "start": [216, 1], "end": [217, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.ofList", "code": "def ofList (l : List (\u03b1 \u00d7 \u03b2)) : HashMap \u03b1 \u03b2 :=\n  l.foldl (init := HashMap.empty) (fun m p => m.insert p.fst p.snd)", "start": [219, 1], "end": [221, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.HashMap.ofListWith", "code": "def ofListWith (l : List (\u03b1 \u00d7 \u03b2)) (f : \u03b2 \u2192 \u03b2 \u2192 \u03b2) : HashMap \u03b1 \u03b2 :=\n  l.foldl (init := HashMap.empty)\n    (fun m p =>\n      match m.find? p.fst with\n        | none   => m.insert p.fst p.snd\n        | some v => m.insert p.fst $ f v p.snd)", "start": [223, 1], "end": [229, 48], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.RBColor", "code": "inductive RBColor where\n  | red | black", "start": [9, 1], "end": [10, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode", "code": "inductive RBNode (\u03b1 : Type u) (\u03b2 : \u03b1 \u2192 Type v) where\n  | leaf                                                                                        : RBNode \u03b1 \u03b2\n  | node  (color : RBColor) (lchild : RBNode \u03b1 \u03b2) (key : \u03b1) (val : \u03b2 key) (rchild : RBNode \u03b1 \u03b2) : RBNode \u03b1 \u03b2", "start": [12, 1], "end": [14, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.depth", "code": "def depth (f : Nat \u2192 Nat \u2192 Nat) : RBNode \u03b1 \u03b2 \u2192 Nat\n  | leaf           => 0\n  | node _ l _ _ r => succ (f (depth f l) (depth f r))", "start": [21, 1], "end": [23, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.min", "code": "protected def min : RBNode \u03b1 \u03b2 \u2192 Option (Sigma (fun k => \u03b2 k))\n  | leaf              => none\n  | node _ leaf k v _ => some \u27e8k, v\u27e9\n  | node _ l _ _ _    => RBNode.min l", "start": [25, 1], "end": [28, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.max", "code": "protected def max : RBNode \u03b1 \u03b2 \u2192 Option (Sigma (fun k => \u03b2 k))\n  | leaf              => none\n  | node _ _ k v leaf => some \u27e8k, v\u27e9\n  | node _ _ _ _ r    => RBNode.max r", "start": [30, 1], "end": [33, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.fold", "code": "@[specialize] def fold (f : \u03c3 \u2192 (k : \u03b1) \u2192 \u03b2 k \u2192 \u03c3) : (init : \u03c3) \u2192 RBNode \u03b1 \u03b2 \u2192 \u03c3\n  | b, leaf           => b\n  | b, node _ l k v r => fold f (f (fold f b l) k v) r", "start": [35, 1], "end": [37, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.forM", "code": "@[specialize] def forM [Monad m] (f : (k : \u03b1) \u2192 \u03b2 k \u2192 m Unit) : RBNode \u03b1 \u03b2 \u2192 m Unit\n  | leaf           => pure ()\n  | node _ l k v r => do forM f l; f k v; forM f r", "start": [39, 1], "end": [41, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.foldM", "code": "@[specialize] def foldM [Monad m] (f : \u03c3 \u2192 (k : \u03b1) \u2192 \u03b2 k \u2192 m \u03c3) : (init : \u03c3) \u2192 RBNode \u03b1 \u03b2 \u2192 m \u03c3\n  | b, leaf           => pure b\n  | b, node _ l k v r => do\n    let b \u2190 foldM f b l\n    let b \u2190 f b k v\n    foldM f b r", "start": [43, 1], "end": [48, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.forIn", "code": "@[inline] protected def forIn [Monad m] (as : RBNode \u03b1 \u03b2) (init : \u03c3) (f : (k : \u03b1) \u2192 \u03b2 k \u2192 \u03c3 \u2192 m (ForInStep \u03c3)) : m \u03c3 := do\n  let rec @[specialize] visit : RBNode \u03b1 \u03b2 \u2192 \u03c3 \u2192 m (ForInStep \u03c3)\n    | leaf, b           => return ForInStep.yield b\n    | node _ l k v r, b => do\n      match (\u2190 visit l b) with\n      | r@(ForInStep.done _) => return r\n      | ForInStep.yield b    =>\n        match (\u2190 f k v b) with\n        | r@(ForInStep.done _) => return r\n        | ForInStep.yield b    => visit r b\n  match (\u2190 visit as init) with\n  | ForInStep.done b  => pure b\n  | ForInStep.yield b => pure b", "start": [50, 1], "end": [62, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.revFold", "code": "@[specialize] def revFold (f : \u03c3 \u2192 (k : \u03b1) \u2192 \u03b2 k \u2192 \u03c3) : (init : \u03c3) \u2192 RBNode \u03b1 \u03b2 \u2192 \u03c3\n  | b, leaf           => b\n  | b, node _ l k v r => revFold f (f (revFold f b r) k v) l", "start": [64, 1], "end": [66, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.all", "code": "@[specialize] def all (p : (k : \u03b1) \u2192 \u03b2 k \u2192 Bool) : RBNode \u03b1 \u03b2 \u2192 Bool\n  | leaf           => true\n  | node _ l k v r => p k v && all p l && all p r", "start": [68, 1], "end": [70, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.any", "code": "@[specialize] def any (p : (k : \u03b1) \u2192 \u03b2 k \u2192 Bool) : RBNode \u03b1 \u03b2 \u2192 Bool\n  | leaf             => false\n  | node _ l k v r => p k v || any p l || any p r", "start": [72, 1], "end": [74, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.singleton", "code": "def singleton (k : \u03b1) (v : \u03b2 k) : RBNode \u03b1 \u03b2 :=\n  node red leaf k v leaf", "start": [76, 1], "end": [77, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.balance1", "code": "@[inline] def balance1 : RBNode \u03b1 \u03b2 \u2192 (a : \u03b1) \u2192 \u03b2 a \u2192 RBNode \u03b1 \u03b2 \u2192 RBNode \u03b1 \u03b2\n  | node red (node red a kx vx b) ky vy c, kz, vz, d\n  | node red a kx vx (node red b ky vy c), kz, vz, d => node red (node black a kx vx b) ky vy (node black c kz vz d)\n  | a,                                     kx, vx, b => node black a kx vx b", "start": [80, 1], "end": [83, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.balance2", "code": "@[inline] def balance2 : RBNode \u03b1 \u03b2 \u2192 (a : \u03b1) \u2192 \u03b2 a \u2192 RBNode \u03b1 \u03b2 \u2192 RBNode \u03b1 \u03b2\n  | a, kx, vx, node red (node red b ky vy c) kz vz d\n  | a, kx, vx, node red b ky vy (node red c kz vz d) => node red (node black a kx vx b) ky vy (node black c kz vz d)\n  | a, kx, vx, b                                     => node black a kx vx b", "start": [86, 1], "end": [89, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.isRed", "code": "def isRed : RBNode \u03b1 \u03b2 \u2192 Bool\n  | node red .. => true\n  | _           => false", "start": [91, 1], "end": [93, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.isBlack", "code": "def isBlack : RBNode \u03b1 \u03b2 \u2192 Bool\n  | node black .. => true\n  | _             => false", "start": [95, 1], "end": [97, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.ins", "code": "@[specialize] def ins : RBNode \u03b1 \u03b2 \u2192 (k : \u03b1) \u2192 \u03b2 k \u2192 RBNode \u03b1 \u03b2\n  | leaf,               kx, vx => node red leaf kx vx leaf\n  | node red a ky vy b, kx, vx =>\n    match cmp kx ky with\n    | Ordering.lt => node red (ins a kx vx) ky vy b\n    | Ordering.gt => node red a ky vy (ins b kx vx)\n    | Ordering.eq => node red a kx vx b\n  | node black a ky vy b, kx, vx =>\n    match cmp kx ky with\n    | Ordering.lt => balance1 (ins a kx vx) ky vy b\n    | Ordering.gt => balance2 a ky vy (ins b kx vx)\n    | Ordering.eq => node black a kx vx b", "start": [103, 1], "end": [114, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.setBlack", "code": "def setBlack : RBNode \u03b1 \u03b2 \u2192 RBNode \u03b1 \u03b2\n  | node _ l k v r => node black l k v r\n  | e              => e", "start": [116, 1], "end": [118, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.insert", "code": "@[specialize] def insert (t : RBNode \u03b1 \u03b2) (k : \u03b1) (v : \u03b2 k) : RBNode \u03b1 \u03b2 :=\n  if isRed t then setBlack (ins cmp t k v)\n  else ins cmp t k v", "start": [120, 1], "end": [122, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.setRed", "code": "def setRed : RBNode \u03b1 \u03b2 \u2192 RBNode \u03b1 \u03b2\n  | node _ a k v b => node red a k v b\n  | e              => e", "start": [126, 1], "end": [128, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.balLeft", "code": "def balLeft : RBNode \u03b1 \u03b2 \u2192 (k : \u03b1) \u2192 \u03b2 k \u2192 RBNode \u03b1 \u03b2 \u2192 RBNode \u03b1 \u03b2\n  | node red a kx vx b,   k, v, r                    => node red (node black a kx vx b) k v r\n  | l, k, v, node black a ky vy b                    => balance2 l k v (node red a ky vy b)\n  | l, k, v, node red (node black a ky vy b) kz vz c => node red (node black l k v a) ky vy (balance2 b kz vz (setRed c))\n  | l, k, v, r                                       => node red l k v r", "start": [130, 1], "end": [134, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.balRight", "code": "def balRight (l : RBNode \u03b1 \u03b2) (k : \u03b1) (v : \u03b2 k) (r : RBNode \u03b1 \u03b2) : RBNode \u03b1 \u03b2 :=\n  match r with\n  | (node red b ky vy c) => node red l k v (node black b ky vy c)\n  | _ => match l with\n    | node black a kx vx b                    => balance1 (node red a kx vx b) k v r\n    | node red a kx vx (node black b ky vy c) => node red (balance1 (setRed a) kx vx b) ky vy (node black c k v r)\n    | _                                       => node red l k v r", "start": [136, 1], "end": [142, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.size", "code": "@[local simp] def size : RBNode \u03b1 \u03b2 \u2192 Nat\n  | leaf => 0\n  | node _ x _ _ y => x.size + y.size + 1", "start": [144, 1], "end": [147, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.appendTrees", "code": "def appendTrees :  RBNode \u03b1 \u03b2 \u2192 RBNode \u03b1 \u03b2 \u2192 RBNode \u03b1 \u03b2\n  | leaf, x => x\n  | x, leaf => x\n  | node red a kx vx b,   node red c ky vy d   =>\n    match appendTrees b c with\n    | node red b' kz vz c' => node red (node red a kx vx b') kz vz (node red c' ky vy d)\n    | bc                   => node red a kx vx (node red bc ky vy d)\n  | node black a kx vx b,   node black c ky vy d   =>\n     match appendTrees b c with\n     | node red b' kz vz c' => node red (node black a kx vx b') kz vz (node black c' ky vy d)\n     | bc                   => balLeft a kx vx (node black bc ky vy d)\n   | a, node red b kx vx c   => node red (appendTrees a b) kx vx c\n   | node red a kx vx b,   c => node red a kx vx (appendTrees b c)\ntermination_by _ x y => x.size + y.size", "start": [149, 1], "end": [162, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.del", "code": "@[specialize] def del (x : \u03b1) : RBNode \u03b1 \u03b2 \u2192 RBNode \u03b1 \u03b2\n  | leaf           => leaf\n  | node _ a y v b =>\n    match cmp x y with\n    | Ordering.lt =>\n      if a.isBlack then balLeft (del x a) y v b\n      else node red (del x a) y v b\n    | Ordering.gt =>\n      if b.isBlack then balRight a y v (del x b)\n      else node red a y v (del x b)\n    | Ordering.eq => appendTrees a b", "start": [168, 1], "end": [178, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.erase", "code": "@[specialize] def erase (x : \u03b1) (t : RBNode \u03b1 \u03b2) : RBNode \u03b1 \u03b2 :=\n  let t := del cmp x t;\n  t.setBlack", "start": [180, 1], "end": [182, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.findCore", "code": "@[specialize] def findCore : RBNode \u03b1 \u03b2 \u2192 (k : \u03b1) \u2192 Option (Sigma (fun k => \u03b2 k))\n  | leaf,             _ => none\n  | node _ a ky vy b, x =>\n    match cmp x ky with\n    | Ordering.lt => findCore a x\n    | Ordering.gt => findCore b x\n    | Ordering.eq => some \u27e8ky, vy\u27e9", "start": [189, 1], "end": [195, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.find", "code": "@[specialize] def find {\u03b2 : Type v} : RBNode \u03b1 (fun _ => \u03b2) \u2192 \u03b1 \u2192 Option \u03b2\n  | leaf,             _ => none\n  | node _ a ky vy b, x =>\n    match cmp x ky with\n    | Ordering.lt => find a x\n    | Ordering.gt => find b x\n    | Ordering.eq => some vy", "start": [197, 1], "end": [203, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.lowerBound", "code": "@[specialize] def lowerBound : RBNode \u03b1 \u03b2 \u2192 \u03b1 \u2192 Option (Sigma \u03b2) \u2192 Option (Sigma \u03b2)\n  | leaf,             _, lb => lb\n  | node _ a ky vy b, x, lb =>\n    match cmp x ky with\n    | Ordering.lt => lowerBound a x lb\n    | Ordering.gt => lowerBound b x (some \u27e8ky, vy\u27e9)\n    | Ordering.eq => some \u27e8ky, vy\u27e9", "start": [205, 1], "end": [211, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.WellFormed", "code": "inductive WellFormed (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBNode \u03b1 \u03b2 \u2192 Prop where\n  | leafWff : WellFormed cmp leaf\n  | insertWff {n n' : RBNode \u03b1 \u03b2} {k : \u03b1} {v : \u03b2 k} : WellFormed cmp n \u2192 n' = insert cmp n k v \u2192 WellFormed cmp n'\n  | eraseWff {n n' : RBNode \u03b1 \u03b2} {k : \u03b1} : WellFormed cmp n \u2192 n' = erase cmp k n \u2192 WellFormed cmp n'", "start": [215, 1], "end": [218, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.mapM", "code": "@[specialize] def mapM {\u03b1 : Type v} {\u03b2 \u03b3 : \u03b1 \u2192 Type v} {M : Type v \u2192 Type v} [Applicative M]\n  (f : (a : \u03b1) \u2192 \u03b2 a \u2192 M (\u03b3 a))\n  : RBNode \u03b1 \u03b2 \u2192 M (RBNode \u03b1 \u03b3)\n  | leaf => pure leaf\n  | node color lchild key val rchild =>\n    pure (node color \u00b7 key \u00b7 \u00b7) <*> lchild.mapM f <*> f _ val <*> rchild.mapM f", "start": [222, 1], "end": [227, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.map", "code": "@[specialize] def map {\u03b1 : Type u} {\u03b2 \u03b3 : \u03b1 \u2192 Type v}\n  (f : (a : \u03b1) \u2192 \u03b2 a \u2192 \u03b3 a)\n  : RBNode \u03b1 \u03b2 \u2192 RBNode \u03b1 \u03b3\n  | leaf => leaf\n  | node color lchild key val rchild => node color (lchild.map f) key (f key val) (rchild.map f)", "start": [229, 1], "end": [233, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.RBNode.toArray", "code": "def toArray (n : RBNode \u03b1 \u03b2) : Array (Sigma \u03b2) :=\n  n.fold (init := \u2205) fun acc k v => acc.push \u27e8k,v\u27e9", "start": [237, 1], "end": [238, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap", "code": "def RBMap (\u03b1 : Type u) (\u03b2 : Type v) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : Type (max u v) :=\n  {t : RBNode \u03b1 (fun _ => \u03b2) // t.WellFormed cmp }", "start": [248, 1], "end": [249, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRBMap", "code": "@[inline] def mkRBMap (\u03b1 : Type u) (\u03b2 : Type v) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBMap \u03b1 \u03b2 cmp :=\n  \u27e8leaf, WellFormed.leafWff\u27e9", "start": [251, 1], "end": [252, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.empty", "code": "@[inline] def RBMap.empty {\u03b1 : Type u} {\u03b2 : Type v} {cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering} : RBMap \u03b1 \u03b2 cmp :=\n  mkRBMap ..", "start": [254, 1], "end": [255, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.depth", "code": "def depth (f : Nat \u2192 Nat \u2192 Nat) (t : RBMap \u03b1 \u03b2 cmp) : Nat :=\n  t.val.depth f", "start": [265, 1], "end": [266, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.fold", "code": "@[inline] def fold (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03c3) : (init : \u03c3) \u2192 RBMap \u03b1 \u03b2 cmp \u2192 \u03c3\n  | b, \u27e8t, _\u27e9 => t.fold f b", "start": [268, 1], "end": [269, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.revFold", "code": "@[inline] def revFold (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03c3) : (init : \u03c3) \u2192 RBMap \u03b1 \u03b2 cmp \u2192 \u03c3\n  | b, \u27e8t, _\u27e9 => t.revFold f b", "start": [271, 1], "end": [272, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.foldM", "code": "@[inline] def foldM [Monad m] (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03c3) : (init : \u03c3) \u2192 RBMap \u03b1 \u03b2 cmp \u2192 m \u03c3\n  | b, \u27e8t, _\u27e9 => t.foldM f b", "start": [274, 1], "end": [275, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.forM", "code": "@[inline] def forM [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) (t : RBMap \u03b1 \u03b2 cmp) : m PUnit :=\n  t.foldM (fun _ k v => f k v) \u27e8\u27e9", "start": [277, 1], "end": [278, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.forIn", "code": "@[inline] protected def forIn [Monad m] (t : RBMap \u03b1 \u03b2 cmp) (init : \u03c3) (f : (\u03b1 \u00d7 \u03b2) \u2192 \u03c3 \u2192 m (ForInStep \u03c3)) : m \u03c3 :=\n  t.val.forIn init (fun a b acc => f (a, b) acc)", "start": [280, 1], "end": [281, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.isEmpty", "code": "@[inline] def isEmpty : RBMap \u03b1 \u03b2 cmp \u2192 Bool\n  | \u27e8leaf, _\u27e9 => true\n  | _         => false", "start": [286, 1], "end": [288, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.toList", "code": "@[specialize] def toList : RBMap \u03b1 \u03b2 cmp \u2192 List (\u03b1 \u00d7 \u03b2)\n  | \u27e8t, _\u27e9 => t.revFold (fun ps k v => (k, v)::ps) []", "start": [290, 1], "end": [291, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.min", "code": "@[inline] protected def min : RBMap \u03b1 \u03b2 cmp \u2192 Option (\u03b1 \u00d7 \u03b2)\n  | \u27e8t, _\u27e9 =>\n    match t.min with\n    | some \u27e8k, v\u27e9 => some (k, v)\n    | none        => none", "start": [293, 1], "end": [298, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.max", "code": "@[inline] protected def max : RBMap \u03b1 \u03b2 cmp \u2192 Option (\u03b1 \u00d7 \u03b2)\n  | \u27e8t, _\u27e9 =>\n    match t.max with\n    | some \u27e8k, v\u27e9 => some (k, v)\n    | none        => none", "start": [300, 1], "end": [305, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.insert", "code": "@[inline] def insert : RBMap \u03b1 \u03b2 cmp \u2192 \u03b1 \u2192 \u03b2 \u2192 RBMap \u03b1 \u03b2 cmp\n  | \u27e8t, w\u27e9, k, v => \u27e8t.insert cmp k v, WellFormed.insertWff w rfl\u27e9", "start": [310, 1], "end": [311, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.erase", "code": "@[inline] def erase : RBMap \u03b1 \u03b2 cmp \u2192 \u03b1 \u2192 RBMap \u03b1 \u03b2 cmp\n  | \u27e8t, w\u27e9, k => \u27e8t.erase cmp k, WellFormed.eraseWff w rfl\u27e9", "start": [313, 1], "end": [314, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.ofList", "code": "@[specialize] def ofList : List (\u03b1 \u00d7 \u03b2) \u2192 RBMap \u03b1 \u03b2 cmp\n  | []        => mkRBMap ..\n  | \u27e8k,v\u27e9::xs => (ofList xs).insert k v", "start": [316, 1], "end": [318, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.findCore?", "code": "@[inline] def findCore? : RBMap \u03b1 \u03b2 cmp \u2192 \u03b1 \u2192 Option (Sigma (fun (_ : \u03b1) => \u03b2))\n  | \u27e8t, _\u27e9, x => t.findCore cmp x", "start": [320, 1], "end": [321, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.find?", "code": "@[inline] def find? : RBMap \u03b1 \u03b2 cmp \u2192 \u03b1 \u2192 Option \u03b2\n  | \u27e8t, _\u27e9, x => t.find cmp x", "start": [323, 1], "end": [324, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.findD", "code": "@[inline] def findD (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) (v\u2080 : \u03b2) : \u03b2 :=\n  (t.find? k).getD v\u2080", "start": [326, 1], "end": [327, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.lowerBound", "code": "@[inline] def lowerBound : RBMap \u03b1 \u03b2 cmp \u2192 \u03b1 \u2192 Option (Sigma (fun (_ : \u03b1) => \u03b2))\n  | \u27e8t, _\u27e9, x => t.lowerBound cmp x none", "start": [329, 1], "end": [332, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.contains", "code": "@[inline] def contains (t : RBMap \u03b1 \u03b2 cmp) (a : \u03b1) : Bool :=\n  (t.find? a).isSome", "start": [334, 1], "end": [336, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.fromList", "code": "@[inline] def fromList (l : List (\u03b1 \u00d7 \u03b2)) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBMap \u03b1 \u03b2 cmp :=\n  l.foldl (fun r p => r.insert p.1 p.2) (mkRBMap \u03b1 \u03b2 cmp)", "start": [338, 1], "end": [339, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.fromArray", "code": "@[inline] def fromArray (l : Array (\u03b1 \u00d7 \u03b2)) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBMap \u03b1 \u03b2 cmp :=\n  l.foldl (fun r p => r.insert p.1 p.2) (mkRBMap \u03b1 \u03b2 cmp)", "start": [341, 1], "end": [342, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.all", "code": "@[inline] def all : RBMap \u03b1 \u03b2 cmp \u2192 (\u03b1 \u2192 \u03b2 \u2192 Bool) \u2192 Bool\n  | \u27e8t, _\u27e9, p => t.all p", "start": [344, 1], "end": [346, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.any", "code": "@[inline] def any : RBMap \u03b1 \u03b2 cmp \u2192 (\u03b1 \u2192 \u03b2 \u2192 Bool) \u2192 Bool\n  | \u27e8t, _\u27e9, p => t.any p", "start": [348, 1], "end": [350, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.size", "code": "def size (m : RBMap \u03b1 \u03b2 cmp) : Nat :=\n  m.fold (fun sz _ _ => sz+1) 0", "start": [352, 1], "end": [354, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.maxDepth", "code": "def maxDepth (t : RBMap \u03b1 \u03b2 cmp) : Nat :=\n  t.val.depth Nat.max", "start": [356, 1], "end": [357, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.min!", "code": "@[inline] def min! [Inhabited \u03b1] [Inhabited \u03b2] (t : RBMap \u03b1 \u03b2 cmp) : \u03b1 \u00d7 \u03b2 :=\n  match t.min with\n  | some p => p\n  | none   => panic! \"map is empty\"", "start": [359, 1], "end": [362, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.max!", "code": "@[inline] def max! [Inhabited \u03b1] [Inhabited \u03b2] (t : RBMap \u03b1 \u03b2 cmp) : \u03b1 \u00d7 \u03b2 :=\n  match t.max with\n  | some p => p\n  | none   => panic! \"map is empty\"", "start": [364, 1], "end": [367, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.find!", "code": "@[inline] def find! [Inhabited \u03b2] (t : RBMap \u03b1 \u03b2 cmp) (k : \u03b1) : \u03b2 :=\n  match t.find? k with\n  | some b => b\n  | none   => panic! \"key is not in the map\"", "start": [369, 1], "end": [373, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.mergeBy", "code": "def mergeBy (mergeFn : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b2) (t\u2081 t\u2082 : RBMap \u03b1 \u03b2 cmp) : RBMap \u03b1 \u03b2 cmp :=\n  t\u2082.fold (init := t\u2081) fun t\u2081 a b\u2082 =>\n    t\u2081.insert a <|\n      match t\u2081.find? a with\n      | some b\u2081 => mergeFn a b\u2081 b\u2082\n      | none => b\u2082", "start": [375, 1], "end": [382, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.RBMap.intersectBy", "code": "def intersectBy {\u03b3 : Type v\u2081} {\u03b4 : Type v\u2082} (mergeFn : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4) (t\u2081 : RBMap \u03b1 \u03b2 cmp) (t\u2082 : RBMap \u03b1 \u03b3 cmp) : RBMap \u03b1 \u03b4 cmp :=\n  t\u2081.fold (init := \u2205) fun acc a b\u2081 =>\n      match t\u2082.find? a with\n      | some b\u2082 => acc.insert a <| mergeFn a b\u2081 b\u2082\n      | none => acc", "start": [384, 1], "end": [389, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.rbmapOf", "code": "def rbmapOf {\u03b1 : Type u} {\u03b2 : Type v} (l : List (\u03b1 \u00d7 \u03b2)) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBMap \u03b1 \u03b2 cmp :=\n  RBMap.fromList l cmp", "start": [393, 1], "end": [394, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/SMap.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "lake-packages/lean4/src/lean/Lean/Data/PersistentHashMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.SMap", "code": "structure SMap (\u03b1 : Type u) (\u03b2 : Type v) [BEq \u03b1] [Hashable \u03b1] where\n  stage\u2081 : Bool         := true\n  map\u2081   : HashMap \u03b1 \u03b2  := {}\n  map\u2082   : PHashMap \u03b1 \u03b2 := {}", "start": [12, 1], "end": [31, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.empty", "code": "def empty : SMap \u03b1 \u03b2 := {}", "start": [37, 1], "end": [37, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.fromHashMap", "code": "@[inline] def fromHashMap (m : HashMap \u03b1 \u03b2) (stage\u2081 := true) : SMap \u03b1 \u03b2 :=\n  { map\u2081 := m, stage\u2081 := stage\u2081 }", "start": [39, 1], "end": [40, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.insert", "code": "@[specialize] def insert : SMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 \u03b2 \u2192 SMap \u03b1 \u03b2\n  | \u27e8true, m\u2081, m\u2082\u27e9, k, v  => \u27e8true, m\u2081.insert k v, m\u2082\u27e9\n  | \u27e8false, m\u2081, m\u2082\u27e9, k, v => \u27e8false, m\u2081, m\u2082.insert k v\u27e9", "start": [42, 1], "end": [44, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.insert'", "code": "@[specialize] def insert' : SMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 \u03b2 \u2192 SMap \u03b1 \u03b2\n  | \u27e8true, m\u2081, m\u2082\u27e9, k, v  => \u27e8true, m\u2081.insert k v, m\u2082\u27e9\n  | \u27e8false, m\u2081, m\u2082\u27e9, k, v => \u27e8false, m\u2081, m\u2082.insert k v\u27e9", "start": [46, 1], "end": [48, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.find?", "code": "@[specialize] def find? : SMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 Option \u03b2\n  | \u27e8true, m\u2081, _\u27e9, k   => m\u2081.find? k\n  | \u27e8false, m\u2081, m\u2082\u27e9, k => (m\u2082.find? k).orElse fun _ => m\u2081.find? k", "start": [50, 1], "end": [52, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.findD", "code": "@[inline] def findD (m : SMap \u03b1 \u03b2) (a : \u03b1) (b\u2080 : \u03b2) : \u03b2 :=\n  (m.find? a).getD b\u2080", "start": [54, 1], "end": [55, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.find!", "code": "@[inline] def find! [Inhabited \u03b2] (m : SMap \u03b1 \u03b2) (a : \u03b1) : \u03b2 :=\n  match m.find? a with\n  | some b => b\n  | none   => panic! \"key is not in the map\"", "start": [57, 1], "end": [60, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.contains", "code": "@[specialize] def contains : SMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 Bool\n  | \u27e8true, m\u2081, _\u27e9, k   => m\u2081.contains k\n  | \u27e8false, m\u2081, m\u2082\u27e9, k => m\u2081.contains k || m\u2082.contains k", "start": [62, 1], "end": [64, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.find?'", "code": "@[specialize] def find?' : SMap \u03b1 \u03b2 \u2192 \u03b1 \u2192 Option \u03b2\n  | \u27e8true, m\u2081, _\u27e9, k   => m\u2081.find? k\n  | \u27e8false, m\u2081, m\u2082\u27e9, k => (m\u2081.find? k).orElse fun _ => m\u2082.find? k", "start": [66, 1], "end": [70, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.forM", "code": "def forM [Monad m] (s : SMap \u03b1 \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m PUnit) : m PUnit := do\n  s.map\u2081.forM f\n  s.map\u2082.forM f", "start": [72, 1], "end": [74, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.switch", "code": "def switch (m : SMap \u03b1 \u03b2) : SMap \u03b1 \u03b2 :=\n  if m.stage\u2081 then { m with stage\u2081 := false } else m", "start": [76, 1], "end": [78, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.foldStage2", "code": "@[inline] def foldStage2 {\u03c3 : Type w} (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03c3) (s : \u03c3) (m : SMap \u03b1 \u03b2) : \u03c3 :=\n  m.map\u2082.foldl f s", "start": [80, 1], "end": [81, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.fold", "code": "def fold {\u03c3 : Type w} (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03c3) (init : \u03c3) (m : SMap \u03b1 \u03b2) : \u03c3 :=\n  m.map\u2082.foldl f $ m.map\u2081.fold f init", "start": [83, 1], "end": [84, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.size", "code": "def size (m : SMap \u03b1 \u03b2) : Nat :=\n  m.map\u2081.size + m.map\u2082.size", "start": [86, 1], "end": [87, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.stageSizes", "code": "def stageSizes (m : SMap \u03b1 \u03b2) : Nat \u00d7 Nat :=\n  (m.map\u2081.size, m.map\u2082.size)", "start": [89, 1], "end": [90, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.numBuckets", "code": "def numBuckets (m : SMap \u03b1 \u03b2) : Nat :=\n  m.map\u2081.numBuckets", "start": [92, 1], "end": [93, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.SMap.toList", "code": "def toList (m : SMap \u03b1 \u03b2) : List (\u03b1 \u00d7 \u03b2) :=\n  m.fold (init := []) fun es a b => (a, b)::es", "start": [95, 1], "end": [96, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.List.toSMap", "code": "def List.toSMap [BEq \u03b1] [Hashable \u03b1] (es : List (\u03b1 \u00d7 \u03b2)) : SMap \u03b1 \u03b2 :=\n  es.foldl (init := {}) fun s (a, b) => s.insert a b", "start": [100, 1], "end": [101, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Name.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Name.hashEx", "code": "@[export lean_name_hash_exported] def hashEx : Name \u2192 UInt64 :=\n  Name.hash", "start": [12, 1], "end": [13, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.getPrefix", "code": "def getPrefix : Name \u2192 Name\n  | anonymous => anonymous\n  | str p _   => p\n  | num p _   => p", "start": [15, 1], "end": [18, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.getString!", "code": "def getString! : Name \u2192 String\n  | str _ s => s\n  | _       => unreachable!", "start": [20, 1], "end": [22, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.getNumParts", "code": "def getNumParts : Name \u2192 Nat\n  | anonymous => 0\n  | str p _   => getNumParts p + 1\n  | num p _   => getNumParts p + 1", "start": [24, 1], "end": [27, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.updatePrefix", "code": "def updatePrefix : Name \u2192 Name \u2192 Name\n  | anonymous, _    => anonymous\n  | str _ s,   newP => Name.mkStr newP s\n  | num _ s,   newP => Name.mkNum newP s", "start": [29, 1], "end": [32, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.componentsRev", "code": "def componentsRev : Name \u2192 List Name\n  | anonymous => []\n  | str n s   => Name.mkStr anonymous s :: componentsRev n\n  | num n v   => Name.mkNum anonymous v :: componentsRev n", "start": [34, 1], "end": [37, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.components", "code": "def components (n : Name) : List Name :=\n  n.componentsRev.reverse", "start": [39, 1], "end": [40, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.eqStr", "code": "def eqStr : Name \u2192 String \u2192 Bool\n  | str anonymous s, s' => s == s'\n  | _,                 _  => false", "start": [42, 1], "end": [44, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isPrefixOf", "code": "def isPrefixOf : Name \u2192 Name \u2192 Bool\n  | p, anonymous    => p == anonymous\n  | p, n@(num p' _) => p == n || isPrefixOf p p'\n  | p, n@(str p' _) => p == n || isPrefixOf p p'", "start": [46, 1], "end": [49, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isSuffixOf", "code": "def isSuffixOf : Name \u2192 Name \u2192 Bool\n  | anonymous, _         => true\n  | str p\u2081 s\u2081, str p\u2082 s\u2082 => s\u2081 == s\u2082 && isSuffixOf p\u2081 p\u2082\n  | num p\u2081 n\u2081, num p\u2082 n\u2082 => n\u2081 == n\u2082 && isSuffixOf p\u2081 p\u2082\n  | _,         _         => false", "start": [52, 1], "end": [56, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.cmp", "code": "def cmp : Name \u2192 Name \u2192 Ordering\n  | anonymous, anonymous => Ordering.eq\n  | anonymous, _         => Ordering.lt\n  | _,         anonymous => Ordering.gt\n  | num p\u2081 i\u2081, num p\u2082 i\u2082 =>\n    match cmp p\u2081 p\u2082 with\n    | Ordering.eq => compare i\u2081 i\u2082\n    | ord => ord\n  | num _ _,   str _ _   => Ordering.lt\n  | str _ _,   num _ _   => Ordering.gt\n  | str p\u2081 n\u2081, str p\u2082 n\u2082 =>\n    match cmp p\u2081 p\u2082 with\n    | Ordering.eq => compare n\u2081 n\u2082\n    | ord => ord", "start": [58, 1], "end": [71, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.lt", "code": "def lt (x y : Name) : Bool :=\n  cmp x y == Ordering.lt", "start": [73, 1], "end": [74, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.quickCmpAux", "code": "def quickCmpAux : Name \u2192 Name \u2192 Ordering\n  | anonymous, anonymous => Ordering.eq\n  | anonymous, _         => Ordering.lt\n  | _,         anonymous => Ordering.gt\n  | num n v, num n' v' =>\n    match compare v v' with\n    | Ordering.eq => n.quickCmpAux n'\n    | ord => ord\n  | num _ _, str _  _  => Ordering.lt\n  | str _ _, num _  _  => Ordering.gt\n  | str n s, str n' s' =>\n    match compare s s' with\n    | Ordering.eq => n.quickCmpAux n'\n    | ord => ord", "start": [76, 1], "end": [89, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.quickCmp", "code": "def quickCmp (n\u2081 n\u2082 : Name) : Ordering :=\n  match compare n\u2081.hash n\u2082.hash with\n  | Ordering.eq => quickCmpAux n\u2081 n\u2082\n  | ord => ord", "start": [91, 1], "end": [94, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.quickLt", "code": "def quickLt (n\u2081 n\u2082 : Name) : Bool :=\n  quickCmp n\u2081 n\u2082 == Ordering.lt", "start": [96, 1], "end": [97, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isInternal", "code": "def isInternal : Name \u2192 Bool\n  | str p s => s.get 0 == '_' || isInternal p\n  | num p _ => isInternal p\n  | _       => false", "start": [99, 1], "end": [104, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isImplementationDetail", "code": "def isImplementationDetail : Name \u2192 Bool\n  | str anonymous s => s.startsWith \"__\"\n  | num p _ => p.isImplementationDetail\n  | str p _ => p.isImplementationDetail\n  | anonymous => false", "start": [106, 1], "end": [115, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isAtomic", "code": "def isAtomic : Name \u2192 Bool\n  | anonymous       => true\n  | str anonymous _ => true\n  | num anonymous _ => true\n  | _               => false", "start": [117, 1], "end": [121, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isAnonymous", "code": "def isAnonymous : Name \u2192 Bool\n  | anonymous         => true\n  | _                 => false", "start": [123, 1], "end": [125, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isStr", "code": "def isStr : Name \u2192 Bool\n  | str .. => true\n  | _      => false", "start": [127, 1], "end": [129, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.isNum", "code": "def isNum : Name \u2192 Bool\n  | num .. => true\n  | _      => false", "start": [131, 1], "end": [133, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.anyS", "code": "def anyS (n : Name) (f : String \u2192 Bool) : Bool :=\n  match n with\n  | .str p s => f s || p.anyS f\n  | .num p _ => p.anyS f\n  | _ => false", "start": [135, 1], "end": [148, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/RBTree.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.RBTree", "code": "def RBTree (\u03b1 : Type u) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : Type u :=\n  RBMap \u03b1 Unit cmp", "start": [10, 1], "end": [11, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRBTree", "code": "@[inline] def mkRBTree (\u03b1 : Type u) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBTree \u03b1 cmp :=\n  mkRBMap \u03b1 Unit cmp", "start": [16, 1], "end": [17, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.empty", "code": "@[inline] def empty : RBTree \u03b1 cmp :=\n  RBMap.empty", "start": [25, 1], "end": [26, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.depth", "code": "@[inline] def depth (f : Nat \u2192 Nat \u2192 Nat) (t : RBTree \u03b1 cmp) : Nat :=\n  RBMap.depth f t", "start": [28, 1], "end": [29, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.fold", "code": "@[inline] def fold (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (init : \u03b2) (t : RBTree \u03b1 cmp) : \u03b2 :=\n  RBMap.fold (fun r a _ => f r a) init t", "start": [31, 1], "end": [32, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.revFold", "code": "@[inline] def revFold (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (init : \u03b2) (t : RBTree \u03b1 cmp) : \u03b2 :=\n  RBMap.revFold (fun r a _ => f r a) init t", "start": [34, 1], "end": [35, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.foldM", "code": "@[inline] def foldM {m : Type v \u2192 Type w} [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (init : \u03b2) (t : RBTree \u03b1 cmp) : m \u03b2 :=\n  RBMap.foldM (fun r a _ => f r a) init t", "start": [37, 1], "end": [38, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.forM", "code": "@[inline] def forM {m : Type v \u2192 Type w} [Monad m] (f : \u03b1 \u2192 m PUnit) (t : RBTree \u03b1 cmp) : m PUnit :=\n  t.foldM (fun _ a => f a) \u27e8\u27e9", "start": [40, 1], "end": [41, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.forIn", "code": "@[inline] protected def forIn [Monad m] (t : RBTree \u03b1 cmp) (init : \u03c3) (f : \u03b1 \u2192 \u03c3 \u2192 m (ForInStep \u03c3)) : m \u03c3 :=\n  t.val.forIn init (fun a _ acc => f a acc)", "start": [43, 1], "end": [44, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.isEmpty", "code": "@[inline] def isEmpty (t : RBTree \u03b1 cmp) : Bool :=\n  RBMap.isEmpty t", "start": [49, 1], "end": [50, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.toList", "code": "@[specialize] def toList (t : RBTree \u03b1 cmp) : List \u03b1 :=\n  t.revFold (fun as a => a::as) []", "start": [52, 1], "end": [53, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.toArray", "code": "@[specialize] def toArray (t : RBTree \u03b1 cmp) : Array \u03b1 :=\n  t.fold (fun as a => as.push a) #[]", "start": [55, 1], "end": [56, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.min", "code": "@[inline] protected def min (t : RBTree \u03b1 cmp) : Option \u03b1 :=\n  match RBMap.min t with\n  | some \u27e8a, _\u27e9 => some a\n  | none        => none", "start": [58, 1], "end": [61, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.max", "code": "@[inline] protected def max (t : RBTree \u03b1 cmp) : Option \u03b1 :=\n  match RBMap.max t with\n  | some \u27e8a, _\u27e9 => some a\n  | none        => none", "start": [63, 1], "end": [66, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.insert", "code": "@[inline] def insert (t : RBTree \u03b1 cmp) (a : \u03b1) : RBTree \u03b1 cmp :=\n  RBMap.insert t a ()", "start": [71, 1], "end": [72, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.erase", "code": "@[inline] def erase (t : RBTree \u03b1 cmp) (a : \u03b1) : RBTree \u03b1 cmp :=\n  RBMap.erase t a", "start": [74, 1], "end": [75, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.ofList", "code": "@[specialize] def ofList : List \u03b1 \u2192 RBTree \u03b1 cmp\n  | []    => mkRBTree ..\n  | x::xs => (ofList xs).insert x", "start": [77, 1], "end": [79, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.find?", "code": "@[inline] def find? (t : RBTree \u03b1 cmp) (a : \u03b1) : Option \u03b1 :=\n  match RBMap.findCore? t a with\n  | some \u27e8a, _\u27e9 => some a\n  | none        => none", "start": [81, 1], "end": [84, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.contains", "code": "@[inline] def contains (t : RBTree \u03b1 cmp) (a : \u03b1) : Bool :=\n  (t.find? a).isSome", "start": [86, 1], "end": [87, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.fromList", "code": "def fromList (l : List \u03b1) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBTree \u03b1 cmp :=\n  l.foldl insert (mkRBTree \u03b1 cmp)", "start": [89, 1], "end": [90, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.fromArray", "code": "def fromArray (l : Array \u03b1) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBTree \u03b1 cmp :=\n  l.foldl insert (mkRBTree \u03b1 cmp)", "start": [92, 1], "end": [93, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.all", "code": "@[inline] def all (t : RBTree \u03b1 cmp) (p : \u03b1 \u2192 Bool) : Bool :=\n  RBMap.all t (fun a _ => p a)", "start": [95, 1], "end": [96, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.any", "code": "@[inline] def any (t : RBTree \u03b1 cmp) (p : \u03b1 \u2192 Bool) : Bool :=\n  RBMap.any t (fun a _ => p a)", "start": [98, 1], "end": [99, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.subset", "code": "def subset (t\u2081 t\u2082 : RBTree \u03b1 cmp) : Bool :=\n  t\u2081.all fun a => (t\u2082.find? a).toBool", "start": [101, 1], "end": [102, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.seteq", "code": "def seteq (t\u2081 t\u2082 : RBTree \u03b1 cmp) : Bool :=\n  subset t\u2081 t\u2082 && subset t\u2082 t\u2081", "start": [104, 1], "end": [105, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.union", "code": "def union (t\u2081 t\u2082 : RBTree \u03b1 cmp) : RBTree \u03b1 cmp :=\n  if t\u2081.isEmpty then\n    t\u2082\n  else\n    t\u2082.fold .insert t\u2081", "start": [107, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.RBTree.diff", "code": "def diff (t\u2081 t\u2082 : RBTree \u03b1 cmp) : RBTree \u03b1 cmp :=\n  t\u2082.fold .erase t\u2081", "start": [113, 1], "end": [114, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.rbtreeOf", "code": "def rbtreeOf {\u03b1 : Type u} (l : List \u03b1) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : RBTree \u03b1 cmp :=\n  RBTree.fromList l cmp", "start": [118, 1], "end": [119, 24], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/SSet.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/SMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.SSet", "code": "def SSet (\u03b1 : Type u) [BEq \u03b1] [Hashable \u03b1] := SMap \u03b1 Unit", "start": [10, 1], "end": [11, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.SSet.empty", "code": "abbrev empty : SSet \u03b1 := SMap.empty", "start": [18, 1], "end": [18, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.SSet.insert", "code": "abbrev insert (s : SSet \u03b1) (a : \u03b1) : SSet \u03b1 :=\n  SMap.insert s a ()", "start": [20, 1], "end": [21, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.SSet.contains", "code": "abbrev contains (s : SSet \u03b1) (a : \u03b1) : Bool :=\n  SMap.contains s a", "start": [23, 1], "end": [24, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.SSet.forM", "code": "abbrev forM [Monad m] (s : SSet \u03b1) (f : \u03b1 \u2192 m PUnit) : m PUnit :=\n  SMap.forM s fun a _ => f a", "start": [26, 1], "end": [27, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.SSet.switch", "code": "abbrev switch (s : SSet \u03b1) : SSet \u03b1 :=\n  SMap.switch s", "start": [29, 1], "end": [31, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.SSet.fold", "code": "abbrev fold (f : \u03c3 \u2192 \u03b1 \u2192 \u03c3) (init : \u03c3) (s : SSet \u03b1) : \u03c3 :=\n  SMap.fold (fun d a _ => f d a) init s", "start": [33, 1], "end": [34, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.SSet.size", "code": "abbrev size (s : SSet \u03b1) : Nat :=\n  SMap.size s", "start": [36, 1], "end": [37, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.SSet.toList", "code": "def toList (m : SSet \u03b1) : List \u03b1 :=\n  m.fold (init := []) fun es a => a::es", "start": [39, 1], "end": [40, 40], "kind": "commanddeclaration"}, {"full_name": "List.toSSet", "code": "def List.toSSet [BEq \u03b1] [Hashable \u03b1] (es : List \u03b1) : Lean.SSet \u03b1 :=\n  es.foldl (init := {}) fun s a => s.insert a", "start": [46, 1], "end": [47, 46], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/HashSet.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.HashSetBucket", "code": "def HashSetBucket (\u03b1 : Type u) :=\n  { b : Array (List \u03b1) // b.size.isPowerOfTwo }", "start": [9, 1], "end": [10, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetBucket.update", "code": "def HashSetBucket.update {\u03b1 : Type u} (data : HashSetBucket \u03b1) (i : USize) (d : List \u03b1) (h : i.toNat < data.val.size) : HashSetBucket \u03b1 :=\n  \u27e8 data.val.uset i d h,\n    by erw [Array.size_set]; apply data.property \u27e9", "start": [12, 1], "end": [14, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp", "code": "structure HashSetImp (\u03b1 : Type u) where\n  size       : Nat\n  buckets    : HashSetBucket \u03b1", "start": [16, 1], "end": [18, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.mkHashSetImp", "code": "def mkHashSetImp {\u03b1 : Type u} (capacity := 8) : HashSetImp \u03b1 :=\n  { size       := 0\n    buckets    :=\n    \u27e8mkArray ((capacity * 4) / 3).nextPowerOfTwo [],\n     by simp; apply Nat.isPowerOfTwo_nextPowerOfTwo\u27e9 }", "start": [20, 1], "end": [24, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.mkIdx", "code": "@[extern \"lean_hashset_mk_idx\"]\nprivate def mkIdx {sz : Nat} (hash : UInt64) (h : sz.isPowerOfTwo) : { u : USize // u.toNat < sz } :=\n  let u := hash.toUSize &&& (sz.toUSize - 1)\n  if h' : u.toNat < sz then\n    \u27e8u, h'\u27e9\n  else\n    \u27e80, by simp [USize.toNat, OfNat.ofNat, USize.ofNat, Fin.ofNat']; apply Nat.pos_of_isPowerOfTwo h\u27e9", "start": [30, 1], "end": [37, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.reinsertAux", "code": "@[inline] def reinsertAux (hashFn : \u03b1 \u2192 UInt64) (data : HashSetBucket \u03b1) (a : \u03b1) : HashSetBucket \u03b1 :=\n  let \u27e8i, h\u27e9 := mkIdx (hashFn a) data.property\n  data.update i (a :: data.val[i]) h", "start": [39, 1], "end": [41, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.foldBucketsM", "code": "@[inline] def foldBucketsM {\u03b4 : Type w} {m : Type w \u2192 Type w} [Monad m] (data : HashSetBucket \u03b1) (d : \u03b4) (f : \u03b4 \u2192 \u03b1 \u2192 m \u03b4) : m \u03b4 :=\n  data.val.foldlM (init := d) fun d as => as.foldlM f d", "start": [43, 1], "end": [44, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.foldBuckets", "code": "@[inline] def foldBuckets {\u03b4 : Type w} (data : HashSetBucket \u03b1) (d : \u03b4) (f : \u03b4 \u2192 \u03b1 \u2192 \u03b4) : \u03b4 :=\n  Id.run $ foldBucketsM data d f", "start": [46, 1], "end": [47, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.foldM", "code": "@[inline] def foldM {\u03b4 : Type w} {m : Type w \u2192 Type w} [Monad m] (f : \u03b4 \u2192 \u03b1 \u2192 m \u03b4) (d : \u03b4) (h : HashSetImp \u03b1) : m \u03b4 :=\n  foldBucketsM h.buckets d f", "start": [49, 1], "end": [50, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.fold", "code": "@[inline] def fold {\u03b4 : Type w} (f : \u03b4 \u2192 \u03b1 \u2192 \u03b4) (d : \u03b4) (m : HashSetImp \u03b1) : \u03b4 :=\n  foldBuckets m.buckets d f", "start": [52, 1], "end": [53, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.forBucketsM", "code": "@[inline] def forBucketsM {m : Type w \u2192 Type w} [Monad m] (data : HashSetBucket \u03b1) (f : \u03b1 \u2192 m PUnit) : m PUnit :=\n  data.val.forM fun as => as.forM f", "start": [55, 1], "end": [56, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.forM", "code": "@[inline] def forM {m : Type w \u2192 Type w} [Monad m] (f : \u03b1 \u2192 m PUnit) (h : HashSetImp \u03b1) : m PUnit :=\n  forBucketsM h.buckets f", "start": [58, 1], "end": [59, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.find?", "code": "def find? [BEq \u03b1] [Hashable \u03b1] (m : HashSetImp \u03b1) (a : \u03b1) : Option \u03b1 :=\n  match m with\n  | \u27e8_, buckets\u27e9 =>\n    let \u27e8i, h\u27e9 := mkIdx (hash a) buckets.property\n    buckets.val[i].find? (fun a' => a == a')", "start": [61, 1], "end": [65, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.contains", "code": "def contains [BEq \u03b1] [Hashable \u03b1] (m : HashSetImp \u03b1) (a : \u03b1) : Bool :=\n  match m with\n  | \u27e8_, buckets\u27e9 =>\n    let \u27e8i, h\u27e9 := mkIdx (hash a) buckets.property\n    buckets.val[i].contains a", "start": [67, 1], "end": [71, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.moveEntries", "code": "def moveEntries [Hashable \u03b1] (i : Nat) (source : Array (List \u03b1)) (target : HashSetBucket \u03b1) : HashSetBucket \u03b1 :=\n  if h : i < source.size then\n     let idx : Fin source.size := \u27e8i, h\u27e9\n     let es  : List \u03b1   := source.get idx\n     let source                := source.set idx []\n     let target                := es.foldl (reinsertAux hash) target\n     moveEntries (i+1) source target\n  else\n    target\ntermination_by _ i source _ => source.size - i", "start": [73, 1], "end": [83, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.expand", "code": "def expand [Hashable \u03b1] (size : Nat) (buckets : HashSetBucket \u03b1) : HashSetImp \u03b1 :=\n  let bucketsNew : HashSetBucket \u03b1 := \u27e8\n    mkArray (buckets.val.size * 2) [],\n    by simp; apply Nat.mul2_isPowerOfTwo_of_isPowerOfTwo buckets.property\n  \u27e9\n  { size    := size,\n    buckets := moveEntries 0 buckets.val bucketsNew }", "start": [85, 1], "end": [91, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.insert", "code": "def insert [BEq \u03b1] [Hashable \u03b1] (m : HashSetImp \u03b1) (a : \u03b1) : HashSetImp \u03b1 :=\n  match m with\n  | \u27e8size, buckets\u27e9 =>\n    let \u27e8i, h\u27e9 := mkIdx (hash a) buckets.property\n    let bkt    := buckets.val[i]\n    if bkt.contains a\n    then \u27e8size, buckets.update i (bkt.replace a a) h\u27e9\n    else\n      let size'    := size + 1\n      let buckets' := buckets.update i (a :: bkt) h\n      if size' \u2264 buckets.val.size\n      then { size := size', buckets := buckets' }\n      else expand size' buckets'", "start": [93, 1], "end": [105, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.erase", "code": "def erase [BEq \u03b1] [Hashable \u03b1] (m : HashSetImp \u03b1) (a : \u03b1) : HashSetImp \u03b1 :=\n  match m with\n  | \u27e8 size, buckets \u27e9 =>\n    let \u27e8i, h\u27e9 := mkIdx (hash a) buckets.property\n    let bkt    := buckets.val[i]\n    if bkt.contains a then \u27e8size - 1, buckets.update i (bkt.erase a) h\u27e9\n    else m", "start": [107, 1], "end": [113, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSetImp.WellFormed", "code": "inductive WellFormed [BEq \u03b1] [Hashable \u03b1] : HashSetImp \u03b1 \u2192 Prop where\n  | mkWff     : \u2200 n,                  WellFormed (mkHashSetImp n)\n  | insertWff : \u2200 m a, WellFormed m \u2192 WellFormed (insert m a)\n  | eraseWff  : \u2200 m a, WellFormed m \u2192 WellFormed (erase m a)", "start": [115, 1], "end": [118, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet", "code": "def HashSet (\u03b1 : Type u) [BEq \u03b1] [Hashable \u03b1] :=\n  { m : HashSetImp \u03b1 // m.WellFormed }", "start": [122, 1], "end": [123, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.mkHashSet", "code": "def mkHashSet {\u03b1 : Type u} [BEq \u03b1] [Hashable \u03b1] (capacity := 8) : HashSet \u03b1 :=\n  \u27e8 mkHashSetImp capacity, WellFormed.mkWff capacity \u27e9", "start": [127, 1], "end": [128, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.empty", "code": "@[inline] def empty [BEq \u03b1] [Hashable \u03b1] : HashSet \u03b1 :=\n  mkHashSet", "start": [131, 1], "end": [132, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.insert", "code": "@[inline] def insert (m : HashSet \u03b1) (a : \u03b1) : HashSet \u03b1 :=\n  match m with\n  | \u27e8 m, hw \u27e9 => \u27e8 m.insert a, WellFormed.insertWff m a hw \u27e9", "start": [141, 1], "end": [143, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.erase", "code": "@[inline] def erase (m : HashSet \u03b1) (a : \u03b1) : HashSet \u03b1 :=\n  match m with\n  | \u27e8 m, hw \u27e9 => \u27e8 m.erase a, WellFormed.eraseWff m a hw \u27e9", "start": [145, 1], "end": [147, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.find?", "code": "@[inline] def find? (m : HashSet \u03b1) (a : \u03b1) : Option \u03b1 :=\n  match m with\n  | \u27e8 m, _ \u27e9 => m.find? a", "start": [149, 1], "end": [151, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.contains", "code": "@[inline] def contains (m : HashSet \u03b1) (a : \u03b1) : Bool :=\n  match m with\n  | \u27e8 m, _ \u27e9 => m.contains a", "start": [153, 1], "end": [155, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.foldM", "code": "@[inline] def foldM {\u03b4 : Type w} {m : Type w \u2192 Type w} [Monad m] (f : \u03b4 \u2192 \u03b1 \u2192 m \u03b4) (init : \u03b4) (h : HashSet \u03b1) : m \u03b4 :=\n  match h with\n  | \u27e8 h, _ \u27e9 => h.foldM f init", "start": [157, 1], "end": [159, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.fold", "code": "@[inline] def fold {\u03b4 : Type w} (f : \u03b4 \u2192 \u03b1 \u2192 \u03b4) (init : \u03b4) (m : HashSet \u03b1) : \u03b4 :=\n  match m with\n  | \u27e8 m, _ \u27e9 => m.fold f init", "start": [161, 1], "end": [163, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.forM", "code": "@[inline] def forM {m : Type w \u2192 Type w} [Monad m] (h : HashSet \u03b1) (f : \u03b1 \u2192 m PUnit) : m PUnit :=\n  match h with\n  | \u27e8h, _\u27e9 => h.forM f", "start": [165, 1], "end": [167, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.size", "code": "@[inline] def size (m : HashSet \u03b1) : Nat :=\n  match m with\n  | \u27e8 {size := sz, ..}, _ \u27e9 => sz", "start": [175, 1], "end": [177, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.isEmpty", "code": "@[inline] def isEmpty (m : HashSet \u03b1) : Bool :=\n  m.size = 0", "start": [179, 1], "end": [180, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.toList", "code": "def toList (m : HashSet \u03b1) : List \u03b1 :=\n  m.fold (init := []) fun r a => a::r", "start": [182, 1], "end": [183, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.toArray", "code": "def toArray (m : HashSet \u03b1) : Array \u03b1 :=\n  m.fold (init := #[]) fun r a => r.push a", "start": [185, 1], "end": [186, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.numBuckets", "code": "def numBuckets (m : HashSet \u03b1) : Nat :=\n  m.val.buckets.val.size", "start": [188, 1], "end": [189, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.HashSet.insertMany", "code": "def insertMany [ForIn Id \u03c1 \u03b1] (s : HashSet \u03b1) (as : \u03c1) : HashSet \u03b1 := Id.run do\n  let mut s := s\n  for a in as do\n    s := s.insert a\n  return s", "start": [191, 1], "end": [196, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/KVMap.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Name.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.DataValue", "code": "inductive DataValue where\n  | ofString (v : String)\n  | ofBool   (v : Bool)\n  | ofName   (v : Name)\n  | ofNat    (v : Nat)\n  | ofInt    (v : Int)\n  | ofSyntax (v : Syntax)\n  deriving Inhabited, BEq, Repr", "start": [10, 1], "end": [18, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.DataValue.beqExp", "code": "@[export lean_data_value_beq]\ndef DataValue.beqExp (a b : DataValue) : Bool :=\n  a == b", "start": [20, 1], "end": [22, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBoolDataValueEx", "code": "@[export lean_mk_bool_data_value] def mkBoolDataValueEx (b : Bool) : DataValue := DataValue.ofBool b", "start": [24, 1], "end": [24, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.DataValue.getBoolEx", "code": "@[export lean_data_value_bool] def DataValue.getBoolEx : DataValue \u2192 Bool\n  | DataValue.ofBool b => b\n  | _                  => false", "start": [25, 1], "end": [27, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.DataValue.sameCtor", "code": "def DataValue.sameCtor : DataValue \u2192 DataValue \u2192 Bool\n  | .ofString _, .ofString _ => true\n  | .ofBool _,   .ofBool _   => true\n  | .ofName _,   .ofName _   => true\n  | .ofNat _,    .ofNat _    => true\n  | .ofInt _,    .ofInt _    => true\n  | .ofSyntax _, .ofSyntax _ => true\n  | _,           _           => false", "start": [29, 1], "end": [36, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.DataValue.str", "code": "@[export lean_data_value_to_string]\ndef DataValue.str : DataValue \u2192 String\n  | .ofString v => v\n  | .ofBool v   => toString v\n  | .ofName v   => toString v\n  | .ofNat v    => toString v\n  | .ofInt v    => toString v\n  | .ofSyntax v => toString v", "start": [38, 1], "end": [45, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap", "code": "structure KVMap where\n  entries : List (Name \u00d7 DataValue) := []\n  deriving Inhabited, Repr", "start": [57, 1], "end": [66, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.empty", "code": "def empty : KVMap :=\n  {}", "start": [71, 1], "end": [72, 5], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.isEmpty", "code": "def isEmpty : KVMap \u2192 Bool\n  | \u27e8m\u27e9 => m.isEmpty", "start": [74, 1], "end": [75, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.size", "code": "def size (m : KVMap) : Nat :=\n  m.entries.length", "start": [77, 1], "end": [78, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.findCore", "code": "def findCore : List (Name \u00d7 DataValue) \u2192 Name \u2192 Option DataValue\n  | [],       _  => none\n  | (k,v)::m, k' => if k == k' then some v else findCore m k'", "start": [80, 1], "end": [82, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.find", "code": "def find : KVMap \u2192 Name \u2192 Option DataValue\n  | \u27e8m\u27e9, k => findCore m k", "start": [84, 1], "end": [85, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.findD", "code": "def findD (m : KVMap) (k : Name) (d\u2080 : DataValue) : DataValue :=\n  (m.find k).getD d\u2080", "start": [87, 1], "end": [88, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.insertCore", "code": "def insertCore : List (Name \u00d7 DataValue) \u2192 Name \u2192 DataValue \u2192 List (Name \u00d7 DataValue)\n  | [],       k', v' => [(k',v')]\n  | (k,v)::m, k', v' => if k == k' then (k, v') :: m else (k, v) :: insertCore m k' v'", "start": [90, 1], "end": [92, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.insert", "code": "def insert : KVMap \u2192 Name \u2192 DataValue \u2192 KVMap\n  | \u27e8m\u27e9, k, v => \u27e8insertCore m k v\u27e9", "start": [94, 1], "end": [95, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.contains", "code": "def contains (m : KVMap) (n : Name) : Bool :=\n  (m.find n).isSome", "start": [97, 1], "end": [98, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.getString", "code": "def getString (m : KVMap) (k : Name) (defVal := \"\") : String :=\n  match m.find k with\n  | some (DataValue.ofString v) => v\n  | _                           => defVal", "start": [100, 1], "end": [103, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.getNat", "code": "def getNat (m : KVMap) (k : Name) (defVal := 0) : Nat :=\n  match m.find k with\n  | some (DataValue.ofNat v) => v\n  | _                        => defVal", "start": [105, 1], "end": [108, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.getInt", "code": "def getInt (m : KVMap) (k : Name) (defVal : Int := 0) : Int :=\n  match m.find k with\n  | some (DataValue.ofInt v) => v\n  | _                        => defVal", "start": [110, 1], "end": [113, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.getBool", "code": "def getBool (m : KVMap) (k : Name) (defVal := false) : Bool :=\n  match m.find k with\n  | some (DataValue.ofBool v) => v\n  | _                         => defVal", "start": [115, 1], "end": [118, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.getName", "code": "def getName (m : KVMap) (k : Name) (defVal := Name.anonymous) : Name :=\n  match m.find k with\n  | some (DataValue.ofName v) => v\n  | _                         => defVal", "start": [120, 1], "end": [123, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.getSyntax", "code": "def getSyntax (m : KVMap) (k : Name) (defVal := Syntax.missing) : Syntax :=\n  match m.find k with\n  | some (DataValue.ofSyntax v) => v\n  | _                           => defVal", "start": [125, 1], "end": [128, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.setString", "code": "def setString (m : KVMap) (k : Name) (v : String) : KVMap :=\n  m.insert k (DataValue.ofString v)", "start": [130, 1], "end": [131, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.setNat", "code": "def setNat (m : KVMap) (k : Name) (v : Nat) : KVMap :=\n  m.insert k (DataValue.ofNat v)", "start": [133, 1], "end": [134, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.setInt", "code": "def setInt (m : KVMap) (k : Name) (v : Int) : KVMap :=\n  m.insert k (DataValue.ofInt v)", "start": [136, 1], "end": [137, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.setBool", "code": "def setBool (m : KVMap) (k : Name) (v : Bool) : KVMap :=\n  m.insert k (DataValue.ofBool v)", "start": [139, 1], "end": [140, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.setName", "code": "def setName (m : KVMap) (k : Name) (v : Name) : KVMap :=\n  m.insert k (DataValue.ofName v)", "start": [142, 1], "end": [143, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.setSyntax", "code": "def setSyntax (m : KVMap) (k : Name) (v : Syntax) : KVMap :=\n  m.insert k (DataValue.ofSyntax v)", "start": [145, 1], "end": [146, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.forIn", "code": "@[inline] protected def forIn.{w, w'} {\u03b4 : Type w} {m : Type w \u2192 Type w'} [Monad m]\n  (kv : KVMap) (init : \u03b4) (f : Name \u00d7 DataValue \u2192 \u03b4 \u2192 m (ForInStep \u03b4)) : m \u03b4 :=\n  kv.entries.forIn init f", "start": [148, 1], "end": [150, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.subsetAux", "code": "def subsetAux : List (Name \u00d7 DataValue) \u2192 KVMap \u2192 Bool\n  | [],          _  => true\n  | (k, v\u2081)::m\u2081, m\u2082 =>\n    match m\u2082.find k with\n    | some v\u2082 => v\u2081 == v\u2082 && subsetAux m\u2081 m\u2082\n    | none    => false", "start": [155, 1], "end": [160, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.subset", "code": "def subset : KVMap \u2192 KVMap \u2192 Bool\n  | \u27e8m\u2081\u27e9, m\u2082 => subsetAux m\u2081 m\u2082", "start": [162, 1], "end": [163, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.eqv", "code": "def eqv (m\u2081 m\u2082 : KVMap) : Bool :=\n  subset m\u2081 m\u2082 && subset m\u2082 m\u2081", "start": [165, 1], "end": [166, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.Value", "code": "class Value (\u03b1 : Type) where\n  toDataValue  : \u03b1 \u2192 DataValue\n  ofDataValue? : DataValue \u2192 Option \u03b1", "start": [171, 1], "end": [173, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.get?", "code": "@[inline] def get? {\u03b1 : Type} [Value \u03b1] (m : KVMap) (k : Name) : Option \u03b1 :=\n  m.find k |>.bind Value.ofDataValue?", "start": [175, 1], "end": [176, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.get", "code": "@[inline] def get {\u03b1 : Type} [Value \u03b1] (m : KVMap) (k : Name) (defVal : \u03b1) : \u03b1 :=\n  m.get? k |>.getD defVal", "start": [178, 1], "end": [179, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.KVMap.set", "code": "@[inline] def set {\u03b1 : Type} [Value \u03b1] (m : KVMap) (k : Name) (v : \u03b1) : KVMap :=\n  m.insert k (Value.toDataValue v)", "start": [181, 1], "end": [182, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/ImportingFlag.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.enableInitializersExecution", "code": "@[export lean_enable_initializer_execution]\nunsafe def enableInitializersExecution : IO Unit :=\n  runInitializersRef.set true", "start": [12, 1], "end": [26, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.isInitializerExecutionEnabled", "code": "def isInitializerExecutionEnabled : IO Bool :=\n  runInitializersRef.get", "start": [28, 1], "end": [29, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.initializing", "code": "def initializing : IO Bool :=\n  IO.initializing <||> importingRef.get", "start": [31, 1], "end": [36, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.withImporting", "code": "def withImporting (x : IO \u03b1) : IO \u03b1 :=\n  try\n    importingRef.set true\n    x\n  finally\n    importingRef.set false\n    runInitializersRef.set false", "start": [38, 1], "end": [54, 33], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/NameMap.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashSet.lean", "lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Lean/Data/SSet.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Name.lean", "lake-packages/lean4/src/lean/Lean/Data/RBTree.lean"], "premises": [{"full_name": "Lean.NameMap", "code": "def NameMap (\u03b1 : Type) := RBMap Name \u03b1 Name.quickCmp", "start": [15, 1], "end": [15, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.mkNameMap", "code": "@[inline] def mkNameMap (\u03b1 : Type) : NameMap \u03b1 := mkRBMap Name \u03b1 Name.quickCmp", "start": [17, 1], "end": [17, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.insert", "code": "def insert (m : NameMap \u03b1) (n : Name) (a : \u03b1) := RBMap.insert m n a", "start": [27, 1], "end": [27, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.contains", "code": "def contains (m : NameMap \u03b1) (n : Name) : Bool := RBMap.contains m n", "start": [29, 1], "end": [29, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMap.find?", "code": "@[inline] def find? (m : NameMap \u03b1) (n : Name) : Option \u03b1 := RBMap.find? m n", "start": [31, 1], "end": [31, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSet", "code": "def NameSet := RBTree Name Name.quickCmp", "start": [38, 1], "end": [38, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSet.empty", "code": "def empty : NameSet := mkRBTree Name Name.quickCmp", "start": [41, 1], "end": [41, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSet.insert", "code": "def insert (s : NameSet) (n : Name) : NameSet := RBTree.insert s n", "start": [44, 1], "end": [44, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSet.contains", "code": "def contains (s : NameSet) (n : Name) : Bool := RBMap.contains s n", "start": [45, 1], "end": [45, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSet.append", "code": "def append (s t : NameSet) : NameSet :=\n  s.mergeBy (fun _ _ _ => .unit) t", "start": [49, 1], "end": [51, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSSet", "code": "def NameSSet := SSet Name", "start": [58, 1], "end": [58, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSSet.empty", "code": "abbrev empty : NameSSet := SSet.empty", "start": [61, 1], "end": [61, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSSet.insert", "code": "abbrev insert (s : NameSSet) (n : Name) : NameSSet := SSet.insert s n", "start": [64, 1], "end": [64, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSSet.contains", "code": "abbrev contains (s : NameSSet) (n : Name) : Bool := SSet.contains s n", "start": [65, 1], "end": [65, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.NameHashSet", "code": "def NameHashSet := HashSet Name", "start": [68, 1], "end": [68, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.NameHashSet.empty", "code": "@[inline] def empty : NameHashSet := HashSet.empty", "start": [71, 1], "end": [71, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.NameHashSet.insert", "code": "def insert (s : NameHashSet) (n : Name) := HashSet.insert s n", "start": [74, 1], "end": [74, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.NameHashSet.contains", "code": "def contains (s : NameHashSet) (n : Name) : Bool := HashSet.contains s n", "start": [75, 1], "end": [75, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.MacroScopesView.isPrefixOf", "code": "def MacroScopesView.isPrefixOf (v\u2081 v\u2082 : MacroScopesView) : Bool :=\n  v\u2081.name.isPrefixOf v\u2082.name &&\n  v\u2081.scopes == v\u2082.scopes &&\n  v\u2081.mainModule == v\u2082.mainModule &&\n  v\u2081.imported == v\u2082.imported", "start": [78, 1], "end": [82, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.MacroScopesView.isSuffixOf", "code": "def MacroScopesView.isSuffixOf (v\u2081 v\u2082 : MacroScopesView) : Bool :=\n  v\u2081.name.isSuffixOf v\u2082.name &&\n  v\u2081.scopes == v\u2082.scopes &&\n  v\u2081.mainModule == v\u2082.mainModule &&\n  v\u2081.imported == v\u2082.imported", "start": [84, 1], "end": [88, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Options.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/NameMap.lean", "lake-packages/lean4/src/lean/Lean/ImportingFlag.lean", "lake-packages/lean4/src/lean/Lean/Data/KVMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Options", "code": "def Options := KVMap", "start": [12, 1], "end": [12, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Options.empty", "code": "def Options.empty : Options  := {}", "start": [14, 1], "end": [14, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.OptionDecl", "code": "structure OptionDecl where\n  declName : Name := by exact decl_name%\n  defValue : DataValue\n  group    : String := \"\"\n  descr    : String := \"\"\n  deriving Inhabited", "start": [21, 1], "end": [26, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.OptionDecls", "code": "def OptionDecls := NameMap OptionDecl", "start": [28, 1], "end": [28, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.registerOption", "code": "@[export lean_register_option]\ndef registerOption (name : Name) (decl : OptionDecl) : IO Unit := do\n  unless (\u2190 initializing) do\n    throw (IO.userError \"failed to register option, options can only be registered during initialization\")\n  let decls \u2190 optionDeclsRef.get\n  if decls.contains name then\n    throw $ IO.userError s!\"invalid option declaration '{name}', option already exists\"\n  optionDeclsRef.set $ decls.insert name decl", "start": [34, 1], "end": [41, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.getOptionDecls", "code": "def getOptionDecls : IO OptionDecls := optionDeclsRef.get", "start": [43, 1], "end": [43, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.getOptionDeclsArray", "code": "@[export lean_get_option_decls_array]\ndef getOptionDeclsArray : IO (Array (Name \u00d7 OptionDecl)) := do\n  let decls \u2190 getOptionDecls\n  pure $ decls.fold\n   (fun (r : Array (Name \u00d7 OptionDecl)) k v => r.push (k, v))\n   #[]", "start": [45, 1], "end": [50, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.getOptionDecl", "code": "def getOptionDecl (name : Name) : IO OptionDecl := do\n  let decls \u2190 getOptionDecls\n  let (some decl) \u2190 pure (decls.find? name) | throw $ IO.userError s!\"unknown option '{name}'\"\n  pure decl", "start": [52, 1], "end": [55, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.getOptionDefaultValue", "code": "def getOptionDefaultValue (name : Name) : IO DataValue := do\n  let decl \u2190 getOptionDecl name\n  pure decl.defValue", "start": [57, 1], "end": [59, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.getOptionDescr", "code": "def getOptionDescr (name : Name) : IO String := do\n  let decl \u2190 getOptionDecl name\n  pure decl.descr", "start": [61, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadOptions", "code": "class MonadOptions (m : Type \u2192 Type) where\n  getOptions : m Options", "start": [65, 1], "end": [66, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.getBoolOption", "code": "def getBoolOption (k : Name) (defValue := false) : m Bool := do\n  let opts \u2190 getOptions\n  return opts.getBool k defValue", "start": [75, 1], "end": [77, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.getNatOption", "code": "def getNatOption (k : Name) (defValue := 0) : m Nat := do\n  let opts \u2190 getOptions\n  return opts.getNat k defValue", "start": [79, 1], "end": [81, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadWithOptions", "code": "class MonadWithOptions (m : Type \u2192 Type) where\n  withOptions (f : Options \u2192 Options) (x : m \u03b1) : m \u03b1", "start": [83, 1], "end": [84, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.withInPattern", "code": "def withInPattern [MonadWithOptions m] (x : m \u03b1) : m \u03b1 :=\n  withOptions (fun o => o.setBool `_inPattern true) x", "start": [94, 1], "end": [95, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Options.getInPattern", "code": "def Options.getInPattern (o : Options) : Bool :=\n  o.getBool `_inPattern", "start": [97, 1], "end": [98, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Option", "code": "protected structure Option (\u03b1 : Type) where\n  name     : Name\n  defValue : \u03b1\n  deriving Inhabited", "start": [100, 1], "end": [104, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Option.Decl", "code": "protected structure Decl (\u03b1 : Type) where\n  defValue : \u03b1\n  group    : String := \"\"\n  descr    : String := \"\"", "start": [108, 1], "end": [111, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Option.get?", "code": "protected def get? [KVMap.Value \u03b1] (opts : Options) (opt : Lean.Option \u03b1) : Option \u03b1 :=\n  opts.get? opt.name", "start": [113, 1], "end": [114, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Option.get", "code": "protected def get [KVMap.Value \u03b1] (opts : Options) (opt : Lean.Option \u03b1) : \u03b1 :=\n  opts.get opt.name opt.defValue", "start": [116, 1], "end": [117, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Option.set", "code": "protected def set [KVMap.Value \u03b1] (opts : Options) (opt : Lean.Option \u03b1) (val : \u03b1) : Options :=\n  opts.set opt.name val", "start": [119, 1], "end": [120, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Option.setIfNotSet", "code": "protected def setIfNotSet [KVMap.Value \u03b1] (opts : Options) (opt : Lean.Option \u03b1) (val : \u03b1) : Options :=\n  if opts.contains opt.name then opts else opt.set opts val", "start": [122, 1], "end": [124, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Option.register", "code": "protected def register [KVMap.Value \u03b1] (name : Name) (decl : Lean.Option.Decl \u03b1) (ref : Name := by exact decl_name%) : IO (Lean.Option \u03b1) := do\n  registerOption name {\n    declName := ref\n    defValue := KVMap.Value.toDataValue decl.defValue\n    group := decl.group\n    descr := decl.descr\n  }\n  return { name := name, defValue := decl.defValue }", "start": [126, 1], "end": [133, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Format.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Format.getWidth", "code": "def getWidth (o : Options) : Nat    := o.get `format.width  defWidth", "start": [13, 1], "end": [13, 69], "kind": "commanddeclaration"}, {"full_name": "Std.Format.getIndent", "code": "def getIndent (o : Options) : Nat   := o.get `format.indent defIndent", "start": [14, 1], "end": [14, 70], "kind": "commanddeclaration"}, {"full_name": "Std.Format.getUnicode", "code": "def getUnicode (o : Options) : Bool := o.get `format.unicode defUnicode", "start": [15, 1], "end": [15, 72], "kind": "commanddeclaration"}, {"full_name": "Std.Format.pretty'", "code": "def pretty' (f : Format) (o : Options := {}) : String :=\n  pretty f (format.width.get o)", "start": [32, 1], "end": [33, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.formatKVMap", "code": "def formatKVMap (m : KVMap) : Format :=\n  sbracket (Format.joinSep m.entries \", \")", "start": [66, 1], "end": [67, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Hygiene.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Name.lean", "lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Lean/Data/Format.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Unhygienic.Context", "code": "structure Unhygienic.Context where\n  ref   : Syntax\n  scope : MacroScope", "start": [13, 1], "end": [15, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Unhygienic", "code": "abbrev Unhygienic := ReaderT Lean.Unhygienic.Context <| StateM MacroScope", "start": [17, 1], "end": [31, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Unhygienic.run", "code": "@[inline]\nprotected def run {\u03b1 : Type} (x : Unhygienic \u03b1) : \u03b1 := (x \u27e8Syntax.missing, firstFrontendMacroScope\u27e9).run' (firstFrontendMacroScope+1)", "start": [42, 1], "end": [43, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.mkInaccessibleUserNameAux", "code": "private def mkInaccessibleUserNameAux (unicode : Bool) (name : Name) (idx : Nat) : Name :=\n  if unicode then\n    if idx == 0 then\n      name.appendAfter \"\u271d\"\n    else\n      name.appendAfter (\"\u271d\" ++ idx.toSuperscriptString)\n  else\n    name ++ Name.mkNum \"_inaccessible\" idx", "start": [46, 1], "end": [53, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.mkInaccessibleUserName", "code": "private def mkInaccessibleUserName (unicode : Bool) : Name \u2192 Name\n  | .num p@(.str ..) idx =>\n    mkInaccessibleUserNameAux unicode p idx\n  | .num .anonymous idx =>\n    mkInaccessibleUserNameAux unicode Name.anonymous idx\n  | .num p idx =>\n    if unicode then\n      (mkInaccessibleUserName unicode p).appendAfter (\"\u207b\" ++ idx.toSuperscriptString)\n    else\n      Name.mkNum (mkInaccessibleUserName unicode p) idx\n  | n => n", "start": [55, 1], "end": [65, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.getSanitizeNames", "code": "def getSanitizeNames (o : Options) : Bool := pp.sanitizeNames.get o", "start": [73, 1], "end": [73, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.NameSanitizerState", "code": "structure NameSanitizerState where\n  options            : Options\n  \n  nameStem2Idx       : NameMap Nat := {}\n  \n  userName2Sanitized : NameMap Name := {}", "start": [75, 1], "end": [80, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.mkFreshInaccessibleUserName", "code": "private partial def mkFreshInaccessibleUserName (userName : Name) (idx : Nat) : StateM NameSanitizerState Name := do\n  let s \u2190 get\n  let userNameNew := mkInaccessibleUserName (Std.Format.getUnicode s.options) (Name.mkNum userName idx)\n  if s.nameStem2Idx.contains userNameNew then\n    mkFreshInaccessibleUserName userName (idx+1)\n  else do\n    modify fun s => { s with nameStem2Idx := s.nameStem2Idx.insert userName (idx+1) }\n    pure userNameNew", "start": [82, 1], "end": [89, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.sanitizeName", "code": "def sanitizeName (userName : Name) : StateM NameSanitizerState Name := do\n  let stem := userName.eraseMacroScopes;\n  let idx  := (\u2190 get).nameStem2Idx.find? stem |>.getD 0\n  let san \u2190 mkFreshInaccessibleUserName stem idx\n  modify fun s => { s with userName2Sanitized := s.userName2Sanitized.insert userName san }\n  pure san", "start": [91, 1], "end": [97, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.sanitizeSyntaxAux", "code": "private partial def sanitizeSyntaxAux : Syntax \u2192 StateM NameSanitizerState Syntax\n  | stx@(Syntax.ident _ _ n _) => do\n    let n \u2190 match (\u2190 get).userName2Sanitized.find? n with\n      | some n' => pure n'\n      | none    => if n.hasMacroScopes then sanitizeName n else pure n\n    return mkIdentFrom stx n\n  | Syntax.node info k args => Syntax.node info k <$> args.mapM sanitizeSyntaxAux\n  | stx => pure stx", "start": [99, 1], "end": [106, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.sanitizeSyntax", "code": "def sanitizeSyntax (stx : Syntax) : StateM NameSanitizerState Syntax := do\n  if getSanitizeNames (\u2190 get).options then\n    sanitizeSyntaxAux stx\n  else\n    pure stx", "start": [108, 1], "end": [112, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/PersistentHashSet.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/PersistentHashMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PersistentHashSet", "code": "structure PersistentHashSet (\u03b1 : Type u) [BEq \u03b1] [Hashable \u03b1] where\n  (set : PersistentHashMap \u03b1 Unit)", "start": [11, 1], "end": [12, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.PHashSet", "code": "abbrev PHashSet (\u03b1 : Type u) [BEq \u03b1] [Hashable \u03b1] := PersistentHashSet \u03b1", "start": [14, 1], "end": [14, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.empty", "code": "@[inline] def empty [BEq \u03b1] [Hashable \u03b1] : PersistentHashSet \u03b1 :=\n  { set := PersistentHashMap.empty }", "start": [18, 1], "end": [19, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.isEmpty", "code": "@[inline] def isEmpty (s : PersistentHashSet \u03b1) : Bool :=\n  s.set.isEmpty", "start": [29, 1], "end": [30, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.insert", "code": "@[inline] def insert (s : PersistentHashSet \u03b1) (a : \u03b1) : PersistentHashSet \u03b1 :=\n  { set := s.set.insert a () }", "start": [32, 1], "end": [33, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.erase", "code": "@[inline] def erase (s : PersistentHashSet \u03b1) (a : \u03b1) : PersistentHashSet \u03b1 :=\n  { set := s.set.erase a }", "start": [35, 1], "end": [36, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.find?", "code": "@[inline] def find? (s : PersistentHashSet \u03b1) (a : \u03b1) : Option \u03b1 :=\n  match s.set.findEntry? a with\n  | some (a, _) => some a\n  | none        => none", "start": [38, 1], "end": [41, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.contains", "code": "@[inline] def contains (s : PersistentHashSet \u03b1) (a : \u03b1) : Bool :=\n  s.set.contains a", "start": [43, 1], "end": [44, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.size", "code": "@[inline] def size (s : PersistentHashSet \u03b1) : Nat :=\n  s.set.size", "start": [46, 1], "end": [47, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.foldM", "code": "@[inline] def foldM {\u03b2 : Type v} {m : Type v \u2192 Type v} [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (init : \u03b2) (s : PersistentHashSet \u03b1) : m \u03b2 :=\n  s.set.foldlM (init := init) fun d a _ => f d a", "start": [49, 1], "end": [50, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentHashSet.fold", "code": "@[inline] def fold {\u03b2 : Type v} (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (init : \u03b2) (s : PersistentHashSet \u03b1) : \u03b2 :=\n  Id.run $ s.foldM f init", "start": [52, 1], "end": [53, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Level.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashSet.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/PersistentHashSet.lean", "lake-packages/lean4/src/lean/Lean/Data/Name.lean", "lake-packages/lean4/src/lean/Lean/Hygiene.lean", "lake-packages/lean4/src/lean/Lean/Data/Format.lean", "lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "lake-packages/lean4/src/lean/Lean/Data/PersistentHashMap.lean"], "premises": [{"full_name": "Nat.imax", "code": "def Nat.imax (n m : Nat) : Nat :=\n  if m = 0 then 0 else Nat.max n m", "start": [14, 1], "end": [15, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.Data", "code": "def Level.Data := UInt64", "start": [19, 1], "end": [25, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.Data.hash", "code": "def Level.Data.hash (c : Level.Data) : UInt64 :=\n  c.toUInt32.toUInt64", "start": [30, 1], "end": [31, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.Data.depth", "code": "def Level.Data.depth (c : Level.Data) : UInt32 :=\n  (c.shiftRight 40).toUInt32", "start": [36, 1], "end": [37, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.Data.hasMVar", "code": "def Level.Data.hasMVar (c : Level.Data) : Bool :=\n  ((c.shiftRight 32).land 1) == 1", "start": [39, 1], "end": [40, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.Data.hasParam", "code": "def Level.Data.hasParam (c : Level.Data) : Bool :=\n  ((c.shiftRight 33).land 1) == 1", "start": [42, 1], "end": [43, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.mkData", "code": "def Level.mkData (h : UInt64) (depth : Nat := 0) (hasMVar hasParam : Bool := false) : Level.Data :=\n  if depth > Nat.pow 2 24 - 1 then panic! \"universe level depth is too big\"\n  else\n    let r : UInt64 := h.toUInt32.toUInt64 + hasMVar.toUInt64.shiftLeft 32 + hasParam.toUInt64.shiftLeft 33 + depth.toUInt64.shiftLeft 40\n    r", "start": [45, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.LevelMVarId", "code": "structure LevelMVarId where\n  name : Name\n  deriving Inhabited, BEq, Hashable, Repr", "start": [64, 1], "end": [67, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.LMVarId", "code": "abbrev LMVarId := LevelMVarId", "start": [69, 1], "end": [70, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.LMVarIdSet", "code": "def LMVarIdSet := RBTree LMVarId (Name.quickCmp \u00b7.name \u00b7.name)\n  deriving Inhabited, EmptyCollection", "start": [75, 1], "end": [76, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.LMVarIdMap", "code": "def LMVarIdMap (\u03b1 : Type) := RBMap LMVarId \u03b1 (Name.quickCmp \u00b7.name \u00b7.name)", "start": [80, 1], "end": [80, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Level", "code": "inductive Level where\n  | zero   : Level\n  | succ   : Level \u2192 Level\n  | max    : Level \u2192 Level \u2192 Level\n  | imax   : Level \u2192 Level \u2192 Level\n  | param  : Name \u2192 Level\n  | mvar   : LMVarId \u2192 Level\nwith\n  @[computed_field] data : Level \u2192 Data\n    | .zero => mkData 2221 0 false false\n    | .mvar mvarId => mkData (mixHash 2237 <| hash mvarId) 0 true false\n    | .param name => mkData (mixHash 2239 <| hash name) 0 false true\n    | .succ u => mkData (mixHash 2243 <| u.data.hash) (u.data.depth.toNat + 1) u.data.hasMVar u.data.hasParam\n    | .max u v => mkData (mixHash 2251 <| mixHash (u.data.hash) (v.data.hash)) (Nat.max u.data.depth.toNat v.data.depth.toNat + 1)\n       (u.data.hasMVar || v.data.hasMVar) (u.data.hasParam || v.data.hasParam)\n    | .imax u v => mkData (mixHash 2267 <| mixHash (u.data.hash) (v.data.hash)) (Nat.max u.data.depth.toNat v.data.depth.toNat + 1)\n       (u.data.hasMVar || v.data.hasMVar) (u.data.hasParam || v.data.hasParam)\n\nderiving Inhabited, Repr", "start": [89, 1], "end": [107, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.hash", "code": "protected def hash (u : Level) : UInt64 :=\n  u.data.hash", "start": [111, 1], "end": [112, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.depth", "code": "def depth (u : Level) : Nat :=\n  u.data.depth.toNat", "start": [116, 1], "end": [117, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.hasMVar", "code": "def hasMVar (u : Level) : Bool :=\n  u.data.hasMVar", "start": [119, 1], "end": [120, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.hasParam", "code": "def hasParam (u : Level) : Bool :=\n  u.data.hasParam", "start": [122, 1], "end": [123, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.hashEx", "code": "@[export lean_level_hash] def hashEx (u : Level) : UInt32 := hash u |>.toUInt32", "start": [125, 1], "end": [125, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.hasMVarEx", "code": "@[export lean_level_has_mvar] def hasMVarEx : Level \u2192 Bool := hasMVar", "start": [126, 1], "end": [126, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.hasParamEx", "code": "@[export lean_level_has_param] def hasParamEx : Level \u2192 Bool := hasParam", "start": [127, 1], "end": [127, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.depthEx", "code": "@[export lean_level_depth] def depthEx (u : Level) : UInt32 := u.data.depth", "start": [128, 1], "end": [128, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.levelZero", "code": "def levelZero :=\n  Level.zero", "start": [132, 1], "end": [133, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelMVar", "code": "def mkLevelMVar (mvarId : LMVarId) :=\n  Level.mvar mvarId", "start": [135, 1], "end": [136, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelParam", "code": "def mkLevelParam (name : Name) :=\n  Level.param name", "start": [138, 1], "end": [139, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelSucc", "code": "def mkLevelSucc (u : Level) :=\n  Level.succ u", "start": [141, 1], "end": [142, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelMax", "code": "def mkLevelMax (u v : Level) :=\n  Level.max u v", "start": [144, 1], "end": [145, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelIMax", "code": "def mkLevelIMax (u v : Level) :=\n  Level.imax u v", "start": [147, 1], "end": [148, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.levelOne", "code": "def levelOne := mkLevelSucc levelZero", "start": [150, 1], "end": [150, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelZeroEx", "code": "@[export lean_level_mk_zero] def mkLevelZeroEx : Unit \u2192 Level := fun _ => levelZero", "start": [152, 1], "end": [152, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelSuccEx", "code": "@[export lean_level_mk_succ] def mkLevelSuccEx : Level \u2192 Level := mkLevelSucc", "start": [153, 1], "end": [153, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelMVarEx", "code": "@[export lean_level_mk_mvar] def mkLevelMVarEx : LMVarId \u2192 Level := mkLevelMVar", "start": [154, 1], "end": [154, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelParamEx", "code": "@[export lean_level_mk_param] def mkLevelParamEx : Name \u2192 Level := mkLevelParam", "start": [155, 1], "end": [155, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelMaxEx", "code": "@[export lean_level_mk_max] def mkLevelMaxEx : Level \u2192 Level \u2192 Level := mkLevelMax", "start": [156, 1], "end": [156, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelIMaxEx", "code": "@[export lean_level_mk_imax] def mkLevelIMaxEx : Level \u2192 Level \u2192 Level := mkLevelIMax", "start": [157, 1], "end": [157, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isZero", "code": "def isZero : Level \u2192 Bool\n  | zero   => true\n  | _      => false", "start": [161, 1], "end": [163, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isSucc", "code": "def isSucc : Level \u2192 Bool\n  | succ .. => true\n  | _       => false", "start": [165, 1], "end": [167, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isMax", "code": "def isMax : Level \u2192 Bool\n  | max .. => true\n  | _      => false", "start": [169, 1], "end": [171, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isIMax", "code": "def isIMax : Level \u2192 Bool\n  | imax .. => true\n  | _       => false", "start": [173, 1], "end": [175, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isMaxIMax", "code": "def isMaxIMax : Level \u2192 Bool\n  | max ..  => true\n  | imax .. => true\n  | _       => false", "start": [177, 1], "end": [180, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isParam", "code": "def isParam : Level \u2192 Bool\n  | param .. => true\n  | _        => false", "start": [182, 1], "end": [184, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isMVar", "code": "def isMVar : Level \u2192 Bool\n  | mvar .. => true\n  | _       => false", "start": [186, 1], "end": [188, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.mvarId!", "code": "def mvarId! : Level \u2192 LMVarId\n  | mvar mvarId => mvarId\n  | _           => panic! \"metavariable expected\"", "start": [190, 1], "end": [192, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isNeverZero", "code": "def isNeverZero : Level \u2192 Bool\n  | zero         => false\n  | param ..     => false\n  | mvar ..      => false\n  | succ ..      => true\n  | max l\u2081 l\u2082    => isNeverZero l\u2081 || isNeverZero l\u2082\n  | imax _  l\u2082   => isNeverZero l\u2082", "start": [194, 1], "end": [202, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.ofNat", "code": "def ofNat : Nat \u2192 Level\n  | 0   => levelZero\n  | n+1 => mkLevelSucc (ofNat n)", "start": [204, 1], "end": [206, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.addOffsetAux", "code": "def addOffsetAux : Nat \u2192 Level \u2192 Level\n  | 0,     u => u\n  | (n+1), u => addOffsetAux n (mkLevelSucc u)", "start": [208, 1], "end": [210, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.addOffset", "code": "def addOffset (u : Level) (n : Nat) : Level :=\n  u.addOffsetAux n", "start": [212, 1], "end": [213, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isExplicit", "code": "def isExplicit : Level \u2192 Bool\n  | zero     => true\n  | succ u   => !u.hasMVar && !u.hasParam && isExplicit u\n  | _        => false", "start": [215, 1], "end": [218, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.getOffsetAux", "code": "def getOffsetAux : Level \u2192 Nat \u2192 Nat\n  | succ u  , r => getOffsetAux u (r+1)\n  | _,        r => r", "start": [220, 1], "end": [222, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.getOffset", "code": "def getOffset (lvl : Level) : Nat :=\n  getOffsetAux lvl 0", "start": [224, 1], "end": [225, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.getLevelOffset", "code": "def getLevelOffset : Level \u2192 Level\n  | succ u   => getLevelOffset u\n  | u        => u", "start": [227, 1], "end": [229, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.toNat", "code": "def toNat (lvl : Level) : Option Nat :=\n  match lvl.getLevelOffset with\n  | zero   => lvl.getOffset\n  | _      => none", "start": [231, 1], "end": [234, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.beq", "code": "@[extern \"lean_level_eq\"]\nprotected opaque beq (a : @& Level) (b : @& Level) : Bool", "start": [236, 1], "end": [237, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.occurs", "code": "def occurs : Level \u2192 Level \u2192 Bool\n  | u, v@(succ v\u2081  )     => u == v || occurs u v\u2081\n  | u, v@(max v\u2081 v\u2082  )   => u == v || occurs u v\u2081 || occurs u v\u2082\n  | u, v@(imax v\u2081 v\u2082  )  => u == v || occurs u v\u2081 || occurs u v\u2082\n  | u, v                 => u == v", "start": [241, 1], "end": [246, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.ctorToNat", "code": "def ctorToNat : Level \u2192 Nat\n  | zero ..  => 0\n  | param .. => 1\n  | mvar ..  => 2\n  | succ ..  => 3\n  | max ..   => 4\n  | imax ..  => 5", "start": [248, 1], "end": [254, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.normLtAux", "code": "partial def normLtAux : Level \u2192 Nat \u2192 Level \u2192 Nat \u2192 Bool\n  | succ l\u2081, k\u2081, l\u2082, k\u2082 => normLtAux l\u2081 (k\u2081+1) l\u2082 k\u2082\n  | l\u2081, k\u2081, succ l\u2082, k\u2082 => normLtAux l\u2081 k\u2081 l\u2082 (k\u2082+1)\n  | l\u2081@(max l\u2081\u2081 l\u2081\u2082), k\u2081, l\u2082@(max l\u2082\u2081 l\u2082\u2082), k\u2082 =>\n    if l\u2081 == l\u2082 then k\u2081 < k\u2082\n    else if l\u2081\u2081 != l\u2082\u2081 then normLtAux l\u2081\u2081 0 l\u2082\u2081 0\n    else normLtAux l\u2081\u2082 0 l\u2082\u2082 0\n  | l\u2081@(imax l\u2081\u2081 l\u2081\u2082), k\u2081, l\u2082@(imax l\u2082\u2081 l\u2082\u2082), k\u2082 =>\n    if l\u2081 == l\u2082 then k\u2081 < k\u2082\n    else if l\u2081\u2081 != l\u2082\u2081 then normLtAux l\u2081\u2081 0 l\u2082\u2081 0\n    else normLtAux l\u2081\u2082 0 l\u2082\u2082 0\n  | param n\u2081, k\u2081, param n\u2082, k\u2082 => if n\u2081 == n\u2082 then k\u2081 < k\u2082 else Name.lt n\u2081 n\u2082 | mvar n\u2081, k\u2081, mvar n\u2082, k\u2082 => if n\u2081 == n\u2082 then k\u2081 < k\u2082 else Name.lt n\u2081.name n\u2082.name\n  | l\u2081, k\u2081, l\u2082, k\u2082 => if l\u2081 == l\u2082 then k\u2081 < k\u2082 else ctorToNat l\u2081 < ctorToNat l\u2082", "start": [257, 1], "end": [276, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.normLt", "code": "def normLt (l\u2081 l\u2082 : Level) : Bool :=\n  normLtAux l\u2081 0 l\u2082 0", "start": [278, 1], "end": [284, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isAlreadyNormalizedCheap", "code": "private def isAlreadyNormalizedCheap : Level \u2192 Bool\n  | zero    => true\n  | param _ => true\n  | mvar _  => true\n  | succ u  => isAlreadyNormalizedCheap u\n  | _       => false", "start": [286, 1], "end": [291, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.mkIMaxAux", "code": "private def mkIMaxAux : Level \u2192 Level \u2192 Level\n  | _,    zero => zero\n  | zero, u    => u\n  | u\u2081,   u\u2082   => if u\u2081 == u\u2082 then u\u2081 else mkLevelIMax u\u2081 u\u2082", "start": [294, 1], "end": [297, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.getMaxArgsAux", "code": "@[specialize] private partial def getMaxArgsAux (normalize : Level \u2192 Level) : Level \u2192 Bool \u2192 Array Level \u2192 Array Level\n  | max l\u2081 l\u2082, alreadyNormalized, lvls => getMaxArgsAux normalize l\u2082 alreadyNormalized (getMaxArgsAux normalize l\u2081 alreadyNormalized lvls)\n  | l,           false,             lvls => getMaxArgsAux normalize (normalize l) true lvls\n  | l,           true,              lvls => lvls.push l", "start": [300, 1], "end": [303, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.accMax", "code": "private def accMax (result : Level) (prev : Level) (offset : Nat) : Level :=\n  if result.isZero then prev.addOffset offset\n  else mkLevelMax result (prev.addOffset offset)", "start": [305, 1], "end": [307, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.mkMaxAux", "code": "private partial def mkMaxAux (lvls : Array Level) (extraK : Nat) (i : Nat) (prev : Level) (prevK : Nat) (result : Level) : Level :=\n  if h : i < lvls.size then\n    let lvl   := lvls.get \u27e8i, h\u27e9\n    let curr  := lvl.getLevelOffset\n    let currK := lvl.getOffset\n    if curr == prev then\n      mkMaxAux lvls extraK (i+1) curr currK result\n    else\n      mkMaxAux lvls extraK (i+1) curr currK (accMax result prev (extraK + prevK))\n  else\n    accMax result prev (extraK + prevK)", "start": [317, 1], "end": [327, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.skipExplicit", "code": "private partial def skipExplicit (lvls : Array Level) (i : Nat) : Nat :=\n  if h : i < lvls.size then\n    let lvl := lvls.get \u27e8i, h\u27e9\n    if lvl.getLevelOffset.isZero then skipExplicit lvls (i+1) else i\n  else\n    i", "start": [332, 1], "end": [337, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isExplicitSubsumedAux", "code": "private partial def isExplicitSubsumedAux (lvls : Array Level) (maxExplicit : Nat) (i : Nat) : Bool :=\n  if h : i < lvls.size then\n    let lvl := lvls.get \u27e8i, h\u27e9\n    if lvl.getOffset \u2265 maxExplicit then true\n    else isExplicitSubsumedAux lvls maxExplicit (i+1)\n  else\n    false", "start": [339, 1], "end": [352, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isExplicitSubsumed", "code": "private def isExplicitSubsumed (lvls : Array Level) (firstNonExplicit : Nat) : Bool :=\n  if firstNonExplicit == 0 then false\n  else\n    let max := (lvls.get! (firstNonExplicit - 1)).getOffset;\n    isExplicitSubsumedAux lvls max firstNonExplicit", "start": [355, 1], "end": [359, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.normalize", "code": "partial def normalize (l : Level) : Level :=\n  if isAlreadyNormalizedCheap l then l\n  else\n    let k := l.getOffset\n    let u := l.getLevelOffset\n    match u with\n    | max l\u2081 l\u2082 =>\n      let lvls  := getMaxArgsAux normalize l\u2081 false #[]\n      let lvls  := getMaxArgsAux normalize l\u2082 false lvls\n      let lvls  := lvls.qsort normLt\n      let firstNonExplicit := skipExplicit lvls 0\n      let i := if isExplicitSubsumed lvls firstNonExplicit then firstNonExplicit else firstNonExplicit - 1\n      let lvl\u2081  := lvls[i]!\n      let prev  := lvl\u2081.getLevelOffset\n      let prevK := lvl\u2081.getOffset\n      mkMaxAux lvls k (i+1) prev prevK levelZero\n    | imax l\u2081 l\u2082 =>\n      if l\u2082.isNeverZero then addOffset (normalize (mkLevelMax l\u2081 l\u2082)) k\n      else\n        let l\u2081 := normalize l\u2081\n        let l\u2082 := normalize l\u2082\n        addOffset (mkIMaxAux l\u2081 l\u2082) k\n    | _ => unreachable!", "start": [361, 1], "end": [383, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.isEquiv", "code": "def isEquiv (u v : Level) : Bool :=\n  u == v || u.normalize == v.normalize", "start": [385, 1], "end": [390, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.dec", "code": "def dec : Level \u2192 Option Level\n  | zero       => none\n  | param _    => none\n  | mvar _     => none\n  | succ l     => l\n  | max l\u2081 l\u2082  => return mkLevelMax (\u2190 dec l\u2081) (\u2190 dec l\u2082)\n  \n  | imax l\u2081 l\u2082 => return mkLevelMax (\u2190  dec l\u2081) (\u2190 dec l\u2082)", "start": [392, 1], "end": [401, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.PP.Result", "code": "inductive Result where\n  | leaf      : Name \u2192 Result\n  | num       : Nat \u2192 Result\n  | offset    : Result \u2192 Nat \u2192 Result\n  | maxNode   : List Result \u2192 Result\n  | imaxNode  : List Result \u2192 Result", "start": [406, 1], "end": [411, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.PP.Result.succ", "code": "def Result.succ : Result \u2192 Result\n  | Result.offset f k => Result.offset f (k+1)\n  | Result.num k      => Result.num (k+1)\n  | f                 => Result.offset f 1", "start": [413, 1], "end": [416, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.PP.Result.max", "code": "def Result.max : Result \u2192 Result \u2192 Result\n  | f, Result.maxNode Fs => Result.maxNode (f::Fs)\n  | f\u2081, f\u2082               => Result.maxNode [f\u2081, f\u2082]", "start": [418, 1], "end": [420, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.PP.Result.imax", "code": "def Result.imax : Result \u2192 Result \u2192 Result\n  | f, Result.imaxNode Fs => Result.imaxNode (f::Fs)\n  | f\u2081, f\u2082                => Result.imaxNode [f\u2081, f\u2082]", "start": [422, 1], "end": [424, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.PP.toResult", "code": "def toResult : Level \u2192 Result\n  | zero       => Result.num 0\n  | succ l     => Result.succ (toResult l)\n  | max l\u2081 l\u2082  => Result.max (toResult l\u2081) (toResult l\u2082)\n  | imax l\u2081 l\u2082 => Result.imax (toResult l\u2081) (toResult l\u2082)\n  | param n    => Result.leaf n\n  | mvar n     =>\n    let n := n.name.replacePrefix `_uniq (Name.mkSimple \"?u\");\n    Result.leaf n", "start": [426, 1], "end": [434, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.PP.parenIfFalse", "code": "private def parenIfFalse : Format \u2192 Bool \u2192 Format\n  | f, true  => f\n  | f, false => f.paren", "start": [436, 1], "end": [438, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.PP.Result.formatLst", "code": "private partial def Result.formatLst : List Result \u2192 Format\n    | []    => Format.nil\n    | r::rs => Format.line ++ format r false ++ formatLst rs", "start": [441, 3], "end": [443, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.PP.Result.format", "code": "partial def Result.format : Result \u2192 Bool \u2192 Format\n    | Result.leaf n,         _ => Std.format n\n    | Result.num k,          _ => toString k\n    | Result.offset f 0,     r => format f r\n    | Result.offset f (k+1), r =>\n      let f' := format f false;\n      parenIfFalse (f' ++ \"+\" ++ Std.format (k+1)) r\n    | Result.maxNode fs,    r => parenIfFalse (Format.group <| \"max\"  ++ formatLst fs) r\n    | Result.imaxNode fs,   r => parenIfFalse (Format.group <| \"imax\" ++ formatLst fs) r", "start": [445, 3], "end": [453, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.PP.Result.quote", "code": "protected partial def Result.quote (r : Result) (prec : Nat) : Syntax.Level :=\n  let addParen (s : Syntax.Level) :=\n    if prec > 0 then Unhygienic.run `(level| ( $s )) else s\n  match r with\n  | Result.leaf n         => Unhygienic.run `(level| $(mkIdent n):ident)\n  | Result.num  k         => Unhygienic.run `(level| $(quote k):num)\n  | Result.offset r 0     => Result.quote r prec\n  | Result.offset r (k+1) => addParen <| Unhygienic.run `(level| $(Result.quote r 65) + $(quote (k+1)):num)\n  | Result.maxNode rs     => addParen <| Unhygienic.run `(level| max $(rs.toArray.map (Result.quote \u00b7 max_prec))*)\n  | Result.imaxNode rs    => addParen <| Unhygienic.run `(level| imax $(rs.toArray.map (Result.quote \u00b7 max_prec))*)", "start": [456, 1], "end": [465, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.format", "code": "protected def format (u : Level) : Format :=\n  (PP.toResult u).format true", "start": [469, 1], "end": [470, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.quote", "code": "protected def quote (u : Level) (prec : Nat := 0) : Syntax.Level :=\n  (PP.toResult u).quote prec", "start": [478, 1], "end": [479, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelMaxCore", "code": "@[inline] private def mkLevelMaxCore (u v : Level) (elseK : Unit \u2192 Level) : Level :=\n  let subsumes (u v : Level) : Bool :=\n    if v.isExplicit && u.getOffset \u2265 v.getOffset then true\n    else match u with\n      | Level.max u\u2081 u\u2082 => v == u\u2081 || v == u\u2082\n      | _ => false\n  if u == v then u\n  else if u.isZero then v\n  else if v.isZero then u\n  else if subsumes u v then u\n  else if subsumes v u then v\n  else if u.getLevelOffset == v.getLevelOffset then\n    if u.getOffset \u2265 v.getOffset then u else v\n  else\n    elseK ()", "start": [486, 1], "end": [500, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelMax'", "code": "def mkLevelMax' (u v : Level) : Level :=\n  mkLevelMaxCore u v fun _ => mkLevelMax u v", "start": [503, 1], "end": [504, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.simpLevelMax'", "code": "def simpLevelMax' (u v : Level) (d : Level) : Level :=\n  mkLevelMaxCore u v fun _ => d", "start": [506, 1], "end": [507, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelIMaxCore", "code": "@[inline] private def mkLevelIMaxCore (u v : Level) (elseK : Unit \u2192 Level) : Level :=\n  if v.isNeverZero then mkLevelMax' u v\n  else if v.isZero then v\n  else if u.isZero then v\n  else if u == v then u\n  else elseK ()", "start": [509, 1], "end": [514, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLevelIMax'", "code": "def mkLevelIMax' (u v : Level) : Level :=\n  mkLevelIMaxCore u v fun _ => mkLevelIMax u v", "start": [517, 1], "end": [518, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.simpLevelIMax'", "code": "def simpLevelIMax' (u v : Level) (d : Level) :=\n  mkLevelIMaxCore u v fun _ => d", "start": [520, 1], "end": [521, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.updateSucc!Impl", "code": "@[inline] private unsafe def updateSucc!Impl (lvl : Level) (newLvl : Level) : Level :=\n  match lvl with\n  | succ l => if ptrEq l newLvl then lvl else mkLevelSucc newLvl\n  | _      => panic! \"succ level expected\"", "start": [531, 1], "end": [534, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.updateSucc!", "code": "@[implemented_by updateSucc!Impl]\ndef updateSucc! (lvl : Level) (newLvl : Level) : Level :=\n  match lvl with\n  | succ _ => mkLevelSucc newLvl\n  | _      => panic! \"succ level expected\"", "start": [536, 1], "end": [540, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.updateMax!Impl", "code": "@[inline] private unsafe def updateMax!Impl (lvl : Level) (newLhs : Level) (newRhs : Level) : Level :=\n  match lvl with\n  | max lhs rhs => if ptrEq lhs newLhs && ptrEq rhs newRhs then simpLevelMax' newLhs newRhs lvl else mkLevelMax' newLhs newRhs\n  | _           => panic! \"max level expected\"", "start": [542, 1], "end": [545, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.updateMax!", "code": "@[implemented_by updateMax!Impl]\ndef updateMax! (lvl : Level) (newLhs : Level) (newRhs : Level) : Level :=\n  match lvl with\n  | max _ _ => mkLevelMax' newLhs newRhs\n  | _       => panic! \"max level expected\"", "start": [547, 1], "end": [551, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.updateIMax!Impl", "code": "@[inline] private unsafe def updateIMax!Impl (lvl : Level) (newLhs : Level) (newRhs : Level) : Level :=\n  match lvl with\n  | imax lhs rhs => if ptrEq lhs newLhs && ptrEq rhs newRhs then simpLevelIMax' newLhs newRhs lvl else mkLevelIMax' newLhs newRhs\n  | _            => panic! \"imax level expected\"", "start": [553, 1], "end": [556, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.updateIMax!", "code": "@[implemented_by updateIMax!Impl]\ndef updateIMax! (lvl : Level) (newLhs : Level) (newRhs : Level) : Level :=\n  match lvl with\n  | imax _ _ => mkLevelIMax' newLhs newRhs\n  | _        => panic! \"imax level expected\"", "start": [558, 1], "end": [562, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.mkNaryMax", "code": "def mkNaryMax : List Level \u2192 Level\n  | []    => levelZero\n  | [u]   => u\n  | u::us => mkLevelMax' u (mkNaryMax us)", "start": [564, 1], "end": [567, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.substParams", "code": "@[specialize] def substParams (u : Level) (s : Name \u2192 Option Level) : Level :=\n  go u\nwhere\n  go (u : Level) : Level :=\n    match u with\n    | .zero       => u\n    | .succ v     => if u.hasParam then u.updateSucc! (go v) else u\n    | .max v\u2081 v\u2082  => if u.hasParam then u.updateMax! (go v\u2081) (go v\u2082) else u\n    | .imax v\u2081 v\u2082 => if u.hasParam then u.updateIMax! (go v\u2081) (go v\u2082) else u\n    | .param n    => match s n with\n      | some u' => u'\n      | none    => u\n    | u => u", "start": [569, 1], "end": [581, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.getParamSubst", "code": "def getParamSubst : List Name \u2192 List Level \u2192 Name \u2192 Option Level\n  | p::ps, u::us, p' => if p == p' then some u else getParamSubst ps us p'\n  | _,     _,     _  => none", "start": [583, 1], "end": [585, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.instantiateParams", "code": "def instantiateParams (u : Level) (paramNames : List Name) (vs : List Level) : Level :=\n  u.substParams (getParamSubst paramNames vs)", "start": [587, 1], "end": [588, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.geq", "code": "def geq (u v : Level) : Bool :=\n  go u.normalize v.normalize\nwhere\n  go (u v : Level) : Bool :=\n    u == v ||\n    match u, v with\n    | _,          zero       => true\n    | u,          max v\u2081 v\u2082  => go u v\u2081 && go u v\u2082\n    | max u\u2081 u\u2082,  v          => go u\u2081 v || go u\u2082 v\n    | u,          imax v\u2081 v\u2082 => go u v\u2081 && go u v\u2082\n    | imax _  u\u2082, v          => go u\u2082 v\n    | succ u,     succ v     => go u v\n    | _, _ =>\n      let v' := v.getLevelOffset\n      (u.getLevelOffset == v' || v'.isZero)\n      && u.getOffset \u2265 v.getOffset\ntermination_by _ u v => (u, v)", "start": [590, 1], "end": [606, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.LevelMap", "code": "abbrev LevelMap (\u03b1 : Type)  := HashMap Level \u03b1", "start": [610, 1], "end": [610, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentLevelMap", "code": "abbrev PersistentLevelMap (\u03b1 : Type) := PHashMap Level \u03b1", "start": [611, 1], "end": [611, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.LevelSet", "code": "abbrev LevelSet := HashSet Level", "start": [612, 1], "end": [612, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentLevelSet", "code": "abbrev PersistentLevelSet := PHashSet Level", "start": [613, 1], "end": [613, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.PLevelSet", "code": "abbrev PLevelSet := PersistentLevelSet", "start": [614, 1], "end": [614, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.collectMVars", "code": "def Level.collectMVars (u : Level) (s : LMVarIdSet := {}) : LMVarIdSet :=\n  match u with\n  | succ v   => collectMVars v s\n  | max u v  => collectMVars u (collectMVars v s)\n  | imax u v => collectMVars u (collectMVars v s)\n  | mvar n   => s.insert n\n  | _        => s", "start": [616, 1], "end": [622, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.find?", "code": "def Level.find? (u : Level) (p : Level \u2192 Bool) : Option Level :=\n  let rec visit (u : Level) : Option Level :=\n    if p u then\n      return u\n    else match u with\n      | succ v   => visit v\n      | max u v  => visit u <|> visit v\n      | imax u v => visit u <|> visit v\n      | _          => failure\n  visit u", "start": [624, 1], "end": [633, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Level.any", "code": "def Level.any (u : Level) (p : Level \u2192 Bool) : Bool :=\n  u.find? p |>.isSome", "start": [635, 1], "end": [636, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.toLevel", "code": "abbrev Nat.toLevel (n : Nat) : Lean.Level :=\n  Lean.Level.ofNat n", "start": [640, 1], "end": [641, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Json/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/RBTree.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.JsonNumber", "code": "structure JsonNumber where\n  mantissa : Int\n  exponent : Nat\n  deriving DecidableEq", "start": [11, 1], "end": [14, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.fromNat", "code": "protected def fromNat (n : Nat) : JsonNumber := \u27e8n, 0\u27e9", "start": [18, 1], "end": [18, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.fromInt", "code": "protected def fromInt (n : Int) : JsonNumber := \u27e8n, 0\u27e9", "start": [19, 1], "end": [19, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.countDigits", "code": "private partial def countDigits (n : Nat) : Nat :=\n  let rec loop (n digits : Nat) : Nat :=\n    if n \u2264 9 then\n      digits\n    else\n      loop (n/10) (digits+1)\n  loop n 1", "start": [25, 1], "end": [31, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.normalize", "code": "protected def normalize : JsonNumber \u2192 Int \u00d7 Nat \u00d7 Int\n  | \u27e8m, e\u27e9 => Id.run do\n    if m = 0 then (0, 0, 0)\n    else\n      let sign : Int := if m > 0 then 1 else -1\n      let mut mAbs := m.natAbs\n      let nDigits := countDigits mAbs\n      for _ in [0:nDigits] do\n        if mAbs % 10 = 0 then\n          mAbs := mAbs / 10\n        else\n          break\n      (sign, mAbs, -(e : Int) + nDigits)", "start": [34, 1], "end": [47, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.lt", "code": "def lt (a b : JsonNumber) : Bool :=\n  let (as, am, ae) := a.normalize\n  let (bs, bm, be) := b.normalize\n  match (as, bs) with\n  | (-1, 1) => true\n  | (1, -1) => false\n  | _ =>\n    let ((am, ae), (bm, be)) :=\n      if as = -1 && bs = -1 then\n        ((bm, be), (am, ae))\n      else\n        ((am, ae), (bm, be))\n    let amDigits := countDigits am\n    let bmDigits := countDigits bm\n    let (am, bm) :=\n      if amDigits < bmDigits then\n        (am * 10^(bmDigits - amDigits), bm)\n      else\n        (am, bm * 10^(amDigits - bmDigits))\n    if ae < be then true\n    else if ae > be then false\n    else am < bm", "start": [50, 1], "end": [72, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.ltProp", "code": "def ltProp : LT JsonNumber :=\n  \u27e8fun a b => lt a b = true\u27e9", "start": [74, 1], "end": [75, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.toString", "code": "protected def toString : JsonNumber \u2192 String\n  | \u27e8m, 0\u27e9 => m.repr\n  | \u27e8m, e\u27e9 =>\n    let sign := if m \u2265 0 then \"\" else \"-\"\n    let m := m.natAbs\n    let exp : Int := 9 + countDigits m - (e : Int)\n    let exp := if exp < 0 then exp else 0\n    let e' := (10 : Int) ^ (e - exp.natAbs)\n    let left := (m / e').repr\n    if m % e' = 0 && exp = 0 then\n      s!\"{sign}{left}\"\n    else\n      let right := e' + m % e'\n        |>.repr.toSubstring.drop 1\n        |>.dropRightWhile (fun c => c = '0')\n        |>.toString\n      let exp := if exp = 0 then \"\" else \"e\" ++ exp.repr\n      s!\"{sign}{left}.{right}{exp}\"", "start": [89, 1], "end": [111, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.shiftl", "code": "protected def shiftl : JsonNumber \u2192 Nat \u2192 JsonNumber\n  | \u27e8m, e\u27e9, s => \u27e8m * (10 ^ (s - e) : Nat), e - s\u27e9", "start": [114, 1], "end": [118, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.shiftr", "code": "protected def shiftr : JsonNumber \u2192 Nat \u2192 JsonNumber\n  | \u27e8m, e\u27e9, s => \u27e8m, e + s\u27e9", "start": [121, 1], "end": [122, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.toFloat", "code": "def toFloat : JsonNumber \u2192 Float\n  | \u27e8m, e\u27e9 => (if m >= 0 then 1.0 else -1.0) * OfScientific.ofScientific m.natAbs true e", "start": [141, 1], "end": [142, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.fromPositiveFloat!", "code": "private def fromPositiveFloat! (x : Float) : JsonNumber :=\n  match Lean.Syntax.decodeScientificLitVal? (toString x) with\n  | none => panic! s!\"Failed to parse {toString x}\"\n  | some (m, sign, e) => OfScientific.ofScientific m sign e", "start": [144, 1], "end": [150, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonNumber.fromFloat?", "code": "def fromFloat? (x : Float): Sum String JsonNumber :=\n  if x.isNaN then Sum.inl \"NaN\"\n  else if x.isInf then\n    Sum.inl <| if x > 0 then \"Infinity\" else \"-Infinity\"\n  else if x == 0.0 then\n    Sum.inr 0 else if x < 0.0 then\n    Sum.inr <| Neg.neg <| fromPositiveFloat! <| Neg.neg <| x\n  else\n    Sum.inr <| fromPositiveFloat! <| x", "start": [152, 1], "end": [163, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.strLt", "code": "def strLt (a b : String) := Decidable.decide (a < b)", "start": [167, 1], "end": [167, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Json", "code": "inductive Json where\n  | null\n  | bool (b : Bool)\n  | num (n : JsonNumber)\n  | str (s : String)\n  | arr (elems : Array Json)\n  | obj (kvPairs : RBNode String (fun _ => Json))\n  deriving Inhabited", "start": [169, 1], "end": [179, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.beq'", "code": "private partial def beq' : Json \u2192 Json \u2192 Bool\n  | null,   null   => true\n  | bool a, bool b => a == b\n  | num a,  num b  => a == b\n  | str a,  str b  => a == b\n  | arr a,  arr b  =>\n    let _ : BEq Json := \u27e8beq'\u27e9\n    a == b\n  | obj a,  obj b =>\n    let _ : BEq Json := \u27e8beq'\u27e9\n    let szA := a.fold (init := 0) (fun a _ _ => a + 1)\n    let szB := b.fold (init := 0) (fun a _ _ => a + 1)\n    szA == szB && a.all fun field fa =>\n      match b.find compare field with\n      | none    => false\n      | some fb => fa == fb\n  | _,      _      => false", "start": [183, 1], "end": [199, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.mkObj", "code": "def mkObj (o : List (String \u00d7 Json)) : Json :=\n  obj <| Id.run do\n    let mut kvPairs := RBNode.leaf\n    for \u27e8k, v\u27e9 in o do\n      kvPairs := kvPairs.insert compare k v\n    kvPairs", "start": [205, 1], "end": [210, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.isNull", "code": "def isNull : Json -> Bool\n  | null => true\n  | _    => false", "start": [218, 1], "end": [220, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getObj?", "code": "def getObj? : Json \u2192 Except String (RBNode String (fun _ => Json))\n  | obj kvs => return kvs\n  | _       => throw \"object expected\"", "start": [222, 1], "end": [224, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getArr?", "code": "def getArr? : Json \u2192 Except String (Array Json)\n  | arr a => return a\n  | _     => throw \"array expected\"", "start": [226, 1], "end": [228, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getStr?", "code": "def getStr? : Json \u2192 Except String String\n  | str s => return s\n  | _     => throw \"String expected\"", "start": [230, 1], "end": [232, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getNat?", "code": "def getNat? : Json \u2192 Except String Nat\n  | (n : Nat) => return n\n  | _         => throw \"Natural number expected\"", "start": [234, 1], "end": [236, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getInt?", "code": "def getInt? : Json \u2192 Except String Int\n  | (i : Int) => return i\n  | _         => throw \"Integer expected\"", "start": [238, 1], "end": [240, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getBool?", "code": "def getBool? : Json \u2192 Except String Bool\n  | (b : Bool) => return b\n  | _          => throw \"Bool expected\"", "start": [242, 1], "end": [244, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getNum?", "code": "def getNum? : Json \u2192 Except String JsonNumber\n  | num n => return n\n  | _     => throw \"number expected\"", "start": [246, 1], "end": [248, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getObjVal?", "code": "def getObjVal? : Json \u2192 String \u2192 Except String Json\n  | obj kvs, k =>\n    match kvs.find compare k with\n    | some v => return v\n    | none => throw s!\"property not found: {k}\"\n  | _      , _ => throw \"object expected\"", "start": [250, 1], "end": [255, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getArrVal?", "code": "def getArrVal? : Json \u2192 Nat \u2192 Except String Json\n  | arr a, i =>\n    match a.get? i with\n    | some v => return v\n    | none => throw s!\"index out of bounds: {i}\"\n  | _    , _ => throw \"array expected\"", "start": [257, 1], "end": [262, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getObjValD", "code": "def getObjValD (j : Json) (k : String) : Json :=\n  (j.getObjVal? k).toOption.getD null", "start": [264, 1], "end": [265, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.setObjVal!", "code": "def setObjVal! : Json \u2192 String \u2192 Json \u2192 Json\n  | obj kvs, k, v => obj <| kvs.insert compare k v\n  | _      , _, _ => panic! \"Json.setObjVal!: not an object: {j}\"", "start": [267, 1], "end": [269, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.mergeObj", "code": "def mergeObj : Json \u2192 Json \u2192 Json\n  | obj kvs\u2081, obj kvs\u2082 =>\n    obj <| fold (insert compare) kvs\u2081 kvs\u2082\n  | _, j\u2082 => j\u2082", "start": [272, 1], "end": [278, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Structured", "code": "inductive Structured where\n  | arr (elems : Array Json)\n  | obj (kvPairs : RBNode String (fun _ => Json))", "start": [280, 1], "end": [282, 50], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Expr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Level.lean", "lake-packages/lean4/src/lean/Lean/Data/KVMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Literal", "code": "inductive Literal where\n  \n  | natVal (val : Nat)\n  \n  | strVal (val : String)\n  deriving Inhabited, BEq, Repr", "start": [11, 1], "end": [17, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Literal.hash", "code": "protected def Literal.hash : Literal \u2192 UInt64\n  | .natVal v => hash v\n  | .strVal v => hash v", "start": [19, 1], "end": [21, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Literal.lt", "code": "def Literal.lt : Literal \u2192 Literal \u2192 Bool\n  | .natVal _,  .strVal _  => true\n  | .natVal v\u2081, .natVal v\u2082 => v\u2081 < v\u2082\n  | .strVal v\u2081, .strVal v\u2082 => v\u2081 < v\u2082\n  | _,                 _   => false", "start": [25, 1], "end": [33, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.BinderInfo", "code": "inductive BinderInfo where\n  \n  | default\n  \n  | implicit\n  \n  | strictImplicit\n  \n  | instImplicit\n  deriving Inhabited, BEq, Repr", "start": [40, 1], "end": [74, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.BinderInfo.hash", "code": "def BinderInfo.hash : BinderInfo \u2192 UInt64\n  | .default        => 947\n  | .implicit       => 1019\n  | .strictImplicit => 1087\n  | .instImplicit   => 1153", "start": [76, 1], "end": [80, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.BinderInfo.isExplicit", "code": "def BinderInfo.isExplicit : BinderInfo \u2192 Bool\n  | .implicit       => false\n  | .strictImplicit => false\n  | .instImplicit   => false\n  | _               => true", "start": [82, 1], "end": [90, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.BinderInfo.isInstImplicit", "code": "def BinderInfo.isInstImplicit : BinderInfo \u2192 Bool\n  | BinderInfo.instImplicit => true\n  | _                       => false", "start": [94, 1], "end": [97, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.BinderInfo.isImplicit", "code": "def BinderInfo.isImplicit : BinderInfo \u2192 Bool\n  | BinderInfo.implicit => true\n  | _                   => false", "start": [99, 1], "end": [102, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.BinderInfo.isStrictImplicit", "code": "def BinderInfo.isStrictImplicit : BinderInfo \u2192 Bool\n  | BinderInfo.strictImplicit => true\n  | _                         => false", "start": [104, 1], "end": [107, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.MData", "code": "abbrev MData := KVMap", "start": [109, 1], "end": [110, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MData.empty", "code": "abbrev MData.empty : MData := {}", "start": [111, 1], "end": [111, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.Data", "code": "def Expr.Data := UInt64", "start": [113, 1], "end": [126, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.Data.hash", "code": "def Expr.Data.hash (c : Expr.Data) : UInt64 :=\n  c.toUInt32.toUInt64", "start": [131, 1], "end": [132, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.Data.approxDepth", "code": "def Expr.Data.approxDepth (c : Expr.Data) : UInt8 :=\n  ((c.shiftRight 32).land 255).toUInt8", "start": [137, 1], "end": [138, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.Data.looseBVarRange", "code": "def Expr.Data.looseBVarRange (c : Expr.Data) : UInt32 :=\n  (c.shiftRight 44).toUInt32", "start": [140, 1], "end": [141, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.Data.hasFVar", "code": "def Expr.Data.hasFVar (c : Expr.Data) : Bool :=\n  ((c.shiftRight 40).land 1) == 1", "start": [143, 1], "end": [144, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.Data.hasExprMVar", "code": "def Expr.Data.hasExprMVar (c : Expr.Data) : Bool :=\n  ((c.shiftRight 41).land 1) == 1", "start": [146, 1], "end": [147, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.Data.hasLevelMVar", "code": "def Expr.Data.hasLevelMVar (c : Expr.Data) : Bool :=\n  ((c.shiftRight 42).land 1) == 1", "start": [149, 1], "end": [150, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.Data.hasLevelParam", "code": "def Expr.Data.hasLevelParam (c : Expr.Data) : Bool :=\n  ((c.shiftRight 43).land 1) == 1", "start": [152, 1], "end": [153, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.BinderInfo.toUInt64", "code": "@[extern \"lean_uint8_to_uint64\"]\ndef BinderInfo.toUInt64 : BinderInfo \u2192 UInt64\n  | .default        => 0\n  | .implicit       => 1\n  | .strictImplicit => 2\n  | .instImplicit   => 3", "start": [157, 1], "end": [162, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mkData", "code": "def Expr.mkData\n    (h : UInt64) (looseBVarRange : Nat := 0) (approxDepth : UInt32 := 0)\n    (hasFVar hasExprMVar hasLevelMVar hasLevelParam : Bool := false)\n    : Expr.Data :=\n  let approxDepth : UInt8 := if approxDepth > 255 then 255 else approxDepth.toUInt8\n  assert! (looseBVarRange \u2264 Nat.pow 2 20 - 1)\n  let r : UInt64 :=\n      h.toUInt32.toUInt64 +\n      approxDepth.toUInt64.shiftLeft 32 +\n      hasFVar.toUInt64.shiftLeft 40 +\n      hasExprMVar.toUInt64.shiftLeft 41 +\n      hasLevelMVar.toUInt64.shiftLeft 42 +\n      hasLevelParam.toUInt64.shiftLeft 43 +\n      looseBVarRange.toUInt64.shiftLeft 44\n  r", "start": [164, 1], "end": [178, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mkAppData", "code": "@[inline] def Expr.mkAppData (fData : Data) (aData : Data) : Data :=\n  let depth          := (max fData.approxDepth.toUInt16 aData.approxDepth.toUInt16) + 1\n  let approxDepth    := if depth > 255 then 255 else depth.toUInt8\n  let looseBVarRange := max fData.looseBVarRange aData.looseBVarRange\n  let hash           := mixHash fData aData\n  let fData : UInt64 := fData\n  let aData : UInt64 := aData\n  assert! (looseBVarRange \u2264 (Nat.pow 2 20 - 1).toUInt32)\n  ((fData ||| aData) &&& ((15 : UInt64) <<< (40 : UInt64))) ||| hash.toUInt32.toUInt64 ||| (approxDepth.toUInt64 <<< (32 : UInt64)) ||| (looseBVarRange.toUInt64 <<< (44 : UInt64))", "start": [180, 1], "end": [189, 180], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mkDataForBinder", "code": "@[inline] def Expr.mkDataForBinder (h : UInt64) (looseBVarRange : Nat) (approxDepth : UInt32) (hasFVar hasExprMVar hasLevelMVar hasLevelParam : Bool) : Expr.Data :=\n  Expr.mkData h looseBVarRange approxDepth hasFVar hasExprMVar hasLevelMVar hasLevelParam", "start": [191, 1], "end": [192, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mkDataForLet", "code": "@[inline] def Expr.mkDataForLet (h : UInt64) (looseBVarRange : Nat) (approxDepth : UInt32) (hasFVar hasExprMVar hasLevelMVar hasLevelParam : Bool) : Expr.Data :=\n  Expr.mkData h looseBVarRange approxDepth hasFVar hasExprMVar hasLevelMVar hasLevelParam", "start": [194, 1], "end": [195, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId", "code": "structure FVarId where\n  name : Name\n  deriving Inhabited, BEq, Hashable", "start": [214, 1], "end": [224, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarIdSet", "code": "def FVarIdSet := RBTree FVarId (Name.quickCmp \u00b7.name \u00b7.name)\n  deriving Inhabited, EmptyCollection", "start": [229, 1], "end": [233, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarIdSet.insert", "code": "def FVarIdSet.insert (s : FVarIdSet) (fvarId : FVarId) : FVarIdSet :=\n  RBTree.insert s fvarId", "start": [237, 1], "end": [238, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarIdHashSet", "code": "def FVarIdHashSet := HashSet FVarId\n  deriving Inhabited, EmptyCollection", "start": [240, 1], "end": [245, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarIdMap", "code": "def FVarIdMap (\u03b1 : Type) := RBMap FVarId \u03b1 (Name.quickCmp \u00b7.name \u00b7.name)", "start": [247, 1], "end": [250, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarIdMap.insert", "code": "def FVarIdMap.insert (s : FVarIdMap \u03b1) (fvarId : FVarId) (a : \u03b1) : FVarIdMap \u03b1 :=\n  RBMap.insert s fvarId a", "start": [252, 1], "end": [253, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId", "code": "structure MVarId where\n  name : Name\n  deriving Inhabited, BEq, Hashable, Repr", "start": [260, 1], "end": [263, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarIdSet", "code": "def MVarIdSet := RBTree MVarId (Name.quickCmp \u00b7.name \u00b7.name)\n  deriving Inhabited, EmptyCollection", "start": [268, 1], "end": [269, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarIdSet.insert", "code": "def MVarIdSet.insert (s : MVarIdSet) (mvarId : MVarId) : MVarIdSet :=\n  RBTree.insert s mvarId", "start": [271, 1], "end": [272, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarIdMap", "code": "def MVarIdMap (\u03b1 : Type) := RBMap MVarId \u03b1 (Name.quickCmp \u00b7.name \u00b7.name)", "start": [276, 1], "end": [276, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarIdMap.insert", "code": "def MVarIdMap.insert (s : MVarIdMap \u03b1) (mvarId : MVarId) (a : \u03b1) : MVarIdMap \u03b1 :=\n  RBMap.insert s mvarId a", "start": [278, 1], "end": [279, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr", "code": "inductive Expr where\n  \n  | bvar (deBruijnIndex : Nat)\n\n  \n  | fvar (fvarId : FVarId)\n\n  \n  | mvar (mvarId : MVarId)\n\n  \n  | sort (u : Level)\n\n  \n  | const (declName : Name) (us : List Level)\n\n  \n  | app (fn : Expr) (arg : Expr)\n\n  \n  | lam (binderName : Name) (binderType : Expr) (body : Expr) (binderInfo : BinderInfo)\n\n  \n  | forallE (binderName : Name) (binderType : Expr) (body : Expr) (binderInfo : BinderInfo)\n\n  \n  | letE (declName : Name) (type : Expr) (value : Expr) (body : Expr) (nonDep : Bool)\n\n  \n  | lit : Literal \u2192 Expr\n\n  \n  | mdata (data : MData) (expr : Expr)\n\n  \n  | proj (typeName : Name) (idx : Nat) (struct : Expr)\nwith\n  @[computed_field, extern \"lean_expr_data\"]\n  data : @& Expr \u2192 Data\n    | .const n lvls => mkData (mixHash 5 <| mixHash (hash n) (hash lvls)) 0 0 false false (lvls.any Level.hasMVar) (lvls.any Level.hasParam)\n    | .bvar idx => mkData (mixHash 7 <| hash idx) (idx+1)\n    | .sort lvl => mkData (mixHash 11 <| hash lvl) 0 0 false false lvl.hasMVar lvl.hasParam\n    | .fvar fvarId => mkData (mixHash 13 <| hash fvarId) 0 0 true\n    | .mvar fvarId => mkData (mixHash 17 <| hash fvarId) 0 0 false true\n    | .mdata _m e =>\n      let d := e.data.approxDepth.toUInt32+1\n      mkData (mixHash d.toUInt64 <| e.data.hash) e.data.looseBVarRange.toNat d e.data.hasFVar e.data.hasExprMVar e.data.hasLevelMVar e.data.hasLevelParam\n    | .proj s i e =>\n      let d := e.data.approxDepth.toUInt32+1\n      mkData (mixHash d.toUInt64 <| mixHash (hash s) <| mixHash (hash i) e.data.hash)\n          e.data.looseBVarRange.toNat d e.data.hasFVar e.data.hasExprMVar e.data.hasLevelMVar e.data.hasLevelParam\n    | .app f a => mkAppData f.data a.data\n    | .lam _ t b _ =>\n      let d := (max t.data.approxDepth.toUInt32 b.data.approxDepth.toUInt32) + 1\n      mkDataForBinder (mixHash d.toUInt64 <| mixHash t.data.hash b.data.hash)\n        (max t.data.looseBVarRange.toNat (b.data.looseBVarRange.toNat - 1))\n        d\n        (t.data.hasFVar || b.data.hasFVar)\n        (t.data.hasExprMVar || b.data.hasExprMVar)\n        (t.data.hasLevelMVar || b.data.hasLevelMVar)\n        (t.data.hasLevelParam || b.data.hasLevelParam)\n    | .forallE _ t b _ =>\n      let d := (max t.data.approxDepth.toUInt32 b.data.approxDepth.toUInt32) + 1\n      mkDataForBinder (mixHash d.toUInt64 <| mixHash t.data.hash b.data.hash)\n        (max t.data.looseBVarRange.toNat (b.data.looseBVarRange.toNat - 1))\n        d\n        (t.data.hasFVar || b.data.hasFVar)\n        (t.data.hasExprMVar || b.data.hasExprMVar)\n        (t.data.hasLevelMVar || b.data.hasLevelMVar)\n        (t.data.hasLevelParam || b.data.hasLevelParam)\n    | .letE _ t v b _ =>\n      let d := (max (max t.data.approxDepth.toUInt32 v.data.approxDepth.toUInt32) b.data.approxDepth.toUInt32) + 1\n      mkDataForLet (mixHash d.toUInt64 <| mixHash t.data.hash <| mixHash v.data.hash b.data.hash)\n        (max (max t.data.looseBVarRange.toNat v.data.looseBVarRange.toNat) (b.data.looseBVarRange.toNat - 1))\n        d\n        (t.data.hasFVar || v.data.hasFVar || b.data.hasFVar)\n        (t.data.hasExprMVar || v.data.hasExprMVar || b.data.hasExprMVar)\n        (t.data.hasLevelMVar || v.data.hasLevelMVar || b.data.hasLevelMVar)\n        (t.data.hasLevelParam || v.data.hasLevelParam || b.data.hasLevelParam)\n    | .lit l => mkData (mixHash 3 (hash l))\nderiving Inhabited, Repr", "start": [288, 1], "end": [507, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ctorName", "code": "def ctorName : Expr \u2192 String\n  | bvar ..    => \"bvar\"\n  | fvar ..    => \"fvar\"\n  | mvar ..    => \"mvar\"\n  | sort ..    => \"sort\"\n  | const ..   => \"const\"\n  | app ..     => \"app\"\n  | lam ..     => \"lam\"\n  | forallE .. => \"forallE\"\n  | letE ..    => \"letE\"\n  | lit ..     => \"lit\"\n  | mdata ..   => \"mdata\"\n  | proj ..    => \"proj\"", "start": [511, 1], "end": [524, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hash", "code": "protected def hash (e : Expr) : UInt64 :=\n  e.data.hash", "start": [526, 1], "end": [527, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasFVar", "code": "def hasFVar (e : Expr) : Bool :=\n  e.data.hasFVar", "start": [531, 1], "end": [536, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasExprMVar", "code": "def hasExprMVar (e : Expr) : Bool :=\n  e.data.hasExprMVar", "start": [538, 1], "end": [543, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasLevelMVar", "code": "def hasLevelMVar (e : Expr) : Bool :=\n  e.data.hasLevelMVar", "start": [545, 1], "end": [550, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasMVar", "code": "def hasMVar (e : Expr) : Bool :=\n  let d := e.data\n  d.hasExprMVar || d.hasLevelMVar", "start": [552, 1], "end": [558, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasLevelParam", "code": "def hasLevelParam (e : Expr) : Bool :=\n  e.data.hasLevelParam", "start": [560, 1], "end": [565, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.approxDepth", "code": "def approxDepth (e : Expr) : UInt32 :=\n  e.data.approxDepth.toUInt32", "start": [567, 1], "end": [573, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.looseBVarRange", "code": "def looseBVarRange (e : Expr) : Nat :=\n  e.data.looseBVarRange.toNat", "start": [575, 1], "end": [582, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.binderInfo", "code": "def binderInfo (e : Expr) : BinderInfo :=\n  match e with\n  | .forallE _ _ _ bi => bi\n  | .lam _ _ _ bi => bi\n  | _ => .default", "start": [584, 1], "end": [591, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hashEx", "code": "@[export lean_expr_hash] def hashEx : Expr \u2192 UInt64 := hash", "start": [596, 1], "end": [596, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasFVarEx", "code": "@[export lean_expr_has_fvar] def hasFVarEx : Expr \u2192 Bool := hasFVar", "start": [597, 1], "end": [597, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasExprMVarEx", "code": "@[export lean_expr_has_expr_mvar] def hasExprMVarEx : Expr \u2192 Bool := hasExprMVar", "start": [598, 1], "end": [598, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasLevelMVarEx", "code": "@[export lean_expr_has_level_mvar] def hasLevelMVarEx : Expr \u2192 Bool := hasLevelMVar", "start": [599, 1], "end": [599, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasMVarEx", "code": "@[export lean_expr_has_mvar] def hasMVarEx : Expr \u2192 Bool := hasMVar", "start": [600, 1], "end": [600, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasLevelParamEx", "code": "@[export lean_expr_has_level_param] def hasLevelParamEx : Expr \u2192 Bool := hasLevelParam", "start": [601, 1], "end": [601, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.looseBVarRangeEx", "code": "@[export lean_expr_loose_bvar_range] def looseBVarRangeEx (e : Expr) : UInt32 := e.data.looseBVarRange", "start": [602, 1], "end": [602, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.binderInfoEx", "code": "@[export lean_expr_binder_info] def binderInfoEx : Expr \u2192 BinderInfo := binderInfo", "start": [603, 1], "end": [603, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.mkConst", "code": "def mkConst (declName : Name) (us : List Level := []) : Expr :=\n  .const declName us", "start": [607, 1], "end": [609, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Literal.type", "code": "def Literal.type : Literal \u2192 Expr\n  | .natVal _ => mkConst `Nat\n  | .strVal _ => mkConst `String", "start": [611, 1], "end": [614, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Literal.typeEx", "code": "@[export lean_lit_type]\ndef Literal.typeEx : Literal \u2192 Expr := Literal.type", "start": [616, 1], "end": [617, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBVar", "code": "def mkBVar (idx : Nat) : Expr :=\n  .bvar idx", "start": [619, 1], "end": [621, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.mkSort", "code": "def mkSort (u : Level) : Expr :=\n  .sort u", "start": [623, 1], "end": [625, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.mkFVar", "code": "def mkFVar (fvarId : FVarId) : Expr :=\n  .fvar fvarId", "start": [627, 1], "end": [633, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.mkMVar", "code": "def mkMVar (mvarId : MVarId) : Expr :=\n  .mvar mvarId", "start": [635, 1], "end": [641, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.mkMData", "code": "def mkMData (m : MData) (e : Expr) : Expr :=\n  .mdata m e", "start": [643, 1], "end": [647, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.mkProj", "code": "def mkProj (structName : Name) (idx : Nat) (struct : Expr) : Expr :=\n  .proj structName idx struct", "start": [649, 1], "end": [653, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp", "code": "def mkApp (f a : Expr) : Expr :=\n  .app f a", "start": [655, 1], "end": [659, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLambda", "code": "def mkLambda (x : Name) (bi : BinderInfo) (t : Expr) (b : Expr) : Expr :=\n  .lam x t b bi", "start": [661, 1], "end": [665, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.mkForall", "code": "def mkForall (x : Name) (bi : BinderInfo) (t : Expr) (b : Expr) : Expr :=\n  .forallE x t b bi", "start": [667, 1], "end": [671, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.mkSimpleThunkType", "code": "def mkSimpleThunkType (type : Expr) : Expr :=\n  mkForall Name.anonymous .default (mkConst `Unit) type", "start": [673, 1], "end": [675, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.mkSimpleThunk", "code": "def mkSimpleThunk (type : Expr) : Expr :=\n  mkLambda `_ BinderInfo.default (mkConst `Unit) type", "start": [677, 1], "end": [679, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLet", "code": "def mkLet (x : Name) (t : Expr) (v : Expr) (b : Expr) (nonDep : Bool := false) : Expr :=\n  .letE x t v b nonDep", "start": [681, 1], "end": [685, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAppB", "code": "def mkAppB (f a b : Expr) := mkApp (mkApp f a) b", "start": [687, 1], "end": [687, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp2", "code": "def mkApp2 (f a b : Expr) := mkAppB f a b", "start": [688, 1], "end": [688, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp3", "code": "def mkApp3 (f a b c : Expr) := mkApp (mkAppB f a b) c", "start": [689, 1], "end": [689, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp4", "code": "def mkApp4 (f a b c d : Expr) := mkAppB (mkAppB f a b) c d", "start": [690, 1], "end": [690, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp5", "code": "def mkApp5 (f a b c d e : Expr) := mkApp (mkApp4 f a b c d) e", "start": [691, 1], "end": [691, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp6", "code": "def mkApp6 (f a b c d e\u2081 e\u2082 : Expr) := mkAppB (mkApp4 f a b c d) e\u2081 e\u2082", "start": [692, 1], "end": [692, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp7", "code": "def mkApp7 (f a b c d e\u2081 e\u2082 e\u2083 : Expr) := mkApp3 (mkApp4 f a b c d) e\u2081 e\u2082 e\u2083", "start": [693, 1], "end": [693, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp8", "code": "def mkApp8 (f a b c d e\u2081 e\u2082 e\u2083 e\u2084 : Expr) := mkApp4 (mkApp4 f a b c d) e\u2081 e\u2082 e\u2083 e\u2084", "start": [694, 1], "end": [694, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp9", "code": "def mkApp9 (f a b c d e\u2081 e\u2082 e\u2083 e\u2084 e\u2085 : Expr) := mkApp5 (mkApp4 f a b c d) e\u2081 e\u2082 e\u2083 e\u2084 e\u2085", "start": [695, 1], "end": [695, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.mkApp10", "code": "def mkApp10 (f a b c d e\u2081 e\u2082 e\u2083 e\u2084 e\u2085 e\u2086 : Expr) := mkApp6 (mkApp4 f a b c d) e\u2081 e\u2082 e\u2083 e\u2084 e\u2085 e\u2086", "start": [696, 1], "end": [696, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLit", "code": "def mkLit (l : Literal) : Expr :=\n  .lit l", "start": [698, 1], "end": [702, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRawNatLit", "code": "def mkRawNatLit (n : Nat) : Expr :=\n  mkLit (.natVal n)", "start": [704, 1], "end": [710, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.mkNatLit", "code": "def mkNatLit (n : Nat) : Expr :=\n  let r := mkRawNatLit n\n  mkApp3 (mkConst ``OfNat.ofNat [levelZero]) (mkConst ``Nat) r (mkApp (mkConst ``instOfNatNat) r)", "start": [712, 1], "end": [719, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.mkStrLit", "code": "def mkStrLit (s : String) : Expr :=\n  mkLit (.strVal s)", "start": [721, 1], "end": [723, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBVarEx", "code": "@[export lean_expr_mk_bvar] def mkBVarEx : Nat \u2192 Expr := mkBVar", "start": [725, 1], "end": [725, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.mkFVarEx", "code": "@[export lean_expr_mk_fvar] def mkFVarEx : FVarId \u2192 Expr := mkFVar", "start": [726, 1], "end": [726, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.mkMVarEx", "code": "@[export lean_expr_mk_mvar] def mkMVarEx : MVarId \u2192 Expr := mkMVar", "start": [727, 1], "end": [727, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.mkSortEx", "code": "@[export lean_expr_mk_sort] def mkSortEx : Level \u2192 Expr := mkSort", "start": [728, 1], "end": [728, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.mkConstEx", "code": "@[export lean_expr_mk_const] def mkConstEx (c : Name) (lvls : List Level) : Expr := mkConst c lvls", "start": [729, 1], "end": [729, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAppEx", "code": "@[export lean_expr_mk_app] def mkAppEx : Expr \u2192 Expr \u2192 Expr := mkApp", "start": [730, 1], "end": [730, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLambdaEx", "code": "@[export lean_expr_mk_lambda] def mkLambdaEx (n : Name) (d b : Expr) (bi : BinderInfo) : Expr := mkLambda n bi d b", "start": [731, 1], "end": [731, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.mkForallEx", "code": "@[export lean_expr_mk_forall] def mkForallEx (n : Name) (d b : Expr) (bi : BinderInfo) : Expr := mkForall n bi d b", "start": [732, 1], "end": [732, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLetEx", "code": "@[export lean_expr_mk_let] def mkLetEx (n : Name) (t v b : Expr) : Expr := mkLet n t v b", "start": [733, 1], "end": [733, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLitEx", "code": "@[export lean_expr_mk_lit] def mkLitEx : Literal \u2192 Expr := mkLit", "start": [734, 1], "end": [734, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.mkMDataEx", "code": "@[export lean_expr_mk_mdata] def mkMDataEx : MData \u2192 Expr \u2192 Expr := mkMData", "start": [735, 1], "end": [735, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.mkProjEx", "code": "@[export lean_expr_mk_proj] def mkProjEx : Name \u2192 Nat \u2192 Expr \u2192 Expr := mkProj", "start": [736, 1], "end": [736, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAppN", "code": "def mkAppN (f : Expr) (args : Array Expr) : Expr :=\n  args.foldl mkApp f", "start": [738, 1], "end": [740, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAppRangeAux", "code": "private partial def mkAppRangeAux (n : Nat) (args : Array Expr) (i : Nat) (e : Expr) : Expr :=\n  if i < n then mkAppRangeAux n args (i+1) (mkApp e (args.get! i)) else e", "start": [742, 1], "end": [743, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAppRange", "code": "def mkAppRange (f : Expr) (i j : Nat) (args : Array Expr) : Expr :=\n  mkAppRangeAux j args i f", "start": [745, 1], "end": [747, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAppRev", "code": "def mkAppRev (fn : Expr) (revArgs : Array Expr) : Expr :=\n  revArgs.foldr (fun a r => mkApp r a) fn", "start": [749, 1], "end": [751, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.dbgToString", "code": "@[extern \"lean_expr_dbg_to_string\"]\nopaque dbgToString (e : @& Expr) : String", "start": [755, 1], "end": [756, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.quickLt", "code": "@[extern \"lean_expr_quick_lt\"]\nopaque quickLt (a : @& Expr) (b : @& Expr) : Bool", "start": [758, 1], "end": [760, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.lt", "code": "@[extern \"lean_expr_lt\"]\nopaque lt (a : @& Expr) (b : @& Expr) : Bool", "start": [762, 1], "end": [764, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.eqv", "code": "@[extern \"lean_expr_eqv\"]\nopaque eqv (a : @& Expr) (b : @& Expr) : Bool", "start": [766, 1], "end": [771, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.equal", "code": "@[extern \"lean_expr_equal\"]\nopaque equal (a : @& Expr) (b : @& Expr) : Bool", "start": [776, 1], "end": [781, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isSort", "code": "def isSort : Expr \u2192 Bool\n  | sort .. => true\n  | _       => false", "start": [783, 1], "end": [786, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isType", "code": "def isType : Expr \u2192 Bool\n  | sort (.succ ..) => true\n  | _ => false", "start": [788, 1], "end": [791, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isType0", "code": "def isType0 : Expr \u2192 Bool\n  | sort (.succ .zero) => true\n  | _ => false", "start": [793, 1], "end": [796, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isProp", "code": "def isProp : Expr \u2192 Bool\n  | sort (.zero ..) => true\n  | _ => false", "start": [798, 1], "end": [801, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isBVar", "code": "def isBVar : Expr \u2192 Bool\n  | bvar .. => true\n  | _       => false", "start": [803, 1], "end": [806, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isMVar", "code": "def isMVar : Expr \u2192 Bool\n  | mvar .. => true\n  | _       => false", "start": [808, 1], "end": [811, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isFVar", "code": "def isFVar : Expr \u2192 Bool\n  | fvar .. => true\n  | _       => false", "start": [813, 1], "end": [816, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isApp", "code": "def isApp : Expr \u2192 Bool\n  | app .. => true\n  | _      => false", "start": [818, 1], "end": [821, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isProj", "code": "def isProj : Expr \u2192 Bool\n  | proj ..  => true\n  | _        => false", "start": [823, 1], "end": [826, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isConst", "code": "def isConst : Expr \u2192 Bool\n  | const .. => true\n  | _        => false", "start": [828, 1], "end": [831, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isConstOf", "code": "def isConstOf : Expr \u2192 Name \u2192 Bool\n  | const n .., m => n == m\n  | _,          _ => false", "start": [833, 1], "end": [841, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isFVarOf", "code": "def isFVarOf : Expr \u2192 FVarId \u2192 Bool\n  | .fvar fvarId, fvarId' => fvarId == fvarId'\n  | _, _ => false", "start": [843, 1], "end": [852, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isForall", "code": "def isForall : Expr \u2192 Bool\n  | forallE .. => true\n  | _          => false", "start": [854, 1], "end": [857, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isLambda", "code": "def isLambda : Expr \u2192 Bool\n  | lam .. => true\n  | _      => false", "start": [859, 1], "end": [862, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isBinding", "code": "def isBinding : Expr \u2192 Bool\n  | lam ..     => true\n  | forallE .. => true\n  | _          => false", "start": [864, 1], "end": [868, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isLet", "code": "def isLet : Expr \u2192 Bool\n  | letE .. => true\n  | _       => false", "start": [870, 1], "end": [873, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isMData", "code": "def isMData : Expr \u2192 Bool\n  | mdata .. => true\n  | _        => false", "start": [875, 1], "end": [878, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isLit", "code": "def isLit : Expr \u2192 Bool\n  | lit .. => true\n  | _      => false", "start": [880, 1], "end": [883, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getForallBody", "code": "def getForallBody : Expr \u2192 Expr\n  | forallE _ _ b .. => getForallBody b\n  | e                => e", "start": [885, 1], "end": [892, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getForallBodyMaxDepth", "code": "def getForallBodyMaxDepth : (maxDepth : Nat) \u2192 Expr \u2192 Expr\n  | (n+1), forallE _ _ b _ => getForallBodyMaxDepth n b\n  | 0, e => e\n  | _, e => e", "start": [894, 1], "end": [897, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getForallBinderNames", "code": "def getForallBinderNames : Expr \u2192 List Name\n  | forallE n _ b _ => n :: getForallBinderNames b\n  | _ => []", "start": [899, 1], "end": [903, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppFn", "code": "def getAppFn : Expr \u2192 Expr\n  | app f _ => getAppFn f\n  | e         => e", "start": [905, 1], "end": [912, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppNumArgsAux", "code": "private def getAppNumArgsAux : Expr \u2192 Nat \u2192 Nat\n  | app f _, n => getAppNumArgsAux f (n+1)\n  | _,       n => n", "start": [914, 1], "end": [916, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppNumArgs", "code": "def getAppNumArgs (e : Expr) : Nat :=\n  getAppNumArgsAux e 0", "start": [918, 1], "end": [920, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppArgsAux", "code": "private def getAppArgsAux : Expr \u2192 Array Expr \u2192 Nat \u2192 Array Expr\n  | app f a, as, i => getAppArgsAux f (as.set! i a) (i-1)\n  | _,       as, _ => as", "start": [922, 1], "end": [924, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppArgs", "code": "@[inline] def getAppArgs (e : Expr) : Array Expr :=\n  let dummy := mkSort levelZero\n  let nargs := e.getAppNumArgs\n  getAppArgsAux e (mkArray nargs dummy) (nargs-1)", "start": [926, 1], "end": [930, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppRevArgsAux", "code": "private def getAppRevArgsAux : Expr \u2192 Array Expr \u2192 Array Expr\n  | app f a, as => getAppRevArgsAux f (as.push a)\n  | _,       as => as", "start": [932, 1], "end": [934, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAppRevArgs", "code": "@[inline] def getAppRevArgs (e : Expr) : Array Expr :=\n  getAppRevArgsAux e (Array.mkEmpty e.getAppNumArgs)", "start": [936, 1], "end": [938, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.withAppAux", "code": "@[specialize] def withAppAux (k : Expr \u2192 Array Expr \u2192 \u03b1) : Expr \u2192 Array Expr \u2192 Nat \u2192 \u03b1\n  | app f a, as, i => withAppAux k f (as.set! i a) (i-1)\n  | f,       as, _ => k f as", "start": [940, 1], "end": [942, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.withApp", "code": "@[inline] def withApp (e : Expr) (k : Expr \u2192 Array Expr \u2192 \u03b1) : \u03b1 :=\n  let dummy := mkSort levelZero\n  let nargs := e.getAppNumArgs\n  withAppAux k e (mkArray nargs dummy) (nargs-1)", "start": [944, 1], "end": [948, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.traverseApp", "code": "def traverseApp {M} [Monad M]\n  (f : Expr \u2192 M Expr) (e : Expr) : M Expr :=\n  e.withApp fun fn args => mkAppN <$> f fn <*> args.mapM f", "start": [950, 1], "end": [954, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.withAppRevAux", "code": "@[specialize] private def withAppRevAux (k : Expr \u2192 Array Expr \u2192 \u03b1) : Expr \u2192 Array Expr \u2192 \u03b1\n  | app f a, as => withAppRevAux k f (as.push a)\n  | f,       as => k f as", "start": [956, 1], "end": [958, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.withAppRev", "code": "@[inline] def withAppRev (e : Expr) (k : Expr \u2192 Array Expr \u2192 \u03b1) : \u03b1 :=\n  withAppRevAux k e (Array.mkEmpty e.getAppNumArgs)", "start": [960, 1], "end": [962, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getRevArgD", "code": "def getRevArgD : Expr \u2192 Nat \u2192 Expr \u2192 Expr\n  | app _ a, 0,   _ => a\n  | app f _, i+1, v => getRevArgD f i v\n  | _,       _,   v => v", "start": [964, 1], "end": [967, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getRevArg!", "code": "def getRevArg! : Expr \u2192 Nat \u2192 Expr\n  | app _ a, 0   => a\n  | app f _, i+1 => getRevArg! f i\n  | _,       _   => panic! \"invalid index\"", "start": [969, 1], "end": [972, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getArg!", "code": "@[inline] def getArg! (e : Expr) (i : Nat) (n := e.getAppNumArgs) : Expr :=\n  getRevArg! e (n - i - 1)", "start": [974, 1], "end": [976, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getArgD", "code": "@[inline] def getArgD (e : Expr) (i : Nat) (v\u2080 : Expr) (n := e.getAppNumArgs) : Expr :=\n  getRevArgD e (n - i - 1) v\u2080", "start": [978, 1], "end": [980, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isAppOf", "code": "def isAppOf (e : Expr) (n : Name) : Bool :=\n  match e.getAppFn with\n  | const c _ => c == n\n  | _           => false", "start": [982, 1], "end": [986, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isAppOfArity", "code": "def isAppOfArity : Expr \u2192 Name \u2192 Nat \u2192 Bool\n  | const c _, n, 0   => c == n\n  | app f _,   n, a+1 => isAppOfArity f n a\n  | _,         _, _   => false", "start": [988, 1], "end": [995, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isAppOfArity'", "code": "def isAppOfArity' : Expr \u2192 Name \u2192 Nat \u2192 Bool\n  | mdata _ b , n, a   => isAppOfArity' b n a\n  | const c _,  n, 0   => c == n\n  | app f _,    n, a+1 => isAppOfArity' f n a\n  | _,          _,  _   => false", "start": [997, 1], "end": [1002, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.appFn!", "code": "def appFn! : Expr \u2192 Expr\n  | app f _ => f\n  | _       => panic! \"application expected\"", "start": [1004, 1], "end": [1006, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.appArg!", "code": "def appArg! : Expr \u2192 Expr\n  | app _ a => a\n  | _       => panic! \"application expected\"", "start": [1008, 1], "end": [1010, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.appFn!'", "code": "def appFn!' : Expr \u2192 Expr\n  | mdata _ b => appFn!' b\n  | app f _   => f\n  | _         => panic! \"application expected\"", "start": [1012, 1], "end": [1015, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.appArg!'", "code": "def appArg!' : Expr \u2192 Expr\n  | mdata _ b => appArg!' b\n  | app _ a   => a\n  | _         => panic! \"application expected\"", "start": [1017, 1], "end": [1020, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.sortLevel!", "code": "def sortLevel! : Expr \u2192 Level\n  | sort u => u\n  | _      => panic! \"sort expected\"", "start": [1022, 1], "end": [1024, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.litValue!", "code": "def litValue! : Expr \u2192 Literal\n  | lit v => v\n  | _     => panic! \"literal expected\"", "start": [1026, 1], "end": [1028, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isNatLit", "code": "def isNatLit : Expr \u2192 Bool\n  | lit (Literal.natVal _) => true\n  | _                      => false", "start": [1030, 1], "end": [1032, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.natLit?", "code": "def natLit? : Expr \u2192 Option Nat\n  | lit (Literal.natVal v) => v\n  | _                      => none", "start": [1034, 1], "end": [1036, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isStringLit", "code": "def isStringLit : Expr \u2192 Bool\n  | lit (Literal.strVal _) => true\n  | _                      => false", "start": [1038, 1], "end": [1040, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isCharLit", "code": "def isCharLit (e : Expr) : Bool :=\n  e.isAppOfArity ``Char.ofNat 1 && e.appArg!.isNatLit", "start": [1042, 1], "end": [1043, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.constName!", "code": "def constName! : Expr \u2192 Name\n  | const n _ => n\n  | _         => panic! \"constant expected\"", "start": [1045, 1], "end": [1047, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.constName?", "code": "def constName? : Expr \u2192 Option Name\n  | const n _ => some n\n  | _         => none", "start": [1049, 1], "end": [1051, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.constLevels!", "code": "def constLevels! : Expr \u2192 List Level\n  | const _ ls => ls\n  | _          => panic! \"constant expected\"", "start": [1053, 1], "end": [1055, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.bvarIdx!", "code": "def bvarIdx! : Expr \u2192 Nat\n  | bvar idx => idx\n  | _        => panic! \"bvar expected\"", "start": [1057, 1], "end": [1059, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.fvarId!", "code": "def fvarId! : Expr \u2192 FVarId\n  | fvar n => n\n  | _      => panic! \"fvar expected\"", "start": [1061, 1], "end": [1063, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mvarId!", "code": "def mvarId! : Expr \u2192 MVarId\n  | mvar n => n\n  | _      => panic! \"mvar expected\"", "start": [1065, 1], "end": [1067, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.bindingName!", "code": "def bindingName! : Expr \u2192 Name\n  | forallE n _ _ _ => n\n  | lam n _ _ _     => n\n  | _               => panic! \"binding expected\"", "start": [1069, 1], "end": [1072, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.bindingDomain!", "code": "def bindingDomain! : Expr \u2192 Expr\n  | forallE _ d _ _ => d\n  | lam _ d _ _     => d\n  | _               => panic! \"binding expected\"", "start": [1074, 1], "end": [1077, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.bindingBody!", "code": "def bindingBody! : Expr \u2192 Expr\n  | forallE _ _ b _ => b\n  | lam _ _ b _     => b\n  | _               => panic! \"binding expected\"", "start": [1079, 1], "end": [1082, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.bindingInfo!", "code": "def bindingInfo! : Expr \u2192 BinderInfo\n  | forallE _ _ _ bi => bi\n  | lam _ _ _ bi     => bi\n  | _                => panic! \"binding expected\"", "start": [1084, 1], "end": [1087, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.letName!", "code": "def letName! : Expr \u2192 Name\n  | letE n .. => n\n  | _         => panic! \"let expression expected\"", "start": [1089, 1], "end": [1091, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.letType!", "code": "def letType! : Expr \u2192 Expr\n  | letE _ t .. => t\n  | _           => panic! \"let expression expected\"", "start": [1093, 1], "end": [1095, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.letValue!", "code": "def letValue! : Expr \u2192 Expr\n  | letE _ _ v .. => v\n  | _             => panic! \"let expression expected\"", "start": [1097, 1], "end": [1099, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.letBody!", "code": "def letBody! : Expr \u2192 Expr\n  | letE _ _ _ b .. => b\n  | _               => panic! \"let expression expected\"", "start": [1101, 1], "end": [1103, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.consumeMData", "code": "def consumeMData : Expr \u2192 Expr\n  | mdata _ e => consumeMData e\n  | e         => e", "start": [1105, 1], "end": [1107, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mdataExpr!", "code": "def mdataExpr! : Expr \u2192 Expr\n  | mdata _ e => e\n  | _         => panic! \"mdata expression expected\"", "start": [1109, 1], "end": [1111, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.projExpr!", "code": "def projExpr! : Expr \u2192 Expr\n  | proj _ _ e => e\n  | _          => panic! \"proj expression expected\"", "start": [1113, 1], "end": [1115, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.projIdx!", "code": "def projIdx! : Expr \u2192 Nat\n  | proj _ i _ => i\n  | _          => panic! \"proj expression expected\"", "start": [1117, 1], "end": [1119, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasLooseBVars", "code": "def hasLooseBVars (e : Expr) : Bool :=\n  e.looseBVarRange > 0", "start": [1121, 1], "end": [1122, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isArrow", "code": "def isArrow (e : Expr) : Bool :=\n  match e with\n  | forallE _ _ b _ => !b.hasLooseBVars\n  | _ => false", "start": [1124, 1], "end": [1131, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasLooseBVar", "code": "@[extern \"lean_expr_has_loose_bvar\"]\nopaque hasLooseBVar (e : @& Expr) (bvarIdx : @& Nat) : Bool", "start": [1133, 1], "end": [1134, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasLooseBVarInExplicitDomain", "code": "def hasLooseBVarInExplicitDomain : Expr \u2192 Nat \u2192 Bool \u2192 Bool\n  | Expr.forallE _ d b bi, bvarIdx, tryRange =>\n    (bi.isExplicit && hasLooseBVar d bvarIdx) || hasLooseBVarInExplicitDomain b (bvarIdx+1) tryRange\n  | e, bvarIdx, tryRange => tryRange && hasLooseBVar e bvarIdx", "start": [1136, 1], "end": [1140, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.lowerLooseBVars", "code": "@[extern \"lean_expr_lower_loose_bvars\"]\nopaque lowerLooseBVars (e : @& Expr) (s d : @& Nat) : Expr", "start": [1142, 1], "end": [1150, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.liftLooseBVars", "code": "@[extern \"lean_expr_lift_loose_bvars\"]\nopaque liftLooseBVars (e : @& Expr) (s d : @& Nat) : Expr", "start": [1152, 1], "end": [1155, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.inferImplicit", "code": "def inferImplicit : Expr \u2192 Nat \u2192 Bool \u2192 Expr\n  | Expr.forallE n d b bi, i+1, considerRange =>\n    let b       := inferImplicit b i considerRange\n    let newInfo := if bi.isExplicit && hasLooseBVarInExplicitDomain b 0 considerRange then BinderInfo.implicit else bi\n    mkForall n newInfo d b\n  | e, 0, _ => e\n  | e, _, _ => e", "start": [1157, 1], "end": [1171, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.instantiate", "code": "@[extern \"lean_expr_instantiate\"]\nopaque instantiate (e : @& Expr) (subst : @& Array Expr) : Expr", "start": [1173, 1], "end": [1178, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.instantiate1", "code": "@[extern \"lean_expr_instantiate1\"]\nopaque instantiate1 (e : @& Expr) (subst : @& Expr) : Expr", "start": [1180, 1], "end": [1181, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.instantiateRev", "code": "@[extern \"lean_expr_instantiate_rev\"]\nopaque instantiateRev (e : @& Expr) (subst : @& Array Expr) : Expr", "start": [1183, 1], "end": [1185, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.instantiateRange", "code": "@[extern \"lean_expr_instantiate_range\"]\nopaque instantiateRange (e : @& Expr) (beginIdx endIdx : @& Nat) (xs : @& Array Expr) : Expr", "start": [1187, 1], "end": [1192, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.instantiateRevRange", "code": "@[extern \"lean_expr_instantiate_rev_range\"]\nopaque instantiateRevRange (e : @& Expr) (beginIdx endIdx : @& Nat) (xs : @& Array Expr) : Expr", "start": [1194, 1], "end": [1199, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.abstract", "code": "@[extern \"lean_expr_abstract\"]\nopaque abstract (e : @& Expr) (xs : @& Array Expr) : Expr", "start": [1201, 1], "end": [1203, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.abstractRange", "code": "@[extern \"lean_expr_abstract_range\"]\nopaque abstractRange (e : @& Expr) (n : @& Nat) (xs : @& Array Expr) : Expr", "start": [1205, 1], "end": [1207, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.replaceFVar", "code": "def replaceFVar (e : Expr) (fvar : Expr) (v : Expr) : Expr :=\n  (e.abstract #[fvar]).instantiate1 v", "start": [1209, 1], "end": [1211, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.replaceFVarId", "code": "def replaceFVarId (e : Expr) (fvarId : FVarId) (v : Expr) : Expr :=\n  replaceFVar e (mkFVar fvarId) v", "start": [1213, 1], "end": [1215, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.replaceFVars", "code": "def replaceFVars (e : Expr) (fvars : Array Expr) (vs : Array Expr) : Expr :=\n  (e.abstract fvars).instantiateRev vs", "start": [1217, 1], "end": [1219, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isAtomic", "code": "def isAtomic : Expr \u2192 Bool\n  | Expr.const .. => true\n  | Expr.sort ..  => true\n  | Expr.bvar ..  => true\n  | Expr.lit ..   => true\n  | Expr.mvar ..  => true\n  | Expr.fvar ..  => true\n  | _             => false", "start": [1224, 1], "end": [1232, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.mkDecIsTrue", "code": "def mkDecIsTrue (pred proof : Expr) :=\n  mkAppB (mkConst `Decidable.isTrue) pred proof", "start": [1236, 1], "end": [1237, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.mkDecIsFalse", "code": "def mkDecIsFalse (pred proof : Expr) :=\n  mkAppB (mkConst `Decidable.isFalse) pred proof", "start": [1239, 1], "end": [1240, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.ExprMap", "code": "abbrev ExprMap (\u03b1 : Type)  := HashMap Expr \u03b1", "start": [1242, 1], "end": [1242, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentExprMap", "code": "abbrev PersistentExprMap (\u03b1 : Type) := PHashMap Expr \u03b1", "start": [1243, 1], "end": [1243, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.ExprSet", "code": "abbrev ExprSet := HashSet Expr", "start": [1244, 1], "end": [1244, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentExprSet", "code": "abbrev PersistentExprSet := PHashSet Expr", "start": [1245, 1], "end": [1245, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.PExprSet", "code": "abbrev PExprSet := PersistentExprSet", "start": [1246, 1], "end": [1246, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.ExprStructEq", "code": "structure ExprStructEq where\n  val : Expr\n  deriving Inhabited", "start": [1248, 1], "end": [1251, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ExprStructEq.beq", "code": "protected def beq : ExprStructEq \u2192 ExprStructEq \u2192 Bool\n  | \u27e8e\u2081\u27e9, \u27e8e\u2082\u27e9 => Expr.equal e\u2081 e\u2082", "start": [1257, 1], "end": [1258, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.ExprStructEq.hash", "code": "protected def hash : ExprStructEq \u2192 UInt64\n  | \u27e8e\u27e9 => e.hash", "start": [1260, 1], "end": [1261, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.ExprStructMap", "code": "abbrev ExprStructMap (\u03b1 : Type) := HashMap ExprStructEq \u03b1", "start": [1269, 1], "end": [1269, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentExprStructMap", "code": "abbrev PersistentExprStructMap (\u03b1 : Type) := PHashMap ExprStructEq \u03b1", "start": [1270, 1], "end": [1270, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mkAppRevRangeAux", "code": "private partial def mkAppRevRangeAux (revArgs : Array Expr) (start : Nat) (b : Expr) (i : Nat) : Expr :=\n  if i == start then b\n  else\n    let i := i - 1\n    mkAppRevRangeAux revArgs start (mkApp b (revArgs.get! i)) i", "start": [1274, 1], "end": [1278, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.mkAppRevRange", "code": "def mkAppRevRange (f : Expr) (beginIdx endIdx : Nat) (revArgs : Array Expr) : Expr :=\n  mkAppRevRangeAux revArgs beginIdx f endIdx", "start": [1280, 1], "end": [1282, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.betaRev", "code": "partial def betaRev (f : Expr) (revArgs : Array Expr) (useZeta := false) (preserveMData := false) : Expr :=\n  if revArgs.size == 0 then f\n  else\n    let sz := revArgs.size\n    let rec go (e : Expr) (i : Nat) : Expr :=\n      match e with\n      | Expr.lam _ _ b _ =>\n        if i + 1 < sz then\n          go b (i+1)\n        else\n          let n := sz - (i + 1)\n          mkAppRevRange (b.instantiateRange n sz revArgs) 0 n revArgs\n      | Expr.letE _ _ v b _ =>\n        if useZeta && i < sz then\n          go (b.instantiate1 v) i\n        else\n          let n := sz - i\n          mkAppRevRange (e.instantiateRange n sz revArgs) 0 n revArgs\n      | Expr.mdata k b =>\n        if preserveMData then\n          let n := sz - i\n          mkMData k (mkAppRevRange (b.instantiateRange n sz revArgs) 0 n revArgs)\n        else\n          go b i\n      | b =>\n        let n := sz - i\n        mkAppRevRange (b.instantiateRange n sz revArgs) 0 n revArgs\n    go f 0", "start": [1284, 1], "end": [1326, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.beta", "code": "def beta (f : Expr) (args : Array Expr) : Expr :=\n  betaRev f args.reverse", "start": [1328, 1], "end": [1333, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isHeadBetaTargetFn", "code": "def isHeadBetaTargetFn (useZeta : Bool) : Expr \u2192 Bool\n  | Expr.lam ..         => true\n  | Expr.letE _ _ _ b _ => useZeta && isHeadBetaTargetFn useZeta b\n  | Expr.mdata _ b      => isHeadBetaTargetFn useZeta b\n  | _                   => false", "start": [1335, 1], "end": [1346, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.headBeta", "code": "def headBeta (e : Expr) : Expr :=\n  let f := e.getAppFn\n  if f.isHeadBetaTargetFn false then betaRev f e.getAppRevArgs else e", "start": [1348, 1], "end": [1351, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isHeadBetaTarget", "code": "def isHeadBetaTarget (e : Expr) (useZeta := false) : Bool :=\n  e.isApp && e.getAppFn.isHeadBetaTargetFn useZeta", "start": [1353, 1], "end": [1359, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.etaExpandedBody", "code": "private def etaExpandedBody : Expr \u2192 Nat \u2192 Nat \u2192 Option Expr\n  | app f (bvar j), n+1, i => if j == i then etaExpandedBody f n (i+1) else none\n  | _,              _+1, _ => none\n  | f,              0,   _ => if f.hasLooseBVars then none else some f", "start": [1361, 1], "end": [1364, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.etaExpandedAux", "code": "private def etaExpandedAux : Expr \u2192 Nat \u2192 Option Expr\n  | lam _ _ b _, n => etaExpandedAux b (n+1)\n  | e,           n => etaExpandedBody e n 0", "start": [1366, 1], "end": [1368, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.etaExpanded?", "code": "def etaExpanded? (e : Expr) : Option Expr :=\n  etaExpandedAux e 0", "start": [1370, 1], "end": [1379, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.etaExpandedStrict?", "code": "def etaExpandedStrict? : Expr \u2192 Option Expr\n  | lam _ _ b _ => etaExpandedAux b 1\n  | _           => none", "start": [1381, 1], "end": [1384, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getOptParamDefault?", "code": "def getOptParamDefault? (e : Expr) : Option Expr :=\n  if e.isAppOfArity ``optParam 2 then\n    some e.appArg!\n  else\n    none", "start": [1386, 1], "end": [1391, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getAutoParamTactic?", "code": "def getAutoParamTactic? (e : Expr) : Option Expr :=\n  if e.isAppOfArity ``autoParam 2 then\n    some e.appArg!\n  else\n    none", "start": [1393, 1], "end": [1398, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isOutParam", "code": "@[export lean_is_out_param]\ndef isOutParam (e : Expr) : Bool :=\n  e.isAppOfArity ``outParam 1", "start": [1400, 1], "end": [1403, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isSemiOutParam", "code": "def isSemiOutParam (e : Expr) : Bool :=\n  e.isAppOfArity ``semiOutParam 1", "start": [1405, 1], "end": [1407, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isOptParam", "code": "def isOptParam (e : Expr) : Bool :=\n  e.isAppOfArity ``optParam 2", "start": [1409, 1], "end": [1411, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isAutoParam", "code": "def isAutoParam (e : Expr) : Bool :=\n  e.isAppOfArity ``autoParam 2", "start": [1413, 1], "end": [1415, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.consumeTypeAnnotations", "code": "@[export lean_expr_consume_type_annotations]\npartial def consumeTypeAnnotations (e : Expr) : Expr :=\n  if e.isOptParam || e.isAutoParam then\n    consumeTypeAnnotations e.appFn!.appArg!\n  else if e.isOutParam || e.isSemiOutParam then\n    consumeTypeAnnotations e.appArg!\n  else\n    e", "start": [1417, 1], "end": [1431, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.cleanupAnnotations", "code": "partial def cleanupAnnotations (e : Expr) : Expr :=\n  let e' := e.consumeMData.consumeTypeAnnotations\n  if e' == e then e else cleanupAnnotations e'", "start": [1433, 1], "end": [1442, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasAnyFVar", "code": "@[inline] def hasAnyFVar (e : Expr) (p : FVarId \u2192 Bool) : Bool :=\n  let rec @[specialize] visit (e : Expr) := if !e.hasFVar then false else\n    match e with\n    | Expr.forallE _ d b _   => visit d || visit b\n    | Expr.lam _ d b _       => visit d || visit b\n    | Expr.mdata _ e         => visit e\n    | Expr.letE _ t v b _    => visit t || visit v || visit b\n    | Expr.app f a           => visit f || visit a\n    | Expr.proj _ _ e        => visit e\n    | Expr.fvar fvarId       => p fvarId\n    | _                      => false\n  visit e", "start": [1444, 1], "end": [1456, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.containsFVar", "code": "def containsFVar (e : Expr) (fvarId : FVarId) : Bool :=\n  e.hasAnyFVar (\u00b7 == fvarId)", "start": [1458, 1], "end": [1460, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateApp!Impl", "code": "@[inline] private unsafe def updateApp!Impl (e : Expr) (newFn : Expr) (newArg : Expr) : Expr :=\n  match e with\n  | app fn arg => if ptrEq fn newFn && ptrEq arg newArg then e else mkApp newFn newArg\n  | _          => panic! \"application expected\"", "start": [1468, 1], "end": [1471, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateApp!", "code": "@[implemented_by updateApp!Impl]\ndef updateApp! (e : Expr) (newFn : Expr) (newArg : Expr) : Expr :=\n  match e with\n  | app _ _ => mkApp newFn newArg\n  | _       => panic! \"application expected\"", "start": [1473, 1], "end": [1477, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateFVar!", "code": "@[inline] def updateFVar! (e : Expr) (fvarIdNew : FVarId) : Expr :=\n  match e with\n  | .fvar fvarId => if fvarId == fvarIdNew then e else .fvar fvarIdNew\n  | _            => panic! \"fvar expected\"", "start": [1479, 1], "end": [1482, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateConst!Impl", "code": "@[inline] private unsafe def updateConst!Impl (e : Expr) (newLevels : List Level) : Expr :=\n  match e with\n  | const n ls => if ptrEqList ls newLevels then e else mkConst n newLevels\n  | _          => panic! \"constant expected\"", "start": [1484, 1], "end": [1487, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateConst!", "code": "@[implemented_by updateConst!Impl]\ndef updateConst! (e : Expr) (newLevels : List Level) : Expr :=\n  match e with\n  | const n _ => mkConst n newLevels\n  | _         => panic! \"constant expected\"", "start": [1489, 1], "end": [1493, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateSort!Impl", "code": "@[inline] private unsafe def updateSort!Impl (e : Expr) (u' : Level) : Expr :=\n  match e with\n  | sort u => if ptrEq u u' then e else mkSort u'\n  | _      => panic! \"level expected\"", "start": [1495, 1], "end": [1498, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateSort!", "code": "@[implemented_by updateSort!Impl]\ndef updateSort! (e : Expr) (newLevel : Level) : Expr :=\n  match e with\n  | sort _ => mkSort newLevel\n  | _      => panic! \"level expected\"", "start": [1500, 1], "end": [1504, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateMData!Impl", "code": "@[inline] private unsafe def updateMData!Impl (e : Expr) (newExpr : Expr) : Expr :=\n  match e with\n  | mdata d a => if ptrEq a newExpr then e else mkMData d newExpr\n  | _         => panic! \"mdata expected\"", "start": [1506, 1], "end": [1509, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateMData!", "code": "@[implemented_by updateMData!Impl]\ndef updateMData! (e : Expr) (newExpr : Expr) : Expr :=\n  match e with\n  | mdata d _ => mkMData d newExpr\n  | _         => panic! \"mdata expected\"", "start": [1511, 1], "end": [1515, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateProj!Impl", "code": "@[inline] private unsafe def updateProj!Impl (e : Expr) (newExpr : Expr) : Expr :=\n  match e with\n  | proj s i a => if ptrEq a newExpr then e else mkProj s i newExpr\n  | _          => panic! \"proj expected\"", "start": [1517, 1], "end": [1520, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateProj!", "code": "@[implemented_by updateProj!Impl]\ndef updateProj! (e : Expr) (newExpr : Expr) : Expr :=\n  match e with\n  | proj s i _ => mkProj s i newExpr\n  | _          => panic! \"proj expected\"", "start": [1522, 1], "end": [1526, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateForall!Impl", "code": "@[inline] private unsafe def updateForall!Impl (e : Expr) (newBinfo : BinderInfo) (newDomain : Expr) (newBody : Expr) : Expr :=\n  match e with\n  | forallE n d b bi =>\n    if ptrEq d newDomain && ptrEq b newBody && bi == newBinfo then\n      e\n    else\n      mkForall n newBinfo newDomain newBody\n  | _               => panic! \"forall expected\"", "start": [1528, 1], "end": [1535, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateForall!", "code": "@[implemented_by updateForall!Impl]\ndef updateForall! (e : Expr) (newBinfo : BinderInfo) (newDomain : Expr) (newBody : Expr) : Expr :=\n  match e with\n  | forallE n _ _ _ => mkForall n newBinfo newDomain newBody\n  | _               => panic! \"forall expected\"", "start": [1537, 1], "end": [1541, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateForallE!", "code": "@[inline] def updateForallE! (e : Expr) (newDomain : Expr) (newBody : Expr) : Expr :=\n  match e with\n  | forallE n d b bi => updateForall! (forallE n d b bi) bi newDomain newBody\n  | _                => panic! \"forall expected\"", "start": [1543, 1], "end": [1546, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateLambda!Impl", "code": "@[inline] private unsafe def updateLambda!Impl (e : Expr) (newBinfo : BinderInfo) (newDomain : Expr) (newBody : Expr) : Expr :=\n  match e with\n  | lam n d b bi =>\n    if ptrEq d newDomain && ptrEq b newBody && bi == newBinfo then\n      e\n    else\n      mkLambda n newBinfo newDomain newBody\n  | _           => panic! \"lambda expected\"", "start": [1548, 1], "end": [1555, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateLambda!", "code": "@[implemented_by updateLambda!Impl]\ndef updateLambda! (e : Expr) (newBinfo : BinderInfo) (newDomain : Expr) (newBody : Expr) : Expr :=\n  match e with\n  | lam n _ _ _ => mkLambda n newBinfo newDomain newBody\n  | _           => panic! \"lambda expected\"", "start": [1557, 1], "end": [1561, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateLambdaE!", "code": "@[inline] def updateLambdaE! (e : Expr) (newDomain : Expr) (newBody : Expr) : Expr :=\n  match e with\n  | lam n d b bi => updateLambda! (lam n d b bi) bi newDomain newBody\n  | _            => panic! \"lambda expected\"", "start": [1563, 1], "end": [1566, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateLet!Impl", "code": "@[inline] private unsafe def updateLet!Impl (e : Expr) (newType : Expr) (newVal : Expr) (newBody : Expr) : Expr :=\n  match e with\n  | letE n t v b nonDep =>\n    if ptrEq t newType && ptrEq v newVal && ptrEq b newBody then\n      e\n    else\n      letE n newType newVal newBody nonDep\n  | _              => panic! \"let expression expected\"", "start": [1568, 1], "end": [1575, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateLet!", "code": "@[implemented_by updateLet!Impl]\ndef updateLet! (e : Expr) (newType : Expr) (newVal : Expr) (newBody : Expr) : Expr :=\n  match e with\n  | letE n _ _ _ c => letE n newType newVal newBody c\n  | _              => panic! \"let expression expected\"", "start": [1577, 1], "end": [1581, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.updateFn", "code": "def updateFn : Expr \u2192 Expr \u2192 Expr\n  | e@(app f a), g => e.updateApp! (updateFn f g) a\n  | _,           g => g", "start": [1583, 1], "end": [1585, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.eta", "code": "partial def eta (e : Expr) : Expr :=\n  match e with\n  | Expr.lam _ d b _ =>\n    let b' := b.eta\n    match b' with\n    | .app f (.bvar 0) =>\n      if !f.hasLooseBVar 0 then\n        f.lowerLooseBVars 1 1\n      else\n        e.updateLambdaE! d b'\n    | _ => e.updateLambdaE! d b'\n  | _ => e", "start": [1587, 1], "end": [1601, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.setOption", "code": "def setOption (e : Expr) (optionName : Name) [KVMap.Value \u03b1] (val : \u03b1) : Expr :=\n  mkMData (MData.empty.set optionName val) e", "start": [1603, 1], "end": [1608, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.setPPExplicit", "code": "def setPPExplicit (e : Expr) (flag : Bool) :=\n  e.setOption `pp.explicit flag", "start": [1610, 1], "end": [1615, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.setPPUniverses", "code": "def setPPUniverses (e : Expr) (flag : Bool) :=\n  e.setOption `pp.universes flag", "start": [1617, 1], "end": [1622, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.setAppPPExplicit", "code": "def setAppPPExplicit (e : Expr) : Expr :=\n  match e with\n  | app .. =>\n    let f    := e.getAppFn.setPPExplicit false\n    let args := e.getAppArgs.map (\u00b7.setPPExplicit false)\n    mkAppN f args |>.setPPExplicit true\n  | _      => e", "start": [1624, 1], "end": [1634, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.setAppPPExplicitForExposingMVars", "code": "def setAppPPExplicitForExposingMVars (e : Expr) : Expr :=\n  match e with\n  | app .. =>\n    let f    := e.getAppFn.setPPExplicit false\n    let args := e.getAppArgs.map fun arg => if arg.hasMVar then arg else arg.setPPExplicit false\n    mkAppN f args |>.setPPExplicit true\n  | _      => e", "start": [1636, 1], "end": [1646, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAnnotation", "code": "def mkAnnotation (kind : Name) (e : Expr) : Expr :=\n  mkMData (KVMap.empty.insert kind (DataValue.ofBool true)) e", "start": [1650, 1], "end": [1655, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.annotation?", "code": "def annotation? (kind : Name) (e : Expr) : Option Expr :=\n  match e with\n  | .mdata d b => if d.size == 1 && d.getBool kind false then some b else none\n  | _          => none", "start": [1657, 1], "end": [1663, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLetFunAnnotation", "code": "def mkLetFunAnnotation (e : Expr) : Expr :=\n  mkAnnotation `let_fun e", "start": [1665, 1], "end": [1671, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.letFunAnnotation?", "code": "def letFunAnnotation? (e : Expr) : Option Expr :=\n  annotation? `let_fun e", "start": [1673, 1], "end": [1677, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.isLetFun", "code": "def isLetFun (e : Expr) : Bool :=\n  match letFunAnnotation? e with\n  | none   => false\n  | some e => e.isApp && e.appFn!.isLambda", "start": [1679, 1], "end": [1685, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.mkInaccessible", "code": "def mkInaccessible (e : Expr) : Expr :=\n  mkAnnotation `_inaccessible e", "start": [1687, 1], "end": [1692, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.inaccessible?", "code": "def inaccessible? (e : Expr) : Option Expr :=\n  annotation? `_inaccessible e", "start": [1694, 1], "end": [1696, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.patternRefAnnotationKey", "code": "private def patternRefAnnotationKey := `_patWithRef", "start": [1698, 1], "end": [1698, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.patternWithRef?", "code": "def patternWithRef? (p : Expr) : Option (Syntax \u00d7 Expr) :=\n  match p with\n  | .mdata d _ =>\n    match d.find patternRefAnnotationKey with\n    | some (DataValue.ofSyntax stx) => some (stx, p.mdataExpr!)\n    | _ => none\n  | _ => none", "start": [1700, 1], "end": [1711, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.isPatternWithRef", "code": "def isPatternWithRef (p : Expr) : Bool :=\n  patternWithRef? p |>.isSome", "start": [1713, 1], "end": [1714, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.mkPatternWithRef", "code": "def mkPatternWithRef (p : Expr) (stx : Syntax) : Expr :=\n  if patternWithRef? p |>.isSome then\n    p\n  else\n    mkMData (KVMap.empty.insert patternRefAnnotationKey (DataValue.ofSyntax stx)) p", "start": [1716, 1], "end": [1724, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.patternAnnotation?", "code": "def patternAnnotation? (e : Expr) : Option Expr :=\n  if let some e := inaccessible? e then\n    some e\n  else if let some (_, e) := patternWithRef? e then\n    some e\n  else\n    none", "start": [1726, 1], "end": [1733, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLHSGoalRaw", "code": "def mkLHSGoalRaw (e : Expr) : Expr :=\n  mkAnnotation `_lhsGoal e", "start": [1735, 1], "end": [1743, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.isLHSGoal?", "code": "def isLHSGoal? (e : Expr) : Option Expr :=\n  match annotation? `_lhsGoal e with\n  | none => none\n  | some e =>\n    if e.isAppOfArity `Eq 3 then\n      some e.appFn!.appArg!\n    else\n      none", "start": [1745, 1], "end": [1753, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.mkFreshFVarId", "code": "def mkFreshFVarId [Monad m] [MonadNameGenerator m] : m FVarId :=\n  return { name := (\u2190 mkFreshId) }", "start": [1755, 1], "end": [1760, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.mkFreshMVarId", "code": "def mkFreshMVarId [Monad m] [MonadNameGenerator m] : m MVarId :=\n  return { name := (\u2190 mkFreshId) }", "start": [1762, 1], "end": [1767, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.mkFreshLMVarId", "code": "def mkFreshLMVarId [Monad m] [MonadNameGenerator m] : m LMVarId :=\n  return { name := (\u2190 mkFreshId) }", "start": [1769, 1], "end": [1774, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.mkNot", "code": "def mkNot (p : Expr) : Expr := mkApp (mkConst ``Not) p", "start": [1776, 1], "end": [1777, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.mkOr", "code": "def mkOr (p q : Expr) : Expr := mkApp2 (mkConst ``Or) p q", "start": [1778, 1], "end": [1779, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAnd", "code": "def mkAnd (p q : Expr) : Expr := mkApp2 (mkConst ``And) p q", "start": [1780, 1], "end": [1781, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.mkEM", "code": "def mkEM (p : Expr) : Expr := mkApp (mkConst ``Classical.em) p", "start": [1782, 1], "end": [1783, 63], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Json/Printer.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Format.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Json.escapeAux", "code": "private def escapeAux (acc : String) (c : Char) : String :=\n  if c = '\"' then acc ++ \"\\\\\\\"\"\n  else if c = '\\\\' then\n    acc ++ \"\\\\\\\\\"\n  else if c = '\\n' then\n    acc ++ \"\\\\n\"\n  else if c = '\\x0d' then\n    acc ++ \"\\\\r\"\n  else if 0x0020 \u2264 c.val \u2227 c.val \u2264 0x10ffff then\n    acc ++ String.singleton c\n  else\n    let n := c.toNat;\n    acc ++ \"\\\\u\" ++\n    [ Nat.digitChar (n / 4096),\n      Nat.digitChar ((n % 4096) / 256),\n      Nat.digitChar ((n % 256) / 16),\n      Nat.digitChar (n % 16) ].asString", "start": [12, 1], "end": [38, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.escape", "code": "def escape (s : String) : String :=\n  s.foldl escapeAux \"\"", "start": [40, 1], "end": [41, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.renderString", "code": "def renderString (s : String) : String :=\n  \"\\\"\" ++ escape s ++ \"\\\"\"", "start": [43, 1], "end": [44, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.render", "code": "partial def render : Json \u2192 Format\n  | null       => \"null\"\n  | bool true  => \"true\"\n  | bool false => \"false\"\n  | num s      => s.toString\n  | str s      => renderString s\n  | arr elems  =>\n    let elems := Format.joinSep (elems.map render).toList (\",\" ++ Format.line);\n    Format.bracket \"[\" elems \"]\"\n  | obj kvs =>\n    let renderKV : String \u2192 Json \u2192 Format := fun k v =>\n      Format.group (renderString k ++ \":\" ++ Format.line ++ render v);\n    let kvs := Format.joinSep (kvs.fold (fun acc k j => renderKV k j :: acc) []) (\",\" ++ Format.line);\n    Format.bracket \"{\" kvs \"}\"", "start": [48, 1], "end": [61, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.pretty", "code": "def pretty (j : Json) (lineWidth := 80) : String :=\n  Format.pretty (render j) lineWidth", "start": [64, 1], "end": [65, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.CompressWorkItem", "code": "protected inductive CompressWorkItem\n  | json (j : Json)\n  | arrayElem (j : Json)\n  | arrayEnd\n  | objectField (k : String) (j : Json)\n  | objectEnd\n  | comma", "start": [67, 1], "end": [73, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.compress", "code": "partial def compress (j : Json) : String :=\n  go \"\" [json j]\nwhere go (acc : String) : List Json.CompressWorkItem \u2192 String\n  | []               => acc\n  | json j :: is =>\n    match j with\n    | null       => go (acc ++ \"null\") is\n    | bool true  => go (acc ++ \"true\") is\n    | bool false => go (acc ++ \"false\") is\n    | num s      => go (acc ++ s.toString) is\n    | str s      => go (acc ++ renderString s) is\n    | arr elems  => go (acc ++ \"[\") (elems.toList.map arrayElem ++ [arrayEnd] ++ is)\n    | obj kvs    => go (acc ++ \"{\") (kvs.fold (init := []) (fun acc k j => objectField k j :: acc) ++ [objectEnd] ++ is)\n  | arrayElem j :: arrayEnd :: is      => go acc (json j :: arrayEnd :: is)\n  | arrayElem j :: is                  => go acc (json j :: comma :: is)\n  | arrayEnd :: is                     => go (acc ++ \"]\") is\n  | objectField k j :: objectEnd :: is => go (acc ++ renderString k ++ \":\") (json j :: objectEnd :: is)\n  | objectField k j :: is              => go (acc ++ renderString k ++ \":\") (json j :: comma :: is)\n  | objectEnd :: is                    => go (acc ++ \"}\") is\n  | comma :: is                        => go (acc ++ \",\") is", "start": [76, 1], "end": [95, 61], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Parsec.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parsec.ParseResult", "code": "inductive ParseResult (\u03b1 : Type) where\n  | success (pos : String.Iterator) (res : \u03b1)\n  | error (pos : String.Iterator) (err : String)\n  deriving Repr", "start": [10, 1], "end": [13, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec", "code": "def Parsec (\u03b1 : Type) : Type := String.Iterator \u2192 Lean.Parsec.ParseResult \u03b1", "start": [16, 1], "end": [16, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.pure", "code": "@[inline]\nprotected def pure (a : \u03b1) : Parsec \u03b1 := \u03bb it =>\n success it a", "start": [25, 1], "end": [27, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.bind", "code": "@[inline]\ndef bind {\u03b1 \u03b2 : Type} (f : Parsec \u03b1) (g : \u03b1 \u2192 Parsec \u03b2) : Parsec \u03b2 := \u03bb it =>\n  match f it with\n  | success rem a => g a rem\n  | error pos msg => error pos msg", "start": [29, 1], "end": [33, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.fail", "code": "@[inline]\ndef fail (msg : String) : Parsec \u03b1 := fun it =>\n  error it msg", "start": [38, 1], "end": [40, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.orElse", "code": "@[inline]\ndef orElse (p : Parsec \u03b1) (q : Unit \u2192 Parsec \u03b1) : Parsec \u03b1 := fun it =>\n  match p it with\n  | success rem a => success rem a\n  | error rem err =>\n    if it = rem then q () it else error rem err", "start": [42, 1], "end": [47, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.attempt", "code": "@[inline]\ndef attempt (p : Parsec \u03b1) : Parsec \u03b1 := \u03bb it =>\n  match p it with\n  | success rem res => success rem res\n  | error _ err => error it err", "start": [49, 1], "end": [53, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.run", "code": "protected def run (p : Parsec \u03b1) (s : String) : Except String \u03b1 :=\n  match p s.mkIterator with\n  | Parsec.ParseResult.success _ res => Except.ok res\n  | Parsec.ParseResult.error it err  => Except.error s!\"offset {repr it.i.byteIdx}: {err}\"", "start": [58, 1], "end": [61, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.expectedEndOfInput", "code": "def expectedEndOfInput := \"expected end of input\"", "start": [63, 1], "end": [63, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.eof", "code": "@[inline]\ndef eof : Parsec Unit := fun it =>\n  if it.hasNext then\n    error it expectedEndOfInput\n  else\n    success it ()", "start": [65, 1], "end": [70, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.manyCore", "code": "@[specialize]\npartial def manyCore (p : Parsec \u03b1) (acc : Array \u03b1) : Parsec $ Array \u03b1 :=\n  (do manyCore p (acc.push $ \u2190p))\n  <|> pure acc", "start": [72, 1], "end": [75, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.many", "code": "@[inline]\ndef many (p : Parsec \u03b1) : Parsec $ Array \u03b1 := manyCore p #[]", "start": [77, 1], "end": [78, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.many1", "code": "@[inline]\ndef many1 (p : Parsec \u03b1) : Parsec $ Array \u03b1 := do manyCore p #[\u2190p]", "start": [80, 1], "end": [81, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.manyCharsCore", "code": "@[specialize]\npartial def manyCharsCore (p : Parsec Char) (acc : String) : Parsec String :=\n  (do manyCharsCore p (acc.push $ \u2190p))\n  <|> pure acc", "start": [83, 1], "end": [86, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.manyChars", "code": "@[inline]\ndef manyChars (p : Parsec Char) : Parsec String := manyCharsCore p \"\"", "start": [88, 1], "end": [89, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.many1Chars", "code": "@[inline]\ndef many1Chars (p : Parsec Char) : Parsec String := do manyCharsCore p (\u2190p).toString", "start": [91, 1], "end": [92, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.pstring", "code": "def pstring (s : String) : Parsec String := \u03bb it =>\n  let substr := it.extract (it.forward s.length)\n  if substr = s then\n    success (it.forward s.length) substr\n  else\n    error it s!\"expected: {s}\"", "start": [94, 1], "end": [100, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.skipString", "code": "@[inline]\ndef skipString (s : String) : Parsec Unit := pstring s *> pure ()", "start": [102, 1], "end": [103, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.unexpectedEndOfInput", "code": "def unexpectedEndOfInput := \"unexpected end of input\"", "start": [105, 1], "end": [105, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.anyChar", "code": "@[inline]\ndef anyChar : Parsec Char := \u03bb it =>\n  if it.hasNext then success it.next it.curr else error it unexpectedEndOfInput", "start": [107, 1], "end": [109, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.pchar", "code": "@[inline]\ndef pchar (c : Char) : Parsec Char := attempt do\n  if (\u2190anyChar) = c then pure c else fail s!\"expected: '{c}'\"", "start": [111, 1], "end": [113, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.skipChar", "code": "@[inline]\ndef skipChar (c : Char) : Parsec Unit := pchar c *> pure ()", "start": [115, 1], "end": [116, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.digit", "code": "@[inline]\ndef digit : Parsec Char := attempt do\n  let c \u2190 anyChar\n  if '0' \u2264 c \u2227 c \u2264 '9' then return c else fail s!\"digit expected\"", "start": [118, 1], "end": [121, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.hexDigit", "code": "@[inline]\ndef hexDigit : Parsec Char := attempt do\n  let c \u2190 anyChar\n  if ('0' \u2264 c \u2227 c \u2264 '9')\n   \u2228 ('a' \u2264 c \u2227 c \u2264 'f')\n   \u2228 ('A' \u2264 c \u2227 c \u2264 'F') then return c else fail s!\"hex digit expected\"", "start": [123, 1], "end": [128, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.asciiLetter", "code": "@[inline]\ndef asciiLetter : Parsec Char := attempt do\n  let c \u2190 anyChar\n  if ('A' \u2264 c \u2227 c \u2264 'Z') \u2228 ('a' \u2264 c \u2227 c \u2264 'z') then return c else fail s!\"ASCII letter expected\"", "start": [130, 1], "end": [133, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.satisfy", "code": "@[inline]\ndef satisfy (p : Char \u2192 Bool) : Parsec Char := attempt do\n  let c \u2190 anyChar\n  if p c then return c else fail \"condition not satisfied\"", "start": [135, 1], "end": [138, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.notFollowedBy", "code": "@[inline]\ndef notFollowedBy (p : Parsec \u03b1) : Parsec Unit := \u03bb it =>\n  match p it with\n  | success _ _ => error it \"\"\n  | error _ _ => success it ()", "start": [140, 1], "end": [144, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.skipWs", "code": "partial def skipWs (it : String.Iterator) : String.Iterator :=\n  if it.hasNext then\n    let c := it.curr\n    if c = '\\u0009' \u2228 c = '\\u000a' \u2228 c = '\\u000d' \u2228 c = '\\u0020' then\n      skipWs it.next\n    else\n      it\n  else\n   it", "start": [146, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.peek?", "code": "@[inline]\ndef peek? : Parsec (Option Char) := fun it =>\n  if it.hasNext then\n    success it it.curr\n  else\n    success it none", "start": [156, 1], "end": [161, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.peek!", "code": "@[inline]\ndef peek! : Parsec Char := do\n  let some c \u2190 peek? | fail unexpectedEndOfInput\n  return c", "start": [163, 1], "end": [166, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.skip", "code": "@[inline]\ndef skip : Parsec Unit := fun it =>\n  success it.next ()", "start": [168, 1], "end": [170, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parsec.ws", "code": "@[inline]\ndef ws : Parsec Unit := fun it =>\n  success (skipWs it) ()", "start": [172, 1], "end": [174, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/PtrSet.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashSet.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Ptr", "code": "structure Ptr (\u03b1 : Type u) where\n  value : \u03b1", "start": [10, 1], "end": [11, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.PtrSet", "code": "unsafe def PtrSet (\u03b1 : Type) :=\n  HashSet (Ptr \u03b1)", "start": [19, 1], "end": [23, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.mkPtrSet", "code": "unsafe def mkPtrSet {\u03b1 : Type} (capacity : Nat := 64) : PtrSet \u03b1 :=\n  mkHashSet capacity", "start": [25, 1], "end": [26, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PtrSet.insert", "code": "unsafe abbrev PtrSet.insert (s : PtrSet \u03b1) (a : \u03b1) : PtrSet \u03b1 :=\n  HashSet.insert s { value := a }", "start": [28, 1], "end": [29, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PtrSet.contains", "code": "unsafe abbrev PtrSet.contains (s : PtrSet \u03b1) (a : \u03b1) : Bool :=\n  HashSet.contains s { value := a }", "start": [31, 1], "end": [32, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.ReplaceImpl.Cache", "code": "structure Cache where\n  size : USize\n  keysResults : Array NonScalar", "start": [13, 1], "end": [17, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.Cache.new", "code": "unsafe def Cache.new (e : Expr) : Cache :=\n  let size := (1 <<< min (max e.approxDepth.toUSize 1) 13) - 1\n  { size, keysResults := mkArray (2 * size).toNat (unsafeCast ()) }", "start": [19, 1], "end": [23, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.Cache.keyIdx", "code": "@[inline]\nunsafe def Cache.keyIdx (c : Cache) (key : Expr) : USize :=\n  ptrAddrUnsafe key % c.size", "start": [25, 1], "end": [27, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.Cache.resultIdx", "code": "@[inline]\nunsafe def Cache.resultIdx (c : Cache) (key : Expr) : USize :=\n  c.keyIdx key + c.size", "start": [29, 1], "end": [31, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.Cache.hasResultFor", "code": "@[inline]\nunsafe def Cache.hasResultFor (c : Cache) (key : Expr) : Bool :=\n  have : (c.keyIdx key).toNat < c.keysResults.size := lcProof\n  ptrEq (unsafeCast key) c.keysResults[c.keyIdx key]", "start": [33, 1], "end": [36, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.Cache.getResultFor", "code": "@[inline]\nunsafe def Cache.getResultFor (c : Cache) (key : Expr) : Expr :=\n  have : (c.resultIdx key).toNat < c.keysResults.size := lcProof\n  unsafeCast c.keysResults[c.resultIdx key]", "start": [38, 1], "end": [41, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.Cache.store", "code": "unsafe def Cache.store (c : Cache) (key result : Expr) : Cache :=\n  { c with keysResults := c.keysResults\n    |>.uset (c.keyIdx key) (unsafeCast key) lcProof\n    |>.uset (c.resultIdx key) (unsafeCast result) lcProof }", "start": [43, 1], "end": [46, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.ReplaceM", "code": "abbrev ReplaceM := StateM Cache", "start": [48, 1], "end": [48, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.cache", "code": "@[inline]\nunsafe def cache (key : Expr) (result : Expr) : ReplaceM Expr := do\n  modify (\u00b7.store key result)\n  pure result", "start": [50, 1], "end": [53, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.replaceUnsafeM", "code": "@[specialize]\nunsafe def replaceUnsafeM (f? : Expr \u2192 Option Expr) (e : Expr) : ReplaceM Expr := do\n  let rec @[specialize] visit (e : Expr) := do\n    if (\u2190 get).hasResultFor e then\n      return (\u2190 get).getResultFor e\n    else match f? e with\n      | some eNew => cache e eNew\n      | none      => match e with\n        | Expr.forallE _ d b _   => cache e <| e.updateForallE! (\u2190 visit d) (\u2190 visit b)\n        | Expr.lam _ d b _       => cache e <| e.updateLambdaE! (\u2190 visit d) (\u2190 visit b)\n        | Expr.mdata _ b         => cache e <| e.updateMData! (\u2190 visit b)\n        | Expr.letE _ t v b _    => cache e <| e.updateLet! (\u2190 visit t) (\u2190 visit v) (\u2190 visit b)\n        | Expr.app f a           => cache e <| e.updateApp! (\u2190 visit f) (\u2190 visit a)\n        | Expr.proj _ _ b        => cache e <| e.updateProj! (\u2190 visit b)\n        | e                      => pure e\n  visit e", "start": [55, 1], "end": [70, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceImpl.replaceUnsafe", "code": "@[inline]\nunsafe def replaceUnsafe (f? : Expr \u2192 Option Expr) (e : Expr) : Expr :=\n  (replaceUnsafeM f? e).run' (Cache.new e)", "start": [72, 1], "end": [74, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.replaceNoCache", "code": "@[specialize]\ndef replaceNoCache (f? : Expr \u2192 Option Expr) (e : Expr) : Expr :=\n  match f? e with\n  | some eNew => eNew\n  | none      => match e with\n    | .forallE _ d b _ => let d := replaceNoCache f? d; let b := replaceNoCache f? b; e.updateForallE! d b\n    | .lam _ d b _     => let d := replaceNoCache f? d; let b := replaceNoCache f? b; e.updateLambdaE! d b\n    | .mdata _ b       => let b := replaceNoCache f? b; e.updateMData! b\n    | .letE _ t v b _  => let t := replaceNoCache f? t; let v := replaceNoCache f? v; let b := replaceNoCache f? b; e.updateLet! t v b\n    | .app f a         => let f := replaceNoCache f? f; let a := replaceNoCache f? a; e.updateApp! f a\n    | .proj _ _ b      => let b := replaceNoCache f? b; e.updateProj! b\n    | e                => e", "start": [81, 1], "end": [92, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.replace", "code": "@[implemented_by ReplaceImpl.replaceUnsafe]\npartial def replace (f? : Expr \u2192 Option Expr) (e : Expr) : Expr :=\n  e.replaceNoCache f?", "start": [94, 1], "end": [96, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/PersistentArray.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PersistentArrayNode", "code": "inductive PersistentArrayNode (\u03b1 : Type u) where\n  | node (cs : Array (PersistentArrayNode \u03b1)) : PersistentArrayNode \u03b1\n  | leaf (vs : Array \u03b1)                       : PersistentArrayNode \u03b1\n  deriving Inhabited", "start": [10, 1], "end": [13, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArrayNode.isNode", "code": "def isNode {\u03b1} : PersistentArrayNode \u03b1 \u2192 Bool\n  | node _ => true\n  | leaf _ => false", "start": [17, 1], "end": [19, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.initShift", "code": "abbrev PersistentArray.initShift : USize := 5", "start": [23, 1], "end": [23, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.branching", "code": "abbrev PersistentArray.branching : USize := USize.ofNat (2 ^ PersistentArray.initShift.toNat)", "start": [24, 1], "end": [24, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray", "code": "structure PersistentArray (\u03b1 : Type u) where\n  \n  root    : PersistentArrayNode \u03b1 := PersistentArrayNode.node (Array.mkEmpty PersistentArray.branching.toNat)\n  tail    : Array \u03b1               := Array.mkEmpty PersistentArray.branching.toNat\n  size    : Nat                   := 0\n  shift   : USize                 := PersistentArray.initShift\n  tailOff : Nat                   := 0\n  deriving Inhabited", "start": [26, 1], "end": [36, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PArray", "code": "abbrev PArray (\u03b1 : Type u) := PersistentArray \u03b1", "start": [38, 1], "end": [38, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.empty", "code": "def empty : PersistentArray \u03b1 := {}", "start": [46, 1], "end": [46, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.isEmpty", "code": "def isEmpty (a : PersistentArray \u03b1) : Bool := a.size == 0", "start": [48, 1], "end": [48, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.mkEmptyArray", "code": "def mkEmptyArray : Array \u03b1 := Array.mkEmpty branching.toNat", "start": [50, 1], "end": [50, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.mul2Shift", "code": "abbrev mul2Shift (i : USize) (shift : USize) : USize := i.shiftLeft shift", "start": [52, 1], "end": [52, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.div2Shift", "code": "abbrev div2Shift (i : USize) (shift : USize) : USize := i.shiftRight shift", "start": [53, 1], "end": [53, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.mod2Shift", "code": "abbrev mod2Shift (i : USize) (shift : USize) : USize := USize.land i ((USize.shiftLeft 1 shift) - 1)", "start": [54, 1], "end": [54, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.getAux", "code": "partial def getAux [Inhabited \u03b1] : PersistentArrayNode \u03b1 \u2192 USize \u2192 USize \u2192 \u03b1\n  | node cs, i, shift => getAux cs[(div2Shift i shift).toNat]! (mod2Shift i shift) (shift - initShift)\n  | leaf cs, i, _     => cs[i.toNat]!", "start": [56, 1], "end": [58, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.get!", "code": "def get! [Inhabited \u03b1] (t : PersistentArray \u03b1) (i : Nat) : \u03b1 :=\n  if i >= t.tailOff then\n    t.tail.get! (i - t.tailOff)\n  else\n    getAux t.root (USize.ofNat i) t.shift", "start": [60, 1], "end": [64, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.setAux", "code": "partial def setAux : PersistentArrayNode \u03b1 \u2192 USize \u2192 USize \u2192 \u03b1 \u2192 PersistentArrayNode \u03b1\n  | node cs, i, shift, a =>\n    let j     := div2Shift i shift\n    let i     := mod2Shift i shift\n    let shift := shift - initShift\n    node <| cs.modify j.toNat fun c => setAux c i shift a\n  | leaf cs, i, _,     a => leaf (cs.set! i.toNat a)", "start": [70, 1], "end": [76, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.set", "code": "def set (t : PersistentArray \u03b1) (i : Nat) (a : \u03b1) : PersistentArray \u03b1 :=\n  if i >= t.tailOff then\n    { t with tail := t.tail.set! (i - t.tailOff) a }\n  else\n    { t with root := setAux t.root (USize.ofNat i) t.shift a }", "start": [78, 1], "end": [82, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.modifyAux", "code": "@[specialize] partial def modifyAux [Inhabited \u03b1] (f : \u03b1 \u2192 \u03b1) : PersistentArrayNode \u03b1 \u2192 USize \u2192 USize \u2192 PersistentArrayNode \u03b1\n  | node cs, i, shift =>\n    let j     := div2Shift i shift\n    let i     := mod2Shift i shift\n    let shift := shift - initShift\n    node <| cs.modify j.toNat fun c => modifyAux f c i shift\n  | leaf cs, i, _     => leaf (cs.modify i.toNat f)", "start": [84, 1], "end": [90, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.modify", "code": "@[specialize] def modify [Inhabited \u03b1] (t : PersistentArray \u03b1) (i : Nat) (f : \u03b1 \u2192 \u03b1) : PersistentArray \u03b1 :=\n  if i >= t.tailOff then\n    { t with tail := t.tail.modify (i - t.tailOff) f }\n  else\n    { t with root := modifyAux f t.root (USize.ofNat i) t.shift }", "start": [92, 1], "end": [96, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.mkNewPath", "code": "partial def mkNewPath (shift : USize) (a : Array \u03b1) : PersistentArrayNode \u03b1 :=\n  if shift == 0 then\n    leaf a\n  else\n    node (mkEmptyArray.push (mkNewPath (shift - initShift) a))", "start": [98, 1], "end": [102, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.insertNewLeaf", "code": "partial def insertNewLeaf : PersistentArrayNode \u03b1 \u2192 USize \u2192 USize \u2192 Array \u03b1 \u2192 PersistentArrayNode \u03b1\n  | node cs,   i, shift, a =>\n    if i < branching then\n      node (cs.push (leaf a))\n    else\n      let j     := div2Shift i shift\n      let i     := mod2Shift i shift\n      let shift := shift - initShift\n      if j.toNat < cs.size then\n         node <| cs.modify j.toNat fun c => insertNewLeaf c i shift a\n      else\n         node <| cs.push <| mkNewPath shift a\n  | n, _, _, _ => n", "start": [104, 1], "end": [116, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.mkNewTail", "code": "def mkNewTail (t : PersistentArray \u03b1) : PersistentArray \u03b1 :=\n  if t.size <= (mul2Shift 1 (t.shift + initShift)).toNat then\n    { t with\n      tail    := mkEmptyArray, root := insertNewLeaf t.root (USize.ofNat (t.size - 1)) t.shift t.tail,\n      tailOff := t.size }\n  else\n    { t with\n      tail := #[],\n      root := let n := mkEmptyArray.push t.root;\n              node (n.push (mkNewPath t.shift t.tail)),\n      shift   := t.shift + initShift,\n      tailOff := t.size }", "start": [118, 1], "end": [129, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.tooBig", "code": "def tooBig : Nat := USize.size / 8", "start": [131, 1], "end": [131, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.push", "code": "def push (t : PersistentArray \u03b1) (a : \u03b1) : PersistentArray \u03b1 :=\n  let r := { t with tail := t.tail.push a, size := t.size + 1 }\n  if r.tail.size < branching.toNat || t.size >= tooBig then\n    r\n  else\n    mkNewTail r", "start": [133, 1], "end": [138, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.emptyArray", "code": "private def emptyArray {\u03b1 : Type u} : Array (PersistentArrayNode \u03b1) :=\n  Array.mkEmpty PersistentArray.branching.toNat", "start": [140, 1], "end": [141, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.popLeaf", "code": "partial def popLeaf : PersistentArrayNode \u03b1 \u2192 Option (Array \u03b1) \u00d7 Array (PersistentArrayNode \u03b1)\n  | node cs =>\n    if h : cs.size \u2260 0 then\n      let idx : Fin cs.size := \u27e8cs.size - 1, by exact Nat.pred_lt h\u27e9\n      let last := cs.get idx\n      let cs'  := cs.set idx default\n      match popLeaf last with\n      | (none,   _)       => (none, emptyArray)\n      | (some l, newLast) =>\n        if newLast.size == 0 then\n          let cs' := cs'.pop\n          if cs'.isEmpty then (some l, emptyArray) else (some l, cs')\n        else\n          (some l, cs'.set (Array.size_set cs idx _ \u25b8 idx) (node newLast))\n    else\n      (none, emptyArray)\n  | leaf vs   => (some vs, emptyArray)", "start": [143, 1], "end": [159, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.pop", "code": "def pop (t : PersistentArray \u03b1) : PersistentArray \u03b1 :=\n  if t.tail.size > 0 then\n    { t with tail := t.tail.pop, size := t.size - 1 }\n  else\n    match popLeaf t.root with\n    | (none, _) => t\n    | (some last, newRoots) =>\n      let last       := last.pop\n      let newSize    := t.size - 1\n      let newTailOff := newSize - last.size\n      if newRoots.size == 1 && (newRoots.get! 0).isNode then\n        { root    := newRoots.get! 0,\n          shift   := t.shift - initShift,\n          size    := newSize,\n          tail    := last,\n          tailOff := newTailOff }\n      else\n        { t with\n          root    := node newRoots,\n          size    := newSize,\n          tail    := last,\n          tailOff := newTailOff }", "start": [161, 1], "end": [182, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.foldlMAux", "code": "@[specialize] private partial def foldlMAux (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) : PersistentArrayNode \u03b1 \u2192 \u03b2 \u2192 m \u03b2\n  | node cs, b => cs.foldlM (fun b c => foldlMAux f c b) b\n  | leaf vs, b => vs.foldlM f b", "start": [188, 1], "end": [190, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.foldlFromMAux", "code": "@[specialize] private partial def foldlFromMAux (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) : PersistentArrayNode \u03b1 \u2192 USize \u2192 USize \u2192 \u03b2 \u2192 m \u03b2\n  | node cs, i, shift, b => do\n    let j    := (div2Shift i shift).toNat\n    let b \u2190 foldlFromMAux f (cs.get! j) (mod2Shift i shift) (shift - initShift) b\n    cs.foldlM (init := b) (start := j+1) fun b c => foldlMAux f c b\n  | leaf vs, i, _, b => vs.foldlM (init := b) (start := i.toNat) f", "start": [192, 1], "end": [197, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.foldlM", "code": "@[specialize] def foldlM (t : PersistentArray \u03b1) (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (init : \u03b2) (start : Nat := 0) : m \u03b2 := do\n  if start == 0 then\n    let b \u2190 foldlMAux f t.root init\n    t.tail.foldlM f b\n  else if start >= t.tailOff then\n    t.tail.foldlM (init := init) (start := start - t.tailOff) f\n  else do\n    let b \u2190 foldlFromMAux f t.root (USize.ofNat start) t.shift init\n    t.tail.foldlM f b", "start": [199, 1], "end": [207, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.foldrMAux", "code": "@[specialize] private partial def foldrMAux [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) : PersistentArrayNode \u03b1 \u2192 \u03b2 \u2192 m \u03b2\n  | node cs, b => cs.foldrM (fun c b => foldrMAux f c b) b\n  | leaf vs, b => vs.foldrM f b", "start": [209, 1], "end": [211, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.foldrM", "code": "@[specialize] def foldrM [Monad m] (t : PersistentArray \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (init : \u03b2) : m \u03b2 := do\n  foldrMAux f t.root (\u2190 t.tail.foldrM f init)", "start": [213, 1], "end": [214, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.forInAux", "code": "@[specialize]\npartial def forInAux {\u03b1 : Type u} {\u03b2 : Type v} {m : Type v \u2192 Type w} [Monad m] [inh : Inhabited \u03b2]\n    (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) (n : PersistentArrayNode \u03b1) (b : \u03b2) : m (ForInStep \u03b2) := do\n  let mut b := b\n  match n with\n  | leaf vs =>\n    for v in vs do\n      match (\u2190 f v b) with\n      | r@(ForInStep.done _) => return r\n      | ForInStep.yield bNew => b := bNew\n    return ForInStep.yield b\n  | node cs =>\n    for c in cs do\n      match (\u2190 forInAux f c b) with\n      | r@(ForInStep.done _) => return r\n      | ForInStep.yield bNew => b := bNew\n    return ForInStep.yield b", "start": [217, 1], "end": [233, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.forIn", "code": "@[specialize] protected def forIn (t : PersistentArray \u03b1) (init : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 m (ForInStep \u03b2)) : m \u03b2 := do\n  match (\u2190 forInAux (inh := \u27e8init\u27e9) f t.root init) with\n  | ForInStep.done b  => pure b\n  | ForInStep.yield b =>\n    let mut b := b\n    for v in t.tail do\n      match (\u2190 f v b) with\n      | ForInStep.done r => return r\n      | ForInStep.yield bNew => b := bNew\n    return b", "start": [235, 1], "end": [244, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.findSomeMAux", "code": "@[specialize] partial def findSomeMAux (f : \u03b1 \u2192 m (Option \u03b2)) : PersistentArrayNode \u03b1 \u2192 m (Option \u03b2)\n  | node cs => cs.findSomeM? (fun c => findSomeMAux f c)\n  | leaf vs => vs.findSomeM? f", "start": [249, 1], "end": [251, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.findSomeM?", "code": "@[specialize] def findSomeM? (t : PersistentArray \u03b1) (f : \u03b1 \u2192 m (Option \u03b2)) : m (Option \u03b2) := do\n  match (\u2190 findSomeMAux f t.root) with\n  | none   => t.tail.findSomeM? f\n  | some b => pure (some b)", "start": [253, 1], "end": [256, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.findSomeRevMAux", "code": "@[specialize] partial def findSomeRevMAux (f : \u03b1 \u2192 m (Option \u03b2)) : PersistentArrayNode \u03b1 \u2192 m (Option \u03b2)\n  | node cs => cs.findSomeRevM? (fun c => findSomeRevMAux f c)\n  | leaf vs => vs.findSomeRevM? f", "start": [258, 1], "end": [260, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.findSomeRevM?", "code": "@[specialize] def findSomeRevM? (t : PersistentArray \u03b1) (f : \u03b1 \u2192 m (Option \u03b2)) : m (Option \u03b2) := do\n  match (\u2190 t.tail.findSomeRevM? f) with\n  | none   => findSomeRevMAux f t.root\n  | some b => pure (some b)", "start": [262, 1], "end": [265, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.forMAux", "code": "@[specialize] partial def forMAux (f : \u03b1 \u2192 m PUnit) : PersistentArrayNode \u03b1 \u2192 m PUnit\n  | node cs => cs.forM (fun c => forMAux f c)\n  | leaf vs => vs.forM f", "start": [267, 1], "end": [269, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.forM", "code": "@[specialize] def forM (t : PersistentArray \u03b1) (f : \u03b1 \u2192 m PUnit) : m PUnit :=\n  forMAux f t.root *> t.tail.forM f", "start": [271, 1], "end": [272, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.foldl", "code": "@[inline] def foldl (t : PersistentArray \u03b1) (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (init : \u03b2) (start : Nat := 0) : \u03b2 :=\n  Id.run <| t.foldlM f init start", "start": [276, 1], "end": [277, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.foldr", "code": "@[inline] def foldr (t : PersistentArray \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) : \u03b2 :=\n  Id.run <| t.foldrM f init", "start": [279, 1], "end": [280, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.filter", "code": "@[inline] def filter (as : PersistentArray \u03b1) (p : \u03b1 \u2192 Bool) : PersistentArray \u03b1 :=\n  as.foldl (init := {}) fun asNew a => if p a then asNew.push a else asNew", "start": [282, 1], "end": [283, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.toArray", "code": "def toArray (t : PersistentArray \u03b1) : Array \u03b1 :=\n  t.foldl Array.push #[]", "start": [285, 1], "end": [286, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.append", "code": "def append (t\u2081 t\u2082 : PersistentArray \u03b1) : PersistentArray \u03b1 :=\n  if t\u2081.isEmpty then\n    t\u2082\n  else\n    t\u2082.foldl PersistentArray.push t\u2081", "start": [288, 1], "end": [292, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.findSome?", "code": "@[inline] def findSome? {\u03b2} (t : PersistentArray \u03b1) (f : \u03b1 \u2192 (Option \u03b2)) : Option \u03b2 :=\n  Id.run $ t.findSomeM? f", "start": [296, 1], "end": [297, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.findSomeRev?", "code": "@[inline] def findSomeRev? {\u03b2} (t : PersistentArray \u03b1) (f : \u03b1 \u2192 (Option \u03b2)) : Option \u03b2 :=\n  Id.run $ t.findSomeRevM? f", "start": [299, 1], "end": [300, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.toList", "code": "def toList (t : PersistentArray \u03b1) : List \u03b1 :=\n  (t.foldl (init := []) fun xs x => x :: xs).reverse", "start": [302, 1], "end": [303, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.anyMAux", "code": "@[specialize] partial def anyMAux (p : \u03b1 \u2192 m Bool) : PersistentArrayNode \u03b1 \u2192 m Bool\n  | node cs => cs.anyM fun c => anyMAux p c\n  | leaf vs => vs.anyM p", "start": [307, 1], "end": [309, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.anyM", "code": "@[specialize] def anyM (t : PersistentArray \u03b1) (p : \u03b1 \u2192 m Bool) : m Bool :=\n  anyMAux p t.root <||> t.tail.anyM p", "start": [311, 1], "end": [312, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.allM", "code": "@[inline] def allM (a : PersistentArray \u03b1) (p : \u03b1 \u2192 m Bool) : m Bool := do\n  let b \u2190 anyM a (fun v => do let b \u2190 p v; pure (not b))\n  pure (not b)", "start": [314, 1], "end": [316, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.any", "code": "@[inline] def any (a : PersistentArray \u03b1) (p : \u03b1 \u2192 Bool) : Bool :=\n  Id.run $ anyM a p", "start": [320, 1], "end": [321, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.all", "code": "@[inline] def all (a : PersistentArray \u03b1) (p : \u03b1 \u2192 Bool) : Bool :=\n  !any a fun v => !p v", "start": [323, 1], "end": [324, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.mapMAux", "code": "@[specialize] partial def mapMAux (f : \u03b1 \u2192 m \u03b2) : PersistentArrayNode \u03b1 \u2192 m (PersistentArrayNode \u03b2)\n  | node cs => node <$> cs.mapM (fun c => mapMAux f c)\n  | leaf vs => leaf <$> vs.mapM f", "start": [330, 1], "end": [332, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.mapM", "code": "@[specialize] def mapM (f : \u03b1 \u2192 m \u03b2) (t : PersistentArray \u03b1) : m (PersistentArray \u03b2) := do\n  let root \u2190 mapMAux f t.root\n  let tail \u2190 t.tail.mapM f\n  pure { t with tail := tail, root := root }", "start": [334, 1], "end": [337, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.map", "code": "@[inline] def map {\u03b2} (f : \u03b1 \u2192 \u03b2) (t : PersistentArray \u03b1) : PersistentArray \u03b2 :=\n  Id.run $ t.mapM f", "start": [341, 1], "end": [342, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.Stats", "code": "structure Stats where\n  numNodes : Nat\n  depth : Nat\n  tailSize : Nat", "start": [344, 1], "end": [347, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.collectStats", "code": "partial def collectStats : PersistentArrayNode \u03b1 \u2192 Stats \u2192 Nat \u2192 Stats\n  | node cs, s, d =>\n    cs.foldl (fun s c => collectStats c s (d+1))\n      { s with\n        numNodes := s.numNodes + 1,\n        depth    := Nat.max d s.depth }\n  | leaf _,  s, d => { s with numNodes := s.numNodes + 1, depth := Nat.max d s.depth }", "start": [349, 1], "end": [355, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.stats", "code": "def stats (r : PersistentArray \u03b1) : Stats :=\n  collectStats r.root { numNodes := 0, depth := 0, tailSize := r.tail.size } 0", "start": [357, 1], "end": [358, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentArray.Stats.toString", "code": "def Stats.toString (s : Stats) : String :=\n  s!\"\\{nodes := {s.numNodes}, depth := {s.depth}, tail size := {s.tailSize}}\"", "start": [360, 1], "end": [361, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.mkPersistentArray", "code": "def mkPersistentArray {\u03b1 : Type u} (n : Nat) (v : \u03b1) : PArray \u03b1 :=\n  n.fold (init := PersistentArray.empty) fun _ p => p.push v", "start": [367, 1], "end": [368, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.mkPArray", "code": "@[inline] def mkPArray {\u03b1 : Type u} (n : Nat) (v : \u03b1) : PArray \u03b1 :=\n  mkPersistentArray n v", "start": [370, 1], "end": [371, 24], "kind": "commanddeclaration"}, {"full_name": "List.toPArray'", "code": "def List.toPArray' {\u03b1 : Type u} (xs : List \u03b1) : PersistentArray \u03b1 :=\n  let rec loop : List \u03b1 \u2192 PersistentArray \u03b1 \u2192 PersistentArray \u03b1\n  | [],    t => t\n  | x::xs, t => loop xs (t.push x)\n  loop xs {}", "start": [377, 1], "end": [381, 13], "kind": "commanddeclaration"}, {"full_name": "Array.toPArray'", "code": "def Array.toPArray' {\u03b1 : Type u} (xs : Array \u03b1) : PersistentArray \u03b1 :=\n  xs.foldl (init := .empty) fun p x => p.push x", "start": [383, 1], "end": [384, 48], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Json/FromToJson.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/Printer.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.FromJson", "code": "class FromJson (\u03b1 : Type u) where\n  fromJson? : Json \u2192 Except String \u03b1", "start": [14, 1], "end": [15, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.ToJson", "code": "class ToJson (\u03b1 : Type u) where\n  toJson : \u03b1 \u2192 Json", "start": [19, 1], "end": [20, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.bignumFromJson?", "code": "def bignumFromJson? (j : Json) : Except String Nat := do\n  let s \u2190 j.getStr?\n  let some v := Syntax.decodeNatLitVal? s | throw s!\"expected a string-encoded number, got '{j}'\"\n  return v", "start": [91, 1], "end": [97, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.bignumToJson", "code": "def bignumToJson (n : Nat) : Json :=\n  toString n", "start": [99, 1], "end": [100, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.toStructured?", "code": "def toStructured? [ToJson \u03b1] (v : \u03b1) : Except String Structured :=\n  fromJson? (toJson v)", "start": [155, 1], "end": [156, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.getObjValAs?", "code": "def getObjValAs? (j : Json) (\u03b1 : Type u) [FromJson \u03b1] (k : String) : Except String \u03b1 :=\n  fromJson? <| j.getObjValD k", "start": [158, 1], "end": [159, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.setObjValAs!", "code": "def setObjValAs! (j : Json) {\u03b1 : Type u} [ToJson \u03b1] (k : String) (v : \u03b1) : Json :=\n  j.setObjVal! k <| toJson v", "start": [161, 1], "end": [162, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.opt", "code": "def opt [ToJson \u03b1] (k : String) : Option \u03b1 \u2192 List (String \u00d7 Json)\n  | none   => []\n  | some o => [\u27e8k, toJson o\u27e9]", "start": [164, 1], "end": [166, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.parseTagged", "code": "def parseTagged\n    (json : Json)\n    (tag : String)\n    (nFields : Nat)\n    (fieldNames? : Option (Array Name)) : Except String (Array Json) :=\n  if nFields == 0 then\n    match getStr? json with\n    | Except.ok s => if s == tag then Except.ok #[] else throw s!\"incorrect tag: {s} \u225f {tag}\"\n    | Except.error err => Except.error err\n  else\n    match getObjVal? json tag with\n    | Except.ok payload =>\n      match fieldNames? with\n      | some fieldNames =>\n        do\n          let mut fields := #[]\n          for fieldName in fieldNames do\n            fields := fields.push (\u2190getObjVal? payload fieldName.getString!)\n          Except.ok fields\n      | none =>\n        if nFields == 1 then\n          Except.ok #[payload]\n        else\n          match getArr? payload with\n          | Except.ok fields =>\n            if fields.size == nFields then\n              Except.ok fields\n            else\n              Except.error s!\"incorrect number of fields: {fields.size} \u225f {nFields}\"\n          | Except.error err => Except.error err\n    | Except.error err => Except.error err", "start": [168, 1], "end": [199, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Json/Parser.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Parsec.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Json.Parser.hexChar", "code": "@[inline]\ndef hexChar : Parsec Nat := do\n  let c \u2190 anyChar\n  if '0' \u2264 c \u2227 c \u2264 '9' then\n    pure $ c.val.toNat - '0'.val.toNat\n  else if 'a' \u2264 c \u2227 c \u2264 'f' then\n    pure $ c.val.toNat - 'a'.val.toNat + 10\n  else if 'A' \u2264 c \u2227 c \u2264 'F' then\n    pure $ c.val.toNat - 'A'.val.toNat + 10\n  else\n    fail \"invalid hex character\"", "start": [14, 1], "end": [24, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.escapedChar", "code": "def escapedChar : Parsec Char := do\n  let c \u2190 anyChar\n  match c with\n  | '\\\\' => return '\\\\'\n  | '\"'  => return '\"'\n  | '/'  => return '/'\n  | 'b'  => return '\\x08'\n  | 'f'  => return '\\x0c'\n  | 'n'  => return '\\n'\n  | 'r'  => return '\\x0d'\n  | 't'  => return '\\t'\n  | 'u'  =>\n    let u1 \u2190 hexChar; let u2 \u2190 hexChar; let u3 \u2190 hexChar; let u4 \u2190 hexChar\n    return Char.ofNat $ 4096*u1 + 256*u2 + 16*u3 + u4\n  | _ => fail \"illegal \\\\u escape\"", "start": [26, 1], "end": [40, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.strCore", "code": "partial def strCore (acc : String) : Parsec String := do\n  let c \u2190 peek!\n  if c = '\"' then skip\n    return acc\n  else\n    let c \u2190 anyChar\n    if c = '\\\\' then\n      strCore (acc.push (\u2190 escapedChar))\n    else if 0x0020 \u2264 c.val \u2227 c.val \u2264 0x10ffff then\n      strCore (acc.push c)\n    else\n      fail \"unexpected character in string\"", "start": [42, 1], "end": [57, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.str", "code": "def str : Parsec String := strCore \"\"", "start": [59, 1], "end": [59, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.natCore", "code": "partial def natCore (acc digits : Nat) : Parsec (Nat \u00d7 Nat) := do\n  let some c \u2190 peek? | return (acc, digits)\n  if '0' \u2264 c \u2227 c \u2264 '9' then\n    skip\n    let acc' := 10*acc + (c.val.toNat - '0'.val.toNat)\n    natCore acc' (digits+1)\n  else\n    return (acc, digits)", "start": [61, 1], "end": [68, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.lookahead", "code": "@[inline]\ndef lookahead (p : Char \u2192 Prop) (desc : String) [DecidablePred p] : Parsec Unit := do\n  let c \u2190 peek!\n  if p c then\n    return ()\n  else\n    fail <| \"expected \" ++ desc", "start": [70, 1], "end": [76, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.natNonZero", "code": "@[inline]\ndef natNonZero : Parsec Nat := do\n  lookahead (fun c => '1' \u2264 c \u2227 c \u2264 '9') \"1-9\"\n  let (n, _) \u2190 natCore 0 0\n  return n", "start": [78, 1], "end": [82, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.natNumDigits", "code": "@[inline]\ndef natNumDigits : Parsec (Nat \u00d7 Nat) := do\n  lookahead (fun c => '0' \u2264 c \u2227 c \u2264 '9') \"digit\"\n  natCore 0 0", "start": [84, 1], "end": [87, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.natMaybeZero", "code": "@[inline]\ndef natMaybeZero : Parsec Nat := do\n  let (n, _) \u2190 natNumDigits\n  return n", "start": [89, 1], "end": [92, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.num", "code": "def num : Parsec JsonNumber := do\n  let c \u2190 peek!\n  let sign \u2190 if c = '-' then\n    skip\n    pure (-1 : Int)\n  else\n    pure 1\n  let c \u2190 peek!\n  let res \u2190 if c = '0' then\n    skip\n    pure 0\n  else\n    natNonZero\n  let c? \u2190 peek?\n  let res : JsonNumber \u2190 if c? = some '.' then\n    skip\n    let (n, d) \u2190 natNumDigits\n    if d > USize.size then fail \"too many decimals\"\n    let mantissa' := sign * (res * (10^d : Nat) + n)\n    let exponent' := d\n    pure <| JsonNumber.mk mantissa' exponent'\n  else\n    pure <| JsonNumber.fromInt (sign * res)\n  let c? \u2190 peek?\n  if c? = some 'e' \u2228 c? = some 'E' then\n    skip\n    let c \u2190 peek!\n    if c = '-' then\n      skip\n      let n \u2190 natMaybeZero\n      return res.shiftr n\n    else\n      if c = '+' then skip\n      let n \u2190 natMaybeZero\n      if n > USize.size then fail \"exp too large\"\n      return res.shiftl n\n  else\n    return res", "start": [94, 1], "end": [131, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.arrayCore", "code": "partial def arrayCore (anyCore : Parsec Json) (acc : Array Json) : Parsec (Array Json) := do\n  let hd \u2190 anyCore\n  let acc' := acc.push hd\n  let c \u2190 anyChar\n  if c = ']' then\n    ws\n    return acc'\n  else if c = ',' then\n    ws\n    arrayCore anyCore acc'\n  else\n    fail \"unexpected character in array\"", "start": [133, 1], "end": [144, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.objectCore", "code": "partial def objectCore (anyCore : Parsec Json) : Parsec (RBNode String (fun _ => Json)) := do\n  lookahead (fun c => c = '\"') \"\\\"\"; skip; let k \u2190 strCore \"\"; ws\n  lookahead (fun c => c = ':') \":\"; skip; ws\n  let v \u2190 anyCore\n  let c \u2190 anyChar\n  if c = '}' then\n    ws\n    return RBNode.singleton k v\n  else if c = ',' then\n    ws\n    let kvs \u2190 objectCore anyCore\n    return kvs.insert compare k v\n  else\n    fail \"unexpected character in object\"", "start": [146, 1], "end": [160, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.anyCore", "code": "partial def anyCore : Parsec Json := do\n  let c \u2190 peek!\n  if c = '[' then\n    skip; ws\n    let c \u2190 peek!\n    if c = ']' then\n      skip; ws\n      return Json.arr (Array.mkEmpty 0)\n    else\n      let a \u2190 arrayCore anyCore (Array.mkEmpty 4)\n      return Json.arr a\n  else if c = '{' then\n    skip; ws\n    let c \u2190 peek!\n    if c = '}' then\n      skip; ws\n      return Json.obj (RBNode.leaf)\n    else\n      let kvs \u2190 objectCore anyCore\n      return Json.obj kvs\n  else if c = '\\\"' then\n    skip\n    let s \u2190 strCore \"\"\n    ws\n    return Json.str s\n  else if c = 'f' then\n    skipString \"false\"; ws\n    return Json.bool false\n  else if c = 't' then\n    skipString \"true\"; ws\n    return Json.bool true\n  else if c = 'n' then\n    skipString \"null\"; ws\n    return Json.null\n  else if c = '-' \u2228 ('0' \u2264 c \u2227 c \u2264 '9') then\n    let n \u2190 num\n    ws\n    return Json.num n\n  else\n    fail \"unexpected input\"", "start": [162, 1], "end": [201, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Json.Parser.any", "code": "def any : Parsec Json := do\n  ws\n  let res \u2190 anyCore\n  eof\n  return res", "start": [204, 1], "end": [208, 13], "kind": "commanddeclaration"}, {"full_name": "Json.parse", "code": "def parse (s : String) : Except String Lean.Json :=\n  match Json.Parser.any s.mkIterator with\n  | Parsec.ParseResult.success _ res => Except.ok res\n  | Parsec.ParseResult.error it err  => Except.error s!\"offset {repr it.i.byteIdx}: {err}\"", "start": [214, 1], "end": [217, 91], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/FindExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Util/PtrSet.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.FindImpl.FindM", "code": "unsafe abbrev FindM := StateT (PtrSet Expr) Id", "start": [13, 1], "end": [13, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FindImpl.checkVisited", "code": "@[inline] unsafe def checkVisited (e : Expr) : OptionT FindM Unit := do\n  if (\u2190 get).contains e then\n    failure\n  modify fun s => s.insert e", "start": [15, 1], "end": [18, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FindImpl.findM?", "code": "unsafe def findM? (p : Expr \u2192 Bool) (e : Expr) : OptionT FindM Expr :=\n  let rec visit (e : Expr) := do\n    checkVisited e\n    if p e then\n      pure e\n    else match e with\n      | .forallE _ d b _ => visit d <|> visit b\n      | .lam _ d b _     => visit d <|> visit b\n      | .mdata _ b       => visit b\n      | .letE _ t v b _  => visit t <|> visit v <|> visit b\n      | .app f a         => visit f <|> visit a\n      | .proj _ _ b      => visit b\n      | _                => failure\n  visit e", "start": [20, 1], "end": [33, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FindImpl.findUnsafe?", "code": "unsafe def findUnsafe? (p : Expr \u2192 Bool) (e : Expr) : Option Expr :=\n  Id.run <| findM? p e |>.run' mkPtrSet", "start": [35, 1], "end": [36, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.find?", "code": "@[implemented_by FindImpl.findUnsafe?]\ndef find? (p : Expr \u2192 Bool) (e : Expr) : Option Expr :=\n  \n  if p e then\n    some e\n  else match e with\n    | .forallE _ d b _ => find? p d <|> find? p b\n    | .lam _ d b _     => find? p d <|> find? p b\n    | .mdata _ b       => find? p b\n    | .letE _ t v b _  => find? p t <|> find? p v <|> find? p b\n    | .app f a         => find? p f <|> find? p a\n    | .proj _ _ b      => find? p b\n    | _                => none", "start": [40, 1], "end": [52, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.occurs", "code": "def occurs (e : Expr) (t : Expr) : Bool :=\n  (t.find? fun s => s == e).isSome", "start": [54, 1], "end": [56, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FindStep", "code": "inductive FindStep where\n   | found\n   | visit\n   | done", "start": [58, 1], "end": [64, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FindExtImpl.findM?", "code": "unsafe def findM? (p : Expr \u2192 FindStep) (e : Expr) : OptionT FindImpl.FindM Expr :=\n  visit e\nwhere\n  visitApp (e : Expr) :=\n    match e with\n    | .app f a .. => visitApp f <|> visit a\n    | e => visit e\n\n  visit (e : Expr) := do\n    FindImpl.checkVisited e\n    match p e with\n      | .done  => failure\n      | .found => pure e\n      | .visit =>\n        match e with\n        | .forallE _ d b _ => visit d <|> visit b\n        | .lam _ d b _     => visit d <|> visit b\n        | .mdata _ b       => visit b\n        | .letE _ t v b _  => visit t <|> visit v <|> visit b\n        | .app ..          => visitApp e\n        | .proj _ _ b      => visit b\n        | _                => failure", "start": [68, 1], "end": [89, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FindExtImpl.findUnsafe?", "code": "unsafe def findUnsafe? (p : Expr \u2192 FindStep) (e : Expr) : Option Expr :=\n  Id.run <| findM? p e |>.run' mkPtrSet", "start": [91, 1], "end": [92, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.findExt?", "code": "@[implemented_by FindExtImpl.findUnsafe?]\nopaque findExt? (p : Expr \u2192 FindStep) (e : Expr) : Option Expr", "start": [96, 1], "end": [100, 63], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/Path.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Name.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.realPathNormalized", "code": "def realPathNormalized (p : FilePath) : IO FilePath :=\n  return (\u2190 IO.FS.realPath p).normalize", "start": [16, 1], "end": [17, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.modToFilePath", "code": "def modToFilePath (base : FilePath) (mod : Name) (ext : String) : FilePath :=\n  go mod |>.withExtension ext\nwhere\n  go : Name \u2192 FilePath\n  | Name.str p h => go p / h\n  | Name.anonymous => base\n  | Name.num _ _ => panic! \"ill-formed import\"", "start": [19, 1], "end": [25, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.SearchPath", "code": "abbrev SearchPath := System.SearchPath", "start": [27, 1], "end": [28, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.SearchPath.findWithExt", "code": "def findWithExt (sp : SearchPath) (ext : String) (mod : Name) : IO (Option FilePath) := do\n  let pkg := mod.getRoot.toString\n  let root? \u2190 sp.findM? fun p =>\n    (p / pkg).isDir <||> ((p / pkg).withExtension ext).pathExists\n  return root?.map (modToFilePath \u00b7 mod ext)", "start": [32, 1], "end": [39, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.SearchPath.findModuleWithExt", "code": "def findModuleWithExt (sp : SearchPath) (ext : String) (mod : Name) : IO (Option FilePath) := do\n  if let some path \u2190 findWithExt sp ext mod then\n    if \u2190 path.pathExists then\n      return some path\n  return none", "start": [41, 1], "end": [46, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.SearchPath.findAllWithExt", "code": "def findAllWithExt (sp : SearchPath) (ext : String) : IO (Array FilePath) := do\n  let mut paths := #[]\n  for p in sp do\n    if (\u2190 p.isDir) then\n      paths := paths ++ (\u2190 p.walkDir).filter (\u00b7.extension == some ext)\n  return paths", "start": [48, 1], "end": [53, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.getBuildDir", "code": "@[export lean_get_prefix]\ndef getBuildDir : IO FilePath := do\n  return (\u2190 IO.appDir).parent |>.get!", "start": [59, 1], "end": [61, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.getLibDir", "code": "@[export lean_get_libdir]\ndef getLibDir (leanSysroot : FilePath) : IO FilePath := do\n  let mut buildDir := leanSysroot\n  if Internal.isStage0 () then\n    buildDir := buildDir / \"..\" / \"stage1\"\n  return buildDir / \"lib\" / \"lean\"", "start": [63, 1], "end": [69, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.getBuiltinSearchPath", "code": "def getBuiltinSearchPath (leanSysroot : FilePath) : IO SearchPath :=\n  return [\u2190 getLibDir leanSysroot]", "start": [71, 1], "end": [72, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.addSearchPathFromEnv", "code": "def addSearchPathFromEnv (sp : SearchPath) : IO SearchPath := do\n  let val \u2190 IO.getEnv \"LEAN_PATH\"\n  match val with\n  | none     => pure sp\n  | some val => pure <| SearchPath.parse val ++ sp", "start": [74, 1], "end": [78, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.initSearchPath", "code": "def initSearchPath (leanSysroot : FilePath) (sp : SearchPath := \u2205) : IO Unit := do\n  let sp := sp ++ (\u2190 addSearchPathFromEnv (\u2190 getBuiltinSearchPath leanSysroot))\n  searchPathRef.set sp", "start": [80, 1], "end": [86, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.initSearchPathInternal", "code": "@[export lean_init_search_path]\nprivate def initSearchPathInternal : IO Unit := do\n  initSearchPath (\u2190 getBuildDir)", "start": [88, 1], "end": [90, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.findOLean", "code": "partial def findOLean (mod : Name) : IO FilePath := do\n  let sp \u2190 searchPathRef.get\n  if let some fname \u2190 sp.findWithExt \"olean\" mod then\n    return fname\n  else\n    let pkg := FilePath.mk mod.getRoot.toString\n    let mut msg := s!\"unknown package '{pkg}'\"\n    let rec maybeThisOne dir := do\n      if \u2190 (dir / pkg).isDir then\n        return some s!\"\\nYou might need to open '{dir}' as a workspace in your editor\"\n      if let some dir := dir.parent then\n        maybeThisOne dir\n      else\n       return none\n    if let some msg' \u2190 maybeThisOne (\u2190 IO.currentDir) then\n      msg := msg ++ msg'\n    throw <| IO.userError msg", "start": [92, 1], "end": [108, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.moduleNameOfFileName", "code": "@[export lean_module_name_of_file]\ndef moduleNameOfFileName (fname : FilePath) (rootDir : Option FilePath) : IO Name := do\n  let fname \u2190 IO.FS.realPath fname\n  let rootDir \u2190 match rootDir with\n    | some rootDir => pure rootDir\n    | none         => IO.currentDir\n  let mut rootDir \u2190 realPathNormalized rootDir\n  if !rootDir.toString.endsWith System.FilePath.pathSeparator.toString then\n    rootDir := \u27e8rootDir.toString ++ System.FilePath.pathSeparator.toString\u27e9\n  if !rootDir.toString.isPrefixOf fname.normalize.toString then\n    throw $ IO.userError s!\"input file '{fname}' must be contained in root directory ({rootDir})\"\n  let fnameSuffix := fname.toString.drop rootDir.toString.length\n  let modNameStr := FilePath.mk fnameSuffix |>.withExtension \"\"\n  let modName    := modNameStr.components.foldl Name.mkStr Name.anonymous\n  pure modName", "start": [110, 1], "end": [126, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.searchModuleNameOfFileName", "code": "def searchModuleNameOfFileName (fname : FilePath) (rootDirs : SearchPath) : IO (Option Name) := do\n  for rootDir in rootDirs do\n    try\n      return some <| \u2190 moduleNameOfFileName fname <| some rootDir\n    catch\n      | _ => pure ()\n  return none", "start": [128, 1], "end": [135, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.findSysroot", "code": "def findSysroot (lean := \"lean\") : IO FilePath := do\n  if let some root \u2190 IO.getEnv \"LEAN_SYSROOT\" then\n    return root\n  let out \u2190 IO.Process.run {\n    cmd := lean\n    args := #[\"  }\n  return out.trim", "start": [137, 1], "end": [153, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Declaration.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ReducibilityHints", "code": "inductive ReducibilityHints where\n  | opaque  : ReducibilityHints\n  | abbrev  : ReducibilityHints\n  | regular : UInt32 \u2192 ReducibilityHints\n  deriving Inhabited", "start": [9, 1], "end": [37, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.mkReducibilityHintsRegularEx", "code": "@[export lean_mk_reducibility_hints_regular]\ndef mkReducibilityHintsRegularEx (h : UInt32) : ReducibilityHints :=\n  ReducibilityHints.regular h", "start": [39, 1], "end": [41, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.ReducibilityHints.getHeightEx", "code": "@[export lean_reducibility_hints_get_height]\ndef ReducibilityHints.getHeightEx (h : ReducibilityHints) : UInt32 :=\n  match h with\n  | ReducibilityHints.regular h => h\n  | _ => 0", "start": [43, 1], "end": [47, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.ReducibilityHints.lt", "code": "def lt : ReducibilityHints \u2192 ReducibilityHints \u2192 Bool\n  | .abbrev,     .abbrev     => false\n  | .abbrev,     _           => true\n  | .regular d\u2081, .regular d\u2082 => d\u2081 < d\u2082\n  | .regular _,  .opaque     => true\n  | _,           _           => false", "start": [51, 1], "end": [56, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.ReducibilityHints.isAbbrev", "code": "def isAbbrev : ReducibilityHints \u2192 Bool\n  | .abbrev => true\n  | _       => false", "start": [58, 1], "end": [60, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ReducibilityHints.isRegular", "code": "def isRegular : ReducibilityHints \u2192 Bool\n  | regular .. => true\n  | _          => false", "start": [62, 1], "end": [64, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantVal", "code": "structure ConstantVal where\n  name : Name\n  levelParams : List Name\n  type : Expr\n  deriving Inhabited, BEq", "start": [68, 1], "end": [73, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.AxiomVal", "code": "structure AxiomVal extends ConstantVal where\n  isUnsafe : Bool\n  deriving Inhabited, BEq", "start": [75, 1], "end": [77, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAxiomValEx", "code": "@[export lean_mk_axiom_val]\ndef mkAxiomValEx (name : Name) (levelParams : List Name) (type : Expr) (isUnsafe : Bool) : AxiomVal := {\n  name := name,\n  levelParams := levelParams,\n  type := type,\n  isUnsafe := isUnsafe\n}", "start": [79, 1], "end": [85, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.AxiomVal.isUnsafeEx", "code": "@[export lean_axiom_val_is_unsafe] def AxiomVal.isUnsafeEx (v : AxiomVal) : Bool :=\n  v.isUnsafe", "start": [87, 1], "end": [88, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.DefinitionSafety", "code": "inductive DefinitionSafety where\n  | \u00abunsafe\u00bb | safe | \u00abpartial\u00bb\n  deriving Inhabited, BEq, Repr", "start": [90, 1], "end": [92, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.DefinitionVal", "code": "structure DefinitionVal extends ConstantVal where\n  value  : Expr\n  hints  : ReducibilityHints\n  safety : DefinitionSafety\n  \n  all : List Name := [name]\n  deriving Inhabited", "start": [94, 1], "end": [106, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.mkDefinitionValEx", "code": "@[export lean_mk_definition_val]\ndef mkDefinitionValEx (name : Name) (levelParams : List Name) (type : Expr) (value : Expr) (hints : ReducibilityHints) (safety : DefinitionSafety) (all : List Name) : DefinitionVal := {\n  name, levelParams, type, hints, safety, value, all\n}", "start": [108, 1], "end": [111, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.DefinitionVal.getSafetyEx", "code": "@[export lean_definition_val_get_safety] def DefinitionVal.getSafetyEx (v : DefinitionVal) : DefinitionSafety :=\n  v.safety", "start": [113, 1], "end": [114, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.TheoremVal", "code": "structure TheoremVal extends ConstantVal where\n  value : Expr\n  \n  all : List Name := [name]\n  deriving Inhabited, BEq", "start": [116, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.OpaqueVal", "code": "structure OpaqueVal extends ConstantVal where\n  value : Expr\n  isUnsafe : Bool\n  \n  all : List Name := [name]\n  deriving Inhabited, BEq", "start": [124, 1], "end": [132, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.mkOpaqueValEx", "code": "@[export lean_mk_opaque_val]\ndef mkOpaqueValEx (name : Name) (levelParams : List Name) (type : Expr) (value : Expr) (isUnsafe : Bool) (all : List Name) : OpaqueVal := {\n  name, levelParams, type, value, isUnsafe, all\n}", "start": [134, 1], "end": [137, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.OpaqueVal.isUnsafeEx", "code": "@[export lean_opaque_val_is_unsafe] def OpaqueVal.isUnsafeEx (v : OpaqueVal) : Bool :=\n  v.isUnsafe", "start": [139, 1], "end": [140, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Constructor", "code": "structure Constructor where\n  name : Name\n  type : Expr\n  deriving Inhabited", "start": [142, 1], "end": [145, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.InductiveType", "code": "structure InductiveType where\n  name : Name\n  type : Expr\n  ctors : List Constructor\n  deriving Inhabited", "start": [147, 1], "end": [151, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Declaration", "code": "inductive Declaration where\n  | axiomDecl       (val : AxiomVal)\n  | defnDecl        (val : DefinitionVal)\n  | thmDecl         (val : TheoremVal)\n  | opaqueDecl      (val : OpaqueVal)\n  | quotDecl\n  | mutualDefnDecl  (defns : List DefinitionVal) | inductDecl      (lparams : List Name) (nparams : Nat) (types : List InductiveType) (isUnsafe : Bool)\n  deriving Inhabited", "start": [153, 1], "end": [162, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.mkInductiveDeclEs", "code": "@[export lean_mk_inductive_decl]\ndef mkInductiveDeclEs (lparams : List Name) (nparams : Nat) (types : List InductiveType) (isUnsafe : Bool) : Declaration :=\n  Declaration.inductDecl lparams nparams types isUnsafe", "start": [164, 1], "end": [166, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Declaration.isUnsafeInductiveDeclEx", "code": "@[export lean_is_unsafe_inductive_decl]\ndef Declaration.isUnsafeInductiveDeclEx : Declaration \u2192 Bool\n  | Declaration.inductDecl _ _ _ isUnsafe => isUnsafe\n  | _ => false", "start": [168, 1], "end": [171, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Declaration.foldExprM", "code": "@[specialize] def Declaration.foldExprM {\u03b1} {m : Type \u2192 Type} [Monad m] (d : Declaration) (f : \u03b1 \u2192 Expr \u2192 m \u03b1) (a : \u03b1) : m \u03b1 :=\n  match d with\n  | Declaration.quotDecl                                        => pure a\n  | Declaration.axiomDecl { type := type, .. }                  => f a type\n  | Declaration.defnDecl { type := type, value := value, .. }   => do let a \u2190 f a type; f a value\n  | Declaration.opaqueDecl { type := type, value := value, .. } => do let a \u2190 f a type; f a value\n  | Declaration.thmDecl { type := type, value := value, .. }    => do let a \u2190 f a type; f a value\n  | Declaration.mutualDefnDecl vals                             => vals.foldlM (fun a v => do let a \u2190 f a v.type; f a v.value) a\n  | Declaration.inductDecl _ _ inductTypes _                    =>\n    inductTypes.foldlM\n      (fun a inductType => do\n        let a \u2190 f a inductType.type\n        inductType.ctors.foldlM (fun a ctor => f a ctor.type) a)\n      a", "start": [173, 1], "end": [186, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Declaration.forExprM", "code": "@[inline] def Declaration.forExprM {m : Type \u2192 Type} [Monad m] (d : Declaration) (f : Expr \u2192 m Unit) : m Unit :=\n  d.foldExprM (fun _ a => f a) ()", "start": [188, 1], "end": [189, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.InductiveVal", "code": "structure InductiveVal extends ConstantVal where\n  \n  numParams : Nat\n  \n  numIndices : Nat\n  \n  all : List Name\n  \n  ctors : List Name\n  \n  isRec : Bool\n  \n  isUnsafe : Bool\n  \n  isReflexive : Bool\n  \n  isNested : Bool\n  deriving Inhabited", "start": [191, 1], "end": [240, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.mkInductiveValEx", "code": "@[export lean_mk_inductive_val]\ndef mkInductiveValEx (name : Name) (levelParams : List Name) (type : Expr) (numParams numIndices : Nat)\n    (all ctors : List Name) (isRec isUnsafe isReflexive isNested : Bool) : InductiveVal := {\n  name := name\n  levelParams := levelParams\n  type := type\n  numParams := numParams\n  numIndices := numIndices\n  all := all\n  ctors := ctors\n  isRec := isRec\n  isUnsafe := isUnsafe\n  isReflexive := isReflexive\n  isNested := isNested\n}", "start": [242, 1], "end": [256, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.InductiveVal.isRecEx", "code": "@[export lean_inductive_val_is_rec] def InductiveVal.isRecEx (v : InductiveVal) : Bool := v.isRec", "start": [258, 1], "end": [258, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.InductiveVal.isUnsafeEx", "code": "@[export lean_inductive_val_is_unsafe] def InductiveVal.isUnsafeEx (v : InductiveVal) : Bool := v.isUnsafe", "start": [259, 1], "end": [259, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.InductiveVal.isReflexiveEx", "code": "@[export lean_inductive_val_is_reflexive] def InductiveVal.isReflexiveEx (v : InductiveVal) : Bool := v.isReflexive", "start": [260, 1], "end": [260, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.InductiveVal.isNestedEx", "code": "@[export lean_inductive_val_is_nested] def InductiveVal.isNestedEx (v : InductiveVal) : Bool := v.isNested", "start": [261, 1], "end": [261, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.InductiveVal.numCtors", "code": "def InductiveVal.numCtors (v : InductiveVal) : Nat := v.ctors.length", "start": [263, 1], "end": [263, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstructorVal", "code": "structure ConstructorVal extends ConstantVal where\n  \n  induct  : Name\n  \n  cidx    : Nat\n  \n  numParams : Nat\n  \n  numFields : Nat\n  isUnsafe : Bool\n  deriving Inhabited, BEq", "start": [265, 1], "end": [275, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.mkConstructorValEx", "code": "@[export lean_mk_constructor_val]\ndef mkConstructorValEx (name : Name) (levelParams : List Name) (type : Expr) (induct : Name) (cidx numParams numFields : Nat) (isUnsafe : Bool) : ConstructorVal := {\n  name := name,\n  levelParams := levelParams,\n  type := type,\n  induct := induct,\n  cidx := cidx,\n  numParams := numParams,\n  numFields := numFields,\n  isUnsafe := isUnsafe\n}", "start": [277, 1], "end": [287, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstructorVal.isUnsafeEx", "code": "@[export lean_constructor_val_is_unsafe] def ConstructorVal.isUnsafeEx (v : ConstructorVal) : Bool := v.isUnsafe", "start": [289, 1], "end": [289, 113], "kind": "commanddeclaration"}, {"full_name": "Lean.RecursorRule", "code": "structure RecursorRule where\n  \n  ctor : Name\n  \n  nfields : Nat\n  \n  rhs : Expr\n  deriving Inhabited, BEq", "start": [291, 1], "end": [299, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.RecursorVal", "code": "structure RecursorVal extends ConstantVal where\n  \n  all : List Name\n  \n  numParams : Nat\n  \n  numIndices : Nat\n  \n  numMotives : Nat\n  \n  numMinors : Nat\n  \n  rules : List RecursorRule\n  \n  k : Bool\n  isUnsafe : Bool\n  deriving Inhabited, BEq", "start": [301, 1], "end": [325, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRecursorValEx", "code": "@[export lean_mk_recursor_val]\ndef mkRecursorValEx (name : Name) (levelParams : List Name) (type : Expr) (all : List Name) (numParams numIndices numMotives numMinors : Nat)\n    (rules : List RecursorRule) (k isUnsafe : Bool) : RecursorVal := {\n  name := name, levelParams := levelParams, type := type, all := all, numParams := numParams, numIndices := numIndices,\n  numMotives := numMotives, numMinors := numMinors, rules := rules, k := k, isUnsafe := isUnsafe\n}", "start": [327, 1], "end": [332, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.RecursorVal.kEx", "code": "@[export lean_recursor_k] def RecursorVal.kEx (v : RecursorVal) : Bool := v.k", "start": [334, 1], "end": [334, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.RecursorVal.isUnsafeEx", "code": "@[export lean_recursor_is_unsafe] def RecursorVal.isUnsafeEx (v : RecursorVal) : Bool := v.isUnsafe", "start": [335, 1], "end": [335, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.RecursorVal.getMajorIdx", "code": "def RecursorVal.getMajorIdx (v : RecursorVal) : Nat :=\n  v.numParams + v.numMotives + v.numMinors + v.numIndices", "start": [337, 1], "end": [338, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.RecursorVal.getFirstIndexIdx", "code": "def RecursorVal.getFirstIndexIdx (v : RecursorVal) : Nat :=\n  v.numParams + v.numMotives + v.numMinors", "start": [340, 1], "end": [341, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.RecursorVal.getFirstMinorIdx", "code": "def RecursorVal.getFirstMinorIdx (v : RecursorVal) : Nat :=\n  v.numParams + v.numMotives", "start": [343, 1], "end": [344, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.RecursorVal.getInduct", "code": "def RecursorVal.getInduct (v : RecursorVal) : Name :=\n  v.name.getPrefix", "start": [346, 1], "end": [347, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.QuotKind", "code": "inductive QuotKind where\n  | type  | ctor  | lift  | ind   deriving Inhabited", "start": [349, 1], "end": [354, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.QuotVal", "code": "structure QuotVal extends ConstantVal where\n  kind : QuotKind\n  deriving Inhabited", "start": [356, 1], "end": [358, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.mkQuotValEx", "code": "@[export lean_mk_quot_val]\ndef mkQuotValEx (name : Name) (levelParams : List Name) (type : Expr) (kind : QuotKind) : QuotVal := {\n  name := name, levelParams := levelParams, type := type, kind := kind\n}", "start": [360, 1], "end": [363, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.QuotVal.kindEx", "code": "@[export lean_quot_val_kind] def QuotVal.kindEx (v : QuotVal) : QuotKind := v.kind", "start": [365, 1], "end": [365, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo", "code": "inductive ConstantInfo where\n  | axiomInfo    (val : AxiomVal)\n  | defnInfo     (val : DefinitionVal)\n  | thmInfo      (val : TheoremVal)\n  | opaqueInfo   (val : OpaqueVal)\n  | quotInfo     (val : QuotVal)\n  | inductInfo   (val : InductiveVal)\n  | ctorInfo     (val : ConstructorVal)\n  | recInfo      (val : RecursorVal)\n  deriving Inhabited", "start": [367, 1], "end": [377, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.toConstantVal", "code": "def toConstantVal : ConstantInfo \u2192 ConstantVal\n  | defnInfo     {toConstantVal := d, ..} => d\n  | axiomInfo    {toConstantVal := d, ..} => d\n  | thmInfo      {toConstantVal := d, ..} => d\n  | opaqueInfo   {toConstantVal := d, ..} => d\n  | quotInfo     {toConstantVal := d, ..} => d\n  | inductInfo   {toConstantVal := d, ..} => d\n  | ctorInfo     {toConstantVal := d, ..} => d\n  | recInfo      {toConstantVal := d, ..} => d", "start": [381, 1], "end": [389, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.isUnsafe", "code": "def isUnsafe : ConstantInfo \u2192 Bool\n  | defnInfo   v => v.safety == .unsafe\n  | axiomInfo  v => v.isUnsafe\n  | thmInfo    _ => false\n  | opaqueInfo v => v.isUnsafe\n  | quotInfo   _ => false\n  | inductInfo v => v.isUnsafe\n  | ctorInfo   v => v.isUnsafe\n  | recInfo    v => v.isUnsafe", "start": [391, 1], "end": [399, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.isPartial", "code": "def isPartial : ConstantInfo \u2192 Bool\n  | defnInfo v => v.safety == .partial\n  | _ => false", "start": [401, 1], "end": [403, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.name", "code": "def name (d : ConstantInfo) : Name :=\n  d.toConstantVal.name", "start": [405, 1], "end": [406, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.levelParams", "code": "def levelParams (d : ConstantInfo) : List Name :=\n  d.toConstantVal.levelParams", "start": [408, 1], "end": [409, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.numLevelParams", "code": "def numLevelParams (d : ConstantInfo) : Nat :=\n  d.levelParams.length", "start": [411, 1], "end": [412, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.type", "code": "def type (d : ConstantInfo) : Expr :=\n  d.toConstantVal.type", "start": [414, 1], "end": [415, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.value?", "code": "def value? : ConstantInfo \u2192 Option Expr\n  | defnInfo {value := r, ..} => some r\n  | thmInfo  {value := r, ..} => some r\n  | _                         => none", "start": [417, 1], "end": [420, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.hasValue", "code": "def hasValue : ConstantInfo \u2192 Bool\n  | defnInfo _ => true\n  | thmInfo  _ => true\n  | _                         => false", "start": [422, 1], "end": [425, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.value!", "code": "def value! : ConstantInfo \u2192 Expr\n  | defnInfo {value := r, ..} => r\n  | thmInfo  {value := r, ..} => r\n  | _                         => panic! \"declaration with value expected\"", "start": [427, 1], "end": [430, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.hints", "code": "def hints : ConstantInfo \u2192 ReducibilityHints\n  | defnInfo {hints := r, ..} => r\n  | _                         => ReducibilityHints.opaque", "start": [432, 1], "end": [434, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.isCtor", "code": "def isCtor : ConstantInfo \u2192 Bool\n  | ctorInfo _ => true\n  | _          => false", "start": [436, 1], "end": [438, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.isInductive", "code": "def isInductive : ConstantInfo \u2192 Bool\n  | inductInfo _ => true\n  | _            => false", "start": [440, 1], "end": [442, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.inductiveVal!", "code": "def inductiveVal! : ConstantInfo \u2192 InductiveVal\n  | .inductInfo val => val\n  | _ => panic! \"Expected a `ConstantInfo.inductInfo`.\"", "start": [444, 1], "end": [446, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.all", "code": "def all : ConstantInfo \u2192 List Name\n  | inductInfo val => val.all\n  | defnInfo val   => val.all\n  | thmInfo val    => val.all\n  | opaqueInfo val => val.all\n  | info           => [info.name]", "start": [448, 1], "end": [456, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRecName", "code": "def mkRecName (declName : Name) : Name :=\n  Name.mkStr declName \"rec\"", "start": [460, 1], "end": [461, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/InstantiateLevelParams.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.instantiateLevelParamsCore", "code": "@[specialize] def instantiateLevelParamsCore (s : Name \u2192 Option Level) (e : Expr) : Expr :=\n  e.replace replaceFn\nwhere\n  @[specialize] replaceFn (e : Expr) : Option Expr :=\n    if !e.hasLevelParam then e else match e with\n    | const _ us => e.updateConst! (us.map fun u => u.substParams s)\n    | sort u => e.updateSort! (u.substParams s)\n    | _ => none", "start": [11, 1], "end": [21, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getParamSubst", "code": "private def getParamSubst : List Name \u2192 List Level \u2192 Name \u2192 Option Level\n  | p::ps, u::us, p' => if p == p' then some u else getParamSubst ps us p'\n  | _,     _,     _  => none", "start": [23, 1], "end": [25, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.instantiateLevelParams", "code": "def instantiateLevelParams (e : Expr) (paramNames : List Name) (lvls : List Level) : Expr :=\n  if paramNames.isEmpty || lvls.isEmpty then e else\n    instantiateLevelParamsCore (getParamSubst paramNames lvls) e", "start": [27, 1], "end": [33, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.instantiateLevelParamsNoCache", "code": "def instantiateLevelParamsNoCache (e : Expr) (paramNames : List Name) (lvls : List Level) : Expr :=\n  if paramNames.isEmpty || lvls.isEmpty then e else\n    e.replaceNoCache (instantiateLevelParamsCore.replaceFn (getParamSubst paramNames lvls))", "start": [35, 1], "end": [42, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getParamSubstArray", "code": "private partial def getParamSubstArray (ps : Array Name) (us : Array Level) (p' : Name) (i : Nat) : Option Level :=\n  if h : i < ps.size then\n    let p := ps.get \u27e8i, h\u27e9\n    if h : i < us.size then\n      let u := us.get \u27e8i, h\u27e9\n      if p == p' then some u else getParamSubstArray ps us p' (i+1)\n    else none\n  else none", "start": [44, 1], "end": [51, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.instantiateLevelParamsArray", "code": "def instantiateLevelParamsArray (e : Expr) (paramNames : Array Name) (lvls : Array Level) : Expr :=\n  if paramNames.isEmpty || lvls.isEmpty then e else\n    e.instantiateLevelParamsCore fun p =>\n      getParamSubstArray paramNames lvls p 0", "start": [53, 1], "end": [60, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/Profile.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.get_profiler", "code": "@[export lean_get_profiler]\nprivate def get_profiler (o : Options) : Bool :=\n  profiler.get o", "start": [22, 1], "end": [24, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.profiler.threshold.getSecs", "code": "@[export lean_get_profiler_threshold]\ndef profiler.threshold.getSecs (o : Options) : Float :=\n  (profiler.threshold.get o).toFloat / 1000", "start": [26, 1], "end": [28, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.profileit", "code": "@[extern \"lean_profileit\"]\ndef profileit {\u03b1 : Type} (category : @& String) (opts : @& Options) (fn : Unit \u2192 \u03b1) (decl := Name.anonymous) : \u03b1 := fn ()", "start": [30, 1], "end": [32, 122], "kind": "commanddeclaration"}, {"full_name": "Lean.profileitIOUnsafe", "code": "unsafe def profileitIOUnsafe {\u03b5 \u03b1 : Type} (category : String) (opts : Options) (act : EIO \u03b5 \u03b1) (decl := Name.anonymous) : EIO \u03b5 \u03b1 :=\n  match profileit (decl := decl) category opts fun _ => unsafeEIO act with\n  | Except.ok a    => pure a\n  | Except.error e => throw e", "start": [34, 1], "end": [37, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.profileitIO", "code": "@[implemented_by profileitIOUnsafe]\ndef profileitIO {\u03b5 \u03b1 : Type} (category : String) (opts : Options) (act : EIO \u03b5 \u03b1) (decl := Name.anonymous) : EIO \u03b5 \u03b1 := act", "start": [39, 1], "end": [40, 124], "kind": "commanddeclaration"}, {"full_name": "Lean.profileitM", "code": "def profileitM {m : Type \u2192 Type} (\u03b5 : Type) [MonadFunctorT (EIO \u03b5) m] {\u03b1 : Type} (category : String) (opts : Options) (act : m \u03b1) (decl := Name.anonymous) : m \u03b1 :=\n  monadMap (fun {\u03b2} => profileitIO (\u03b5 := \u03b5) (\u03b1 := \u03b2) (decl := decl) category opts) act", "start": [43, 1], "end": [44, 87], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/LocalContext.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/PersistentArray.lean", "lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Hygiene.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LocalDeclKind", "code": "inductive LocalDeclKind\n  \n  | default\n  \n  | implDetail\n  \n  | auxDecl\n  deriving Inhabited, Repr, DecidableEq, Hashable", "start": [12, 1], "end": [41, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl", "code": "inductive LocalDecl where\n  | cdecl (index : Nat) (fvarId : FVarId) (userName : Name) (type : Expr) (bi : BinderInfo) (kind : LocalDeclKind)\n  | ldecl (index : Nat) (fvarId : FVarId) (userName : Name) (type : Expr) (value : Expr) (nonDep : Bool) (kind : LocalDeclKind)\n  deriving Inhabited", "start": [43, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLocalDeclEx", "code": "@[export lean_mk_local_decl]\ndef mkLocalDeclEx (index : Nat) (fvarId : FVarId) (userName : Name) (type : Expr) (bi : BinderInfo) : LocalDecl :=\n  .cdecl index fvarId userName type bi .default", "start": [56, 1], "end": [58, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.mkLetDeclEx", "code": "@[export lean_mk_let_decl]\ndef mkLetDeclEx (index : Nat) (fvarId : FVarId) (userName : Name) (type : Expr) (val : Expr) : LocalDecl :=\n  .ldecl index fvarId userName type val false .default", "start": [59, 1], "end": [61, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.binderInfoEx", "code": "@[export lean_local_decl_binder_info]\ndef LocalDecl.binderInfoEx : LocalDecl \u2192 BinderInfo\n  | .cdecl _ _ _ _ bi _ => bi\n  | _                   => BinderInfo.default", "start": [62, 1], "end": [65, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.isLet", "code": "def isLet : LocalDecl \u2192 Bool\n  | cdecl .. => false\n  | ldecl .. => true", "start": [68, 1], "end": [70, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.index", "code": "def index : LocalDecl \u2192 Nat\n  | cdecl (index := i) .. => i\n  | ldecl (index := i) .. => i", "start": [72, 1], "end": [74, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.setIndex", "code": "def setIndex : LocalDecl \u2192 Nat \u2192 LocalDecl\n  | cdecl _  id n t bi k,   idx => cdecl idx id n t bi k\n  | ldecl _  id n t v nd k, idx => ldecl idx id n t v nd k", "start": [76, 1], "end": [78, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.fvarId", "code": "def fvarId : LocalDecl \u2192 FVarId\n  | cdecl (fvarId := id) .. => id\n  | ldecl (fvarId := id) .. => id", "start": [80, 1], "end": [82, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.userName", "code": "def userName : LocalDecl \u2192 Name\n  | cdecl (userName := n) .. => n\n  | ldecl (userName := n) .. => n", "start": [84, 1], "end": [86, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.type", "code": "def type : LocalDecl \u2192 Expr\n  | cdecl (type := t) .. => t\n  | ldecl (type := t) .. => t", "start": [88, 1], "end": [90, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.setType", "code": "def setType : LocalDecl \u2192 Expr \u2192 LocalDecl\n  | cdecl idx id n _ bi k, t   => cdecl idx id n t bi k\n  | ldecl idx id n _ v nd k, t => ldecl idx id n t v nd k", "start": [92, 1], "end": [94, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.binderInfo", "code": "def binderInfo : LocalDecl \u2192 BinderInfo\n  | cdecl (bi := bi) .. => bi\n  | ldecl ..            => BinderInfo.default", "start": [96, 1], "end": [98, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.kind", "code": "def kind : LocalDecl \u2192 LocalDeclKind\n  | cdecl .. | ldecl .. => \u2039_\u203a", "start": [100, 1], "end": [101, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.isAuxDecl", "code": "def isAuxDecl (d : LocalDecl) : Bool :=\n  d.kind = .auxDecl", "start": [103, 1], "end": [104, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.isImplementationDetail", "code": "def isImplementationDetail (d : LocalDecl) : Bool :=\n  d.kind != .default", "start": [106, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.value?", "code": "def value? : LocalDecl \u2192 Option Expr\n  | cdecl ..              => none\n  | ldecl (value := v) .. => some v", "start": [113, 1], "end": [115, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.value", "code": "def value : LocalDecl \u2192 Expr\n  | cdecl ..              => panic! \"let declaration expected\"\n  | ldecl (value := v) .. => v", "start": [117, 1], "end": [119, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.hasValue", "code": "def hasValue : LocalDecl \u2192 Bool\n  | cdecl .. => false\n  | ldecl .. => true", "start": [121, 1], "end": [123, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.setValue", "code": "def setValue : LocalDecl \u2192 Expr \u2192 LocalDecl\n  | ldecl idx id n t _ nd k, v => ldecl idx id n t v nd k\n  | d, _                       => d", "start": [125, 1], "end": [127, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.setUserName", "code": "def setUserName : LocalDecl \u2192 Name \u2192 LocalDecl\n  | cdecl index id _ type bi k,     userName => cdecl index id userName type bi k\n  | ldecl index id _ type val nd k, userName => ldecl index id userName type val nd k", "start": [129, 1], "end": [131, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.setBinderInfo", "code": "def setBinderInfo : LocalDecl \u2192 BinderInfo \u2192 LocalDecl\n  | cdecl index id n type _ k,  bi => cdecl index id n type bi k\n  | ldecl .., _                    => panic! \"unexpected let declaration\"", "start": [133, 1], "end": [135, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.toExpr", "code": "def toExpr (decl : LocalDecl) : Expr :=\n  mkFVar decl.fvarId", "start": [137, 1], "end": [138, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.hasExprMVar", "code": "def hasExprMVar : LocalDecl \u2192 Bool\n  | cdecl (type := t) ..              => t.hasExprMVar\n  | ldecl (type := t) (value := v) .. => t.hasExprMVar || v.hasExprMVar", "start": [140, 1], "end": [142, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext", "code": "structure LocalContext where\n  fvarIdToDecl : PersistentHashMap FVarId LocalDecl := {}\n  decls        : PersistentArray (Option LocalDecl) := {}\n  deriving Inhabited", "start": [146, 1], "end": [156, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.mkEmpty", "code": "@[export lean_mk_empty_local_ctx]\ndef mkEmpty : Unit \u2192 LocalContext := fun _ => {}", "start": [160, 1], "end": [161, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.empty", "code": "def empty : LocalContext := {}", "start": [163, 1], "end": [163, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.isEmpty", "code": "@[export lean_local_ctx_is_empty]\ndef isEmpty (lctx : LocalContext) : Bool :=\n  lctx.fvarIdToDecl.isEmpty", "start": [165, 1], "end": [167, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.mkLocalDecl", "code": "def mkLocalDecl (lctx : LocalContext) (fvarId : FVarId) (userName : Name) (type : Expr) (bi : BinderInfo := BinderInfo.default) (kind : LocalDeclKind := .default) : LocalContext :=\n  match lctx with\n  | { fvarIdToDecl := map, decls := decls } =>\n    let idx  := decls.size\n    let decl := LocalDecl.cdecl idx fvarId userName type bi kind\n    { fvarIdToDecl := map.insert fvarId decl, decls := decls.push decl }", "start": [169, 1], "end": [178, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.mkLocalDeclExported", "code": "@[export lean_local_ctx_mk_local_decl]\nprivate def mkLocalDeclExported (lctx : LocalContext) (fvarId : FVarId) (userName : Name) (type : Expr) (bi : BinderInfo) : LocalContext :=\n  mkLocalDecl lctx fvarId userName type bi", "start": [181, 1], "end": [183, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.mkLetDecl", "code": "def mkLetDecl (lctx : LocalContext) (fvarId : FVarId) (userName : Name) (type : Expr) (value : Expr) (nonDep := false) (kind : LocalDeclKind := default) : LocalContext :=\n  match lctx with\n  | { fvarIdToDecl := map, decls := decls } =>\n    let idx  := decls.size\n    let decl := LocalDecl.ldecl idx fvarId userName type value nonDep kind\n    { fvarIdToDecl := map.insert fvarId decl, decls := decls.push decl }", "start": [185, 1], "end": [191, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.mkLetDeclExported", "code": "@[export lean_local_ctx_mk_let_decl]\nprivate def mkLetDeclExported (lctx : LocalContext) (fvarId : FVarId) (userName : Name) (type : Expr) (value : Expr) (nonDep : Bool) : LocalContext :=\n  mkLetDecl lctx fvarId userName type value nonDep", "start": [193, 1], "end": [195, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.addDecl", "code": "def addDecl (lctx : LocalContext) (newDecl : LocalDecl) : LocalContext :=\n  match lctx with\n  | { fvarIdToDecl := map, decls := decls } =>\n    let idx     := decls.size\n    let newDecl := newDecl.setIndex idx\n    { fvarIdToDecl := map.insert newDecl.fvarId newDecl, decls := decls.push newDecl }", "start": [197, 1], "end": [204, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.find?", "code": "@[export lean_local_ctx_find]\ndef find? (lctx : LocalContext) (fvarId : FVarId) : Option LocalDecl :=\n  lctx.fvarIdToDecl.find? fvarId", "start": [206, 1], "end": [208, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.findFVar?", "code": "def findFVar? (lctx : LocalContext) (e : Expr) : Option LocalDecl :=\n  lctx.find? e.fvarId!", "start": [210, 1], "end": [211, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.get!", "code": "def get! (lctx : LocalContext) (fvarId : FVarId) : LocalDecl :=\n  match lctx.find? fvarId with\n  | some d => d\n  | none   => panic! \"unknown free variable\"", "start": [213, 1], "end": [216, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.getFVar!", "code": "def getFVar! (lctx : LocalContext) (e : Expr) : LocalDecl :=\n  lctx.get! e.fvarId!", "start": [218, 1], "end": [221, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.contains", "code": "def contains (lctx : LocalContext) (fvarId : FVarId) : Bool :=\n  lctx.fvarIdToDecl.contains fvarId", "start": [223, 1], "end": [224, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.containsFVar", "code": "def containsFVar (lctx : LocalContext) (e : Expr) : Bool :=\n  lctx.contains e.fvarId!", "start": [226, 1], "end": [229, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.getFVarIds", "code": "def getFVarIds (lctx : LocalContext) : Array FVarId :=\n  lctx.decls.foldl (init := #[]) fun r decl? => match decl? with\n    | some decl => r.push decl.fvarId\n    | none      => r", "start": [231, 1], "end": [234, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.getFVars", "code": "def getFVars (lctx : LocalContext) : Array Expr :=\n  lctx.getFVarIds.map mkFVar", "start": [236, 1], "end": [238, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.popTailNoneAux", "code": "private partial def popTailNoneAux (a : PArray (Option LocalDecl)) : PArray (Option LocalDecl) :=\n  if a.size == 0 then a\n  else match a.get! (a.size - 1) with\n    | none   => popTailNoneAux a.pop\n    | some _ => a", "start": [240, 1], "end": [244, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.erase", "code": "@[export lean_local_ctx_erase]\ndef erase (lctx : LocalContext) (fvarId : FVarId) : LocalContext :=\n  match lctx with\n  | { fvarIdToDecl := map, decls := decls } =>\n    match map.find? fvarId with\n    | none      => lctx\n    | some decl => { fvarIdToDecl := map.erase fvarId, decls := popTailNoneAux (decls.set decl.index none) }", "start": [246, 1], "end": [252, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.pop", "code": "def pop (lctx : LocalContext): LocalContext :=\n  match lctx with\n  | { fvarIdToDecl := map, decls := decls } =>\n    if decls.size == 0 then lctx\n    else match decls.get! (decls.size - 1) with\n      | none      => lctx | some decl => { fvarIdToDecl := map.erase decl.fvarId, decls := popTailNoneAux decls.pop }", "start": [254, 1], "end": [260, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.findFromUserName?", "code": "def findFromUserName? (lctx : LocalContext) (userName : Name) : Option LocalDecl :=\n  lctx.decls.findSomeRev? fun decl =>\n    match decl with\n    | none      => none\n    | some decl => if decl.userName == userName then some decl else none", "start": [262, 1], "end": [266, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.usesUserName", "code": "def usesUserName (lctx : LocalContext) (userName : Name) : Bool :=\n  (lctx.findFromUserName? userName).isSome", "start": [268, 1], "end": [269, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.getUnusedNameAux", "code": "private partial def getUnusedNameAux (lctx : LocalContext) (suggestion : Name) (i : Nat) : Name \u00d7 Nat :=\n  let curr := suggestion.appendIndexAfter i\n  if lctx.usesUserName curr then getUnusedNameAux lctx suggestion (i + 1)\n  else (curr, i + 1)", "start": [271, 1], "end": [274, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.getUnusedName", "code": "def getUnusedName (lctx : LocalContext) (suggestion : Name) : Name :=\n  let suggestion := suggestion.eraseMacroScopes\n  if lctx.usesUserName suggestion then (getUnusedNameAux lctx suggestion 1).1\n  else suggestion", "start": [276, 1], "end": [279, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.lastDecl", "code": "def lastDecl (lctx : LocalContext) : Option LocalDecl :=\n  lctx.decls.get! (lctx.decls.size - 1)", "start": [281, 1], "end": [282, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.setUserName", "code": "def setUserName (lctx : LocalContext) (fvarId : FVarId) (userName : Name) : LocalContext :=\n  let decl := lctx.get! fvarId\n  let decl := decl.setUserName userName\n  { fvarIdToDecl := lctx.fvarIdToDecl.insert decl.fvarId decl,\n    decls        := lctx.decls.set decl.index decl }", "start": [284, 1], "end": [288, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.renameUserName", "code": "def renameUserName (lctx : LocalContext) (fromName : Name) (toName : Name) : LocalContext :=\n  match lctx with\n  | { fvarIdToDecl := map, decls := decls } =>\n    match lctx.findFromUserName? fromName with\n    | none      => lctx\n    | some decl =>\n      let decl := decl.setUserName toName;\n      { fvarIdToDecl := map.insert decl.fvarId decl,\n        decls        := decls.set decl.index decl }", "start": [290, 1], "end": [298, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.modifyLocalDecl", "code": "@[inline] def modifyLocalDecl (lctx : LocalContext) (fvarId : FVarId) (f : LocalDecl \u2192 LocalDecl) : LocalContext :=\n  match lctx with\n  | { fvarIdToDecl := map, decls := decls } =>\n    match lctx.find? fvarId with\n    | none      => lctx\n    | some decl =>\n      let decl := f decl\n      { fvarIdToDecl := map.insert decl.fvarId decl\n        decls        := decls.set decl.index decl }", "start": [300, 1], "end": [312, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.setBinderInfo", "code": "def setBinderInfo (lctx : LocalContext) (fvarId : FVarId) (bi : BinderInfo) : LocalContext :=\n  modifyLocalDecl lctx fvarId fun decl => decl.setBinderInfo bi", "start": [314, 1], "end": [315, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.numIndices", "code": "@[export lean_local_ctx_num_indices]\ndef numIndices (lctx : LocalContext) : Nat :=\n  lctx.decls.size", "start": [317, 1], "end": [319, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.getAt?", "code": "def getAt? (lctx : LocalContext) (i : Nat) : Option LocalDecl :=\n  lctx.decls.get! i", "start": [321, 1], "end": [322, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.foldlM", "code": "@[specialize] def foldlM [Monad m] (lctx : LocalContext) (f : \u03b2 \u2192 LocalDecl \u2192 m \u03b2) (init : \u03b2) (start : Nat := 0) : m \u03b2 :=\n  lctx.decls.foldlM (init := init) (start := start) fun b decl => match decl with\n    | none      => pure b\n    | some decl => f b decl", "start": [324, 1], "end": [327, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.foldrM", "code": "@[specialize] def foldrM [Monad m] (lctx : LocalContext) (f : LocalDecl \u2192 \u03b2 \u2192 m \u03b2) (init : \u03b2) : m \u03b2 :=\n  lctx.decls.foldrM (init := init) fun decl b => match decl with\n    | none      => pure b\n    | some decl => f decl b", "start": [329, 1], "end": [332, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.forM", "code": "@[specialize] def forM [Monad m] (lctx : LocalContext) (f : LocalDecl \u2192 m PUnit) : m PUnit :=\n  lctx.decls.forM fun decl => match decl with\n    | none      => pure PUnit.unit\n    | some decl => f decl", "start": [334, 1], "end": [337, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.findDeclM?", "code": "@[specialize] def findDeclM? [Monad m] (lctx : LocalContext) (f : LocalDecl \u2192 m (Option \u03b2)) : m (Option \u03b2) :=\n  lctx.decls.findSomeM? fun decl => match decl with\n    | none      => pure none\n    | some decl => f decl", "start": [339, 1], "end": [342, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.findDeclRevM?", "code": "@[specialize] def findDeclRevM? [Monad m] (lctx : LocalContext) (f : LocalDecl \u2192 m (Option \u03b2)) : m (Option \u03b2) :=\n  lctx.decls.findSomeRevM? fun decl => match decl with\n    | none      => pure none\n    | some decl => f decl", "start": [344, 1], "end": [347, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.foldl", "code": "@[inline] def foldl (lctx : LocalContext) (f : \u03b2 \u2192 LocalDecl \u2192 \u03b2) (init : \u03b2) (start : Nat := 0) : \u03b2 :=\n  Id.run <| lctx.foldlM f init start", "start": [354, 1], "end": [355, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.foldr", "code": "@[inline] def foldr (lctx : LocalContext) (f : LocalDecl \u2192 \u03b2 \u2192 \u03b2) (init : \u03b2) : \u03b2 :=\n  Id.run <| lctx.foldrM f init", "start": [357, 1], "end": [358, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.size", "code": "def size (lctx : LocalContext) : Nat :=\n  lctx.foldl (fun n _ => n+1) 0", "start": [360, 1], "end": [361, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.findDecl?", "code": "@[inline] def findDecl? (lctx : LocalContext) (f : LocalDecl \u2192 Option \u03b2) : Option \u03b2 :=\n  Id.run <| lctx.findDeclM? f", "start": [363, 1], "end": [364, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.findDeclRev?", "code": "@[inline] def findDeclRev? (lctx : LocalContext) (f : LocalDecl \u2192 Option \u03b2) : Option \u03b2 :=\n  Id.run <| lctx.findDeclRevM? f", "start": [366, 1], "end": [367, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.isSubPrefixOfAux", "code": "partial def isSubPrefixOfAux (a\u2081 a\u2082 : PArray (Option LocalDecl)) (exceptFVars : Array Expr) (i j : Nat) : Bool :=\n  if i < a\u2081.size then\n    match a\u2081[i]! with\n    | none       => isSubPrefixOfAux a\u2081 a\u2082 exceptFVars (i+1) j\n    | some decl\u2081 =>\n      if exceptFVars.any fun fvar => fvar.fvarId! == decl\u2081.fvarId then\n        isSubPrefixOfAux a\u2081 a\u2082 exceptFVars (i+1) j\n      else if j < a\u2082.size then\n        match a\u2082[j]! with\n        | none       => isSubPrefixOfAux a\u2081 a\u2082 exceptFVars i (j+1)\n        | some decl\u2082 => if decl\u2081.fvarId == decl\u2082.fvarId then isSubPrefixOfAux a\u2081 a\u2082 exceptFVars (i+1) (j+1) else isSubPrefixOfAux a\u2081 a\u2082 exceptFVars i (j+1)\n      else false\n  else true", "start": [369, 1], "end": [381, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.isSubPrefixOf", "code": "def isSubPrefixOf (lctx\u2081 lctx\u2082 : LocalContext) (exceptFVars : Array Expr := #[]) : Bool :=\n  isSubPrefixOfAux lctx\u2081.decls lctx\u2082.decls exceptFVars 0 0", "start": [383, 1], "end": [387, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.mkBinding", "code": "@[inline] def mkBinding (isLambda : Bool) (lctx : LocalContext) (xs : Array Expr) (b : Expr) : Expr :=\n  let b := b.abstract xs\n  xs.size.foldRev (init := b) fun i b =>\n    let x := xs[i]!\n    match lctx.findFVar? x with\n    | some (.cdecl _ _ n ty bi _)  =>\n      let ty := ty.abstractRange i xs;\n      if isLambda then\n        Lean.mkLambda n bi ty b\n      else\n        Lean.mkForall n bi ty b\n    | some (.ldecl _ _ n ty val nonDep _) =>\n      if b.hasLooseBVar 0 then\n        let ty  := ty.abstractRange i xs\n        let val := val.abstractRange i xs\n        mkLet n ty val b nonDep\n      else\n        b.lowerLooseBVars 1 1\n    | none => panic! \"unknown free variable\"", "start": [389, 1], "end": [407, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.mkLambda", "code": "def mkLambda (lctx : LocalContext) (xs : Array Expr) (b : Expr) : Expr :=\n  mkBinding true lctx xs b", "start": [409, 1], "end": [412, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.mkForall", "code": "def mkForall (lctx : LocalContext) (xs : Array Expr) (b : Expr) : Expr :=\n  mkBinding false lctx xs b", "start": [414, 1], "end": [417, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.anyM", "code": "@[inline] def anyM [Monad m] (lctx : LocalContext) (p : LocalDecl \u2192 m Bool) : m Bool :=\n  lctx.decls.anyM fun d => match d with\n    | some decl => p decl\n    | none      => pure false", "start": [419, 1], "end": [422, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.allM", "code": "@[inline] def allM [Monad m] (lctx : LocalContext) (p : LocalDecl \u2192 m Bool) : m Bool :=\n  lctx.decls.allM fun d => match d with\n    | some decl => p decl\n    | none      => pure true", "start": [424, 1], "end": [427, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.any", "code": "@[inline] def any (lctx : LocalContext) (p : LocalDecl \u2192 Bool) : Bool :=\n  Id.run <| lctx.anyM p", "start": [429, 1], "end": [431, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.all", "code": "@[inline] def all (lctx : LocalContext) (p : LocalDecl \u2192 Bool) : Bool :=\n  Id.run <| lctx.allM p", "start": [433, 1], "end": [435, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.sanitizeNames", "code": "def sanitizeNames (lctx : LocalContext) : StateM NameSanitizerState LocalContext := do\n  let st \u2190 get\n  if !getSanitizeNames st.options then pure lctx else\n    StateT.run' (s := ({} : NameSet)) <|\n      lctx.decls.size.foldRevM (init := lctx) fun i lctx => do\n        match lctx.decls[i]! with\n        | none      => pure lctx\n        | some decl =>\n          if decl.userName.hasMacroScopes || (\u2190 get).contains decl.userName then do\n            modify fun s => s.insert decl.userName\n            let userNameNew \u2190 liftM <| sanitizeName decl.userName\n            pure <| lctx.setUserName decl.fvarId userNameNew\n          else\n            modify fun s => s.insert decl.userName\n            pure lctx", "start": [437, 1], "end": [452, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadLCtx", "code": "class MonadLCtx (m : Type \u2192 Type) where\n  getLCtx : m LocalContext", "start": [456, 1], "end": [458, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.replaceFVarId", "code": "def LocalDecl.replaceFVarId (fvarId : FVarId) (e : Expr) (d : LocalDecl) : LocalDecl :=\n  if d.fvarId == fvarId then d\n  else match d with\n    | .cdecl idx id n type bi k => .cdecl idx id n (type.replaceFVarId fvarId e) bi k\n    | .ldecl idx id n type val nonDep k => .ldecl idx id n (type.replaceFVarId fvarId e) (val.replaceFVarId fvarId e) nonDep k", "start": [465, 1], "end": [469, 127], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.replaceFVarId", "code": "def LocalContext.replaceFVarId (fvarId : FVarId) (e : Expr) (lctx : LocalContext) : LocalContext :=\n  let lctx := lctx.erase fvarId\n  { fvarIdToDecl := lctx.fvarIdToDecl.map (\u00b7.replaceFVarId fvarId e)\n    decls := lctx.decls.map fun localDecl? => localDecl?.map (\u00b7.replaceFVarId fvarId e) }", "start": [471, 1], "end": [474, 90], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/MonadCache.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MonadCache", "code": "class MonadCache (\u03b1 \u03b2 : Type) (m : Type \u2192 Type) where\n  findCached? : \u03b1 \u2192 m (Option \u03b2)\n  cache       : \u03b1 \u2192 \u03b2 \u2192 m Unit", "start": [9, 1], "end": [12, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.checkCache", "code": "@[always_inline, inline]\ndef checkCache {\u03b1 \u03b2 : Type} {m : Type \u2192 Type} [MonadCache \u03b1 \u03b2 m] [Monad m] (a : \u03b1) (f : Unit \u2192 m \u03b2) : m \u03b2 := do\n  match (\u2190 MonadCache.findCached? a) with\n  | some b => pure b\n  | none   => do\n    let b \u2190 f ()\n    MonadCache.cache a b\n    pure b", "start": [14, 1], "end": [23, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadHashMapCacheAdapter", "code": "class MonadHashMapCacheAdapter (\u03b1 \u03b2 : Type) (m : Type \u2192 Type) [BEq \u03b1] [Hashable \u03b1] where\n  getCache    : m (HashMap \u03b1 \u03b2)\n  modifyCache : (HashMap \u03b1 \u03b2 \u2192 HashMap \u03b1 \u03b2) \u2192 m Unit", "start": [34, 1], "end": [38, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadHashMapCacheAdapter.findCached?", "code": "@[always_inline, inline]\ndef findCached? {\u03b1 \u03b2 : Type} {m : Type \u2192 Type} [BEq \u03b1] [Hashable \u03b1] [Monad m] [MonadHashMapCacheAdapter \u03b1 \u03b2 m] (a : \u03b1) : m (Option \u03b2) := do\n  let c \u2190 getCache\n  pure (c.find? a)", "start": [42, 1], "end": [45, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadHashMapCacheAdapter.cache", "code": "@[always_inline, inline]\ndef cache {\u03b1 \u03b2 : Type} {m : Type \u2192 Type} [BEq \u03b1] [Hashable \u03b1] [MonadHashMapCacheAdapter \u03b1 \u03b2 m] (a : \u03b1) (b : \u03b2) : m Unit :=\n  modifyCache fun s => s.insert a b", "start": [47, 1], "end": [49, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadCacheT", "code": "def MonadCacheT {\u03c9} (\u03b1 \u03b2 : Type) (m : Type \u2192 Type) [STWorld \u03c9 m] [BEq \u03b1] [Hashable \u03b1] := StateRefT (HashMap \u03b1 \u03b2) m", "start": [57, 1], "end": [57, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadCacheT.run", "code": "@[inline] def run {\u03c3} (x : MonadCacheT \u03b1 \u03b2 m \u03c3) : m \u03c3 :=\n  x.run' mkHashMap", "start": [67, 1], "end": [68, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadStateCacheT", "code": "def MonadStateCacheT (\u03b1 \u03b2 : Type) (m : Type \u2192 Type) [BEq \u03b1] [Hashable \u03b1] := StateT (HashMap \u03b1 \u03b2) m", "start": [81, 1], "end": [81, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadStateCacheT.run", "code": "@[always_inline, inline] def run {\u03c3} (x : MonadStateCacheT \u03b1 \u03b2 m \u03c3) : m \u03c3 :=\n  x.run' mkHashMap", "start": [91, 1], "end": [92, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/ToExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ToExpr", "code": "class ToExpr (\u03b1 : Type u) where\n  \n  toExpr     : \u03b1 \u2192 Expr\n  \n  toTypeExpr : Expr", "start": [11, 1], "end": [23, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Name.toExprAux", "code": "private def Name.toExprAux (n : Name) : Expr :=\n  if isSimple n 0 then\n    mkStr n 0 #[]\n  else\n    go n\nwhere\n  isSimple (n : Name) (sz : Nat) : Bool :=\n    match n with\n    | .anonymous => 0 < sz && sz <= 8\n    | .str p _ => isSimple p (sz+1)\n    | _ => false\n\n  mkStr (n : Name) (sz : Nat) (args : Array Expr) : Expr :=\n    match n with\n    | .anonymous => mkAppN (mkConst (.str ``Lean.Name (\"mkStr\" ++ toString sz))) args.reverse\n    | .str p s => mkStr p (sz+1) (args.push (toExpr s))\n    | _ => unreachable!\n\n  go : Name \u2192 Expr\n    | .anonymous => mkConst ``Lean.Name.anonymous\n    | .str p s ..=> mkApp2 (mkConst ``Lean.Name.str) (go p) (toExpr s)\n    | .num p n ..=> mkApp2 (mkConst ``Lean.Name.num) (go p) (toExpr n)", "start": [47, 1], "end": [68, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.List.toExprAux", "code": "private def List.toExprAux [ToExpr \u03b1] (nilFn : Expr) (consFn : Expr) : List \u03b1 \u2192 Expr\n  | []    => nilFn\n  | a::as => mkApp2 consFn (toExpr a) (toExprAux nilFn consFn as)", "start": [81, 1], "end": [83, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.toCtorIfLit", "code": "def Expr.toCtorIfLit : Expr \u2192 Expr\n  | .lit (.natVal v) =>\n    if v == 0 then mkConst ``Nat.zero\n    else mkApp (mkConst ``Nat.succ) (mkRawNatLit (v-1))\n  | .lit (.strVal v) =>\n    mkApp (mkConst ``String.mk) (toExpr v.toList)\n  | e => e", "start": [103, 1], "end": [109, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Json/Stream.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json/Parser.lean", "lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/FromToJson.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/Printer.lean"], "premises": [{"full_name": "IO.FS.Stream.readJson", "code": "def readJson (h : FS.Stream) (nBytes : Nat) : IO Json := do\n  let bytes \u2190 h.read (USize.ofNat nBytes)\n  let s := String.fromUTF8Unchecked bytes\n  ofExcept (Json.parse s)", "start": [17, 1], "end": [21, 26], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeJson", "code": "def writeJson (h : FS.Stream) (j : Json) : IO Unit := do\n  h.putStr j.compress\n  h.flush", "start": [23, 1], "end": [25, 10], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Environment.lean", "imports": ["lake-packages/lean4/src/lean/Lean/LocalContext.lean", "lake-packages/lean4/src/lean/Lean/ImportingFlag.lean", "lake-packages/lean4/src/lean/Lean/Util/Profile.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Util/InstantiateLevelParams.lean", "lake-packages/lean4/src/lean/Lean/Declaration.lean", "lake-packages/lean4/src/lean/Lean/Data/SMap.lean", "lake-packages/lean4/src/lean/Lean/Util/Path.lean", "lake-packages/lean4/src/lean/Lean/Data/HashMap.lean", "lake-packages/lean4/src/lean/Lean/Util/FindExpr.lean"], "premises": [{"full_name": "Lean.EnvExtensionStateSpec", "code": "opaque EnvExtensionStateSpec : (\u03b1 : Type) \u00d7 Inhabited \u03b1 := \u27e8Unit, \u27e8()\u27e9\u27e9", "start": [17, 1], "end": [18, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionState", "code": "def EnvExtensionState : Type := EnvExtensionStateSpec.fst", "start": [19, 1], "end": [19, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.ModuleIdx", "code": "def ModuleIdx := Nat\n  deriving BEq, ToString", "start": [22, 1], "end": [23, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.ModuleIdx.toNat", "code": "abbrev ModuleIdx.toNat (midx : ModuleIdx) : Nat := midx", "start": [25, 1], "end": [25, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstMap", "code": "abbrev ConstMap := SMap Name ConstantInfo", "start": [29, 1], "end": [29, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Import", "code": "structure Import where\n  module      : Name\n  runtimeOnly : Bool := false\n  deriving Repr, Inhabited", "start": [31, 1], "end": [34, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.CompactedRegion", "code": "def CompactedRegion := USize", "start": [40, 1], "end": [44, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.CompactedRegion.isMemoryMapped", "code": "@[extern \"lean_compacted_region_is_memory_mapped\"]\nopaque CompactedRegion.isMemoryMapped : CompactedRegion \u2192 Bool", "start": [46, 1], "end": [47, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.CompactedRegion.free", "code": "@[extern \"lean_compacted_region_free\"]\nunsafe opaque CompactedRegion.free : CompactedRegion \u2192 IO Unit", "start": [49, 1], "end": [51, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionEntrySpec", "code": "opaque EnvExtensionEntrySpec : NonemptyType.{0}", "start": [53, 1], "end": [54, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionEntry", "code": "def EnvExtensionEntry : Type := EnvExtensionEntrySpec.type", "start": [55, 1], "end": [55, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.ModuleData", "code": "structure ModuleData where\n  imports         : Array Import\n  \n  constNames      : Array Name\n  constants       : Array ConstantInfo\n  \n  extraConstNames : Array Name\n  entries         : Array (Name \u00d7 Array EnvExtensionEntry)\n  deriving Inhabited", "start": [58, 1], "end": [77, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvironmentHeader", "code": "structure EnvironmentHeader where\n  \n  trustLevel   : UInt32       := 0\n  \n  quotInit     : Bool         := false\n  \n  mainModule   : Name         := default\n  \n  imports      : Array Import := #[]\n  \n  regions      : Array CompactedRegion := #[]\n  \n  moduleNames  : Array Name   := #[]\n  \n  moduleData   : Array ModuleData := #[]\n  deriving Nonempty", "start": [79, 1], "end": [103, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment", "code": "structure Environment where\n  \n  private mk ::\n  \n  const2ModIdx : HashMap Name ModuleIdx\n  \n  constants    : ConstMap\n  \n  extensions   : Array EnvExtensionState\n  \n  extraConstNames : NameSet\n  \n  header       : EnvironmentHeader := {}\n  deriving Nonempty", "start": [105, 1], "end": [151, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.addAux", "code": "private def addAux (env : Environment) (cinfo : ConstantInfo) : Environment :=\n  { env with constants := env.constants.insert cinfo.name cinfo }", "start": [155, 1], "end": [156, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.addExtraName", "code": "def addExtraName (env : Environment) (name : Name) : Environment :=\n  if env.constants.contains name then\n    env\n  else\n    { env with extraConstNames := env.extraConstNames.insert name }", "start": [158, 1], "end": [167, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.find?", "code": "@[export lean_environment_find]\ndef find? (env : Environment) (n : Name) : Option ConstantInfo :=\n  \n  env.constants.find?' n", "start": [169, 1], "end": [172, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.contains", "code": "def contains (env : Environment) (n : Name) : Bool :=\n  env.constants.contains n", "start": [174, 1], "end": [175, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.imports", "code": "def imports (env : Environment) : Array Import :=\n  env.header.imports", "start": [177, 1], "end": [178, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.allImportedModuleNames", "code": "def allImportedModuleNames (env : Environment) : Array Name :=\n  env.header.moduleNames", "start": [180, 1], "end": [181, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.setMainModule", "code": "@[export lean_environment_set_main_module]\ndef setMainModule (env : Environment) (m : Name) : Environment :=\n  { env with header := { env.header with mainModule := m } }", "start": [183, 1], "end": [185, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.mainModule", "code": "@[export lean_environment_main_module]\ndef mainModule (env : Environment) : Name :=\n  env.header.mainModule", "start": [187, 1], "end": [189, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.markQuotInit", "code": "@[export lean_environment_mark_quot_init]\nprivate def markQuotInit (env : Environment) : Environment :=\n  { env with header := { env.header with quotInit := true } }", "start": [191, 1], "end": [193, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.isQuotInit", "code": "@[export lean_environment_quot_init]\nprivate def isQuotInit (env : Environment) : Bool :=\n  env.header.quotInit", "start": [195, 1], "end": [197, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.getTrustLevel", "code": "@[export lean_environment_trust_level]\nprivate def getTrustLevel (env : Environment) : UInt32 :=\n  env.header.trustLevel", "start": [199, 1], "end": [201, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.getModuleIdxFor?", "code": "def getModuleIdxFor? (env : Environment) (declName : Name) : Option ModuleIdx :=\n  env.const2ModIdx.find? declName", "start": [203, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.isConstructor", "code": "def isConstructor (env : Environment) (declName : Name) : Bool :=\n  match env.find? declName with\n  | ConstantInfo.ctorInfo _ => true\n  | _                       => false", "start": [206, 1], "end": [209, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.getModuleIdx?", "code": "def getModuleIdx? (env : Environment) (moduleName : Name) : Option ModuleIdx :=\n  env.header.moduleNames.findIdx? (\u00b7 == moduleName)", "start": [211, 1], "end": [212, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.KernelException", "code": "inductive KernelException where\n  | unknownConstant  (env : Environment) (name : Name)\n  | alreadyDeclared  (env : Environment) (name : Name)\n  | declTypeMismatch (env : Environment) (decl : Declaration) (givenType : Expr)\n  | declHasMVars     (env : Environment) (name : Name) (expr : Expr)\n  | declHasFVars     (env : Environment) (name : Name) (expr : Expr)\n  | funExpected      (env : Environment) (lctx : LocalContext) (expr : Expr)\n  | typeExpected     (env : Environment) (lctx : LocalContext) (expr : Expr)\n  | letTypeMismatch  (env : Environment) (lctx : LocalContext) (name : Name) (givenType : Expr) (expectedType : Expr)\n  | exprTypeMismatch (env : Environment) (lctx : LocalContext) (expr : Expr) (expectedType : Expr)\n  | appTypeMismatch  (env : Environment) (lctx : LocalContext) (app : Expr) (funType : Expr) (argType : Expr)\n  | invalidProj      (env : Environment) (lctx : LocalContext) (proj : Expr)\n  | other            (msg : String)\n  | deterministicTimeout\n  | excessiveMemory\n  | deepRecursion", "start": [216, 1], "end": [232, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.addDecl", "code": "@[extern \"lean_add_decl\"]\nopaque addDecl (env : Environment) (decl : @& Declaration) : Except KernelException Environment", "start": [236, 1], "end": [238, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.instantiateTypeLevelParams", "code": "def instantiateTypeLevelParams (c : ConstantInfo) (ls : List Level) : Expr :=\n  c.type.instantiateLevelParams c.levelParams ls", "start": [244, 1], "end": [245, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.instantiateValueLevelParams!", "code": "def instantiateValueLevelParams! (c : ConstantInfo) (ls : List Level) : Expr :=\n  c.value!.instantiateLevelParams c.levelParams ls", "start": [247, 1], "end": [248, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterface", "code": "structure EnvExtensionInterface where\n  ext          : Type \u2192 Type\n  inhabitedExt : Inhabited \u03c3 \u2192 Inhabited (ext \u03c3)\n  registerExt  (mkInitial : IO \u03c3) : IO (ext \u03c3)\n  setState     (e : ext \u03c3) (exts : Array EnvExtensionState) : \u03c3 \u2192 Array EnvExtensionState\n  modifyState  (e : ext \u03c3) (exts : Array EnvExtensionState) : (\u03c3 \u2192 \u03c3) \u2192 Array EnvExtensionState\n  getState     [Inhabited \u03c3] (e : ext \u03c3) (exts : Array EnvExtensionState) : \u03c3\n  mkInitialExtStates : IO (Array EnvExtensionState)\n  ensureExtensionsSize : Array EnvExtensionState \u2192 IO (Array EnvExtensionState)", "start": [252, 1], "end": [261, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceUnsafe.Ext", "code": "structure Ext (\u03c3 : Type) where\n  idx       : Nat\n  mkInitial : IO \u03c3\n  deriving Inhabited", "start": [278, 1], "end": [281, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceUnsafe.ensureExtensionsArraySize", "code": "partial def ensureExtensionsArraySize (exts : Array EnvExtensionState) : IO (Array EnvExtensionState) := do\n  loop exts.size exts\nwhere\n  loop (i : Nat) (exts : Array EnvExtensionState) : IO (Array EnvExtensionState) := do\n    let envExtensions \u2190 envExtensionsRef.get\n    if i < envExtensions.size then\n      let s \u2190 envExtensions[i]!.mkInitial\n      let exts := exts.push s\n      loop (i + 1) exts\n    else\n      return exts", "start": [285, 1], "end": [302, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceUnsafe.invalidExtMsg", "code": "private def invalidExtMsg := \"invalid environment extension has been accessed\"", "start": [304, 1], "end": [304, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceUnsafe.setState", "code": "unsafe def setState {\u03c3} (ext : Ext \u03c3) (exts : Array EnvExtensionState) (s : \u03c3) : Array EnvExtensionState :=\n  if h : ext.idx < exts.size then\n    exts.set \u27e8ext.idx, h\u27e9 (unsafeCast s)\n  else\n    have : Inhabited (Array EnvExtensionState) := \u27e8exts\u27e9\n    panic! invalidExtMsg", "start": [306, 1], "end": [311, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceUnsafe.modifyState", "code": "@[inline] unsafe def modifyState {\u03c3 : Type} (ext : Ext \u03c3) (exts : Array EnvExtensionState) (f : \u03c3 \u2192 \u03c3) : Array EnvExtensionState :=\n  if ext.idx < exts.size then\n    exts.modify ext.idx fun s =>\n      let s : \u03c3 := unsafeCast s\n      let s : \u03c3 := f s\n      unsafeCast s\n  else\n    have : Inhabited (Array EnvExtensionState) := \u27e8exts\u27e9\n    panic! invalidExtMsg", "start": [313, 1], "end": [321, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceUnsafe.getState", "code": "unsafe def getState {\u03c3} [Inhabited \u03c3] (ext : Ext \u03c3) (exts : Array EnvExtensionState) : \u03c3 :=\n  if h : ext.idx < exts.size then\n    let s : EnvExtensionState := exts.get \u27e8ext.idx, h\u27e9\n    unsafeCast s\n  else\n    panic! invalidExtMsg", "start": [323, 1], "end": [328, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceUnsafe.registerExt", "code": "unsafe def registerExt {\u03c3} (mkInitial : IO \u03c3) : IO (Ext \u03c3) := do\n  unless (\u2190 initializing) do\n    throw (IO.userError \"failed to register environment, extensions can only be registered during initialization\")\n  let exts \u2190 envExtensionsRef.get\n  let idx := exts.size\n  let ext : Ext \u03c3 := {\n     idx        := idx,\n     mkInitial  := mkInitial,\n  }\n  envExtensionsRef.modify fun exts => exts.push (unsafeCast ext)\n  pure ext", "start": [330, 1], "end": [340, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceUnsafe.mkInitialExtStates", "code": "def mkInitialExtStates : IO (Array EnvExtensionState) := do\n  let exts \u2190 envExtensionsRef.get\n  exts.mapM fun ext => ext.mkInitial", "start": [342, 1], "end": [344, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceUnsafe.imp", "code": "unsafe def imp : EnvExtensionInterface := {\n  ext                  := Ext\n  ensureExtensionsSize := ensureExtensionsArraySize\n  inhabitedExt         := fun _ => \u27e8default\u27e9\n  registerExt          := registerExt\n  setState             := setState\n  modifyState          := modifyState\n  getState             := getState\n  mkInitialExtStates   := mkInitialExtStates\n}", "start": [346, 1], "end": [355, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtensionInterfaceImp", "code": "@[implemented_by EnvExtensionInterfaceUnsafe.imp]\nopaque EnvExtensionInterfaceImp : EnvExtensionInterface", "start": [359, 1], "end": [360, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtension", "code": "def EnvExtension (\u03c3 : Type) : Type := EnvExtensionInterfaceImp.ext \u03c3", "start": [362, 1], "end": [362, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.ensureExtensionsArraySize", "code": "private def ensureExtensionsArraySize (env : Environment) : IO Environment := do\n  let exts \u2190 EnvExtensionInterfaceImp.ensureExtensionsSize env.extensions\n  return { env with extensions := exts }", "start": [364, 1], "end": [366, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtension.setState", "code": "def setState {\u03c3 : Type} (ext : EnvExtension \u03c3) (env : Environment) (s : \u03c3) : Environment :=\n  { env with extensions := EnvExtensionInterfaceImp.setState ext env.extensions s }", "start": [371, 1], "end": [372, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtension.modifyState", "code": "def modifyState {\u03c3 : Type} (ext : EnvExtension \u03c3) (env : Environment) (f : \u03c3 \u2192 \u03c3) : Environment :=\n  { env with extensions := EnvExtensionInterfaceImp.modifyState ext env.extensions f }", "start": [374, 1], "end": [375, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.EnvExtension.getState", "code": "def getState {\u03c3 : Type} [Inhabited \u03c3] (ext : EnvExtension \u03c3) (env : Environment) : \u03c3 :=\n  EnvExtensionInterfaceImp.getState ext env.extensions", "start": [377, 1], "end": [378, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.registerEnvExtension", "code": "def registerEnvExtension {\u03c3 : Type} (mkInitial : IO \u03c3) : IO (EnvExtension \u03c3) := EnvExtensionInterfaceImp.registerExt mkInitial", "start": [382, 1], "end": [389, 127], "kind": "commanddeclaration"}, {"full_name": "Lean.mkInitialExtensionStates", "code": "private def mkInitialExtensionStates : IO (Array EnvExtensionState) := EnvExtensionInterfaceImp.mkInitialExtStates", "start": [390, 1], "end": [390, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.mkEmptyEnvironment", "code": "@[export lean_mk_empty_environment]\ndef mkEmptyEnvironment (trustLevel : UInt32 := 0) : IO Environment := do\n  let initializing \u2190 IO.initializing\n  if initializing then throw (IO.userError \"environment objects cannot be created during initialization\")\n  let exts \u2190 mkInitialExtensionStates\n  pure {\n    const2ModIdx    := {}\n    constants       := {}\n    header          := { trustLevel := trustLevel }\n    extraConstNames := {}\n    extensions      := exts\n  }", "start": [392, 1], "end": [403, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentEnvExtensionState", "code": "structure PersistentEnvExtensionState (\u03b1 : Type) (\u03c3 : Type) where\n  importedEntries : Array (Array \u03b1)  state : \u03c3", "start": [405, 1], "end": [407, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.ImportM.Context", "code": "structure ImportM.Context where\n  env  : Environment\n  opts : Options", "start": [409, 1], "end": [411, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.ImportM", "code": "abbrev ImportM := ReaderT Lean.ImportM.Context IO", "start": [413, 1], "end": [413, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentEnvExtension", "code": "structure PersistentEnvExtension (\u03b1 : Type) (\u03b2 : Type) (\u03c3 : Type) where\n  toEnvExtension  : EnvExtension (PersistentEnvExtensionState \u03b1 \u03c3)\n  name            : Name\n  addImportedFn   : Array (Array \u03b1) \u2192 ImportM \u03c3\n  addEntryFn      : \u03c3 \u2192 \u03b2 \u2192 \u03c3\n  exportEntriesFn : \u03c3 \u2192 Array \u03b1\n  statsFn         : \u03c3 \u2192 Format", "start": [415, 1], "end": [437, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentEnvExtension.getModuleEntries", "code": "def getModuleEntries {\u03b1 \u03b2 \u03c3 : Type} [Inhabited \u03c3] (ext : PersistentEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) (m : ModuleIdx) : Array \u03b1 :=\n  (ext.toEnvExtension.getState env).importedEntries.get! m", "start": [454, 1], "end": [455, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentEnvExtension.addEntry", "code": "def addEntry {\u03b1 \u03b2 \u03c3 : Type} (ext : PersistentEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) (b : \u03b2) : Environment :=\n  ext.toEnvExtension.modifyState env fun s =>\n    let state   := ext.addEntryFn s.state b;\n    { s with state := state }", "start": [457, 1], "end": [460, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentEnvExtension.getState", "code": "def getState {\u03b1 \u03b2 \u03c3 : Type} [Inhabited \u03c3] (ext : PersistentEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) : \u03c3 :=\n  (ext.toEnvExtension.getState env).state", "start": [462, 1], "end": [464, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentEnvExtension.setState", "code": "def setState {\u03b1 \u03b2 \u03c3 : Type} (ext : PersistentEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) (s : \u03c3) : Environment :=\n  ext.toEnvExtension.modifyState env fun ps => { ps with  state := s }", "start": [466, 1], "end": [468, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentEnvExtension.modifyState", "code": "def modifyState {\u03b1 \u03b2 \u03c3 : Type} (ext : PersistentEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) (f : \u03c3 \u2192 \u03c3) : Environment :=\n  ext.toEnvExtension.modifyState env fun ps => { ps with state := f (ps.state) }", "start": [470, 1], "end": [472, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.PersistentEnvExtensionDescr", "code": "structure PersistentEnvExtensionDescr (\u03b1 \u03b2 \u03c3 : Type) where\n  name            : Name := by exact decl_name%\n  mkInitial       : IO \u03c3\n  addImportedFn   : Array (Array \u03b1) \u2192 ImportM \u03c3\n  addEntryFn      : \u03c3 \u2192 \u03b2 \u2192 \u03c3\n  exportEntriesFn : \u03c3 \u2192 Array \u03b1\n  statsFn         : \u03c3 \u2192 Format := fun _ => Format.nil", "start": [478, 1], "end": [484, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.registerPersistentEnvExtensionUnsafe", "code": "unsafe def registerPersistentEnvExtensionUnsafe {\u03b1 \u03b2 \u03c3 : Type} [Inhabited \u03c3] (descr : PersistentEnvExtensionDescr \u03b1 \u03b2 \u03c3) : IO (PersistentEnvExtension \u03b1 \u03b2 \u03c3) := do\n  let pExts \u2190 persistentEnvExtensionsRef.get\n  if pExts.any (fun ext => ext.name == descr.name) then throw (IO.userError s!\"invalid environment extension, '{descr.name}' has already been used\")\n  let ext \u2190 registerEnvExtension do\n    let initial \u2190 descr.mkInitial\n    let s : PersistentEnvExtensionState \u03b1 \u03c3 := {\n      importedEntries := #[],\n      state           := initial\n    }\n    pure s\n  let pExt : PersistentEnvExtension \u03b1 \u03b2 \u03c3 := {\n    toEnvExtension  := ext,\n    name            := descr.name,\n    addImportedFn   := descr.addImportedFn,\n    addEntryFn      := descr.addEntryFn,\n    exportEntriesFn := descr.exportEntriesFn,\n    statsFn         := descr.statsFn\n  }\n  persistentEnvExtensionsRef.modify fun pExts => pExts.push (unsafeCast pExt)\n  return pExt", "start": [486, 1], "end": [505, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.registerPersistentEnvExtension", "code": "@[implemented_by registerPersistentEnvExtensionUnsafe]\nopaque registerPersistentEnvExtension {\u03b1 \u03b2 \u03c3 : Type} [Inhabited \u03c3] (descr : PersistentEnvExtensionDescr \u03b1 \u03b2 \u03c3) : IO (PersistentEnvExtension \u03b1 \u03b2 \u03c3)", "start": [507, 1], "end": [508, 147], "kind": "commanddeclaration"}, {"full_name": "Lean.SimplePersistentEnvExtension", "code": "def SimplePersistentEnvExtension (\u03b1 \u03c3 : Type) := PersistentEnvExtension \u03b1 \u03b1 (List \u03b1 \u00d7 \u03c3)", "start": [510, 1], "end": [511, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.mkStateFromImportedEntries", "code": "@[specialize] def mkStateFromImportedEntries {\u03b1 \u03c3 : Type} (addEntryFn : \u03c3 \u2192 \u03b1 \u2192 \u03c3) (initState : \u03c3) (as : Array (Array \u03b1)) : \u03c3 :=\n  as.foldl (fun r es => es.foldl (fun r e => addEntryFn r e) r) initState", "start": [513, 1], "end": [514, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.SimplePersistentEnvExtensionDescr", "code": "structure SimplePersistentEnvExtensionDescr (\u03b1 \u03c3 : Type) where\n  name          : Name := by exact decl_name%\n  addEntryFn    : \u03c3 \u2192 \u03b1 \u2192 \u03c3\n  addImportedFn : Array (Array \u03b1) \u2192 \u03c3\n  toArrayFn     : List \u03b1 \u2192 Array \u03b1 := fun es => es.toArray", "start": [516, 1], "end": [520, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.registerSimplePersistentEnvExtension", "code": "def registerSimplePersistentEnvExtension {\u03b1 \u03c3 : Type} [Inhabited \u03c3] (descr : SimplePersistentEnvExtensionDescr \u03b1 \u03c3) : IO (SimplePersistentEnvExtension \u03b1 \u03c3) :=\n  registerPersistentEnvExtension {\n    name            := descr.name,\n    mkInitial       := pure ([], descr.addImportedFn #[]),\n    addImportedFn   := fun as => pure ([], descr.addImportedFn as),\n    addEntryFn      := fun s e => match s with\n      | (entries, s) => (e::entries, descr.addEntryFn s e),\n    exportEntriesFn := fun s => descr.toArrayFn s.1.reverse,\n    statsFn := fun s => format \"number of local entries: \" ++ format s.1.length\n  }", "start": [522, 1], "end": [531, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.SimplePersistentEnvExtension.getEntries", "code": "def getEntries {\u03b1 \u03c3 : Type} [Inhabited \u03c3] (ext : SimplePersistentEnvExtension \u03b1 \u03c3) (env : Environment) : List \u03b1 :=\n  (PersistentEnvExtension.getState ext env).1", "start": [538, 1], "end": [541, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.SimplePersistentEnvExtension.getState", "code": "def getState {\u03b1 \u03c3 : Type} [Inhabited \u03c3] (ext : SimplePersistentEnvExtension \u03b1 \u03c3) (env : Environment) : \u03c3 :=\n  (PersistentEnvExtension.getState ext env).2", "start": [543, 1], "end": [545, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.SimplePersistentEnvExtension.setState", "code": "def setState {\u03b1 \u03c3 : Type} (ext : SimplePersistentEnvExtension \u03b1 \u03c3) (env : Environment) (s : \u03c3) : Environment :=\n  PersistentEnvExtension.modifyState ext env (fun \u27e8entries, _\u27e9 => (entries, s))", "start": [547, 1], "end": [549, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.SimplePersistentEnvExtension.modifyState", "code": "def modifyState {\u03b1 \u03c3 : Type} (ext : SimplePersistentEnvExtension \u03b1 \u03c3) (env : Environment) (f : \u03c3 \u2192 \u03c3) : Environment :=\n  PersistentEnvExtension.modifyState ext env (fun \u27e8entries, s\u27e9 => (entries, f s))", "start": [551, 1], "end": [553, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.TagDeclarationExtension", "code": "def TagDeclarationExtension := SimplePersistentEnvExtension Name NameSet", "start": [557, 1], "end": [559, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.mkTagDeclarationExtension", "code": "def mkTagDeclarationExtension (name : Name := by exact decl_name%) : IO TagDeclarationExtension :=\n  registerSimplePersistentEnvExtension {\n    name          := name,\n    addImportedFn := fun _ => {},\n    addEntryFn    := fun s n => s.insert n,\n    toArrayFn     := fun es => es.toArray.qsort Name.quickLt\n  }", "start": [561, 1], "end": [567, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.TagDeclarationExtension.tag", "code": "def tag (ext : TagDeclarationExtension) (env : Environment) (declName : Name) : Environment :=\n  have : Inhabited Environment := \u27e8env\u27e9\n  assert! env.getModuleIdxFor? declName |>.isNone ext.addEntry env declName", "start": [574, 1], "end": [577, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.TagDeclarationExtension.isTagged", "code": "def isTagged (ext : TagDeclarationExtension) (env : Environment) (declName : Name) : Bool :=\n  match env.getModuleIdxFor? declName with\n  | some modIdx => (ext.getModuleEntries env modIdx).binSearchContains declName Name.quickLt\n  | none        => (ext.getState env).contains declName", "start": [579, 1], "end": [582, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.MapDeclarationExtension", "code": "def MapDeclarationExtension (\u03b1 : Type) := SimplePersistentEnvExtension (Name \u00d7 \u03b1) (NameMap \u03b1)", "start": [586, 1], "end": [589, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.mkMapDeclarationExtension", "code": "def mkMapDeclarationExtension [Inhabited \u03b1] (name : Name := by exact decl_name%) : IO (MapDeclarationExtension \u03b1) :=\n  registerSimplePersistentEnvExtension {\n    name          := name,\n    addImportedFn := fun _ => {},\n    addEntryFn    := fun s n => s.insert n.1 n.2 ,\n    toArrayFn     := fun es => es.toArray.qsort (fun a b => Name.quickLt a.1 b.1)\n  }", "start": [591, 1], "end": [597, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.MapDeclarationExtension.insert", "code": "def insert (ext : MapDeclarationExtension \u03b1) (env : Environment) (declName : Name) (val : \u03b1) : Environment :=\n  have : Inhabited Environment := \u27e8env\u27e9\n  assert! env.getModuleIdxFor? declName |>.isNone ext.addEntry env (declName, val)", "start": [604, 1], "end": [607, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.MapDeclarationExtension.find?", "code": "def find? [Inhabited \u03b1] (ext : MapDeclarationExtension \u03b1) (env : Environment) (declName : Name) : Option \u03b1 :=\n  match env.getModuleIdxFor? declName with\n  | some modIdx =>\n    match (ext.getModuleEntries env modIdx).binSearch (declName, default) (fun a b => Name.quickLt a.1 b.1) with\n    | some e => some e.2\n    | none   => none\n  | none => (ext.getState env).find? declName", "start": [609, 1], "end": [615, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.MapDeclarationExtension.contains", "code": "def contains [Inhabited \u03b1] (ext : MapDeclarationExtension \u03b1) (env : Environment) (declName : Name) : Bool :=\n  match env.getModuleIdxFor? declName with\n  | some modIdx => (ext.getModuleEntries env modIdx).binSearchContains (declName, default) (fun a b => Name.quickLt a.1 b.1)\n  | none        => (ext.getState env).contains declName", "start": [617, 1], "end": [620, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.saveModuleData", "code": "@[extern \"lean_save_module_data\"]\nopaque saveModuleData (fname : @& System.FilePath) (mod : @& Name) (data : @& ModuleData) : IO Unit", "start": [624, 1], "end": [625, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.readModuleData", "code": "@[extern \"lean_read_module_data\"]\nopaque readModuleData (fname : @& System.FilePath) : IO (ModuleData \u00d7 CompactedRegion)", "start": [626, 1], "end": [627, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.freeRegions", "code": "@[noinline, export lean_environment_free_regions]\nunsafe def Environment.freeRegions (env : Environment) : IO Unit :=\n  \n  env.header.regions.forM CompactedRegion.free", "start": [629, 1], "end": [649, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.mkModuleData", "code": "def mkModuleData (env : Environment) : IO ModuleData := do\n  let pExts \u2190 persistentEnvExtensionsRef.get\n  let entries := pExts.map fun pExt =>\n    let state := pExt.getState env\n    (pExt.name, pExt.exportEntriesFn state)\n  let constNames := env.constants.foldStage2 (fun names name _ => names.push name) #[]\n  let constants  := env.constants.foldStage2 (fun cs _ c => cs.push c) #[]\n  return {\n    imports         := env.header.imports\n    extraConstNames := env.extraConstNames.toArray\n    constNames, constants, entries\n  }", "start": [651, 1], "end": [662, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.writeModule", "code": "@[export lean_write_module]\ndef writeModule (env : Environment) (fname : System.FilePath) : IO Unit := do\n  saveModuleData fname env.mainModule (\u2190 mkModuleData env)", "start": [664, 1], "end": [666, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.mkExtNameMap", "code": "def mkExtNameMap (startingAt : Nat) : IO (HashMap Name Nat) := do\n  let descrs \u2190 persistentEnvExtensionsRef.get\n  let mut result := {}\n  for h : i in [startingAt : descrs.size] do\n    have : i < descrs.size := h.upper\n    let descr := descrs[i]\n    result := result.insert descr.name i\n  return result", "start": [668, 1], "end": [679, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.setImportedEntries", "code": "private def setImportedEntries (env : Environment) (mods : Array ModuleData) (startingAt : Nat := 0) : IO Environment := do\n  let mut env := env\n  let extDescrs \u2190 persistentEnvExtensionsRef.get\n  \n  for extDescr in extDescrs[startingAt:] do\n    env := extDescr.toEnvExtension.modifyState env fun s => { s with importedEntries := mkArray mods.size #[] }\n  \n  let extNameIdx \u2190 mkExtNameMap startingAt\n  for h : modIdx in [:mods.size] do\n    have : modIdx < mods.size := h.upper\n    let mod := mods[modIdx]\n    for (extName, entries) in mod.entries do\n      if let some entryIdx := extNameIdx.find? extName then\n        env := extDescrs[entryIdx]!.toEnvExtension.modifyState env fun s => { s with importedEntries := s.importedEntries.set! modIdx entries }\n  return env", "start": [681, 1], "end": [695, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.updateEnvAttributes", "code": "@[extern 2 \"lean_update_env_attributes\"] opaque updateEnvAttributes : Environment \u2192 IO Environment", "start": [697, 1], "end": [706, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.getNumBuiltinAttributes", "code": "@[extern 1 \"lean_get_num_attributes\"] opaque getNumBuiltinAttributes : IO Nat", "start": [707, 1], "end": [708, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.finalizePersistentExtensions", "code": "private partial def finalizePersistentExtensions (env : Environment) (mods : Array ModuleData) (opts : Options) : IO Environment := do\n  loop 0 env\nwhere\n  loop (i : Nat) (env : Environment) : IO Environment := do\n    let pExtDescrs \u2190 persistentEnvExtensionsRef.get\n    if i < pExtDescrs.size then\n      let extDescr := pExtDescrs[i]!\n      let s := extDescr.toEnvExtension.getState env\n      let prevSize := (\u2190 persistentEnvExtensionsRef.get).size\n      let prevAttrSize \u2190 getNumBuiltinAttributes\n      let newState \u2190 extDescr.addImportedFn s.importedEntries { env := env, opts := opts }\n      let mut env := extDescr.toEnvExtension.setState env { s with state := newState }\n      env \u2190 ensureExtensionsArraySize env\n      if (\u2190 persistentEnvExtensionsRef.get).size > prevSize || (\u2190 getNumBuiltinAttributes) > prevAttrSize then\n        env \u2190 setImportedEntries env mods prevSize\n        env \u2190 updateEnvAttributes env\n      loop (i + 1) env\n    else\n      return env", "start": [710, 1], "end": [733, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.ImportState", "code": "structure ImportState where\n  moduleNameSet : NameHashSet := {}\n  moduleNames   : Array Name := #[]\n  moduleData    : Array ModuleData := #[]\n  regions       : Array CompactedRegion := #[]", "start": [735, 1], "end": [739, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.throwAlreadyImported", "code": "def throwAlreadyImported (s : ImportState) (const2ModIdx : HashMap Name ModuleIdx) (modIdx : Nat) (cname : Name) : IO \u03b1 := do\n  let modName := s.moduleNames[modIdx]!\n  let constModName := s.moduleNames[const2ModIdx[cname].get!.toNat]!\n  throw <| IO.userError s!\"import {modName} failed, environment already contains '{cname}' from {constModName}\"", "start": [741, 1], "end": [744, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.ImportStateM", "code": "abbrev ImportStateM := StateRefT ImportState IO", "start": [746, 1], "end": [746, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.ImportStateM.run", "code": "@[inline] nonrec def ImportStateM.run (x : ImportStateM \u03b1) (s : ImportState := {}) : IO (\u03b1 \u00d7 ImportState) :=\n  x.run s", "start": [748, 1], "end": [749, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.importModulesCore", "code": "partial def importModulesCore (imports : Array Import) : ImportStateM Unit := do\n  for i in imports do\n    if i.runtimeOnly || (\u2190 get).moduleNameSet.contains i.module then\n      continue\n    modify fun s => { s with moduleNameSet := s.moduleNameSet.insert i.module }\n    let mFile \u2190 findOLean i.module\n    unless (\u2190 mFile.pathExists) do\n      throw <| IO.userError s!\"object file '{mFile}' of module {i.module} does not exist\"\n    let (mod, region) \u2190 readModuleData mFile\n    importModulesCore mod.imports\n    modify fun s => { s with\n      moduleData  := s.moduleData.push mod\n      regions     := s.regions.push region\n      moduleNames := s.moduleNames.push i.module\n    }", "start": [751, 1], "end": [765, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.finalizeImport", "code": "def finalizeImport (s : ImportState) (imports : Array Import) (opts : Options) (trustLevel : UInt32 := 0) : IO Environment := do\n  let numConsts := s.moduleData.foldl (init := 0) fun numConsts mod =>\n    numConsts + mod.constants.size + mod.extraConstNames.size\n  let mut const2ModIdx : HashMap Name ModuleIdx := mkHashMap (capacity := numConsts)\n  let mut constantMap : HashMap Name ConstantInfo := mkHashMap (capacity := numConsts)\n  for h:modIdx in [0:s.moduleData.size] do\n    let mod := s.moduleData[modIdx]'h.upper\n    for cname in mod.constNames, cinfo in mod.constants do\n      match constantMap.insert' cname cinfo with\n      | (constantMap', replaced) =>\n        constantMap := constantMap'\n        if replaced then\n          throwAlreadyImported s const2ModIdx modIdx cname\n      const2ModIdx := const2ModIdx.insert cname modIdx\n    for cname in mod.extraConstNames do\n      const2ModIdx := const2ModIdx.insert cname modIdx\n  let constants : ConstMap := SMap.fromHashMap constantMap false\n  let exts \u2190 mkInitialExtensionStates\n  let env : Environment := {\n    const2ModIdx    := const2ModIdx\n    constants       := constants\n    extraConstNames := {}\n    extensions      := exts\n    header          := {\n      quotInit     := !imports.isEmpty trustLevel   := trustLevel\n      imports      := imports\n      regions      := s.regions\n      moduleNames  := s.moduleNames\n      moduleData   := s.moduleData\n    }\n  }\n  let env \u2190 setImportedEntries env s.moduleData\n  let env \u2190 finalizePersistentExtensions env s.moduleData opts\n  pure env", "start": [767, 1], "end": [801, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.importModules", "code": "@[export lean_import_modules]\ndef importModules (imports : Array Import) (opts : Options) (trustLevel : UInt32 := 0) : IO Environment := profileitIO \"import\" opts do\n  for imp in imports do\n    if imp.module matches .anonymous then\n      throw <| IO.userError \"import failed, trying to import module with anonymous name\"\n  withImporting do\n    let (_, s) \u2190 importModulesCore imports |>.run\n    finalizeImport s imports opts trustLevel", "start": [803, 1], "end": [810, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.withImportModules", "code": "unsafe def withImportModules {\u03b1 : Type} (imports : Array Import) (opts : Options) (trustLevel : UInt32 := 0) (act : Environment \u2192 IO \u03b1) : IO \u03b1 := do\n  let env \u2190 importModules imports opts trustLevel\n  try act env finally env.freeRegions", "start": [812, 1], "end": [817, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.registerNamespace", "code": "def registerNamespace (env : Environment) (n : Name) : Environment :=\n  if (namespacesExt.getState env).contains n then env else namespacesExt.addEntry env n", "start": [839, 1], "end": [841, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.isNamespace", "code": "def isNamespace (env : Environment) (n : Name) : Bool :=\n  (namespacesExt.getState env).contains n", "start": [843, 1], "end": [845, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.getNamespaceSet", "code": "def getNamespaceSet (env : Environment) : NameSSet :=\n  namespacesExt.getState env", "start": [847, 1], "end": [849, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.isNamespaceName", "code": "private def isNamespaceName : Name \u2192 Bool\n  | .str .anonymous _ => true\n  | .str p _          => isNamespaceName p\n  | _                 => false", "start": [851, 1], "end": [854, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.registerNamePrefixes", "code": "private def registerNamePrefixes : Environment \u2192 Name \u2192 Environment\n  | env, .str p _ => if isNamespaceName p then registerNamePrefixes (registerNamespace env p) p else env\n  | env, _        => env", "start": [856, 1], "end": [858, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.add", "code": "@[export lean_environment_add]\nprivate def add (env : Environment) (cinfo : ConstantInfo) : Environment :=\n  let env := registerNamePrefixes env cinfo.name\n  env.addAux cinfo", "start": [860, 1], "end": [863, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.displayStats", "code": "@[export lean_display_stats]\ndef displayStats (env : Environment) : IO Unit := do\n  let pExtDescrs \u2190 persistentEnvExtensionsRef.get\n  IO.println (\"direct imports:                        \" ++ toString env.header.imports);\n  IO.println (\"number of imported modules:            \" ++ toString env.header.regions.size);\n  IO.println (\"number of memory-mapped modules:       \" ++ toString (env.header.regions.filter (\u00b7.isMemoryMapped) |>.size));\n  IO.println (\"number of consts:                      \" ++ toString env.constants.size);\n  IO.println (\"number of imported consts:             \" ++ toString env.constants.stageSizes.1);\n  IO.println (\"number of local consts:                \" ++ toString env.constants.stageSizes.2);\n  IO.println (\"number of buckets for imported consts: \" ++ toString env.constants.numBuckets);\n  IO.println (\"trust level:                           \" ++ toString env.header.trustLevel);\n  IO.println (\"number of extensions:                  \" ++ toString env.extensions.size);\n  pExtDescrs.forM fun extDescr => do\n    IO.println (\"extension '\" ++ toString extDescr.name ++ \"'\")\n    let s := extDescr.toEnvExtension.getState env\n    let fmt := extDescr.statsFn s.state\n    unless fmt.isNil do IO.println (\"  \" ++ toString (Format.nest 2 (extDescr.statsFn s.state)))\n    IO.println (\"  number of imported entries: \" ++ toString (s.importedEntries.foldl (fun sum es => sum + es.size) 0))", "start": [865, 1], "end": [882, 120], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.evalConst", "code": "@[extern \"lean_eval_const\"]\nunsafe opaque evalConst (\u03b1) (env : @& Environment) (opts : @& Options) (constName : @& Name) : Except String \u03b1", "start": [884, 1], "end": [889, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.throwUnexpectedType", "code": "private def throwUnexpectedType {\u03b1} (typeName : Name) (constName : Name) : ExceptT String Id \u03b1 :=\n  throw (\"unexpected type at '\" ++ toString constName ++ \"', `\" ++ toString typeName ++ \"` expected\")", "start": [891, 1], "end": [892, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.evalConstCheck", "code": "unsafe def evalConstCheck (\u03b1) (env : Environment) (opts : Options) (typeName : Name) (constName : Name) : ExceptT String Id \u03b1 :=\n  match env.find? constName with\n  | none      => throw (\"unknown constant '\" ++ toString constName ++ \"'\")\n  | some info =>\n    match info.type with\n    | Expr.const c _ =>\n      if c != typeName then throwUnexpectedType typeName constName\n      else env.evalConst \u03b1 opts constName\n    | _ => throwUnexpectedType typeName constName", "start": [894, 1], "end": [904, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.hasUnsafe", "code": "def hasUnsafe (env : Environment) (e : Expr) : Bool :=\n  let c? := e.find? fun e => match e with\n    | Expr.const c _ =>\n      match env.find? c with\n      | some cinfo => cinfo.isUnsafe\n      | none       => false\n    | _ => false;\n  c?.isSome", "start": [906, 1], "end": [913, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Kernel.isDefEq", "code": "@[extern \"lean_kernel_is_def_eq\"]\nopaque isDefEq (env : Environment) (lctx : LocalContext) (a b : Expr) : Except KernelException Bool", "start": [920, 1], "end": [925, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Kernel.isDefEqGuarded", "code": "def isDefEqGuarded (env : Environment) (lctx : LocalContext) (a b : Expr) : Bool :=\n  if let .ok result := isDefEq env lctx a b then result else false", "start": [927, 1], "end": [928, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Kernel.whnf", "code": "@[extern \"lean_kernel_whnf\"]\nopaque whnf (env : Environment) (lctx : LocalContext) (a : Expr) : Except KernelException Expr", "start": [930, 1], "end": [935, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadEnv", "code": "class MonadEnv (m : Type \u2192 Type) where\n  getEnv    : m Environment\n  modifyEnv : (Environment \u2192 Environment) \u2192 m Unit", "start": [939, 1], "end": [941, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/MetavarContext.lean", "imports": ["lake-packages/lean4/src/lean/Lean/LocalContext.lean", "lake-packages/lean4/src/lean/Lean/Util/MonadCache.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LocalInstance", "code": "structure LocalInstance where\n  className : Name\n  fvar      : Expr\n  deriving Inhabited", "start": [221, 1], "end": [230, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalInstances", "code": "abbrev LocalInstances := Array LocalInstance", "start": [232, 1], "end": [232, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalInstances.erase", "code": "def LocalInstances.erase (localInsts : LocalInstances) (fvarId : FVarId) : LocalInstances :=\n  match localInsts.findIdx? (fun inst => inst.fvar.fvarId! == fvarId) with\n  | some idx => localInsts.eraseIdx idx\n  | _        => localInsts", "start": [240, 1], "end": [244, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarKind", "code": "inductive MetavarKind where\n  \n  | natural\n  \n  | synthetic\n  \n  | syntheticOpaque\n  deriving Inhabited, Repr", "start": [246, 1], "end": [255, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarKind.isSyntheticOpaque", "code": "def MetavarKind.isSyntheticOpaque : MetavarKind \u2192 Bool\n  | MetavarKind.syntheticOpaque => true\n  | _                           => false", "start": [257, 1], "end": [259, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarKind.isNatural", "code": "def MetavarKind.isNatural : MetavarKind \u2192 Bool\n  | MetavarKind.natural => true\n  | _                   => false", "start": [261, 1], "end": [263, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarDecl", "code": "structure MetavarDecl where\n  \n  userName       : Name := Name.anonymous\n  \n  lctx           : LocalContext\n  \n  type           : Expr\n  \n  depth          : Nat\n  localInstances : LocalInstances\n  kind           : MetavarKind\n  \n  numScopeArgs   : Nat := 0\n  \n  index          : Nat\n  deriving Inhabited", "start": [265, 1], "end": [287, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.DelayedMetavarAssignment", "code": "structure DelayedMetavarAssignment where\n  fvars         : Array Expr\n  mvarIdPending : MVarId", "start": [289, 1], "end": [305, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext", "code": "structure MetavarContext where\n  \n  depth          : Nat := 0\n  \n  levelAssignDepth : Nat := 0\n  \n  mvarCounter    : Nat := 0\n  lDepth         : PersistentHashMap LMVarId Nat := {}\n  \n  decls          : PersistentHashMap MVarId MetavarDecl := {}\n  \n  userNames      : PersistentHashMap Name MVarId := {}\n  \n  lAssignment    : PersistentHashMap LMVarId Level := {}\n  \n  eAssignment    : PersistentHashMap MVarId Expr := {}\n  \n  dAssignment    : PersistentHashMap MVarId DelayedMetavarAssignment := {}", "start": [307, 1], "end": [329, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadMCtx", "code": "class MonadMCtx (m : Type \u2192 Type) where\n  getMCtx    : m MetavarContext\n  modifyMCtx : (MetavarContext \u2192 MetavarContext) \u2192 m Unit", "start": [331, 1], "end": [334, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.setMCtx", "code": "abbrev setMCtx [MonadMCtx m] (mctx : MetavarContext) : m Unit :=\n  modifyMCtx fun _ => mctx", "start": [343, 1], "end": [344, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.getLevelMVarAssignment?", "code": "abbrev getLevelMVarAssignment? [Monad m] [MonadMCtx m] (mvarId : LMVarId) : m (Option Level) :=\n  return (\u2190 getMCtx).lAssignment.find? mvarId", "start": [346, 1], "end": [347, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.getExprAssignmentCore?", "code": "def MetavarContext.getExprAssignmentCore? (m : MetavarContext) (mvarId : MVarId) : Option Expr :=\n  m.eAssignment.find? mvarId", "start": [349, 1], "end": [350, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.getExprMVarAssignment?", "code": "def getExprMVarAssignment? [Monad m] [MonadMCtx m] (mvarId : MVarId) : m (Option Expr) :=\n  return (\u2190 getMCtx).getExprAssignmentCore? mvarId", "start": [352, 1], "end": [353, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.getDelayedMVarAssignment?", "code": "def getDelayedMVarAssignment? [Monad m] [MonadMCtx m] (mvarId : MVarId) : m (Option DelayedMetavarAssignment) :=\n  return (\u2190 getMCtx).dAssignment.find? mvarId", "start": [355, 1], "end": [356, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.getDelayedMVarRoot", "code": "partial def getDelayedMVarRoot [Monad m] [MonadMCtx m] (mvarId : MVarId) : m MVarId := do\n  match (\u2190 getDelayedMVarAssignment? mvarId) with\n  | some d => getDelayedMVarRoot d.mvarIdPending\n  | none   => return mvarId", "start": [358, 1], "end": [369, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.isLevelMVarAssigned", "code": "def isLevelMVarAssigned [Monad m] [MonadMCtx m] (mvarId : LMVarId) : m Bool :=\n  return (\u2190 getMCtx).lAssignment.contains mvarId", "start": [371, 1], "end": [372, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.isAssigned", "code": "def _root_.Lean.MVarId.isAssigned [Monad m] [MonadMCtx m] (mvarId : MVarId) : m Bool :=\n  return (\u2190 getMCtx).eAssignment.contains mvarId", "start": [374, 1], "end": [376, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.isExprMVarAssigned", "code": "@[deprecated MVarId.isAssigned]\ndef isExprMVarAssigned [Monad m] [MonadMCtx m] (mvarId : MVarId) : m Bool := do\n  mvarId.isAssigned", "start": [378, 1], "end": [380, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.isDelayedAssigned", "code": "def _root_.Lean.MVarId.isDelayedAssigned [Monad m] [MonadMCtx m] (mvarId : MVarId) : m Bool :=\n  return (\u2190 getMCtx).dAssignment.contains mvarId", "start": [382, 1], "end": [383, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.isMVarDelayedAssigned", "code": "@[deprecated MVarId.isDelayedAssigned]\ndef isMVarDelayedAssigned [Monad m] [MonadMCtx m] (mvarId : MVarId) : m Bool := do\n  mvarId.isDelayedAssigned", "start": [385, 1], "end": [387, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.isLevelMVarAssignable", "code": "def isLevelMVarAssignable [Monad m] [MonadMCtx m] (mvarId : LMVarId) : m Bool := do\n  let mctx \u2190 getMCtx\n  match mctx.lDepth.find? mvarId with\n  | some d => return d >= mctx.levelAssignDepth\n  | _      => panic! \"unknown universe metavariable\"", "start": [389, 1], "end": [393, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.getDecl", "code": "def MetavarContext.getDecl (mctx : MetavarContext) (mvarId : MVarId) : MetavarDecl :=\n  match mctx.decls.find? mvarId with\n  | some decl => decl\n  | none      => panic! \"unknown metavariable\"", "start": [395, 1], "end": [398, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.isAssignable", "code": "def _root_.Lean.MVarId.isAssignable [Monad m] [MonadMCtx m] (mvarId : MVarId) : m Bool := do\n  let mctx \u2190 getMCtx\n  let decl := mctx.getDecl mvarId\n  return decl.depth == mctx.depth", "start": [400, 1], "end": [403, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.isExprMVarAssignable", "code": "@[deprecated MVarId.isAssignable]\ndef isExprMVarAssignable [Monad m] [MonadMCtx m] (mvarId : MVarId) : m Bool := do\n  mvarId.isAssignable", "start": [405, 1], "end": [407, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.hasAssignedLevelMVar", "code": "def hasAssignedLevelMVar [Monad m] [MonadMCtx m] : Level \u2192 m Bool\n  | .succ lvl       => pure lvl.hasMVar <&&> hasAssignedLevelMVar lvl\n  | .max lvl\u2081 lvl\u2082  => (pure lvl\u2081.hasMVar <&&> hasAssignedLevelMVar lvl\u2081) <||> (pure lvl\u2082.hasMVar <&&> hasAssignedLevelMVar lvl\u2082)\n  | .imax lvl\u2081 lvl\u2082 => (pure lvl\u2081.hasMVar <&&> hasAssignedLevelMVar lvl\u2081) <||> (pure lvl\u2082.hasMVar <&&> hasAssignedLevelMVar lvl\u2082)\n  | .mvar mvarId    => isLevelMVarAssigned mvarId\n  | .zero           => pure false\n  | .param _        => pure false", "start": [409, 1], "end": [416, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.hasAssignedMVar", "code": "def hasAssignedMVar [Monad m] [MonadMCtx m] : Expr \u2192 m Bool\n  | .const _ lvls    => lvls.anyM hasAssignedLevelMVar\n  | .sort lvl        => hasAssignedLevelMVar lvl\n  | .app f a         => (pure f.hasMVar <&&> hasAssignedMVar f) <||> (pure a.hasMVar <&&> hasAssignedMVar a)\n  | .letE _ t v b _  => (pure t.hasMVar <&&> hasAssignedMVar t) <||> (pure v.hasMVar <&&> hasAssignedMVar v) <||> (pure b.hasMVar <&&> hasAssignedMVar b)\n  | .forallE _ d b _ => (pure d.hasMVar <&&> hasAssignedMVar d) <||> (pure b.hasMVar <&&> hasAssignedMVar b)\n  | .lam _ d b _     => (pure d.hasMVar <&&> hasAssignedMVar d) <||> (pure b.hasMVar <&&> hasAssignedMVar b)\n  | .fvar _          => return false\n  | .bvar _          => return false\n  | .lit _           => return false\n  | .mdata _ e       => pure e.hasMVar <&&> hasAssignedMVar e\n  | .proj _ _ e      => pure e.hasMVar <&&> hasAssignedMVar e\n  | .mvar mvarId     => mvarId.isAssigned <||> mvarId.isDelayedAssigned", "start": [418, 1], "end": [431, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.hasAssignableLevelMVar", "code": "def hasAssignableLevelMVar [Monad m] [MonadMCtx m] : Level \u2192 m Bool\n  | .succ lvl       => pure lvl.hasMVar <&&> hasAssignableLevelMVar lvl\n  | .max lvl\u2081 lvl\u2082  => (pure lvl\u2081.hasMVar <&&> hasAssignableLevelMVar lvl\u2081) <||> (pure lvl\u2082.hasMVar <&&> hasAssignableLevelMVar lvl\u2082)\n  | .imax lvl\u2081 lvl\u2082 => (pure lvl\u2081.hasMVar <&&> hasAssignableLevelMVar lvl\u2081) <||> (pure lvl\u2082.hasMVar <&&> hasAssignableLevelMVar lvl\u2082)\n  | .mvar mvarId    => isLevelMVarAssignable mvarId\n  | .zero           => return false\n  | .param _        => return false", "start": [433, 1], "end": [440, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.hasAssignableMVar", "code": "def hasAssignableMVar [Monad m] [MonadMCtx m] : Expr \u2192 m Bool\n  | .const _ lvls    => lvls.anyM hasAssignableLevelMVar\n  | .sort lvl        => hasAssignableLevelMVar lvl\n  | .app f a         => (pure f.hasMVar <&&> hasAssignableMVar f) <||> (pure a.hasMVar <&&> hasAssignableMVar a)\n  | .letE _ t v b _  => (pure t.hasMVar <&&> hasAssignableMVar t) <||> (pure v.hasMVar <&&> hasAssignableMVar v) <||> (pure b.hasMVar <&&> hasAssignableMVar b)\n  | .forallE _ d b _ => (pure d.hasMVar <&&> hasAssignableMVar d) <||> (pure b.hasMVar <&&> hasAssignableMVar b)\n  | .lam _ d b _     => (pure d.hasMVar <&&> hasAssignableMVar d) <||> (pure b.hasMVar <&&> hasAssignableMVar b)\n  | .fvar _          => return false\n  | .bvar _          => return false\n  | .lit _           => return false\n  | .mdata _ e       => pure e.hasMVar <&&> hasAssignableMVar e\n  | .proj _ _ e      => pure e.hasMVar <&&> hasAssignableMVar e\n  | .mvar mvarId     => mvarId.isAssignable", "start": [442, 1], "end": [455, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.assignLevelMVar", "code": "def assignLevelMVar [MonadMCtx m] (mvarId : LMVarId) (val : Level) : m Unit :=\n  modifyMCtx fun m => { m with lAssignment := m.lAssignment.insert mvarId val }", "start": [457, 1], "end": [464, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.assign", "code": "def _root_.Lean.MVarId.assign [MonadMCtx m] (mvarId : MVarId) (val : Expr) : m Unit :=\n  modifyMCtx fun m => { m with eAssignment := m.eAssignment.insert mvarId val }", "start": [466, 1], "end": [473, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.assignExprMVar", "code": "@[deprecated MVarId.assign]\ndef assignExprMVar [MonadMCtx m] (mvarId : MVarId) (val : Expr) : m Unit :=\n  mvarId.assign val", "start": [475, 1], "end": [477, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.assignDelayedMVar", "code": "def assignDelayedMVar [MonadMCtx m] (mvarId : MVarId) (fvars : Array Expr) (mvarIdPending : MVarId) : m Unit :=\n  modifyMCtx fun m => { m with dAssignment := m.dAssignment.insert mvarId { fvars, mvarIdPending } }", "start": [479, 1], "end": [480, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.instantiateLevelMVars", "code": "partial def instantiateLevelMVars [Monad m] [MonadMCtx m] : Level \u2192 m Level\n  | lvl@(Level.succ lvl\u2081)      => return Level.updateSucc! lvl (\u2190 instantiateLevelMVars lvl\u2081)\n  | lvl@(Level.max lvl\u2081 lvl\u2082)  => return Level.updateMax! lvl (\u2190 instantiateLevelMVars lvl\u2081) (\u2190 instantiateLevelMVars lvl\u2082)\n  | lvl@(Level.imax lvl\u2081 lvl\u2082) => return Level.updateIMax! lvl (\u2190 instantiateLevelMVars lvl\u2081) (\u2190 instantiateLevelMVars lvl\u2082)\n  | lvl@(Level.mvar mvarId)    => do\n    match (\u2190 getLevelMVarAssignment? mvarId) with\n    | some newLvl =>\n      if !newLvl.hasMVar then pure newLvl\n      else do\n        let newLvl' \u2190 instantiateLevelMVars newLvl\n        assignLevelMVar mvarId newLvl'\n        pure newLvl'\n    | none        => pure lvl\n  | lvl => pure lvl", "start": [501, 1], "end": [514, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.instantiateExprMVars", "code": "partial def instantiateExprMVars [Monad m] [MonadMCtx m] [STWorld \u03c9 m] [MonadLiftT (ST \u03c9) m] (e : Expr) : MonadCacheT ExprStructEq Expr m Expr :=\n  if !e.hasMVar then\n    pure e\n  else checkCache { val := e : ExprStructEq } fun _ => do match e with\n    | .proj _ _ s      => return e.updateProj! (\u2190 instantiateExprMVars s)\n    | .forallE _ d b _ => return e.updateForallE! (\u2190 instantiateExprMVars d) (\u2190 instantiateExprMVars b)\n    | .lam _ d b _     => return e.updateLambdaE! (\u2190 instantiateExprMVars d) (\u2190 instantiateExprMVars b)\n    | .letE _ t v b _  => return e.updateLet! (\u2190 instantiateExprMVars t) (\u2190 instantiateExprMVars v) (\u2190 instantiateExprMVars b)\n    | .const _ lvls    => return e.updateConst! (\u2190 lvls.mapM instantiateLevelMVars)\n    | .sort lvl        => return e.updateSort! (\u2190 instantiateLevelMVars lvl)\n    | .mdata _ b       => return e.updateMData! (\u2190 instantiateExprMVars b)\n    | .app ..          => e.withApp fun f args => do\n      let instArgs (f : Expr) : MonadCacheT ExprStructEq Expr m Expr := do\n        let args \u2190 args.mapM instantiateExprMVars\n        pure (mkAppN f args)\n      let instApp : MonadCacheT ExprStructEq Expr m Expr := do\n        let wasMVar := f.isMVar\n        let f \u2190 instantiateExprMVars f\n        if wasMVar && f.isLambda then\n          \n          instantiateExprMVars (f.betaRev args.reverse)\n        else\n          instArgs f\n      match f with\n      | .mvar mvarId =>\n        match (\u2190 getDelayedMVarAssignment? mvarId) with\n        | none => instApp\n        | some { fvars, mvarIdPending } =>\n          \n          if fvars.size > args.size then\n            \n            instArgs f\n          else\n            let newVal \u2190 instantiateExprMVars (mkMVar mvarIdPending)\n            if newVal.hasExprMVar then\n              instArgs f\n            else do\n              let args \u2190 args.mapM instantiateExprMVars\n              \n              let newVal := newVal.abstract fvars\n              let result := newVal.instantiateRevRange 0 fvars.size args\n              let result := mkAppRange result fvars.size args.size args\n              pure result\n      | _ => instApp\n    | e@(.mvar mvarId) => checkCache { val := e : ExprStructEq } fun _ => do\n      match (\u2190 getExprMVarAssignment? mvarId) with\n      | some newE => do\n        let newE' \u2190 instantiateExprMVars newE\n        mvarId.assign newE'\n        pure newE'\n      | none => pure e\n    | e => pure e", "start": [516, 1], "end": [585, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.instantiateMVarsCore", "code": "def instantiateMVarsCore (mctx : MetavarContext) (e : Expr) : Expr \u00d7 MetavarContext :=\n  let instantiate {\u03c9} (e : Expr) : (MonadCacheT ExprStructEq Expr <| StateRefT MetavarContext (ST \u03c9)) Expr :=\n    instantiateExprMVars e\n  runST fun _ => instantiate e |>.run |>.run mctx", "start": [591, 1], "end": [594, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.instantiateMVars", "code": "def instantiateMVars [Monad m] [MonadMCtx m] (e : Expr) : m Expr := do\n  if !e.hasMVar then\n    return e\n  else\n    let (r, mctx) := instantiateMVarsCore (\u2190 getMCtx) e\n    modifyMCtx fun _ => mctx\n    return r", "start": [596, 1], "end": [602, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.instantiateLCtxMVars", "code": "def instantiateLCtxMVars [Monad m] [MonadMCtx m] (lctx : LocalContext) : m LocalContext :=\n  lctx.foldlM (init := {}) fun lctx ldecl => do\n     match ldecl with\n     | .cdecl _ fvarId userName type bi k =>\n       let type \u2190 instantiateMVars type\n       return lctx.mkLocalDecl fvarId userName type bi k\n     | .ldecl _ fvarId userName type value nonDep k =>\n       let type \u2190 instantiateMVars type\n       let value \u2190 instantiateMVars value\n       return lctx.mkLetDecl fvarId userName type value nonDep k", "start": [604, 1], "end": [613, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.instantiateMVarDeclMVars", "code": "def instantiateMVarDeclMVars [Monad m] [MonadMCtx m] (mvarId : MVarId) : m Unit := do\n  let mvarDecl     := (\u2190 getMCtx).getDecl mvarId\n  let lctx \u2190 instantiateLCtxMVars mvarDecl.lctx\n  let type \u2190 instantiateMVars mvarDecl.type\n  modifyMCtx fun mctx => { mctx with decls := mctx.decls.insert mvarId { mvarDecl with lctx, type } }", "start": [615, 1], "end": [619, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.instantiateLocalDeclMVars", "code": "def instantiateLocalDeclMVars [Monad m] [MonadMCtx m] (localDecl : LocalDecl) : m LocalDecl := do\n  match localDecl with\n  | .cdecl idx id n type bi k =>\n    return .cdecl idx id n (\u2190 instantiateMVars type) bi k\n  | .ldecl idx id n type val nonDep k =>\n    return .ldecl idx id n (\u2190 instantiateMVars type) (\u2190 instantiateMVars val) nonDep k", "start": [621, 1], "end": [626, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.DependsOn.State", "code": "structure State where\n  visited : ExprSet := {}\n  mctx    : MetavarContext", "start": [630, 1], "end": [632, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.DependsOn.M", "code": "private abbrev M := StateM State", "start": [634, 1], "end": [634, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.DependsOn.shouldVisit", "code": "private def shouldVisit (e : Expr) : M Bool := do\n  if !e.hasMVar && !e.hasFVar then\n    return false\n  else if (\u2190 get).visited.contains e then\n    return false\n  else\n    modify fun s => { s with visited := s.visited.insert e }\n    return true", "start": [640, 1], "end": [647, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.DependsOn.dep", "code": "@[specialize] private partial def dep (pf : FVarId \u2192 Bool) (pm : MVarId \u2192  Bool) (e : Expr) : M Bool :=\n  let rec\n    visit (e : Expr) : M Bool := do\n      if !(\u2190 shouldVisit e) then\n        pure false\n      else\n        visitMain e,\n    visitApp : Expr \u2192 M Bool\n      | .app f a .. => visitApp f <||> visit a\n      | e => visit e,\n    visitMain : Expr \u2192 M Bool\n      | .proj _ _ s      => visit s\n      | .forallE _ d b _ => visit d <||> visit b\n      | .lam _ d b _     => visit d <||> visit b\n      | .letE _ t v b _  => visit t <||> visit v <||> visit b\n      | .mdata _ b       => visit b\n      | e@(.app ..)      => do\n        let f := e.getAppFn\n        if f.isMVar then\n          let e' \u2190 instantiateMVars e\n          if e'.getAppFn != f then\n            visitMain e'\n          else if pm f.mvarId! then\n            return true\n          else\n            visitApp e\n        else\n          visitApp e\n      | .mvar mvarId     => do\n        match (\u2190 getExprMVarAssignment? mvarId) with\n        | some a => visit a\n        | none   =>\n          if pm mvarId then\n            return true\n          else\n            let lctx := (\u2190 getMCtx).getDecl mvarId |>.lctx\n            return lctx.any fun decl => pf decl.fvarId\n      | .fvar fvarId     => return pf fvarId\n      | _                    => pure false\n  visit e", "start": [649, 1], "end": [688, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.DependsOn.main", "code": "@[inline] partial def main (pf : FVarId \u2192 Bool) (pm : MVarId \u2192 Bool) (e : Expr) : M Bool :=\n  if !e.hasFVar && !e.hasMVar then pure false else dep pf pm e", "start": [690, 1], "end": [691, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.findExprDependsOn", "code": "@[inline] def findExprDependsOn [Monad m] [MonadMCtx m] (e : Expr) (pf : FVarId \u2192 Bool := fun _ => false) (pm : MVarId \u2192 Bool := fun _ => false) : m Bool := do\n  let (result, { mctx, .. }) := DependsOn.main pf pm e |>.run { mctx := (\u2190 getMCtx) }\n  setMCtx mctx\n  return result", "start": [695, 1], "end": [704, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.findLocalDeclDependsOn", "code": "@[inline] def findLocalDeclDependsOn [Monad m] [MonadMCtx m] (localDecl : LocalDecl) (pf : FVarId \u2192 Bool := fun _ => false) (pm : MVarId \u2192 Bool := fun _ => false) : m Bool := do\n  match localDecl with\n  | .cdecl (type := t) ..  => findExprDependsOn t pf pm\n  | .ldecl (type := t) (value := v) .. =>\n    let (result, { mctx, .. }) := (DependsOn.main pf pm t <||> DependsOn.main pf pm v).run { mctx := (\u2190 getMCtx) }\n    setMCtx mctx\n    return result", "start": [706, 1], "end": [715, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.exprDependsOn", "code": "def exprDependsOn [Monad m] [MonadMCtx m] (e : Expr) (fvarId : FVarId) : m Bool :=\n  findExprDependsOn e (fvarId == \u00b7)", "start": [717, 1], "end": [718, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.dependsOn", "code": "def dependsOn [Monad m] [MonadMCtx m] (e : Expr) (fvarId : FVarId) : m Bool :=\n  exprDependsOn e fvarId", "start": [720, 1], "end": [722, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.localDeclDependsOn", "code": "def localDeclDependsOn [Monad m] [MonadMCtx m] (localDecl : LocalDecl) (fvarId : FVarId) : m Bool :=\n  findLocalDeclDependsOn localDecl (fvarId == \u00b7)", "start": [724, 1], "end": [726, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.exprDependsOn'", "code": "def exprDependsOn' [Monad m] [MonadMCtx m] (e : Expr) (x : Expr) : m Bool :=\n  if x.isFVar then\n    findExprDependsOn e (x.fvarId! == \u00b7)\n  else if x.isMVar then\n    findExprDependsOn e (pm := (x.mvarId! == \u00b7))\n  else\n    return false", "start": [728, 1], "end": [735, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.localDeclDependsOn'", "code": "def localDeclDependsOn' [Monad m] [MonadMCtx m] (localDecl : LocalDecl) (x : Expr) : m Bool :=\n  if x.isFVar then\n    findLocalDeclDependsOn localDecl (x.fvarId! == \u00b7)\n  else if x.isMVar then\n    findLocalDeclDependsOn localDecl (pm := (x.mvarId! == \u00b7))\n  else\n    return false", "start": [737, 1], "end": [744, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.dependsOnPred", "code": "def dependsOnPred [Monad m] [MonadMCtx m] (e : Expr) (pf : FVarId \u2192 Bool := fun _ => false) (pm : MVarId \u2192 Bool := fun _ => false) : m Bool :=\n  findExprDependsOn e pf pm", "start": [746, 1], "end": [748, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.localDeclDependsOnPred", "code": "def localDeclDependsOnPred [Monad m] [MonadMCtx m] (localDecl : LocalDecl) (pf : FVarId \u2192 Bool := fun _ => false) (pm : MVarId \u2192 Bool := fun _ => false) : m Bool := do\n  findLocalDeclDependsOn localDecl pf pm", "start": [750, 1], "end": [752, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.mkMetavarContext", "code": "@[export lean_mk_metavar_ctx]\ndef mkMetavarContext : Unit \u2192 MetavarContext := fun _ => {}", "start": [759, 1], "end": [760, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.addExprMVarDecl", "code": "def addExprMVarDecl (mctx : MetavarContext)\n    (mvarId : MVarId)\n    (userName : Name)\n    (lctx : LocalContext)\n    (localInstances : LocalInstances)\n    (type : Expr)\n    (kind : MetavarKind := MetavarKind.natural)\n    (numScopeArgs : Nat := 0) : MetavarContext :=\n  { mctx with\n    mvarCounter := mctx.mvarCounter + 1\n    decls       := mctx.decls.insert mvarId {\n      depth := mctx.depth\n      index := mctx.mvarCounter\n      userName\n      lctx\n      localInstances\n      type\n      kind\n      numScopeArgs }\n    userNames := if userName.isAnonymous then mctx.userNames else mctx.userNames.insert userName mvarId }", "start": [762, 1], "end": [784, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.addExprMVarDeclExp", "code": "def addExprMVarDeclExp (mctx : MetavarContext) (mvarId : MVarId) (userName : Name) (lctx : LocalContext) (localInstances : LocalInstances)\n    (type : Expr) (kind : MetavarKind) : MetavarContext :=\n    addExprMVarDecl mctx mvarId userName lctx localInstances type kind", "start": [786, 1], "end": [788, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.addLevelMVarDecl", "code": "def addLevelMVarDecl (mctx : MetavarContext) (mvarId : LMVarId) : MetavarContext :=\n  { mctx with lDepth := mctx.lDepth.insert mvarId mctx.depth }", "start": [790, 1], "end": [794, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.findDecl?", "code": "def findDecl? (mctx : MetavarContext) (mvarId : MVarId) : Option MetavarDecl :=\n  mctx.decls.find? mvarId", "start": [796, 1], "end": [797, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.findUserName?", "code": "def findUserName? (mctx : MetavarContext) (userName : Name) : Option MVarId :=\n  mctx.userNames.find? userName", "start": [799, 1], "end": [800, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.setMVarKind", "code": "def setMVarKind (mctx : MetavarContext) (mvarId : MVarId) (kind : MetavarKind) : MetavarContext :=\n  let decl := mctx.getDecl mvarId\n  { mctx with decls := mctx.decls.insert mvarId { decl with kind := kind } }", "start": [802, 1], "end": [804, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.setMVarUserName", "code": "def setMVarUserName (mctx : MetavarContext) (mvarId : MVarId) (userName : Name) : MetavarContext :=\n  let decl := mctx.getDecl mvarId\n  { mctx with\n    decls := mctx.decls.insert mvarId { decl with userName := userName }\n    userNames :=\n      let userNames := mctx.userNames.erase decl.userName\n      if userName.isAnonymous then userNames else userNames.insert userName mvarId }", "start": [806, 1], "end": [815, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.setMVarUserNameTemporarily", "code": "def setMVarUserNameTemporarily (mctx : MetavarContext) (mvarId : MVarId) (userName : Name) : MetavarContext :=\n  let decl := mctx.getDecl mvarId\n  { mctx with decls := mctx.decls.insert mvarId { decl with userName := userName } }", "start": [817, 1], "end": [825, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.setMVarType", "code": "def setMVarType (mctx : MetavarContext) (mvarId : MVarId) (type : Expr) : MetavarContext :=\n  let decl := mctx.getDecl mvarId\n  { mctx with decls := mctx.decls.insert mvarId { decl with type := type } }", "start": [827, 1], "end": [831, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.findLevelDepth?", "code": "def findLevelDepth? (mctx : MetavarContext) (mvarId : LMVarId) : Option Nat :=\n  mctx.lDepth.find? mvarId", "start": [833, 1], "end": [834, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.getLevelDepth", "code": "def getLevelDepth (mctx : MetavarContext) (mvarId : LMVarId) : Nat :=\n  match mctx.findLevelDepth? mvarId with\n  | some d => d\n  | none   => panic! \"unknown metavariable\"", "start": [836, 1], "end": [839, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.isAnonymousMVar", "code": "def isAnonymousMVar (mctx : MetavarContext) (mvarId : MVarId) : Bool :=\n  match mctx.findDecl? mvarId with\n  | none          => false\n  | some mvarDecl => mvarDecl.userName.isAnonymous", "start": [841, 1], "end": [844, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.incDepth", "code": "def incDepth (mctx : MetavarContext) (allowLevelAssignments := false) : MetavarContext :=\n  let depth := mctx.depth + 1\n  let levelAssignDepth :=\n    if allowLevelAssignments then mctx.levelAssignDepth else depth\n  { mctx with depth, levelAssignDepth }", "start": [846, 1], "end": [850, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.Exception", "code": "inductive Exception where\n  | revertFailure (mctx : MetavarContext) (lctx : LocalContext) (toRevert : Array Expr) (varName : String)", "start": [858, 1], "end": [859, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.State", "code": "structure State where\n  mctx           : MetavarContext\n  nextMacroScope : MacroScope\n  ngen           : NameGenerator\n  cache          : HashMap ExprStructEq Expr := {}", "start": [869, 1], "end": [878, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.Context", "code": "structure Context where\n  mainModule         : Name\n  preserveOrder      : Bool\n  \n  binderInfoForMVars : BinderInfo := BinderInfo.implicit\n  \n  mvarIdsToAbstract  : MVarIdSet := {}", "start": [880, 1], "end": [886, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.MCore", "code": "abbrev MCore := EStateM Exception State", "start": [888, 1], "end": [888, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.M", "code": "abbrev M     := ReaderT Context MCore", "start": [889, 1], "end": [889, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.mkFreshBinderName", "code": "private def mkFreshBinderName (n : Name := `x) : M Name := do\n  let fresh \u2190 modifyGet fun s => (s.nextMacroScope, { s with nextMacroScope := s.nextMacroScope + 1 })\n  return addMacroScope (\u2190 read).mainModule n fresh", "start": [895, 1], "end": [897, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.preserveOrder", "code": "def preserveOrder : M Bool :=\n  return (\u2190 read).preserveOrder", "start": [899, 1], "end": [900, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.getLocalDeclWithSmallestIdx", "code": "private def getLocalDeclWithSmallestIdx (lctx : LocalContext) (xs : Array Expr) : LocalDecl := Id.run do\n  let mut d : LocalDecl := lctx.getFVar! xs[0]!\n  for x in xs[1:] do\n    if x.isFVar then\n      let curr := lctx.getFVar! x\n      if curr.index < d.index then\n        d := curr\n  return d", "start": [906, 1], "end": [914, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.collectForwardDeps", "code": "def collectForwardDeps (lctx : LocalContext) (toRevert : Array Expr) : M (Array Expr) := do\n  if toRevert.size == 0 then\n    pure toRevert\n  else\n    if (\u2190 preserveOrder) then\n      toRevert.size.forM fun i => do\n        let fvar := toRevert[i]!\n        i.forM fun j => do\n          let prevFVar := toRevert[j]!\n          let prevDecl := lctx.getFVar! prevFVar\n          if (\u2190 localDeclDependsOn prevDecl fvar.fvarId!) then\n            throw (Exception.revertFailure (\u2190 getMCtx) lctx toRevert prevDecl.userName.toString)\n    let newToRevert      := if (\u2190 preserveOrder) then toRevert else Array.mkEmpty toRevert.size\n    let firstDeclToVisit := getLocalDeclWithSmallestIdx lctx toRevert\n    let initSize         := newToRevert.size\n    lctx.foldlM (init := newToRevert) (start := firstDeclToVisit.index) fun (newToRevert : Array Expr) decl => do\n      if initSize.any fun i => decl.fvarId == newToRevert[i]!.fvarId! then\n        return newToRevert\n      else if toRevert.any fun x => decl.fvarId == x.fvarId! then\n        return newToRevert.push decl.toExpr\n      else if (\u2190 findLocalDeclDependsOn decl (newToRevert.any fun x => x.fvarId! == \u00b7)) then\n        return newToRevert.push decl.toExpr\n      else\n        return newToRevert", "start": [916, 1], "end": [973, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.reduceLocalContext", "code": "def reduceLocalContext (lctx : LocalContext) (toRevert : Array Expr) : LocalContext :=\n  toRevert.foldr (init := lctx) fun x lctx =>\n    if x.isFVar then lctx.erase x.fvarId! else lctx", "start": [975, 1], "end": [979, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.getInScope", "code": "private def getInScope (lctx : LocalContext) (xs : Array Expr) : Array Expr :=\n  xs.foldl (init := #[]) fun scope x =>\n    if !x.isFVar then\n      scope\n    else if lctx.contains x.fvarId! then\n      scope.push x\n    else\n      scope", "start": [981, 1], "end": [989, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.withFreshCache", "code": "@[inline] private def withFreshCache (x : M \u03b1) : M \u03b1 := do\n  let cache \u2190 modifyGet fun s => (s.cache, { s with cache := {} })\n  let a \u2190 x\n  modify fun s => { s with cache := cache }\n  pure a", "start": [991, 1], "end": [996, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.mkMVarApp", "code": "private def mkMVarApp (lctx : LocalContext) (mvar : Expr) (xs : Array Expr) (kind : MetavarKind) : Expr :=\n  xs.foldl (init := mvar) fun e x =>\n    if !x.isFVar then\n      e\n    else\n      match kind with\n      | MetavarKind.syntheticOpaque => mkApp e x\n      | _                           => if (lctx.getFVar! x).isLet then e else mkApp e x", "start": [998, 1], "end": [1009, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.visit", "code": "private partial def visit (xs : Array Expr) (e : Expr) : M Expr :=\n    if !e.hasMVar then pure e else checkCache { val := e : ExprStructEq } fun _ => elim xs e", "start": [1013, 3], "end": [1014, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.elim", "code": "private partial def elim (xs : Array Expr) (e : Expr) : M Expr :=\n    match e with\n    | .proj _ _ s      => return e.updateProj! (\u2190 visit xs s)\n    | .forallE _ d b _ => return e.updateForallE! (\u2190 visit xs d) (\u2190 visit xs b)\n    | .lam _ d b _     => return e.updateLambdaE! (\u2190 visit xs d) (\u2190 visit xs b)\n    | .letE _ t v b _  => return e.updateLet! (\u2190 visit xs t) (\u2190 visit xs v) (\u2190 visit xs b)\n    | .mdata _ b       => return e.updateMData! (\u2190 visit xs b)\n    | .app ..          => e.withApp fun f args => elimApp xs f args\n    | .mvar _          => elimApp xs e #[]\n    | e                => return e", "start": [1016, 3], "end": [1025, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.mkAuxMVarType", "code": "private partial def mkAuxMVarType (lctx : LocalContext) (xs : Array Expr) (kind : MetavarKind) (e : Expr) : M Expr := do\n    let e \u2190 abstractRangeAux xs xs.size e\n    xs.size.foldRevM (init := e) fun i e => do\n      let x := xs[i]!\n      if x.isFVar then\n        match lctx.getFVar! x with\n        | LocalDecl.cdecl _ _ n type bi _ =>\n          let type := type.headBeta\n          let type \u2190 abstractRangeAux xs i type\n          return Lean.mkForall n bi type e\n        | LocalDecl.ldecl _ _ n type value nonDep _ =>\n          let type := type.headBeta\n          let type  \u2190 abstractRangeAux xs i type\n          let value \u2190 abstractRangeAux xs i value\n          let e := mkLet n type value e nonDep\n          match kind with\n          | MetavarKind.syntheticOpaque =>\n            let e := e.liftLooseBVars 0 1\n            return mkForall n BinderInfo.default type e\n          | _ => pure e\n      else\n        let mvarDecl := (\u2190 get).mctx.getDecl x.mvarId!\n        let type := mvarDecl.type.headBeta\n        let type \u2190 abstractRangeAux xs i type\n        let id \u2190 if mvarDecl.userName.isAnonymous then mkFreshBinderName else pure mvarDecl.userName\n        return Lean.mkForall id (\u2190 read).binderInfoForMVars type e\n  where\n    abstractRangeAux (xs : Array Expr) (i : Nat) (e : Expr) : M Expr := do\n      let e \u2190 elim xs e\n      pure (e.abstractRange i xs)", "start": [1027, 3], "end": [1066, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.elimMVar", "code": "private partial def elimMVar (xs : Array Expr) (mvarId : MVarId) (args : Array Expr) : M (Expr \u00d7 Array Expr) := do\n    let mvarDecl  := (\u2190 getMCtx).getDecl mvarId\n    let mvarLCtx  := mvarDecl.lctx\n    let toRevert  := getInScope mvarLCtx xs\n    if toRevert.size == 0 then\n      let args \u2190 args.mapM (visit xs)\n      return (mkAppN (mkMVar mvarId) args, #[])\n    else\n      \n      let newMVarKind := if !(\u2190 mvarId.isAssignable) then MetavarKind.syntheticOpaque else mvarDecl.kind\n      let args \u2190 args.mapM (visit xs)\n      let toRevert \u2190 collectForwardDeps mvarLCtx toRevert\n      let newMVarLCtx   := reduceLocalContext mvarLCtx toRevert\n      let newLocalInsts := mvarDecl.localInstances.filter fun inst => toRevert.all fun x => inst.fvar != x\n      let newMVarType \u2190 withFreshCache do mkAuxMVarType mvarLCtx toRevert newMVarKind mvarDecl.type\n      let newMVarId    := { name := (\u2190 get).ngen.curr }\n      let newMVar      := mkMVar newMVarId\n      let result       := mkMVarApp mvarLCtx newMVar toRevert newMVarKind\n      let numScopeArgs := mvarDecl.numScopeArgs + result.getAppNumArgs\n      modify fun s => { s with\n          mctx := s.mctx.addExprMVarDecl newMVarId Name.anonymous newMVarLCtx newLocalInsts newMVarType newMVarKind numScopeArgs,\n          ngen := s.ngen.next\n        }\n      if !mvarDecl.kind.isSyntheticOpaque then\n        mvarId.assign result\n      else\n        \n        let (mvarIdPending, nestedFVars) \u2190 match (\u2190 getDelayedMVarAssignment? mvarId) with\n          | none => pure (mvarId, #[])\n          | some { fvars, mvarIdPending } => pure (mvarIdPending, fvars)\n        assignDelayedMVar newMVarId (toRevert ++ nestedFVars) mvarIdPending\n      return (mkAppN result args, toRevert)", "start": [1068, 3], "end": [1127, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.elimApp", "code": "private partial def elimApp (xs : Array Expr) (f : Expr) (args : Array Expr) : M Expr := do\n    match f with\n    | Expr.mvar mvarId =>\n      match (\u2190 getExprMVarAssignment? mvarId) with\n      | some newF =>\n        if newF.isLambda then\n          let args \u2190 args.mapM (visit xs)\n          \n          elim xs <| newF.betaRev args.reverse\n        else\n          elimApp xs newF args\n      | none =>\n        if (\u2190 read).mvarIdsToAbstract.contains mvarId then\n          return mkAppN f (\u2190 args.mapM (visit xs))\n        else\n          return (\u2190 elimMVar xs mvarId args).1\n    | _ =>\n      return mkAppN (\u2190 visit xs f) (\u2190 args.mapM (visit xs))", "start": [1129, 3], "end": [1146, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.elimMVarDeps", "code": "partial def elimMVarDeps (xs : Array Expr) (e : Expr) : M Expr :=\n  if !e.hasMVar then\n    return e\n  else\n    withFreshCache do\n      elim xs e", "start": [1150, 1], "end": [1155, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.revert", "code": "partial def revert (xs : Array Expr) (mvarId : MVarId) : M (Expr \u00d7 Array Expr) :=\n  withFreshCache do\n    elimMVar xs mvarId #[]", "start": [1157, 1], "end": [1166, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.abstractRange", "code": "@[inline] def abstractRange (xs : Array Expr) (i : Nat) (e : Expr) : M Expr := do\n  let e \u2190 elimMVarDeps xs e\n  pure (e.abstractRange i xs)", "start": [1168, 1], "end": [1175, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBinding.mkBinding", "code": "@[specialize] def mkBinding (isLambda : Bool) (lctx : LocalContext) (xs : Array Expr) (e : Expr) (usedOnly : Bool) (usedLetOnly : Bool) : M (Expr \u00d7 Nat) := do\n  let e \u2190 abstractRange xs xs.size e\n  xs.size.foldRevM (init := (e, 0)) fun i (e, num) => do\n      let x := xs[i]!\n      if x.isFVar then\n        match lctx.getFVar! x with\n        | LocalDecl.cdecl _ _ n type bi _ =>\n          if !usedOnly || e.hasLooseBVar 0 then\n            let type := type.headBeta;\n            let type \u2190 abstractRange xs i type\n            if isLambda then\n              return (Lean.mkLambda n bi type e, num + 1)\n            else\n              return (Lean.mkForall n bi type e, num + 1)\n          else\n            return (e.lowerLooseBVars 1 1, num)\n        | LocalDecl.ldecl _ _ n type value nonDep _ =>\n          if !usedLetOnly || e.hasLooseBVar 0 then\n            let type  \u2190 abstractRange xs i type\n            let value \u2190 abstractRange xs i value\n            return (mkLet n type value e nonDep, num + 1)\n          else\n            return (e.lowerLooseBVars 1 1, num)\n      else\n        let mvarDecl := (\u2190 get).mctx.getDecl x.mvarId!\n        let type := mvarDecl.type.headBeta\n        let type \u2190 abstractRange xs i type\n        let id \u2190 if mvarDecl.userName.isAnonymous then mkFreshBinderName else pure mvarDecl.userName\n        if isLambda then\n          return (Lean.mkLambda id (\u2190 read).binderInfoForMVars type e, num + 1)\n        else\n          return (Lean.mkForall id (\u2190 read).binderInfoForMVars type e, num + 1)", "start": [1177, 1], "end": [1212, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBindingM.Context", "code": "structure MkBindingM.Context where\n  mainModule : Name\n  lctx       : LocalContext", "start": [1216, 1], "end": [1218, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.MkBindingM", "code": "abbrev MkBindingM := ReaderT MkBindingM.Context MkBinding.MCore", "start": [1220, 1], "end": [1220, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.elimMVarDeps", "code": "def elimMVarDeps (xs : Array Expr) (e : Expr) (preserveOrder : Bool) : MkBindingM Expr := fun ctx =>\n  MkBinding.elimMVarDeps xs e { preserveOrder, mainModule := ctx.mainModule }", "start": [1222, 1], "end": [1223, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.revert", "code": "def revert (xs : Array Expr) (mvarId : MVarId) (preserveOrder : Bool) : MkBindingM (Expr \u00d7 Array Expr) := fun ctx =>\n  MkBinding.revert xs mvarId { preserveOrder, mainModule := ctx.mainModule }", "start": [1225, 1], "end": [1226, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.mkBinding", "code": "def mkBinding (isLambda : Bool) (xs : Array Expr) (e : Expr) (usedOnly : Bool := false) (usedLetOnly : Bool := true) (binderInfoForMVars := BinderInfo.implicit) : MkBindingM (Expr \u00d7 Nat) := fun ctx =>\n  let mvarIdsToAbstract := xs.foldl (init := {}) fun s x => if x.isMVar then s.insert x.mvarId! else s\n  MkBinding.mkBinding isLambda ctx.lctx xs e usedOnly usedLetOnly { preserveOrder := false, binderInfoForMVars, mvarIdsToAbstract, mainModule := ctx.mainModule }", "start": [1228, 1], "end": [1230, 162], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.mkLambda", "code": "@[inline] def mkLambda (xs : Array Expr) (e : Expr) (usedOnly : Bool := false) (usedLetOnly : Bool := true) (binderInfoForMVars := BinderInfo.implicit) : MkBindingM Expr :=\n  return (\u2190 mkBinding (isLambda := true) xs e usedOnly usedLetOnly binderInfoForMVars).1", "start": [1232, 1], "end": [1233, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.mkForall", "code": "@[inline] def mkForall (xs : Array Expr) (e : Expr) (usedOnly : Bool := false) (usedLetOnly : Bool := true) (binderInfoForMVars := BinderInfo.implicit) : MkBindingM Expr :=\n  return (\u2190 mkBinding (isLambda := false) xs e usedOnly usedLetOnly binderInfoForMVars).1", "start": [1235, 1], "end": [1236, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.abstractRange", "code": "@[inline] def abstractRange (e : Expr) (n : Nat) (xs : Array Expr) : MkBindingM Expr := fun ctx =>\n  MkBinding.abstractRange xs n e { preserveOrder := false, mainModule := ctx.mainModule }", "start": [1238, 1], "end": [1239, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.collectForwardDeps", "code": "@[inline] def collectForwardDeps (toRevert : Array Expr) (preserveOrder : Bool) : MkBindingM (Array Expr) := fun ctx =>\n  MkBinding.collectForwardDeps ctx.lctx toRevert { preserveOrder, mainModule := ctx.mainModule }", "start": [1241, 1], "end": [1242, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.isWellFormed", "code": "partial def isWellFormed [Monad m] [MonadMCtx m] (lctx : LocalContext) : Expr \u2192 m Bool\n  | .mdata _ e           => isWellFormed lctx e\n  | .proj _ _ e          => isWellFormed lctx e\n  | e@(.app f a)         => pure (!e.hasExprMVar && !e.hasFVar) <||> (isWellFormed lctx f <&&> isWellFormed lctx a)\n  | e@(.lam _ d b _)     => pure (!e.hasExprMVar && !e.hasFVar) <||> (isWellFormed lctx d <&&> isWellFormed lctx b)\n  | e@(.forallE _ d b _) => pure (!e.hasExprMVar && !e.hasFVar) <||> (isWellFormed lctx d <&&> isWellFormed lctx b)\n  | e@(.letE _ t v b _)  => pure (!e.hasExprMVar && !e.hasFVar) <||> (isWellFormed lctx t <&&> isWellFormed lctx v <&&> isWellFormed lctx b)\n  | .const ..            => return true\n  | .bvar ..             => return true\n  | .sort ..             => return true\n  | .lit ..              => return true\n  | .mvar mvarId         => do\n    let mvarDecl := (\u2190 getMCtx).getDecl mvarId;\n    if mvarDecl.lctx.isSubPrefixOf lctx then\n      return true\n    else match (\u2190 getExprMVarAssignment? mvarId) with\n      | none   => return false\n      | some v => isWellFormed lctx v\n  | .fvar fvarId         => return lctx.contains fvarId", "start": [1244, 1], "end": [1266, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.LevelMVarToParam.Context", "code": "structure Context where\n  paramNamePrefix : Name\n  alreadyUsedPred : Name \u2192 Bool\n  except          : LMVarId \u2192 Bool", "start": [1270, 1], "end": [1273, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.LevelMVarToParam.State", "code": "structure State where\n  mctx         : MetavarContext\n  paramNames   : Array Name := #[]\n  nextParamIdx : Nat\n  cache        : HashMap ExprStructEq Expr := {}", "start": [1275, 1], "end": [1279, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.LevelMVarToParam.M", "code": "abbrev M := ReaderT Context <| StateM State", "start": [1281, 1], "end": [1281, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.LevelMVarToParam.mkParamName", "code": "partial def mkParamName : M Name := do\n  let ctx \u2190 read\n  let s \u2190 get\n  let newParamName := ctx.paramNamePrefix.appendIndexAfter s.nextParamIdx\n  if ctx.alreadyUsedPred newParamName then\n    modify fun s => { s with nextParamIdx := s.nextParamIdx + 1 }\n    mkParamName\n  else do\n    modify fun s => { s with nextParamIdx := s.nextParamIdx + 1, paramNames := s.paramNames.push newParamName }\n    pure newParamName", "start": [1291, 1], "end": [1300, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.LevelMVarToParam.visitLevel", "code": "partial def visitLevel (u : Level) : M Level := do\n  match u with\n  | .succ v      => return u.updateSucc! (\u2190 visitLevel v)\n  | .max v\u2081 v\u2082   => return u.updateMax! (\u2190 visitLevel v\u2081) (\u2190 visitLevel v\u2082)\n  | .imax v\u2081 v\u2082  => return u.updateIMax! (\u2190 visitLevel v\u2081) (\u2190 visitLevel v\u2082)\n  | .zero        => return u\n  | .param ..    => return u\n  | .mvar mvarId =>\n    match (\u2190 getLevelMVarAssignment? mvarId) with\n    | some v => visitLevel v\n    | none   =>\n      if (\u2190 read).except mvarId then\n        return u\n      else\n        let p \u2190 mkParamName\n        let p := mkLevelParam p\n        assignLevelMVar mvarId p\n        return p", "start": [1302, 1], "end": [1319, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.LevelMVarToParam.main", "code": "partial def main (e : Expr) : M Expr :=\n  if !e.hasMVar then\n    return e\n  else\n    checkCache { val := e : ExprStructEq } fun _ => do\n      match e with\n      | .proj _ _ s      => return e.updateProj! (\u2190 main s)\n      | .forallE _ d b _ => return e.updateForallE! (\u2190 main d) (\u2190 main b)\n      | .lam _ d b _     => return e.updateLambdaE! (\u2190 main d) (\u2190 main b)\n      | .letE _ t v b _  => return e.updateLet! (\u2190 main t) (\u2190 main v) (\u2190 main b)\n      | .app ..          => e.withApp fun f args => visitApp f args\n      | .mdata _ b       => return e.updateMData! (\u2190 main b)\n      | .const _ us      => return e.updateConst! (\u2190 us.mapM visitLevel)\n      | .sort u          => return e.updateSort! (\u2190 visitLevel u)\n      | .mvar ..         => visitApp e #[]\n      | e                => return e\nwhere\n  visitApp (f : Expr) (args : Array Expr) : M Expr := do\n    match f with\n    | .mvar mvarId .. =>\n      match (\u2190 getExprMVarAssignment? mvarId) with\n      | some v => return (\u2190 visitApp v args).headBeta\n      | none   => return mkAppN f (\u2190 args.mapM main)\n    | _ => return mkAppN (\u2190 main f) (\u2190 args.mapM main)", "start": [1321, 1], "end": [1344, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.UnivMVarParamResult", "code": "structure UnivMVarParamResult where\n  mctx          : MetavarContext\n  newParamNames : Array Name\n  nextParamIdx  : Nat\n  expr          : Expr", "start": [1348, 1], "end": [1352, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.levelMVarToParam", "code": "def levelMVarToParam (mctx : MetavarContext) (alreadyUsedPred : Name \u2192 Bool) (except : LMVarId \u2192 Bool) (e : Expr) (paramNamePrefix : Name := `u) (nextParamIdx : Nat := 1)\n    : UnivMVarParamResult :=\n  let (e, s) := LevelMVarToParam.main e { except, paramNamePrefix, alreadyUsedPred } { mctx, nextParamIdx }\n  { mctx          := s.mctx\n    newParamNames := s.paramNames\n    nextParamIdx  := s.nextParamIdx\n    expr          := e }", "start": [1354, 1], "end": [1360, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.getExprAssignmentDomain", "code": "def getExprAssignmentDomain (mctx : MetavarContext) : Array MVarId :=\n  mctx.eAssignment.foldl (init := #[]) fun a mvarId _ => Array.push a mvarId", "start": [1362, 1], "end": [1363, 77], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Position.lean", "imports": ["lake-packages/lean4/src/lean/Lean/ToExpr.lean", "lake-packages/lean4/src/lean/Lean/Data/Format.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Position", "code": "structure Position where\n  line   : Nat\n  column : Nat\n  deriving Inhabited, DecidableEq, Repr", "start": [11, 1], "end": [14, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Position.lt", "code": "protected def lt : Position \u2192 Position \u2192 Bool\n  | \u27e8l\u2081, c\u2081\u27e9, \u27e8l\u2082, c\u2082\u27e9 => Prod.lexLt (l\u2081, c\u2081) (l\u2082, c\u2082)", "start": [17, 1], "end": [18, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.FileMap", "code": "structure FileMap where\n  source    : String\n  positions : Array String.Pos\n  lines     : Array Nat\n  deriving Inhabited", "start": [32, 1], "end": [36, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadFileMap", "code": "class MonadFileMap (m : Type \u2192 Type) where\n  getFileMap : m FileMap", "start": [38, 1], "end": [39, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.FileMap.ofString", "code": "partial def ofString (s : String) : FileMap :=\n  let rec loop (i : String.Pos) (line : Nat) (ps : Array String.Pos) (lines : Array Nat) : FileMap :=\n    if s.atEnd i then { source := s, positions := ps.push i, lines := lines.push line }\n    else\n      let c := s.get i\n      let i := s.next i\n      if c == '\\n' then loop i (line+1) (ps.push i) (lines.push (line+1))\n      else loop i line ps lines\n  loop 0 1 (#[0]) (#[1])", "start": [45, 1], "end": [53, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.FileMap.toPosition", "code": "partial def toPosition (fmap : FileMap) (pos : String.Pos) : Position :=\n  match fmap with\n  | { source := str, positions := ps, lines := lines } =>\n    if ps.size >= 2 && pos <= ps.back then\n      let rec toColumn (i : String.Pos) (c : Nat) : Nat :=\n        if i == pos || str.atEnd i then c\n        else toColumn (str.next i) (c+1)\n      let rec loop (b e : Nat) :=\n        let posB := ps[b]!\n        if e == b + 1 then { line := lines.get! b, column := toColumn posB 0 }\n        else\n          let m := (b + e) / 2;\n          let posM := ps.get! m;\n          if pos == posM then { line := lines.get! m, column := 0 }\n          else if pos > posM then loop m e\n          else loop b m\n      loop 0 (ps.size -1)\n    else if lines.isEmpty then\n      \u27e80, 0\u27e9\n    else\n      \u27e8lines.back, (pos - ps.back).byteIdx\u27e9", "start": [55, 1], "end": [78, 44], "kind": "commanddeclaration"}, {"full_name": "String.toFileMap", "code": "def String.toFileMap (s : String) : Lean.FileMap :=\n  Lean.FileMap.ofString s", "start": [83, 1], "end": [84, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/OpenDecl.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Name.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.OpenDecl", "code": "inductive OpenDecl where\n  | simple   (ns : Name) (except : List Name)\n  | explicit (id : Name) (declName : Name)\n  deriving BEq", "start": [10, 1], "end": [14, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.rootNamespace", "code": "def rootNamespace := `_root_", "start": [26, 1], "end": [26, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.removeRoot", "code": "def removeRoot (n : Name) : Name :=\n  n.replacePrefix rootNamespace Name.anonymous", "start": [28, 1], "end": [29, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json/Parser.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/Stream.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/FromToJson.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/Printer.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Types.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/OpenDecl.lean", "lake-packages/lean4/src/lean/Lean/Data/Position.lean", "lake-packages/lean4/src/lean/Lean/MetavarContext.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean"], "premises": [{"full_name": "Lean.Elab.ContextInfo", "code": "structure ContextInfo where\n  env           : Environment\n  fileMap       : FileMap\n  mctx          : MetavarContext := {}\n  options       : Options        := {}\n  currNamespace : Name           := Name.anonymous\n  openDecls     : List OpenDecl  := []\n  ngen          : NameGenerator", "start": [15, 1], "end": [25, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ElabInfo", "code": "structure ElabInfo where\n  \n  elaborator : Name\n  \n  stx : Syntax\n  deriving Inhabited", "start": [27, 1], "end": [34, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.TermInfo", "code": "structure TermInfo extends ElabInfo where\n  lctx : LocalContext expectedType? : Option Expr\n  expr : Expr\n  isBinder : Bool := false\n  deriving Inhabited", "start": [36, 1], "end": [41, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.CommandInfo", "code": "structure CommandInfo extends ElabInfo where\n  deriving Inhabited", "start": [43, 1], "end": [44, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.CompletionInfo", "code": "inductive CompletionInfo where\n  | dot (termInfo : TermInfo) (field? : Option Syntax) (expectedType? : Option Expr)\n  | id (stx : Syntax) (id : Name) (danglingDot : Bool) (lctx : LocalContext) (expectedType? : Option Expr)\n  | dotId (stx : Syntax) (id : Name) (lctx : LocalContext) (expectedType? : Option Expr)\n  | fieldId (stx : Syntax) (id : Name) (lctx : LocalContext) (structName : Name)\n  | namespaceId (stx : Syntax)\n  | option (stx : Syntax)\n  | endSection (stx : Syntax) (scopeNames : List String)\n  | tactic (stx : Syntax) (goals : List MVarId)", "start": [46, 1], "end": [56, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.OptionInfo", "code": "structure OptionInfo where\n  stx : Syntax\n  optionName : Name\n  declName : Name", "start": [59, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.FieldInfo", "code": "structure FieldInfo where\n  \n  projName  : Name\n  \n  fieldName : Name\n  lctx      : LocalContext\n  val       : Expr\n  stx       : Syntax\n  deriving Inhabited", "start": [65, 1], "end": [73, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.TacticInfo", "code": "structure TacticInfo extends ElabInfo where\n  mctxBefore  : MetavarContext\n  goalsBefore : List MVarId\n  mctxAfter   : MetavarContext\n  goalsAfter  : List MVarId\n  deriving Inhabited", "start": [75, 1], "end": [85, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.MacroExpansionInfo", "code": "structure MacroExpansionInfo where\n  lctx   : LocalContext stx    : Syntax\n  output : Syntax\n  deriving Inhabited", "start": [87, 1], "end": [91, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.CustomInfo", "code": "structure CustomInfo where\n  stx : Syntax\n  value : Dynamic", "start": [93, 1], "end": [96, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.UserWidgetInfo", "code": "structure UserWidgetInfo where\n  stx : Syntax\n  \n  widgetId : Name\n  \n  props : Json\n  deriving Inhabited", "start": [98, 1], "end": [108, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.FVarAliasInfo", "code": "structure FVarAliasInfo where\n  userName : Name\n  id     : FVarId\n  baseId : FVarId", "start": [110, 1], "end": [119, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.FieldRedeclInfo", "code": "structure FieldRedeclInfo where\n  stx : Syntax", "start": [121, 1], "end": [131, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info", "code": "inductive Info where\n  | ofTacticInfo (i : TacticInfo)\n  | ofTermInfo (i : TermInfo)\n  | ofCommandInfo (i : CommandInfo)\n  | ofMacroExpansionInfo (i : MacroExpansionInfo)\n  | ofOptionInfo (i : OptionInfo)\n  | ofFieldInfo (i : FieldInfo)\n  | ofCompletionInfo (i : CompletionInfo)\n  | ofUserWidgetInfo (i : UserWidgetInfo)\n  | ofCustomInfo (i : CustomInfo)\n  | ofFVarAliasInfo (i : FVarAliasInfo)\n  | ofFieldRedeclInfo (i : FieldRedeclInfo)\n  deriving Inhabited", "start": [133, 1], "end": [146, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree", "code": "inductive InfoTree where\n  \n  | context (i : ContextInfo) (t : InfoTree)\n  \n  | node (i : Info) (children : PersistentArray InfoTree)\n  \n  | hole (mvarId : MVarId)\n  deriving Inhabited", "start": [148, 1], "end": [176, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoState", "code": "structure InfoState where\n  \n  enabled    : Bool := true\n  \n  assignment : PersistentHashMap MVarId InfoTree := {}\n  \n  trees      : PersistentArray InfoTree := {}\n  deriving Inhabited", "start": [178, 1], "end": [195, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.MonadInfoTree", "code": "class MonadInfoTree (m : Type \u2192 Type)  where\n  getInfoState    : m InfoState\n  modifyInfoState : (InfoState \u2192 InfoState) \u2192 m Unit", "start": [197, 1], "end": [199, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.setInfoState", "code": "def setInfoState [MonadInfoTree m] (s : InfoState) : m Unit :=\n  modifyInfoState fun _ => s", "start": [207, 1], "end": [208, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/Sorry.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/FindExpr.lean", "lake-packages/lean4/src/lean/Lean/Declaration.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.isSorry", "code": "def Expr.isSorry : Expr \u2192 Bool\n  | app (app (.const ``sorryAx ..) ..) .. => true\n  | _ => false", "start": [11, 1], "end": [13, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isSyntheticSorry", "code": "def Expr.isSyntheticSorry : Expr \u2192 Bool\n  | app (app (const ``sorryAx ..) ..) (const ``Bool.true ..) => true\n  | _ => false", "start": [15, 1], "end": [17, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isNonSyntheticSorry", "code": "def Expr.isNonSyntheticSorry : Expr \u2192 Bool\n  | app (app (const ``sorryAx ..) ..) (const ``Bool.false ..) => true\n  | _ => false", "start": [19, 1], "end": [21, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasSorry", "code": "def Expr.hasSorry (e : Expr) : Bool :=\n  Option.isSome <| e.find? (\u00b7.isConstOf ``sorryAx)", "start": [23, 1], "end": [24, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasSyntheticSorry", "code": "def Expr.hasSyntheticSorry (e : Expr) : Bool :=\n  Option.isSome <| e.find? (\u00b7.isSyntheticSorry)", "start": [26, 1], "end": [27, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.hasNonSyntheticSorry", "code": "def Expr.hasNonSyntheticSorry (e : Expr) : Bool :=\n  Option.isSome <| e.find? (\u00b7.isNonSyntheticSorry)", "start": [29, 1], "end": [30, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Declaration.hasSorry", "code": "def Declaration.hasSorry (d : Declaration) : Bool := Id.run do\n  d.foldExprM (fun r e => r || e.hasSorry) false", "start": [32, 1], "end": [33, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Declaration.hasNonSyntheticSorry", "code": "def Declaration.hasNonSyntheticSorry (d : Declaration) : Bool := Id.run do\n  d.foldExprM (fun r e => r || e.hasNonSyntheticSorry) false", "start": [35, 1], "end": [36, 61], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/PPExt.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/OpenDecl.lean", "lake-packages/lean4/src/lean/Lean/MetavarContext.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Types.lean"], "premises": [{"full_name": "Lean.PPContext", "code": "structure PPContext where\n  env           : Environment\n  mctx          : MetavarContext := {}\n  lctx          : LocalContext := {}\n  opts          : Options := {}\n  currNamespace : Name := Name.anonymous\n  openDecls     : List OpenDecl := []", "start": [33, 1], "end": [39, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.InfoPerPos", "code": "abbrev PrettyPrinter.InfoPerPos := RBMap Nat Elab.Info compare", "start": [41, 1], "end": [41, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.FormatWithInfos", "code": "structure FormatWithInfos where\n  fmt : Format\n  infos : PrettyPrinter.InfoPerPos", "start": [42, 1], "end": [44, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.PPFns", "code": "structure PPFns where\n  ppExprWithInfos : PPContext \u2192 Expr \u2192 IO FormatWithInfos\n  ppTerm : PPContext \u2192 Term \u2192 IO Format\n  ppGoal : PPContext \u2192 MVarId \u2192 IO Format\n  deriving Inhabited", "start": [48, 1], "end": [52, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ppExprWithInfos", "code": "def ppExprWithInfos (ctx : PPContext) (e : Expr) : IO FormatWithInfos := do\n  let e := instantiateMVarsCore ctx.mctx e |>.1\n  if pp.raw.get ctx.opts then\n    return format (toString e)\n  else\n    try\n      ppExt.getState ctx.env |>.ppExprWithInfos ctx e\n    catch ex =>\n      if pp.rawOnError.get ctx.opts then\n        pure f!\"[Error pretty printing expression: {ex}. Falling back to raw printer.]{Format.line}{e}\"\n      else\n        pure f!\"failed to pretty print expression (use 'set_option pp.rawOnError true' for raw representation)\"", "start": [64, 1], "end": [75, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.ppTerm", "code": "def ppTerm (ctx : PPContext) (stx : Term) : IO Format :=\n  let fmtRaw := fun () => stx.raw.formatStx (some <| pp.raw.maxDepth.get ctx.opts) (pp.raw.showInfo.get ctx.opts)\n  if pp.raw.get ctx.opts then\n    return fmtRaw ()\n  else\n    try\n      ppExt.getState ctx.env |>.ppTerm ctx stx\n    catch ex =>\n      if pp.rawOnError.get ctx.opts then\n        pure f!\"[Error pretty printing syntax: {ex}. Falling back to raw printer.]{Format.line}{fmtRaw ()}\"\n      else\n        pure f!\"failed to pretty print term (use 'set_option pp.rawOnError true' for raw representation)\"", "start": [77, 1], "end": [88, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.ppGoal", "code": "def ppGoal (ctx : PPContext) (mvarId : MVarId) : IO Format :=\n    ppExt.getState ctx.env |>.ppGoal ctx mvarId", "start": [90, 1], "end": [91, 48], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Message.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Util/PPExt.lean", "lake-packages/lean4/src/lean/Lean/Data/OpenDecl.lean", "lake-packages/lean4/src/lean/Lean/Data/Position.lean", "lake-packages/lean4/src/lean/Lean/MetavarContext.lean", "lake-packages/lean4/src/lean/Lean/Util/Sorry.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean"], "premises": [{"full_name": "Lean.mkErrorStringWithPos", "code": "def mkErrorStringWithPos (fileName : String) (pos : Position) (msg : String) (endPos : Option Position := none) : String :=\n  let endPos := match endPos with\n    | some endPos => s!\"-{endPos.line}:{endPos.column}\"\n    | none        => \"\"\n  s!\"{fileName}:{pos.line}:{pos.column}{endPos}: {msg}\"", "start": [17, 1], "end": [21, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageSeverity", "code": "inductive MessageSeverity where\n  | information | warning | error\n  deriving Inhabited, BEq", "start": [23, 1], "end": [25, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageDataContext", "code": "structure MessageDataContext where\n  env  : Environment\n  mctx : MetavarContext\n  lctx : LocalContext\n  opts : Options", "start": [27, 1], "end": [31, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.NamingContext", "code": "structure NamingContext where\n  currNamespace : Name\n  openDecls : List OpenDecl", "start": [33, 1], "end": [39, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.PPFormat", "code": "structure PPFormat where\n  \n  pp : Option PPContext \u2192 IO FormatWithInfos\n  \n  hasSyntheticSorry : MetavarContext \u2192 Bool := fun _ => false", "start": [41, 1], "end": [46, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData", "code": "inductive MessageData where\n  \n  | ofFormat          : Format \u2192 MessageData\n  \n  | ofPPFormat        : PPFormat \u2192 MessageData\n  | ofGoal            : MVarId \u2192 MessageData\n  \n  | withContext       : MessageDataContext \u2192 MessageData \u2192 MessageData\n  | withNamingContext : NamingContext \u2192 MessageData \u2192 MessageData\n  \n  |  nest              : Nat \u2192 MessageData \u2192 MessageData\n  \n  |  group             : MessageData \u2192 MessageData\n  \n  |  compose           : MessageData \u2192 MessageData \u2192 MessageData\n  \n  | tagged            : Name \u2192 MessageData \u2192 MessageData\n  | trace (cls : Name) (msg : MessageData) (children : Array MessageData)\n    (collapsed : Bool := false)\n  deriving Inhabited", "start": [48, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.isEmpty", "code": "def isEmpty : MessageData \u2192 Bool\n  | ofFormat f => f.isEmpty\n  | withContext _ m => m.isEmpty\n  | withNamingContext _ m => m.isEmpty\n  | nest _ m => m.isEmpty\n  | group m => m.isEmpty\n  | compose m\u2081 m\u2082 => m\u2081.isEmpty && m\u2082.isEmpty\n  | tagged _ m => m.isEmpty\n  | _ => false", "start": [73, 1], "end": [82, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.hasTag", "code": "partial def hasTag : MessageData \u2192 Bool\n  | withContext _ msg       => hasTag msg\n  | withNamingContext _ msg => hasTag msg\n  | nest _ msg              => hasTag msg\n  | group msg               => hasTag msg\n  | compose msg\u2081 msg\u2082       => hasTag msg\u2081 || hasTag msg\u2082\n  | tagged n msg            => p n || hasTag msg\n  | trace cls msg msgs _    => p cls || hasTag msg || msgs.any hasTag\n  | _                       => false", "start": [85, 1], "end": [94, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.nil", "code": "def nil : MessageData :=\n  ofFormat Format.nil", "start": [96, 1], "end": [98, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.mkPPContext", "code": "def mkPPContext (nCtx : NamingContext) (ctx : MessageDataContext) : PPContext := {\n  env := ctx.env, mctx := ctx.mctx, lctx := ctx.lctx, opts := ctx.opts,\n  currNamespace := nCtx.currNamespace, openDecls := nCtx.openDecls\n}", "start": [100, 1], "end": [103, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.ofSyntax", "code": "def ofSyntax (stx : Syntax) : MessageData :=\n  let stx := stx.copyHeadTailInfoFrom .missing\n  .ofPPFormat {\n    pp := fun\n      | some ctx => ppTerm ctx \u27e8stx\u27e9  | none     => return stx.formatStx\n  }", "start": [105, 1], "end": [112, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.ofExpr", "code": "def ofExpr (e : Expr) : MessageData :=\n  .ofPPFormat {\n    pp := fun\n      | some ctx => ppExprWithInfos ctx e\n      | none     => return format (toString e)\n    hasSyntheticSorry := (instantiateMVarsCore \u00b7 e |>.1.hasSyntheticSorry)\n  }", "start": [114, 1], "end": [120, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.ofLevel", "code": "def ofLevel (l : Level) : MessageData := ofFormat (format l)", "start": [122, 1], "end": [122, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.ofName", "code": "def ofName (n : Name) : MessageData := ofFormat (format n)", "start": [123, 1], "end": [123, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.hasSyntheticSorry", "code": "partial def hasSyntheticSorry (msg : MessageData) : Bool :=\n  visit none msg\nwhere\n  visit (mctx? : Option MetavarContext) : MessageData \u2192 Bool\n  | ofPPFormat f            => f.hasSyntheticSorry (mctx?.getD {})\n  | withContext ctx msg     => visit ctx.mctx msg\n  | withNamingContext _ msg => visit mctx? msg\n  | nest _ msg              => visit mctx? msg\n  | group msg               => visit mctx? msg\n  | compose msg\u2081 msg\u2082       => visit mctx? msg\u2081 || visit mctx? msg\u2082\n  | tagged _ msg            => visit mctx? msg\n  | trace _ msg msgs _      => visit mctx? msg || msgs.any (visit mctx?)\n  | _                       => false", "start": [125, 1], "end": [137, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.formatAux", "code": "partial def formatAux : NamingContext \u2192 Option MessageDataContext \u2192 MessageData \u2192 IO Format\n  | _,    _,         ofFormat fmt             => return fmt\n  | nCtx, ctx?,      ofPPFormat f             => (\u00b7.fmt) <$> f.pp (ctx?.map (mkPPContext nCtx))\n  | _,    none,      ofGoal mvarId            => return \"goal \" ++ format (mkMVar mvarId)\n  | nCtx, some ctx,  ofGoal mvarId            => ppGoal (mkPPContext nCtx ctx) mvarId\n  | nCtx, _,         withContext ctx d        => formatAux nCtx ctx d\n  | _,    ctx,       withNamingContext nCtx d => formatAux nCtx ctx d\n  | nCtx, ctx,       tagged _ d               => formatAux nCtx ctx d\n  | nCtx, ctx,       nest n d                 => Format.nest n <$> formatAux nCtx ctx d\n  | nCtx, ctx,       compose d\u2081 d\u2082            => return (\u2190 formatAux nCtx ctx d\u2081) ++ (\u2190 formatAux nCtx ctx d\u2082)\n  | nCtx, ctx,       group d                  => Format.group <$> formatAux nCtx ctx d\n  | nCtx, ctx,       trace cls header children _ => do\n    let msg := f!\"[{cls}] {(\u2190 formatAux nCtx ctx header).nest 2}\"\n    let children \u2190 children.mapM (formatAux nCtx ctx)\n    return .nest 2 (.joinSep (msg::children.toList) \"\\n\")", "start": [139, 1], "end": [153, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.format", "code": "protected def format (msgData : MessageData) : IO Format :=\n  formatAux { currNamespace := Name.anonymous, openDecls := [] } none msgData", "start": [155, 1], "end": [156, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.toString", "code": "protected def toString (msgData : MessageData) : IO String := do\n  return toString (\u2190 msgData.format)", "start": [158, 1], "end": [159, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.arrayExpr.toMessageData", "code": "partial def arrayExpr.toMessageData (es : Array Expr) (i : Nat) (acc : MessageData) : MessageData :=\n  if h : i < es.size then\n    let e   := es.get \u27e8i, h\u27e9;\n    let acc := if i == 0 then acc ++ ofExpr e else acc ++ \", \" ++ ofExpr e;\n    toMessageData es (i+1) acc\n  else\n    acc ++ \"]\"", "start": [172, 1], "end": [178, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.bracket", "code": "def bracket (l : String) (f : MessageData) (r : String) : MessageData := group (nest l.length <| l ++ f ++ r)", "start": [182, 1], "end": [183, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.paren", "code": "def paren (f : MessageData) : MessageData := bracket \"(\" f \")\"", "start": [184, 1], "end": [185, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.sbracket", "code": "def sbracket (f : MessageData) : MessageData := bracket \"[\" f \"]\"", "start": [186, 1], "end": [187, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.joinSep", "code": "def joinSep : List MessageData \u2192 MessageData \u2192 MessageData\n  | [],    _   => Format.nil\n  | [a],   _   => a\n  | a::as, sep => a ++ sep ++ joinSep as sep", "start": [188, 1], "end": [192, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.ofList", "code": "def ofList : List MessageData \u2192 MessageData\n  | [] => \"[]\"\n  | xs => sbracket <| joinSep xs (ofFormat \",\" ++ Format.line)", "start": [194, 1], "end": [197, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.ofArray", "code": "def ofArray (msgs : Array MessageData) : MessageData :=\n  ofList msgs.toList", "start": [199, 1], "end": [201, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Message", "code": "structure Message where\n  fileName      : String\n  pos           : Position\n  endPos        : Option Position := none\n  \n  keepFullRange : Bool := false\n  severity      : MessageSeverity := MessageSeverity.error\n  caption       : String          := \"\"\n  \n  data          : MessageData\n  deriving Inhabited", "start": [208, 1], "end": [220, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Message.toString", "code": "protected def toString (msg : Message) (includeEndPos := false) : IO String := do\n  let mut str \u2190 msg.data.toString\n  let endPos := if includeEndPos then msg.endPos else none\n  unless msg.caption == \"\" do\n    str := msg.caption ++ \":\\n\" ++ str\n  match msg.severity with\n  | MessageSeverity.information => pure ()\n  | MessageSeverity.warning     => str := mkErrorStringWithPos msg.fileName msg.pos (endPos := endPos) \"warning: \" ++ str\n  | MessageSeverity.error       => str := mkErrorStringWithPos msg.fileName msg.pos (endPos := endPos) \"error: \" ++ str\n  if str.isEmpty || str.back != '\\n' then\n    str := str ++ \"\\n\"\n  return str", "start": [224, 1], "end": [235, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog", "code": "structure MessageLog where\n  msgs : PersistentArray Message := {}\n  deriving Inhabited", "start": [239, 1], "end": [242, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog.empty", "code": "def empty : MessageLog := \u27e8{}\u27e9", "start": [245, 1], "end": [245, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog.isEmpty", "code": "def isEmpty (log : MessageLog) : Bool :=\n  log.msgs.isEmpty", "start": [247, 1], "end": [248, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog.add", "code": "def add (msg : Message) (log : MessageLog) : MessageLog :=\n  \u27e8log.msgs.push msg\u27e9", "start": [250, 1], "end": [251, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog.append", "code": "protected def append (l\u2081 l\u2082 : MessageLog) : MessageLog :=\n  \u27e8l\u2081.msgs ++ l\u2082.msgs\u27e9", "start": [253, 1], "end": [254, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog.hasErrors", "code": "def hasErrors (log : MessageLog) : Bool :=\n  log.msgs.any fun m => match m.severity with\n    | MessageSeverity.error => true\n    | _                     => false", "start": [259, 1], "end": [262, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog.errorsToWarnings", "code": "def errorsToWarnings (log : MessageLog) : MessageLog :=\n  { msgs := log.msgs.map (fun m => match m.severity with | MessageSeverity.error => { m with severity := MessageSeverity.warning } | _ => m) }", "start": [264, 1], "end": [265, 143], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog.getInfoMessages", "code": "def getInfoMessages (log : MessageLog) : MessageLog :=\n  { msgs := log.msgs.filter fun m => match m.severity with | MessageSeverity.information => true | _ => false }", "start": [267, 1], "end": [268, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog.forM", "code": "def forM {m : Type \u2192 Type} [Monad m] (log : MessageLog) (f : Message \u2192 m Unit) : m Unit :=\n  log.msgs.forM f", "start": [270, 1], "end": [271, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageLog.toList", "code": "def toList (log : MessageLog) : List Message :=\n  (log.msgs.foldl (fun acc msg => msg :: acc) []).reverse", "start": [273, 1], "end": [274, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.nestD", "code": "def MessageData.nestD (msg : MessageData) : MessageData :=\n  MessageData.nest 2 msg", "start": [278, 1], "end": [279, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.indentD", "code": "def indentD (msg : MessageData) : MessageData :=\n  MessageData.nestD (Format.line ++ msg)", "start": [281, 1], "end": [282, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.indentExpr", "code": "def indentExpr (e : Expr) : MessageData :=\n  indentD e", "start": [284, 1], "end": [285, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.AddMessageContext", "code": "class AddMessageContext (m : Type \u2192 Type) where\n  addMessageContext : MessageData \u2192 m MessageData", "start": [287, 1], "end": [288, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.addMessageContextPartial", "code": "def addMessageContextPartial {m} [Monad m] [MonadEnv m] [MonadOptions m] (msgData : MessageData) : m MessageData := do\n  let env \u2190 getEnv\n  let opts \u2190 getOptions\n  return MessageData.withContext { env := env, mctx := {}, lctx := {}, opts := opts } msgData", "start": [295, 1], "end": [298, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.addMessageContextFull", "code": "def addMessageContextFull {m} [Monad m] [MonadEnv m] [MonadMCtx m] [MonadLCtx m] [MonadOptions m] (msgData : MessageData) : m MessageData := do\n  let env \u2190 getEnv\n  let mctx \u2190 getMCtx\n  let lctx \u2190 getLCtx\n  let opts \u2190 getOptions\n  return MessageData.withContext { env := env, mctx := mctx, lctx := lctx, opts := opts } msgData", "start": [300, 1], "end": [305, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.ToMessageData", "code": "class ToMessageData (\u03b1 : Type) where\n  toMessageData : \u03b1 \u2192 MessageData", "start": [307, 1], "end": [308, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.stringToMessageData", "code": "def stringToMessageData (str : String) : MessageData :=\n  let lines := str.split (\u00b7 == '\\n')\n  let lines := lines.map (MessageData.ofFormat \u2218 format)\n  MessageData.joinSep lines (MessageData.ofFormat Format.line)", "start": [312, 1], "end": [315, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.toMessageList", "code": "def toMessageList (msgs : Array MessageData) : MessageData :=\n  indentD (MessageData.joinSep msgs.toList m!\"\\n\\n\")", "start": [340, 1], "end": [341, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.KernelException.mkCtx", "code": "private def mkCtx (env : Environment) (lctx : LocalContext) (opts : Options) (msg : MessageData) : MessageData :=\n  MessageData.withContext { env := env, mctx := {}, lctx := lctx, opts := opts } msg", "start": [345, 1], "end": [346, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.KernelException.toMessageData", "code": "def toMessageData (e : KernelException) (opts : Options) : MessageData :=\n  match e with\n  | unknownConstant env constName       => mkCtx env {} opts m!\"(kernel) unknown constant '{constName}'\"\n  | alreadyDeclared env constName       => mkCtx env {} opts m!\"(kernel) constant has already been declared '{constName}'\"\n  | declTypeMismatch env decl givenType =>\n    mkCtx env {} opts <|\n    let process (n : Name) (expectedType : Expr) : MessageData :=\n      m!\"(kernel) declaration type mismatch, '{n}' has type{indentExpr givenType}\\nbut it is expected to have type{indentExpr expectedType}\";\n    match decl with\n    | Declaration.defnDecl { name := n, type := type, .. } => process n type\n    | Declaration.thmDecl { name := n, type := type, .. }  => process n type\n    | _ => \"(kernel) declaration type mismatch\" | declHasMVars env constName _        => mkCtx env {} opts m!\"(kernel) declaration has metavariables '{constName}'\"\n  | declHasFVars env constName _        => mkCtx env {} opts m!\"(kernel) declaration has free variables '{constName}'\"\n  | funExpected env lctx e              => mkCtx env lctx opts m!\"(kernel) function expected{indentExpr e}\"\n  | typeExpected env lctx e             => mkCtx env lctx opts m!\"(kernel) type expected{indentExpr e}\"\n  | letTypeMismatch  env lctx n _ _     => mkCtx env lctx opts m!\"(kernel) let-declaration type mismatch '{n}'\"\n  | exprTypeMismatch env lctx e _       => mkCtx env lctx opts m!\"(kernel) type mismatch at{indentExpr e}\"\n  | appTypeMismatch  env lctx e fnType argType =>\n    mkCtx env lctx opts m!\"application type mismatch{indentExpr e}\\nargument has type{indentExpr argType}\\nbut function has type{indentExpr fnType}\"\n  | invalidProj env lctx e              => mkCtx env lctx opts m!\"(kernel) invalid projection{indentExpr e}\"\n  | other msg                           => m!\"(kernel) {msg}\"\n  | deterministicTimeout                => \"(kernel) deterministic timeout\"\n  | excessiveMemory                     => \"(kernel) excessive memory consumption detected\"\n  | deepRecursion                       => \"(kernel) deep recursion detected\"", "start": [348, 1], "end": [372, 78], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/InternalExceptionId.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.InternalExceptionId", "code": "structure InternalExceptionId where\n  idx : Nat := 0\n  deriving Inhabited, BEq", "start": [8, 1], "end": [11, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.registerInternalExceptionId", "code": "def registerInternalExceptionId (name : Name) : IO InternalExceptionId := do\n  let exs \u2190 internalExceptionsRef.get\n  if exs.contains name then throw <| IO.userError s!\"invalid internal exception id, '{name}' has already been used\"\n  let nextIdx := exs.size\n  internalExceptionsRef.modify fun a => a.push name\n  pure { idx := nextIdx }", "start": [16, 1], "end": [27, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.InternalExceptionId.toString", "code": "def InternalExceptionId.toString (id : InternalExceptionId) : String :=\n  s!\"internal exception #{id.idx}\"", "start": [29, 1], "end": [31, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.InternalExceptionId.getName", "code": "def InternalExceptionId.getName (id : InternalExceptionId) : IO Name :=  do\n  let exs \u2190 internalExceptionsRef.get\n  let i := id.idx;\n  if h : i < exs.size then\n    return exs.get \u27e8i, h\u27e9\n  else\n    throw <| IO.userError \"invalid internal exception id\"", "start": [33, 1], "end": [40, 58], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Exception.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/MonadCache.lean", "lake-packages/lean4/src/lean/Lean/InternalExceptionId.lean", "lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Message.lean"], "premises": [{"full_name": "Lean.Exception", "code": "inductive Exception where\n  \n  | error (ref : Syntax) (msg : MessageData)\n  \n  | internal (id : InternalExceptionId) (extra : KVMap := {})", "start": [13, 1], "end": [21, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Exception.toMessageData", "code": "def Exception.toMessageData : Exception \u2192 MessageData\n  | .error _ msg   => msg\n  | .internal id _ => id.toString", "start": [23, 1], "end": [26, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Exception.hasSyntheticSorry", "code": "def Exception.hasSyntheticSorry : Exception \u2192 Bool\n  | Exception.error _ msg => msg.hasSyntheticSorry\n  | _                     => false", "start": [28, 1], "end": [30, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Exception.getRef", "code": "def Exception.getRef : Exception \u2192 Syntax\n  | .error ref _  => ref\n  | .internal _ _ => Syntax.missing", "start": [32, 1], "end": [38, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.AddErrorMessageContext", "code": "class AddErrorMessageContext (m : Type \u2192 Type) where\n  add : Syntax \u2192 MessageData \u2192 m (Syntax \u00d7 MessageData)", "start": [42, 1], "end": [47, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.throwError", "code": "protected def throwError [Monad m] [MonadError m] (msg : MessageData) : m \u03b1 := do\n  let ref \u2190 getRef\n  let (ref, msg) \u2190 AddErrorMessageContext.add ref msg\n  throw <| Exception.error ref msg", "start": [61, 1], "end": [69, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.throwUnknownConstant", "code": "def throwUnknownConstant [Monad m] [MonadError m] (constName : Name) : m \u03b1 :=\n  Lean.throwError m!\"unknown constant '{mkConst constName}'\"", "start": [71, 1], "end": [73, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.throwErrorAt", "code": "protected def throwErrorAt [Monad m] [MonadError m] (ref : Syntax) (msg : MessageData) : m \u03b1 := do\n  withRef ref <| Lean.throwError msg", "start": [75, 1], "end": [77, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.ofExcept", "code": "def ofExcept [Monad m] [MonadError m] [ToString \u03b5] (x : Except \u03b5 \u03b1) : m \u03b1 :=\n  match x with\n  | .ok a    => return a\n  | .error e => Lean.throwError <| toString e", "start": [79, 1], "end": [86, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.throwKernelException", "code": "def throwKernelException [Monad m] [MonadError m] [MonadOptions m] (ex : KernelException) : m \u03b1 := do\n  Lean.throwError <| ex.toMessageData (\u2190 getOptions)", "start": [88, 1], "end": [92, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.ofExceptKernelException", "code": "def ofExceptKernelException [Monad m] [MonadError m] [MonadOptions m] (x : Except KernelException \u03b1) : m \u03b1 :=\n  match x with\n  | .ok a    => return a\n  | .error e => throwKernelException e", "start": [94, 1], "end": [98, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadRecDepth", "code": "class MonadRecDepth (m : Type \u2192 Type) where\n  withRecDepth {\u03b1} : Nat \u2192 m \u03b1 \u2192 m \u03b1\n  getRecDepth      : m Nat\n  getMaxRecDepth   : m Nat", "start": [102, 1], "end": [105, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.throwMaxRecDepthAt", "code": "def throwMaxRecDepthAt [MonadError m] (ref : Syntax) : m \u03b1 :=\n  throw <| .error ref (MessageData.ofFormat (Std.Format.text maxRecDepthErrorMessage))", "start": [118, 1], "end": [122, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Exception.isMaxRecDepth", "code": "def Exception.isMaxRecDepth (ex : Exception) : Bool :=\n  match ex with\n  | error _ (MessageData.ofFormat (Std.Format.text msg)) => msg == maxRecDepthErrorMessage\n  | _ => false", "start": [124, 1], "end": [133, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.withIncRecDepth", "code": "@[inline] def withIncRecDepth [Monad m] [MonadError m] [MonadRecDepth m] (x : m \u03b1) : m \u03b1 := do\n  let curr \u2190 MonadRecDepth.getRecDepth\n  let max  \u2190 MonadRecDepth.getMaxRecDepth\n  if curr == max then\n    throwMaxRecDepthAt (\u2190 getRef)\n  else\n    MonadRecDepth.withRecDepth (curr+1) x", "start": [135, 1], "end": [146, 42], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Modifiers.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.addProtected", "code": "@[export lean_add_protected]\ndef addProtected (env : Environment) (n : Name) : Environment :=\n  protectedExt.tag env n", "start": [12, 1], "end": [14, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.isProtected", "code": "@[export lean_is_protected]\ndef isProtected (env : Environment) (n : Name) : Bool :=\n  protectedExt.isTagged env n", "start": [16, 1], "end": [18, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.privateHeader", "code": "def privateHeader : Name := `_private", "start": [31, 1], "end": [31, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.mkPrivateName", "code": "def mkPrivateName (env : Environment) (n : Name) : Name :=\n  Name.mkNum (privateHeader ++ env.mainModule) 0 ++ n", "start": [33, 1], "end": [34, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.isPrivateName", "code": "def isPrivateName : Name \u2192 Bool\n  | n@(.str p _) => n == privateHeader || isPrivateName p\n  | .num p _     => isPrivateName p\n  | _            => false", "start": [36, 1], "end": [39, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.isPrivateNameExport", "code": "@[export lean_is_private_name]\ndef isPrivateNameExport (n : Name) : Bool :=\n  isPrivateName n", "start": [41, 1], "end": [43, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.isPrivatePrefix", "code": "private def isPrivatePrefix (n : Name) : Bool :=\n  match n with\n  | .num p 0 => go p\n  | _ => false\nwhere\n  go (n : Name) : Bool :=\n    n == privateHeader ||\n    match n with\n    | .str p _ => go p\n    | _ => false", "start": [45, 1], "end": [58, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.privateToUserNameAux", "code": "private def privateToUserNameAux (n : Name) : Name :=\n  match n with\n  | .str p s => .str (privateToUserNameAux p) s\n  | .num p i => if isPrivatePrefix n then .anonymous else .num (privateToUserNameAux p) i\n  | _        => .anonymous", "start": [60, 1], "end": [64, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.privateToUserName?", "code": "@[export lean_private_to_user_name]\ndef privateToUserName? (n : Name) : Option Name :=\n  if isPrivateName n then privateToUserNameAux n\n  else none", "start": [66, 1], "end": [69, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.isPrivateNameFromImportedModule", "code": "def isPrivateNameFromImportedModule (env : Environment) (n : Name) : Bool :=\n  match privateToUserName? n with\n  | some userName => mkPrivateName env userName != n\n  | _ => false", "start": [71, 1], "end": [74, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.privatePrefixAux", "code": "private def privatePrefixAux : Name \u2192 Name\n  | .str p _ => privatePrefixAux p\n  | n        => n", "start": [76, 1], "end": [78, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.privatePrefix?", "code": "@[export lean_private_prefix]\ndef privatePrefix? (n : Name) : Option Name :=\n  if isPrivateName n then privatePrefixAux n\n  else none", "start": [80, 1], "end": [83, 12], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/AuxRecursor.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.casesOnSuffix", "code": "def casesOnSuffix       := \"casesOn\"", "start": [10, 1], "end": [10, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.recOnSuffix", "code": "def recOnSuffix         := \"recOn\"", "start": [11, 1], "end": [11, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.brecOnSuffix", "code": "def brecOnSuffix        := \"brecOn\"", "start": [12, 1], "end": [12, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.binductionOnSuffix", "code": "def binductionOnSuffix  := \"binductionOn\"", "start": [13, 1], "end": [13, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.belowSuffix", "code": "def belowSuffix         := \"below\"", "start": [14, 1], "end": [14, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.mkCasesOnName", "code": "def mkCasesOnName (indDeclName : Name) : Name := Name.mkStr indDeclName casesOnSuffix", "start": [16, 1], "end": [16, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRecOnName", "code": "def mkRecOnName (indDeclName : Name) : Name   := Name.mkStr indDeclName recOnSuffix", "start": [17, 1], "end": [17, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBRecOnName", "code": "def mkBRecOnName (indDeclName : Name) : Name  := Name.mkStr indDeclName brecOnSuffix", "start": [18, 1], "end": [18, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBInductionOnName", "code": "def mkBInductionOnName (indDeclName : Name) : Name  := Name.mkStr indDeclName binductionOnSuffix", "start": [19, 1], "end": [19, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBelowName", "code": "def mkBelowName (indDeclName : Name) : Name := Name.mkStr indDeclName belowSuffix", "start": [20, 1], "end": [20, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.markAuxRecursor", "code": "@[export lean_mark_aux_recursor]\ndef markAuxRecursor (env : Environment) (declName : Name) : Environment :=\n  auxRecExt.tag env declName", "start": [24, 1], "end": [26, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.isAuxRecursor", "code": "@[export lean_is_aux_recursor]\ndef isAuxRecursor (env : Environment) (declName : Name) : Bool :=\n  auxRecExt.isTagged env declName\n  || declName == ``Eq.ndrec\n  || declName == ``Eq.ndrecOn", "start": [28, 1], "end": [34, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.isAuxRecursorWithSuffix", "code": "def isAuxRecursorWithSuffix (env : Environment) (declName : Name) (suffix : Name) : Bool :=\n  match declName with\n  | .str _ s => s == suffix && isAuxRecursor env declName\n  | _ => false", "start": [36, 1], "end": [39, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.isCasesOnRecursor", "code": "def isCasesOnRecursor (env : Environment) (declName : Name) : Bool :=\n  isAuxRecursorWithSuffix env declName casesOnSuffix", "start": [41, 1], "end": [42, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.isRecOnRecursor", "code": "def isRecOnRecursor (env : Environment) (declName : Name) : Bool :=\n  isAuxRecursorWithSuffix env declName recOnSuffix", "start": [44, 1], "end": [45, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.isBRecOnRecursor", "code": "def isBRecOnRecursor (env : Environment) (declName : Name) : Bool :=\n  isAuxRecursorWithSuffix env declName brecOnSuffix", "start": [47, 1], "end": [48, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.markNoConfusion", "code": "@[export lean_mark_no_confusion]\ndef markNoConfusion (env : Environment) (n : Name) : Environment :=\n  noConfusionExt.tag env n", "start": [52, 1], "end": [54, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.isNoConfusion", "code": "@[export lean_is_no_confusion]\ndef isNoConfusion (env : Environment) (n : Name) : Bool :=\n  noConfusionExt.isTagged env n", "start": [56, 1], "end": [58, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/Old.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.mkEagerLambdaLiftingName", "code": "@[export lean_mk_eager_lambda_lifting_name]\ndef mkEagerLambdaLiftingName (n : Name) (idx : Nat) : Name :=\n  Name.mkStr n (\"_elambda_\" ++ toString idx)", "start": [13, 1], "end": [15, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.isEagerLambdaLiftingName", "code": "@[export lean_is_eager_lambda_lifting_name]\ndef isEagerLambdaLiftingName : Name \u2192 Bool\n  | .str p s => \"_elambda\".isPrefixOf s || isEagerLambdaLiftingName p\n  | .num p _ => isEagerLambdaLiftingName p\n  | _        => false", "start": [17, 1], "end": [21, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.getDeclNamesForCodeGen", "code": "def getDeclNamesForCodeGen : Declaration \u2192 List Name\n  | Declaration.defnDecl { name := n, .. }   => [n]\n  | Declaration.mutualDefnDecl defs          => defs.map fun d => d.name\n  | Declaration.opaqueDecl { name := n, .. } => [n]\n  | Declaration.axiomDecl { name := n, .. }  => [n] | _                                        => []", "start": [23, 1], "end": [31, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.checkIsDefinition", "code": "def checkIsDefinition (env : Environment) (n : Name) : Except String Unit :=\nmatch env.find? n with\n  | (some (ConstantInfo.defnInfo _))   => Except.ok ()\n  | (some (ConstantInfo.opaqueInfo _)) => Except.ok ()\n  | none => Except.error s!\"unknow declaration '{n}'\"\n  | _    => Except.error s!\"declaration is not a definition '{n}'\"", "start": [33, 1], "end": [38, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.mkUnsafeRecName", "code": "@[export lean_mk_unsafe_rec_name]\ndef mkUnsafeRecName (declName : Name) : Name :=\n  Name.mkStr declName \"_unsafe_rec\"", "start": [40, 1], "end": [46, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.isUnsafeRecName?", "code": "@[export lean_is_unsafe_rec_name]\ndef isUnsafeRecName? : Name \u2192 Option Name\n  | .str n \"_unsafe_rec\" => some n\n  | _ => none", "start": [48, 1], "end": [52, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.compileDecls", "code": "@[extern \"lean_compile_decls\"]\nopaque compileDecls (env : Environment) (opt : @& Options) (decls : @& List Name) : Except KernelException Environment", "start": [58, 1], "end": [63, 119], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.compileDecl", "code": "def compileDecl (env : Environment) (opt : @& Options) (decl : @& Declaration) : Except KernelException Environment :=\n  compileDecls env opt (Compiler.getDeclNamesForCodeGen decl)", "start": [65, 1], "end": [67, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.addAndCompile", "code": "def addAndCompile (env : Environment) (opt : Options) (decl : Declaration) : Except KernelException Environment := do\n  let env \u2190 addDecl env decl\n  compileDecl env opt decl", "start": [70, 1], "end": [72, 27], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Log.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Message.lean", "lake-packages/lean4/src/lean/Lean/Util/Sorry.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MonadLog", "code": "class MonadLog (m : Type \u2192 Type) extends MonadFileMap m where\n  \n  getRef       : m Syntax\n  \n  getFileName  : m String\n  \n  hasErrors    : m Bool\n  \n  logMessage   : Message \u2192 m Unit", "start": [11, 1], "end": [22, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.getRefPos", "code": "def getRefPos : m String.Pos := do\n  let ref \u2190 MonadLog.getRef\n  return ref.getPos?.getD 0", "start": [35, 1], "end": [40, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.getRefPosition", "code": "def getRefPosition : m Position := do\n  let fileMap \u2190 getFileMap\n  return fileMap.toPosition (\u2190 getRefPos)", "start": [42, 1], "end": [47, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.logAt", "code": "def logAt (ref : Syntax) (msgData : MessageData) (severity : MessageSeverity := MessageSeverity.error) : m Unit :=\n  unless severity == .error && msgData.hasSyntheticSorry do\n    let severity := if severity == .warning && warningAsError.get (\u2190 getOptions) then .error else severity\n    let ref    := replaceRef ref (\u2190 MonadLog.getRef)\n    let pos    := ref.getPos?.getD 0\n    let endPos := ref.getTailPos?.getD pos\n    let fileMap \u2190 getFileMap\n    let msgData \u2190 addMessageContext msgData\n    logMessage { fileName := (\u2190 getFileName), pos := fileMap.toPosition pos, endPos := fileMap.toPosition endPos, data := msgData, severity := severity }", "start": [55, 1], "end": [68, 154], "kind": "commanddeclaration"}, {"full_name": "Lean.logErrorAt", "code": "def logErrorAt (ref : Syntax) (msgData : MessageData) : m Unit :=\n  logAt ref msgData MessageSeverity.error", "start": [70, 1], "end": [72, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.logWarningAt", "code": "def logWarningAt [MonadOptions m] (ref : Syntax) (msgData : MessageData) : m Unit := do\n  logAt ref msgData .warning", "start": [74, 1], "end": [76, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.logInfoAt", "code": "def logInfoAt (ref : Syntax) (msgData : MessageData) : m Unit :=\n  logAt ref msgData MessageSeverity.information", "start": [78, 1], "end": [80, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.log", "code": "def log (msgData : MessageData) (severity : MessageSeverity := MessageSeverity.error): m Unit := do\n  let ref \u2190 MonadLog.getRef\n  logAt ref msgData severity", "start": [82, 1], "end": [85, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.logError", "code": "def logError (msgData : MessageData) : m Unit :=\n  log msgData MessageSeverity.error", "start": [87, 1], "end": [89, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.logWarning", "code": "def logWarning [MonadOptions m] (msgData : MessageData) : m Unit := do\n  log msgData (if warningAsError.get (\u2190 getOptions) then .error else .warning)", "start": [91, 1], "end": [93, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.logInfo", "code": "def logInfo (msgData : MessageData) : m Unit :=\n  log msgData MessageSeverity.information", "start": [95, 1], "end": [97, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.logUnknownDecl", "code": "def logUnknownDecl (declName : Name) : m Unit :=\n  logError m!\"unknown declaration '{declName}'\"", "start": [99, 1], "end": [101, 48], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/Trace.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Exception.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.TraceElem", "code": "structure TraceElem where\n  ref : Syntax\n  msg : MessageData\n  deriving Inhabited", "start": [60, 1], "end": [63, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.TraceState", "code": "structure TraceState where\n  traces  : PersistentArray TraceElem := {}\n  deriving Inhabited", "start": [65, 1], "end": [67, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadTrace", "code": "class MonadTrace (m : Type \u2192 Type) where\n  modifyTraceState : (TraceState \u2192 TraceState) \u2192 m Unit\n  getTraceState    : m TraceState", "start": [71, 1], "end": [73, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.printTraces", "code": "def printTraces : m Unit := do\n  for {msg, ..} in (\u2190 getTraceState).traces do\n    IO.println (\u2190 msg.format)", "start": [83, 1], "end": [85, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.resetTraceState", "code": "def resetTraceState : m Unit :=\n  modifyTraceState (fun _ => {})", "start": [87, 1], "end": [88, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.checkTraceOption", "code": "private def checkTraceOption (inherited : HashSet Name) (opts : Options) (cls : Name) : Bool :=\n  !opts.isEmpty && go (`trace ++ cls)\nwhere\n  go (opt : Name) : Bool :=\n    if let some enabled := opts.get? opt then\n      enabled\n    else if let .str parent _ := opt then\n      inherited.contains opt && go parent\n    else\n      false", "start": [90, 1], "end": [99, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.isTracingEnabledFor", "code": "def isTracingEnabledFor (cls : Name) : m Bool := do\n  let inherited \u2190 (inheritedTraceOptions.get : IO _)\n  pure (checkTraceOption inherited (\u2190 getOptions) cls)", "start": [101, 1], "end": [103, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.getTraces", "code": "@[inline] def getTraces : m (PersistentArray TraceElem) := do\n  let s \u2190 getTraceState\n  pure s.traces", "start": [105, 1], "end": [107, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.modifyTraces", "code": "@[inline] def modifyTraces (f : PersistentArray TraceElem \u2192 PersistentArray TraceElem) : m Unit :=\n  modifyTraceState fun s => { s with traces := f s.traces }", "start": [109, 1], "end": [110, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.setTraceState", "code": "@[inline] def setTraceState (s : TraceState) : m Unit :=\n  modifyTraceState fun _ => s", "start": [112, 1], "end": [113, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.getResetTraces", "code": "private def getResetTraces : m (PersistentArray TraceElem) := do\n  let oldTraces \u2190 getTraces\n  modifyTraces fun _ => {}\n  pure oldTraces", "start": [115, 1], "end": [118, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.addRawTrace", "code": "def addRawTrace (msg : MessageData) : m Unit := do\n  let ref \u2190 getRef\n  let msg \u2190 addMessageContext msg\n  modifyTraces (\u00b7.push { ref, msg })", "start": [123, 1], "end": [126, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.addTrace", "code": "def addTrace (cls : Name) (msg : MessageData) : m Unit := do\n  let ref \u2190 getRef\n  let msg \u2190 addMessageContext msg\n  modifyTraces (\u00b7.push { ref, msg := .trace cls msg #[] })", "start": [128, 1], "end": [131, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.trace", "code": "@[inline] def trace (cls : Name) (msg : Unit \u2192 MessageData) : m Unit := do\n  if (\u2190 isTracingEnabledFor cls) then\n    addTrace cls (msg ())", "start": [133, 1], "end": [135, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.traceM", "code": "@[inline] def traceM (cls : Name) (mkMsg : m MessageData) : m Unit := do\n  if (\u2190 isTracingEnabledFor cls) then\n    let msg \u2190 mkMsg\n    addTrace cls msg", "start": [137, 1], "end": [140, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.addTraceNodeCore", "code": "private def addTraceNodeCore (oldTraces : PersistentArray TraceElem)\n    (cls : Name) (ref : Syntax) (msg : MessageData) (collapsed : Bool) : m Unit :=\n  modifyTraces fun newTraces =>\n    oldTraces.push { ref, msg := .trace cls msg (newTraces.toArray.map (\u00b7.msg)) collapsed }", "start": [142, 1], "end": [145, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.addTraceNode", "code": "private def addTraceNode (oldTraces : PersistentArray TraceElem)\n    (cls : Name) (ref : Syntax) (msg : MessageData) (collapsed : Bool) : m Unit :=\n  withRef ref do\n  let msg \u2190 addMessageContext msg\n  addTraceNodeCore oldTraces cls ref msg collapsed", "start": [147, 1], "end": [151, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.withSeconds", "code": "def withSeconds [Monad m] [MonadLiftT BaseIO m] (act : m \u03b1) : m (\u03b1 \u00d7 Float) := do\n  let start \u2190 IO.monoNanosNow\n  let a \u2190 act\n  let stop \u2190 IO.monoNanosNow\n  return (a, (stop - start).toFloat / 1000000000)", "start": [153, 1], "end": [157, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.trace.profiler.threshold.getSecs", "code": "def trace.profiler.threshold.getSecs (o : Options) : Float :=\n  (trace.profiler.threshold.get o).toFloat / 1000", "start": [171, 1], "end": [172, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.shouldProfile", "code": "@[inline]\ndef shouldProfile : m Bool := do\n  let opts \u2190 getOptions\n  return profiler.get opts || trace.profiler.get opts", "start": [174, 1], "end": [177, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.shouldEnableNestedTrace", "code": "@[inline]\ndef shouldEnableNestedTrace (cls : Name) (secs : Float) : m Bool := do\n  return (\u2190 isTracingEnabledFor cls) || secs < trace.profiler.threshold.getSecs (\u2190 getOptions)", "start": [179, 1], "end": [181, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.withTraceNode", "code": "def withTraceNode [MonadExcept \u03b5 m] [MonadLiftT BaseIO m] (cls : Name) (msg : Except \u03b5 \u03b1 \u2192 m MessageData) (k : m \u03b1)\n    (collapsed := true) : m \u03b1 := do\n  let opts \u2190 getOptions\n  let clsEnabled \u2190 isTracingEnabledFor cls\n  unless clsEnabled || trace.profiler.get opts do\n    return (\u2190 k)\n  let oldTraces \u2190 getResetTraces\n  let (res, secs) \u2190 withSeconds <| observing k\n  let aboveThresh := trace.profiler.get opts && secs > trace.profiler.threshold.getSecs opts\n  unless clsEnabled || aboveThresh do\n    modifyTraces (oldTraces ++ \u00b7)\n    return (\u2190 MonadExcept.ofExcept res)\n  let ref \u2190 getRef\n  let mut m \u2190 try msg res catch _ => pure m!\"<exception thrown while producing trace node message>\"\n  if profiler.get opts || aboveThresh then\n    m := m!\"[{secs}s] {m}\"\n  addTraceNode oldTraces cls ref m collapsed\n  MonadExcept.ofExcept res", "start": [183, 1], "end": [200, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.withTraceNode'", "code": "def withTraceNode' [MonadExcept Exception m] [MonadLiftT BaseIO m] (cls : Name) (k : m (\u03b1 \u00d7 MessageData)) (collapsed := true) : m \u03b1 :=\n  let msg := fun\n    | .ok (_, msg) => return msg\n    | .error err => return err.toMessageData\n  Prod.fst <$> withTraceNode cls msg k collapsed", "start": [202, 1], "end": [206, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.registerTraceClass", "code": "def registerTraceClass (traceClassName : Name) (inherited := false) (ref : Name := by exact decl_name%) : IO Unit := do\n  let optionName := `trace ++ traceClassName\n  registerOption optionName {\n    declName := ref\n    group := \"trace\"\n    defValue := false\n    descr := \"enable/disable tracing for the given module and submodules\"\n  }\n  if inherited then\n    inheritedTraceOptions.modify (\u00b7.insert optionName)", "start": [210, 1], "end": [227, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.bombEmoji", "code": "def bombEmoji := \"\ud83d\udca5\"", "start": [236, 1], "end": [236, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.checkEmoji", "code": "def checkEmoji := \"\u2705\"", "start": [237, 1], "end": [237, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.crossEmoji", "code": "def crossEmoji := \"\u274c\"", "start": [238, 1], "end": [238, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.exceptBoolEmoji", "code": "def exceptBoolEmoji : Except \u03b5 Bool \u2192 String\n  | .error _ => bombEmoji\n  | .ok true => checkEmoji\n  | .ok false => crossEmoji", "start": [240, 1], "end": [243, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.exceptOptionEmoji", "code": "def exceptOptionEmoji : Except \u03b5 (Option \u03b1) \u2192 String\n  | .error _ => bombEmoji\n  | .ok (some _) => checkEmoji\n  | .ok none => crossEmoji", "start": [245, 1], "end": [248, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.ExceptToEmoji", "code": "class ExceptToEmoji (\u03b5 \u03b1 : Type) where\n  toEmoji : Except \u03b5 \u03b1 \u2192 String", "start": [250, 1], "end": [251, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.withTraceNodeBefore", "code": "def withTraceNodeBefore [MonadRef m] [AddMessageContext m] [MonadOptions m] [MonadExcept \u03b5 m] [MonadLiftT BaseIO m] [ExceptToEmoji \u03b5 \u03b1] (cls : Name) (msg : m MessageData) (k : m \u03b1) (collapsed := true) : m \u03b1 := do\n  let opts \u2190 getOptions\n  let clsEnabled \u2190 isTracingEnabledFor cls\n  unless clsEnabled || trace.profiler.get opts do\n    return (\u2190 k)\n  let oldTraces \u2190 getResetTraces\n  let ref \u2190 getRef\n  let msg \u2190 withRef ref do addMessageContext (\u2190 msg)\n  let (res, secs) \u2190 withSeconds <| observing k\n  let aboveThresh := trace.profiler.get opts && secs > trace.profiler.threshold.getSecs opts\n  unless clsEnabled || aboveThresh do\n    modifyTraces (oldTraces ++ \u00b7)\n    return (\u2190 MonadExcept.ofExcept res)\n  let mut msg := m!\"{ExceptToEmoji.toEmoji res} {msg}\"\n  if profiler.get opts || aboveThresh then\n    msg := m!\"[{secs}s] {msg}\"\n  addTraceNodeCore oldTraces cls ref msg collapsed\n  MonadExcept.ofExcept res", "start": [259, 1], "end": [284, 27], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/RecDepth.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/ResolveName.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Exception.lean", "lake-packages/lean4/src/lean/Lean/Modifiers.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Hygiene.lean", "lake-packages/lean4/src/lean/Lean/Data/OpenDecl.lean"], "premises": [{"full_name": "Lean.AliasState", "code": "abbrev AliasState := SMap Name (List Name)", "start": [17, 1], "end": [17, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.AliasEntry", "code": "abbrev AliasEntry := Name \u00d7 Name", "start": [18, 1], "end": [18, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.addAliasEntry", "code": "def addAliasEntry (s : AliasState) (e : AliasEntry) : AliasState :=\n  match s.find? e.1 with\n  | none    => s.insert e.1 [e.2]\n  | some es => if es.contains e.2 then s else s.insert e.1 (e.2 :: es)", "start": [20, 1], "end": [23, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.addAlias", "code": "@[export lean_add_alias] def addAlias (env : Environment) (a : Name) (e : Name) : Environment :=\n  aliasExtension.addEntry env (a, e)", "start": [31, 1], "end": [33, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.getAliasState", "code": "def getAliasState (env : Environment) : AliasState :=\n  aliasExtension.getState env", "start": [35, 1], "end": [36, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.getAliases", "code": "def getAliases (env : Environment) (a : Name) (skipProtected : Bool) : List Name :=\n  match aliasExtension.getState env |>.find? a with\n  | none    => []\n  | some es =>\n    if skipProtected then\n      es.filter (!isProtected env \u00b7)\n    else\n      es", "start": [38, 1], "end": [49, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.getRevAliases", "code": "def getRevAliases (env : Environment) (e : Name) : List Name :=\n  (aliasExtension.getState env).fold (fun as a es => if List.contains es e then a :: as else as) []", "start": [52, 1], "end": [53, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.ResolveName.resolveQualifiedName", "code": "private def resolveQualifiedName (env : Environment) (ns : Name) (id : Name) : List Name :=\n  let resolvedId    := ns ++ id\n  let resolvedIds   := getAliases env resolvedId (skipProtected := id.isAtomic)\n  if env.contains resolvedId && (!id.isAtomic || !isProtected env resolvedId) then\n    resolvedId :: resolvedIds\n  else\n    let resolvedIdPrv := mkPrivateName env resolvedId\n    if env.contains resolvedIdPrv then resolvedIdPrv :: resolvedIds\n    else resolvedIds", "start": [58, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ResolveName.resolveUsingNamespace", "code": "private def resolveUsingNamespace (env : Environment) (id : Name) : Name \u2192 List Name\n  | ns@(.str p _) =>\n    match resolveQualifiedName env ns id with\n    | []          => resolveUsingNamespace env id p\n    | resolvedIds => resolvedIds\n  | _ => []", "start": [71, 1], "end": [77, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.ResolveName.resolveExact", "code": "private def resolveExact (env : Environment) (id : Name) : Option Name :=\n  if id.isAtomic then none\n  else\n    let resolvedId := id.replacePrefix rootNamespace Name.anonymous\n    if env.contains resolvedId then some resolvedId\n    else\n      let resolvedIdPrv := mkPrivateName env resolvedId\n      if env.contains resolvedIdPrv then some resolvedIdPrv\n      else none", "start": [79, 1], "end": [90, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.ResolveName.resolveOpenDecls", "code": "private def resolveOpenDecls (env : Environment) (id : Name) : List OpenDecl \u2192 List Name \u2192 List Name\n  | [], resolvedIds => resolvedIds\n  | OpenDecl.simple ns exs :: openDecls, resolvedIds =>\n    if exs.contains id then\n      resolveOpenDecls env id openDecls resolvedIds\n    else\n      let newResolvedIds := resolveQualifiedName env ns id\n      resolveOpenDecls env id openDecls (newResolvedIds ++ resolvedIds)\n  | OpenDecl.explicit openedId resolvedId :: openDecls, resolvedIds =>\n    let resolvedIds :=\n      if openedId == id then\n        resolvedId :: resolvedIds\n      else if openedId.isPrefixOf id then\n        let candidate := id.replacePrefix openedId resolvedId\n        if env.contains candidate then\n          candidate :: resolvedIds\n        else\n          resolvedIds\n      else\n        resolvedIds\n    resolveOpenDecls env id openDecls resolvedIds", "start": [92, 1], "end": [113, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.ResolveName.resolveGlobalName", "code": "def resolveGlobalName (env : Environment) (ns : Name) (openDecls : List OpenDecl) (id : Name) : List (Name \u00d7 List String) :=\n  let extractionResult := extractMacroScopes id\n  let rec loop (id : Name) (projs : List String) : List (Name \u00d7 List String) :=\n    match id with\n    | .str p s =>\n      let id := { extractionResult with name := id }.review\n      match resolveUsingNamespace env id ns with\n      | resolvedIds@(_ :: _) => resolvedIds.eraseDups.map fun id => (id, projs)\n      | [] =>\n        match resolveExact env id with\n        | some newId => [(newId, projs)]\n        | none =>\n          let resolvedIds := if env.contains id then [id] else []\n          let idPrv       := mkPrivateName env id\n          let resolvedIds := if env.contains idPrv then [idPrv] ++ resolvedIds else resolvedIds\n          let resolvedIds := resolveOpenDecls env id openDecls resolvedIds\n          let resolvedIds := getAliases env id (skipProtected := id.isAtomic) ++ resolvedIds\n          match resolvedIds with\n          | _ :: _ => resolvedIds.eraseDups.map fun id => (id, projs)\n          | []     => loop p (s::projs)\n    | _ => []\n  loop extractionResult.name []", "start": [115, 1], "end": [138, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.ResolveName.resolveNamespaceUsingScope?", "code": "def resolveNamespaceUsingScope? (env : Environment) (n : Name) : Name \u2192 Option Name\n  | .anonymous    => if env.isNamespace n then some n else none\n  | ns@(.str p _) => if env.isNamespace (ns ++ n) then some (ns ++ n) else resolveNamespaceUsingScope? env n p\n  | _             => unreachable!", "start": [142, 1], "end": [145, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.ResolveName.resolveNamespaceUsingOpenDecls", "code": "def resolveNamespaceUsingOpenDecls (env : Environment) (n : Name) : List OpenDecl \u2192 List Name\n  | [] => []\n  | OpenDecl.simple ns exs :: ds =>\n    if env.isNamespace (ns ++ n) && !exs.contains n then\n      (ns ++ n) :: resolveNamespaceUsingOpenDecls env n ds\n    else\n      resolveNamespaceUsingOpenDecls env n ds\n  | _ :: ds => resolveNamespaceUsingOpenDecls env n ds", "start": [147, 1], "end": [154, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.ResolveName.resolveNamespace", "code": "def resolveNamespace (env : Environment) (ns : Name) (openDecls : List OpenDecl) (id : Name) : List Name :=\n  match resolveNamespaceUsingScope? env id ns with\n  | some ns => ns :: resolveNamespaceUsingOpenDecls env id openDecls\n  | none => resolveNamespaceUsingOpenDecls env id openDecls", "start": [156, 1], "end": [170, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.MonadResolveName", "code": "class MonadResolveName (m : Type \u2192 Type) where\n  getCurrNamespace   : m Name\n  getOpenDecls       : m (List OpenDecl)", "start": [174, 1], "end": [176, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.resolveGlobalName", "code": "def resolveGlobalName [Monad m] [MonadResolveName m] [MonadEnv m] (id : Name) : m (List (Name \u00d7 List String)) := do\n  return ResolveName.resolveGlobalName (\u2190 getEnv) (\u2190 getCurrNamespace) (\u2190 getOpenDecls) id", "start": [184, 1], "end": [208, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.resolveNamespaceCore", "code": "def resolveNamespaceCore [Monad m] [MonadResolveName m] [MonadEnv m] [MonadError m] (id : Name) (allowEmpty := false) : m (List Name) := do\n  let nss := ResolveName.resolveNamespace (\u2190 getEnv) (\u2190 getCurrNamespace) (\u2190 getOpenDecls) id\n  if !allowEmpty && nss.isEmpty then\n    throwError s!\"unknown namespace '{id}'\"\n  return nss", "start": [210, 1], "end": [218, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.resolveNamespace", "code": "def resolveNamespace [Monad m] [MonadResolveName m] [MonadEnv m] [MonadError m] : Ident \u2192 m (List Name)\n  | stx@\u27e8Syntax.ident _ _ n pre\u27e9 => do\n    let pre := pre.filterMap fun\n      | .namespace ns => some ns\n      | _             => none\n    if pre.isEmpty then\n      withRef stx <| resolveNamespaceCore n\n    else\n      return pre\n  | stx => throwErrorAt stx s!\"expected identifier\"", "start": [220, 1], "end": [230, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.resolveUniqueNamespace", "code": "def resolveUniqueNamespace [Monad m] [MonadResolveName m] [MonadEnv m] [MonadError m] (id : Ident) : m Name := do\n  match (\u2190 resolveNamespace id) with\n  | [ns] => return ns\n  | nss => throwError s!\"ambiguous namespace '{id.getId}', possible interpretations: '{nss}'\"", "start": [232, 1], "end": [236, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.resolveGlobalConstCore", "code": "def resolveGlobalConstCore [Monad m] [MonadResolveName m] [MonadEnv m] [MonadError m] (n : Name) : m (List Name) := do\n  let cs \u2190 resolveGlobalName n\n  let cs := cs.filter fun (_, fieldList) => fieldList.isEmpty\n  if cs.isEmpty then throwUnknownConstant n\n  return cs.map (\u00b7.1)", "start": [238, 1], "end": [246, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.resolveGlobalConstNoOverloadCore", "code": "def resolveGlobalConstNoOverloadCore [Monad m] [MonadResolveName m] [MonadEnv m] [MonadError m] (n : Name) : m Name := do\n  let cs \u2190 resolveGlobalConstCore n\n  match cs with\n  | [c] => pure c\n  | _   => throwError s!\"ambiguous identifier '{mkConst n}', possible interpretations: {cs.map mkConst}\"", "start": [248, 1], "end": [253, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.resolveGlobalConst", "code": "def resolveGlobalConst [Monad m] [MonadResolveName m] [MonadEnv m] [MonadError m] : Syntax \u2192 m (List Name)\n  | stx@(Syntax.ident _ _ n pre) => do\n    let pre := pre.filterMap fun\n      | .decl n [] => some n\n      | _          => none\n    if pre.isEmpty then\n      withRef stx <| resolveGlobalConstCore n\n    else\n      return pre\n  | stx => throwErrorAt stx s!\"expected identifier\"", "start": [255, 1], "end": [285, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.resolveGlobalConstNoOverload", "code": "def resolveGlobalConstNoOverload [Monad m] [MonadResolveName m] [MonadEnv m] [MonadError m] (id : Syntax) : m Name := do\n  let cs \u2190 resolveGlobalConst id\n  match cs with\n  | [c] => pure c\n  | _   => throwErrorAt id s!\"ambiguous identifier '{id}', possible interpretations: {cs.map mkConst}\"", "start": [287, 1], "end": [310, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.unresolveNameGlobal", "code": "def unresolveNameGlobal [Monad m] [MonadResolveName m] [MonadEnv m] (n\u2080 : Name) (fullNames := false) : m Name := do\n  if n\u2080.hasMacroScopes then return n\u2080\n  if fullNames then\n    match (\u2190 resolveGlobalName n\u2080) with\n      | [(potentialMatch, _)] => if (privateToUserName? potentialMatch).getD potentialMatch == n\u2080 then return n\u2080 else return rootNamespace ++ n\u2080\n      | _ => return n\u2080 let mut initialNames := (getRevAliases (\u2190 getEnv) n\u2080).toArray\n  initialNames := initialNames.push (rootNamespace ++ n\u2080)\n  for initialName in initialNames do\n    match (\u2190 unresolveNameCore initialName) with\n    | none => continue\n    | some n => return n\n  return n\u2080 where\n  unresolveNameCore (n : Name) : m (Option Name) := do\n    let mut revComponents := n.componentsRev\n    let mut candidate := Name.anonymous\n    for _ in [:revComponents.length] do\n      match revComponents with\n      | [] => return none\n      | cmpt::rest => candidate := cmpt ++ candidate; revComponents := rest\n      match (\u2190 resolveGlobalName candidate) with\n      | [(potentialMatch, _)] => if potentialMatch == n\u2080 then return some candidate else continue\n      | _ => continue\n    return none", "start": [312, 1], "end": [336, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Eval.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MetaEval", "code": "class MetaEval (\u03b1 : Type u) where\n  eval : Environment \u2192 Options \u2192 \u03b1 \u2192 (hideUnit : Bool) \u2192 IO Environment", "start": [12, 1], "end": [18, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.runMetaEval", "code": "def runMetaEval {\u03b1 : Type u} [MetaEval \u03b1] (env : Environment) (opts : Options) (a : \u03b1) : IO (String \u00d7 Except IO.Error Environment) :=\n  IO.FS.withIsolatedStreams (MetaEval.eval env opts a false |>.toBaseIO)", "start": [23, 1], "end": [24, 73], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/MonadEnv.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Exception.lean", "lake-packages/lean4/src/lean/Lean/Log.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Declaration.lean", "lake-packages/lean4/src/lean/Lean/Compiler/Old.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Lean/AuxRecursor.lean"], "premises": [{"full_name": "Lean.setEnv", "code": "def setEnv [MonadEnv m] (env : Environment) : m Unit :=\n  modifyEnv fun _ => env", "start": [15, 1], "end": [16, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.withEnv", "code": "def withEnv [Monad m] [MonadFinally m] [MonadEnv m] (env : Environment) (x : m \u03b1) : m \u03b1 := do\n  let saved \u2190 getEnv\n  try\n    setEnv env\n    x\n  finally\n    setEnv saved", "start": [18, 1], "end": [24, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.isInductive", "code": "def isInductive [Monad m] [MonadEnv m] (declName : Name) : m Bool := do\n  match (\u2190 getEnv).find? declName with\n  | some (ConstantInfo.inductInfo ..) => return true\n  | _ => return false", "start": [26, 1], "end": [29, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.isRecCore", "code": "def isRecCore (env : Environment) (declName : Name) : Bool :=\n  match env.find? declName with\n  | some (ConstantInfo.recInfo ..) => true\n  | _ => false", "start": [31, 1], "end": [34, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.isRec", "code": "def isRec [Monad m] [MonadEnv m] (declName : Name) : m Bool :=\n  return isRecCore (\u2190 getEnv) declName", "start": [36, 1], "end": [37, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.withoutModifyingEnv", "code": "@[inline] def withoutModifyingEnv [Monad m] [MonadEnv m] [MonadFinally m] {\u03b1 : Type} (x : m \u03b1) : m \u03b1 := do\n  let env \u2190 getEnv\n  try x finally setEnv env", "start": [39, 1], "end": [41, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.withoutModifyingEnv'", "code": "@[inline] def withoutModifyingEnv' [Monad m] [MonadEnv m] [MonadFinally m] {\u03b1 : Type} (x : m \u03b1) : m (\u03b1 \u00d7 Environment) := do\n  let env \u2190 getEnv\n  try\n    let a \u2190 x\n    return (a, \u2190 getEnv)\n  finally\n    setEnv env", "start": [43, 1], "end": [50, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.matchConst", "code": "@[inline] def matchConst [Monad m] [MonadEnv m] (e : Expr) (failK : Unit \u2192 m \u03b1) (k : ConstantInfo \u2192 List Level \u2192 m \u03b1) : m \u03b1 := do\n  match e with\n  | Expr.const constName us => do\n    match (\u2190 getEnv).find? constName with\n    | some cinfo => k cinfo us\n    | none       => failK ()\n  | _ => failK ()", "start": [52, 1], "end": [58, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.matchConstInduct", "code": "@[inline] def matchConstInduct [Monad m] [MonadEnv m] (e : Expr) (failK : Unit \u2192 m \u03b1) (k : InductiveVal \u2192 List Level \u2192 m \u03b1) : m \u03b1 :=\n  matchConst e failK fun cinfo us =>\n    match cinfo with\n    | ConstantInfo.inductInfo val => k val us\n    | _                           => failK ()", "start": [60, 1], "end": [64, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.matchConstCtor", "code": "@[inline] def matchConstCtor [Monad m] [MonadEnv m] (e : Expr) (failK : Unit \u2192 m \u03b1) (k : ConstructorVal \u2192 List Level \u2192 m \u03b1) : m \u03b1 :=\n  matchConst e failK fun cinfo us =>\n    match cinfo with\n    | ConstantInfo.ctorInfo val => k val us\n    | _                         => failK ()", "start": [66, 1], "end": [70, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.matchConstRec", "code": "@[inline] def matchConstRec [Monad m] [MonadEnv m] (e : Expr) (failK : Unit \u2192 m \u03b1) (k : RecursorVal \u2192 List Level \u2192 m \u03b1) : m \u03b1 :=\n  matchConst e failK fun cinfo us =>\n    match cinfo with\n    | ConstantInfo.recInfo val => k val us\n    | _                        => failK ()", "start": [72, 1], "end": [76, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.hasConst", "code": "def hasConst [Monad m] [MonadEnv m] (constName : Name) : m Bool := do\n  return (\u2190 getEnv).contains constName", "start": [78, 1], "end": [79, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAuxNameAux", "code": "private partial def mkAuxNameAux (env : Environment) (base : Name) (i : Nat) : Name :=\n  let candidate := base.appendIndexAfter i\n  if env.contains candidate then\n    mkAuxNameAux env base (i+1)\n  else\n    candidate", "start": [81, 1], "end": [86, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAuxName", "code": "def mkAuxName [Monad m] [MonadEnv m] (baseName : Name) (idx : Nat) : m Name := do\n  return mkAuxNameAux (\u2190 getEnv) baseName idx", "start": [88, 1], "end": [89, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.getConstInfo", "code": "def getConstInfo [Monad m] [MonadEnv m] [MonadError m] (constName : Name) : m ConstantInfo := do\n  match (\u2190 getEnv).find? constName with\n  | some info => pure info\n  | none      => throwError \"unknown constant '{mkConst constName}'\"", "start": [91, 1], "end": [94, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.mkConstWithLevelParams", "code": "def mkConstWithLevelParams [Monad m] [MonadEnv m] [MonadError m] (constName : Name) : m Expr := do\n  let info \u2190 getConstInfo constName\n  return mkConst constName (info.levelParams.map mkLevelParam)", "start": [96, 1], "end": [98, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.getConstInfoDefn", "code": "def getConstInfoDefn [Monad m] [MonadEnv m] [MonadError m] (constName : Name) : m DefinitionVal := do\n  match (\u2190 getConstInfo constName) with\n  | ConstantInfo.defnInfo v => pure v\n  | _                       => throwError \"'{mkConst constName}' is not a definition\"", "start": [100, 1], "end": [103, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.getConstInfoInduct", "code": "def getConstInfoInduct [Monad m] [MonadEnv m] [MonadError m] (constName : Name) : m InductiveVal := do\n  match (\u2190 getConstInfo constName) with\n  | ConstantInfo.inductInfo v => pure v\n  | _                         => throwError \"'{mkConst constName}' is not a inductive type\"", "start": [105, 1], "end": [108, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.getConstInfoCtor", "code": "def getConstInfoCtor [Monad m] [MonadEnv m] [MonadError m] (constName : Name) : m ConstructorVal := do\n  match (\u2190 getConstInfo constName) with\n  | ConstantInfo.ctorInfo v => pure v\n  | _                       => throwError \"'{mkConst constName}' is not a constructor\"", "start": [110, 1], "end": [113, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.getConstInfoRec", "code": "def getConstInfoRec [Monad m] [MonadEnv m] [MonadError m] (constName : Name) : m RecursorVal := do\n  match (\u2190 getConstInfo constName) with\n  | ConstantInfo.recInfo v => pure v\n  | _                      => throwError \"'{mkConst constName}' is not a recursor\"", "start": [115, 1], "end": [118, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.matchConstStruct", "code": "@[inline] def matchConstStruct [Monad m] [MonadEnv m] [MonadError m] (e : Expr) (failK : Unit \u2192 m \u03b1) (k : InductiveVal \u2192 List Level \u2192 ConstructorVal \u2192 m \u03b1) : m \u03b1 :=\n  matchConstInduct e failK fun ival us => do\n    if ival.isRec || ival.numIndices != 0 then failK ()\n    else match ival.ctors with\n      | [ctor] =>\n        match (\u2190 getConstInfo ctor) with\n        | ConstantInfo.ctorInfo cval => k ival us cval\n        | _ => failK ()\n      | _ => failK ()", "start": [120, 1], "end": [128, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.evalConst", "code": "unsafe def evalConst [Monad m] [MonadEnv m] [MonadError m] [MonadOptions m] (\u03b1) (constName : Name) : m \u03b1 := do\n  ofExcept <| (\u2190 getEnv).evalConst \u03b1 (\u2190 getOptions) constName", "start": [130, 1], "end": [131, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.evalConstCheck", "code": "unsafe def evalConstCheck [Monad m] [MonadEnv m] [MonadError m] [MonadOptions m] (\u03b1) (typeName : Name) (constName : Name) : m \u03b1 := do\n  ofExcept <| (\u2190 getEnv).evalConstCheck \u03b1 (\u2190 getOptions) typeName constName", "start": [133, 1], "end": [134, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.findModuleOf?", "code": "def findModuleOf? [Monad m] [MonadEnv m] [MonadError m] (declName : Name) : m (Option Name) := do\n  discard <| getConstInfo declName match (\u2190 getEnv).getModuleIdxFor? declName with\n  | none        => return none\n  | some modIdx => return some ((\u2190 getEnv).allImportedModuleNames[modIdx.toNat]!)", "start": [136, 1], "end": [140, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.isEnumType", "code": "def isEnumType  [Monad m] [MonadEnv m] [MonadError m] (declName : Name) : m Bool := do\n  if let ConstantInfo.inductInfo info \u2190 getConstInfo declName then\n    if !info.type.isProp && info.all.length == 1 && info.numIndices == 0 && info.numParams == 0\n       && !info.ctors.isEmpty && !info.isRec && !info.isNested && !info.isUnsafe then\n      info.ctors.allM fun ctorName => do\n        let ConstantInfo.ctorInfo info \u2190 getConstInfo ctorName | return false\n        return info.numFields == 0\n    else\n      return false\n  else\n    return false", "start": [142, 1], "end": [152, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/CoreM.lean", "imports": ["lake-packages/lean4/src/lean/Lean/MonadEnv.lean", "lake-packages/lean4/src/lean/Lean/Log.lean", "lake-packages/lean4/src/lean/Lean/Eval.lean", "lake-packages/lean4/src/lean/Lean/ResolveName.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Util/RecDepth.lean", "lake-packages/lean4/src/lean/Lean/Util/Trace.lean", "lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Types.lean"], "premises": [{"full_name": "Lean.Core.getMaxHeartbeats", "code": "def getMaxHeartbeats (opts : Options) : Nat :=\n  maxHeartbeats.get opts * 1000", "start": [24, 1], "end": [25, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.InstantiateLevelCache", "code": "abbrev InstantiateLevelCache := PersistentHashMap Name (List Level \u00d7 Expr)", "start": [27, 1], "end": [27, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.Cache", "code": "structure Cache where\n  instLevelType  : InstantiateLevelCache := {}\n  instLevelValue : InstantiateLevelCache := {}\n  deriving Inhabited", "start": [29, 1], "end": [33, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.State", "code": "structure State where\n  \n  env             : Environment\n  \n  nextMacroScope  : MacroScope     := firstFrontendMacroScope + 1\n  \n  ngen            : NameGenerator  := {}\n  \n  traceState      : TraceState     := {}\n  \n  cache           : Cache          := {}\n  \n  messages        : MessageLog     := {}\n  \n  infoState       : Elab.InfoState := {}\n  deriving Nonempty", "start": [35, 1], "end": [51, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.Context", "code": "structure Context where\n  \n  fileName       : String\n  \n  fileMap        : FileMap\n  options        : Options := {}\n  currRecDepth   : Nat := 0\n  maxRecDepth    : Nat := 1000\n  ref            : Syntax := Syntax.missing\n  currNamespace  : Name := Name.anonymous\n  openDecls      : List OpenDecl := []\n  initHeartbeats : Nat := 0\n  maxHeartbeats  : Nat := getMaxHeartbeats options\n  currMacroScope : MacroScope := firstFrontendMacroScope\n  deriving Nonempty", "start": [53, 1], "end": [68, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.CoreM", "code": "abbrev CoreM := ReaderT Context <| StateRefT State (EIO Exception)", "start": [70, 1], "end": [78, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.withFreshMacroScope", "code": "protected def withFreshMacroScope (x : CoreM \u03b1) : CoreM \u03b1 := do\n  let fresh \u2190 modifyGetThe Core.State (fun st => (st.nextMacroScope, { st with nextMacroScope := st.nextMacroScope + 1 }))\n  withReader (fun ctx => { ctx with currMacroScope := fresh }) x", "start": [118, 1], "end": [120, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.modifyCache", "code": "@[inline] def modifyCache (f : Cache \u2192 Cache) : CoreM Unit :=\n  modify fun \u27e8env, next, ngen, trace, cache, messages, infoState\u27e9 => \u27e8env, next, ngen, trace, f cache, messages, infoState\u27e9", "start": [131, 1], "end": [132, 124], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.modifyInstLevelTypeCache", "code": "@[inline] def modifyInstLevelTypeCache (f : InstantiateLevelCache \u2192 InstantiateLevelCache) : CoreM Unit :=\n  modifyCache fun \u27e8c\u2081, c\u2082\u27e9 => \u27e8f c\u2081, c\u2082\u27e9", "start": [134, 1], "end": [135, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.modifyInstLevelValueCache", "code": "@[inline] def modifyInstLevelValueCache (f : InstantiateLevelCache \u2192 InstantiateLevelCache) : CoreM Unit :=\n  modifyCache fun \u27e8c\u2081, c\u2082\u27e9 => \u27e8c\u2081, f c\u2082\u27e9", "start": [137, 1], "end": [138, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.instantiateTypeLevelParams", "code": "def instantiateTypeLevelParams (c : ConstantInfo) (us : List Level) : CoreM Expr := do\n  if let some (us', r) := (\u2190 get).cache.instLevelType.find? c.name then\n    if us == us' then\n      return r\n  let r := c.instantiateTypeLevelParams us\n  modifyInstLevelTypeCache fun s => s.insert c.name (us, r)\n  return r", "start": [140, 1], "end": [146, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.instantiateValueLevelParams", "code": "def instantiateValueLevelParams (c : ConstantInfo) (us : List Level) : CoreM Expr := do\n  if let some (us', r) := (\u2190 get).cache.instLevelValue.find? c.name then\n    if us == us' then\n      return r\n  unless c.hasValue do\n    throwError \"Not a definition or theorem: {c.name}\"\n  let r := c.instantiateValueLevelParams! us\n  modifyInstLevelValueCache fun s => s.insert c.name (us, r)\n  return r", "start": [148, 1], "end": [156, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.liftIOCore", "code": "@[inline] def liftIOCore (x : IO \u03b1) : CoreM \u03b1 := do\n  let ref \u2190 getRef\n  IO.toEIO (fun (err : IO.Error) => Exception.error ref (toString err)) x", "start": [158, 1], "end": [160, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.restore", "code": "def restore (b : State) : CoreM Unit :=\n  modify fun s => { s with env := b.env, messages := b.messages, infoState := b.infoState }", "start": [169, 1], "end": [171, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.mkFreshNameImp", "code": "private def mkFreshNameImp (n : Name) : CoreM Name := do\n  let fresh \u2190 modifyGet fun s => (s.nextMacroScope, { s with nextMacroScope := s.nextMacroScope + 1 })\n  return addMacroScope (\u2190 getEnv).mainModule n fresh", "start": [173, 1], "end": [175, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.mkFreshUserName", "code": "def mkFreshUserName (n : Name) : CoreM Name :=\n  mkFreshNameImp n", "start": [177, 1], "end": [178, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.CoreM.run", "code": "@[inline] def CoreM.run (x : CoreM \u03b1) (ctx : Context) (s : State) : EIO Exception (\u03b1 \u00d7 State) :=\n  (x ctx).run s", "start": [180, 1], "end": [181, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.CoreM.run'", "code": "@[inline] def CoreM.run' (x : CoreM \u03b1) (ctx : Context) (s : State) : EIO Exception \u03b1 :=\n  Prod.fst <$> x.run ctx s", "start": [183, 1], "end": [184, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.CoreM.toIO", "code": "@[inline] def CoreM.toIO (x : CoreM \u03b1) (ctx : Context) (s : State) : IO (\u03b1 \u00d7 State) := do\n  match (\u2190 (x.run { ctx with initHeartbeats := (\u2190 IO.getNumHeartbeats) } s).toIO') with\n  | Except.error (Exception.error _ msg)   => throw <| IO.userError (\u2190 msg.toString)\n  | Except.error (Exception.internal id _) => throw <| IO.userError <| \"internal exception #\" ++ toString id.idx\n  | Except.ok a                            => return a", "start": [186, 1], "end": [190, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.withIncRecDepth", "code": "protected def withIncRecDepth [Monad m] [MonadControlT CoreM m] (x : m \u03b1) : m \u03b1 :=\n  controlAt CoreM fun runInBase => withIncRecDepth (runInBase x)", "start": [199, 1], "end": [200, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.throwMaxHeartbeat", "code": "def throwMaxHeartbeat (moduleName : Name) (optionName : Name) (max : Nat) : CoreM Unit := do\n  let msg := s!\"(deterministic) timeout at '{moduleName}', maximum number of heartbeats ({max/1000}) has been reached (use 'set_option {optionName} <num>' to set the limit)\"\n  throw <| Exception.error (\u2190 getRef) (MessageData.ofFormat (Std.Format.text msg))", "start": [202, 1], "end": [204, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.checkMaxHeartbeatsCore", "code": "def checkMaxHeartbeatsCore (moduleName : String) (optionName : Name) (max : Nat) : CoreM Unit := do\n  unless max == 0 do\n    let numHeartbeats \u2190 IO.getNumHeartbeats\n    if numHeartbeats - (\u2190 read).initHeartbeats > max then\n      throwMaxHeartbeat moduleName optionName max", "start": [206, 1], "end": [210, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.checkMaxHeartbeats", "code": "def checkMaxHeartbeats (moduleName : String) : CoreM Unit := do\n  checkMaxHeartbeatsCore moduleName `maxHeartbeats (\u2190 read).maxHeartbeats", "start": [212, 1], "end": [213, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.withCurrHeartbeatsImp", "code": "private def withCurrHeartbeatsImp (x : CoreM \u03b1) : CoreM \u03b1 := do\n  let heartbeats \u2190 IO.getNumHeartbeats\n  withReader (fun ctx => { ctx with initHeartbeats := heartbeats }) x", "start": [215, 1], "end": [217, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.withCurrHeartbeats", "code": "def withCurrHeartbeats [Monad m] [MonadControlT CoreM m] (x : m \u03b1) : m \u03b1 :=\n  controlAt CoreM fun runInBase => withCurrHeartbeatsImp (runInBase x)", "start": [219, 1], "end": [220, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.setMessageLog", "code": "def setMessageLog (messages : MessageLog) : CoreM Unit :=\n  modify fun s => { s with messages := messages }", "start": [222, 1], "end": [223, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.resetMessageLog", "code": "def resetMessageLog : CoreM Unit :=\n  setMessageLog {}", "start": [225, 1], "end": [226, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.getMessageLog", "code": "def getMessageLog : CoreM MessageLog :=\n  return (\u2190 get).messages", "start": [228, 1], "end": [229, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.withAtLeastMaxRecDepth", "code": "@[inline] def withAtLeastMaxRecDepth [MonadFunctorT CoreM m] (max : Nat) : m \u03b1 \u2192 m \u03b1 :=\n  monadMap (m := CoreM) <| withReader (fun ctx => { ctx with maxRecDepth := Nat.max max ctx.maxRecDepth })", "start": [245, 1], "end": [246, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.catchInternalId", "code": "@[inline] def catchInternalId [Monad m] [MonadExcept Exception m] (id : InternalExceptionId) (x : m \u03b1) (h : Exception \u2192 m \u03b1) : m \u03b1 := do\n  try\n    x\n  catch ex => match ex with\n    | .error ..       => throw ex\n    | .internal id' _ => if id == id' then h ex else throw ex", "start": [248, 1], "end": [253, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.catchInternalIds", "code": "@[inline] def catchInternalIds [Monad m] [MonadExcept Exception m] (ids : List InternalExceptionId) (x : m \u03b1) (h : Exception \u2192 m \u03b1) : m \u03b1 := do\n  try\n    x\n  catch ex => match ex with\n    | .error ..      => throw ex\n    | .internal id _ => if ids.contains id then h ex else throw ex", "start": [255, 1], "end": [260, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Exception.isMaxHeartbeat", "code": "def Exception.isMaxHeartbeat (ex : Exception) : Bool :=\n  match ex with\n  | Exception.error _ (MessageData.ofFormat (Std.Format.text msg)) => \"(deterministic) timeout\".isPrefixOf msg\n  | _ => false", "start": [262, 1], "end": [269, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.mkArrow", "code": "def mkArrow (d b : Expr) : CoreM Expr :=\n  return Lean.mkForall (\u2190 mkFreshUserName `x) BinderInfo.default d b", "start": [271, 1], "end": [273, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.addDecl", "code": "def addDecl (decl : Declaration) : CoreM Unit := do\n  profileitM Exception \"type checking\" (\u2190 getOptions) do\n    withTraceNode `Kernel (fun _ => return m!\"typechecking declaration\") do\n      if !(\u2190 MonadLog.hasErrors) && decl.hasSorry then\n        logWarning \"declaration uses 'sorry'\"\n      match (\u2190 getEnv).addDecl decl with\n      | Except.ok    env => setEnv env\n      | Except.error ex  => throwKernelException ex", "start": [275, 1], "end": [282, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.supportedRecursors", "code": "private def supportedRecursors :=\n  #[``Empty.rec, ``False.rec, ``Eq.ndrec, ``Eq.rec, ``Eq.recOn, ``Eq.casesOn, ``False.casesOn, ``Empty.casesOn, ``And.rec, ``And.casesOn]", "start": [284, 1], "end": [285, 138], "kind": "commanddeclaration"}, {"full_name": "Lean.checkUnsupported", "code": "private def checkUnsupported [Monad m] [MonadEnv m] [MonadError m] (decl : Declaration) : m Unit := do\n  let env \u2190 getEnv\n  decl.forExprM fun e =>\n    let unsupportedRecursor? := e.find? fun\n      | Expr.const declName .. =>\n        ((isAuxRecursor env declName && !isCasesOnRecursor env declName) || isRecCore env declName)\n        && !supportedRecursors.contains declName\n      | _ => false\n    match unsupportedRecursor? with\n    | some (Expr.const declName ..) => throwError \"code generator does not support recursor '{declName}' yet, consider using 'match ... with' and/or structural recursion\"\n    | _ => pure ()", "start": [287, 1], "end": [299, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.compileDeclsNew", "code": "@[extern \"lean_lcnf_compile_decls\"]\nopaque compileDeclsNew (declNames : List Name) : CoreM Unit", "start": [308, 1], "end": [309, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.compileDecl", "code": "def compileDecl (decl : Declaration) : CoreM Unit := do\n  let opts \u2190 getOptions\n  if compiler.enableNew.get opts then\n    compileDeclsNew (Compiler.getDeclNamesForCodeGen decl)\n  match (\u2190 getEnv).compileDecl opts decl with\n  | Except.ok env   => setEnv env\n  | Except.error (KernelException.other msg) =>\n    checkUnsupported decl throwError msg\n  | Except.error ex =>\n    throwKernelException ex", "start": [311, 1], "end": [321, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.compileDecls", "code": "def compileDecls (decls : List Name) : CoreM Unit := do\n  let opts \u2190 getOptions\n  if compiler.enableNew.get opts then\n    compileDeclsNew decls\n  match (\u2190 getEnv).compileDecls opts decls with\n  | Except.ok env   => setEnv env\n  | Except.error (KernelException.other msg) =>\n    throwError msg\n  | Except.error ex =>\n    throwKernelException ex", "start": [323, 1], "end": [332, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.addAndCompile", "code": "def addAndCompile (decl : Declaration) : CoreM Unit := do\n  addDecl decl;\n  compileDecl decl", "start": [334, 1], "end": [336, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.ImportM.runCoreM", "code": "def ImportM.runCoreM (x : CoreM \u03b1) : ImportM \u03b1 := do\n  let ctx \u2190 read\n  let (a, _) \u2190 x.toIO { options := ctx.opts, fileName := \"<ImportM>\", fileMap := default } { env := ctx.env }\n  return a", "start": [338, 1], "end": [341, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Attributes.lean", "imports": ["lake-packages/lean4/src/lean/Lean/MonadEnv.lean", "lake-packages/lean4/src/lean/Lean/CoreM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.AttributeApplicationTime", "code": "inductive AttributeApplicationTime where\n  | afterTypeChecking | afterCompilation | beforeElaboration\n  deriving Inhabited, BEq", "start": [11, 1], "end": [13, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.AttrM", "code": "abbrev AttrM := CoreM", "start": [15, 1], "end": [15, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeImplCore", "code": "structure AttributeImplCore where\n  \n  ref : Name := by exact decl_name%\n  name : Name\n  descr : String\n  applicationTime := AttributeApplicationTime.afterTypeChecking\n  deriving Inhabited", "start": [20, 1], "end": [26, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeKind", "code": "inductive AttributeKind\n  | global | local | scoped\n  deriving BEq, Inhabited", "start": [28, 1], "end": [41, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeImpl", "code": "structure AttributeImpl extends AttributeImplCore where\n  \n  add (decl : Name) (stx : Syntax) (kind : AttributeKind) : AttrM Unit\n  erase (decl : Name) : AttrM Unit := throwError \"attribute cannot be erased\"\n  deriving Inhabited", "start": [49, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.registerBuiltinAttribute", "code": "def registerBuiltinAttribute (attr : AttributeImpl) : IO Unit := do\n  let m \u2190 attributeMapRef.get\n  if m.contains attr.name then throw (IO.userError (\"invalid builtin attribute declaration, '\" ++ toString attr.name ++ \"' has already been used\"))\n  unless (\u2190 initializing) do\n    throw (IO.userError \"failed to register attribute, attributes can only be registered during initialization\")\n  attributeMapRef.modify fun m => m.insert attr.name attr", "start": [57, 1], "end": [63, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Attribute.Builtin.ensureNoArgs", "code": "def Attribute.Builtin.ensureNoArgs (stx : Syntax) : AttrM Unit := do\n  if stx.getKind == `Lean.Parser.Attr.simple && stx[1].isNone && stx[2].isNone then\n    return ()\n  else if stx.getKind == `Lean.Parser.Attr.\u00abclass\u00bb then\n    return ()\n  else match stx with\n    | Syntax.missing => return () | _              => throwErrorAt stx \"unexpected attribute argument\"", "start": [78, 1], "end": [85, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Attribute.Builtin.getIdent?", "code": "def Attribute.Builtin.getIdent? (stx : Syntax) : AttrM (Option Syntax) := do\n  if stx.getKind == `Lean.Parser.Attr.simple then\n    if !stx[1].isNone && stx[1][0].isIdent then\n      return some stx[1][0]\n    else\n      return none\n  \n  else if stx.getKind == `Lean.Parser.Attr.\u00abmacro\u00bb || stx.getKind == `Lean.Parser.Attr.\u00abexport\u00bb then\n    return some stx[1]\n  else\n    throwErrorAt stx \"unexpected attribute argument\"", "start": [87, 1], "end": [97, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Attribute.Builtin.getIdent", "code": "def Attribute.Builtin.getIdent (stx : Syntax) : AttrM Syntax := do\n  match (\u2190 getIdent? stx) with\n  | some id => return id\n  | none    => throwErrorAt stx \"unexpected attribute argument, identifier expected\"", "start": [99, 1], "end": [102, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Attribute.Builtin.getId?", "code": "def Attribute.Builtin.getId? (stx : Syntax) : AttrM (Option Name) := do\n  let ident? \u2190 getIdent? stx\n  return Syntax.getId <$> ident?", "start": [104, 1], "end": [106, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Attribute.Builtin.getId", "code": "def Attribute.Builtin.getId (stx : Syntax) : AttrM Name := do\n  return (\u2190 getIdent stx).getId", "start": [108, 1], "end": [109, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.getAttrParamOptPrio", "code": "def getAttrParamOptPrio (optPrioStx : Syntax) : AttrM Nat :=\n  if optPrioStx.isNone then\n    return eval_prio default\n  else match optPrioStx[0].isNatLit? with\n    | some prio => return prio\n    | none => throwErrorAt optPrioStx \"priority expected\"", "start": [111, 1], "end": [116, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Attribute.Builtin.getPrio", "code": "def Attribute.Builtin.getPrio (stx : Syntax) : AttrM Nat := do\n  if stx.getKind == `Lean.Parser.Attr.simple then\n    getAttrParamOptPrio stx[1]\n  else\n    throwErrorAt stx \"unexpected attribute argument, optional priority expected\"", "start": [118, 1], "end": [122, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.TagAttribute", "code": "structure TagAttribute where\n  attr : AttributeImpl\n  ext  : PersistentEnvExtension Name Name NameSet\n  deriving Inhabited", "start": [125, 1], "end": [136, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.registerTagAttribute", "code": "def registerTagAttribute (name : Name) (descr : String)\n    (validate : Name \u2192 AttrM Unit := fun _ => pure ()) (ref : Name := by exact decl_name%) (applicationTime := AttributeApplicationTime.afterTypeChecking) : IO TagAttribute := do\n  let ext : PersistentEnvExtension Name Name NameSet \u2190 registerPersistentEnvExtension {\n    name            := ref\n    mkInitial       := pure {}\n    addImportedFn   := fun _ _ => pure {}\n    addEntryFn      := fun (s : NameSet) n => s.insert n\n    exportEntriesFn := fun es =>\n      let r : Array Name := es.fold (fun a e => a.push e) #[]\n      r.qsort Name.quickLt\n    statsFn         := fun s => \"tag attribute\" ++ Format.line ++ \"number of local entries: \" ++ format s.size\n  }\n  let attrImpl : AttributeImpl := {\n    ref, name, descr, applicationTime\n    add   := fun decl stx kind => do\n      Attribute.Builtin.ensureNoArgs stx\n      unless kind == AttributeKind.global do throwError \"invalid attribute '{name}', must be global\"\n      let env \u2190 getEnv\n      unless (env.getModuleIdxFor? decl).isNone do\n        throwError \"invalid attribute '{name}', declaration is in an imported module\"\n      validate decl\n      modifyEnv fun env => ext.addEntry env decl\n  }\n  registerBuiltinAttribute attrImpl\n  return { attr := attrImpl, ext := ext }", "start": [138, 1], "end": [162, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.TagAttribute.hasTag", "code": "def hasTag (attr : TagAttribute) (env : Environment) (decl : Name) : Bool :=\n  match env.getModuleIdxFor? decl with\n  | some modIdx => (attr.ext.getModuleEntries env modIdx).binSearchContains decl Name.quickLt\n  | none        => (attr.ext.getState env).contains decl", "start": [166, 1], "end": [169, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.ParametricAttribute", "code": "structure ParametricAttribute (\u03b1 : Type) where\n  attr : AttributeImpl\n  ext  : PersistentEnvExtension (Name \u00d7 \u03b1) (Name \u00d7 \u03b1) (NameMap \u03b1)\n  deriving Inhabited", "start": [173, 1], "end": [182, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ParametricAttributeImpl", "code": "structure ParametricAttributeImpl (\u03b1 : Type) extends AttributeImplCore where\n  \n  getParam : Name \u2192 Syntax \u2192 AttrM \u03b1\n  afterSet : Name \u2192 \u03b1 \u2192 AttrM Unit := fun _ _ _ => pure ()\n  afterImport : Array (Array (Name \u00d7 \u03b1)) \u2192 ImportM Unit := fun _ => pure ()", "start": [184, 1], "end": [188, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.registerParametricAttribute", "code": "def registerParametricAttribute [Inhabited \u03b1] (impl : ParametricAttributeImpl \u03b1) : IO (ParametricAttribute \u03b1) := do\n  let ext : PersistentEnvExtension (Name \u00d7 \u03b1) (Name \u00d7 \u03b1) (NameMap \u03b1) \u2190 registerPersistentEnvExtension {\n    name            := impl.ref\n    mkInitial       := pure {}\n    addImportedFn   := fun s => impl.afterImport s *> pure {}\n    addEntryFn      := fun (s : NameMap \u03b1) (p : Name \u00d7 \u03b1) => s.insert p.1 p.2\n    exportEntriesFn := fun m =>\n      let r : Array (Name \u00d7 \u03b1) := m.fold (fun a n p => a.push (n, p)) #[]\n      r.qsort (fun a b => Name.quickLt a.1 b.1)\n    statsFn         := fun s => \"parametric attribute\" ++ Format.line ++ \"number of local entries: \" ++ format s.size\n  }\n  let attrImpl : AttributeImpl := {\n    impl.toAttributeImplCore with\n    add   := fun decl stx kind => do\n      unless kind == AttributeKind.global do throwError \"invalid attribute '{impl.name}', must be global\"\n      let env \u2190 getEnv\n      unless (env.getModuleIdxFor? decl).isNone do\n        throwError \"invalid attribute '{impl.name}', declaration is in an imported module\"\n      let val \u2190 impl.getParam decl stx\n      modifyEnv fun env => ext.addEntry env (decl, val)\n      try impl.afterSet decl val catch _ => setEnv env\n  }\n  registerBuiltinAttribute attrImpl\n  pure { attr := attrImpl, ext := ext }", "start": [190, 1], "end": [213, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.ParametricAttribute.getParam?", "code": "def getParam? [Inhabited \u03b1] (attr : ParametricAttribute \u03b1) (env : Environment) (decl : Name) : Option \u03b1 :=\n  match env.getModuleIdxFor? decl with\n  | some modIdx =>\n    match (attr.ext.getModuleEntries env modIdx).binSearch (decl, default) (fun a b => Name.quickLt a.1 b.1) with\n    | some (_, val) => some val\n    | none          => none\n  | none        => (attr.ext.getState env).find? decl", "start": [217, 1], "end": [223, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.ParametricAttribute.setParam", "code": "def setParam (attr : ParametricAttribute \u03b1) (env : Environment) (decl : Name) (param : \u03b1) : Except String Environment :=\n  if (env.getModuleIdxFor? decl).isSome then\n    Except.error (\"invalid '\" ++ toString attr.attr.name ++ \"'.setParam, declaration is in an imported module\")\n  else if ((attr.ext.getState env).find? decl).isSome then\n    Except.error (\"invalid '\" ++ toString attr.attr.name ++ \"'.setParam, attribute has already been set\")\n  else\n    Except.ok (attr.ext.addEntry env (decl, param))", "start": [225, 1], "end": [231, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.EnumAttributes", "code": "structure EnumAttributes (\u03b1 : Type) where\n  attrs : List AttributeImpl\n  ext   : PersistentEnvExtension (Name \u00d7 \u03b1) (Name \u00d7 \u03b1) (NameMap \u03b1)\n  deriving Inhabited", "start": [235, 1], "end": [242, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.registerEnumAttributes", "code": "def registerEnumAttributes [Inhabited \u03b1] (attrDescrs : List (Name \u00d7 String \u00d7 \u03b1))\n    (validate : Name \u2192 \u03b1 \u2192 AttrM Unit := fun _ _ => pure ())\n    (applicationTime := AttributeApplicationTime.afterTypeChecking)\n    (ref : Name := by exact decl_name%) : IO (EnumAttributes \u03b1) := do\n  let ext : PersistentEnvExtension (Name \u00d7 \u03b1) (Name \u00d7 \u03b1) (NameMap \u03b1) \u2190 registerPersistentEnvExtension {\n    name            := ref\n    mkInitial       := pure {}\n    addImportedFn   := fun _ _ => pure {}\n    addEntryFn      := fun (s : NameMap \u03b1) (p : Name \u00d7 \u03b1) => s.insert p.1 p.2\n    exportEntriesFn := fun m =>\n      let r : Array (Name \u00d7 \u03b1) := m.fold (fun a n p => a.push (n, p)) #[]\n      r.qsort (fun a b => Name.quickLt a.1 b.1)\n    statsFn         := fun s => \"enumeration attribute extension\" ++ Format.line ++ \"number of local entries: \" ++ format s.size\n  }\n  let attrs := attrDescrs.map fun (name, descr, val) => {\n    ref             := ref\n    name            := name\n    descr           := descr\n    add             := fun decl stx kind => do\n      Attribute.Builtin.ensureNoArgs stx\n      unless kind == AttributeKind.global do throwError \"invalid attribute '{name}', must be global\"\n      let env \u2190 getEnv\n      unless (env.getModuleIdxFor? decl).isNone do\n        throwError \"invalid attribute '{name}', declaration is in an imported module\"\n      validate decl val\n      modifyEnv fun env => ext.addEntry env (decl, val)\n    applicationTime := applicationTime\n    : AttributeImpl\n  }\n  attrs.forM registerBuiltinAttribute\n  pure { ext := ext, attrs := attrs }", "start": [244, 1], "end": [274, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.EnumAttributes.getValue", "code": "def getValue [Inhabited \u03b1] (attr : EnumAttributes \u03b1) (env : Environment) (decl : Name) : Option \u03b1 :=\n  match env.getModuleIdxFor? decl with\n  | some modIdx =>\n    match (attr.ext.getModuleEntries env modIdx).binSearch (decl, default) (fun a b => Name.quickLt a.1 b.1) with\n    | some (_, val) => some val\n    | none          => none\n  | none        => (attr.ext.getState env).find? decl", "start": [278, 1], "end": [284, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.EnumAttributes.setValue", "code": "def setValue (attrs : EnumAttributes \u03b1) (env : Environment) (decl : Name) (val : \u03b1) : Except String Environment :=\n  if (env.getModuleIdxFor? decl).isSome then\n    Except.error (\"invalid '\" ++ toString attrs.ext.name ++ \"'.setValue, declaration is in an imported module\")\n  else if ((attrs.ext.getState env).find? decl).isSome then\n    Except.error (\"invalid '\" ++ toString attrs.ext.name ++ \"'.setValue, attribute has already been set\")\n  else\n    Except.ok (attrs.ext.addEntry env (decl, val))", "start": [286, 1], "end": [292, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeImplBuilder", "code": "abbrev AttributeImplBuilder := Name \u2192 List DataValue \u2192 Except String AttributeImpl", "start": [300, 1], "end": [300, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeImplBuilderTable", "code": "abbrev AttributeImplBuilderTable := HashMap Name AttributeImplBuilder", "start": [301, 1], "end": [301, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.registerAttributeImplBuilder", "code": "def registerAttributeImplBuilder (builderId : Name) (builder : AttributeImplBuilder) : IO Unit := do\n  let table \u2190 attributeImplBuilderTableRef.get\n  if table.contains builderId then throw (IO.userError (\"attribute implementation builder '\" ++ toString builderId ++ \"' has already been declared\"))\n  attributeImplBuilderTableRef.modify fun table => table.insert builderId builder", "start": [305, 1], "end": [308, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAttributeImplOfBuilder", "code": "def mkAttributeImplOfBuilder (builderId ref : Name) (args : List DataValue) : IO AttributeImpl := do\n  let table \u2190 attributeImplBuilderTableRef.get\n  match table.find? builderId with\n  | none         => throw (IO.userError (\"unknown attribute implementation builder '\" ++ toString builderId ++ \"'\"))\n  | some builder => IO.ofExcept <| builder ref args", "start": [310, 1], "end": [314, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeExtensionOLeanEntry", "code": "inductive AttributeExtensionOLeanEntry where\n  | decl (declName : Name) | builder (builderId ref : Name) (args : List DataValue)", "start": [316, 1], "end": [318, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeExtensionState", "code": "structure AttributeExtensionState where\n  newEntries : List AttributeExtensionOLeanEntry := []\n  map        : PersistentHashMap Name AttributeImpl\n  deriving Inhabited", "start": [320, 1], "end": [323, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeExtension", "code": "abbrev AttributeExtension := PersistentEnvExtension AttributeExtensionOLeanEntry (AttributeExtensionOLeanEntry \u00d7 AttributeImpl) AttributeExtensionState", "start": [325, 1], "end": [325, 152], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeExtension.mkInitial", "code": "private def AttributeExtension.mkInitial : IO AttributeExtensionState := do\n  let map \u2190 attributeMapRef.get\n  pure { map := map }", "start": [327, 1], "end": [329, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAttributeImplOfConstantUnsafe", "code": "unsafe def mkAttributeImplOfConstantUnsafe (env : Environment) (opts : Options) (declName : Name) : Except String AttributeImpl :=\n  match env.find? declName with\n  | none      => throw (\"unknow constant '\" ++ toString declName ++ \"'\")\n  | some info =>\n    match info.type with\n    | Expr.const `Lean.AttributeImpl _ => env.evalConst AttributeImpl opts declName\n    | _ => throw (\"unexpected attribute implementation type at '\" ++ toString declName ++ \"' (`AttributeImpl` expected\")", "start": [331, 1], "end": [337, 121], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAttributeImplOfConstant", "code": "@[implemented_by mkAttributeImplOfConstantUnsafe]\nopaque mkAttributeImplOfConstant (env : Environment) (opts : Options) (declName : Name) : Except String AttributeImpl", "start": [339, 1], "end": [340, 118], "kind": "commanddeclaration"}, {"full_name": "Lean.mkAttributeImplOfEntry", "code": "def mkAttributeImplOfEntry (env : Environment) (opts : Options) (e : AttributeExtensionOLeanEntry) : IO AttributeImpl :=\n  match e with\n  | .decl declName              => IO.ofExcept <| mkAttributeImplOfConstant env opts declName\n  | .builder builderId ref args => mkAttributeImplOfBuilder builderId ref args", "start": [342, 1], "end": [345, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.AttributeExtension.addImported", "code": "private def AttributeExtension.addImported (es : Array (Array AttributeExtensionOLeanEntry)) : ImportM AttributeExtensionState := do\n  let ctx \u2190 read\n  let map \u2190 attributeMapRef.get\n  let map \u2190 es.foldlM\n    (fun map entries =>\n      entries.foldlM\n        (fun (map : PersistentHashMap Name AttributeImpl) entry => do\n          let attrImpl \u2190 mkAttributeImplOfEntry ctx.env ctx.opts entry\n          return map.insert attrImpl.name attrImpl)\n        map)\n    map\n  pure { map := map }", "start": [347, 1], "end": [358, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.addAttrEntry", "code": "private def addAttrEntry (s : AttributeExtensionState) (e : AttributeExtensionOLeanEntry \u00d7 AttributeImpl) : AttributeExtensionState :=\n  { s with map := s.map.insert e.2.name e.2, newEntries := e.1 :: s.newEntries }", "start": [360, 1], "end": [361, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.isBuiltinAttribute", "code": "@[export lean_is_attribute]\ndef isBuiltinAttribute (n : Name) : IO Bool := do\n  let m \u2190 attributeMapRef.get; pure (m.contains n)", "start": [372, 1], "end": [375, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.getBuiltinAttributeNames", "code": "def getBuiltinAttributeNames : IO (List Name) :=\n  return (\u2190 attributeMapRef.get).foldl (init := []) fun r n _ => n::r", "start": [377, 1], "end": [379, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.getBuiltinAttributeImpl", "code": "def getBuiltinAttributeImpl (attrName : Name) : IO AttributeImpl := do\n  let m \u2190 attributeMapRef.get\n  match m.find? attrName with\n  | some attr => pure attr\n  | none      => throw (IO.userError (\"unknown attribute '\" ++ toString attrName ++ \"'\"))", "start": [381, 1], "end": [385, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.getBuiltinAttributeApplicationTime", "code": "@[export lean_attribute_application_time]\ndef getBuiltinAttributeApplicationTime (n : Name) : IO AttributeApplicationTime := do\n  let attr \u2190 getBuiltinAttributeImpl n\n  pure attr.applicationTime", "start": [387, 1], "end": [390, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.isAttribute", "code": "def isAttribute (env : Environment) (attrName : Name) : Bool :=\n  (attributeExtension.getState env).map.contains attrName", "start": [392, 1], "end": [393, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.getAttributeNames", "code": "def getAttributeNames (env : Environment) : List Name :=\n  let m := (attributeExtension.getState env).map\n  m.foldl (fun r n _ => n::r) []", "start": [395, 1], "end": [397, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.getAttributeImpl", "code": "def getAttributeImpl (env : Environment) (attrName : Name) : Except String AttributeImpl :=\n  let m := (attributeExtension.getState env).map\n  match m.find? attrName with\n  | some attr => pure attr\n  | none      => throw (\"unknown attribute '\" ++ toString attrName ++ \"'\")", "start": [399, 1], "end": [403, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.registerAttributeOfDecl", "code": "def registerAttributeOfDecl (env : Environment) (opts : Options) (attrDeclName : Name) : Except String Environment := do\n  let attrImpl \u2190 mkAttributeImplOfConstant env opts attrDeclName\n  if isAttribute env attrImpl.name then\n    throw (\"invalid builtin attribute declaration, '\" ++ toString attrImpl.name ++ \"' has already been used\")\n  else\n    return attributeExtension.addEntry env (.decl attrDeclName, attrImpl)", "start": [405, 1], "end": [410, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.registerAttributeOfBuilder", "code": "def registerAttributeOfBuilder (env : Environment) (builderId ref : Name) (args : List DataValue) : IO Environment := do\n  let attrImpl \u2190 mkAttributeImplOfBuilder builderId ref args\n  if isAttribute env attrImpl.name then\n    throw (IO.userError (\"invalid builtin attribute declaration, '\" ++ toString attrImpl.name ++ \"' has already been used\"))\n  else\n    return attributeExtension.addEntry env (.builder builderId ref args, attrImpl)", "start": [412, 1], "end": [417, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Attribute.add", "code": "def Attribute.add (declName : Name) (attrName : Name) (stx : Syntax) (kind := AttributeKind.global) : AttrM Unit := do\n  let attr \u2190 ofExcept <| getAttributeImpl (\u2190 getEnv) attrName\n  attr.add declName stx kind", "start": [419, 1], "end": [421, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Attribute.erase", "code": "def Attribute.erase (declName : Name) (attrName : Name) : AttrM Unit := do\n  let attr \u2190 ofExcept <| getAttributeImpl (\u2190 getEnv) attrName\n  attr.erase declName", "start": [423, 1], "end": [425, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.updateEnvAttributesImpl", "code": "@[export lean_update_env_attributes]\ndef updateEnvAttributesImpl (env : Environment) : IO Environment := do\n  let map \u2190 attributeMapRef.get\n  let s := attributeExtension.getState env\n  let s := map.foldl (init := s) fun s attrName attrImpl =>\n    if s.map.contains attrName then\n      s\n    else\n      { s with map := s.map.insert attrName attrImpl }\n  return attributeExtension.setState env s", "start": [427, 1], "end": [437, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.getNumBuiltinAttributesImpl", "code": "@[export lean_get_num_attributes] def getNumBuiltinAttributesImpl : IO Nat :=\n  return (\u2190 attributeMapRef.get).size", "start": [439, 1], "end": [441, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/ReducibilityAttrs.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ReducibilityStatus", "code": "inductive ReducibilityStatus where\n  | reducible | semireducible | irreducible\n  deriving Inhabited, Repr", "start": [10, 1], "end": [15, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.getReducibilityStatusImp", "code": "@[export lean_get_reducibility_status]\nprivate def getReducibilityStatusImp (env : Environment) (declName : Name) : ReducibilityStatus :=\n  match reducibilityAttrs.getValue env declName with\n  | some s => s\n  | none   => ReducibilityStatus.semireducible", "start": [26, 1], "end": [30, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.setReducibilityStatusImp", "code": "@[export lean_set_reducibility_status]\nprivate def setReducibilityStatusImp (env : Environment) (declName : Name) (s : ReducibilityStatus) : Environment :=\n  match reducibilityAttrs.setValue env declName s with\n  | Except.ok env => env\n  | _ => env", "start": [32, 1], "end": [36, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.getReducibilityStatus", "code": "def getReducibilityStatus [Monad m] [MonadEnv m] (declName : Name) : m ReducibilityStatus := do\n  return getReducibilityStatusImp (\u2190 getEnv) declName", "start": [38, 1], "end": [40, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.setReducibilityStatus", "code": "def setReducibilityStatus [Monad m] [MonadEnv m] (declName : Name) (s : ReducibilityStatus) : m Unit := do\n  modifyEnv fun env => setReducibilityStatusImp env declName s", "start": [42, 1], "end": [44, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.setReducibleAttribute", "code": "def setReducibleAttribute [Monad m] [MonadEnv m] (declName : Name) : m Unit := do\n  setReducibilityStatus declName ReducibilityStatus.reducible", "start": [46, 1], "end": [48, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.isReducible", "code": "def isReducible [Monad m] [MonadEnv m] (declName : Name) : m Bool := do\n  match (\u2190 getReducibilityStatus declName) with\n  | ReducibilityStatus.reducible => return true\n  | _ => return false", "start": [50, 1], "end": [54, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.isIrreducible", "code": "def isIrreducible [Monad m] [MonadEnv m] (declName : Name) : m Bool := do\n  match (\u2190 getReducibilityStatus declName) with\n  | ReducibilityStatus.irreducible => return true\n  | _ => return false", "start": [56, 1], "end": [60, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/MonadBacktrack.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MonadBacktrack", "code": "class MonadBacktrack (s : outParam Type) (m : Type \u2192 Type) where\n  saveState    : m s\n  restoreState : s \u2192 m Unit", "start": [9, 1], "end": [12, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.commitWhenSome?", "code": "def commitWhenSome? [Monad m] [MonadBacktrack s m] [MonadExcept \u03b5 m] (x? : m (Option \u03b1)) : m (Option \u03b1) := do\n  let s \u2190 saveState\n  try\n    match (\u2190 x?) with\n    | some a => return some a\n    | none   =>\n      restoreState s\n      return none\n  catch ex =>\n    restoreState s\n    throw ex", "start": [16, 1], "end": [29, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.commitWhenSomeNoEx?", "code": "def commitWhenSomeNoEx? [Monad m] [MonadBacktrack s m] [MonadExcept \u03b5 m] (x? : m (Option \u03b1)) : m (Option \u03b1) :=\n  try\n    commitWhenSome? x?\n  catch _ =>\n    return none", "start": [31, 1], "end": [40, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.commitWhen", "code": "def commitWhen [Monad m] [MonadBacktrack s m] [MonadExcept \u03b5 m] (x : m Bool) : m Bool := do\n  let s \u2190 saveState\n  try\n    match (\u2190 x) with\n    | true  => pure true\n    | false =>\n      restoreState s\n      pure false\n  catch ex =>\n    restoreState s\n    throw ex", "start": [42, 1], "end": [52, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.commitIfNoEx", "code": "def commitIfNoEx [Monad m] [MonadBacktrack s m] [MonadExcept \u03b5 m] (x : m \u03b1) : m \u03b1 := do\n  let s \u2190 saveState\n  try\n    x\n  catch ex =>\n    restoreState s\n    throw ex", "start": [54, 1], "end": [60, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.withoutModifyingState", "code": "def withoutModifyingState [Monad m] [MonadFinally m] [MonadBacktrack s m] (x : m \u03b1) : m \u03b1 := do\n  let s \u2190 saveState\n  try\n    x\n  finally\n    restoreState s", "start": [62, 1], "end": [67, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.observing?", "code": "def observing? [Monad m] [MonadBacktrack s m] [MonadExcept \u03b5 m] (x : m \u03b1) : m (Option \u03b1) := do\n  let s \u2190 saveState\n  try\n    x\n  catch _ =>\n    restoreState s\n    return none", "start": [69, 1], "end": [75, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Class.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ClassEntry", "code": "structure ClassEntry where\n  \n  name      : Name\n  \n  outParams : Array Nat", "start": [10, 1], "end": [22, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.ClassEntry.lt", "code": "def lt (a b : ClassEntry) : Bool :=\n  Name.quickLt a.name b.name", "start": [26, 1], "end": [27, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.ClassState", "code": "structure ClassState where\n  outParamMap : SMap Name (Array Nat) := SMap.empty\n  deriving Inhabited", "start": [31, 1], "end": [34, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ClassState.addEntry", "code": "def addEntry (s : ClassState) (entry : ClassEntry) : ClassState :=\n  { s with outParamMap := s.outParamMap.insert entry.name entry.outParams }", "start": [38, 1], "end": [39, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.ClassState.switch", "code": "def switch (s : ClassState) : ClassState :=\n  { s with outParamMap := s.outParamMap.switch }", "start": [41, 1], "end": [47, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.isClass", "code": "@[export lean_is_class]\ndef isClass (env : Environment) (n : Name) : Bool :=\n  (classExtension.getState env).outParamMap.contains n", "start": [61, 1], "end": [64, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.getOutParamPositions?", "code": "def getOutParamPositions? (env : Environment) (declName : Name) : Option (Array Nat) :=\n  (classExtension.getState env).outParamMap.find? declName", "start": [66, 1], "end": [68, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.hasOutParams", "code": "@[export lean_has_out_params]\ndef hasOutParams (env : Environment) (declName : Name) : Bool :=\n  match getOutParamPositions? env declName with\n  | some outParams => !outParams.isEmpty\n  | none => false", "start": [70, 1], "end": [75, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.checkOutParam", "code": "private partial def checkOutParam (i : Nat) (outParamFVarIds : Array FVarId) (outParams : Array Nat) (type : Expr) : Except String (Array Nat) :=\n  match type with\n  | .forallE _ d b bi =>\n    let addOutParam (_ : Unit) :=\n      let fvarId := { name := Name.mkNum `_fvar outParamFVarIds.size }\n      let fvar      := mkFVar fvarId\n      let b         := b.instantiate1 fvar\n      checkOutParam (i+1) (outParamFVarIds.push fvarId) (outParams.push i) b\n    if d.isOutParam then\n      addOutParam ()\n    else if d.hasAnyFVar fun fvarId => outParamFVarIds.contains fvarId then\n      if bi.isInstImplicit then\n        \n        addOutParam ()\n      else\n        Except.error s!\"invalid class, parameter #{i+1} depends on `outParam`, but it is not an `outParam`\"\n    else\n      checkOutParam (i+1) outParamFVarIds outParams b\n  | _ => return outParams", "start": [77, 1], "end": [107, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.mkOutParamArgsImplicit", "code": "@[export lean_mk_outparam_args_implicit]\npartial def mkOutParamArgsImplicit (type : Expr) : Expr :=\n  go type type #[]\nwhere\n  go (type : Expr) (typeAux : Expr) (outParamFVarIds : Array FVarId) : Expr :=\n    match typeAux with\n    | .forallE _ d b bi =>\n      let mkOutParamImplicit (dNew : Expr) :=\n        let fvarId := { name := Name.mkNum `_fvar outParamFVarIds.size }\n        let fvar      := mkFVar fvarId\n        let b         := b.instantiate1 fvar\n        let bNew      := go type.bindingBody! b (outParamFVarIds.push fvarId)\n        type.updateForall! .implicit dNew bNew\n      let keepBinderInfo (_ : Unit) :=\n        let bNew := go type.bindingBody! b outParamFVarIds\n        type.updateForallE! type.bindingDomain! bNew\n      if d.isOutParam then\n        mkOutParamImplicit type.bindingDomain!.appArg! else if d.hasAnyFVar fun fvarId => outParamFVarIds.contains fvarId then\n        if bi.isInstImplicit then\n          mkOutParamImplicit type.bindingDomain!\n        else\n          keepBinderInfo ()\n      else\n        keepBinderInfo ()\n    | _ => type", "start": [109, 1], "end": [142, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.addClass", "code": "def addClass (env : Environment) (clsName : Name) : Except String Environment := do\n  if isClass env clsName then\n    throw s!\"class has already been declared '{clsName}'\"\n  let some decl := env.find? clsName\n    | throw s!\"unknown declaration '{clsName}'\"\n  unless decl matches .inductInfo .. | .axiomInfo .. do\n    throw s!\"invalid 'class', declaration '{clsName}' must be inductive datatype, structure, or constant\"\n  let outParams \u2190 checkOutParam 0 #[] #[] decl.type\n  return classExtension.addEntry env { name := clsName, outParams }", "start": [144, 1], "end": [159, 68], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/TransparencyMode.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.TransparencyMode.hash", "code": "def hash : TransparencyMode \u2192 UInt64\n  | all       => 7\n  | default   => 11\n  | reducible => 13\n  | instances => 17", "start": [10, 1], "end": [14, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.TransparencyMode.lt", "code": "def lt : TransparencyMode \u2192 TransparencyMode \u2192 Bool\n  | reducible, default   => true\n  | reducible, all       => true\n  | reducible, instances => true\n  | instances, default   => true\n  | instances, all       => true\n  | default,   all       => true\n  | _,         _         => false", "start": [18, 1], "end": [25, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/LOption.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LOption", "code": "inductive LOption (\u03b1 : Type u) where\n  | none  : LOption \u03b1\n  | some  : \u03b1 \u2192 LOption \u03b1\n  | undef : LOption \u03b1\n  deriving Inhabited, BEq", "start": [10, 1], "end": [14, 26], "kind": "commanddeclaration"}, {"full_name": "Option.toLOption", "code": "def Option.toLOption {\u03b1 : Type u} : Option \u03b1 \u2192 Lean.LOption \u03b1\n  | none   => .none\n  | some a => .some a", "start": [24, 1], "end": [26, 22], "kind": "commanddeclaration"}, {"full_name": "toLOptionM", "code": "@[inline] def toLOptionM {\u03b1} {m : Type \u2192 Type} [Monad m] (x : m (Option \u03b1)) : m (Lean.LOption \u03b1) := do\n  let b \u2190 x\n  return b.toLOption", "start": [28, 1], "end": [30, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/InlineAttrs.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.InlineAttributeKind", "code": "inductive InlineAttributeKind where\n  | inline | noinline | macroInline | inlineIfReduce | alwaysInline\n  deriving Inhabited, BEq, Hashable", "start": [11, 1], "end": [13, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.isValidMacroInline", "code": "private def isValidMacroInline (declName : Name) : CoreM Bool := do\n  let .defnInfo info \u2190 getConstInfo declName\n    | return false\n  unless info.all.length = 1 do\n    return false\n  let env \u2190 getEnv\n  let isRec (declName' : Name) : Bool :=\n    isBRecOnRecursor env declName' ||\n    declName' == ``WellFounded.fix ||\n    declName' == declName ++ `_unary if Option.isSome <| info.value.find? fun e => e.isConst && isRec e.constName! then\n    return false\n  return true", "start": [15, 1], "end": [32, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.setInlineAttribute", "code": "def setInlineAttribute (env : Environment) (declName : Name) (kind : InlineAttributeKind) : Except String Environment :=\n  inlineAttrs.setValue env declName kind", "start": [47, 1], "end": [48, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.getInlineAttribute?", "code": "def getInlineAttribute? (env : Environment) (declName : Name) : Option InlineAttributeKind :=\n  inlineAttrs.getValue env declName", "start": [50, 1], "end": [51, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasInlineAttrCore", "code": "private def hasInlineAttrCore (env : Environment) (kind : InlineAttributeKind) (declName : Name) : Bool :=\n  match inlineAttrs.getValue env declName with\n  | some k => kind == k\n  | _ => false", "start": [53, 1], "end": [56, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasInlineAttribute", "code": "abbrev hasInlineAttribute (env : Environment) (declName : Name) : Bool :=\n  hasInlineAttrCore env .inline declName", "start": [58, 1], "end": [59, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasInlineIfReduceAttribute", "code": "def hasInlineIfReduceAttribute (env : Environment) (declName : Name) : Bool :=\n  hasInlineAttrCore env .inlineIfReduce declName", "start": [61, 1], "end": [62, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasNoInlineAttribute", "code": "def hasNoInlineAttribute (env : Environment) (declName : Name) : Bool :=\n  hasInlineAttrCore env .noinline declName", "start": [64, 1], "end": [65, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasMacroInlineAttribute", "code": "def hasMacroInlineAttribute (env : Environment) (declName : Name) : Bool :=\n  hasInlineAttrCore env .macroInline declName", "start": [67, 1], "end": [68, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasAlwaysInlineAttribute", "code": "abbrev hasAlwaysInlineAttribute (env : Environment) (declName : Name) : Bool :=\n  hasInlineAttrCore env .alwaysInline declName", "start": [70, 1], "end": [71, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasInlineAttrAux", "code": "private partial def hasInlineAttrAux (env : Environment) (kind : InlineAttributeKind) (n : Name) : Bool :=\n  \n  if isEagerLambdaLiftingName n then false\n  else match inlineAttrs.getValue env n with\n    | some k => kind == k\n    | none   => if n.isInternal then hasInlineAttrAux env kind n.getPrefix else false", "start": [75, 1], "end": [80, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasInlineAttributeOld", "code": "@[export lean_has_inline_attribute]\ndef hasInlineAttributeOld (env : Environment) (n : Name) : Bool :=\n  hasInlineAttrAux env InlineAttributeKind.inline n", "start": [82, 1], "end": [84, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasInlineIfReduceAttributeOld", "code": "@[export lean_has_inline_if_reduce_attribute]\ndef hasInlineIfReduceAttributeOld (env : Environment) (n : Name) : Bool :=\n  hasInlineAttrAux env InlineAttributeKind.inlineIfReduce n", "start": [86, 1], "end": [88, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasNoInlineAttributeOld", "code": "@[export lean_has_noinline_attribute]\ndef hasNoInlineAttributeOld (env : Environment) (n : Name) : Bool :=\n  hasInlineAttrAux env InlineAttributeKind.noinline n", "start": [90, 1], "end": [92, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasMacroInlineAttributeOld", "code": "@[export lean_has_macro_inline_attribute]\ndef hasMacroInlineAttributeOld (env : Environment) (n : Name) : Bool :=\n  hasInlineAttrAux env InlineAttributeKind.macroInline n", "start": [94, 1], "end": [96, 57], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/InlineAttrs.lean", "lake-packages/lean4/src/lean/Lean/Data/LOption.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean", "lake-packages/lean4/src/lean/Lean/Meta/TransparencyMode.lean", "lake-packages/lean4/src/lean/Lean/Class.lean", "lake-packages/lean4/src/lean/Lean/Util/MonadBacktrack.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Lean/ReducibilityAttrs.lean"], "premises": [{"full_name": "Lean.Meta.Config", "code": "structure Config where\n  \n  foApprox           : Bool := false\n  \n  ctxApprox          : Bool := false\n  \n  quasiPatternApprox : Bool := false\n  \n  constApprox        : Bool := false\n  \n  isDefEqStuckEx     : Bool := false\n  \n  transparency       : TransparencyMode := TransparencyMode.default\n  \n  zetaNonDep         : Bool := true\n  \n  trackZeta          : Bool := false\n  \n  unificationHints   : Bool := true\n  \n  proofIrrelevance   : Bool := true\n  \n  assignSyntheticOpaque : Bool := false\n  \n  offsetCnstrs          : Bool := true\n  \n  etaStruct             : EtaStructMode := .all", "start": [29, 1], "end": [103, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ParamInfo", "code": "structure ParamInfo where\n  \n  binderInfo     : BinderInfo := BinderInfo.default\n  \n  hasFwdDeps     : Bool       := false\n  \n  backDeps       : Array Nat  := #[]\n  \n  isProp         : Bool       := false\n  \n  isDecInst      : Bool       := false\n  \n  higherOrderOutParam : Bool  := false\n  \n  dependsOnHigherOrderOutParam : Bool := false\n  deriving Inhabited", "start": [105, 1], "end": [150, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ParamInfo.isImplicit", "code": "def ParamInfo.isImplicit (p : ParamInfo) : Bool :=\n  p.binderInfo == BinderInfo.implicit", "start": [152, 1], "end": [153, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ParamInfo.isInstImplicit", "code": "def ParamInfo.isInstImplicit (p : ParamInfo) : Bool :=\n  p.binderInfo == BinderInfo.instImplicit", "start": [155, 1], "end": [156, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ParamInfo.isStrictImplicit", "code": "def ParamInfo.isStrictImplicit (p : ParamInfo) : Bool :=\n  p.binderInfo == BinderInfo.strictImplicit", "start": [158, 1], "end": [159, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ParamInfo.isExplicit", "code": "def ParamInfo.isExplicit (p : ParamInfo) : Bool :=\n  p.binderInfo == BinderInfo.default", "start": [161, 1], "end": [162, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FunInfo", "code": "structure FunInfo where\n  \n  paramInfo  : Array ParamInfo := #[]\n  \n  resultDeps : Array Nat       := #[]", "start": [165, 1], "end": [175, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.InfoCacheKey", "code": "structure InfoCacheKey where\n  \n  transparency : TransparencyMode\n  \n  expr         : Expr\n  \n  nargs?       : Option Nat\n  deriving Inhabited, BEq", "start": [177, 1], "end": [191, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstanceCache", "code": "abbrev SynthInstanceCache := PersistentHashMap (LocalInstances \u00d7 Expr) (Option Expr)", "start": [198, 1], "end": [198, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.InferTypeCache", "code": "abbrev InferTypeCache := PersistentExprStructMap Expr", "start": [200, 1], "end": [200, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FunInfoCache", "code": "abbrev FunInfoCache   := PersistentHashMap InfoCacheKey FunInfo", "start": [201, 1], "end": [201, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.WhnfCache", "code": "abbrev WhnfCache      := PersistentExprStructMap Expr", "start": [202, 1], "end": [202, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DefEqCache", "code": "structure DefEqCache where\n  reducible : PersistentHashMap (Expr \u00d7 Expr) Bool := {}\n  instances : PersistentHashMap (Expr \u00d7 Expr) Bool := {}\n  default   : PersistentHashMap (Expr \u00d7 Expr) Bool := {}\n  all       : PersistentHashMap (Expr \u00d7 Expr) Bool := {}\n  deriving Inhabited", "start": [204, 1], "end": [213, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cache", "code": "structure Cache where\n  inferType      : InferTypeCache := {}\n  funInfo        : FunInfoCache   := {}\n  synthInstance  : SynthInstanceCache := {}\n  whnfDefault    : WhnfCache := {} whnfAll        : WhnfCache := {} defEqTrans     : DefEqCache := {} defEqPerm      : DefEqCache := {} deriving Inhabited", "start": [215, 1], "end": [226, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DefEqContext", "code": "structure DefEqContext where\n  lhs            : Expr\n  rhs            : Expr\n  lctx           : LocalContext\n  localInstances : LocalInstances", "start": [228, 1], "end": [236, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.PostponedEntry", "code": "structure PostponedEntry where\n  \n  ref  : Syntax\n  lhs  : Level\n  rhs  : Level\n  \n  ctx? : Option DefEqContext\n  deriving Inhabited", "start": [238, 1], "end": [250, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.State", "code": "structure State where\n  mctx           : MetavarContext := {}\n  cache          : Cache := {}\n  \n  zetaFVarIds    : FVarIdSet := {}\n  \n  postponed      : PersistentArray PostponedEntry := {}\n  deriving Inhabited", "start": [252, 1], "end": [262, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SavedState", "code": "structure SavedState where\n  core        : Core.State\n  meta        : State\n  deriving Nonempty", "start": [264, 1], "end": [270, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Context", "code": "structure Context where\n  config            : Config               := {}\n  \n  lctx              : LocalContext         := {}\n  \n  localInstances    : LocalInstances       := #[]\n  \n  defEqCtx?         : Option DefEqContext  := none\n  \n  synthPendingDepth : Nat                  := 0\n  \n  canUnfold?        : Option (Config \u2192 ConstantInfo \u2192 CoreM Bool) := none", "start": [272, 1], "end": [293, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MetaM", "code": "abbrev MetaM  := ReaderT Context $ StateRefT State CoreM", "start": [295, 1], "end": [295, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.saveState", "code": "protected def saveState : MetaM SavedState :=\n  return { core := (\u2190 getThe Core.State), meta := (\u2190 get) }", "start": [319, 1], "end": [320, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SavedState.restore", "code": "def SavedState.restore (b : SavedState) : MetaM Unit := do\n  Core.restore b.core\n  modify fun s => { s with mctx := b.meta.mctx, zetaFVarIds := b.meta.zetaFVarIds, postponed := b.meta.postponed }", "start": [322, 1], "end": [325, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MetaM.run", "code": "@[inline] def MetaM.run (x : MetaM \u03b1) (ctx : Context := {}) (s : State := {}) : CoreM (\u03b1 \u00d7 State) :=\n  x ctx |>.run s", "start": [331, 1], "end": [332, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MetaM.run'", "code": "@[inline] def MetaM.run' (x : MetaM \u03b1) (ctx : Context := {}) (s : State := {}) : CoreM \u03b1 :=\n  Prod.fst <$> x.run ctx s", "start": [334, 1], "end": [335, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MetaM.toIO", "code": "@[inline] def MetaM.toIO (x : MetaM \u03b1) (ctxCore : Core.Context) (sCore : Core.State) (ctx : Context := {}) (s : State := {}) : IO (\u03b1 \u00d7 Core.State \u00d7 State) := do\n  let ((a, s), sCore) \u2190 (x.run ctx s).toIO ctxCore sCore\n  pure (a, sCore, s)", "start": [337, 1], "end": [339, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwIsDefEqStuck", "code": "protected def throwIsDefEqStuck : MetaM \u03b1 :=\n  throw <| Exception.internal isDefEqStuckExceptionId", "start": [344, 1], "end": [345, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.liftMetaM", "code": "@[inline] def liftMetaM [MonadLiftT MetaM m] (x : MetaM \u03b1) : m \u03b1 :=\n  liftM x", "start": [353, 1], "end": [354, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mapMetaM", "code": "@[inline] def mapMetaM [MonadControlT MetaM m] [Monad m] (f : forall {\u03b1}, MetaM \u03b1 \u2192 MetaM \u03b1) {\u03b1} (x : m \u03b1) : m \u03b1 :=\n  controlAt MetaM fun runInBase => f <| runInBase x", "start": [356, 1], "end": [357, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.map1MetaM", "code": "@[inline] def map1MetaM [MonadControlT MetaM m] [Monad m] (f : forall {\u03b1}, (\u03b2 \u2192 MetaM \u03b1) \u2192 MetaM \u03b1) {\u03b1} (k : \u03b2 \u2192 m \u03b1) : m \u03b1 :=\n  controlAt MetaM fun runInBase => f fun b => runInBase <| k b", "start": [359, 1], "end": [360, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.map2MetaM", "code": "@[inline] def map2MetaM [MonadControlT MetaM m] [Monad m] (f : forall {\u03b1}, (\u03b2 \u2192 \u03b3 \u2192 MetaM \u03b1) \u2192 MetaM \u03b1) {\u03b1} (k : \u03b2 \u2192 \u03b3 \u2192 m \u03b1) : m \u03b1 :=\n  controlAt MetaM fun runInBase => f fun b c => runInBase <| k b c", "start": [362, 1], "end": [363, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.modifyCache", "code": "@[inline] def modifyCache (f : Cache \u2192 Cache) : MetaM Unit :=\n  modify fun \u27e8mctx, cache, zetaFVarIds, postponed\u27e9 => \u27e8mctx, f cache, zetaFVarIds, postponed\u27e9", "start": [368, 1], "end": [369, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.modifyInferTypeCache", "code": "@[inline] def modifyInferTypeCache (f : InferTypeCache \u2192 InferTypeCache) : MetaM Unit :=\n  modifyCache fun \u27e8ic, c1, c2, c3, c4, c5, c6\u27e9 => \u27e8f ic, c1, c2, c3, c4, c5, c6\u27e9", "start": [371, 1], "end": [372, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.modifyDefEqTransientCache", "code": "@[inline] def modifyDefEqTransientCache (f : DefEqCache \u2192 DefEqCache) : MetaM Unit :=\n  modifyCache fun \u27e8c1, c2, c3, c4, c5, defeqTrans, c6\u27e9 => \u27e8c1, c2, c3, c4, c5, f defeqTrans, c6\u27e9", "start": [374, 1], "end": [375, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.modifyDefEqPermCache", "code": "@[inline] def modifyDefEqPermCache (f : DefEqCache \u2192 DefEqCache) : MetaM Unit :=\n  modifyCache fun \u27e8c1, c2, c3, c4, c5, c6, defeqPerm\u27e9 => \u27e8c1, c2, c3, c4, c5, c6, f defeqPerm\u27e9", "start": [377, 1], "end": [378, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.resetDefEqPermCaches", "code": "@[inline] def resetDefEqPermCaches : MetaM Unit :=\n  modifyDefEqPermCache fun _ => {}", "start": [380, 1], "end": [381, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getLocalInstances", "code": "def getLocalInstances : MetaM LocalInstances :=\n  return (\u2190 read).localInstances", "start": [383, 1], "end": [384, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getConfig", "code": "def getConfig : MetaM Config :=\n  return (\u2190 read).config", "start": [386, 1], "end": [387, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.resetZetaFVarIds", "code": "def resetZetaFVarIds : MetaM Unit :=\n  modify fun s => { s with zetaFVarIds := {} }", "start": [389, 1], "end": [390, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getZetaFVarIds", "code": "def getZetaFVarIds : MetaM FVarIdSet :=\n  return (\u2190 get).zetaFVarIds", "start": [392, 1], "end": [393, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getPostponed", "code": "def getPostponed : MetaM (PersistentArray PostponedEntry) :=\n  return (\u2190 get).postponed", "start": [395, 1], "end": [397, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.setPostponed", "code": "def setPostponed (postponed : PersistentArray PostponedEntry) : MetaM Unit :=\n  modify fun s => { s with postponed := postponed }", "start": [399, 1], "end": [401, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.modifyPostponed", "code": "@[inline] def modifyPostponed (f : PersistentArray PostponedEntry \u2192 PersistentArray PostponedEntry) : MetaM Unit :=\n  modify fun s => { s with postponed := f s.postponed }", "start": [403, 1], "end": [405, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.useEtaStruct", "code": "def useEtaStruct (inductName : Name) : MetaM Bool := do\n  match (\u2190 getConfig).etaStruct with\n  | .none => return false\n  | .all  => return true\n  | .notClasses => return !isClass (\u2190 getEnv) inductName", "start": [407, 1], "end": [420, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnf", "code": "@[extern 6 \"lean_whnf\"] opaque whnf : Expr \u2192 MetaM Expr", "start": [427, 1], "end": [430, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.inferType", "code": "@[extern 6 \"lean_infer_type\"] opaque inferType : Expr \u2192 MetaM Expr", "start": [431, 1], "end": [432, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isExprDefEqAux", "code": "@[extern 7 \"lean_is_expr_def_eq\"] opaque isExprDefEqAux : Expr \u2192 Expr \u2192 MetaM Bool", "start": [433, 1], "end": [433, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isLevelDefEqAux", "code": "@[extern 7 \"lean_is_level_def_eq\"] opaque isLevelDefEqAux : Level \u2192 Level \u2192 MetaM Bool", "start": [434, 1], "end": [434, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.synthPending", "code": "@[extern 6 \"lean_synth_pending\"] protected opaque synthPending : MVarId \u2192 MetaM Bool", "start": [435, 1], "end": [435, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfForall", "code": "def whnfForall (e : Expr) : MetaM Expr := do\n  let e' \u2190 whnf e\n  if e'.isForall then pure e' else pure e", "start": [437, 1], "end": [439, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withIncRecDepth", "code": "protected def withIncRecDepth (x : n \u03b1) : n \u03b1 :=\n  mapMetaM (withIncRecDepth (m := MetaM)) x", "start": [442, 1], "end": [443, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshExprMVarAtCore", "code": "private def mkFreshExprMVarAtCore\n    (mvarId : MVarId) (lctx : LocalContext) (localInsts : LocalInstances) (type : Expr) (kind : MetavarKind) (userName : Name) (numScopeArgs : Nat) : MetaM Expr := do\n  modifyMCtx fun mctx => mctx.addExprMVarDecl mvarId userName lctx localInsts type kind numScopeArgs;\n  return mkMVar mvarId", "start": [445, 1], "end": [448, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshExprMVarAt", "code": "def mkFreshExprMVarAt\n    (lctx : LocalContext) (localInsts : LocalInstances) (type : Expr)\n    (kind : MetavarKind := MetavarKind.natural) (userName : Name := Name.anonymous) (numScopeArgs : Nat := 0)\n    : MetaM Expr := do\n  mkFreshExprMVarAtCore (\u2190 mkFreshMVarId) lctx localInsts type kind userName numScopeArgs", "start": [450, 1], "end": [454, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshLevelMVar", "code": "def mkFreshLevelMVar : MetaM Level := do\n  let mvarId \u2190 mkFreshLMVarId\n  modifyMCtx fun mctx => mctx.addLevelMVarDecl mvarId;\n  return mkLevelMVar mvarId", "start": [456, 1], "end": [459, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshExprMVarCore", "code": "private def mkFreshExprMVarCore (type : Expr) (kind : MetavarKind) (userName : Name) : MetaM Expr := do\n  mkFreshExprMVarAt (\u2190 getLCtx) (\u2190 getLocalInstances) type kind userName", "start": [461, 1], "end": [462, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshExprMVarImpl", "code": "private def mkFreshExprMVarImpl (type? : Option Expr) (kind : MetavarKind) (userName : Name) : MetaM Expr :=\n  match type? with\n  | some type => mkFreshExprMVarCore type kind userName\n  | none      => do\n    let u \u2190 mkFreshLevelMVar\n    let type \u2190 mkFreshExprMVarCore (mkSort u) MetavarKind.natural Name.anonymous\n    mkFreshExprMVarCore type kind userName", "start": [464, 1], "end": [470, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshExprMVar", "code": "def mkFreshExprMVar (type? : Option Expr) (kind := MetavarKind.natural) (userName := Name.anonymous) : MetaM Expr :=\n  mkFreshExprMVarImpl type? kind userName", "start": [472, 1], "end": [473, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshTypeMVar", "code": "def mkFreshTypeMVar (kind := MetavarKind.natural) (userName := Name.anonymous) : MetaM Expr := do\n  let u \u2190 mkFreshLevelMVar\n  mkFreshExprMVar (mkSort u) kind userName", "start": [475, 1], "end": [477, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshExprMVarWithIdCore", "code": "private def mkFreshExprMVarWithIdCore (mvarId : MVarId) (type : Expr)\n    (kind : MetavarKind := MetavarKind.natural) (userName : Name := Name.anonymous) (numScopeArgs : Nat := 0)\n    : MetaM Expr := do\n  mkFreshExprMVarAtCore mvarId (\u2190 getLCtx) (\u2190 getLocalInstances) type kind userName numScopeArgs", "start": [479, 1], "end": [484, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshExprMVarWithId", "code": "def mkFreshExprMVarWithId (mvarId : MVarId) (type? : Option Expr := none) (kind : MetavarKind := MetavarKind.natural) (userName := Name.anonymous) : MetaM Expr :=\n  match type? with\n  | some type => mkFreshExprMVarWithIdCore mvarId type kind userName\n  | none      => do\n    let u \u2190 mkFreshLevelMVar\n    let type \u2190 mkFreshExprMVar (mkSort u)\n    mkFreshExprMVarWithIdCore mvarId type kind userName", "start": [486, 1], "end": [492, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshLevelMVars", "code": "def mkFreshLevelMVars (num : Nat) : MetaM (List Level) :=\n  num.foldM (init := []) fun _ us =>\n    return (\u2190 mkFreshLevelMVar)::us", "start": [494, 1], "end": [496, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshLevelMVarsFor", "code": "def mkFreshLevelMVarsFor (info : ConstantInfo) : MetaM (List Level) :=\n  mkFreshLevelMVars info.numLevelParams", "start": [498, 1], "end": [499, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkConstWithFreshMVarLevels", "code": "def mkConstWithFreshMVarLevels (declName : Name) : MetaM Expr := do\n  let info \u2190 getConstInfo declName\n  return mkConst declName (\u2190 mkFreshLevelMVarsFor info)", "start": [501, 1], "end": [507, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getTransparency", "code": "def getTransparency : MetaM TransparencyMode :=\n  return (\u2190 getConfig).transparency", "start": [509, 1], "end": [511, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.shouldReduceAll", "code": "def shouldReduceAll : MetaM Bool :=\n  return (\u2190 getTransparency) == TransparencyMode.all", "start": [513, 1], "end": [514, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.shouldReduceReducibleOnly", "code": "def shouldReduceReducibleOnly : MetaM Bool :=\n  return (\u2190 getTransparency) == TransparencyMode.reducible", "start": [516, 1], "end": [517, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.findDecl?", "code": "def _root_.Lean.MVarId.findDecl? (mvarId : MVarId) : MetaM (Option MetavarDecl) :=\n  return (\u2190 getMCtx).findDecl? mvarId", "start": [519, 1], "end": [524, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.findMVarDecl?", "code": "@[deprecated MVarId.findDecl?]\ndef findMVarDecl? (mvarId : MVarId) : MetaM (Option MetavarDecl) :=\n  mvarId.findDecl?", "start": [526, 1], "end": [528, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.getDecl", "code": "def _root_.Lean.MVarId.getDecl (mvarId : MVarId) : MetaM MetavarDecl := do\n  match (\u2190 mvarId.findDecl?) with\n  | some d => pure d\n  | none   => throwError \"unknown metavariable '?{mvarId.name}'\"", "start": [530, 1], "end": [537, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMVarDecl", "code": "@[deprecated MVarId.getDecl]\ndef getMVarDecl (mvarId : MVarId) : MetaM MetavarDecl := do\n  mvarId.getDecl", "start": [539, 1], "end": [541, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.getKind", "code": "def _root_.Lean.MVarId.getKind (mvarId : MVarId) : MetaM MetavarKind :=\n  return (\u2190 mvarId.getDecl).kind", "start": [543, 1], "end": [547, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMVarDeclKind", "code": "@[deprecated MVarId.getKind]\ndef getMVarDeclKind (mvarId : MVarId) : MetaM MetavarKind :=\n  mvarId.getKind", "start": [549, 1], "end": [551, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isSyntheticMVar", "code": "def isSyntheticMVar (e : Expr) : MetaM Bool := do\n  if e.isMVar then\n     return (\u2190 e.mvarId!.getKind) matches .synthetic | .syntheticOpaque\n  else\n     return false", "start": [553, 1], "end": [558, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.setKind", "code": "def _root_.Lean.MVarId.setKind (mvarId : MVarId) (kind : MetavarKind) : MetaM Unit :=\n  modifyMCtx fun mctx => mctx.setMVarKind mvarId kind", "start": [560, 1], "end": [564, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.setMVarKind", "code": "@[deprecated MVarId.setKind]\ndef setMVarKind (mvarId : MVarId) (kind : MetavarKind) : MetaM Unit :=\n  mvarId.setKind kind", "start": [566, 1], "end": [568, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.setType", "code": "def _root_.Lean.MVarId.setType (mvarId : MVarId) (type : Expr) : MetaM Unit := do\n  modifyMCtx fun mctx => mctx.setMVarType mvarId type", "start": [570, 1], "end": [573, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.setMVarType", "code": "@[deprecated MVarId.setType]\ndef setMVarType (mvarId : MVarId) (type : Expr) : MetaM Unit := do\n  mvarId.setType type", "start": [575, 1], "end": [577, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.isReadOnly", "code": "def _root_.Lean.MVarId.isReadOnly (mvarId : MVarId) : MetaM Bool := do\n  return (\u2190 mvarId.getDecl).depth != (\u2190 getMCtx).depth", "start": [579, 1], "end": [584, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isReadOnlyExprMVar", "code": "@[deprecated MVarId.isReadOnly]\ndef isReadOnlyExprMVar (mvarId : MVarId) : MetaM Bool := do\n  mvarId.isReadOnly", "start": [586, 1], "end": [588, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.isReadOnlyOrSyntheticOpaque", "code": "def _root_.Lean.MVarId.isReadOnlyOrSyntheticOpaque (mvarId : MVarId) : MetaM Bool := do\n  let mvarDecl \u2190 mvarId.getDecl\n  match mvarDecl.kind with\n  | MetavarKind.syntheticOpaque => return !(\u2190 getConfig).assignSyntheticOpaque\n  | _ => return mvarDecl.depth != (\u2190 getMCtx).depth", "start": [590, 1], "end": [599, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar", "code": "@[deprecated MVarId.isReadOnlyOrSyntheticOpaque]\ndef isReadOnlyOrSyntheticOpaqueExprMVar (mvarId : MVarId) : MetaM Bool := do\n  mvarId.isReadOnlyOrSyntheticOpaque", "start": [601, 1], "end": [603, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.LMVarId.getLevel", "code": "def _root_.Lean.LMVarId.getLevel (mvarId : LMVarId) : MetaM Nat := do\n  match (\u2190 getMCtx).findLevelDepth? mvarId with\n  | some depth => return depth\n  | _          => throwError \"unknown universe metavariable '?{mvarId.name}'\"", "start": [605, 1], "end": [611, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getLevelMVarDepth", "code": "@[deprecated LMVarId.getLevel]\ndef getLevelMVarDepth (mvarId : LMVarId) : MetaM Nat :=\n  mvarId.getLevel", "start": [613, 1], "end": [615, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.LMVarId.isReadOnly", "code": "def _root_.Lean.LMVarId.isReadOnly (mvarId : LMVarId) : MetaM Bool :=\n  return (\u2190 mvarId.getLevel) < (\u2190 getMCtx).levelAssignDepth", "start": [617, 1], "end": [622, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isReadOnlyLevelMVar", "code": "@[deprecated LMVarId.isReadOnly]\ndef isReadOnlyLevelMVar (mvarId : LMVarId) : MetaM Bool := do\n  mvarId.isReadOnly", "start": [624, 1], "end": [626, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.setUserName", "code": "def _root_.Lean.MVarId.setUserName (mvarId : MVarId) (newUserName : Name) : MetaM Unit :=\n  modifyMCtx fun mctx => mctx.setMVarUserName mvarId newUserName", "start": [628, 1], "end": [632, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.setMVarUserName", "code": "@[deprecated MVarId.setUserName]\ndef setMVarUserName (mvarId : MVarId) (userNameNew : Name) : MetaM Unit :=\n  mvarId.setUserName userNameNew", "start": [634, 1], "end": [636, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.throwUnknown", "code": "def _root_.Lean.FVarId.throwUnknown (fvarId : FVarId) : CoreM \u03b1 :=\n  throwError \"unknown free variable '{mkFVar fvarId}'\"", "start": [638, 1], "end": [642, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwUnknownFVar", "code": "@[deprecated FVarId.throwUnknown]\ndef throwUnknownFVar (fvarId : FVarId) : MetaM \u03b1 :=\n  fvarId.throwUnknown", "start": [644, 1], "end": [646, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.findDecl?", "code": "def _root_.Lean.FVarId.findDecl? (fvarId : FVarId) : MetaM (Option LocalDecl) :=\n  return (\u2190 getLCtx).find? fvarId", "start": [648, 1], "end": [652, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.findLocalDecl?", "code": "@[deprecated FVarId.findDecl?]\ndef findLocalDecl? (fvarId : FVarId) : MetaM (Option LocalDecl) :=\n  fvarId.findDecl?", "start": [654, 1], "end": [656, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.getDecl", "code": "def _root_.Lean.FVarId.getDecl (fvarId : FVarId) : MetaM LocalDecl := do\n  match (\u2190 getLCtx).find? fvarId with\n  | some d => return d\n  | none   => fvarId.throwUnknown", "start": [658, 1], "end": [665, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getLocalDecl", "code": "@[deprecated FVarId.getDecl]\ndef getLocalDecl (fvarId : FVarId) : MetaM LocalDecl := do\n  fvarId.getDecl", "start": [667, 1], "end": [669, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.getType", "code": "def _root_.Lean.FVarId.getType (fvarId : FVarId) : MetaM Expr :=\n  return (\u2190 fvarId.getDecl).type", "start": [671, 1], "end": [673, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.getBinderInfo", "code": "def _root_.Lean.FVarId.getBinderInfo (fvarId : FVarId) : MetaM BinderInfo :=\n  return (\u2190 fvarId.getDecl).binderInfo", "start": [675, 1], "end": [677, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.getValue?", "code": "def _root_.Lean.FVarId.getValue? (fvarId : FVarId) : MetaM (Option Expr) :=\n  return (\u2190 fvarId.getDecl).value?", "start": [679, 1], "end": [681, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.getUserName", "code": "def _root_.Lean.FVarId.getUserName (fvarId : FVarId) : MetaM Name :=\n  return (\u2190 fvarId.getDecl).userName", "start": [683, 1], "end": [685, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.FVarId.isLetVar", "code": "def _root_.Lean.FVarId.isLetVar (fvarId : FVarId) : MetaM Bool :=\n  return (\u2190 fvarId.getDecl).isLet", "start": [687, 1], "end": [689, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getFVarLocalDecl", "code": "def getFVarLocalDecl (fvar : Expr) : MetaM LocalDecl :=\n  fvar.fvarId!.getDecl", "start": [691, 1], "end": [694, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getLocalDeclFromUserName", "code": "def getLocalDeclFromUserName (userName : Name) : MetaM LocalDecl := do\n  match (\u2190 getLCtx).findFromUserName? userName with\n  | some d => pure d\n  | none   => throwError \"unknown local declaration '{userName}'\"", "start": [696, 1], "end": [703, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getFVarFromUserName", "code": "def getFVarFromUserName (userName : Name) : MetaM Expr := do\n  let d \u2190 getLocalDeclFromUserName userName\n  return Expr.fvar d.fvarId", "start": [705, 1], "end": [708, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.liftMkBindingM", "code": "@[inline] def liftMkBindingM (x : MetavarContext.MkBindingM \u03b1) : MetaM \u03b1 := do\n  match x { lctx := (\u2190 getLCtx), mainModule := (\u2190 getEnv).mainModule } { mctx := (\u2190 getMCtx), ngen := (\u2190 getNGen), nextMacroScope := (\u2190 getThe Core.State).nextMacroScope } with\n  | .ok e sNew => do\n    setMCtx sNew.mctx\n    modifyThe Core.State fun s => { s with ngen := sNew.ngen, nextMacroScope := sNew.nextMacroScope }\n    pure e\n  | .error (.revertFailure ..) sNew => do\n    setMCtx sNew.mctx\n    modifyThe Core.State fun s => { s with ngen := sNew.ngen, nextMacroScope := sNew.nextMacroScope }\n    throwError \"failed to create binder due to failure when reverting variable dependencies\"", "start": [710, 1], "end": [722, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.abstractRangeM", "code": "def _root_.Lean.Expr.abstractRangeM (e : Expr) (n : Nat) (xs : Array Expr) : MetaM Expr :=\n  liftMkBindingM <| MetavarContext.abstractRange e n xs", "start": [724, 1], "end": [732, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.abstractRange", "code": "@[deprecated Expr.abstractRangeM]\ndef abstractRange (e : Expr) (n : Nat) (xs : Array Expr) : MetaM Expr :=\n  e.abstractRangeM n xs", "start": [734, 1], "end": [736, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.abstractM", "code": "def _root_.Lean.Expr.abstractM (e : Expr) (xs : Array Expr) : MetaM Expr :=\n  e.abstractRangeM xs.size xs", "start": [738, 1], "end": [743, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.abstract", "code": "@[deprecated Expr.abstractM]\ndef abstract (e : Expr) (xs : Array Expr) : MetaM Expr :=\n  e.abstractM xs", "start": [745, 1], "end": [747, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.collectForwardDeps", "code": "def collectForwardDeps (toRevert : Array Expr) (preserveOrder : Bool) : MetaM (Array Expr) := do\n  liftMkBindingM <| MetavarContext.collectForwardDeps toRevert preserveOrder", "start": [749, 1], "end": [754, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkForallFVars", "code": "def mkForallFVars (xs : Array Expr) (e : Expr) (usedOnly : Bool := false) (usedLetOnly : Bool := true) (binderInfoForMVars := BinderInfo.implicit) : MetaM Expr :=\n  if xs.isEmpty then return e else liftMkBindingM <| MetavarContext.mkForall xs e usedOnly usedLetOnly binderInfoForMVars", "start": [756, 1], "end": [762, 122], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLambdaFVars", "code": "def mkLambdaFVars (xs : Array Expr) (e : Expr) (usedOnly : Bool := false) (usedLetOnly : Bool := true) (binderInfoForMVars := BinderInfo.implicit) : MetaM Expr :=\n  if xs.isEmpty then return e else liftMkBindingM <| MetavarContext.mkLambda xs e usedOnly usedLetOnly binderInfoForMVars", "start": [764, 1], "end": [768, 122], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLetFVars", "code": "def mkLetFVars (xs : Array Expr) (e : Expr) (usedLetOnly := true) (binderInfoForMVars := BinderInfo.implicit) : MetaM Expr :=\n  mkLambdaFVars xs e (usedLetOnly := usedLetOnly) (binderInfoForMVars := binderInfoForMVars)", "start": [770, 1], "end": [771, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFunUnit", "code": "def mkFunUnit (a : Expr) : MetaM Expr :=\n  return Lean.mkLambda (\u2190 mkFreshUserName `x) BinderInfo.default (mkConst ``Unit) a", "start": [773, 1], "end": [775, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.elimMVarDeps", "code": "def elimMVarDeps (xs : Array Expr) (e : Expr) (preserveOrder : Bool := false) : MetaM Expr :=\n  if xs.isEmpty then pure e else liftMkBindingM <| MetavarContext.elimMVarDeps xs e preserveOrder", "start": [777, 1], "end": [778, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withConfig", "code": "@[inline] def withConfig (f : Config \u2192 Config) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withReader (fun ctx => { ctx with config := f ctx.config })", "start": [780, 1], "end": [782, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withTrackingZeta", "code": "@[inline] def withTrackingZeta (x : n \u03b1) : n \u03b1 :=\n  withConfig (fun cfg => { cfg with trackZeta := true }) x", "start": [784, 1], "end": [785, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withoutProofIrrelevance", "code": "@[inline] def withoutProofIrrelevance (x : n \u03b1) : n \u03b1 :=\n  withConfig (fun cfg => { cfg with proofIrrelevance := false }) x", "start": [787, 1], "end": [788, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withTransparency", "code": "@[inline] def withTransparency (mode : TransparencyMode) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withConfig (fun config => { config with transparency := mode })", "start": [790, 1], "end": [791, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withDefault", "code": "@[inline] def withDefault (x : n \u03b1) : n \u03b1 :=\n  withTransparency TransparencyMode.default x", "start": [793, 1], "end": [795, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withReducible", "code": "@[inline] def withReducible (x : n \u03b1) : n \u03b1 :=\n  withTransparency TransparencyMode.reducible x", "start": [797, 1], "end": [799, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withReducibleAndInstances", "code": "@[inline] def withReducibleAndInstances (x : n \u03b1) : n \u03b1 :=\n  withTransparency TransparencyMode.instances x", "start": [801, 1], "end": [806, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withAtLeastTransparency", "code": "@[inline] def withAtLeastTransparency (mode : TransparencyMode) (x : n \u03b1) : n \u03b1 :=\n  withConfig\n    (fun config =>\n      let oldMode := config.transparency\n      let mode    := if oldMode.lt mode then mode else oldMode\n      { config with transparency := mode })\n    x", "start": [808, 1], "end": [818, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withAssignableSyntheticOpaque", "code": "@[inline] def withAssignableSyntheticOpaque (x : n \u03b1) : n \u03b1 :=\n  withConfig (fun config => { config with assignSyntheticOpaque := true }) x", "start": [820, 1], "end": [822, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.savingCacheImpl", "code": "@[inline] private def savingCacheImpl (x : MetaM \u03b1) : MetaM \u03b1 := do\n  let savedCache := (\u2190 get).cache\n  try x finally modify fun s => { s with cache := savedCache }", "start": [824, 1], "end": [827, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.savingCache", "code": "@[inline] def savingCache : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM savingCacheImpl", "start": [829, 1], "end": [830, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getTheoremInfo", "code": "def getTheoremInfo (info : ConstantInfo) : MetaM (Option ConstantInfo) := do\n  if (\u2190 shouldReduceAll) then\n    return some info\n  else\n    return none", "start": [832, 1], "end": [836, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getDefInfoTemp", "code": "private def getDefInfoTemp (info : ConstantInfo) : MetaM (Option ConstantInfo) := do\n  match (\u2190 getTransparency) with\n  | TransparencyMode.all => return some info\n  | TransparencyMode.default => return some info\n  | _ =>\n    if (\u2190 isReducible info.name) then\n      return some info\n    else\n      return none", "start": [838, 1], "end": [846, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getConstTemp?", "code": "private def getConstTemp? (constName : Name) : MetaM (Option ConstantInfo) := do\n  match (\u2190 getEnv).find? constName with\n  | some (info@(ConstantInfo.thmInfo _))  => getTheoremInfo info\n  | some (info@(ConstantInfo.defnInfo _)) => getDefInfoTemp info\n  | some info                             => pure (some info)\n  | none                                  => throwUnknownConstant constName", "start": [848, 1], "end": [857, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isClassQuickConst?", "code": "private def isClassQuickConst? (constName : Name) : MetaM (LOption Name) := do\n  if isClass (\u2190 getEnv) constName then\n    return .some constName\n  else\n    match (\u2190 getConstTemp? constName) with\n    | some (.defnInfo ..) => return .undef | _ => return .none", "start": [859, 1], "end": [865, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isClassQuick?", "code": "private partial def isClassQuick? : Expr \u2192 MetaM (LOption Name)\n  | .bvar ..         => return .none\n  | .lit ..          => return .none\n  | .fvar ..         => return .none\n  | .sort ..         => return .none\n  | .lam ..          => return .none\n  | .letE ..         => return .undef\n  | .proj ..         => return .undef\n  | .forallE _ _ b _ => isClassQuick? b\n  | .mdata _ e       => isClassQuick? e\n  | .const n _       => isClassQuickConst? n\n  | .mvar mvarId     => do\n    let some val \u2190 getExprMVarAssignment? mvarId | return .none\n    isClassQuick? val\n  | .app f _         => do\n    match f.getAppFn with\n    | .const n ..  => isClassQuickConst? n\n    | .lam ..      => return .undef\n    | .mvar mvarId =>\n      let some val \u2190 getExprMVarAssignment? mvarId | return .none\n      match val.getAppFn with\n      | .const n .. => isClassQuickConst? n\n      | _ => return .undef\n    | _            => return .none", "start": [867, 1], "end": [890, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewLocalInstanceImp", "code": "private def withNewLocalInstanceImp (className : Name) (fvar : Expr) (k : MetaM \u03b1) : MetaM \u03b1 := do\n  let localDecl \u2190 getFVarLocalDecl fvar\n  if localDecl.isImplementationDetail then\n    k\n  else\n    withReader (fun ctx => { ctx with localInstances := ctx.localInstances.push { className := className, fvar := fvar } }) k", "start": [892, 1], "end": [897, 126], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewLocalInstance", "code": "def withNewLocalInstance (className : Name) (fvar : Expr) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withNewLocalInstanceImp className fvar", "start": [899, 1], "end": [902, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.fvarsSizeLtMaxFVars", "code": "private def fvarsSizeLtMaxFVars (fvars : Array Expr) (maxFVars? : Option Nat) : Bool :=\n  match maxFVars? with\n  | some maxFVars => fvars.size < maxFVars\n  | none          => true", "start": [904, 1], "end": [907, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewLocalInstancesImp", "code": "private partial def withNewLocalInstancesImp\n      (fvars : Array Expr) (i : Nat) (k : MetaM \u03b1) : MetaM \u03b1 := do\n    if h : i < fvars.size then\n      let fvar := fvars.get \u27e8i, h\u27e9\n      let decl \u2190 getFVarLocalDecl fvar\n      match (\u2190 isClassQuick? decl.type) with\n      | .none   => withNewLocalInstancesImp fvars (i+1) k\n      | .undef  =>\n        match (\u2190 isClassExpensive? decl.type) with\n        | none   => withNewLocalInstancesImp fvars (i+1) k\n        | some c => withNewLocalInstance c fvar <| withNewLocalInstancesImp fvars (i+1) k\n      | .some c => withNewLocalInstance c fvar <| withNewLocalInstancesImp fvars (i+1) k\n    else\n      k", "start": [910, 3], "end": [929, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallTelescopeReducingAuxAux", "code": "private partial def forallTelescopeReducingAuxAux\n      (reducing          : Bool) (maxFVars? : Option Nat)\n      (type              : Expr)\n      (k                 : Array Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n    let rec process (lctx : LocalContext) (fvars : Array Expr) (j : Nat) (type : Expr) : MetaM \u03b1 := do\n      match type with\n      | .forallE n d b bi =>\n        if fvarsSizeLtMaxFVars fvars maxFVars? then\n          let d     := d.instantiateRevRange j fvars.size fvars\n          let fvarId \u2190 mkFreshFVarId\n          let lctx  := lctx.mkLocalDecl fvarId n d bi\n          let fvar  := mkFVar fvarId\n          let fvars := fvars.push fvar\n          process lctx fvars j b\n        else\n          let type := type.instantiateRevRange j fvars.size fvars;\n          withReader (fun ctx => { ctx with lctx := lctx }) do\n            withNewLocalInstancesImp fvars j do\n              k fvars type\n      | _ =>\n        let type := type.instantiateRevRange j fvars.size fvars;\n        withReader (fun ctx => { ctx with lctx := lctx }) do\n          withNewLocalInstancesImp fvars j do\n            if reducing && fvarsSizeLtMaxFVars fvars maxFVars? then\n              let newType \u2190 whnf type\n              if newType.isForall then\n                process lctx fvars fvars.size newType\n              else\n                k fvars type\n            else\n              k fvars type\n    process (\u2190 getLCtx) #[] 0 type", "start": [931, 3], "end": [987, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallTelescopeReducingAux", "code": "private partial def forallTelescopeReducingAux (type : Expr) (maxFVars? : Option Nat) (k : Array Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n    match maxFVars? with\n    | some 0 => k #[] type\n    | _ => do\n      let newType \u2190 whnf type\n      if newType.isForall then\n        forallTelescopeReducingAuxAux true maxFVars? newType k\n      else\n        k #[] type", "start": [989, 3], "end": [997, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isClassApp?", "code": "private partial def isClassApp? (type : Expr) (instantiated := false) : MetaM (Option Name) := do\n    match type.getAppFn with\n    | .const c _ =>\n      let env \u2190 getEnv\n      if isClass env c then\n        return some c\n      else\n        match (\u2190 whnf type).getAppFn with\n        | .const c _ => if isClass env c then return some c else return none\n        | _ => return none\n    | .mvar .. =>\n      if instantiated then return none\n      isClassApp? (\u2190 instantiateMVars type) true\n    | _ => return none", "start": [1001, 3], "end": [1015, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isClassExpensive?", "code": "private partial def isClassExpensive? (type : Expr) : MetaM (Option Name) :=\n    withReducible do forallTelescopeReducingAux type none fun _ type => isClassApp? type", "start": [1017, 3], "end": [1019, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isClassImp?", "code": "private partial def isClassImp? (type : Expr) : MetaM (Option Name) := do\n    match (\u2190 isClassQuick? type) with\n    | .none   => return none\n    | .some c => return (some c)\n    | .undef  => isClassExpensive? type", "start": [1021, 3], "end": [1025, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isClass?", "code": "def isClass? (type : Expr) : MetaM (Option Name) :=\n  try isClassImp? type catch _ => return none", "start": [1029, 1], "end": [1040, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewLocalInstancesImpAux", "code": "private def withNewLocalInstancesImpAux (fvars : Array Expr) (j : Nat) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withNewLocalInstancesImp fvars j", "start": [1042, 1], "end": [1043, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewLocalInstances", "code": "partial def withNewLocalInstances (fvars : Array Expr) (j : Nat) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withNewLocalInstancesImpAux fvars j", "start": [1045, 1], "end": [1046, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallTelescopeImp", "code": "@[inline] private def forallTelescopeImp (type : Expr) (k : Array Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  forallTelescopeReducingAuxAux (reducing := false) (maxFVars? := none) type k", "start": [1048, 1], "end": [1049, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallTelescope", "code": "def forallTelescope (type : Expr) (k : Array Expr \u2192 Expr \u2192 n \u03b1) : n \u03b1 :=\n  map2MetaM (fun k => forallTelescopeImp type k) k", "start": [1051, 1], "end": [1056, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallTelescopeReducingImp", "code": "private def forallTelescopeReducingImp (type : Expr) (k : Array Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  forallTelescopeReducingAux type (maxFVars? := none) k", "start": [1058, 1], "end": [1059, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallTelescopeReducing", "code": "def forallTelescopeReducing (type : Expr) (k : Array Expr \u2192 Expr \u2192 n \u03b1) : n \u03b1 :=\n  map2MetaM (fun k => forallTelescopeReducingImp type k) k", "start": [1061, 1], "end": [1065, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallBoundedTelescopeImp", "code": "private def forallBoundedTelescopeImp (type : Expr) (maxFVars? : Option Nat) (k : Array Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  forallTelescopeReducingAux type maxFVars? k", "start": [1067, 1], "end": [1068, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallBoundedTelescope", "code": "def forallBoundedTelescope (type : Expr) (maxFVars? : Option Nat) (k : Array Expr \u2192 Expr \u2192 n \u03b1) : n \u03b1 :=\n  map2MetaM (fun k => forallBoundedTelescopeImp type maxFVars? k) k", "start": [1070, 1], "end": [1074, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.lambdaTelescopeImp", "code": "private partial def lambdaTelescopeImp (e : Expr) (consumeLet : Bool) (k : Array Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  process consumeLet (\u2190 getLCtx) #[] 0 e\nwhere\n  process (consumeLet : Bool) (lctx : LocalContext) (fvars : Array Expr) (j : Nat) (e : Expr) : MetaM \u03b1 := do\n    match consumeLet, e with\n    | _, .lam n d b bi =>\n      let d := d.instantiateRevRange j fvars.size fvars\n      let fvarId \u2190 mkFreshFVarId\n      let lctx := lctx.mkLocalDecl fvarId n d bi\n      let fvar := mkFVar fvarId\n      process consumeLet lctx (fvars.push fvar) j b\n    | true, .letE n t v b _ => do\n      let t := t.instantiateRevRange j fvars.size fvars\n      let v := v.instantiateRevRange j fvars.size fvars\n      let fvarId \u2190 mkFreshFVarId\n      let lctx := lctx.mkLetDecl fvarId n t v\n      let fvar := mkFVar fvarId\n      process true lctx (fvars.push fvar) j b\n    | _, e =>\n      let e := e.instantiateRevRange j fvars.size fvars\n      withReader (fun ctx => { ctx with lctx := lctx }) do\n        withNewLocalInstancesImp fvars j do\n          k fvars e", "start": [1076, 1], "end": [1098, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.lambdaLetTelescope", "code": "def lambdaLetTelescope (e : Expr) (k : Array Expr \u2192 Expr \u2192 n \u03b1) : n \u03b1 :=\n  map2MetaM (fun k => lambdaTelescopeImp e true k) k", "start": [1100, 1], "end": [1102, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.lambdaTelescope", "code": "def lambdaTelescope (e : Expr) (k : Array Expr \u2192 Expr \u2192 n \u03b1) : n \u03b1 :=\n  map2MetaM (fun k => lambdaTelescopeImp e false k) k", "start": [1104, 1], "end": [1109, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getParamNames", "code": "def getParamNames (declName : Name) : MetaM (Array Name) := do\n  forallTelescopeReducing (\u2190 getConstInfo declName).type fun xs _ => do\n    xs.mapM fun x => do\n      let localDecl \u2190 x.fvarId!.getDecl\n      return localDecl.userName", "start": [1111, 1], "end": [1116, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallMetaTelescopeReducingAux", "code": "private partial def forallMetaTelescopeReducingAux\n    (e : Expr) (reducing : Bool) (maxMVars? : Option Nat) (kind : MetavarKind) : MetaM (Array Expr \u00d7 Array BinderInfo \u00d7 Expr) :=\n  process #[] #[] 0 e\nwhere\n  process (mvars : Array Expr) (bis : Array BinderInfo) (j : Nat) (type : Expr) : MetaM (Array Expr \u00d7 Array BinderInfo \u00d7 Expr) := do\n    if maxMVars?.isEqSome mvars.size then\n      let type := type.instantiateRevRange j mvars.size mvars;\n      return (mvars, bis, type)\n    else\n      match type with\n      | .forallE n d b bi =>\n        let d  := d.instantiateRevRange j mvars.size mvars\n        let k  := if bi.isInstImplicit then  MetavarKind.synthetic else kind\n        let mvar \u2190 mkFreshExprMVar d k n\n        let mvars := mvars.push mvar\n        let bis   := bis.push bi\n        process mvars bis j b\n      | _ =>\n        let type := type.instantiateRevRange j mvars.size mvars;\n        if reducing then do\n          let newType \u2190 whnf type;\n          if newType.isForall then\n            process mvars bis mvars.size newType\n          else\n            return (mvars, bis, type)\n        else\n          return (mvars, bis, type)", "start": [1119, 1], "end": [1145, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallMetaTelescope", "code": "def forallMetaTelescope (e : Expr) (kind := MetavarKind.natural) : MetaM (Array Expr \u00d7 Array BinderInfo \u00d7 Expr) :=\n  forallMetaTelescopeReducingAux e (reducing := false) (maxMVars? := none) kind", "start": [1147, 1], "end": [1155, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallMetaTelescopeReducing", "code": "def forallMetaTelescopeReducing (e : Expr) (maxMVars? : Option Nat := none) (kind := MetavarKind.natural) : MetaM (Array Expr \u00d7 Array BinderInfo \u00d7 Expr) :=\n  forallMetaTelescopeReducingAux e (reducing := true) maxMVars? kind", "start": [1157, 1], "end": [1160, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forallMetaBoundedTelescope", "code": "def forallMetaBoundedTelescope (e : Expr) (maxMVars : Nat) (kind : MetavarKind := MetavarKind.natural) : MetaM (Array Expr \u00d7 Array BinderInfo \u00d7 Expr) :=\n  forallMetaTelescopeReducingAux e (reducing := true) (maxMVars? := some maxMVars) (kind := kind)", "start": [1162, 1], "end": [1165, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.lambdaMetaTelescope", "code": "partial def lambdaMetaTelescope (e : Expr) (maxMVars? : Option Nat := none) : MetaM (Array Expr \u00d7 Array BinderInfo \u00d7 Expr) :=\n  process #[] #[] 0 e\nwhere\n  process (mvars : Array Expr) (bis : Array BinderInfo) (j : Nat) (type : Expr) : MetaM (Array Expr \u00d7 Array BinderInfo \u00d7 Expr) := do\n    let finalize : Unit \u2192 MetaM (Array Expr \u00d7 Array BinderInfo \u00d7 Expr) := fun _ => do\n      let type := type.instantiateRevRange j mvars.size mvars\n      return (mvars, bis, type)\n    if maxMVars?.isEqSome mvars.size then\n      finalize ()\n    else\n      match type with\n      | .lam _ d b bi =>\n        let d     := d.instantiateRevRange j mvars.size mvars\n        let mvar \u2190 mkFreshExprMVar d\n        let mvars := mvars.push mvar\n        let bis   := bis.push bi\n        process mvars bis j b\n      | _ => finalize ()", "start": [1167, 1], "end": [1185, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewFVar", "code": "private def withNewFVar (n : Name) (fvar fvarType : Expr) (k : Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  if let some c \u2190 isClass? fvarType then\n    withNewLocalInstance c fvar <| k fvar\n  else\n    k fvar", "start": [1187, 1], "end": [1191, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLocalDeclImp", "code": "private def withLocalDeclImp (n : Name) (bi : BinderInfo) (type : Expr) (k : Expr \u2192 MetaM \u03b1) (kind : LocalDeclKind) : MetaM \u03b1 := do\n  let fvarId \u2190 mkFreshFVarId\n  let ctx \u2190 read\n  let lctx := ctx.lctx.mkLocalDecl fvarId n type bi kind\n  let fvar := mkFVar fvarId\n  withReader (fun ctx => { ctx with lctx := lctx }) do\n    withNewFVar n fvar type k", "start": [1193, 1], "end": [1199, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLocalDecl", "code": "def withLocalDecl (name : Name) (bi : BinderInfo) (type : Expr) (k : Expr \u2192 n \u03b1) (kind : LocalDeclKind := .default) : n \u03b1 :=\n  map1MetaM (fun k => withLocalDeclImp name bi type k kind) k", "start": [1201, 1], "end": [1204, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLocalDeclD", "code": "def withLocalDeclD (name : Name) (type : Expr) (k : Expr \u2192 n \u03b1) : n \u03b1 :=\n  withLocalDecl name BinderInfo.default type k", "start": [1206, 1], "end": [1207, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLocalDecls", "code": "partial def withLocalDecls\n    [Inhabited \u03b1]\n    (declInfos : Array (Name \u00d7 BinderInfo \u00d7 (Array Expr \u2192 n Expr)))\n    (k : (xs : Array Expr) \u2192 n \u03b1)\n    : n \u03b1 :=\n  loop #[]\nwhere\n  loop [Inhabited \u03b1] (acc : Array Expr) : n \u03b1 := do\n    if acc.size < declInfos.size then\n      let (name, bi, typeCtor) := declInfos[acc.size]!\n      withLocalDecl name bi (\u2190typeCtor acc) fun x => loop (acc.push x)\n    else\n      k acc", "start": [1209, 1], "end": [1228, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLocalDeclsD", "code": "def withLocalDeclsD [Inhabited \u03b1] (declInfos : Array (Name \u00d7 (Array Expr \u2192 n Expr))) (k : (xs : Array Expr) \u2192 n \u03b1) : n \u03b1 :=\n  withLocalDecls\n    (declInfos.map (fun (name, typeCtor) => (name, BinderInfo.default, typeCtor))) k", "start": [1230, 1], "end": [1232, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewBinderInfosImp", "code": "private def withNewBinderInfosImp (bs : Array (FVarId \u00d7 BinderInfo)) (k : MetaM \u03b1) : MetaM \u03b1 := do\n  let lctx := bs.foldl (init := (\u2190 getLCtx)) fun lctx (fvarId, bi) =>\n      lctx.setBinderInfo fvarId bi\n  withReader (fun ctx => { ctx with lctx := lctx }) k", "start": [1234, 1], "end": [1237, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewBinderInfos", "code": "def withNewBinderInfos (bs : Array (FVarId \u00d7 BinderInfo)) (k : n \u03b1) : n \u03b1 :=\n  mapMetaM (fun k => withNewBinderInfosImp bs k) k", "start": [1239, 1], "end": [1240, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withInstImplicitAsImplict", "code": "def withInstImplicitAsImplict (xs : Array Expr) (k : MetaM \u03b1) : MetaM \u03b1 := do\n  let newBinderInfos \u2190 xs.filterMapM fun x => do\n    let bi \u2190 x.fvarId!.getBinderInfo\n    if bi == .instImplicit then\n      return some (x.fvarId!, .implicit)\n    else\n      return none\n  withNewBinderInfos newBinderInfos k", "start": [1242, 1], "end": [1252, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLetDeclImp", "code": "private def withLetDeclImp (n : Name) (type : Expr) (val : Expr) (k : Expr \u2192 MetaM \u03b1) (kind : LocalDeclKind) : MetaM \u03b1 := do\n  let fvarId \u2190 mkFreshFVarId\n  let ctx \u2190 read\n  let lctx := ctx.lctx.mkLetDecl fvarId n type val (nonDep := false) kind\n  let fvar := mkFVar fvarId\n  withReader (fun ctx => { ctx with lctx := lctx }) do\n    withNewFVar n fvar type k", "start": [1254, 1], "end": [1260, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLetDecl", "code": "def withLetDecl (name : Name) (type : Expr) (val : Expr) (k : Expr \u2192 n \u03b1) (kind : LocalDeclKind := .default) : n \u03b1 :=\n  map1MetaM (fun k => withLetDeclImp name type val k kind) k", "start": [1262, 1], "end": [1267, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLocalInstancesImp", "code": "def withLocalInstancesImp (decls : List LocalDecl) (k : MetaM \u03b1) : MetaM \u03b1 := do\n  let mut localInsts := (\u2190 read).localInstances\n  let size := localInsts.size\n  for decl in decls do\n    unless decl.isImplementationDetail do\n      if let some className \u2190 isClass? decl.type then\n        localInsts := localInsts.push { className, fvar := decl.toExpr }\n  if localInsts.size == size then\n    k\n  else\n    withReader (fun ctx => { ctx with localInstances := localInsts }) k", "start": [1269, 1], "end": [1279, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLocalInstances", "code": "def withLocalInstances (decls : List LocalDecl) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withLocalInstancesImp decls", "start": [1281, 1], "end": [1283, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withExistingLocalDeclsImp", "code": "private def withExistingLocalDeclsImp (decls : List LocalDecl) (k : MetaM \u03b1) : MetaM \u03b1 := do\n  let ctx \u2190 read\n  let lctx := decls.foldl (fun (lctx : LocalContext) decl => lctx.addDecl decl) ctx.lctx\n  withReader (fun ctx => { ctx with lctx := lctx }) do\n    withLocalInstancesImp decls k", "start": [1285, 1], "end": [1289, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withExistingLocalDecls", "code": "def withExistingLocalDecls (decls : List LocalDecl) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withExistingLocalDeclsImp decls", "start": [1291, 1], "end": [1302, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewMCtxDepthImp", "code": "private def withNewMCtxDepthImp (allowLevelAssignments : Bool) (x : MetaM \u03b1) : MetaM \u03b1 := do\n  let saved \u2190 get\n  modify fun s => { s with mctx := s.mctx.incDepth allowLevelAssignments, postponed := {} }\n  try\n    x\n  finally\n    modify fun s => { s with mctx := saved.mctx, postponed := saved.postponed }", "start": [1304, 1], "end": [1310, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewMCtxDepth", "code": "def withNewMCtxDepth (k : n \u03b1) (allowLevelAssignments := false) : n \u03b1 :=\n  mapMetaM (withNewMCtxDepthImp allowLevelAssignments) k", "start": [1312, 1], "end": [1320, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLocalContextImp", "code": "private def withLocalContextImp (lctx : LocalContext) (localInsts : LocalInstances) (x : MetaM \u03b1) : MetaM \u03b1 := do\n  withReader (fun ctx => { ctx with lctx := lctx, localInstances := localInsts }) do\n    x", "start": [1322, 1], "end": [1324, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLCtx", "code": "def withLCtx (lctx : LocalContext) (localInsts : LocalInstances) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withLocalContextImp lctx localInsts", "start": [1326, 1], "end": [1332, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withMVarContextImp", "code": "private def withMVarContextImp (mvarId : MVarId) (x : MetaM \u03b1) : MetaM \u03b1 := do\n  let mvarDecl \u2190 mvarId.getDecl\n  withLocalContextImp mvarDecl.lctx mvarDecl.localInstances x", "start": [1334, 1], "end": [1336, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.withContext", "code": "def _root_.Lean.MVarId.withContext (mvarId : MVarId) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withMVarContextImp mvarId", "start": [1338, 1], "end": [1343, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withMVarContext", "code": "@[deprecated MVarId.withContext]\ndef withMVarContext (mvarId : MVarId) : n \u03b1 \u2192 n \u03b1 :=\n  mvarId.withContext", "start": [1345, 1], "end": [1347, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withMCtxImp", "code": "private def withMCtxImp (mctx : MetavarContext) (x : MetaM \u03b1) : MetaM \u03b1 := do\n  let mctx' \u2190 getMCtx\n  setMCtx mctx\n  try x finally setMCtx mctx'", "start": [1349, 1], "end": [1352, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withMCtx", "code": "def withMCtx (mctx : MetavarContext) : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM <| withMCtxImp mctx", "start": [1354, 1], "end": [1360, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.approxDefEqImp", "code": "@[inline] private def approxDefEqImp (x : MetaM \u03b1) : MetaM \u03b1 :=\n  withConfig (fun config => { config with foApprox := true, ctxApprox := true, quasiPatternApprox := true}) x", "start": [1362, 1], "end": [1363, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.approxDefEq", "code": "@[inline] def approxDefEq : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM approxDefEqImp", "start": [1365, 1], "end": [1367, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.fullApproxDefEqImp", "code": "@[inline] private def fullApproxDefEqImp (x : MetaM \u03b1) : MetaM \u03b1 :=\n  withConfig (fun config => { config with foApprox := true, ctxApprox := true, quasiPatternApprox := true, constApprox := true }) x", "start": [1369, 1], "end": [1370, 132], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.fullApproxDefEq", "code": "@[inline] def fullApproxDefEq : n \u03b1 \u2192 n \u03b1 :=\n  mapMetaM fullApproxDefEqImp", "start": [1372, 1], "end": [1380, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.normalizeLevel", "code": "def normalizeLevel (u : Level) : MetaM Level := do\n  let u \u2190 instantiateLevelMVars u\n  pure u.normalize", "start": [1382, 1], "end": [1385, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfR", "code": "def whnfR (e : Expr) : MetaM Expr :=\n  withTransparency TransparencyMode.reducible <| whnf e", "start": [1387, 1], "end": [1389, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfD", "code": "def whnfD (e : Expr) : MetaM Expr :=\n  withTransparency TransparencyMode.default <| whnf e", "start": [1391, 1], "end": [1393, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfI", "code": "def whnfI (e : Expr) : MetaM Expr :=\n  withTransparency TransparencyMode.instances <| whnf e", "start": [1395, 1], "end": [1397, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.setInlineAttribute", "code": "def setInlineAttribute (declName : Name) (kind := Compiler.InlineAttributeKind.inline): MetaM Unit := do\n  let env \u2190 getEnv\n  match Compiler.setInlineAttribute env declName kind with\n  | .ok env    => setEnv env\n  | .error msg => throwError msg", "start": [1399, 1], "end": [1409, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.instantiateForallAux", "code": "private partial def instantiateForallAux (ps : Array Expr) (i : Nat) (e : Expr) : MetaM Expr := do\n  if h : i < ps.size then\n    let p := ps.get \u27e8i, h\u27e9\n    match (\u2190 whnf e) with\n    | .forallE _ _ b _ => instantiateForallAux ps (i+1) (b.instantiate1 p)\n    | _                => throwError \"invalid instantiateForall, too many parameters\"\n  else\n    return e", "start": [1411, 1], "end": [1418, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.instantiateForall", "code": "def instantiateForall (e : Expr) (ps : Array Expr) : MetaM Expr :=\n  instantiateForallAux ps 0 e", "start": [1420, 1], "end": [1422, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.instantiateLambdaAux", "code": "private partial def instantiateLambdaAux (ps : Array Expr) (i : Nat) (e : Expr) : MetaM Expr := do\n  if h : i < ps.size then\n    let p := ps.get \u27e8i, h\u27e9\n    match (\u2190 whnf e) with\n    | .lam _ _ b _ => instantiateLambdaAux ps (i+1) (b.instantiate1 p)\n    | _            => throwError \"invalid instantiateLambda, too many parameters\"\n  else\n    return e", "start": [1424, 1], "end": [1431, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.instantiateLambda", "code": "def instantiateLambda (e : Expr) (ps : Array Expr) : MetaM Expr :=\n  instantiateLambdaAux ps 0 e", "start": [1433, 1], "end": [1436, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ppExprWithInfos", "code": "def ppExprWithInfos (e : Expr) : MetaM FormatWithInfos := do\n  let ctxCore  \u2190 readThe Core.Context\n  Lean.ppExprWithInfos { env := (\u2190 getEnv), mctx := (\u2190 getMCtx), lctx := (\u2190 getLCtx), opts := (\u2190 getOptions), currNamespace := ctxCore.currNamespace, openDecls := ctxCore.openDecls } e", "start": [1438, 1], "end": [1441, 185], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ppExpr", "code": "def ppExpr (e : Expr) : MetaM Format := (\u00b7.fmt) <$> ppExprWithInfos e", "start": [1443, 1], "end": [1444, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.orElse", "code": "@[inline] protected def orElse (x : MetaM \u03b1) (y : Unit \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  let s \u2190 saveState\n  try x catch _ => s.restore; y ()", "start": [1446, 1], "end": [1448, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.orelseMergeErrorsImp", "code": "@[inline] private def orelseMergeErrorsImp (x y : MetaM \u03b1)\n    (mergeRef : Syntax \u2192 Syntax \u2192 Syntax := fun r\u2081 _ => r\u2081)\n    (mergeMsg : MessageData \u2192 MessageData \u2192 MessageData := fun m\u2081 m\u2082 => m\u2081 ++ Format.line ++ m\u2082) : MetaM \u03b1 := do\n  let env  \u2190 getEnv\n  let mctx \u2190 getMCtx\n  try\n    x\n  catch ex =>\n    setEnv env\n    setMCtx mctx\n    match ex with\n    | Exception.error ref\u2081 m\u2081 =>\n      try\n        y\n      catch\n        | Exception.error ref\u2082 m\u2082 => throw <| Exception.error (mergeRef ref\u2081 ref\u2082) (mergeMsg m\u2081 m\u2082)\n        | ex => throw ex\n    | ex => throw ex", "start": [1456, 1], "end": [1473, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.orelseMergeErrors", "code": "@[inline] def orelseMergeErrors [MonadControlT MetaM m] [Monad m] (x y : m \u03b1)\n    (mergeRef : Syntax \u2192 Syntax \u2192 Syntax := fun r\u2081 _ => r\u2081)\n    (mergeMsg : MessageData \u2192 MessageData \u2192 MessageData := fun m\u2081 m\u2082 => m\u2081 ++ Format.line ++ Format.line ++ m\u2082) : m \u03b1 := do\n  controlAt MetaM fun runInBase => orelseMergeErrorsImp (runInBase x) (runInBase y) mergeRef mergeMsg", "start": [1475, 1], "end": [1482, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mapErrorImp", "code": "def mapErrorImp (x : MetaM \u03b1) (f : MessageData \u2192 MessageData) : MetaM \u03b1 := do\n  try\n    x\n  catch\n    | Exception.error ref msg => throw <| Exception.error ref <| f msg\n    | ex => throw ex", "start": [1484, 1], "end": [1490, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mapError", "code": "@[inline] def mapError [MonadControlT MetaM m] [Monad m] (x : m \u03b1) (f : MessageData \u2192 MessageData) : m \u03b1 :=\n  controlAt MetaM fun runInBase => mapErrorImp (runInBase x) f", "start": [1492, 1], "end": [1493, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.sortFVarIds", "code": "def sortFVarIds (fvarIds : Array FVarId) : MetaM (Array FVarId) := do\n  let lctx \u2190 getLCtx\n  return fvarIds.qsort fun fvarId\u2081 fvarId\u2082 =>\n    match lctx.find? fvarId\u2081, lctx.find? fvarId\u2082 with\n    | some d\u2081, some d\u2082 => d\u2081.index < d\u2082.index\n    | some _,  none    => false\n    | none,    some _  => true\n    | none,    none    => Name.quickLt fvarId\u2081.name fvarId\u2082.name", "start": [1495, 1], "end": [1505, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isInductivePredicate", "code": "def isInductivePredicate (declName : Name) : MetaM Bool := do\n  match (\u2190 getEnv).find? declName with\n  | some (.inductInfo { type := type, ..}) =>\n    forallTelescopeReducing type fun _ type => do\n      match (\u2190 whnfD type) with\n      | .sort u .. => return u == levelZero\n      | _ => return false\n  | _ => return false", "start": [1509, 1], "end": [1517, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isListLevelDefEqAux", "code": "def isListLevelDefEqAux : List Level \u2192 List Level \u2192 MetaM Bool\n  | [],    []    => return true\n  | u::us, v::vs => isLevelDefEqAux u v <&&> isListLevelDefEqAux us vs\n  | _,     _     => return false", "start": [1519, 1], "end": [1522, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getNumPostponed", "code": "def getNumPostponed : MetaM Nat := do\n  return (\u2190 getPostponed).size", "start": [1524, 1], "end": [1525, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getResetPostponed", "code": "def getResetPostponed : MetaM (PersistentArray PostponedEntry) := do\n  let ps \u2190 getPostponed\n  setPostponed {}\n  return ps", "start": [1527, 1], "end": [1530, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.exposeRelevantUniverses", "code": "private def exposeRelevantUniverses (e : Expr) (p : Level \u2192 Bool) : Expr :=\n  e.replace fun\n    | .const _ us => if us.any p then some (e.setPPUniverses true) else none\n    | .sort u     => if p u then some (e.setPPUniverses true) else none\n    | _           => none", "start": [1532, 1], "end": [1537, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLeveErrorMessageCore", "code": "private def mkLeveErrorMessageCore (header : String) (entry : PostponedEntry) : MetaM MessageData := do\n  match entry.ctx? with\n  | none =>\n    return m!\"{header}{indentD m!\"{entry.lhs} =?= {entry.rhs}\"}\"\n  | some ctx =>\n    withLCtx ctx.lctx ctx.localInstances do\n      let s   := entry.lhs.collectMVars entry.rhs.collectMVars\n      \n      let p (u : Level) := u.any fun | .mvar m => s.contains m | _ => false\n      let lhs := exposeRelevantUniverses (\u2190 instantiateMVars ctx.lhs) p\n      let rhs := exposeRelevantUniverses (\u2190 instantiateMVars ctx.rhs) p\n      try\n        addMessageContext m!\"{header}{indentD m!\"{entry.lhs} =?= {entry.rhs}\"}\\nwhile trying to unify{indentD m!\"{lhs} : {\u2190 inferType lhs}\"}\\nwith{indentD m!\"{rhs} : {\u2190 inferType rhs}\"}\"\n      catch _ =>\n        addMessageContext m!\"{header}{indentD m!\"{entry.lhs} =?= {entry.rhs}\"}\\nwhile trying to unify{indentD lhs}\\nwith{indentD rhs}\"", "start": [1539, 1], "end": [1553, 135], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLevelStuckErrorMessage", "code": "def mkLevelStuckErrorMessage (entry : PostponedEntry) : MetaM MessageData := do\n  mkLeveErrorMessageCore \"stuck at solving universe constraint\" entry", "start": [1555, 1], "end": [1556, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLevelErrorMessage", "code": "def mkLevelErrorMessage (entry : PostponedEntry) : MetaM MessageData := do\n  mkLeveErrorMessageCore \"failed to solve universe constraint\" entry", "start": [1558, 1], "end": [1559, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.processPostponedStep", "code": "private def processPostponedStep (exceptionOnFailure : Bool) : MetaM Bool := do\n  let ps \u2190 getResetPostponed\n  for p in ps do\n    unless (\u2190 withReader (fun ctx => { ctx with defEqCtx? := p.ctx? }) <| isLevelDefEqAux p.lhs p.rhs) do\n      if exceptionOnFailure then\n        withRef p.ref do\n          throwError (\u2190 mkLevelErrorMessage p)\n      else\n        return false\n  return true", "start": [1561, 1], "end": [1570, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.processPostponed", "code": "partial def processPostponed (mayPostpone : Bool := true) (exceptionOnFailure := false) : MetaM Bool := do\n  if (\u2190 getNumPostponed) == 0 then\n    return true\n  else\n    let numPostponedBegin \u2190 getNumPostponed\n    withTraceNode `Meta.isLevelDefEq.postponed\n        (fun _ => return m!\"processing #{numPostponedBegin} postponed is-def-eq level constraints\") do\n      let rec loop : MetaM Bool := do\n        let numPostponed \u2190 getNumPostponed\n        if numPostponed == 0 then\n          return true\n        else\n          if !(\u2190 processPostponedStep exceptionOnFailure) then\n            return false\n          else\n            let numPostponed' \u2190 getNumPostponed\n            if numPostponed' == 0 then\n              return true\n            else if numPostponed' < numPostponed then\n              loop\n            else\n              trace[Meta.isLevelDefEq.postponed] \"no progress solving pending is-def-eq level constraints\"\n              return mayPostpone\n      loop", "start": [1572, 1], "end": [1595, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkpointDefEq", "code": "@[specialize] def checkpointDefEq (x : MetaM Bool) (mayPostpone : Bool := true) : MetaM Bool := do\n  let s \u2190 saveState\n  \n  modifyDefEqTransientCache fun _ => {}\n  let postponed \u2190 getResetPostponed\n  try\n    if (\u2190 x) then\n      if (\u2190 processPostponed mayPostpone) then\n        let newPostponed \u2190 getPostponed\n        setPostponed (postponed ++ newPostponed)\n        return true\n      else\n        s.restore\n        return false\n    else\n      s.restore\n      return false\n  catch ex =>\n    s.restore\n    throw ex", "start": [1597, 1], "end": [1632, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isLevelDefEq", "code": "def isLevelDefEq (u v : Level) : MetaM Bool :=\n  checkpointDefEq (mayPostpone := true) <| Meta.isLevelDefEqAux u v", "start": [1634, 1], "end": [1638, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isExprDefEq", "code": "def isExprDefEq (t s : Expr) : MetaM Bool :=\n  withReader (fun ctx => { ctx with defEqCtx? := some { lhs := t, rhs := s, lctx := ctx.lctx, localInstances := ctx.localInstances } }) do\n    \n    resetDefEqPermCaches\n    checkpointDefEq (mayPostpone := true) <| Meta.isExprDefEqAux t s", "start": [1640, 1], "end": [1663, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEq", "code": "abbrev isDefEq (t s : Expr) : MetaM Bool :=\n  isExprDefEq t s", "start": [1665, 1], "end": [1678, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isExprDefEqGuarded", "code": "def isExprDefEqGuarded (a b : Expr) : MetaM Bool := do\n  try isExprDefEq a b catch _ => return false", "start": [1680, 1], "end": [1681, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqGuarded", "code": "abbrev isDefEqGuarded (t s : Expr) : MetaM Bool :=\n  isExprDefEqGuarded t s", "start": [1683, 1], "end": [1685, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqNoConstantApprox", "code": "def isDefEqNoConstantApprox (t s : Expr) : MetaM Bool :=\n  approxDefEq <| isDefEq t s", "start": [1687, 1], "end": [1688, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.etaExpand", "code": "def etaExpand (e : Expr) : MetaM Expr :=\n  withDefault do forallTelescopeReducing (\u2190 inferType e) fun xs _ => mkLambdaFVars xs (mkAppN e xs)", "start": [1690, 1], "end": [1699, 100], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/LBool.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LBool", "code": "inductive LBool where\n  | false\n  | true\n  | undef\n  deriving Inhabited, BEq", "start": [9, 1], "end": [13, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.LBool.neg", "code": "def neg : LBool \u2192 LBool\n  | true  => false\n  | false => true\n  | undef => undef", "start": [17, 1], "end": [20, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.LBool.and", "code": "def and : LBool \u2192 LBool \u2192 LBool\n  | true,  b  => b\n  | a,     _  => a", "start": [22, 1], "end": [24, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.LBool.toString", "code": "def toString : LBool \u2192 String\n  | true  => \"true\"\n  | false => \"false\"\n  | undef => \"undef\"", "start": [26, 1], "end": [29, 21], "kind": "commanddeclaration"}, {"full_name": "Bool.toLBool", "code": "def Bool.toLBool : Bool \u2192 Lean.LBool\n  | true  => Lean.LBool.true\n  | false => Lean.LBool.false", "start": [37, 1], "end": [39, 30], "kind": "commanddeclaration"}, {"full_name": "toLBoolM", "code": "@[inline] def toLBoolM {m : Type \u2192 Type} [Monad m] (x : m Bool) : m Lean.LBool := do\n  let b \u2190 x\n  pure b.toLBool", "start": [41, 1], "end": [43, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/ProjFns.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ProjectionFunctionInfo", "code": "structure ProjectionFunctionInfo where\n  \n  ctorName : Name\n  \n  numParams : Nat\n  \n  i : Nat\n  \n  fromClass : Bool\n  deriving Inhabited", "start": [10, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.mkProjectionInfoEx", "code": "@[export lean_mk_projection_info]\ndef mkProjectionInfoEx (ctorName : Name) (numParams : Nat) (i : Nat) (fromClass : Bool) : ProjectionFunctionInfo :=\n  { ctorName, numParams, i, fromClass }", "start": [25, 1], "end": [27, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.ProjectionFunctionInfo.fromClassEx", "code": "@[export lean_projection_info_from_class]\ndef ProjectionFunctionInfo.fromClassEx (info : ProjectionFunctionInfo) : Bool :=\n  info.fromClass", "start": [28, 1], "end": [30, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.addProjectionFnInfo", "code": "@[export lean_add_projection_info]\ndef addProjectionFnInfo (env : Environment) (projName : Name) (ctorName : Name) (numParams : Nat) (i : Nat) (fromClass : Bool) : Environment :=\n  projectionFnInfoExt.insert env projName { ctorName, numParams, i, fromClass }", "start": [34, 1], "end": [36, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.getProjectionFnInfo?", "code": "@[export lean_get_projection_info]\ndef getProjectionFnInfo? (env : Environment) (projName : Name) : Option ProjectionFunctionInfo :=\n  projectionFnInfoExt.find? env projName", "start": [40, 1], "end": [42, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.isProjectionFn", "code": "def isProjectionFn (env : Environment) (declName : Name) : Bool :=\n  projectionFnInfoExt.contains env declName", "start": [44, 1], "end": [45, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.getProjectionStructureName?", "code": "def getProjectionStructureName? (env : Environment) (projName : Name) : Option Name :=\n  match env.getProjectionFnInfo? projName with\n  | none          => none\n  | some projInfo =>\n    match env.find? projInfo.ctorName with\n    | some (ConstantInfo.ctorInfo val) => some val.induct\n    | _ => none", "start": [47, 1], "end": [54, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.isProjectionFn", "code": "def isProjectionFn [MonadEnv m] [Monad m] (declName : Name) : m Bool :=\n  return (\u2190 getEnv).isProjectionFn declName", "start": [58, 1], "end": [59, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.getProjectionFnInfo?", "code": "def getProjectionFnInfo? [MonadEnv m] [Monad m] (declName : Name) : m (Option ProjectionFunctionInfo) :=\n  return (\u2190 getEnv).getProjectionFnInfo? declName", "start": [61, 1], "end": [62, 50], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/InferType.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/LBool.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.instantiateBetaRevRange", "code": "partial def Expr.instantiateBetaRevRange (e : Expr) (start : Nat) (stop : Nat) (args : Array Expr) : Expr :=\n  if e.hasLooseBVars && stop > start then\n    assert! stop \u2264 args.size\n    visit e 0 |>.run\n  else\n    e\nwhere\n  visit (e : Expr) (offset : Nat) : MonadStateCacheT (ExprStructEq \u00d7 Nat) Expr Id Expr :=\n    if offset >= e.looseBVarRange then\n      return e\n    else checkCache ({ val := e : ExprStructEq }, offset) fun _ => do\n      match e with\n      | .forallE _ d b _ => return e.updateForallE! (\u2190 visit d offset) (\u2190 visit b (offset+1))\n      | .lam _ d b _     => return e.updateLambdaE! (\u2190 visit d offset) (\u2190 visit b (offset+1))\n      | .letE _ t v b _  => return e.updateLet! (\u2190 visit t offset) (\u2190 visit v offset) (\u2190 visit b (offset+1))\n      | .mdata _ b       => return e.updateMData! (\u2190 visit b offset)\n      | .proj _ _ b      => return e.updateProj! (\u2190 visit b offset)\n      | .app .. =>\n        e.withAppRev fun f revArgs => do\n        let fNew    \u2190 visit f offset\n        let revArgs \u2190 revArgs.mapM (visit \u00b7 offset)\n        if f.isBVar then\n          return fNew.betaRev revArgs\n        else\n          return mkAppRev fNew revArgs\n      | Expr.bvar vidx         =>\n        let n := stop - start\n        if vidx < offset + n then\n          return args[stop - (vidx - offset) - 1]!.liftLooseBVars 0 offset\n        else\n          return mkBVar (vidx - n)\n      | .const .. => unreachable!\n      | .fvar ..  => unreachable!\n      | .mvar ..  => unreachable!\n      | .sort ..  => unreachable!\n      | .lit ..   => unreachable!", "start": [11, 1], "end": [65, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwFunctionExpected", "code": "def throwFunctionExpected {\u03b1} (f : Expr) : MetaM \u03b1 :=\n  throwError \"function expected{indentExpr f}\"", "start": [69, 1], "end": [70, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.inferAppType", "code": "private def inferAppType (f : Expr) (args : Array Expr) : MetaM Expr := do\n  let mut fType \u2190 inferType f\n  let mut j := 0\n  \n  for i in [:args.size] do\n    match fType with\n    | Expr.forallE _ _ b _ => fType := b\n    | _ =>\n      match (\u2190 whnf <| fType.instantiateBetaRevRange j i args) with\n      | Expr.forallE _ _ b _ => j := i; fType := b\n      | _ => throwFunctionExpected <| mkAppRange f 0 (i+1) args\n  return fType.instantiateBetaRevRange j args.size args", "start": [72, 1], "end": [84, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwIncorrectNumberOfLevels", "code": "def throwIncorrectNumberOfLevels {\u03b1} (constName : Name) (us : List Level) : MetaM \u03b1 :=\n  throwError \"incorrect number of universe levels {mkConst constName us}\"", "start": [86, 1], "end": [87, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.inferConstType", "code": "private def inferConstType (c : Name) (us : List Level) : MetaM Expr := do\n  let cinfo \u2190 getConstInfo c\n  if cinfo.levelParams.length == us.length then\n    instantiateTypeLevelParams cinfo us\n  else\n    throwIncorrectNumberOfLevels c us", "start": [89, 1], "end": [94, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.inferProjType", "code": "private def inferProjType (structName : Name) (idx : Nat) (e : Expr) : MetaM Expr := do\n  let failed {\u03b1} : Unit \u2192 MetaM \u03b1 := fun _ =>\n    throwError \"invalid projection{indentExpr (mkProj structName idx e)}\"\n  let structType \u2190 inferType e\n  let structType \u2190 whnf structType\n  matchConstStruct structType.getAppFn failed fun structVal structLvls ctorVal =>\n    let n := structVal.numParams\n    let structParams := structType.getAppArgs\n    if n != structParams.size then\n      failed ()\n    else do\n      let mut ctorType \u2190 inferAppType (mkConst ctorVal.name structLvls) structParams\n      for i in [:idx] do\n        ctorType \u2190 whnf ctorType\n        match ctorType with\n        | Expr.forallE _ _ body _ =>\n          if body.hasLooseBVars then\n            ctorType := body.instantiate1 <| mkProj structName i e\n          else\n            ctorType := body\n        | _ => failed ()\n      ctorType \u2190 whnf ctorType\n      match ctorType with\n      | Expr.forallE _ d _ _ => return d.consumeTypeAnnotations\n      | _                    => failed ()", "start": [96, 1], "end": [120, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwTypeExcepted", "code": "def throwTypeExcepted {\u03b1} (type : Expr) : MetaM \u03b1 :=\n  throwError \"type expected{indentExpr type}\"", "start": [122, 1], "end": [123, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getLevel", "code": "def getLevel (type : Expr) : MetaM Level := do\n  let typeType \u2190 inferType type\n  let typeType \u2190 whnfD typeType\n  match typeType with\n  | Expr.sort lvl     => return lvl\n  | Expr.mvar mvarId  =>\n    if (\u2190 mvarId.isReadOnlyOrSyntheticOpaque) then\n      throwTypeExcepted type\n    else\n      let lvl \u2190 mkFreshLevelMVar\n      mvarId.assign (mkSort lvl)\n      return lvl\n  | _ => throwTypeExcepted type", "start": [125, 1], "end": [137, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.inferForallType", "code": "private def inferForallType (e : Expr) : MetaM Expr :=\n  forallTelescope e fun xs e => do\n    let lvl  \u2190 getLevel e\n    let lvl  \u2190 xs.foldrM (init := lvl) fun x lvl => do\n      let xType    \u2190 inferType x\n      let xTypeLvl \u2190 getLevel xType\n      return mkLevelIMax' xTypeLvl lvl\n    return mkSort lvl.normalize", "start": [139, 1], "end": [146, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.inferLambdaType", "code": "private def inferLambdaType (e : Expr) : MetaM Expr :=\n  lambdaLetTelescope e fun xs e => do\n    let type \u2190 inferType e\n    mkForallFVars xs type", "start": [148, 1], "end": [152, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwUnknownMVar", "code": "def throwUnknownMVar {\u03b1} (mvarId : MVarId) : MetaM \u03b1 :=\n  throwError \"unknown metavariable '?{mvarId.name}'\"", "start": [154, 1], "end": [155, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.inferMVarType", "code": "private def inferMVarType (mvarId : MVarId) : MetaM Expr := do\n  match (\u2190 getMCtx).findDecl? mvarId with\n  | some d => return d.type\n  | none   => throwUnknownMVar mvarId", "start": [157, 1], "end": [160, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.inferFVarType", "code": "private def inferFVarType (fvarId : FVarId) : MetaM Expr := do\n  match (\u2190 getLCtx).find? fvarId with\n  | some d => return d.type\n  | none   => fvarId.throwUnknown", "start": [162, 1], "end": [165, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkInferTypeCache", "code": "@[inline] private def checkInferTypeCache (e : Expr) (inferType : MetaM Expr) : MetaM Expr := do\n  match (\u2190 get).cache.inferType.find? e with\n  | some type => return type\n  | none =>\n    let type \u2190 inferType\n    unless e.hasMVar || type.hasMVar do\n      modifyInferTypeCache fun c => c.insert e type\n    return type", "start": [167, 1], "end": [174, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.inferTypeImp", "code": "@[export lean_infer_type]\ndef inferTypeImp (e : Expr) : MetaM Expr :=\n  let rec infer (e : Expr) :  MetaM Expr := do\n    match e with\n    | .const c []    => inferConstType c []\n    | .const c us    => checkInferTypeCache e (inferConstType c us)\n    | .proj n i s    => checkInferTypeCache e (inferProjType n i s)\n    | .app f ..      => checkInferTypeCache e (inferAppType f.getAppFn e.getAppArgs)\n    | .mvar mvarId   => inferMVarType mvarId\n    | .fvar fvarId   => inferFVarType fvarId\n    | .bvar bidx     => throwError \"unexpected bound variable {mkBVar bidx}\"\n    | .mdata _ e     => infer e\n    | .lit v         => return v.type\n    | .sort lvl      => return mkSort (mkLevelSucc lvl)\n    | .forallE ..    => checkInferTypeCache e (inferForallType e)\n    | .lam ..        => checkInferTypeCache e (inferLambdaType e)\n    | .letE ..       => checkInferTypeCache e (inferLambdaType e)\n  withIncRecDepth <| withTransparency TransparencyMode.default (infer e)", "start": [176, 1], "end": [193, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isAlwaysZero", "code": "private def isAlwaysZero : Level \u2192 Bool\n  | .zero ..    => true\n  | .mvar ..    => false\n  | .param ..   => false\n  | .succ ..    => false\n  | .max u v    => isAlwaysZero u && isAlwaysZero v\n  | .imax _ u   => isAlwaysZero u", "start": [195, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isArrowProp", "code": "private partial def isArrowProp : Expr \u2192 Nat \u2192 MetaM LBool\n  | .sort u,          0   => return isAlwaysZero (\u2190 instantiateLevelMVars u) |>.toLBool\n  | .forallE ..,      0   => return LBool.false\n  | .forallE _ _ b _, n+1 => isArrowProp b n\n  | .letE _ _ _ b _,  n   => isArrowProp b n\n  | .mdata _ e,       n   => isArrowProp e n\n  | _,                _   => return LBool.undef", "start": [206, 1], "end": [216, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isPropQuickApp", "code": "private partial def isPropQuickApp : Expr \u2192 Nat \u2192 MetaM LBool\n  | .const c lvls,   arity   => do let constType \u2190 inferConstType c lvls; isArrowProp constType arity\n  | .fvar fvarId,    arity   => do let fvarType  \u2190 inferFVarType fvarId;  isArrowProp fvarType arity\n  | .mvar mvarId,    arity   => do let mvarType  \u2190 inferMVarType mvarId;  isArrowProp mvarType arity\n  | .app f ..,       arity   => isPropQuickApp f (arity+1)\n  | .mdata _ e,      arity   => isPropQuickApp e arity\n  | .letE _ _ _ b _, arity   => isPropQuickApp b arity\n  | .lam ..,         0       => return LBool.false\n  | .lam _ _ b _,    arity+1 => isPropQuickApp b arity\n  | _,               _       => return LBool.undef", "start": [218, 1], "end": [230, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isPropQuick", "code": "partial def isPropQuick : Expr \u2192 MetaM LBool\n  | .bvar ..          => return LBool.undef\n  | .lit ..           => return LBool.false\n  | .sort ..          => return LBool.false\n  | .lam ..           => return LBool.false\n  | .letE _ _ _ b _   => isPropQuick b\n  | .proj ..          => return LBool.undef\n  | .forallE _ _ b _  => isPropQuick b\n  | .mdata _ e        => isPropQuick e\n  | .const c lvls     => do let constType \u2190 inferConstType c lvls; isArrowProp constType 0\n  | .fvar fvarId      => do let fvarType  \u2190 inferFVarType fvarId;  isArrowProp fvarType 0\n  | .mvar mvarId      => do let mvarType  \u2190 inferMVarType mvarId;  isArrowProp mvarType 0\n  | .app f ..         => isPropQuickApp f 1", "start": [232, 1], "end": [247, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isProp", "code": "def isProp (e : Expr) : MetaM Bool := do\n  match (\u2190 isPropQuick e) with\n  | .true  => return true\n  | .false => return false\n  | .undef =>\n    let type \u2190 inferType e\n    let type \u2190 whnfD type\n    match type with\n    | Expr.sort u => return isAlwaysZero (\u2190 instantiateLevelMVars u)\n    | _           => return false", "start": [249, 1], "end": [264, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isArrowProposition", "code": "private partial def isArrowProposition : Expr \u2192 Nat \u2192 MetaM LBool\n  | .forallE _ _ b _, n+1 => isArrowProposition b n\n  | .letE _ _ _ b _,  n   => isArrowProposition b n\n  | .mdata _ e,       n   => isArrowProposition e n\n  | type,             0   => isPropQuick type\n  | _,                _   => return LBool.undef", "start": [266, 1], "end": [275, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isProofQuickApp", "code": "private partial def isProofQuickApp : Expr \u2192 Nat \u2192 MetaM LBool\n  | .const c lvls,   arity   => do let constType \u2190 inferConstType c lvls; isArrowProposition constType arity\n  | .fvar fvarId,    arity   => do let fvarType  \u2190 inferFVarType fvarId;  isArrowProposition fvarType arity\n  | .mvar mvarId,    arity   => do let mvarType  \u2190 inferMVarType mvarId;  isArrowProposition mvarType arity\n  | .app f _,        arity   => isProofQuickApp f (arity+1)\n  | .mdata _ e,      arity   => isProofQuickApp e arity\n  | .letE _ _ _ b _, arity   => isProofQuickApp b arity\n  | .lam _ _ b _,    0       => isProofQuick b\n  | .lam _ _ b _,    arity+1 => isProofQuickApp b arity\n  | _,               _       => return LBool.undef", "start": [278, 1], "end": [290, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isProofQuick", "code": "partial def isProofQuick : Expr \u2192 MetaM LBool\n  | .bvar ..          => return LBool.undef\n  | .lit ..           => return LBool.false\n  | .sort ..          => return LBool.false\n  | .lam _ _ b _      => isProofQuick b\n  | .letE _ _ _ b _   => isProofQuick b\n  | .proj ..          => return LBool.undef\n  | .forallE ..       => return LBool.false\n  | .mdata _ e        => isProofQuick e\n  | .const c lvls     => do let constType \u2190 inferConstType c lvls; isArrowProposition constType 0\n  | .fvar fvarId      => do let fvarType  \u2190 inferFVarType fvarId;  isArrowProposition fvarType 0\n  | .mvar mvarId      => do let mvarType  \u2190 inferMVarType mvarId;  isArrowProposition mvarType 0\n  | .app f ..         => isProofQuickApp f 1", "start": [292, 1], "end": [307, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isProof", "code": "def isProof (e : Expr) : MetaM Bool := do\n  match (\u2190 isProofQuick e) with\n  | .true  => return true\n  | .false => return false\n  | .undef => Meta.isProp (\u2190 inferType e)", "start": [311, 1], "end": [315, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isArrowType", "code": "private partial def isArrowType : Expr \u2192 Nat \u2192 MetaM LBool\n  | .sort ..,         0   => return LBool.true\n  | .forallE ..,      0   => return LBool.false\n  | .forallE _ _ b _, n+1 => isArrowType b n\n  | .letE _ _ _ b _,  n   => isArrowType b n\n  | .mdata _ e,       n   => isArrowType e n\n  | _,                _   => return LBool.undef", "start": [317, 1], "end": [327, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isTypeQuickApp", "code": "private partial def isTypeQuickApp : Expr \u2192 Nat \u2192 MetaM LBool\n  | .const c lvls,   arity   => do let constType \u2190 inferConstType c lvls; isArrowType constType arity\n  | .fvar fvarId,    arity   => do let fvarType  \u2190 inferFVarType fvarId;  isArrowType fvarType arity\n  | .mvar mvarId,    arity   => do let mvarType  \u2190 inferMVarType mvarId;  isArrowType mvarType arity\n  | .app f _,        arity   => isTypeQuickApp f (arity+1)\n  | .mdata _ e,      arity   => isTypeQuickApp e arity\n  | .letE _ _ _ b _, arity   => isTypeQuickApp b arity\n  | .lam ..,         0       => return LBool.false\n  | .lam _ _ b _,    arity+1 => isTypeQuickApp b arity\n  | _,               _       => return LBool.undef", "start": [329, 1], "end": [341, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isTypeQuick", "code": "partial def isTypeQuick : Expr \u2192 MetaM LBool\n  | .bvar ..          => return LBool.undef\n  | .lit ..           => return LBool.false\n  | .sort ..          => return LBool.true\n  | .lam ..           => return LBool.false\n  | .letE _ _ _ b _   => isTypeQuick b\n  | .proj ..          => return LBool.undef\n  | .forallE ..       => return LBool.true\n  | .mdata _ e        => isTypeQuick e\n  | .const c lvls     => do let constType \u2190 inferConstType c lvls; isArrowType constType 0\n  | .fvar fvarId      => do let fvarType  \u2190 inferFVarType fvarId;  isArrowType fvarType 0\n  | .mvar mvarId      => do let mvarType  \u2190 inferMVarType mvarId;  isArrowType mvarType 0\n  | .app f ..         => isTypeQuickApp f 1", "start": [343, 1], "end": [358, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isType", "code": "def isType (e : Expr) : MetaM Bool := do\n  match (\u2190 isTypeQuick e) with\n  | .true  => return true\n  | .false => return false\n  | .undef =>\n    let type \u2190 inferType e\n    let type \u2190 whnfD type\n    match type with\n    | .sort .. => return true\n    | _        => return false", "start": [360, 1], "end": [372, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withLocalDecl'", "code": "@[inline] private def withLocalDecl' {\u03b1} (name : Name) (bi : BinderInfo) (type : Expr) (x : Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  let fvarId \u2190 mkFreshFVarId\n  withReader (fun ctx => { ctx with lctx := ctx.lctx.mkLocalDecl fvarId name type bi }) do\n    x (mkFVar fvarId)", "start": [375, 1], "end": [378, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isTypeFormerTypeQuick", "code": "def isTypeFormerTypeQuick : Expr \u2192 Bool\n  | .forallE _ _ b _ => isTypeFormerTypeQuick b\n  | .sort _ => true\n  | _ => false", "start": [380, 1], "end": [383, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isTypeFormerType", "code": "partial def isTypeFormerType (type : Expr) : MetaM Bool := do\n  match isTypeFormerTypeQuick type with\n  | true => return true\n  | false => savingCache <| go type #[]\nwhere\n  go (type : Expr) (xs : Array Expr) : MetaM Bool := do\n    match type with\n    | .sort .. => return true\n    | .forallE n d b c => withLocalDecl' n c (d.instantiateRev xs) fun x => go b (xs.push x)\n    | _ =>\n      let type \u2190 whnfD (type.instantiateRev xs)\n      match type with\n      | .sort .. => return true\n      | .forallE .. => go type #[]\n      | _ => return false", "start": [385, 1], "end": [402, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isTypeFormer", "code": "def isTypeFormer (e : Expr) : MetaM Bool := do\n  isTypeFormerType (\u2190 inferType e)", "start": [404, 1], "end": [409, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/ExternAttr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/ProjFns.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean"], "premises": [{"full_name": "Lean.ExternEntry", "code": "inductive ExternEntry where\n  | adhoc    (backend : Name)\n  | inline   (backend : Name) (pattern : String)\n  | standard (backend : Name) (fn : String)\n  | foreign  (backend : Name) (fn : String)", "start": [14, 1], "end": [18, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.ExternAttrData", "code": "structure ExternAttrData where\n  arity?   : Option Nat := none\n  entries  : List ExternEntry\n  deriving Inhabited", "start": [20, 1], "end": [37, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.syntaxToExternAttrData", "code": "private def syntaxToExternAttrData (stx : Syntax) : AttrM ExternAttrData := do\n  let arity?  := if stx[1].isNone then none else some <| stx[1][0].isNatLit?.getD 0\n  let entriesStx := stx[2].getArgs\n  if entriesStx.size == 0 && arity? == none then\n    return { entries := [ ExternEntry.adhoc `all ] }\n  let mut entries := #[]\n  for entryStx in entriesStx do\n    let backend := if entryStx[0].isNone then `all else entryStx[0][0].getId\n    let str \u2190 match entryStx[2].isStrLit? with\n      | none     => throwErrorAt entryStx[2] \"string literal expected\"\n      | some str => pure str\n    if entryStx[1].isNone then\n      entries := entries.push <| ExternEntry.standard backend str\n    else\n      entries := entries.push <| ExternEntry.inline backend str\n  return { arity? := arity?, entries := entries.toList }", "start": [41, 1], "end": [56, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.addExtern", "code": "@[extern \"lean_add_extern\"]\nopaque addExtern (env : Environment) (n : Name) : ExceptT String Id Environment", "start": [58, 1], "end": [59, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.getExternAttrData?", "code": "@[export lean_get_extern_attr_data]\ndef getExternAttrData? (env : Environment) (n : Name) : Option ExternAttrData :=\n  externAttr.getParam? env n", "start": [75, 1], "end": [77, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.parseOptNum", "code": "private def parseOptNum : Nat \u2192 String.Iterator \u2192 Nat \u2192 String.Iterator \u00d7 Nat\n  | 0,   it, r => (it, r)\n  | n+1, it, r =>\n    if !it.hasNext then (it, r)\n    else\n      let c := it.curr\n      if '0' <= c && c <= '9'\n      then parseOptNum n it.next (r*10 + (c.toNat - '0'.toNat))\n      else (it, r)", "start": [79, 1], "end": [87, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.expandExternPatternAux", "code": "def expandExternPatternAux (args : List String) : Nat \u2192 String.Iterator \u2192 String \u2192 String\n  | 0,   _,  r => r\n  | i+1, it, r =>\n    if \u00ac it.hasNext then r\n    else let c := it.curr\n      if c \u2260 '#' then expandExternPatternAux args i it.next (r.push c)\n      else\n        let it      := it.next\n        let (it, j) := parseOptNum it.remainingBytes it 0\n        let j       := j-1\n        expandExternPatternAux args i it (r ++ args.getD j \"\")", "start": [89, 1], "end": [99, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.expandExternPattern", "code": "def expandExternPattern (pattern : String) (args : List String) : String :=\n  expandExternPatternAux args pattern.length pattern.mkIterator \"\"", "start": [101, 1], "end": [102, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.mkSimpleFnCall", "code": "def mkSimpleFnCall (fn : String) (args : List String) : String :=\n  fn ++ \"(\" ++ ((args.intersperse \", \").foldl (\u00b7++\u00b7) \"\") ++ \")\"", "start": [104, 1], "end": [105, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.ExternEntry.backend", "code": "def ExternEntry.backend : ExternEntry \u2192 Name\n  | ExternEntry.adhoc n      => n\n  | ExternEntry.inline n _   => n\n  | ExternEntry.standard n _ => n\n  | ExternEntry.foreign n _  => n", "start": [107, 1], "end": [111, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.getExternEntryForAux", "code": "def getExternEntryForAux (backend : Name) : List ExternEntry \u2192 Option ExternEntry\n  | []    => none\n  | e::es =>\n    if e.backend == `all then some e\n    else if e.backend == backend then some e\n    else getExternEntryForAux backend es", "start": [113, 1], "end": [118, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.getExternEntryFor", "code": "def getExternEntryFor (d : ExternAttrData) (backend : Name) : Option ExternEntry :=\n  getExternEntryForAux backend d.entries", "start": [120, 1], "end": [121, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.isExtern", "code": "def isExtern (env : Environment) (fn : Name) : Bool :=\n  getExternAttrData? env fn |>.isSome", "start": [123, 1], "end": [124, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.isExternC", "code": "def isExternC (env : Environment) (fn : Name) : Bool :=\n  match getExternAttrData? env fn with\n  | some { entries := [ ExternEntry.standard `all _ ], .. } => true\n  | _ => false", "start": [126, 1], "end": [131, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.getExternNameFor", "code": "def getExternNameFor (env : Environment) (backend : Name) (fn : Name) : Option String := do\n  let data? \u2190 getExternAttrData? env fn\n  let entry \u2190 getExternEntryFor data? backend\n  match entry with\n  | ExternEntry.standard _ n => pure n\n  | ExternEntry.foreign _ n  => pure n\n  | _ => failure", "start": [133, 1], "end": [139, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.getExternConstArity", "code": "private def getExternConstArity (declName : Name) : CoreM Nat := do\n  let fromSignature : Unit \u2192 CoreM Nat := fun _ => do\n    let cinfo \u2190 getConstInfo declName\n    let (arity, _) \u2190 (Meta.forallTelescopeReducing cinfo.type fun xs _ => pure xs.size : MetaM Nat).run\n    return arity\n  let env \u2190 getEnv\n  match getExternAttrData? env declName with\n  | none      => fromSignature ()\n  | some data => match data.arity? with\n    | some arity => return arity\n    | none       => fromSignature ()", "start": [141, 1], "end": [151, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.getExternConstArityExport", "code": "@[export lean_get_extern_const_arity]\ndef getExternConstArityExport (env : Environment) (declName : Name) : IO (Option Nat) := do\n  try\n    let (arity, _) \u2190 (getExternConstArity declName).toIO { fileName := \"<compiler>\", fileMap := default } { env := env }\n    return some arity\n  catch\n   | IO.Error.userError _   => return none\n   | _  => return none", "start": [153, 1], "end": [160, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/PPGoal.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.addLine", "code": "private def addLine (fmt : Format) : Format :=\n  if fmt.isNil then fmt else fmt ++ Format.line", "start": [34, 1], "end": [35, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getGoalPrefix", "code": "def getGoalPrefix (mvarDecl : MetavarDecl) : String :=\n  if isLHSGoal? mvarDecl.type |>.isSome then\n    \"| \"\n  else\n    \"\u22a2 \"", "start": [37, 1], "end": [42, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ppGoal", "code": "def ppGoal (mvarId : MVarId) : MetaM Format := do\n  match (\u2190 getMCtx).findDecl? mvarId with\n  | none          => return \"unknown goal\"\n  | some mvarDecl =>\n    let indent         := 2 let showLetValues  := pp.showLetValues.get (\u2190 getOptions)\n    let ppAuxDecls     := pp.auxDecls.get (\u2190 getOptions)\n    let ppImplDetailHyps := pp.implementationDetailHyps.get (\u2190 getOptions)\n    let lctx           := mvarDecl.lctx\n    let lctx           := lctx.sanitizeNames.run' { options := (\u2190 getOptions) }\n    withLCtx lctx mvarDecl.localInstances do\n      let rec pushPending (ids : List Name) (type? : Option Expr) (fmt : Format) : MetaM Format := do\n        if ids.isEmpty then\n          return fmt\n        else\n          let fmt := addLine fmt\n          match type? with\n          | none      => return fmt\n          | some type =>\n            let typeFmt \u2190 ppExpr type\n            return fmt ++ (Format.joinSep ids.reverse (format \" \") ++ \" :\" ++ Format.nest indent (Format.line ++ typeFmt)).group\n      let rec ppVars (varNames : List Name) (prevType? : Option Expr) (fmt : Format) (localDecl : LocalDecl) : MetaM (List Name \u00d7 Option Expr \u00d7 Format) := do\n        match localDecl with\n        | .cdecl _ _ varName type _ _ =>\n          let varName := varName.simpMacroScopes\n          let type \u2190 instantiateMVars type\n          if prevType? == none || prevType? == some type then\n            return (varName :: varNames, some type, fmt)\n          else do\n            let fmt \u2190 pushPending varNames prevType? fmt\n            return ([varName], some type, fmt)\n        | .ldecl _ _ varName type val _ _ => do\n          let varName := varName.simpMacroScopes\n          let fmt \u2190 pushPending varNames prevType? fmt\n          let fmt  := addLine fmt\n          let type \u2190 instantiateMVars type\n          let typeFmt \u2190 ppExpr type\n          let mut fmtElem  := format varName ++ \" : \" ++ typeFmt\n          if showLetValues then\n            let val \u2190 instantiateMVars val\n            let valFmt \u2190 ppExpr val\n            fmtElem := fmtElem ++ \" :=\" ++ Format.nest indent (Format.line ++ valFmt)\n          let fmt := fmt ++ fmtElem.group\n          return ([], none, fmt)\n      let (varNames, type?, fmt) \u2190 lctx.foldlM (init := ([], none, Format.nil)) fun (varNames, prevType?, fmt) (localDecl : LocalDecl) =>\n         if !ppAuxDecls && localDecl.isAuxDecl || !ppImplDetailHyps && localDecl.isImplementationDetail then\n           return (varNames, prevType?, fmt)\n         else\n           ppVars varNames prevType? fmt localDecl\n      let fmt \u2190 pushPending varNames type? fmt\n      let fmt := addLine fmt\n      let typeFmt \u2190 ppExpr (\u2190 instantiateMVars mvarDecl.type)\n      let fmt := fmt ++ getGoalPrefix mvarDecl ++ Format.nest indent typeFmt\n      match mvarDecl.userName with\n      | Name.anonymous => return fmt\n      | name           => return \"case \" ++ format name.eraseMacroScopes ++ Format.line ++ fmt", "start": [44, 1], "end": [101, 95], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/PrefixTree.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PrefixTreeNode", "code": "inductive PrefixTreeNode (\u03b1 : Type u) (\u03b2 : Type v) where\n  | Node : Option \u03b2 \u2192 RBNode \u03b1 (fun _ => PrefixTreeNode \u03b1 \u03b2) \u2192 PrefixTreeNode \u03b1 \u03b2", "start": [11, 1], "end": [12, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTreeNode.empty", "code": "def empty : PrefixTreeNode \u03b1 \u03b2 :=\n  PrefixTreeNode.Node none RBNode.leaf", "start": [19, 1], "end": [20, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTreeNode.insert", "code": "@[specialize]\npartial def insert (t : PrefixTreeNode \u03b1 \u03b2) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (k : List \u03b1) (val : \u03b2) : PrefixTreeNode \u03b1 \u03b2 :=\n  let rec insertEmpty (k : List \u03b1) : PrefixTreeNode \u03b1 \u03b2 :=\n    match k with\n    | [] => PrefixTreeNode.Node (some val) RBNode.leaf\n    | k :: ks =>\n      let t := insertEmpty ks\n      PrefixTreeNode.Node none (RBNode.singleton k t)\n  let rec loop\n    | PrefixTreeNode.Node _ m, [] =>\n      PrefixTreeNode.Node (some val) m | PrefixTreeNode.Node v m, k :: ks =>\n      let t := match RBNode.find cmp m k with\n        | none   => insertEmpty ks\n        | some t => loop t ks\n      PrefixTreeNode.Node v (RBNode.insert cmp m k t)\n  loop t k", "start": [22, 1], "end": [38, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTreeNode.find?", "code": "@[specialize]\npartial def find? (t : PrefixTreeNode \u03b1 \u03b2) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (k : List \u03b1) : Option \u03b2 :=\n  let rec loop\n    | PrefixTreeNode.Node val _, [] => val\n    | PrefixTreeNode.Node _   m, k :: ks =>\n      match RBNode.find cmp m k with\n      | none   => none\n      | some t => loop t ks\n  loop t k", "start": [40, 1], "end": [48, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTreeNode.foldMatchingM", "code": "@[specialize]\npartial def foldMatchingM [Monad m] (t : PrefixTreeNode \u03b1 \u03b2) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) (k : List \u03b1) (init : \u03c3) (f : \u03b2 \u2192 \u03c3 \u2192 m \u03c3) : m \u03c3 :=\n  let rec fold : PrefixTreeNode \u03b1 \u03b2 \u2192 \u03c3 \u2192 m \u03c3\n    | PrefixTreeNode.Node b? n, d => do\n      let d \u2190 match b? with\n        | none   => pure d\n        | some b => f b d\n      n.foldM (init := d) fun d _ t => fold t d\n  let rec find : List \u03b1 \u2192 PrefixTreeNode \u03b1 \u03b2 \u2192 \u03c3 \u2192 m \u03c3\n    | [],    t, d => fold t d\n    | k::ks, PrefixTreeNode.Node _ m, d =>\n      match RBNode.find cmp m k with\n      | none   => pure init\n      | some t => find ks t d\n  find k t init", "start": [50, 1], "end": [64, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTreeNode.WellFormed", "code": "inductive WellFormed (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : PrefixTreeNode \u03b1 \u03b2 \u2192 Prop where\n  | emptyWff  : WellFormed cmp empty\n  | insertWff : WellFormed cmp t \u2192 WellFormed cmp (insert t cmp k val)", "start": [66, 1], "end": [68, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTree", "code": "def PrefixTree (\u03b1 : Type u) (\u03b2 : Type v) (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering) : Type (max u v) :=\n  { t : PrefixTreeNode \u03b1 \u03b2 // t.WellFormed cmp }", "start": [72, 1], "end": [73, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTree.empty", "code": "def PrefixTree.empty : PrefixTree \u03b1 \u03b2 p :=\n  \u27e8PrefixTreeNode.empty, WellFormed.emptyWff\u27e9", "start": [77, 1], "end": [78, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTree.insert", "code": "@[inline]\ndef PrefixTree.insert (t : PrefixTree \u03b1 \u03b2 p) (k : List \u03b1) (v : \u03b2) : PrefixTree \u03b1 \u03b2 p :=\n  \u27e8t.val.insert p k v, WellFormed.insertWff t.property\u27e9", "start": [86, 1], "end": [88, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTree.find?", "code": "@[inline]\ndef PrefixTree.find? (t : PrefixTree \u03b1 \u03b2 p) (k : List \u03b1) : Option \u03b2 :=\n  t.val.find? p k", "start": [90, 1], "end": [92, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTree.foldMatchingM", "code": "@[inline]\ndef PrefixTree.foldMatchingM [Monad m] (t : PrefixTree \u03b1 \u03b2 p) (k : List \u03b1) (init : \u03c3) (f : \u03b2 \u2192 \u03c3 \u2192 m \u03c3) : m \u03c3 :=\n  t.val.foldMatchingM p k init f", "start": [94, 1], "end": [96, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTree.foldM", "code": "@[inline]\ndef PrefixTree.foldM [Monad m] (t : PrefixTree \u03b1 \u03b2 p) (init : \u03c3) (f : \u03b2 \u2192 \u03c3 \u2192 m \u03c3) : m \u03c3 :=\n  t.foldMatchingM [] init f", "start": [98, 1], "end": [100, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTree.forMatchingM", "code": "@[inline]\ndef PrefixTree.forMatchingM [Monad m] (t : PrefixTree \u03b1 \u03b2 p) (k : List \u03b1) (f : \u03b2 \u2192 m Unit) : m Unit :=\n  t.val.foldMatchingM p k () (fun b _ => f b)", "start": [102, 1], "end": [104, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PrefixTree.forM", "code": "@[inline]\ndef PrefixTree.forM [Monad m] (t : PrefixTree \u03b1 \u03b2 p) (f : \u03b2 \u2192 m Unit) : m Unit :=\n  t.forMatchingM [] f", "start": [106, 1], "end": [108, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/ExternAttr.lean", "lake-packages/lean4/src/lean/Lean/Data/KVMap.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Format.lean", "lake-packages/lean4/src/lean/Lean/Data/Name.lean"], "premises": [{"full_name": "Lean.IR.FunId", "code": "abbrev FunId := Name", "start": [20, 1], "end": [21, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Index", "code": "abbrev Index := Nat", "start": [22, 1], "end": [22, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.VarId", "code": "structure VarId where\n  idx : Index\n  deriving Inhabited", "start": [23, 1], "end": [26, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.JoinPointId", "code": "structure JoinPointId where\n  idx : Index\n  deriving Inhabited", "start": [28, 1], "end": [31, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Index.lt", "code": "abbrev Index.lt (a b : Index) : Bool := a < b", "start": [33, 1], "end": [33, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MData", "code": "abbrev MData := KVMap", "start": [45, 1], "end": [45, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.MData.empty", "code": "abbrev MData.empty : MData := {}", "start": [46, 1], "end": [46, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IRType", "code": "inductive IRType where\n  | float | uint8 | uint16 | uint32 | uint64 | usize\n  | irrelevant | object | tobject\n  | struct (leanTypeName : Option Name) (types : Array IRType) : IRType\n  | union (leanTypeName : Name) (types : Array IRType) : IRType\n  deriving Inhabited", "start": [48, 1], "end": [85, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IRType.beq", "code": "partial def beq : IRType \u2192 IRType \u2192 Bool\n  | float,          float          => true\n  | uint8,          uint8          => true\n  | uint16,         uint16         => true\n  | uint32,         uint32         => true\n  | uint64,         uint64         => true\n  | usize,          usize          => true\n  | irrelevant,     irrelevant     => true\n  | object,         object         => true\n  | tobject,        tobject        => true\n  | struct n\u2081 tys\u2081, struct n\u2082 tys\u2082 => n\u2081 == n\u2082 && Array.isEqv tys\u2081 tys\u2082 beq\n  | union n\u2081 tys\u2081,  union n\u2082 tys\u2082  => n\u2081 == n\u2082 && Array.isEqv tys\u2081 tys\u2082 beq\n  | _,              _              => false", "start": [89, 1], "end": [101, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IRType.isScalar", "code": "def isScalar : IRType \u2192 Bool\n  | float  => true\n  | uint8  => true\n  | uint16 => true\n  | uint32 => true\n  | uint64 => true\n  | usize  => true\n  | _      => false", "start": [105, 1], "end": [112, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IRType.isObj", "code": "def isObj : IRType \u2192 Bool\n  | object  => true\n  | tobject => true\n  | _       => false", "start": [114, 1], "end": [117, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IRType.isIrrelevant", "code": "def isIrrelevant : IRType \u2192 Bool\n  | irrelevant => true\n  | _ => false", "start": [119, 1], "end": [121, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IRType.isStruct", "code": "def isStruct : IRType \u2192 Bool\n  | struct _ _ => true\n  | _ => false", "start": [123, 1], "end": [125, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IRType.isUnion", "code": "def isUnion : IRType \u2192 Bool\n  | union _ _ => true\n  | _ => false", "start": [127, 1], "end": [129, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Arg", "code": "inductive Arg where\n  | var (id : VarId)\n  | irrelevant\n  deriving Inhabited", "start": [133, 1], "end": [140, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Arg.beq", "code": "protected def Arg.beq : Arg \u2192 Arg \u2192 Bool\n  | var x,      var y      => x == y\n  | irrelevant, irrelevant => true\n  | _,          _          => false", "start": [142, 1], "end": [145, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkVarArg", "code": "@[export lean_ir_mk_var_arg] def mkVarArg (id : VarId) : Arg := Arg.var id", "start": [149, 1], "end": [149, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LitVal", "code": "inductive LitVal where\n  | num (v : Nat)\n  | str (v : String)", "start": [151, 1], "end": [153, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LitVal.beq", "code": "def LitVal.beq : LitVal \u2192 LitVal \u2192 Bool\n  | num v\u2081, num v\u2082 => v\u2081 == v\u2082\n  | str v\u2081, str v\u2082 => v\u2081 == v\u2082\n  | _,      _      => false", "start": [155, 1], "end": [158, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CtorInfo", "code": "structure CtorInfo where\n  name : Name\n  cidx : Nat\n  size : Nat\n  usize : Nat\n  ssize : Nat\n  deriving Repr", "start": [162, 1], "end": [179, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CtorInfo.beq", "code": "def CtorInfo.beq : CtorInfo \u2192 CtorInfo \u2192 Bool\n  | \u27e8n\u2081, cidx\u2081, size\u2081, usize\u2081, ssize\u2081\u27e9, \u27e8n\u2082, cidx\u2082, size\u2082, usize\u2082, ssize\u2082\u27e9 =>\n    n\u2081 == n\u2082 && cidx\u2081 == cidx\u2082 && size\u2081 == size\u2082 && usize\u2081 == usize\u2082 && ssize\u2081 == ssize\u2082", "start": [181, 1], "end": [183, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CtorInfo.isRef", "code": "def CtorInfo.isRef (info : CtorInfo) : Bool :=\n  info.size > 0 || info.usize > 0 || info.ssize > 0", "start": [187, 1], "end": [188, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CtorInfo.isScalar", "code": "def CtorInfo.isScalar (info : CtorInfo) : Bool :=\n  !info.isRef", "start": [190, 1], "end": [191, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Expr", "code": "inductive Expr where\n  \n  | ctor (i : CtorInfo) (ys : Array Arg)\n  | reset (n : Nat) (x : VarId)\n  \n  | reuse (x : VarId) (i : CtorInfo) (updtHeader : Bool) (ys : Array Arg)\n  \n  |  proj (i : Nat) (x : VarId)\n  \n  | uproj (i : Nat) (x : VarId)\n  \n  | sproj (n : Nat) (offset : Nat) (x : VarId)\n  \n  | fap (c : FunId) (ys : Array Arg)\n  \n  | pap (c : FunId) (ys : Array Arg)\n  \n  | ap  (x : VarId) (ys : Array Arg)\n  \n  | box (ty : IRType) (x : VarId)\n  \n  | unbox (x : VarId)\n  | lit (v : LitVal)\n  \n  | isShared (x : VarId)", "start": [193, 1], "end": [221, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkCtorExpr", "code": "@[export lean_ir_mk_ctor_expr]  def mkCtorExpr (n : Name) (cidx : Nat) (size : Nat) (usize : Nat) (ssize : Nat) (ys : Array Arg) : Expr :=\n  Expr.ctor \u27e8n, cidx, size, usize, ssize\u27e9 ys", "start": [223, 1], "end": [224, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkProjExpr", "code": "@[export lean_ir_mk_proj_expr]  def mkProjExpr (i : Nat) (x : VarId) : Expr := Expr.proj i x", "start": [225, 1], "end": [225, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkUProjExpr", "code": "@[export lean_ir_mk_uproj_expr] def mkUProjExpr (i : Nat) (x : VarId) : Expr := Expr.uproj i x", "start": [226, 1], "end": [226, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkSProjExpr", "code": "@[export lean_ir_mk_sproj_expr] def mkSProjExpr (n : Nat) (offset : Nat) (x : VarId) : Expr := Expr.sproj n offset x", "start": [227, 1], "end": [227, 117], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkFAppExpr", "code": "@[export lean_ir_mk_fapp_expr]  def mkFAppExpr (c : FunId) (ys : Array Arg) : Expr := Expr.fap c ys", "start": [228, 1], "end": [228, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkPAppExpr", "code": "@[export lean_ir_mk_papp_expr]  def mkPAppExpr (c : FunId) (ys : Array Arg) : Expr := Expr.pap c ys", "start": [229, 1], "end": [229, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkAppExpr", "code": "@[export lean_ir_mk_app_expr]   def mkAppExpr (x : VarId) (ys : Array Arg) : Expr := Expr.ap x ys", "start": [230, 1], "end": [230, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkNumExpr", "code": "@[export lean_ir_mk_num_expr]   def mkNumExpr (v : Nat) : Expr := Expr.lit (LitVal.num v)", "start": [231, 1], "end": [231, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkStrExpr", "code": "@[export lean_ir_mk_str_expr]   def mkStrExpr (v : String) : Expr := Expr.lit (LitVal.str v)", "start": [232, 1], "end": [232, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Param", "code": "structure Param where\n  x : VarId\n  borrow : Bool\n  ty : IRType\n  deriving Inhabited", "start": [234, 1], "end": [238, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkParam", "code": "@[export lean_ir_mk_param]\ndef mkParam (x : VarId) (borrow : Bool) (ty : IRType) : Param := \u27e8x, borrow, ty\u27e9", "start": [240, 1], "end": [241, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.AltCore", "code": "inductive AltCore (FnBody : Type) : Type where\n  | ctor (info : CtorInfo) (b : FnBody) : AltCore FnBody\n  | default (b : FnBody) : AltCore FnBody", "start": [243, 1], "end": [245, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody", "code": "inductive FnBody where\n  \n  | vdecl (x : VarId) (ty : IRType) (e : Expr) (b : FnBody)\n  \n  | jdecl (j : JoinPointId) (xs : Array Param) (v : FnBody) (b : FnBody)\n  \n  | set (x : VarId) (i : Nat) (y : Arg) (b : FnBody)\n  | setTag (x : VarId) (cidx : Nat) (b : FnBody)\n  \n  | uset (x : VarId) (i : Nat) (y : VarId) (b : FnBody)\n  \n  | sset (x : VarId) (i : Nat) (offset : Nat) (y : VarId) (ty : IRType) (b : FnBody)\n  \n  | inc (x : VarId) (n : Nat) (c : Bool) (persistent : Bool) (b : FnBody)\n  \n  | dec (x : VarId) (n : Nat) (c : Bool) (persistent : Bool) (b : FnBody)\n  | del (x : VarId) (b : FnBody)\n  | mdata (d : MData) (b : FnBody)\n  | case (tid : Name) (x : VarId) (xType : IRType) (cs : Array (AltCore FnBody))\n  | ret (x : Arg)\n  \n  | jmp (j : JoinPointId) (ys : Array Arg)\n  | unreachable", "start": [247, 1], "end": [273, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.nil", "code": "abbrev FnBody.nil := FnBody.unreachable", "start": [277, 1], "end": [277, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkVDecl", "code": "@[export lean_ir_mk_vdecl] def mkVDecl (x : VarId) (ty : IRType) (e : Expr) (b : FnBody) : FnBody := FnBody.vdecl x ty e b", "start": [279, 1], "end": [279, 123], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkJDecl", "code": "@[export lean_ir_mk_jdecl] def mkJDecl (j : JoinPointId) (xs : Array Param) (v : FnBody) (b : FnBody) : FnBody := FnBody.jdecl j xs v b", "start": [280, 1], "end": [280, 136], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkUSet", "code": "@[export lean_ir_mk_uset] def mkUSet (x : VarId) (i : Nat) (y : VarId) (b : FnBody) : FnBody := FnBody.uset x i y b", "start": [281, 1], "end": [281, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkSSet", "code": "@[export lean_ir_mk_sset] def mkSSet (x : VarId) (i : Nat) (offset : Nat) (y : VarId) (ty : IRType) (b : FnBody) : FnBody := FnBody.sset x i offset y ty b", "start": [282, 1], "end": [282, 155], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkCase", "code": "@[export lean_ir_mk_case] def mkCase (tid : Name) (x : VarId) (cs : Array (AltCore FnBody)) : FnBody :=\n  FnBody.case tid x IRType.object cs", "start": [283, 1], "end": [285, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkRet", "code": "@[export lean_ir_mk_ret] def mkRet (x : Arg) : FnBody := FnBody.ret x", "start": [286, 1], "end": [286, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkJmp", "code": "@[export lean_ir_mk_jmp] def mkJmp (j : JoinPointId) (ys : Array Arg) : FnBody := FnBody.jmp j ys", "start": [287, 1], "end": [287, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkUnreachable", "code": "@[export lean_ir_mk_unreachable] def mkUnreachable : Unit \u2192 FnBody := fun _ => FnBody.unreachable", "start": [288, 1], "end": [288, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Alt", "code": "abbrev Alt := AltCore FnBody", "start": [290, 1], "end": [290, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Alt.ctor", "code": "@[match_pattern] abbrev Alt.ctor    := @AltCore.ctor FnBody", "start": [291, 1], "end": [291, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Alt.default", "code": "@[match_pattern] abbrev Alt.default := @AltCore.default FnBody", "start": [292, 1], "end": [292, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.isTerminal", "code": "def FnBody.isTerminal : FnBody \u2192 Bool\n  | FnBody.case _ _ _ _  => true\n  | FnBody.ret _         => true\n  | FnBody.jmp _ _       => true\n  | FnBody.unreachable   => true\n  | _                    => false", "start": [296, 1], "end": [301, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.body", "code": "def FnBody.body : FnBody \u2192 FnBody\n  | FnBody.vdecl _ _ _ b    => b\n  | FnBody.jdecl _ _ _ b    => b\n  | FnBody.set _ _ _ b      => b\n  | FnBody.uset _ _ _ b     => b\n  | FnBody.sset _ _ _ _ _ b => b\n  | FnBody.setTag _ _ b     => b\n  | FnBody.inc _ _ _ _ b    => b\n  | FnBody.dec _ _ _ _ b    => b\n  | FnBody.del _ b          => b\n  | FnBody.mdata _ b        => b\n  | other                   => other", "start": [303, 1], "end": [314, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.setBody", "code": "def FnBody.setBody : FnBody \u2192 FnBody \u2192 FnBody\n  | FnBody.vdecl x t v _,    b => FnBody.vdecl x t v b\n  | FnBody.jdecl j xs v _,   b => FnBody.jdecl j xs v b\n  | FnBody.set x i y _,      b => FnBody.set x i y b\n  | FnBody.uset x i y _,     b => FnBody.uset x i y b\n  | FnBody.sset x i o y t _, b => FnBody.sset x i o y t b\n  | FnBody.setTag x i _,     b => FnBody.setTag x i b\n  | FnBody.inc x n c p _,    b => FnBody.inc x n c p b\n  | FnBody.dec x n c p _,    b => FnBody.dec x n c p b\n  | FnBody.del x _,          b => FnBody.del x b\n  | FnBody.mdata d _,        b => FnBody.mdata d b\n  | other,                   _ => other", "start": [316, 1], "end": [327, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.resetBody", "code": "@[inline] def FnBody.resetBody (b : FnBody) : FnBody :=\n  b.setBody FnBody.nil", "start": [329, 1], "end": [330, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.split", "code": "@[inline] def FnBody.split (b : FnBody) : FnBody \u00d7 FnBody :=\n  let b' := b.body\n  let c  := b.resetBody\n  (c, b')", "start": [332, 1], "end": [337, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.AltCore.body", "code": "def AltCore.body : Alt \u2192 FnBody\n  | Alt.ctor _ b  => b\n  | Alt.default b => b", "start": [339, 1], "end": [341, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.AltCore.setBody", "code": "def AltCore.setBody : Alt \u2192 FnBody \u2192 Alt\n  | Alt.ctor c _, b  => Alt.ctor c b\n  | Alt.default _, b => Alt.default b", "start": [343, 1], "end": [345, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.AltCore.modifyBody", "code": "@[inline] def AltCore.modifyBody (f : FnBody \u2192 FnBody) : AltCore FnBody \u2192 Alt\n  | Alt.ctor c b  => Alt.ctor c (f b)\n  | Alt.default b => Alt.default (f b)", "start": [347, 1], "end": [349, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.AltCore.mmodifyBody", "code": "@[inline] def AltCore.mmodifyBody {m : Type \u2192 Type} [Monad m] (f : FnBody \u2192 m FnBody) : AltCore FnBody \u2192 m Alt\n  | Alt.ctor c b  => Alt.ctor c <$> f b\n  | Alt.default b => Alt.default <$> f b", "start": [351, 1], "end": [353, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Alt.isDefault", "code": "def Alt.isDefault : Alt \u2192 Bool\n  | Alt.ctor _ _  => false\n  | Alt.default _ => true", "start": [355, 1], "end": [357, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.push", "code": "def push (bs : Array FnBody) (b : FnBody) : Array FnBody :=\n  let b := b.resetBody\n  bs.push b", "start": [359, 1], "end": [361, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.flattenAux", "code": "partial def flattenAux (b : FnBody) (r : Array FnBody) : (Array FnBody) \u00d7 FnBody :=\n  if b.isTerminal then (r, b)\n  else flattenAux b.body (push r b)", "start": [363, 1], "end": [365, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.flatten", "code": "def FnBody.flatten (b : FnBody) : (Array FnBody) \u00d7 FnBody :=\n  flattenAux b #[]", "start": [367, 1], "end": [368, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.reshapeAux", "code": "partial def reshapeAux (a : Array FnBody) (i : Nat) (b : FnBody) : FnBody :=\n  if i == 0 then b\n  else\n    let i         := i - 1\n    let (curr, a) := a.swapAt! i default\n    let b         := curr.setBody b\n    reshapeAux a i b", "start": [370, 1], "end": [376, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.reshape", "code": "def reshape (bs : Array FnBody) (term : FnBody) : FnBody :=\n  reshapeAux bs bs.size term", "start": [378, 1], "end": [379, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.modifyJPs", "code": "@[inline] def modifyJPs (bs : Array FnBody) (f : FnBody \u2192 FnBody) : Array FnBody :=\n  bs.map fun b => match b with\n    | FnBody.jdecl j xs v k => FnBody.jdecl j xs (f v) k\n    | other                 => other", "start": [381, 1], "end": [384, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mmodifyJPs", "code": "@[inline] def mmodifyJPs {m : Type \u2192 Type} [Monad m] (bs : Array FnBody) (f : FnBody \u2192 m FnBody) : m (Array FnBody) :=\n  bs.mapM fun b => match b with\n    | FnBody.jdecl j xs v k => return FnBody.jdecl j xs (\u2190 f v) k\n    | other                 => return other", "start": [386, 1], "end": [389, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkAlt", "code": "@[export lean_ir_mk_alt] def mkAlt (n : Name) (cidx : Nat) (size : Nat) (usize : Nat) (ssize : Nat) (b : FnBody) : Alt :=\n  Alt.ctor \u27e8n, cidx, size, usize, ssize\u27e9 b", "start": [391, 1], "end": [392, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.DeclInfo", "code": "structure DeclInfo where\n  \n  sorryDep? : Option Name := none", "start": [394, 1], "end": [397, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl", "code": "inductive Decl where\n  | fdecl  (f : FunId) (xs : Array Param) (type : IRType) (body : FnBody) (info : DeclInfo)\n  | extern (f : FunId) (xs : Array Param) (type : IRType) (ext : ExternAttrData)\n  deriving Inhabited", "start": [399, 1], "end": [402, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.name", "code": "def name : Decl \u2192 FunId\n  | .fdecl f ..  => f\n  | .extern f .. => f", "start": [406, 1], "end": [408, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.params", "code": "def params : Decl \u2192 Array Param\n  | .fdecl (xs := xs) ..  => xs\n  | .extern (xs := xs) .. => xs", "start": [410, 1], "end": [412, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.resultType", "code": "def resultType : Decl \u2192 IRType\n  | .fdecl (type := t) ..  => t\n  | .extern (type := t) .. => t", "start": [414, 1], "end": [416, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.isExtern", "code": "def isExtern : Decl \u2192 Bool\n  | .extern .. => true\n  | _ => false", "start": [418, 1], "end": [420, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.getInfo", "code": "def getInfo : Decl \u2192 DeclInfo\n  | .fdecl (info := info) .. => info\n  | _ => {}", "start": [422, 1], "end": [424, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Decl.updateBody!", "code": "def updateBody! (d : Decl) (bNew : FnBody) : Decl :=\n  match d with\n  | Decl.fdecl f xs t _ info => Decl.fdecl f xs t bNew info\n  | _ => panic! \"expected definition\"", "start": [426, 1], "end": [429, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkDecl", "code": "@[export lean_ir_mk_decl] def mkDecl (f : FunId) (xs : Array Param) (ty : IRType) (b : FnBody) : Decl :=\n  Decl.fdecl f xs ty b {}", "start": [433, 1], "end": [434, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkExternDecl", "code": "@[export lean_ir_mk_extern_decl] def mkExternDecl (f : FunId) (xs : Array Param) (ty : IRType) (e : ExternAttrData) : Decl :=\n  Decl.extern f xs ty e", "start": [436, 1], "end": [437, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkDummyExternDecl", "code": "@[export lean_ir_mk_dummy_extern_decl] def mkDummyExternDecl (f : FunId) (xs : Array Param) (ty : IRType) : Decl :=\n  Decl.fdecl f xs ty FnBody.unreachable {}", "start": [440, 1], "end": [441, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IndexSet", "code": "abbrev IndexSet := RBTree Index compare", "start": [443, 1], "end": [444, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkIndexSet", "code": "def mkIndexSet (idx : Index) : IndexSet :=\n  RBTree.empty.insert idx", "start": [447, 1], "end": [448, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContextEntry", "code": "inductive LocalContextEntry where\n  | param     : IRType \u2192 LocalContextEntry\n  | localVar  : IRType \u2192 Expr \u2192 LocalContextEntry\n  | joinPoint : Array Param \u2192 FnBody \u2192 LocalContextEntry", "start": [450, 1], "end": [453, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext", "code": "abbrev LocalContext := RBMap Index LocalContextEntry compare", "start": [455, 1], "end": [455, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.addLocal", "code": "def LocalContext.addLocal (ctx : LocalContext) (x : VarId) (t : IRType) (v : Expr) : LocalContext :=\n  ctx.insert x.idx (LocalContextEntry.localVar t v)", "start": [457, 1], "end": [458, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.addJP", "code": "def LocalContext.addJP (ctx : LocalContext) (j : JoinPointId) (xs : Array Param) (b : FnBody) : LocalContext :=\n  ctx.insert j.idx (LocalContextEntry.joinPoint xs b)", "start": [460, 1], "end": [461, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.addParam", "code": "def LocalContext.addParam (ctx : LocalContext) (p : Param) : LocalContext :=\n  ctx.insert p.x.idx (LocalContextEntry.param p.ty)", "start": [463, 1], "end": [464, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.addParams", "code": "def LocalContext.addParams (ctx : LocalContext) (ps : Array Param) : LocalContext :=\n  ps.foldl LocalContext.addParam ctx", "start": [466, 1], "end": [467, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.isJP", "code": "def LocalContext.isJP (ctx : LocalContext) (idx : Index) : Bool :=\n  match ctx.find? idx with\n  | some (LocalContextEntry.joinPoint _ _) => true\n  | _     => false", "start": [469, 1], "end": [472, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.getJPBody", "code": "def LocalContext.getJPBody (ctx : LocalContext) (j : JoinPointId) : Option FnBody :=\n  match ctx.find? j.idx with\n  | some (LocalContextEntry.joinPoint _ b) => some b\n  | _     => none", "start": [474, 1], "end": [477, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.getJPParams", "code": "def LocalContext.getJPParams (ctx : LocalContext) (j : JoinPointId) : Option (Array Param) :=\n  match ctx.find? j.idx with\n  | some (LocalContextEntry.joinPoint ys _) => some ys\n  | _     => none", "start": [479, 1], "end": [482, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.isParam", "code": "def LocalContext.isParam (ctx : LocalContext) (idx : Index) : Bool :=\n  match ctx.find? idx with\n  | some (LocalContextEntry.param _) => true\n  | _     => false", "start": [484, 1], "end": [487, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.isLocalVar", "code": "def LocalContext.isLocalVar (ctx : LocalContext) (idx : Index) : Bool :=\n  match ctx.find? idx with\n  | some (LocalContextEntry.localVar _ _) => true\n  | _     => false", "start": [489, 1], "end": [492, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.contains", "code": "def LocalContext.contains (ctx : LocalContext) (idx : Index) : Bool :=\n  RBMap.contains ctx idx", "start": [494, 1], "end": [495, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.eraseJoinPointDecl", "code": "def LocalContext.eraseJoinPointDecl (ctx : LocalContext) (j : JoinPointId) : LocalContext :=\n  ctx.erase j.idx", "start": [497, 1], "end": [498, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.getType", "code": "def LocalContext.getType (ctx : LocalContext) (x : VarId) : Option IRType :=\n  match ctx.find? x.idx with\n  | some (LocalContextEntry.param t) => some t\n  | some (LocalContextEntry.localVar t _) => some t\n  | _     => none", "start": [500, 1], "end": [504, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LocalContext.getValue", "code": "def LocalContext.getValue (ctx : LocalContext) (x : VarId) : Option Expr :=\n  match ctx.find? x.idx with\n  | some (LocalContextEntry.localVar _ v) => some v\n  | _     => none", "start": [506, 1], "end": [509, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.IndexRenaming", "code": "abbrev IndexRenaming := RBMap Index Index compare", "start": [511, 1], "end": [511, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.AlphaEqv", "code": "class AlphaEqv (\u03b1 : Type) where\n  aeqv : IndexRenaming \u2192 \u03b1 \u2192 \u03b1 \u2192 Bool", "start": [513, 1], "end": [514, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.VarId.alphaEqv", "code": "def VarId.alphaEqv (\u03c1 : IndexRenaming) (v\u2081 v\u2082 : VarId) : Bool :=\n  match \u03c1.find? v\u2081.idx with\n  | some v => v == v\u2082.idx\n  | none   => v\u2081 == v\u2082", "start": [518, 1], "end": [521, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Arg.alphaEqv", "code": "def Arg.alphaEqv (\u03c1 : IndexRenaming) : Arg \u2192 Arg \u2192 Bool\n  | Arg.var v\u2081,     Arg.var v\u2082     => aeqv \u03c1 v\u2081 v\u2082\n  | Arg.irrelevant, Arg.irrelevant => true\n  | _,              _              => false", "start": [525, 1], "end": [528, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.args.alphaEqv", "code": "def args.alphaEqv (\u03c1 : IndexRenaming) (args\u2081 args\u2082 : Array Arg) : Bool :=\n  Array.isEqv args\u2081 args\u2082 (fun a b => aeqv \u03c1 a b)", "start": [532, 1], "end": [533, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Expr.alphaEqv", "code": "def Expr.alphaEqv (\u03c1 : IndexRenaming) : Expr \u2192 Expr \u2192 Bool\n  | Expr.ctor i\u2081 ys\u2081,        Expr.ctor i\u2082 ys\u2082        => i\u2081 == i\u2082 && aeqv \u03c1 ys\u2081 ys\u2082\n  | Expr.reset n\u2081 x\u2081,        Expr.reset n\u2082 x\u2082        => n\u2081 == n\u2082 && aeqv \u03c1 x\u2081 x\u2082\n  | Expr.reuse x\u2081 i\u2081 u\u2081 ys\u2081, Expr.reuse x\u2082 i\u2082 u\u2082 ys\u2082 => aeqv \u03c1 x\u2081 x\u2082 && i\u2081 == i\u2082 && u\u2081 == u\u2082 && aeqv \u03c1 ys\u2081 ys\u2082\n  | Expr.proj i\u2081 x\u2081,         Expr.proj i\u2082 x\u2082         => i\u2081 == i\u2082 && aeqv \u03c1 x\u2081 x\u2082\n  | Expr.uproj i\u2081 x\u2081,        Expr.uproj i\u2082 x\u2082        => i\u2081 == i\u2082 && aeqv \u03c1 x\u2081 x\u2082\n  | Expr.sproj n\u2081 o\u2081 x\u2081,     Expr.sproj n\u2082 o\u2082 x\u2082     => n\u2081 == n\u2082 && o\u2081 == o\u2082 && aeqv \u03c1 x\u2081 x\u2082\n  | Expr.fap c\u2081 ys\u2081,         Expr.fap c\u2082 ys\u2082         => c\u2081 == c\u2082 && aeqv \u03c1 ys\u2081 ys\u2082\n  | Expr.pap c\u2081 ys\u2081,         Expr.pap c\u2082 ys\u2082         => c\u2081 == c\u2082 && aeqv \u03c1 ys\u2081 ys\u2082\n  | Expr.ap x\u2081 ys\u2081,          Expr.ap x\u2082 ys\u2082          => aeqv \u03c1 x\u2081 x\u2082 && aeqv \u03c1 ys\u2081 ys\u2082\n  | Expr.box ty\u2081 x\u2081,         Expr.box ty\u2082 x\u2082         => ty\u2081 == ty\u2082 && aeqv \u03c1 x\u2081 x\u2082\n  | Expr.unbox x\u2081,           Expr.unbox x\u2082           => aeqv \u03c1 x\u2081 x\u2082\n  | Expr.lit v\u2081,             Expr.lit v\u2082             => v\u2081 == v\u2082\n  | Expr.isShared x\u2081,        Expr.isShared x\u2082        => aeqv \u03c1 x\u2081 x\u2082\n  | _,                        _                      => false", "start": [537, 1], "end": [551, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.addVarRename", "code": "def addVarRename (\u03c1 : IndexRenaming) (x\u2081 x\u2082 : Nat) :=\n  if x\u2081 == x\u2082 then \u03c1 else \u03c1.insert x\u2081 x\u2082", "start": [555, 1], "end": [556, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.addParamRename", "code": "def addParamRename (\u03c1 : IndexRenaming) (p\u2081 p\u2082 : Param) : Option IndexRenaming :=\n  if p\u2081.ty == p\u2082.ty && p\u2081.borrow = p\u2082.borrow then\n    some (addVarRename \u03c1 p\u2081.x.idx p\u2082.x.idx)\n  else\n    none", "start": [558, 1], "end": [562, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.addParamsRename", "code": "def addParamsRename (\u03c1 : IndexRenaming) (ps\u2081 ps\u2082 : Array Param) : Option IndexRenaming := do\n  if ps\u2081.size != ps\u2082.size then\n    failure\n  else\n    let mut \u03c1 := \u03c1\n    for i in [:ps\u2081.size] do\n      \u03c1 \u2190 addParamRename \u03c1 ps\u2081[i]! ps\u2082[i]!\n    pure \u03c1", "start": [564, 1], "end": [571, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.alphaEqv", "code": "partial def FnBody.alphaEqv : IndexRenaming \u2192 FnBody \u2192 FnBody \u2192 Bool\n  | \u03c1, FnBody.vdecl x\u2081 t\u2081 v\u2081 b\u2081,      FnBody.vdecl x\u2082 t\u2082 v\u2082 b\u2082      => t\u2081 == t\u2082 && aeqv \u03c1 v\u2081 v\u2082 && alphaEqv (addVarRename \u03c1 x\u2081.idx x\u2082.idx) b\u2081 b\u2082\n  | \u03c1, FnBody.jdecl j\u2081 ys\u2081 v\u2081 b\u2081,  FnBody.jdecl j\u2082 ys\u2082 v\u2082 b\u2082        => match addParamsRename \u03c1 ys\u2081 ys\u2082 with\n    | some \u03c1' => alphaEqv \u03c1' v\u2081 v\u2082 && alphaEqv (addVarRename \u03c1 j\u2081.idx j\u2082.idx) b\u2081 b\u2082\n    | none    => false\n  | \u03c1, FnBody.set x\u2081 i\u2081 y\u2081 b\u2081,        FnBody.set x\u2082 i\u2082 y\u2082 b\u2082        => aeqv \u03c1 x\u2081 x\u2082 && i\u2081 == i\u2082 && aeqv \u03c1 y\u2081 y\u2082 && alphaEqv \u03c1 b\u2081 b\u2082\n  | \u03c1, FnBody.uset x\u2081 i\u2081 y\u2081 b\u2081,       FnBody.uset x\u2082 i\u2082 y\u2082 b\u2082       => aeqv \u03c1 x\u2081 x\u2082 && i\u2081 == i\u2082 && aeqv \u03c1 y\u2081 y\u2082 && alphaEqv \u03c1 b\u2081 b\u2082\n  | \u03c1, FnBody.sset x\u2081 i\u2081 o\u2081 y\u2081 t\u2081 b\u2081, FnBody.sset x\u2082 i\u2082 o\u2082 y\u2082 t\u2082 b\u2082 =>\n    aeqv \u03c1 x\u2081 x\u2082 && i\u2081 = i\u2082 && o\u2081 = o\u2082 && aeqv \u03c1 y\u2081 y\u2082 && t\u2081 == t\u2082 && alphaEqv \u03c1 b\u2081 b\u2082\n  | \u03c1, FnBody.setTag x\u2081 i\u2081 b\u2081,        FnBody.setTag x\u2082 i\u2082 b\u2082        => aeqv \u03c1 x\u2081 x\u2082 && i\u2081 == i\u2082 && alphaEqv \u03c1 b\u2081 b\u2082\n  | \u03c1, FnBody.inc x\u2081 n\u2081 c\u2081 p\u2081 b\u2081,     FnBody.inc x\u2082 n\u2082 c\u2082 p\u2082 b\u2082     => aeqv \u03c1 x\u2081 x\u2082 && n\u2081 == n\u2082 && c\u2081 == c\u2082 && p\u2081 == p\u2082 && alphaEqv \u03c1 b\u2081 b\u2082\n  | \u03c1, FnBody.dec x\u2081 n\u2081 c\u2081 p\u2081 b\u2081,     FnBody.dec x\u2082 n\u2082 c\u2082 p\u2082 b\u2082     => aeqv \u03c1 x\u2081 x\u2082 && n\u2081 == n\u2082 && c\u2081 == c\u2082 && p\u2081 == p\u2082 && alphaEqv \u03c1 b\u2081 b\u2082\n  | \u03c1, FnBody.del x\u2081 b\u2081,              FnBody.del x\u2082 b\u2082              => aeqv \u03c1 x\u2081 x\u2082 && alphaEqv \u03c1 b\u2081 b\u2082\n  | \u03c1, FnBody.mdata m\u2081 b\u2081,            FnBody.mdata m\u2082 b\u2082            => m\u2081 == m\u2082 && alphaEqv \u03c1 b\u2081 b\u2082\n  | \u03c1, FnBody.case n\u2081 x\u2081 _ alts\u2081,     FnBody.case n\u2082 x\u2082 _ alts\u2082     => n\u2081 == n\u2082 && aeqv \u03c1 x\u2081 x\u2082 && Array.isEqv alts\u2081 alts\u2082 (fun alt\u2081 alt\u2082 =>\n     match alt\u2081, alt\u2082 with\n     | Alt.ctor i\u2081 b\u2081, Alt.ctor i\u2082 b\u2082 => i\u2081 == i\u2082 && alphaEqv \u03c1 b\u2081 b\u2082\n     | Alt.default b\u2081, Alt.default b\u2082 => alphaEqv \u03c1 b\u2081 b\u2082\n     | _,              _              => false)\n  | \u03c1, FnBody.jmp j\u2081 ys\u2081,             FnBody.jmp j\u2082 ys\u2082             => j\u2081 == j\u2082 && aeqv \u03c1 ys\u2081 ys\u2082\n  | \u03c1, FnBody.ret x\u2081,                 FnBody.ret x\u2082                 => aeqv \u03c1 x\u2081 x\u2082\n  | _, FnBody.unreachable,            FnBody.unreachable            => true\n  | _, _,                             _                             => false", "start": [573, 1], "end": [595, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.FnBody.beq", "code": "def FnBody.beq (b\u2081 b\u2082 : FnBody) : Bool :=\n  FnBody.alphaEqv \u2205 b\u2081 b\u2082", "start": [597, 1], "end": [598, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.VarIdSet", "code": "abbrev VarIdSet := RBTree VarId (fun x y => compare x.idx y.idx)", "start": [602, 1], "end": [602, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.mkIf", "code": "def mkIf (x : VarId) (t e : FnBody) : FnBody :=\n  FnBody.case `Bool x IRType.uint8 #[\n    Alt.ctor {name := ``Bool.false, cidx := 0, size := 0, usize := 0, ssize := 0} e,\n    Alt.ctor {name := ``Bool.true, cidx := 1, size := 0, usize := 0, ssize := 0} t\n  ]", "start": [605, 1], "end": [609, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getUnboxOpName", "code": "def getUnboxOpName (t : IRType) : String :=\n  match t with\n  | IRType.usize  => \"lean_unbox_usize\"\n  | IRType.uint32 => \"lean_unbox_uint32\"\n  | IRType.uint64 => \"lean_unbox_uint64\"\n  | IRType.float  => \"lean_unbox_float\"\n  | _             => \"lean_unbox\"", "start": [611, 1], "end": [617, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Syntax.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Name.lean", "lake-packages/lean4/src/lean/Lean/Data/Format.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "String.Range", "code": "protected structure String.Range where\n  start : String.Pos\n  stop  : String.Pos\n  deriving Inhabited, Repr, BEq, Hashable", "start": [9, 1], "end": [16, 42], "kind": "commanddeclaration"}, {"full_name": "String.Range.contains", "code": "def String.Range.contains (r : String.Range) (pos : String.Pos) (includeStop := false) : Bool :=\n  r.start <= pos && (if includeStop then pos <= r.stop else pos < r.stop)", "start": [18, 1], "end": [19, 74], "kind": "commanddeclaration"}, {"full_name": "String.Range.includes", "code": "def String.Range.includes (super sub : String.Range) : Bool :=\n  super.start <= sub.start && super.stop >= sub.stop", "start": [21, 1], "end": [22, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.SourceInfo.updateTrailing", "code": "def SourceInfo.updateTrailing (trailing : Substring) : SourceInfo \u2192 SourceInfo\n  | SourceInfo.original leading pos _ endPos => SourceInfo.original leading pos trailing endPos\n  | info                                     => info", "start": [26, 1], "end": [28, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.IsNode", "code": "inductive IsNode : Syntax \u2192 Prop where\n  | mk (info : SourceInfo) (kind : SyntaxNodeKind) (args : Array Syntax) : IsNode (Syntax.node info kind args)", "start": [32, 1], "end": [33, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNode", "code": "def SyntaxNode : Type := {s : Syntax // IsNode s }", "start": [35, 1], "end": [35, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.unreachIsNodeMissing", "code": "def unreachIsNodeMissing {\u03b2} (h : IsNode Syntax.missing) : \u03b2 := False.elim (nomatch h)", "start": [37, 1], "end": [37, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.unreachIsNodeAtom", "code": "def unreachIsNodeAtom {\u03b2} {info val} (h : IsNode (Syntax.atom info val)) : \u03b2 := False.elim (nomatch h)", "start": [38, 1], "end": [38, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.unreachIsNodeIdent", "code": "def unreachIsNodeIdent {\u03b2 info rawVal val preresolved} (h : IsNode (Syntax.ident info rawVal val preresolved)) : \u03b2 := False.elim (nomatch h)", "start": [39, 1], "end": [39, 141], "kind": "commanddeclaration"}, {"full_name": "Lean.isLitKind", "code": "def isLitKind (k : SyntaxNodeKind) : Bool :=\n  k == strLitKind || k == numLitKind || k == charLitKind || k == nameLitKind || k == scientificLitKind", "start": [41, 1], "end": [42, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNode.getKind", "code": "@[inline] def getKind (n : SyntaxNode) : SyntaxNodeKind :=\n  match n with\n  | \u27e8Syntax.node _ k _, _\u27e9  => k\n  | \u27e8Syntax.missing, h\u27e9     => unreachIsNodeMissing h\n  | \u27e8Syntax.atom .., h\u27e9     => unreachIsNodeAtom h\n  | \u27e8Syntax.ident .., h\u27e9    => unreachIsNodeIdent h", "start": [46, 1], "end": [51, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNode.withArgs", "code": "@[inline] def withArgs {\u03b2} (n : SyntaxNode) (fn : Array Syntax \u2192 \u03b2) : \u03b2 :=\n  match n with\n  | \u27e8Syntax.node _ _ args, _\u27e9   => fn args\n  | \u27e8Syntax.missing, h\u27e9       => unreachIsNodeMissing h\n  | \u27e8Syntax.atom _ _, h\u27e9      => unreachIsNodeAtom h\n  | \u27e8Syntax.ident _ _ _ _, h\u27e9 => unreachIsNodeIdent h", "start": [53, 1], "end": [58, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNode.getNumArgs", "code": "@[inline] def getNumArgs (n : SyntaxNode) : Nat :=\n  withArgs n fun args => args.size", "start": [60, 1], "end": [61, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNode.getArg", "code": "@[inline] def getArg (n : SyntaxNode) (i : Nat) : Syntax :=\n  withArgs n fun args => args.get! i", "start": [63, 1], "end": [64, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNode.getArgs", "code": "@[inline] def getArgs (n : SyntaxNode) : Array Syntax :=\n  withArgs n fun args => args", "start": [66, 1], "end": [67, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNode.modifyArgs", "code": "@[inline] def modifyArgs (n : SyntaxNode) (fn : Array Syntax \u2192 Array Syntax) : Syntax :=\n  match n with\n  | \u27e8Syntax.node i k args, _\u27e9  => Syntax.node i k (fn args)\n  | \u27e8Syntax.missing, h\u27e9        => unreachIsNodeMissing h\n  | \u27e8Syntax.atom _ _, h\u27e9       => unreachIsNodeAtom h\n  | \u27e8Syntax.ident _ _ _ _,  h\u27e9 => unreachIsNodeIdent h", "start": [69, 1], "end": [74, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getAtomVal", "code": "def getAtomVal : Syntax \u2192 String\n  | atom _ val => val\n  | _          => \"\"", "start": [80, 1], "end": [82, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.setAtomVal", "code": "def setAtomVal : Syntax \u2192 String \u2192 Syntax\n  | atom info _, v => (atom info v)\n  | stx,         _ => stx", "start": [84, 1], "end": [86, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.ifNode", "code": "@[inline] def ifNode {\u03b2} (stx : Syntax) (hyes : SyntaxNode \u2192 \u03b2) (hno : Unit \u2192 \u03b2) : \u03b2 :=\n  match stx with\n  | Syntax.node i k args => hyes \u27e8Syntax.node i k args, IsNode.mk i k args\u27e9\n  | _                    => hno ()", "start": [88, 1], "end": [91, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.ifNodeKind", "code": "@[inline] def ifNodeKind {\u03b2} (stx : Syntax) (kind : SyntaxNodeKind) (hyes : SyntaxNode \u2192 \u03b2) (hno : Unit \u2192 \u03b2) : \u03b2 :=\n  match stx with\n  | Syntax.node i k args => if k == kind then hyes \u27e8Syntax.node i k args, IsNode.mk i k args\u27e9 else hno ()\n  | _                    => hno ()", "start": [93, 1], "end": [96, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.asNode", "code": "def asNode : Syntax \u2192 SyntaxNode\n  | Syntax.node info kind args => \u27e8Syntax.node info kind args, IsNode.mk info kind args\u27e9\n  | _                          => \u27e8mkNullNode, IsNode.mk _ _ _\u27e9", "start": [98, 1], "end": [100, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getIdAt", "code": "def getIdAt (stx : Syntax) (i : Nat) : Name :=\n  (stx.getArg i).getId", "start": [102, 1], "end": [103, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.modifyArgs", "code": "@[inline] def modifyArgs (stx : Syntax) (fn : Array Syntax \u2192 Array Syntax) : Syntax :=\n  match stx with\n  | node i k args => node i k (fn args)\n  | stx           => stx", "start": [105, 1], "end": [108, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.modifyArg", "code": "@[inline] def modifyArg (stx : Syntax) (i : Nat) (fn : Syntax \u2192 Syntax) : Syntax :=\n  match stx with\n  | node info k args => node info k (args.modify i fn)\n  | stx              => stx", "start": [110, 1], "end": [113, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.replaceM", "code": "@[specialize] partial def replaceM {m : Type \u2192 Type} [Monad m] (fn : Syntax \u2192 m (Option Syntax)) : Syntax \u2192 m (Syntax)\n  | stx@(node info kind args) => do\n    match (\u2190 fn stx) with\n    | some stx => return stx\n    | none     => return node info kind (\u2190 args.mapM (replaceM fn))\n  | stx => do\n    let o \u2190 fn stx\n    return o.getD stx", "start": [115, 1], "end": [122, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.rewriteBottomUpM", "code": "@[specialize] partial def rewriteBottomUpM {m : Type \u2192 Type} [Monad m] (fn : Syntax \u2192 m (Syntax)) : Syntax \u2192 m (Syntax)\n  | node info kind args   => do\n    let args \u2190 args.mapM (rewriteBottomUpM fn)\n    fn (node info kind args)\n  | stx => fn stx", "start": [124, 1], "end": [128, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.rewriteBottomUp", "code": "@[inline] def rewriteBottomUp (fn : Syntax \u2192 Syntax) (stx : Syntax) : Syntax :=\n  Id.run <| stx.rewriteBottomUpM fn", "start": [130, 1], "end": [131, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.updateInfo", "code": "private def updateInfo : SourceInfo \u2192 String.Pos \u2192 String.Pos \u2192 SourceInfo\n  | SourceInfo.original lead pos trail endPos, leadStart, trailStop =>\n    SourceInfo.original { lead with startPos := leadStart } pos { trail with stopPos := trailStop } endPos\n  | info, _, _ => info", "start": [133, 1], "end": [136, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.chooseNiceTrailStop", "code": "private def chooseNiceTrailStop (trail : Substring) : String.Pos :=\ntrail.startPos + trail.posOf '\\n'", "start": [138, 1], "end": [139, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.updateLeadingAux", "code": "@[inline]\nprivate def updateLeadingAux : Syntax \u2192 StateM String.Pos (Option Syntax)\n  | atom info@(SourceInfo.original _ _ trail _) val => do\n    let trailStop := chooseNiceTrailStop trail\n    let newInfo := updateInfo info (\u2190 get) trailStop\n    set trailStop\n    return some (atom newInfo val)\n  | ident info@(SourceInfo.original _ _ trail _) rawVal val pre => do\n    let trailStop := chooseNiceTrailStop trail\n    let newInfo := updateInfo info (\u2190 get) trailStop\n    set trailStop\n    return some (ident newInfo rawVal val pre)\n  | _ => pure none", "start": [141, 1], "end": [155, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.updateLeading", "code": "def updateLeading : Syntax \u2192 Syntax :=\n  fun stx => (replaceM updateLeadingAux stx).run' 0", "start": [157, 1], "end": [173, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.updateTrailing", "code": "partial def updateTrailing (trailing : Substring) : Syntax \u2192 Syntax\n  | Syntax.atom info val               => Syntax.atom (info.updateTrailing trailing) val\n  | Syntax.ident info rawVal val pre   => Syntax.ident (info.updateTrailing trailing) rawVal val pre\n  | n@(Syntax.node info k args)        =>\n    if args.size == 0 then n\n    else\n     let i    := args.size - 1\n     let last := updateTrailing trailing args[i]!\n     let args := args.set! i last;\n     Syntax.node info k args\n  | s => s", "start": [175, 1], "end": [185, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getTailWithPos", "code": "partial def getTailWithPos : Syntax \u2192 Option Syntax\n  | stx@(atom info _)   => info.getPos?.map fun _ => stx\n  | stx@(ident info ..) => info.getPos?.map fun _ => stx\n  | node SourceInfo.none _ args => args.findSomeRev? getTailWithPos\n  | stx@(node ..) => stx\n  | _ => none", "start": [187, 1], "end": [192, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.identComponents", "code": "def identComponents (stx : Syntax) (nFields? : Option Nat := none) : List Syntax :=\n  match stx with\n  | ident si@(SourceInfo.original lead pos trail _) rawStr val _ => Id.run do\n    let val := val.eraseMacroScopes\n    let nameComps := nameComps val nFields?\n    let rawComps := splitNameLit rawStr\n    if !rawComps.isEmpty then\n      let rawComps :=\n        if let some nFields := nFields? then\n          let nPrefix := rawComps.length - nFields\n          let prefixSz := rawComps.take nPrefix |>.foldl (init := 0) fun acc (ss : Substring) => acc + ss.bsize + 1\n          let prefixSz := prefixSz - 1 rawStr.extract 0 \u27e8prefixSz\u27e9 :: rawComps.drop nPrefix\n        else\n          rawComps\n      if nameComps.length == rawComps.length then\n        return nameComps.zip rawComps |>.map fun (id, ss) =>\n          let off := ss.startPos - rawStr.startPos\n          let lead := if off == 0 then lead else \"\".toSubstring\n          let trail := if ss.stopPos == rawStr.stopPos then trail else \"\".toSubstring\n          let info := original lead (pos + off) trail (pos + off + \u27e8ss.bsize\u27e9)\n          ident info ss id []\n    nameComps.map fun n => ident si n.toString.toSubstring n []\n  | ident si _ val _ =>\n    let val := val.eraseMacroScopes\n    \n    nameComps val nFields? |>.map fun n => ident si n.toString.toSubstring n []\n  | _ => unreachable!\n  where\n    nameComps (n : Name) (nFields? : Option Nat) : List Name :=\n      if let some nFields := nFields? then\n        let nameComps := n.components\n        let nPrefix := nameComps.length - nFields\n        let namePrefix := nameComps.take nPrefix |>.foldl (init := Name.anonymous) fun acc n => acc ++ n\n        namePrefix :: nameComps.drop nPrefix\n      else\n        n.components", "start": [195, 1], "end": [239, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.TopDown", "code": "structure TopDown where\n  firstChoiceOnly : Bool\n  stx : Syntax", "start": [241, 1], "end": [243, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.topDown", "code": "def topDown (stx : Syntax) (firstChoiceOnly := false) : TopDown := \u27e8firstChoiceOnly, stx\u27e9", "start": [245, 1], "end": [249, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.reprint", "code": "partial def reprint (stx : Syntax) : Option String := do\n  let mut s := \"\"\n  for stx in stx.topDown (firstChoiceOnly := true) do\n    match stx with\n    | atom info val           => s := s ++ reprintLeaf info val\n    | ident info rawVal _ _   => s := s ++ reprintLeaf info rawVal.toString\n    | node _    kind args     =>\n      if kind == choiceKind then\n        let s0 \u2190 reprint args[0]!\n        for arg in args[1:] do\n          let s' \u2190 reprint arg\n          guard (s0 == s')\n    | _ => pure ()\n  return s\nwhere\n  reprintLeaf (info : SourceInfo) (val : String) : String :=\n    match info with\n    | SourceInfo.original lead _ trail _ => s!\"{lead}{val}{trail}\"\n    | _                                => s!\" {val} \"", "start": [271, 1], "end": [295, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.hasMissing", "code": "def hasMissing (stx : Syntax) : Bool := Id.run do\n  for stx in stx.topDown do\n    if stx.isMissing then\n      return true\n  return false", "start": [297, 1], "end": [301, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getRange?", "code": "def getRange? (stx : Syntax) (canonicalOnly := false) : Option String.Range :=\n  match stx.getPos? canonicalOnly, stx.getTailPos? canonicalOnly with\n  | some start, some stop => some { start, stop }\n  | _,          _         => none", "start": [303, 1], "end": [306, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Traverser", "code": "structure Traverser where\n  cur     : Syntax\n  parents : Array Syntax\n  idxs    : Array Nat", "start": [308, 1], "end": [316, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Traverser.fromSyntax", "code": "def fromSyntax (stx : Syntax) : Traverser :=\n  \u27e8stx, #[], #[]\u27e9", "start": [320, 1], "end": [321, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Traverser.setCur", "code": "def setCur (t : Traverser) (stx : Syntax) : Traverser :=\n  { t with cur := stx }", "start": [323, 1], "end": [324, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Traverser.down", "code": "def down (t : Traverser) (idx : Nat) : Traverser :=\n  if idx < t.cur.getNumArgs then\n    { cur := t.cur.getArg idx, parents := t.parents.push <| t.cur.setArg idx default, idxs := t.idxs.push idx }\n  else\n    { cur := Syntax.missing, parents := t.parents.push t.cur, idxs := t.idxs.push idx }", "start": [326, 1], "end": [331, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Traverser.up", "code": "def up (t : Traverser) : Traverser :=\n  if t.parents.size > 0 then\n    let cur := if t.idxs.back < t.parents.back.getNumArgs then t.parents.back.setArg t.idxs.back t.cur else t.parents.back\n    { cur := cur, parents := t.parents.pop, idxs := t.idxs.pop }\n  else\n    t", "start": [333, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Traverser.left", "code": "def left (t : Traverser) : Traverser :=\n  if t.parents.size > 0 then\n    t.up.down (t.idxs.back - 1)\n  else\n    t", "start": [341, 1], "end": [346, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Traverser.right", "code": "def right (t : Traverser) : Traverser :=\n  if t.parents.size > 0 then\n    t.up.down (t.idxs.back + 1)\n  else\n    t", "start": [348, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.MonadTraverser", "code": "class MonadTraverser (m : Type \u2192 Type) where\n  st : MonadState Traverser m", "start": [357, 1], "end": [359, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.MonadTraverser.getCur", "code": "def getCur : m Syntax := Traverser.cur <$> t.st.get", "start": [365, 1], "end": [365, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.MonadTraverser.setCur", "code": "def setCur (stx : Syntax) : m Unit := @modify _ _ t.st (fun t => t.setCur stx)", "start": [366, 1], "end": [366, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.MonadTraverser.goDown", "code": "def goDown (idx : Nat)    : m Unit := @modify _ _ t.st (fun t => t.down idx)", "start": [367, 1], "end": [367, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.MonadTraverser.goUp", "code": "def goUp                  : m Unit := @modify _ _ t.st (fun t => t.up)", "start": [368, 1], "end": [368, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.MonadTraverser.goLeft", "code": "def goLeft                : m Unit := @modify _ _ t.st (fun t => t.left)", "start": [369, 1], "end": [369, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.MonadTraverser.goRight", "code": "def goRight               : m Unit := @modify _ _ t.st (fun t => t.right)", "start": [370, 1], "end": [370, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.MonadTraverser.getIdx", "code": "def getIdx : m Nat := do\n  let st \u2190 t.st.get\n  return st.idxs.back?.getD 0", "start": [372, 1], "end": [374, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.SyntaxNode.getIdAt", "code": "@[inline] def getIdAt (n : SyntaxNode) (i : Nat) : Name :=\n  (n.getArg i).getId", "start": [381, 1], "end": [382, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.mkListNode", "code": "def mkListNode (args : Array Syntax) : Syntax :=\n  mkNullNode args", "start": [386, 1], "end": [387, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isQuot", "code": "def isQuot : Syntax \u2192 Bool\n  | Syntax.node _ (Name.str _ \"quot\")           _ => true\n  | Syntax.node _ `Lean.Parser.Term.dynamicQuot _ => true\n  | _                                             => false", "start": [392, 1], "end": [395, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getQuotContent", "code": "def getQuotContent (stx : Syntax) : Syntax :=\n  let stx := if stx.getNumArgs == 1 then stx[0] else stx\n  if stx.isOfKind `Lean.Parser.Term.dynamicQuot then\n    stx[3]\n  else\n    stx[1]", "start": [397, 1], "end": [402, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isAntiquot", "code": "def isAntiquot : Syntax \u2192 Bool\n  | .node _ (.str _ \"antiquot\") _ => true\n  | _                             => false", "start": [405, 1], "end": [407, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isAntiquots", "code": "def isAntiquots (stx : Syntax) : Bool :=\n  stx.isAntiquot || (stx.isOfKind choiceKind && stx.getNumArgs > 0 && stx.getArgs.all isAntiquot)", "start": [409, 1], "end": [410, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getCanonicalAntiquot", "code": "def getCanonicalAntiquot (stx : Syntax) : Syntax :=\n  if stx.isOfKind choiceKind then\n    stx[0]\n  else\n    stx", "start": [412, 1], "end": [416, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkAntiquotNode", "code": "def mkAntiquotNode (kind : Name) (term : Syntax) (nesting := 0) (name : Option String := none) (isPseudoKind := false) : Syntax :=\n  let nesting := mkNullNode (mkArray nesting (mkAtom \"$\"))\n  let term :=\n    if term.isIdent then term\n    else if term.isOfKind `Lean.Parser.Term.hole then term[0]\n    else mkNode `antiquotNestedExpr #[mkAtom \"(\", term, mkAtom \")\"]\n  let name := match name with\n    | some name => mkNode `antiquotName #[mkAtom \":\", mkAtom name]\n    | none      => mkNullNode\n  mkNode (kind ++ (if isPseudoKind then `pseudo else Name.anonymous) ++ `antiquot) #[mkAtom \"$\", nesting, term, name]", "start": [418, 1], "end": [427, 118], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isEscapedAntiquot", "code": "def isEscapedAntiquot (stx : Syntax) : Bool :=\n  !stx[1].getArgs.isEmpty", "start": [430, 1], "end": [431, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.unescapeAntiquot", "code": "def unescapeAntiquot (stx : Syntax) : Syntax :=\n  if isAntiquot stx then\n    stx.setArg 1 <| mkNullNode stx[1].getArgs.pop\n  else\n    stx", "start": [434, 1], "end": [438, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getAntiquotTerm", "code": "def getAntiquotTerm (stx : Syntax) : Syntax :=\n  let e := if stx.isAntiquot then stx[2] else stx[3]\n  if e.isIdent then e\n  else if e.isAtom then mkNode `Lean.Parser.Term.hole #[e]\n  else\n    e[1]", "start": [441, 1], "end": [447, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.antiquotKind?", "code": "def antiquotKind? : Syntax \u2192 Option (SyntaxNodeKind \u00d7 Bool)\n  | .node _ (.str (.str k \"pseudo\") \"antiquot\") _ => (k, true)\n  | .node _ (.str k                 \"antiquot\") _ => (k, false)\n  | _                                             => none", "start": [449, 1], "end": [453, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.antiquotKinds", "code": "def antiquotKinds (stx : Syntax) : List (SyntaxNodeKind \u00d7 Bool) :=\n  if stx.isOfKind choiceKind then\n    stx.getArgs.filterMap antiquotKind? |>.toList\n  else\n    match antiquotKind? stx with\n    | some stx => [stx]\n    | none     => []", "start": [455, 1], "end": [461, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.antiquotSpliceKind?", "code": "def antiquotSpliceKind? : Syntax \u2192 Option SyntaxNodeKind\n  | .node _ (.str k \"antiquot_scope\") _ => some k\n  | _ => none", "start": [464, 1], "end": [466, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isAntiquotSplice", "code": "def isAntiquotSplice (stx : Syntax) : Bool :=\n  antiquotSpliceKind? stx |>.isSome", "start": [468, 1], "end": [469, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getAntiquotSpliceContents", "code": "def getAntiquotSpliceContents (stx : Syntax) : Array Syntax :=\n  stx[3].getArgs", "start": [471, 1], "end": [472, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getAntiquotSpliceSuffix", "code": "def getAntiquotSpliceSuffix (stx : Syntax) : Syntax :=\n  if stx.isAntiquotSplice then\n    stx[5]\n  else\n    stx[1]", "start": [475, 1], "end": [479, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkAntiquotSpliceNode", "code": "def mkAntiquotSpliceNode (kind : SyntaxNodeKind) (contents : Array Syntax) (suffix : String) (nesting := 0) : Syntax :=\n  let nesting := mkNullNode (mkArray nesting (mkAtom \"$\"))\n  mkNode (kind ++ `antiquot_splice) #[mkAtom \"$\", nesting, mkAtom \"[\", mkNullNode contents, mkAtom \"]\", mkAtom suffix]", "start": [481, 1], "end": [483, 119], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.antiquotSuffixSplice?", "code": "def antiquotSuffixSplice? : Syntax \u2192 Option SyntaxNodeKind\n  | .node _ (.str k \"antiquot_suffix_splice\") _ => some k\n  | _ => none", "start": [486, 1], "end": [488, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isAntiquotSuffixSplice", "code": "def isAntiquotSuffixSplice (stx : Syntax) : Bool :=\n  antiquotSuffixSplice? stx |>.isSome", "start": [490, 1], "end": [491, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.getAntiquotSuffixSpliceInner", "code": "def getAntiquotSuffixSpliceInner (stx : Syntax) : Syntax :=\n  stx[0]", "start": [494, 1], "end": [495, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.mkAntiquotSuffixSpliceNode", "code": "def mkAntiquotSuffixSpliceNode (kind : SyntaxNodeKind) (inner : Syntax) (suffix : String) : Syntax :=\n  mkNode (kind ++ `antiquot_suffix_splice) #[inner, mkAtom suffix]", "start": [497, 1], "end": [498, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isTokenAntiquot", "code": "def isTokenAntiquot (stx : Syntax) : Bool :=\n  stx.isOfKind `token_antiquot", "start": [500, 1], "end": [501, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.isAnyAntiquot", "code": "def isAnyAntiquot (stx : Syntax) : Bool :=\n  stx.isAntiquot || stx.isAntiquotSplice || stx.isAntiquotSuffixSplice || stx.isTokenAntiquot", "start": [503, 1], "end": [504, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Stack", "code": "protected abbrev Stack := List (Syntax \u00d7 Nat)", "start": [506, 1], "end": [509, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.findStack?", "code": "partial def findStack? (root : Syntax) (visit : Syntax \u2192 Bool) (accept : Syntax \u2192 Bool := fun stx => !stx.hasArgs) : Option Syntax.Stack :=\n  if visit root then go [] root else none\nwhere\n  go (stack : Syntax.Stack) (stx : Syntax) : Option Syntax.Stack := Id.run do\n    if accept stx then\n      return (stx, 0) :: stack  for i in [0:stx.getNumArgs] do\n      if visit stx[i] then\n        if let some stack := go ((stx, i) :: stack) stx[i] then\n          return stack\n    return none", "start": [511, 1], "end": [522, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.Stack.matches", "code": "def Stack.matches (stack : Syntax.Stack) (pattern : List $ Option SyntaxNodeKind) : Bool :=\n  stack.length >= pattern.length &&\n  (stack\n    |>.zipWith (fun (s, _) p => p |>.map (s.isOfKind \u00b7) |>.getD true) pattern\n    |>.all id)", "start": [524, 1], "end": [530, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Trie.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Format.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Data.Trie", "code": "inductive Trie (\u03b1 : Type) where\n  | leaf : Option \u03b1 \u2192 Trie \u03b1\n  | node1 : Option \u03b1 \u2192 UInt8 \u2192 Trie \u03b1 \u2192 Trie \u03b1\n  | node : Option \u03b1 \u2192 ByteArray \u2192 Array (Trie \u03b1) \u2192 Trie \u03b1", "start": [37, 1], "end": [42, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.Trie.empty", "code": "def empty : Trie \u03b1 := leaf none", "start": [47, 1], "end": [48, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.Trie.upsert", "code": "partial def upsert (t : Trie \u03b1) (s : String) (f : Option \u03b1 \u2192 \u03b1) : Trie \u03b1 :=\n  let rec insertEmpty (i : Nat) : Trie \u03b1 :=\n    if h : i < s.utf8ByteSize then\n      let c := s.getUtf8Byte i h\n      let t := insertEmpty (i + 1)\n      node1 none c t\n    else\n      leaf (f .none)\n  let rec loop\n    | i, leaf v =>\n      if h : i < s.utf8ByteSize then\n        let c := s.getUtf8Byte i h\n        let t := insertEmpty (i + 1)\n        node1 v c t\n      else\n        leaf (f v)\n    | i, node1 v c' t' =>\n      if h : i < s.utf8ByteSize then\n        let c := s.getUtf8Byte i h\n        if c == c'\n        then node1 v c' (loop (i + 1) t')\n        else \n          let t := insertEmpty (i + 1)\n          node v (.mk #[c, c']) #[t, t']\n      else\n        node1 (f v) c' t'\n    | i, node v cs ts =>\n      if h : i < s.utf8ByteSize then\n        let c := s.getUtf8Byte i h\n        match cs.findIdx? (\u00b7 == c) with\n          | none   =>\n            let t := insertEmpty (i + 1)\n            node v (cs.push c) (ts.push t)\n          | some idx =>\n            node v cs (ts.modify idx (loop (i + 1)))\n      else\n        node (f v) cs ts\n  loop 0 t", "start": [56, 1], "end": [94, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.Trie.insert", "code": "partial def insert (t : Trie \u03b1) (s : String) (val : \u03b1) : Trie \u03b1 :=\n  upsert t s (fun _ => val)", "start": [96, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.Trie.find?", "code": "partial def find? (t : Trie \u03b1) (s : String) : Option \u03b1 :=\n  let rec loop\n    | i, leaf val =>\n      if i < s.utf8ByteSize then\n        none\n      else\n        val\n    | i, node1 val c' t' =>\n      if h : i < s.utf8ByteSize then\n        let c := s.getUtf8Byte i h\n        if c == c'\n        then loop (i + 1) t'\n        else none\n      else\n        val\n    | i, node val cs ts =>\n      if h : i < s.utf8ByteSize then\n        let c := s.getUtf8Byte i h\n        match cs.findIdx? (\u00b7 == c) with\n        | none   => none\n        | some idx => loop (i + 1) (ts.get! idx)\n      else\n        val\n  loop 0 t", "start": [100, 1], "end": [124, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.Trie.values", "code": "partial def values (t : Trie \u03b1) : Array \u03b1 := go t |>.run #[] |>.2\n  where\n    go : Trie \u03b1 \u2192 StateM (Array \u03b1) Unit\n      | leaf a? => do\n        if let some a := a? then\n          modify (\u00b7.push a)\n      | node1 a? _ t' => do\n        if let some a := a? then\n          modify (\u00b7.push a)\n        go t'\n      | node a? _ ts => do\n        if let some a := a? then\n          modify (\u00b7.push a)\n        ts.forM fun t' => go t'", "start": [126, 1], "end": [140, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.Trie.findPrefix", "code": "partial def findPrefix (t : Trie \u03b1) (pre : String) : Array \u03b1 := go t 0\n  where\n    go (t : Trie \u03b1) (i : Nat) : Array \u03b1 :=\n      if h : i < pre.utf8ByteSize then\n        let c := pre.getUtf8Byte i h\n        match t with\n        | leaf _val => .empty\n        | node1 _val c' t' =>\n          if c == c'\n          then go t' (i + 1)\n          else .empty\n        | node _val cs ts =>\n          match cs.findIdx? (\u00b7 == c) with\n          | none   => .empty\n          | some idx => go (ts.get! idx) (i + 1)\n      else\n        t.values", "start": [142, 1], "end": [159, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.Trie.matchPrefix", "code": "partial def matchPrefix (s : String) (t : Trie \u03b1) (i : String.Pos) : Option \u03b1 :=\n  let rec loop\n    | leaf v, _, res =>\n      if v.isSome then v else res\n    | node1 v c' t', i, res =>\n      let res := if v.isSome then v else res\n      if h : i < s.utf8ByteSize then\n        let c := s.getUtf8Byte i h\n        if c == c'\n        then loop t' (i + 1) res\n        else res\n      else\n        res\n    | node v cs ts, i, res =>\n      let res := if v.isSome then v else res\n      if h : i < s.utf8ByteSize then\n        let c := s.getUtf8Byte i h\n        match cs.findIdx? (\u00b7 == c) with\n        | none => res\n        | some idx => loop (ts.get! idx) (i + 1) res\n      else\n        res\n  loop t i.byteIdx none", "start": [161, 1], "end": [185, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Data.Trie.toStringAux", "code": "private partial def toStringAux {\u03b1 : Type} : Trie \u03b1 \u2192 List Format\n  | leaf _ => []\n  | node1 _ c t =>\n    [ format (repr c), Format.group $ Format.nest 4 $ flip Format.joinSep Format.line $ toStringAux t ]\n  | node _ cs ts =>\n    List.join $ List.zipWith (fun c t =>\n      [ format (repr c), (Format.group $ Format.nest 4 $ flip Format.joinSep Format.line $ toStringAux t) ]\n    ) cs.toList ts.toList", "start": [187, 1], "end": [194, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Main.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/PPGoal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.ContextInfo.saveNoFileMap", "code": "def saveNoFileMap : m ContextInfo := return {\n    env           := (\u2190 getEnv)\n    fileMap       := default\n    mctx          := (\u2190 getMCtx)\n    options       := (\u2190 getOptions)\n    currNamespace := (\u2190 getCurrNamespace)\n    openDecls     := (\u2190 getOpenDecls)\n    ngen          := (\u2190 getNGen)\n  }", "start": [13, 1], "end": [21, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ContextInfo.save", "code": "def save [MonadFileMap m] : m ContextInfo := do\n  let ctx \u2190 saveNoFileMap\n  return { ctx with fileMap := (\u2190 getFileMap) }", "start": [23, 1], "end": [25, 48], "kind": "commanddeclaration"}, {"full_name": "CompletionInfo.stx", "code": "def CompletionInfo.stx : CompletionInfo \u2192 Syntax\n  | dot i .. => i.stx\n  | id stx .. => stx\n  | dotId stx .. => stx\n  | fieldId stx .. => stx\n  | namespaceId stx => stx\n  | option stx => stx\n  | endSection stx .. => stx\n  | tactic stx .. => stx", "start": [29, 1], "end": [37, 25], "kind": "commanddeclaration"}, {"full_name": "CustomInfo.format", "code": "def CustomInfo.format : CustomInfo \u2192 Format\n  | i => f!\"CustomInfo({i.value.typeName})\"", "start": [39, 1], "end": [40, 44], "kind": "commanddeclaration"}, {"full_name": "InfoTree.findInfo?", "code": "partial def InfoTree.findInfo? (p : Info \u2192 Bool) (t : InfoTree) : Option Info :=\n  match t with\n  | context _ t => findInfo? p t\n  | node i ts   =>\n    if p i then\n      some i\n    else\n      ts.findSome? (findInfo? p)\n  | _ => none", "start": [44, 1], "end": [52, 14], "kind": "commanddeclaration"}, {"full_name": "InfoTree.substitute", "code": "partial def InfoTree.substitute (tree : InfoTree) (assignment : PersistentHashMap MVarId InfoTree) : InfoTree :=\n  match tree with\n  | node i c => node i <| c.map (substitute \u00b7 assignment)\n  | context i t => context i (substitute t assignment)\n  | hole id  => match assignment.find? id with\n    | none      => hole id\n    | some tree => substitute tree assignment", "start": [54, 1], "end": [62, 46], "kind": "commanddeclaration"}, {"full_name": "ContextInfo.runMetaM", "code": "def ContextInfo.runMetaM (info : ContextInfo) (lctx : LocalContext) (x : MetaM \u03b1) : IO \u03b1 := do\n  let x := x.run { lctx := lctx } { mctx := info.mctx }\n  \n  let ((a, _), _) \u2190\n    x.toIO { options := info.options, currNamespace := info.currNamespace, openDecls := info.openDecls, fileName := \"<InfoTree>\", fileMap := default }\n           { env := info.env, ngen := info.ngen }\n  return a", "start": [64, 1], "end": [73, 11], "kind": "commanddeclaration"}, {"full_name": "ContextInfo.toPPContext", "code": "def ContextInfo.toPPContext (info : ContextInfo) (lctx : LocalContext) : PPContext :=\n  { env  := info.env, mctx := info.mctx, lctx := lctx,\n    opts := info.options, currNamespace := info.currNamespace, openDecls := info.openDecls }", "start": [75, 1], "end": [77, 93], "kind": "commanddeclaration"}, {"full_name": "ContextInfo.ppSyntax", "code": "def ContextInfo.ppSyntax (info : ContextInfo) (lctx : LocalContext) (stx : Syntax) : IO Format := do\n  ppTerm (info.toPPContext lctx) \u27e8stx\u27e9", "start": [79, 1], "end": [80, 39], "kind": "commanddeclaration"}, {"full_name": "formatStxRange", "code": "private def formatStxRange (ctx : ContextInfo) (stx : Syntax) : Format :=\n  let pos    := stx.getPos?.getD 0\n  let endPos := stx.getTailPos?.getD pos\n  f!\"{fmtPos pos stx.getHeadInfo}-{fmtPos endPos stx.getTailInfo}\"\nwhere fmtPos pos info :=\n  let pos := format <| ctx.fileMap.toPosition pos\n  match info with\n  | .original ..                      => pos\n  | .synthetic (canonical := true) .. => f!\"{pos}\u2020!\"\n  | _                                 => f!\"{pos}\u2020\"", "start": [82, 1], "end": [91, 52], "kind": "commanddeclaration"}, {"full_name": "formatElabInfo", "code": "private def formatElabInfo (ctx : ContextInfo) (info : ElabInfo) : Format :=\n  if info.elaborator.isAnonymous then\n    formatStxRange ctx info.stx\n  else\n    f!\"{formatStxRange ctx info.stx} @ {info.elaborator}\"", "start": [93, 1], "end": [97, 58], "kind": "commanddeclaration"}, {"full_name": "TermInfo.runMetaM", "code": "def TermInfo.runMetaM (info : TermInfo) (ctx : ContextInfo) (x : MetaM \u03b1) : IO \u03b1 :=\n  ctx.runMetaM info.lctx x", "start": [99, 1], "end": [100, 27], "kind": "commanddeclaration"}, {"full_name": "TermInfo.format", "code": "def TermInfo.format (ctx : ContextInfo) (info : TermInfo) : IO Format := do\n  info.runMetaM ctx do\n    let ty : Format \u2190 try\n      Meta.ppExpr (\u2190 Meta.inferType info.expr)\n    catch _ =>\n      pure \"<failed-to-infer-type>\"\n    return f!\"{\u2190 Meta.ppExpr info.expr} {if info.isBinder then \"(isBinder := true) \" else \"\"}: {ty} @ {formatElabInfo ctx info.toElabInfo}\"", "start": [102, 1], "end": [108, 140], "kind": "commanddeclaration"}, {"full_name": "CompletionInfo.format", "code": "def CompletionInfo.format (ctx : ContextInfo) (info : CompletionInfo) : IO Format :=\n  match info with\n  | .dot i (expectedType? := expectedType?) .. => return f!\"[.] {\u2190 i.format ctx} : {expectedType?}\"\n  | .id stx _ _ lctx expectedType? => ctx.runMetaM lctx do return f!\"[.] {\u2190 ctx.ppSyntax lctx stx} : {expectedType?} @ {formatStxRange ctx info.stx}\"\n  | _ => return f!\"[.] {info.stx} @ {formatStxRange ctx info.stx}\"", "start": [110, 1], "end": [114, 67], "kind": "commanddeclaration"}, {"full_name": "CommandInfo.format", "code": "def CommandInfo.format (ctx : ContextInfo) (info : CommandInfo) : IO Format := do\n  return f!\"command @ {formatElabInfo ctx info.toElabInfo}\"", "start": [116, 1], "end": [117, 60], "kind": "commanddeclaration"}, {"full_name": "OptionInfo.format", "code": "def OptionInfo.format (ctx : ContextInfo) (info : OptionInfo) : IO Format := do\n  return f!\"option {info.optionName} @ {formatStxRange ctx info.stx}\"", "start": [119, 1], "end": [120, 70], "kind": "commanddeclaration"}, {"full_name": "FieldInfo.format", "code": "def FieldInfo.format (ctx : ContextInfo) (info : FieldInfo) : IO Format := do\n  ctx.runMetaM info.lctx do\n    return f!\"{info.fieldName} : {\u2190 Meta.ppExpr (\u2190 Meta.inferType info.val)} := {\u2190 Meta.ppExpr info.val} @ {formatStxRange ctx info.stx}\"", "start": [122, 1], "end": [124, 138], "kind": "commanddeclaration"}, {"full_name": "ContextInfo.ppGoals", "code": "def ContextInfo.ppGoals (ctx : ContextInfo) (goals : List MVarId) : IO Format :=\n  if goals.isEmpty then\n    return \"no goals\"\n  else\n    ctx.runMetaM {} (return Std.Format.prefixJoin \"\\n\" (\u2190 goals.mapM (Meta.ppGoal \u00b7)))", "start": [126, 1], "end": [130, 87], "kind": "commanddeclaration"}, {"full_name": "TacticInfo.format", "code": "def TacticInfo.format (ctx : ContextInfo) (info : TacticInfo) : IO Format := do\n  let ctxB := { ctx with mctx := info.mctxBefore }\n  let ctxA := { ctx with mctx := info.mctxAfter }\n  let goalsBefore \u2190 ctxB.ppGoals info.goalsBefore\n  let goalsAfter  \u2190 ctxA.ppGoals info.goalsAfter\n  return f!\"Tactic @ {formatElabInfo ctx info.toElabInfo}\\n{info.stx}\\nbefore {goalsBefore}\\nafter {goalsAfter}\"", "start": [132, 1], "end": [137, 113], "kind": "commanddeclaration"}, {"full_name": "MacroExpansionInfo.format", "code": "def MacroExpansionInfo.format (ctx : ContextInfo) (info : MacroExpansionInfo) : IO Format := do\n  let stx    \u2190 ctx.ppSyntax info.lctx info.stx\n  let output \u2190 ctx.ppSyntax info.lctx info.output\n  return f!\"Macro expansion\\n{stx}\\n===>\\n{output}\"", "start": [139, 1], "end": [142, 52], "kind": "commanddeclaration"}, {"full_name": "UserWidgetInfo.format", "code": "def UserWidgetInfo.format (info : UserWidgetInfo) : Format :=\n  f!\"UserWidget {info.widgetId}\\n{Std.ToFormat.format info.props}\"", "start": [144, 1], "end": [145, 67], "kind": "commanddeclaration"}, {"full_name": "FVarAliasInfo.format", "code": "def FVarAliasInfo.format (info : FVarAliasInfo) : Format :=\n  f!\"FVarAlias {info.userName.eraseMacroScopes}\"", "start": [147, 1], "end": [148, 49], "kind": "commanddeclaration"}, {"full_name": "FieldRedeclInfo.format", "code": "def FieldRedeclInfo.format (ctx : ContextInfo) (info : FieldRedeclInfo) : Format :=\n  f!\"FieldRedecl @ {formatStxRange ctx info.stx}\"", "start": [150, 1], "end": [151, 50], "kind": "commanddeclaration"}, {"full_name": "Info.format", "code": "def Info.format (ctx : ContextInfo) : Info \u2192 IO Format\n  | ofTacticInfo i         => i.format ctx\n  | ofTermInfo i           => i.format ctx\n  | ofCommandInfo i        => i.format ctx\n  | ofMacroExpansionInfo i => i.format ctx\n  | ofOptionInfo i         => i.format ctx\n  | ofFieldInfo i          => i.format ctx\n  | ofCompletionInfo i     => i.format ctx\n  | ofUserWidgetInfo i     => pure <| i.format\n  | ofCustomInfo i         => pure <| Std.ToFormat.format i\n  | ofFVarAliasInfo i      => pure <| i.format\n  | ofFieldRedeclInfo i    => pure <| i.format ctx", "start": [153, 1], "end": [164, 51], "kind": "commanddeclaration"}, {"full_name": "Info.toElabInfo?", "code": "def Info.toElabInfo? : Info \u2192 Option ElabInfo\n  | ofTacticInfo i         => some i.toElabInfo\n  | ofTermInfo i           => some i.toElabInfo\n  | ofCommandInfo i        => some i.toElabInfo\n  | ofMacroExpansionInfo _ => none\n  | ofOptionInfo _         => none\n  | ofFieldInfo _          => none\n  | ofCompletionInfo _     => none\n  | ofUserWidgetInfo _     => none\n  | ofCustomInfo _         => none\n  | ofFVarAliasInfo _      => none\n  | ofFieldRedeclInfo _    => none", "start": [166, 1], "end": [177, 35], "kind": "commanddeclaration"}, {"full_name": "Info.updateContext?", "code": "def Info.updateContext? : Option ContextInfo \u2192 Info \u2192 Option ContextInfo\n  | some ctx, ofTacticInfo i => some { ctx with mctx := i.mctxAfter }\n  | ctx?, _ => ctx?", "start": [179, 1], "end": [195, 20], "kind": "commanddeclaration"}, {"full_name": "InfoTree.format", "code": "partial def InfoTree.format (tree : InfoTree) (ctx? : Option ContextInfo := none) : IO Format := do\n  match tree with\n  | hole id     => return .nestD f!\"\u2022 ?{toString id.name}\"\n  | context i t => format t i\n  | node i cs   => match ctx? with\n    | none => return \"\u2022 <context-not-available>\"\n    | some ctx =>\n      let fmt \u2190 i.format ctx\n      if cs.size == 0 then\n        return .nestD f!\"\u2022 {fmt}\"\n      else\n        let ctx? := i.updateContext? ctx?\n        return .nestD f!\"\u2022 {fmt}{Std.Format.prefixJoin .line (\u2190 cs.toList.mapM fun c => format c ctx?)}\"", "start": [197, 1], "end": [209, 105], "kind": "commanddeclaration"}, {"full_name": "modifyInfoTrees", "code": "@[inline] private def modifyInfoTrees (f : PersistentArray InfoTree \u2192 PersistentArray InfoTree) : m Unit :=\n  modifyInfoState fun s => { s with trees := f s.trees }", "start": [214, 1], "end": [215, 57], "kind": "commanddeclaration"}, {"full_name": "getResetInfoTrees", "code": "def getResetInfoTrees : m (PersistentArray InfoTree) := do\n  let trees := (\u2190 getInfoState).trees\n  modifyInfoTrees fun _ => {}\n  return trees", "start": [217, 1], "end": [221, 15], "kind": "commanddeclaration"}, {"full_name": "pushInfoTree", "code": "def pushInfoTree (t : InfoTree) : m Unit := do\n  if (\u2190 getInfoState).enabled then\n    modifyInfoTrees fun ts => ts.push t", "start": [223, 1], "end": [225, 40], "kind": "commanddeclaration"}, {"full_name": "pushInfoLeaf", "code": "def pushInfoLeaf (t : Info) : m Unit := do\n  if (\u2190 getInfoState).enabled then\n    pushInfoTree <| InfoTree.node (children := {}) t", "start": [227, 1], "end": [229, 53], "kind": "commanddeclaration"}, {"full_name": "addCompletionInfo", "code": "def addCompletionInfo (info : CompletionInfo) : m Unit := do\n  pushInfoLeaf <| Info.ofCompletionInfo info", "start": [231, 1], "end": [232, 45], "kind": "commanddeclaration"}, {"full_name": "addConstInfo", "code": "def addConstInfo [MonadEnv m] [MonadError m]\n    (stx : Syntax) (n : Name) (expectedType? : Option Expr := none) : m Unit := do\n  pushInfoLeaf <| .ofTermInfo {\n    elaborator := .anonymous\n    lctx := .empty\n    expr := (\u2190 mkConstWithLevelParams n)\n    stx\n    expectedType?\n  }", "start": [234, 1], "end": [242, 4], "kind": "commanddeclaration"}, {"full_name": "resolveGlobalConstNoOverloadWithInfo", "code": "def resolveGlobalConstNoOverloadWithInfo [MonadResolveName m] [MonadEnv m] [MonadError m]\n    (id : Syntax) (expectedType? : Option Expr := none) : m Name := do\n  let n \u2190 resolveGlobalConstNoOverload id\n  if (\u2190 getInfoState).enabled then\n    addConstInfo id n expectedType?\n  return n", "start": [244, 1], "end": [254, 11], "kind": "commanddeclaration"}, {"full_name": "resolveGlobalConstWithInfos", "code": "def resolveGlobalConstWithInfos [MonadResolveName m] [MonadEnv m] [MonadError m]\n    (id : Syntax) (expectedType? : Option Expr := none) : m (List Name) := do\n  let ns \u2190 resolveGlobalConst id\n  if (\u2190 getInfoState).enabled then\n    for n in ns do\n      addConstInfo id n expectedType?\n  return ns", "start": [256, 1], "end": [263, 12], "kind": "commanddeclaration"}, {"full_name": "resolveGlobalNameWithInfos", "code": "def resolveGlobalNameWithInfos [MonadResolveName m] [MonadEnv m] [MonadError m]\n    (ref : Syntax) (id : Name) : m (List (Name \u00d7 List String)) := do\n  let ns \u2190 resolveGlobalName id\n  if (\u2190 getInfoState).enabled then\n    for (n, _) in ns do\n      addConstInfo ref n\n  return ns", "start": [265, 1], "end": [272, 12], "kind": "commanddeclaration"}, {"full_name": "withInfoContext'", "code": "def withInfoContext' [MonadFinally m] (x : m \u03b1) (mkInfo : \u03b1 \u2192 m (Sum Info MVarId)) : m \u03b1 := do\n  if (\u2190 getInfoState).enabled then\n    let treesSaved \u2190 getResetInfoTrees\n    Prod.fst <$> MonadFinally.tryFinally' x fun a? => do\n      match a? with\n      | none   => modifyInfoTrees fun _ => treesSaved\n      | some a =>\n        let info \u2190 mkInfo a\n        modifyInfoTrees fun trees =>\n          match info with\n          | Sum.inl info   => treesSaved.push <| InfoTree.node info trees\n          | Sum.inr mvarId => treesSaved.push <| InfoTree.hole mvarId\n  else\n    x", "start": [274, 1], "end": [293, 6], "kind": "commanddeclaration"}, {"full_name": "withInfoTreeContext", "code": "def withInfoTreeContext [MonadFinally m] (x : m \u03b1) (mkInfoTree : PersistentArray InfoTree \u2192 m InfoTree) : m \u03b1 := do\n  if (\u2190 getInfoState).enabled then\n    let treesSaved \u2190 getResetInfoTrees\n    Prod.fst <$> MonadFinally.tryFinally' x fun _ => do\n      let st    \u2190 getInfoState\n      let tree  \u2190 mkInfoTree st.trees\n      modifyInfoTrees fun _ => treesSaved.push tree\n  else\n    x", "start": [295, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "withInfoContext", "code": "@[inline] def withInfoContext [MonadFinally m] (x : m \u03b1) (mkInfo : m Info) : m \u03b1 := do\n  withInfoTreeContext x (fun trees => do return InfoTree.node (\u2190 mkInfo) trees)", "start": [307, 1], "end": [309, 80], "kind": "commanddeclaration"}, {"full_name": "withSaveInfoContext", "code": "def withSaveInfoContext [MonadNameGenerator m] [MonadFinally m] [MonadEnv m] [MonadOptions m] [MonadMCtx m] [MonadResolveName m] [MonadFileMap m] (x : m \u03b1) : m \u03b1 := do\n  if (\u2190 getInfoState).enabled then\n    let treesSaved \u2190 getResetInfoTrees\n    Prod.fst <$> MonadFinally.tryFinally' x fun _ => do\n      let st    \u2190 getInfoState\n      let trees \u2190 st.trees.mapM fun tree => do\n        let tree := tree.substitute st.assignment\n        pure <| InfoTree.context (\u2190 ContextInfo.save) tree\n      modifyInfoTrees fun _ => treesSaved ++ trees\n  else\n    x", "start": [311, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "getInfoHoleIdAssignment?", "code": "def getInfoHoleIdAssignment? (mvarId : MVarId) : m (Option InfoTree) :=\n  return (\u2190 getInfoState).assignment[mvarId]", "start": [326, 1], "end": [327, 45], "kind": "commanddeclaration"}, {"full_name": "assignInfoHoleId", "code": "def assignInfoHoleId (mvarId : MVarId) (infoTree : InfoTree) : m Unit := do\n  assert! (\u2190 getInfoHoleIdAssignment? mvarId).isNone\n  modifyInfoState fun s => { s with assignment := s.assignment.insert mvarId infoTree }", "start": [329, 1], "end": [331, 88], "kind": "commanddeclaration"}, {"full_name": "withMacroExpansionInfo", "code": "def withMacroExpansionInfo [MonadFinally m] [Monad m] [MonadInfoTree m] [MonadLCtx m] (stx output : Syntax) (x : m \u03b1) : m \u03b1 :=\n  let mkInfo : m Info := do\n    return Info.ofMacroExpansionInfo {\n      lctx   := (\u2190 getLCtx)\n      stx, output\n    }\n  withInfoContext x mkInfo", "start": [334, 1], "end": [340, 27], "kind": "commanddeclaration"}, {"full_name": "withInfoHole", "code": "@[inline] def withInfoHole [MonadFinally m] [Monad m] [MonadInfoTree m] (mvarId : MVarId) (x : m \u03b1) : m \u03b1 := do\n  if (\u2190 getInfoState).enabled then\n    let treesSaved \u2190 getResetInfoTrees\n    Prod.fst <$> MonadFinally.tryFinally' x fun _ => modifyInfoState fun s =>\n      if h : s.trees.size > 0 then\n        have : s.trees.size - 1 < s.trees.size := Nat.sub_lt h (by decide)\n        { s with trees := treesSaved, assignment := s.assignment.insert mvarId s.trees[s.trees.size - 1] }\n      else\n        { s with trees := treesSaved }\n  else\n    x", "start": [342, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "enableInfoTree", "code": "def enableInfoTree [MonadInfoTree m] (flag := true) : m Unit :=\n  modifyInfoState fun s => { s with enabled := flag }", "start": [354, 1], "end": [355, 54], "kind": "commanddeclaration"}, {"full_name": "withEnableInfoTree", "code": "def withEnableInfoTree [Monad m] [MonadInfoTree m] [MonadFinally m] (flag : Bool) (x : m \u03b1) : m \u03b1 := do\n  let saved := (\u2190 getInfoState).enabled\n  try\n    enableInfoTree flag\n    x\n  finally\n    enableInfoTree saved", "start": [357, 1], "end": [363, 25], "kind": "commanddeclaration"}, {"full_name": "getInfoTrees", "code": "def getInfoTrees [MonadInfoTree m] [Monad m] : m (PersistentArray InfoTree) :=\n  return (\u2190 getInfoState).trees", "start": [365, 1], "end": [366, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/NameTrie.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/PrefixTree.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.NamePart", "code": "inductive NamePart\n  | str (s : String)\n  | num (n : Nat)", "start": [10, 1], "end": [12, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.NamePart.cmp", "code": "def NamePart.cmp : NamePart \u2192 NamePart \u2192 Ordering\n  | NamePart.str a, NamePart.str b => compare a b\n  | NamePart.num a, NamePart.num b => compare a b\n  | NamePart.num _, NamePart.str _ => Ordering.lt\n  | _, _ => Ordering.gt", "start": [19, 1], "end": [23, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.NamePart.lt", "code": "def NamePart.lt : NamePart \u2192 NamePart \u2192 Bool\n  | NamePart.str a, NamePart.str b => a < b\n  | NamePart.num a, NamePart.num b => a < b\n  | NamePart.num _, NamePart.str _ => true\n  | _, _ => false", "start": [25, 1], "end": [29, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.NameTrie", "code": "def NameTrie (\u03b2 : Type u) := PrefixTree NamePart \u03b2 NamePart.cmp", "start": [31, 1], "end": [31, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.toKey", "code": "private def toKey (n : Name) : List NamePart :=\n  loop n []\nwhere\n  loop\n    | Name.str p s,   parts => loop p (NamePart.str s :: parts)\n    | Name.num p n,   parts => loop p (NamePart.num n :: parts)\n    | Name.anonymous, parts => parts", "start": [33, 1], "end": [39, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.NameTrie.insert", "code": "def NameTrie.insert (t : NameTrie \u03b2) (n : Name) (b : \u03b2) : NameTrie \u03b2 :=\n  PrefixTree.insert t (toKey n) b", "start": [41, 1], "end": [42, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.NameTrie.empty", "code": "def NameTrie.empty : NameTrie \u03b2 :=\n  PrefixTree.empty", "start": [44, 1], "end": [45, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.NameTrie.find?", "code": "def NameTrie.find? (t : NameTrie \u03b2) (k : Name) : Option \u03b2 :=\n  PrefixTree.find? t (toKey k)", "start": [53, 1], "end": [54, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.NameTrie.foldMatchingM", "code": "@[inline]\ndef NameTrie.foldMatchingM [Monad m] (t : NameTrie \u03b2) (k : Name) (init : \u03c3) (f : \u03b2 \u2192 \u03c3 \u2192 m \u03c3) : m \u03c3 :=\n  PrefixTree.foldMatchingM t (toKey k) init f", "start": [56, 1], "end": [58, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.NameTrie.foldM", "code": "@[inline]\ndef NameTrie.foldM [Monad m] (t : NameTrie \u03b2) (init : \u03c3) (f : \u03b2 \u2192 \u03c3 \u2192 m \u03c3) : m \u03c3 :=\n  t.foldMatchingM Name.anonymous init f", "start": [60, 1], "end": [62, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.NameTrie.forMatchingM", "code": "@[inline]\ndef NameTrie.forMatchingM [Monad m] (t : NameTrie \u03b2) (k : Name) (f : \u03b2 \u2192 m Unit) : m Unit :=\n  PrefixTree.forMatchingM t (toKey k) f", "start": [64, 1], "end": [66, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.NameTrie.forM", "code": "@[inline]\ndef NameTrie.forM [Monad m] (t : NameTrie \u03b2) (f : \u03b2 \u2192 m Unit) : m Unit :=\n  t.forMatchingM Name.anonymous f", "start": [68, 1], "end": [70, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/Format.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.formatArg", "code": "private def formatArg : Arg \u2192 Format\n  | Arg.var id     => format id\n  | Arg.irrelevant => \"\u25fe\"", "start": [11, 1], "end": [13, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatArray", "code": "def formatArray {\u03b1 : Type} [ToFormat \u03b1] (args : Array \u03b1) : Format :=\n  args.foldl (fun r a => r ++ \" \" ++ format a) Format.nil", "start": [17, 1], "end": [18, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatLitVal", "code": "private def formatLitVal : LitVal \u2192 Format\n  | LitVal.num v => format v\n  | LitVal.str v => format (repr v)", "start": [20, 1], "end": [22, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatCtorInfo", "code": "private def formatCtorInfo : CtorInfo \u2192 Format\n  | { name := name, cidx := cidx, usize := usize, ssize := ssize, .. } => Id.run do\n    let mut r := f!\"ctor_{cidx}\"\n    if usize > 0 || ssize > 0 then\n      r := f!\"{r}.{usize}.{ssize}\"\n    if name != Name.anonymous then\n      r := f!\"{r}[{name}]\"\n    r", "start": [26, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatExpr", "code": "private def formatExpr : Expr \u2192 Format\n  | Expr.ctor i ys      => format i ++ formatArray ys\n  | Expr.reset n x      => \"reset[\" ++ format n ++ \"] \" ++ format x\n  | Expr.reuse x i u ys => \"reuse\" ++ (if u then \"!\" else \"\") ++ \" \" ++ format x ++ \" in \" ++ format i ++ formatArray ys\n  | Expr.proj i x       => \"proj[\" ++ format i ++ \"] \" ++ format x\n  | Expr.uproj i x      => \"uproj[\" ++ format i ++ \"] \" ++ format x\n  | Expr.sproj n o x    => \"sproj[\" ++ format n ++ \", \" ++ format o ++ \"] \" ++ format x\n  | Expr.fap c ys       => format c ++ formatArray ys\n  | Expr.pap c ys       => \"pap \" ++ format c ++ formatArray ys\n  | Expr.ap x ys        => \"app \" ++ format x ++ formatArray ys\n  | Expr.box _ x        => \"box \" ++ format x\n  | Expr.unbox x        => \"unbox \" ++ format x\n  | Expr.lit v          => format v\n  | Expr.isShared x     => \"isShared \" ++ format x", "start": [37, 1], "end": [50, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatIRType", "code": "private partial def formatIRType : IRType \u2192 Format\n  | IRType.float        => \"float\"\n  | IRType.uint8        => \"u8\"\n  | IRType.uint16       => \"u16\"\n  | IRType.uint32       => \"u32\"\n  | IRType.uint64       => \"u64\"\n  | IRType.usize        => \"usize\"\n  | IRType.irrelevant   => \"\u25fe\"\n  | IRType.object       => \"obj\"\n  | IRType.tobject      => \"tobj\"\n  | IRType.struct _ tys =>\n    let _ : ToFormat IRType := \u27e8formatIRType\u27e9\n    \"struct \" ++ Format.bracket \"{\" (Format.joinSep tys.toList \", \") \"}\"\n  | IRType.union _ tys  =>\n    let _ : ToFormat IRType := \u27e8formatIRType\u27e9\n    \"union \" ++ Format.bracket \"{\" (Format.joinSep  tys.toList \", \") \"}\"", "start": [55, 1], "end": [70, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatParam", "code": "private def formatParam : Param \u2192 Format\n  | { x := name, borrow := b, ty := ty } => \"(\" ++ format name ++ \" : \" ++ (if b then \"@& \" else \"\") ++ format ty ++ \")\"", "start": [75, 1], "end": [76, 121], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatAlt", "code": "def formatAlt (fmt : FnBody \u2192 Format) (indent : Nat) : Alt \u2192 Format\n  | Alt.ctor i b  => format i.name ++ \" \u2192\" ++ Format.nest indent (Format.line ++ fmt b)\n  | Alt.default b => \"default \u2192\" ++ Format.nest indent (Format.line ++ fmt b)", "start": [80, 1], "end": [82, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatParams", "code": "def formatParams (ps : Array Param) : Format :=\n  formatArray ps", "start": [84, 1], "end": [85, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatFnBodyHead", "code": "def formatFnBodyHead : FnBody \u2192 Format\n  | FnBody.vdecl x ty e _      => \"let \" ++ format x ++ \" : \" ++ format ty ++ \" := \" ++ format e\n  | FnBody.jdecl j xs _ _      => format j ++ formatParams xs ++ \" := ...\"\n  | FnBody.set x i y _         => \"set \" ++ format x ++ \"[\" ++ format i ++ \"] := \" ++ format y\n  | FnBody.uset x i y _        => \"uset \" ++ format x ++ \"[\" ++ format i ++ \"] := \" ++ format y\n  | FnBody.sset x i o y ty _   => \"sset \" ++ format x ++ \"[\" ++ format i ++ \", \" ++ format o ++ \"] : \" ++ format ty ++ \" := \" ++ format y\n  | FnBody.setTag x cidx _     => \"setTag \" ++ format x ++ \" := \" ++ format cidx\n  | FnBody.inc x n _ _ _       => \"inc\" ++ (if n != 1 then Format.sbracket (format n) else \"\") ++ \" \" ++ format x\n  | FnBody.dec x n _ _ _       => \"dec\" ++ (if n != 1 then Format.sbracket (format n) else \"\") ++ \" \" ++ format x\n  | FnBody.del x _             => \"del \" ++ format x\n  | FnBody.mdata d _           => \"mdata \" ++ format d\n  | FnBody.case _   x _     _  => \"case \" ++ format x ++ \" of ...\"\n  | FnBody.jmp j ys            => \"jmp \" ++ format j ++ formatArray ys\n  | FnBody.ret x               => \"ret \" ++ format x\n  | FnBody.unreachable         => \"\u22a5\"", "start": [87, 1], "end": [101, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatFnBodyHead'", "code": "@[export lean_ir_format_fn_body_head]\nprivate def formatFnBodyHead' (fn : FnBody) : String :=\n  formatFnBodyHead fn |>.pretty", "start": [103, 1], "end": [105, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatFnBody", "code": "partial def formatFnBody (fnBody : FnBody) (indent : Nat := 2) : Format :=\n  let rec loop : FnBody \u2192 Format\n    | FnBody.vdecl x ty e b      => \"let \" ++ format x ++ \" : \" ++ format ty ++ \" := \" ++ format e ++ \";\" ++ Format.line ++ loop b\n    | FnBody.jdecl j xs v b      => format j ++ formatParams xs ++ \" :=\" ++ Format.nest indent (Format.line ++ loop v) ++ \";\" ++ Format.line ++ loop b\n    | FnBody.set x i y b         => \"set \" ++ format x ++ \"[\" ++ format i ++ \"] := \" ++ format y ++ \";\" ++ Format.line ++ loop b\n    | FnBody.uset x i y b        => \"uset \" ++ format x ++ \"[\" ++ format i ++ \"] := \" ++ format y ++ \";\" ++ Format.line ++ loop b\n    | FnBody.sset x i o y ty b   => \"sset \" ++ format x ++ \"[\" ++ format i ++ \", \" ++ format o ++ \"] : \" ++ format ty ++ \" := \" ++ format y ++ \";\" ++ Format.line ++ loop b\n    | FnBody.setTag x cidx b     => \"setTag \" ++ format x ++ \" := \" ++ format cidx ++ \";\" ++ Format.line ++ loop b\n    | FnBody.inc x n _ _ b       => \"inc\" ++ (if n != 1 then Format.sbracket (format n) else \"\") ++ \" \" ++ format x ++ \";\" ++ Format.line ++ loop b\n    | FnBody.dec x n _ _ b       => \"dec\" ++ (if n != 1 then Format.sbracket (format n) else \"\") ++ \" \" ++ format x ++ \";\" ++ Format.line ++ loop b\n    | FnBody.del x b             => \"del \" ++ format x ++ \";\" ++ Format.line ++ loop b\n    | FnBody.mdata d b           => \"mdata \" ++ format d ++ \";\" ++ Format.line ++ loop b\n    | FnBody.case _ x xType cs   => \"case \" ++ format x ++ \" : \" ++ format xType ++ \" of\" ++ cs.foldl (fun r c => r ++ Format.line ++ formatAlt loop indent c) Format.nil\n    | FnBody.jmp j ys            => \"jmp \" ++ format j ++ formatArray ys\n    | FnBody.ret x               => \"ret \" ++ format x\n    | FnBody.unreachable         => \"\u22a5\"\n  loop fnBody", "start": [107, 1], "end": [123, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.formatDecl", "code": "def formatDecl (decl : Decl) (indent : Nat := 2) : Format :=\n  match decl with\n  | Decl.fdecl f xs ty b _  => \"def \" ++ format f ++ formatParams xs ++ format \" : \" ++ format ty ++ \" :=\" ++ Format.nest indent (Format.line ++ formatFnBody b indent)\n  | Decl.extern f xs ty _   => \"extern \" ++ format f ++ formatParams xs ++ format \" : \" ++ format ty", "start": [128, 1], "end": [131, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.declToString", "code": "@[export lean_ir_decl_to_string]\ndef declToString (d : Decl) : String :=\n  (format d).pretty", "start": [135, 1], "end": [137, 20], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Types.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Trie.lean", "lake-packages/lean4/src/lean/Lean/Message.lean", "lake-packages/lean4/src/lean/Lean/Syntax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.mkAtom", "code": "abbrev mkAtom (info : SourceInfo) (val : String) : Syntax :=\n  Syntax.atom info val", "start": [12, 1], "end": [13, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkIdent", "code": "abbrev mkIdent (info : SourceInfo) (rawVal : Substring) (val : Name) : Syntax :=\n  Syntax.ident info rawVal val []", "start": [15, 1], "end": [16, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getNext", "code": "def getNext (input : String) (pos : String.Pos) : Char :=\n  input.get (input.next pos)", "start": [18, 1], "end": [20, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.maxPrec", "code": "def maxPrec  : Nat := eval_prec max", "start": [22, 1], "end": [27, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.argPrec", "code": "def argPrec  : Nat := eval_prec arg", "start": [28, 1], "end": [28, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.leadPrec", "code": "def leadPrec : Nat := eval_prec lead", "start": [29, 1], "end": [29, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.minPrec", "code": "def minPrec  : Nat := eval_prec min", "start": [30, 1], "end": [30, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Token", "code": "abbrev Token := String", "start": [32, 1], "end": [32, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.TokenTable", "code": "abbrev TokenTable := Lean.Data.Trie Token", "start": [34, 1], "end": [34, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxNodeKindSet", "code": "abbrev SyntaxNodeKindSet := PersistentHashMap SyntaxNodeKind Unit", "start": [36, 1], "end": [36, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxNodeKindSet.insert", "code": "def SyntaxNodeKindSet.insert (s : SyntaxNodeKindSet) (k : SyntaxNodeKind) : SyntaxNodeKindSet :=\n  PersistentHashMap.insert s k ()", "start": [38, 1], "end": [39, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.InputContext", "code": "structure InputContext where\n  input    : String\n  fileName : String\n  fileMap  : FileMap\n  deriving Inhabited", "start": [41, 1], "end": [48, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserModuleContext", "code": "structure ParserModuleContext where\n  env : Environment\n  options       : Options\n  currNamespace : Name := .anonymous\n  openDecls     : List OpenDecl := []", "start": [50, 1], "end": [56, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.CacheableParserContext", "code": "structure CacheableParserContext where\n  prec               : Nat\n  quotDepth          : Nat := 0\n  suppressInsideQuot : Bool := false\n  savedPos?          : Option String.Pos := none\n  forbiddenTk?       : Option Token := none\n  deriving BEq", "start": [58, 1], "end": [66, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserContextCore", "code": "structure ParserContextCore extends InputContext, ParserModuleContext, CacheableParserContext where\n  tokens : TokenTable", "start": [68, 1], "end": [70, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserContext", "code": "structure ParserContext extends ParserContextCore where private mk ::", "start": [72, 1], "end": [73, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Error", "code": "structure Error where\n  \n  unexpectedTk : Syntax := .missing\n  unexpected : String := \"\"\n  expected : List String := []\n  deriving Inhabited, BEq", "start": [75, 1], "end": [82, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Error.expectedToString", "code": "private def expectedToString : List String \u2192 String\n  | []       => \"\"\n  | [e]      => e\n  | [e1, e2] => e1 ++ \" or \" ++ e2\n  | e::es    => e ++ \", \" ++ expectedToString es", "start": [86, 1], "end": [90, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Error.toString", "code": "protected def toString (e : Error) : String :=\n  let unexpected := if e.unexpected == \"\" then [] else [e.unexpected]\n  let expected   := if e.expected == [] then [] else\n    let expected := e.expected.toArray.qsort (fun e e' => e < e')\n    let expected := expected.toList.eraseReps\n    [\"expected \" ++ expectedToString expected]\n  \"; \".intercalate $ unexpected ++ expected", "start": [92, 1], "end": [98, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Error.merge", "code": "def merge (e\u2081 e\u2082 : Error) : Error :=\n  match e\u2082 with\n  | { unexpectedTk, unexpected := u, .. } =>\n    { unexpectedTk, unexpected := if u == \"\" then e\u2081.unexpected else u, expected := e\u2081.expected ++ e\u2082.expected }", "start": [103, 1], "end": [107, 113], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.TokenCacheEntry", "code": "structure TokenCacheEntry where\n  startPos : String.Pos := 0\n  stopPos  : String.Pos := 0\n  token    : Syntax := Syntax.missing", "start": [111, 1], "end": [114, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserCacheKey", "code": "structure ParserCacheKey extends CacheableParserContext where\n  parserName : Name\n  pos        : String.Pos\n  deriving BEq", "start": [116, 1], "end": [119, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserCacheEntry", "code": "structure ParserCacheEntry where\n  stx      : Syntax\n  lhsPrec  : Nat\n  newPos   : String.Pos\n  errorMsg : Option Error", "start": [125, 1], "end": [129, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserCache", "code": "structure ParserCache where\n  tokenCache  : TokenCacheEntry\n  parserCache : HashMap ParserCacheKey ParserCacheEntry", "start": [131, 1], "end": [133, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.initCacheForInput", "code": "def initCacheForInput (input : String) : ParserCache where\n  tokenCache  := { startPos := input.endPos + ' '  }\n  parserCache := {}", "start": [135, 1], "end": [137, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack", "code": "structure SyntaxStack where\n  private raw  : Array Syntax\n  private drop : Nat", "start": [139, 1], "end": [142, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.toSubarray", "code": "def toSubarray (stack : SyntaxStack) : Subarray Syntax :=\n  stack.raw.toSubarray stack.drop", "start": [146, 1], "end": [147, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.empty", "code": "def empty : SyntaxStack where\n  raw  := #[]\n  drop := 0", "start": [149, 1], "end": [151, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.size", "code": "def size (stack : SyntaxStack) : Nat :=\n  stack.raw.size - stack.drop", "start": [153, 1], "end": [154, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.isEmpty", "code": "def isEmpty (stack : SyntaxStack) : Bool :=\n  stack.size == 0", "start": [156, 1], "end": [157, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.shrink", "code": "def shrink (stack : SyntaxStack) (n : Nat) : SyntaxStack :=\n  { stack with raw := stack.raw.shrink (stack.drop + n) }", "start": [159, 1], "end": [160, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.push", "code": "def push (stack : SyntaxStack) (a : Syntax) : SyntaxStack :=\n  { stack with raw := stack.raw.push a }", "start": [162, 1], "end": [163, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.pop", "code": "def pop (stack : SyntaxStack) : SyntaxStack :=\n  if stack.size > 0 then\n    { stack with raw := stack.raw.pop }\n  else stack", "start": [165, 1], "end": [168, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.back", "code": "def back (stack : SyntaxStack) : Syntax :=\n  if stack.size > 0 then\n    stack.raw.back\n  else\n    panic! \"SyntaxStack.back: element is inaccessible\"", "start": [170, 1], "end": [174, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.get!", "code": "def get! (stack : SyntaxStack) (i : Nat) : Syntax :=\n  if i < stack.size then\n    stack.raw.get! (stack.drop + i)\n  else\n    panic! \"SyntaxStack.get!: element is inaccessible\"", "start": [176, 1], "end": [180, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.SyntaxStack.extract", "code": "def extract (stack : SyntaxStack) (start stop : Nat) : Array Syntax :=\n  stack.raw.extract (stack.drop + start) (stack.drop + stop)", "start": [182, 1], "end": [183, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState", "code": "structure ParserState where\n  stxStack : SyntaxStack := .empty\n  \n  lhsPrec  : Nat := 0\n  pos      : String.Pos := 0\n  cache    : ParserCache\n  errorMsg : Option Error := none", "start": [190, 1], "end": [200, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.hasError", "code": "@[inline]\ndef hasError (s : ParserState) : Bool :=\n  s.errorMsg != none", "start": [204, 1], "end": [206, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.stackSize", "code": "def stackSize (s : ParserState) : Nat :=\n  s.stxStack.size", "start": [208, 1], "end": [209, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.restore", "code": "def restore (s : ParserState) (iniStackSz : Nat) (iniPos : String.Pos) : ParserState :=\n  { s with stxStack := s.stxStack.shrink iniStackSz, errorMsg := none, pos := iniPos }", "start": [211, 1], "end": [212, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.setPos", "code": "def setPos (s : ParserState) (pos : String.Pos) : ParserState :=\n  { s with pos := pos }", "start": [214, 1], "end": [215, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.setCache", "code": "def setCache (s : ParserState) (cache : ParserCache) : ParserState :=\n  { s with cache := cache }", "start": [217, 1], "end": [218, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.pushSyntax", "code": "def pushSyntax (s : ParserState) (n : Syntax) : ParserState :=\n  { s with stxStack := s.stxStack.push n }", "start": [220, 1], "end": [221, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.popSyntax", "code": "def popSyntax (s : ParserState) : ParserState :=\n  { s with stxStack := s.stxStack.pop }", "start": [223, 1], "end": [224, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.shrinkStack", "code": "def shrinkStack (s : ParserState) (iniStackSz : Nat) : ParserState :=\n  { s with stxStack := s.stxStack.shrink iniStackSz }", "start": [226, 1], "end": [227, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.next", "code": "def next (s : ParserState) (input : String) (pos : String.Pos) : ParserState :=\n  { s with pos := input.next pos }", "start": [229, 1], "end": [230, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.next'", "code": "def next' (s : ParserState) (input : String) (pos : String.Pos) (h : \u00ac input.atEnd pos) : ParserState :=\n  { s with pos := input.next' pos h }", "start": [232, 1], "end": [233, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.toErrorMsg", "code": "def toErrorMsg (ctx : InputContext) (s : ParserState) : String :=\n  match s.errorMsg with\n  | none     => \"\"\n  | some msg =>\n    let pos := ctx.fileMap.toPosition s.pos\n    mkErrorStringWithPos ctx.fileName pos (toString msg)", "start": [235, 1], "end": [240, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkNode", "code": "def mkNode (s : ParserState) (k : SyntaxNodeKind) (iniStackSz : Nat) : ParserState :=\n  match s with\n  | \u27e8stack, lhsPrec, pos, cache, err\u27e9 =>\n    if err != none && stack.size == iniStackSz then\n      let stack   := stack.push Syntax.missing\n      \u27e8stack, lhsPrec, pos, cache, err\u27e9\n    else\n      let newNode := Syntax.node SourceInfo.none k (stack.extract iniStackSz stack.size)\n      let stack   := stack.shrink iniStackSz\n      let stack   := stack.push newNode\n      \u27e8stack, lhsPrec, pos, cache, err\u27e9", "start": [242, 1], "end": [259, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkTrailingNode", "code": "def mkTrailingNode (s : ParserState) (k : SyntaxNodeKind) (iniStackSz : Nat) : ParserState :=\n  match s with\n  | \u27e8stack, lhsPrec, pos, cache, err\u27e9 =>\n    let newNode := Syntax.node SourceInfo.none k (stack.extract (iniStackSz - 1) stack.size)\n    let stack   := stack.shrink (iniStackSz - 1)\n    let stack   := stack.push newNode\n    \u27e8stack, lhsPrec, pos, cache, err\u27e9", "start": [261, 1], "end": [267, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.setError", "code": "@[inline]\ndef setError (s : ParserState) (e : Error) : ParserState :=\n  match s with\n  | \u27e8stack, lhsPrec, pos, cache, _\u27e9 => \u27e8stack, lhsPrec, pos, cache, some e\u27e9", "start": [269, 1], "end": [272, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkError", "code": "def mkError (s : ParserState) (msg : String) : ParserState :=\n  s.setError { expected := [msg] } |>.pushSyntax .missing", "start": [274, 1], "end": [275, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkUnexpectedError", "code": "def mkUnexpectedError (s : ParserState) (msg : String) (expected : List String := []) (pushMissing := true) : ParserState :=\n  let s := s.setError { unexpected := msg, expected }\n  if pushMissing then s.pushSyntax .missing else s", "start": [277, 1], "end": [279, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkEOIError", "code": "def mkEOIError (s : ParserState) (expected : List String := []) : ParserState :=\n  s.mkUnexpectedError \"unexpected end of input\" expected", "start": [281, 1], "end": [282, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkErrorsAt", "code": "def mkErrorsAt (s : ParserState) (ex : List String) (pos : String.Pos) (initStackSz? : Option Nat := none) : ParserState := Id.run do\n  let mut s := s.setPos pos\n  if let some sz := initStackSz? then\n    s := s.shrinkStack sz\n  s := s.setError { expected := ex }\n  s.pushSyntax .missing", "start": [284, 1], "end": [289, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkErrorAt", "code": "def mkErrorAt (s : ParserState) (msg : String) (pos : String.Pos) (initStackSz? : Option Nat := none) : ParserState :=\n  s.mkErrorsAt [msg] pos initStackSz?", "start": [291, 1], "end": [292, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkUnexpectedTokenErrors", "code": "def mkUnexpectedTokenErrors (s : ParserState) (ex : List String) (iniPos : String.Pos := 0) : ParserState :=\n  let tk := s.stxStack.back\n  let s := s.setPos (if iniPos > 0 then iniPos else tk.getPos?.get!)\n  let s := s.setError { unexpectedTk := tk, expected := ex }\n  s.popSyntax.pushSyntax .missing", "start": [294, 1], "end": [304, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkUnexpectedTokenError", "code": "def mkUnexpectedTokenError (s : ParserState) (msg : String) (iniPos : String.Pos := 0) : ParserState :=\n  s.mkUnexpectedTokenErrors [msg] iniPos", "start": [306, 1], "end": [311, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mkUnexpectedErrorAt", "code": "def mkUnexpectedErrorAt (s : ParserState) (msg : String) (pos : String.Pos) : ParserState :=\n  s.setPos pos |>.mkUnexpectedError msg", "start": [313, 1], "end": [314, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserFn", "code": "def ParserFn := ParserContext \u2192 ParserState \u2192 ParserState", "start": [318, 1], "end": [318, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.FirstTokens", "code": "inductive FirstTokens where\n  | epsilon   : FirstTokens\n  | unknown   : FirstTokens\n  | tokens    : List Token \u2192 FirstTokens\n  | optTokens : List Token \u2192 FirstTokens\n  deriving Inhabited", "start": [323, 1], "end": [328, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.FirstTokens.seq", "code": "def seq : FirstTokens \u2192 FirstTokens \u2192 FirstTokens\n  | epsilon,      tks          => tks\n  | optTokens s\u2081, optTokens s\u2082 => optTokens (s\u2081 ++ s\u2082)\n  | optTokens s\u2081, tokens s\u2082    => tokens (s\u2081 ++ s\u2082)\n  | tks,          _            => tks", "start": [332, 1], "end": [336, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.FirstTokens.toOptional", "code": "def toOptional : FirstTokens \u2192 FirstTokens\n  | tokens tks => optTokens tks\n  | tks        => tks", "start": [338, 1], "end": [340, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.FirstTokens.merge", "code": "def merge : FirstTokens \u2192 FirstTokens \u2192 FirstTokens\n  | epsilon,      tks          => toOptional tks\n  | tks,          epsilon      => toOptional tks\n  | tokens s\u2081,    tokens s\u2082    => tokens (s\u2081 ++ s\u2082)\n  | optTokens s\u2081, optTokens s\u2082 => optTokens (s\u2081 ++ s\u2082)\n  | tokens s\u2081,    optTokens s\u2082 => optTokens (s\u2081 ++ s\u2082)\n  | optTokens s\u2081, tokens s\u2082    => optTokens (s\u2081 ++ s\u2082)\n  | _,            _            => unknown", "start": [342, 1], "end": [349, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.FirstTokens.toStr", "code": "def toStr : FirstTokens \u2192 String\n  | epsilon       => \"epsilon\"\n  | unknown       => \"unknown\"\n  | tokens tks    => toString tks\n  | optTokens tks => \"?\" ++ toString tks", "start": [351, 1], "end": [355, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserInfo", "code": "structure ParserInfo where\n  collectTokens : List Token \u2192 List Token := id\n  collectKinds  : SyntaxNodeKindSet \u2192 SyntaxNodeKindSet := id\n  firstTokens   : FirstTokens := FirstTokens.unknown\n  deriving Inhabited", "start": [362, 1], "end": [366, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Parser", "code": "structure Parser where\n  info : ParserInfo := {}\n  fn   : ParserFn\n  deriving Inhabited", "start": [368, 1], "end": [371, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.TrailingParser", "code": "abbrev TrailingParser := Parser", "start": [373, 1], "end": [373, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withFn", "code": "@[inline]\ndef withFn (f : ParserFn \u2192 ParserFn) (p : Parser) : Parser := { p with fn := f p.fn }", "start": [375, 1], "end": [377, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.adaptCacheableContextFn", "code": "def adaptCacheableContextFn (f : CacheableParserContext \u2192 CacheableParserContext) (p : ParserFn) : ParserFn := fun c s =>\n  p { c with toCacheableParserContext := f c.toCacheableParserContext } s", "start": [379, 1], "end": [380, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.adaptCacheableContext", "code": "def adaptCacheableContext (f : CacheableParserContext \u2192 CacheableParserContext) : Parser \u2192 Parser :=\n  withFn (adaptCacheableContextFn f)", "start": [382, 1], "end": [383, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withStackDrop", "code": "private def withStackDrop (drop : Nat) (p : ParserFn) : ParserFn := fun c s =>\n  let initDrop := s.stxStack.drop\n  let s := p c { s with stxStack.drop := drop }\n  { s with stxStack.drop := initDrop }", "start": [385, 1], "end": [388, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withResetCacheFn", "code": "def withResetCacheFn (p : ParserFn) : ParserFn := withStackDrop 0 fun c s =>\n  let parserCache := s.cache.parserCache\n  let s' := p c { s with cache.parserCache := {} }\n  { s' with cache.parserCache := parserCache }", "start": [390, 1], "end": [397, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withResetCache", "code": "@[inherit_doc withResetCacheFn]\ndef withResetCache : Parser \u2192 Parser := withFn withResetCacheFn", "start": [399, 1], "end": [400, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.adaptUncacheableContextFn", "code": "def adaptUncacheableContextFn (f : ParserContextCore \u2192 ParserContextCore) (p : ParserFn) : ParserFn :=\n  withResetCacheFn (fun c s => p \u27e8f c.toParserContextCore\u27e9 s)", "start": [402, 1], "end": [404, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withCacheFn", "code": "def withCacheFn (parserName : Name) (p : ParserFn) : ParserFn := fun c s => Id.run do\n  let key := \u27e8c.toCacheableParserContext, parserName, s.pos\u27e9\n  if let some r := s.cache.parserCache.find? key then\n    return \u27e8s.stxStack.push r.stx, r.lhsPrec, r.newPos, s.cache, r.errorMsg\u27e9\n  let initStackSz := s.stxStack.raw.size\n  let s := withStackDrop initStackSz p c { s with lhsPrec := 0, errorMsg := none }\n  if s.stxStack.raw.size != initStackSz + 1 then\n    panic! s!\"withCacheFn: unexpected stack growth {s.stxStack.raw}\"\n  { s with cache.parserCache := s.cache.parserCache.insert key \u27e8s.stxStack.back, s.lhsPrec, s.pos, s.errorMsg\u27e9 }", "start": [406, 1], "end": [423, 113], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withCache", "code": "@[inherit_doc withCacheFn]\ndef withCache (parserName : Name) : Parser \u2192 Parser := withFn (withCacheFn parserName)", "start": [425, 1], "end": [426, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserFn.run", "code": "def ParserFn.run (p : ParserFn) (ictx : InputContext) (pmctx : ParserModuleContext) (tokens : TokenTable) (s : ParserState) : ParserState :=\n  p { pmctx with\n    prec           := 0\n    toInputContext := ictx\n    tokens\n  } s", "start": [428, 1], "end": [433, 6], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/DeclarationRange.lean", "imports": ["lake-packages/lean4/src/lean/Lean/MonadEnv.lean", "lake-packages/lean4/src/lean/Lean/ToExpr.lean", "lake-packages/lean4/src/lean/Lean/AuxRecursor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.DeclarationRange", "code": "structure DeclarationRange where\n  pos          : Position\n  \n  charUtf16    : Nat\n  endPos       : Position\n  \n  endCharUtf16 : Nat\n  deriving Inhabited, DecidableEq, Repr", "start": [12, 1], "end": [23, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.DeclarationRanges", "code": "structure DeclarationRanges where\n  range          : DeclarationRange\n  selectionRange : DeclarationRange\n  deriving Inhabited, Repr", "start": [29, 1], "end": [32, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.addBuiltinDeclarationRanges", "code": "def addBuiltinDeclarationRanges (declName : Name) (declRanges : DeclarationRanges) : IO Unit :=\n  builtinDeclRanges.modify (\u00b7.insert declName declRanges)", "start": [41, 1], "end": [42, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.addDeclarationRanges", "code": "def addDeclarationRanges [MonadEnv m] (declName : Name) (declRanges : DeclarationRanges) : m Unit :=\n  modifyEnv fun env => declRangeExt.insert env declName declRanges", "start": [44, 1], "end": [45, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.findDeclarationRangesCore?", "code": "def findDeclarationRangesCore? [Monad m] [MonadEnv m] (declName : Name) : m (Option DeclarationRanges) :=\n  return declRangeExt.find? (\u2190 getEnv) declName", "start": [47, 1], "end": [48, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.findDeclarationRanges?", "code": "def findDeclarationRanges? [Monad m] [MonadEnv m] [MonadLiftT IO m] (declName : Name) : m (Option DeclarationRanges) := do\n  let env \u2190 getEnv\n  let ranges \u2190 if isAuxRecursor env declName || isNoConfusion env declName || (\u2190 isRec declName)  then\n    findDeclarationRangesCore? declName.getPrefix\n  else\n    findDeclarationRangesCore? declName\n  match ranges with\n  | none => return (\u2190 builtinDeclRanges.get (m := IO)).find? declName\n  | some _ => return ranges", "start": [50, 1], "end": [58, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/InitAttr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.getIOTypeArg", "code": "private def getIOTypeArg : Expr \u2192 Option Expr\n  | Expr.app (Expr.const `IO _) arg => some arg\n  | _                               => none", "start": [10, 1], "end": [12, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.isUnitType", "code": "private def isUnitType : Expr \u2192 Bool\n  | Expr.const `Unit _ => true\n  | _                  => false", "start": [14, 1], "end": [16, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.isIOUnit", "code": "private def isIOUnit (type : Expr) : Bool :=\n  match getIOTypeArg type with\n  | some type => isUnitType type\n  | _ => false", "start": [18, 1], "end": [21, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.runModInit", "code": "@[extern \"lean_run_mod_init\"]\nunsafe opaque runModInit (mod : Name) : IO Bool", "start": [23, 1], "end": [28, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.runInit", "code": "@[extern \"lean_run_init\"]\nunsafe opaque runInit (env : @& Environment) (opts : @& Options) (decl initDecl : @& Name) : IO Unit", "start": [30, 1], "end": [32, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.registerInitAttrUnsafe", "code": "unsafe def registerInitAttrUnsafe (attrName : Name) (runAfterImport : Bool) (ref : Name) : IO (ParametricAttribute Name) :=\n  registerParametricAttribute {\n    ref := ref\n    name := attrName\n    descr := \"initialization procedure for global references\"\n    getParam := fun declName stx => do\n      let decl \u2190 getConstInfo declName\n      match (\u2190 Attribute.Builtin.getIdent? stx) with\n      | some initFnName =>\n        let initFnName \u2190 Elab.resolveGlobalConstNoOverloadWithInfo initFnName\n        let initDecl \u2190 getConstInfo initFnName\n        match getIOTypeArg initDecl.type with\n        | none => throwError \"initialization function '{initFnName}' must have type of the form `IO <type>`\"\n        | some initTypeArg =>\n          if decl.type == initTypeArg then pure initFnName\n          else throwError \"initialization function '{initFnName}' type mismatch\"\n      | none =>\n        if isIOUnit decl.type then pure Name.anonymous\n        else throwError \"initialization function must have type `IO Unit`\"\n    afterImport := fun entries => do\n      let ctx \u2190 read\n      if runAfterImport && (\u2190 isInitializerExecutionEnabled) then\n        for mod in ctx.env.header.moduleNames,\n            modData in ctx.env.header.moduleData,\n            modEntries in entries do\n          if (\u2190 runModInit mod) then\n            continue\n          if modEntries.isEmpty then\n            continue\n          if (\u2190 interpretedModInits.get).contains mod then\n            continue\n          interpretedModInits.modify (\u00b7.insert mod)\n          for c in modData.constNames do\n            if let some (decl, initDecl) := modEntries.binSearch (c, default) (Name.quickLt \u00b7.1 \u00b7.1) then\n              if initDecl.isAnonymous then\n                let initFn \u2190 IO.ofExcept <| ctx.env.evalConst (IO Unit) ctx.opts decl\n                initFn\n              else\n                runInit ctx.env ctx.opts decl initDecl\n  }", "start": [37, 1], "end": [87, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.registerInitAttrInner", "code": "@[implemented_by registerInitAttrUnsafe]\nprivate opaque registerInitAttrInner (attrName : Name) (runAfterImport : Bool) (ref : Name) : IO (ParametricAttribute Name)", "start": [89, 1], "end": [90, 124], "kind": "commanddeclaration"}, {"full_name": "Lean.registerInitAttr", "code": "@[inline]\ndef registerInitAttr (attrName : Name) (runAfterImport : Bool) (ref : Name := by exact decl_name%) : IO (ParametricAttribute Name) :=\n  registerInitAttrInner attrName runAfterImport ref", "start": [92, 1], "end": [94, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.getInitFnNameForCore?", "code": "def getInitFnNameForCore? (env : Environment) (attr : ParametricAttribute Name) (fn : Name) : Option Name :=\n  match attr.getParam? env fn with\n  | some Name.anonymous => none\n  | some n              => some n\n  | _                   => none", "start": [99, 1], "end": [103, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.getBuiltinInitFnNameFor?", "code": "@[export lean_get_builtin_init_fn_name_for]\ndef getBuiltinInitFnNameFor? (env : Environment) (fn : Name) : Option Name :=\n  getInitFnNameForCore? env builtinInitAttr fn", "start": [105, 1], "end": [107, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.getRegularInitFnNameFor?", "code": "@[export lean_get_regular_init_fn_name_for]\ndef getRegularInitFnNameFor? (env : Environment) (fn : Name) : Option Name :=\n  getInitFnNameForCore? env regularInitAttr fn", "start": [109, 1], "end": [111, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.getInitFnNameFor?", "code": "@[export lean_get_init_fn_name_for]\ndef getInitFnNameFor? (env : Environment) (fn : Name) : Option Name :=\n  getBuiltinInitFnNameFor? env fn <|> getRegularInitFnNameFor? env fn", "start": [113, 1], "end": [115, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.isIOUnitInitFnCore", "code": "def isIOUnitInitFnCore (env : Environment) (attr : ParametricAttribute Name) (fn : Name) : Bool :=\n  match attr.getParam? env fn with\n  | some Name.anonymous => true\n  | _ => false", "start": [117, 1], "end": [120, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.isIOUnitRegularInitFn", "code": "@[export lean_is_io_unit_regular_init_fn]\ndef isIOUnitRegularInitFn (env : Environment) (fn : Name) : Bool :=\n  isIOUnitInitFnCore env regularInitAttr fn", "start": [122, 1], "end": [124, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.isIOUnitBuiltinInitFn", "code": "@[export lean_is_io_unit_builtin_init_fn]\ndef isIOUnitBuiltinInitFn (env : Environment) (fn : Name) : Bool :=\n  isIOUnitInitFnCore env builtinInitAttr fn", "start": [126, 1], "end": [128, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.isIOUnitInitFn", "code": "def isIOUnitInitFn (env : Environment) (fn : Name) : Bool :=\n  isIOUnitBuiltinInitFn env fn || isIOUnitRegularInitFn env fn", "start": [130, 1], "end": [131, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.hasInitAttr", "code": "def hasInitAttr (env : Environment) (fn : Name) : Bool :=\n  (getInitFnNameFor? env fn).isSome", "start": [133, 1], "end": [134, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.setBuiltinInitAttr", "code": "def setBuiltinInitAttr (env : Environment) (declName : Name) (initFnName : Name := Name.anonymous) : Except String Environment :=\n  builtinInitAttr.setParam env declName initFnName", "start": [136, 1], "end": [137, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.declareBuiltin", "code": "def declareBuiltin (forDecl : Name) (value : Expr) : CoreM Unit := do\n  let name := `_regBuiltin ++ forDecl\n  let type := mkApp (mkConst `IO) (mkConst `Unit)\n  let decl := Declaration.defnDecl { name, levelParams := [], type, value, hints := ReducibilityHints.opaque,\n                                     safety := DefinitionSafety.safe }\n  match (\u2190 getEnv).addAndCompile {} decl with\n  | Except.error e => do\n    let msg \u2190 (e.toMessageData {}).toString\n    throwError \"failed to emit registration code for builtin '{forDecl}': {msg}\"\n  | Except.ok env  => IO.ofExcept (setBuiltinInitAttr env name) >>= setEnv", "start": [139, 1], "end": [149, 75], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Lean/Data/NameTrie.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ScopedEnvExtension.Entry", "code": "inductive Entry (\u03b1 : Type) where\n  | global : \u03b1 \u2192 Entry \u03b1\n  | scoped : Name \u2192 \u03b1 \u2192 Entry \u03b1", "start": [14, 1], "end": [16, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.State", "code": "structure State (\u03c3 : Type) where\n  state        : \u03c3\n  activeScopes : NameSet := {}", "start": [18, 1], "end": [20, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.ScopedEntries", "code": "structure ScopedEntries (\u03b2 : Type) where\n  map : SMap Name (PArray \u03b2) := {}\n  deriving Inhabited", "start": [22, 1], "end": [24, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.StateStack", "code": "structure StateStack (\u03b1 : Type) (\u03b2 : Type) (\u03c3 : Type) where\n  stateStack    : List (State \u03c3) := {}\n  scopedEntries : ScopedEntries \u03b2 := {}\n  newEntries    : List (Entry \u03b1) := []\n  deriving Inhabited", "start": [26, 1], "end": [30, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.Descr", "code": "structure Descr (\u03b1 : Type) (\u03b2 : Type) (\u03c3 : Type) where\n  name           : Name := by exact decl_name%\n  mkInitial      : IO \u03c3\n  ofOLeanEntry   : \u03c3 \u2192 \u03b1 \u2192 ImportM \u03b2\n  toOLeanEntry   : \u03b2 \u2192 \u03b1\n  addEntry       : \u03c3 \u2192 \u03b2 \u2192 \u03c3\n  finalizeImport : \u03c3 \u2192 \u03c3 := id", "start": [32, 1], "end": [38, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.mkInitial", "code": "def mkInitial (descr : Descr \u03b1 \u03b2 \u03c3) : IO (StateStack \u03b1 \u03b2 \u03c3) :=\n  return { stateStack := [ { state := (\u2190 descr.mkInitial ) } ] }", "start": [49, 1], "end": [50, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.ScopedEntries.insert", "code": "def ScopedEntries.insert (scopedEntries : ScopedEntries \u03b2) (ns : Name) (b : \u03b2) : ScopedEntries \u03b2 :=\n  match scopedEntries.map.find? ns with\n  | none    => { map := scopedEntries.map.insert ns <| ({} : PArray \u03b2).push b }\n  | some bs => { map := scopedEntries.map.insert ns <| bs.push b }", "start": [52, 1], "end": [55, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.addImportedFn", "code": "def addImportedFn (descr : Descr \u03b1 \u03b2 \u03c3) (as : Array (Array (Entry \u03b1))) : ImportM (StateStack \u03b1 \u03b2 \u03c3) := do\n  let mut s \u2190 descr.mkInitial\n  let mut scopedEntries : ScopedEntries \u03b2 := {}\n  for a in as do\n    for e in a do\n      match e with\n      | Entry.global a =>\n        let b \u2190 descr.ofOLeanEntry s a\n        s := descr.addEntry s b\n      | Entry.scoped ns a =>\n        let b \u2190 descr.ofOLeanEntry s a\n        scopedEntries := scopedEntries.insert ns b\n  s := descr.finalizeImport s\n  return { stateStack := [ { state := s } ], scopedEntries := scopedEntries }", "start": [57, 1], "end": [70, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.addEntryFn", "code": "def addEntryFn (descr : Descr \u03b1 \u03b2 \u03c3) (s : StateStack \u03b1 \u03b2 \u03c3) (e : Entry \u03b2) : StateStack \u03b1 \u03b2 \u03c3 :=\n  match s with\n  | { stateStack := stateStack, scopedEntries := scopedEntries, newEntries := newEntries } =>\n    match e with\n    | Entry.global b => {\n        scopedEntries := scopedEntries\n        newEntries    := (Entry.global (descr.toOLeanEntry b)) :: newEntries\n        stateStack    := stateStack.map fun s => { s with state := descr.addEntry s.state b }\n      }\n    | Entry.\u00abscoped\u00bb ns b =>\n      {\n        scopedEntries := scopedEntries.insert ns b\n        newEntries    := (Entry.\u00abscoped\u00bb ns (descr.toOLeanEntry b)) :: newEntries\n        stateStack    := stateStack.map fun s =>\n          if s.activeScopes.contains ns then\n            { s with state := descr.addEntry s.state b }\n          else\n            s\n      }", "start": [72, 1], "end": [90, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.exportEntriesFn", "code": "def exportEntriesFn (s : StateStack \u03b1 \u03b2 \u03c3) : Array (Entry \u03b1) :=\n  s.newEntries.toArray.reverse", "start": [92, 1], "end": [93, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension", "code": "structure ScopedEnvExtension (\u03b1 : Type) (\u03b2 : Type) (\u03c3 : Type) where\n  descr : Descr \u03b1 \u03b2 \u03c3\n  ext   : PersistentEnvExtension (Entry \u03b1) (Entry \u03b2) (StateStack \u03b1 \u03b2 \u03c3)\n  deriving Inhabited", "start": [99, 1], "end": [102, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.registerScopedEnvExtensionUnsafe", "code": "unsafe def registerScopedEnvExtensionUnsafe (descr : Descr \u03b1 \u03b2 \u03c3) : IO (ScopedEnvExtension \u03b1 \u03b2 \u03c3) := do\n  let ext \u2190 registerPersistentEnvExtension {\n    name            := descr.name\n    mkInitial       := mkInitial descr\n    addImportedFn   := addImportedFn descr\n    addEntryFn      := addEntryFn descr\n    exportEntriesFn := exportEntriesFn\n    statsFn         := fun s => format \"number of local entries: \" ++ format s.newEntries.length\n  }\n  let ext := { descr := descr, ext := ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3 }\n  scopedEnvExtensionsRef.modify fun exts => exts.push (unsafeCast ext)\n  return ext", "start": [106, 1], "end": [117, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.registerScopedEnvExtension", "code": "@[implemented_by registerScopedEnvExtensionUnsafe]\nopaque registerScopedEnvExtension (descr : Descr \u03b1 \u03b2 \u03c3) : IO (ScopedEnvExtension \u03b1 \u03b2 \u03c3)", "start": [119, 1], "end": [120, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.pushScope", "code": "def ScopedEnvExtension.pushScope (ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) : Environment :=\n  let s := ext.ext.getState env\n  match s.stateStack with\n  | [] => env\n  | state :: stack => ext.ext.setState env { s with stateStack := state :: state :: stack }", "start": [122, 1], "end": [126, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.popScope", "code": "def ScopedEnvExtension.popScope (ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) : Environment :=\n  let s := ext.ext.getState env\n  match s.stateStack with\n  | _      :: state\u2082 :: stack => ext.ext.setState env { s with stateStack := state\u2082 :: stack }\n  | _ => env", "start": [128, 1], "end": [132, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.addEntry", "code": "def ScopedEnvExtension.addEntry (ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) (b : \u03b2) : Environment :=\n  ext.ext.addEntry env (Entry.global b)", "start": [134, 1], "end": [135, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.addScopedEntry", "code": "def ScopedEnvExtension.addScopedEntry (ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) (namespaceName : Name) (b : \u03b2) : Environment :=\n  ext.ext.addEntry env (Entry.\u00abscoped\u00bb namespaceName b)", "start": [137, 1], "end": [138, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.addLocalEntry", "code": "def ScopedEnvExtension.addLocalEntry (ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) (b : \u03b2) : Environment :=\n  let s := ext.ext.getState env\n  match s.stateStack with\n  | [] => env\n  | top :: states =>\n    let top := { top with state := ext.descr.addEntry top.state b }\n    ext.ext.setState env { s with stateStack := top :: states }", "start": [140, 1], "end": [146, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.add", "code": "def ScopedEnvExtension.add [Monad m] [MonadResolveName m] [MonadEnv m] (ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3) (b : \u03b2) (kind := AttributeKind.global) : m Unit := do\n  match kind with\n  | AttributeKind.global => modifyEnv (ext.addEntry \u00b7 b)\n  | AttributeKind.local  => modifyEnv (ext.addLocalEntry \u00b7 b)\n  | AttributeKind.scoped => modifyEnv (ext.addScopedEntry \u00b7 (\u2190 getCurrNamespace) b)", "start": [148, 1], "end": [152, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.getState", "code": "def ScopedEnvExtension.getState [Inhabited \u03c3] (ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) : \u03c3 :=\n  match ext.ext.getState env |>.stateStack with\n  | top :: _ => top.state\n  | _        => unreachable!", "start": [154, 1], "end": [157, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.activateScoped", "code": "def ScopedEnvExtension.activateScoped (ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) (namespaceName : Name) : Environment :=\n  let s := ext.ext.getState env\n  match s.stateStack with\n  | top :: stack =>\n    if top.activeScopes.contains namespaceName then\n      env\n    else\n      let activeScopes := top.activeScopes.insert namespaceName\n      let top :=\n        match s.scopedEntries.map.find? namespaceName with\n        | none =>\n          { top with activeScopes := activeScopes }\n        | some bs => Id.run do\n          let mut state := top.state\n          for b in bs do\n            state := ext.descr.addEntry state b\n          { state := state, activeScopes := activeScopes }\n      ext.ext.setState env { s with stateStack := top :: stack }\n  | _ => env", "start": [159, 1], "end": [177, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.ScopedEnvExtension.modifyState", "code": "def ScopedEnvExtension.modifyState (ext : ScopedEnvExtension \u03b1 \u03b2 \u03c3) (env : Environment) (f : \u03c3 \u2192 \u03c3) : Environment :=\n  let s := ext.ext.getState env\n  match s.stateStack with\n  | top :: stack => ext.ext.setState env { s with stateStack := { top with state := f top.state } :: stack }\n  | _ => env", "start": [179, 1], "end": [183, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.pushScope", "code": "def pushScope [Monad m] [MonadEnv m] [MonadLiftT (ST IO.RealWorld) m] : m Unit := do\n  for ext in (\u2190 scopedEnvExtensionsRef.get) do\n    modifyEnv ext.pushScope", "start": [185, 1], "end": [187, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.popScope", "code": "def popScope [Monad m] [MonadEnv m] [MonadLiftT (ST IO.RealWorld) m] : m Unit := do\n  for ext in (\u2190 scopedEnvExtensionsRef.get) do\n    modifyEnv ext.popScope", "start": [189, 1], "end": [191, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.activateScoped", "code": "def activateScoped [Monad m] [MonadEnv m] [MonadLiftT (ST IO.RealWorld) m] (namespaceName : Name) : m Unit := do\n  for ext in (\u2190 scopedEnvExtensionsRef.get) do\n    modifyEnv (ext.activateScoped \u00b7 namespaceName)", "start": [193, 1], "end": [195, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.SimpleScopedEnvExtension", "code": "abbrev SimpleScopedEnvExtension (\u03b1 : Type) (\u03c3 : Type) := ScopedEnvExtension \u03b1 \u03b1 \u03c3", "start": [197, 1], "end": [197, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.SimpleScopedEnvExtension.Descr", "code": "structure SimpleScopedEnvExtension.Descr (\u03b1 : Type) (\u03c3 : Type) where\n  name           : Name := by exact decl_name%\n  addEntry       : \u03c3 \u2192 \u03b1 \u2192 \u03c3\n  initial        : \u03c3\n  finalizeImport : \u03c3 \u2192 \u03c3 := id", "start": [199, 1], "end": [203, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.registerSimpleScopedEnvExtension", "code": "def registerSimpleScopedEnvExtension (descr : SimpleScopedEnvExtension.Descr \u03b1 \u03c3) : IO (SimpleScopedEnvExtension \u03b1 \u03c3) := do\n  registerScopedEnvExtension {\n    name           := descr.name\n    mkInitial      := return descr.initial\n    addEntry       := descr.addEntry\n    toOLeanEntry   := id\n    ofOLeanEntry   := fun _ a => return a\n    finalizeImport := descr.finalizeImport\n  }", "start": [205, 1], "end": [213, 4], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/Basic.lean", "lake-packages/lean4/src/lean/Lean/Compiler/IR/Format.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.IR.LogEntry", "code": "inductive LogEntry where\n  | step (cls : Name) (decls : Array Decl)\n  | message (msg : Format)", "start": [12, 1], "end": [14, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.LogEntry.fmt", "code": "protected def fmt : LogEntry \u2192 Format\n  | step cls decls => Format.bracket \"[\" (format cls) \"]\" ++ decls.foldl (fun fmt decl => fmt ++ Format.line ++ format decl) Format.nil\n  | message msg    => msg", "start": [17, 1], "end": [19, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Log", "code": "abbrev Log := Array LogEntry", "start": [24, 1], "end": [24, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Log.format", "code": "def Log.format (log : Log) : Format :=\n  log.foldl (init := Format.nil) fun fmt entry =>\n    f!\"{fmt}{Format.line}{entry}\"", "start": [26, 1], "end": [28, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.Log.toString", "code": "@[export lean_ir_log_to_string]\ndef Log.toString (log : Log) : String :=\n  log.format.pretty", "start": [30, 1], "end": [32, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CompilerState", "code": "structure CompilerState where\n  env : Environment\n  log : Log := #[]", "start": [34, 1], "end": [36, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.CompilerM", "code": "abbrev CompilerM := ReaderT Options (EStateM String CompilerState)", "start": [38, 1], "end": [38, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.log", "code": "def log (entry : LogEntry) : CompilerM Unit :=\n  modify fun s => { s with log := s.log.push entry }", "start": [40, 1], "end": [41, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.tracePrefixOptionName", "code": "def tracePrefixOptionName := `trace.compiler.ir", "start": [43, 1], "end": [43, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.isLogEnabledFor", "code": "private def isLogEnabledFor (opts : Options) (optName : Name) : Bool :=\n  match opts.find optName with\n  | some (DataValue.ofBool v) => v\n  | _     => opts.getBool tracePrefixOptionName", "start": [45, 1], "end": [48, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.logDeclsAux", "code": "private def logDeclsAux (optName : Name) (cls : Name) (decls : Array Decl) : CompilerM Unit := do\n  let opts \u2190 read\n  if isLogEnabledFor opts optName then\n    log (LogEntry.step cls decls)", "start": [50, 1], "end": [53, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.logDecls", "code": "@[inline] def logDecls (cls : Name) (decl : Array Decl) : CompilerM Unit :=\n  logDeclsAux (tracePrefixOptionName ++ cls) cls decl", "start": [55, 1], "end": [56, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.logMessageIfAux", "code": "private def logMessageIfAux {\u03b1 : Type} [ToFormat \u03b1] (optName : Name) (a : \u03b1) : CompilerM Unit := do\n  let opts \u2190 read\n  if isLogEnabledFor opts optName then\n    log (LogEntry.message (format a))", "start": [58, 1], "end": [61, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.logMessageIf", "code": "@[inline] def logMessageIf {\u03b1 : Type} [ToFormat \u03b1] (cls : Name) (a : \u03b1) : CompilerM Unit :=\n  logMessageIfAux (tracePrefixOptionName ++ cls) a", "start": [63, 1], "end": [64, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.logMessage", "code": "@[inline] def logMessage {\u03b1 : Type} [ToFormat \u03b1] (a : \u03b1) : CompilerM Unit :=\n  logMessageIfAux tracePrefixOptionName a", "start": [66, 1], "end": [67, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.modifyEnv", "code": "@[inline] def modifyEnv (f : Environment \u2192 Environment) : CompilerM Unit :=\n  modify fun s => { s with env := f s.env }", "start": [69, 1], "end": [70, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.DeclMap", "code": "abbrev DeclMap := PHashMap Name Decl", "start": [72, 1], "end": [72, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.declLt", "code": "private abbrev declLt (a b : Decl) :=\n  Name.quickLt a.name b.name", "start": [74, 1], "end": [75, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.sortDecls", "code": "private abbrev sortDecls (decls : Array Decl) : Array Decl :=\n  decls.qsort declLt", "start": [77, 1], "end": [78, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.findAtSorted?", "code": "private abbrev findAtSorted? (decls : Array Decl) (declName : Name) : Option Decl :=\n  let tmpDecl := Decl.extern declName #[] default default\n  decls.binSearch tmpDecl declLt", "start": [80, 1], "end": [82, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.findEnvDecl", "code": "@[export lean_ir_find_env_decl]\ndef findEnvDecl (env : Environment) (declName : Name) : Option Decl :=\n  match env.getModuleIdxFor? declName with\n  | some modIdx => findAtSorted? (declMapExt.getModuleEntries env modIdx) declName\n  | none        => declMapExt.getState env |>.find? declName", "start": [93, 1], "end": [97, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.findDecl", "code": "def findDecl (n : Name) : CompilerM (Option Decl) :=\n  return findEnvDecl (\u2190 get).env n", "start": [99, 1], "end": [100, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.containsDecl", "code": "def containsDecl (n : Name) : CompilerM Bool :=\n  return (\u2190 findDecl n).isSome", "start": [102, 1], "end": [103, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getDecl", "code": "def getDecl (n : Name) : CompilerM Decl := do\n  let (some decl) \u2190 findDecl n | throw s!\"unknown declaration '{n}'\"\n  return decl", "start": [105, 1], "end": [107, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.addDeclAux", "code": "@[export lean_ir_add_decl]\ndef addDeclAux (env : Environment) (decl : Decl) : Environment :=\n  declMapExt.addEntry (env.addExtraName decl.name) decl", "start": [109, 1], "end": [111, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getDecls", "code": "def getDecls (env : Environment) : List Decl :=\n  declMapExt.getEntries env", "start": [113, 1], "end": [114, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getEnv", "code": "def getEnv : CompilerM Environment := do\n  let s \u2190 get; pure s.env", "start": [116, 1], "end": [117, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.addDecl", "code": "def addDecl (decl : Decl) : CompilerM Unit :=\n  modifyEnv fun env => declMapExt.addEntry (env.addExtraName decl.name) decl", "start": [119, 1], "end": [120, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.addDecls", "code": "def addDecls (decls : Array Decl) : CompilerM Unit :=\n  decls.forM addDecl", "start": [122, 1], "end": [123, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.findEnvDecl'", "code": "def findEnvDecl' (env : Environment) (n : Name) (decls : Array Decl) : Option Decl :=\n  match decls.find? (fun decl => decl.name == n) with\n  | some decl => some decl\n  | none      => findEnvDecl env n", "start": [125, 1], "end": [128, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.findDecl'", "code": "def findDecl' (n : Name) (decls : Array Decl) : CompilerM (Option Decl) :=\n  return findEnvDecl' (\u2190 get).env n decls", "start": [130, 1], "end": [131, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.containsDecl'", "code": "def containsDecl' (n : Name) (decls : Array Decl) : CompilerM Bool := do\n  if decls.any fun decl => decl.name == n then\n    return true\n  else\n    containsDecl n", "start": [133, 1], "end": [137, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getDecl'", "code": "def getDecl' (n : Name) (decls : Array Decl) : CompilerM Decl := do\n  let (some decl) \u2190 findDecl' n decls | throw s!\"unknown declaration '{n}'\"\n  return decl", "start": [139, 1], "end": [141, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.IR.getSorryDep", "code": "@[export lean_decl_get_sorry_dep]\ndef getSorryDep (env : Environment) (declName : Name) : Option Name :=\n  match findEnvDecl env declName with\n  | some (.fdecl (info := { sorryDep? := dep?, .. }) ..) => dep?\n  | _ => none", "start": [143, 1], "end": [147, 14], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Types.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.dbgTraceStateFn", "code": "def dbgTraceStateFn (label : String) (p : ParserFn) : ParserFn :=\n  fun c s =>\n    let sz := s.stxStack.size\n    let s' := p c s\n    dbg_trace \"{label}\n  pos: {s'.pos}\n  err: {s'.errorMsg}\n  out: {s'.stxStack.extract sz s'.stxStack.size}\"\n    s'", "start": [61, 1], "end": [69, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.dbgTraceState", "code": "def dbgTraceState (label : String) : Parser \u2192 Parser := withFn (dbgTraceStateFn label)", "start": [71, 1], "end": [71, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.epsilonInfo", "code": "@[noinline]def epsilonInfo : ParserInfo :=\n  { firstTokens := FirstTokens.epsilon }", "start": [73, 1], "end": [74, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkStackTopFn", "code": "def checkStackTopFn (p : Syntax \u2192 Bool) (msg : String) : ParserFn := fun _ s =>\n  if p s.stxStack.back then s\n  else s.mkUnexpectedError msg", "start": [76, 1], "end": [78, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkStackTop", "code": "def checkStackTop (p : Syntax \u2192 Bool) (msg : String) : Parser := {\n  info := epsilonInfo,\n  fn   := checkStackTopFn p msg\n}", "start": [80, 1], "end": [83, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.andthenFn", "code": "def andthenFn (p q : ParserFn) : ParserFn := fun c s =>\n  let s := p c s\n  if s.hasError then s else q c s", "start": [85, 1], "end": [87, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.andthenInfo", "code": "@[noinline] def andthenInfo (p q : ParserInfo) : ParserInfo := {\n  collectTokens := p.collectTokens \u2218 q.collectTokens,\n  collectKinds  := p.collectKinds \u2218 q.collectKinds,\n  firstTokens   := p.firstTokens.seq q.firstTokens\n}", "start": [89, 1], "end": [93, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.andthen", "code": "def andthen (p q : Parser) : Parser where\n  info := andthenInfo p.info q.info\n  fn   := andthenFn p.fn q.fn", "start": [95, 1], "end": [103, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nodeFn", "code": "def nodeFn (n : SyntaxNodeKind) (p : ParserFn) : ParserFn := fun c s =>\n  let iniSz := s.stackSize\n  let s     := p c s\n  s.mkNode n iniSz", "start": [108, 1], "end": [111, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.trailingNodeFn", "code": "def trailingNodeFn (n : SyntaxNodeKind) (p : ParserFn) : ParserFn := fun c s =>\n  let iniSz := s.stackSize\n  let s     := p c s\n  s.mkTrailingNode n iniSz", "start": [113, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nodeInfo", "code": "@[noinline] def nodeInfo (n : SyntaxNodeKind) (p : ParserInfo) : ParserInfo := {\n  collectTokens := p.collectTokens,\n  collectKinds  := fun s => (p.collectKinds s).insert n,\n  firstTokens   := p.firstTokens\n}", "start": [118, 1], "end": [122, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.node", "code": "def node (n : SyntaxNodeKind) (p : Parser) : Parser := {\n  info := nodeInfo n p.info,\n  fn   := nodeFn n p.fn\n}", "start": [124, 1], "end": [127, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.errorFn", "code": "def errorFn (msg : String) : ParserFn := fun _ s =>\n  s.mkUnexpectedError msg", "start": [129, 1], "end": [130, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.error", "code": "def error (msg : String) : Parser := {\n  info := epsilonInfo,\n  fn   := errorFn msg\n}", "start": [132, 1], "end": [135, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.errorAtSavedPosFn", "code": "def errorAtSavedPosFn (msg : String) (delta : Bool) : ParserFn := fun c s =>\n  match c.savedPos? with\n  | none     => s\n  | some pos =>\n    let pos := if delta then c.input.next pos else pos\n    s.mkUnexpectedErrorAt msg pos", "start": [137, 1], "end": [142, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.errorAtSavedPos", "code": "def errorAtSavedPos (msg : String) (delta : Bool) : Parser := {\n  fn := errorAtSavedPosFn msg delta\n}", "start": [144, 1], "end": [149, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkPrecFn", "code": "def checkPrecFn (prec : Nat) : ParserFn := fun c s =>\n  if c.prec <= prec then s\n  else s.mkUnexpectedError \"unexpected token at this precedence level; consider parenthesizing the term\"", "start": [151, 1], "end": [154, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkPrec", "code": "def checkPrec (prec : Nat) : Parser := {\n  info := epsilonInfo\n  fn   := checkPrecFn prec\n}", "start": [156, 1], "end": [159, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkLhsPrecFn", "code": "def checkLhsPrecFn (prec : Nat) : ParserFn := fun _ s =>\n  if s.lhsPrec >= prec then s\n  else s.mkUnexpectedError \"unexpected token at this precedence level; consider parenthesizing the term\"", "start": [161, 1], "end": [164, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkLhsPrec", "code": "def checkLhsPrec (prec : Nat) : Parser := {\n  info := epsilonInfo\n  fn   := checkLhsPrecFn prec\n}", "start": [166, 1], "end": [169, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.setLhsPrecFn", "code": "def setLhsPrecFn (prec : Nat) : ParserFn := fun _ s =>\n  if s.hasError then s\n  else { s with lhsPrec := prec }", "start": [171, 1], "end": [173, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.setLhsPrec", "code": "def setLhsPrec (prec : Nat) : Parser := {\n  info := epsilonInfo\n  fn   := setLhsPrecFn prec\n}", "start": [175, 1], "end": [178, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addQuotDepth", "code": "private def addQuotDepth (i : Int) (p : Parser) : Parser :=\n  adaptCacheableContext (fun c => { c with quotDepth := c.quotDepth + i |>.toNat }) p", "start": [180, 1], "end": [181, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.incQuotDepth", "code": "def incQuotDepth (p : Parser) : Parser := addQuotDepth 1 p", "start": [183, 1], "end": [183, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.decQuotDepth", "code": "def decQuotDepth (p : Parser) : Parser := addQuotDepth (-1) p", "start": [185, 1], "end": [185, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.suppressInsideQuot", "code": "def suppressInsideQuot : Parser \u2192 Parser :=\n  adaptCacheableContext fun c =>\n    if c.quotDepth == 0 then { c with suppressInsideQuot := true } else c", "start": [187, 1], "end": [190, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.leadingNode", "code": "def leadingNode (n : SyntaxNodeKind) (prec : Nat) (p : Parser) : Parser :=\n  checkPrec prec >> node n p >> setLhsPrec prec", "start": [192, 1], "end": [193, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.trailingNodeAux", "code": "def trailingNodeAux (n : SyntaxNodeKind) (p : Parser) : TrailingParser := {\n  info := nodeInfo n p.info\n  fn   := trailingNodeFn n p.fn\n}", "start": [195, 1], "end": [198, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.trailingNode", "code": "def trailingNode (n : SyntaxNodeKind) (prec lhsPrec : Nat) (p : Parser) : TrailingParser :=\n  checkPrec prec >> checkLhsPrec lhsPrec >> trailingNodeAux n p >> setLhsPrec prec", "start": [200, 1], "end": [201, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mergeOrElseErrors", "code": "def mergeOrElseErrors (s : ParserState) (error1 : Error) (iniPos : String.Pos) (mergeErrors : Bool) : ParserState :=\n  match s with\n  | \u27e8stack, lhsPrec, pos, cache, some error2\u27e9 =>\n    if pos == iniPos then \u27e8stack, lhsPrec, pos, cache, some (if mergeErrors then error1.merge error2 else error2)\u27e9\n    else s\n  | other => other", "start": [203, 1], "end": [208, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.OrElseOnAntiquotBehavior", "code": "inductive OrElseOnAntiquotBehavior where\n  | acceptLhs    | takeLongest  | merge        deriving BEq", "start": [211, 1], "end": [215, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.orelseFnCore", "code": "def orelseFnCore (p q : ParserFn) (antiquotBehavior := OrElseOnAntiquotBehavior.merge) : ParserFn := fun c s => Id.run do\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let mut s  := p c s\n  match s.errorMsg with\n  | some errorMsg =>\n    if s.pos == iniPos then\n      mergeOrElseErrors (q c (s.restore iniSz iniPos)) errorMsg iniPos true\n    else\n      s\n  | none =>\n    let pBack := s.stxStack.back\n    if antiquotBehavior == .acceptLhs || s.stackSize != iniSz + 1 || !pBack.isAntiquots then\n      return s\n    let pPos := s.pos\n    s := s.restore iniSz iniPos\n    s := q c s\n    if s.hasError then\n      return s.restore iniSz pPos |>.pushSyntax pBack\n    if s.pos > pPos then\n      return s\n    if s.pos < pPos || antiquotBehavior != .merge || s.stackSize != iniSz + 1 || !s.stxStack.back.isAntiquots then\n      return s.restore iniSz pPos |>.pushSyntax pBack\n    let qBack := s.stxStack.back\n    s := s.popSyntax\n    let pushAntiquots stx s :=\n      if stx.isOfKind choiceKind then\n        { s with stxStack := s.stxStack ++ stx.getArgs }\n      else\n        s.pushSyntax stx\n    s := pushAntiquots pBack s\n    s := pushAntiquots qBack s\n    s.mkNode choiceKind iniSz", "start": [217, 1], "end": [255, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.orelseFn", "code": "def orelseFn (p q : ParserFn) : ParserFn :=\n  orelseFnCore p q", "start": [257, 1], "end": [258, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.orelseInfo", "code": "@[noinline] def orelseInfo (p q : ParserInfo) : ParserInfo := {\n  collectTokens := p.collectTokens \u2218 q.collectTokens\n  collectKinds  := p.collectKinds \u2218 q.collectKinds\n  firstTokens   := p.firstTokens.merge q.firstTokens\n}", "start": [260, 1], "end": [264, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.orelse", "code": "def orelse (p q : Parser) : Parser where\n  info := orelseInfo p.info q.info\n  fn   := orelseFn p.fn q.fn", "start": [266, 1], "end": [274, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.noFirstTokenInfo", "code": "@[noinline] def noFirstTokenInfo (info : ParserInfo) : ParserInfo := {\n  collectTokens := info.collectTokens\n  collectKinds  := info.collectKinds\n}", "start": [279, 1], "end": [282, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.atomicFn", "code": "def atomicFn (p : ParserFn) : ParserFn := fun c s =>\n  let iniPos := s.pos\n  match p c s with\n  | \u27e8stack, lhsPrec, _, cache, some msg\u27e9 => \u27e8stack, lhsPrec, iniPos, cache, some msg\u27e9\n  | other                       => other", "start": [284, 1], "end": [288, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.atomic", "code": "def atomic : Parser \u2192 Parser := withFn atomicFn", "start": [290, 1], "end": [296, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.optionalFn", "code": "def optionalFn (p : ParserFn) : ParserFn := fun c s =>\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let s      := p c s\n  let s      := if s.hasError && s.pos == iniPos then s.restore iniSz iniPos else s\n  s.mkNode nullKind iniSz", "start": [298, 1], "end": [303, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.optionaInfo", "code": "@[noinline] def optionaInfo (p : ParserInfo) : ParserInfo := {\n  collectTokens := p.collectTokens\n  collectKinds  := p.collectKinds\n  firstTokens   := p.firstTokens.toOptional\n}", "start": [305, 1], "end": [309, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.optionalNoAntiquot", "code": "def optionalNoAntiquot (p : Parser) : Parser := {\n  info := optionaInfo p.info\n  fn   := optionalFn p.fn\n}", "start": [311, 1], "end": [314, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.lookaheadFn", "code": "def lookaheadFn (p : ParserFn) : ParserFn := fun c s =>\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let s      := p c s\n  if s.hasError then s else s.restore iniSz iniPos", "start": [316, 1], "end": [320, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.lookahead", "code": "def lookahead : Parser \u2192 Parser := withFn lookaheadFn", "start": [322, 1], "end": [327, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.notFollowedByFn", "code": "def notFollowedByFn (p : ParserFn) (msg : String) : ParserFn := fun c s =>\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let s      := p c s\n  if s.hasError then\n    s.restore iniSz iniPos\n  else\n    let s := s.restore iniSz iniPos\n    s.mkUnexpectedError s!\"unexpected {msg}\"", "start": [329, 1], "end": [337, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.notFollowedBy", "code": "def notFollowedBy (p : Parser) (msg : String) : Parser where\n  fn := notFollowedByFn p.fn msg", "start": [339, 1], "end": [344, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.manyAux", "code": "partial def manyAux (p : ParserFn) : ParserFn := fun c s => Id.run do\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let mut s  := p c s\n  if s.hasError then\n    return if iniPos == s.pos then s.restore iniSz iniPos else s\n  if iniPos == s.pos then\n    return s.mkUnexpectedError \"invalid 'many' parser combinator application, parser did not consume anything\"\n  if s.stackSize > iniSz + 1 then\n    s := s.mkNode nullKind iniSz\n  manyAux p c s", "start": [346, 1], "end": [356, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.manyFn", "code": "def manyFn (p : ParserFn) : ParserFn := fun c s =>\n  let iniSz  := s.stackSize\n  let s := manyAux p c s\n  s.mkNode nullKind iniSz", "start": [358, 1], "end": [361, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.manyNoAntiquot", "code": "def manyNoAntiquot (p : Parser) : Parser := {\n  info := noFirstTokenInfo p.info\n  fn   := manyFn p.fn\n}", "start": [363, 1], "end": [366, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.many1Fn", "code": "def many1Fn (p : ParserFn) : ParserFn := fun c s =>\n  let iniSz  := s.stackSize\n  let s := andthenFn p (manyAux p) c s\n  s.mkNode nullKind iniSz", "start": [368, 1], "end": [371, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.many1NoAntiquot", "code": "def many1NoAntiquot : Parser \u2192 Parser := withFn many1Fn", "start": [373, 1], "end": [373, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepByFnAux", "code": "private partial def sepByFnAux (p : ParserFn) (sep : ParserFn) (allowTrailingSep : Bool) (iniSz : Nat) (pOpt : Bool) : ParserFn :=\n  let rec parse (pOpt : Bool) (c s) := Id.run do\n    let sz  := s.stackSize\n    let pos := s.pos\n    let mut s := p c s\n    if s.hasError then\n      if s.pos > pos then\n        return s.mkNode nullKind iniSz\n      else if pOpt then\n        s := s.restore sz pos\n        return s.mkNode nullKind iniSz\n      else\n        s := s.pushSyntax Syntax.missing\n        return s.mkNode nullKind iniSz\n    if s.stackSize > sz + 1 then\n      s := s.mkNode nullKind sz\n    let sz  := s.stackSize\n    let pos := s.pos\n    s := sep c s\n    if s.hasError then\n      s := s.restore sz pos\n      return s.mkNode nullKind iniSz\n    if s.stackSize > sz + 1 then\n      s := s.mkNode nullKind sz\n    parse allowTrailingSep c s\n  parse pOpt", "start": [375, 1], "end": [401, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepByFn", "code": "def sepByFn (allowTrailingSep : Bool) (p : ParserFn) (sep : ParserFn) : ParserFn := fun c s =>\n  let iniSz := s.stackSize\n  sepByFnAux p sep allowTrailingSep iniSz true c s", "start": [403, 1], "end": [405, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepBy1Fn", "code": "def sepBy1Fn (allowTrailingSep : Bool) (p : ParserFn) (sep : ParserFn) : ParserFn := fun c s =>\n  let iniSz := s.stackSize\n  sepByFnAux p sep allowTrailingSep iniSz false c s", "start": [407, 1], "end": [409, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepByInfo", "code": "@[noinline] def sepByInfo (p sep : ParserInfo) : ParserInfo := {\n  collectTokens := p.collectTokens \u2218 sep.collectTokens\n  collectKinds  := p.collectKinds \u2218 sep.collectKinds\n}", "start": [411, 1], "end": [414, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepBy1Info", "code": "@[noinline] def sepBy1Info (p sep : ParserInfo) : ParserInfo := {\n  collectTokens := p.collectTokens \u2218 sep.collectTokens\n  collectKinds  := p.collectKinds \u2218 sep.collectKinds\n  firstTokens   := p.firstTokens\n}", "start": [416, 1], "end": [420, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepByNoAntiquot", "code": "def sepByNoAntiquot (p sep : Parser) (allowTrailingSep : Bool := false) : Parser := {\n  info := sepByInfo p.info sep.info\n  fn   := sepByFn allowTrailingSep p.fn sep.fn\n}", "start": [422, 1], "end": [425, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepBy1NoAntiquot", "code": "def sepBy1NoAntiquot (p sep : Parser) (allowTrailingSep : Bool := false) : Parser := {\n  info := sepBy1Info p.info sep.info\n  fn   := sepBy1Fn allowTrailingSep p.fn sep.fn\n}", "start": [427, 1], "end": [430, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withResultOfFn", "code": "def withResultOfFn (p : ParserFn) (f : Syntax \u2192 Syntax) : ParserFn := fun c s =>\n  let s := p c s\n  if s.hasError then s\n  else\n    let stx := s.stxStack.back\n    s.popSyntax.pushSyntax (f stx)", "start": [432, 1], "end": [438, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withResultOfInfo", "code": "@[noinline] def withResultOfInfo (p : ParserInfo) : ParserInfo := {\n  collectTokens := p.collectTokens\n  collectKinds  := p.collectKinds\n}", "start": [440, 1], "end": [443, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withResultOf", "code": "def withResultOf (p : Parser) (f : Syntax \u2192 Syntax) : Parser := {\n  info := withResultOfInfo p.info\n  fn   := withResultOfFn p.fn f\n}", "start": [445, 1], "end": [448, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.many1Unbox", "code": "def many1Unbox (p : Parser) : Parser :=\n  withResultOf (many1NoAntiquot p) fun stx => if stx.getNumArgs == 1 then stx.getArg 0 else stx", "start": [450, 1], "end": [451, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.satisfyFn", "code": "partial def satisfyFn (p : Char \u2192 Bool) (errorMsg : String := \"unexpected character\") : ParserFn := fun c s =>\n  let i := s.pos\n  if h : c.input.atEnd i then s.mkEOIError\n  else if p (c.input.get' i h) then s.next' c.input i h\n  else s.mkUnexpectedError errorMsg", "start": [453, 1], "end": [457, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.takeUntilFn", "code": "partial def takeUntilFn (p : Char \u2192 Bool) : ParserFn := fun c s =>\n  let i := s.pos\n  if h : c.input.atEnd i then s\n  else if p (c.input.get' i h) then s\n  else takeUntilFn p c (s.next' c.input i h)", "start": [459, 1], "end": [463, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.takeWhileFn", "code": "def takeWhileFn (p : Char \u2192 Bool) : ParserFn :=\n  takeUntilFn (fun c => !p c)", "start": [465, 1], "end": [466, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.takeWhile1Fn", "code": "def takeWhile1Fn (p : Char \u2192 Bool) (errorMsg : String) : ParserFn :=\n  andthenFn (satisfyFn p errorMsg) (takeWhileFn p)", "start": [468, 1], "end": [469, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.finishCommentBlock", "code": "partial def finishCommentBlock (nesting : Nat) : ParserFn := fun c s =>\n  let input := c.input\n  let i     := s.pos\n  if h : input.atEnd i then eoi s\n  else\n    let curr := input.get' i h\n    let i    := input.next' i h\n    if curr == '-' then\n      if h : input.atEnd i then eoi s\n      else\n        let curr := input.get' i h\n        if curr == '/' then if nesting == 1 then s.next' input i h\n          else finishCommentBlock (nesting-1) c (s.next' input i h)\n        else\n          finishCommentBlock nesting c (s.setPos i)\n    else if curr == '/' then\n      if h : input.atEnd i then eoi s\n      else\n        let curr := input.get' i h\n        if curr == '-' then finishCommentBlock (nesting+1) c (s.next' input i h)\n        else finishCommentBlock nesting c (s.setPos i)\n    else finishCommentBlock nesting c (s.setPos i)\nwhere\n  eoi s := s.mkUnexpectedError (pushMissing := pushMissingOnError) \"unterminated comment\"", "start": [472, 1], "end": [496, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.whitespace", "code": "partial def whitespace : ParserFn := fun c s =>\n  let input := c.input\n  let i     := s.pos\n  if h : input.atEnd i then s\n  else\n    let curr := input.get' i h\n    if curr == '\\t' then\n      s.mkUnexpectedError (pushMissing := false) \"tabs are not allowed; please configure your editor to expand them\"\n    else if curr.isWhitespace then whitespace c (s.next' input i h)\n    else if curr == '-' then\n      let i    := input.next' i h\n      let curr := input.get i\n      if curr == '-' then andthenFn (takeUntilFn (fun c => c = '\\n')) whitespace c (s.next input i)\n      else s\n    else if curr == '/' then\n      let i        := input.next' i h\n      let curr     := input.get i\n      if curr == '-' then\n        let i    := input.next i\n        let curr := input.get i\n        if curr == '-' || curr == '!' then s else andthenFn (finishCommentBlock (pushMissingOnError := false) 1) whitespace c (s.next input i)\n      else s\n    else s", "start": [498, 1], "end": [522, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkEmptySubstringAt", "code": "def mkEmptySubstringAt (s : String) (p : String.Pos) : Substring := {\n  str := s, startPos := p, stopPos := p\n}", "start": [524, 1], "end": [526, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.rawAux", "code": "private def rawAux (startPos : String.Pos) (trailingWs : Bool) : ParserFn := fun c s =>\n  let input   := c.input\n  let stopPos := s.pos\n  let leading := mkEmptySubstringAt input startPos\n  let val     := input.extract startPos stopPos\n  if trailingWs then\n    let s        := whitespace c s\n    let stopPos' := s.pos\n    let trailing := { str := input, startPos := stopPos, stopPos := stopPos' : Substring }\n    let atom     := mkAtom (SourceInfo.original leading startPos trailing (startPos + val)) val\n    s.pushSyntax atom\n  else\n    let trailing := mkEmptySubstringAt input stopPos\n    let atom     := mkAtom (SourceInfo.original leading startPos trailing (startPos + val)) val\n    s.pushSyntax atom", "start": [528, 1], "end": [542, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.rawFn", "code": "def rawFn (p : ParserFn) (trailingWs := false) : ParserFn := fun c s =>\n  let startPos := s.pos\n  let s := p c s\n  if s.hasError then s else rawAux startPos trailingWs c s", "start": [544, 1], "end": [548, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.chFn", "code": "def chFn (c : Char) (trailingWs := false) : ParserFn :=\n  rawFn (satisfyFn (fun d => c == d) (\"'\" ++ toString c ++ \"'\")) trailingWs", "start": [550, 1], "end": [551, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.rawCh", "code": "def rawCh (c : Char) (trailingWs := false) : Parser := {\n  fn := chFn c trailingWs\n}", "start": [553, 1], "end": [555, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.hexDigitFn", "code": "def hexDigitFn : ParserFn := fun c s =>\n  let input := c.input\n  let i     := s.pos\n  if h : input.atEnd i then s.mkEOIError\n  else\n    let curr := input.get' i h\n    let i    := input.next' i h\n    if curr.isDigit || ('a' <= curr && curr <= 'f') || ('A' <= curr && curr <= 'F') then s.setPos i\n    else s.mkUnexpectedError \"invalid hexadecimal numeral\"", "start": [557, 1], "end": [565, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.quotedCharCoreFn", "code": "def quotedCharCoreFn (isQuotable : Char \u2192 Bool) : ParserFn := fun c s =>\n  let input := c.input\n  let i     := s.pos\n  if h : input.atEnd i then s.mkEOIError\n  else\n    let curr := input.get' i h\n    if isQuotable curr then\n      s.next' input i h\n    else if curr == 'x' then\n      andthenFn hexDigitFn hexDigitFn c (s.next' input i h)\n    else if curr == 'u' then\n      andthenFn hexDigitFn (andthenFn hexDigitFn (andthenFn hexDigitFn hexDigitFn)) c (s.next' input i h)\n    else\n      s.mkUnexpectedError \"invalid escape sequence\"", "start": [567, 1], "end": [580, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.isQuotableCharDefault", "code": "def isQuotableCharDefault (c : Char) : Bool :=\n  c == '\\\\' || c == '\\\"' || c == '\\'' || c == 'r' || c == 'n' || c == 't'", "start": [582, 1], "end": [583, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.quotedCharFn", "code": "def quotedCharFn : ParserFn :=\n  quotedCharCoreFn isQuotableCharDefault", "start": [585, 1], "end": [586, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkNodeToken", "code": "def mkNodeToken (n : SyntaxNodeKind) (startPos : String.Pos) : ParserFn := fun c s => Id.run do\n  if s.hasError then\n    return s\n  let input     := c.input\n  let stopPos   := s.pos\n  let leading   := mkEmptySubstringAt input startPos\n  let val       := input.extract startPos stopPos\n  let s         := whitespace c s\n  let wsStopPos := s.pos\n  let trailing  := { str := input, startPos := stopPos, stopPos := wsStopPos : Substring }\n  let info      := SourceInfo.original leading startPos trailing stopPos\n  s.pushSyntax (Syntax.mkLit n val info)", "start": [588, 1], "end": [600, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.charLitFnAux", "code": "def charLitFnAux (startPos : String.Pos) : ParserFn := fun c s =>\n  let input := c.input\n  let i     := s.pos\n  if h : input.atEnd i then s.mkEOIError\n  else\n    let curr := input.get' i h\n    let s    := s.setPos (input.next' i h)\n    let s    := if curr == '\\\\' then quotedCharFn c s else s\n    if s.hasError then s\n    else\n      let i    := s.pos\n      let curr := input.get i\n      let s    := s.setPos (input.next i)\n      if curr == '\\'' then mkNodeToken charLitKind startPos c s\n      else s.mkUnexpectedError \"missing end of character literal\"", "start": [602, 1], "end": [616, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.strLitFnAux", "code": "partial def strLitFnAux (startPos : String.Pos) : ParserFn := fun c s =>\n  let input := c.input\n  let i     := s.pos\n  if h : input.atEnd i then s.mkUnexpectedErrorAt \"unterminated string literal\" startPos\n  else\n    let curr := input.get' i h\n    let s    := s.setPos (input.next' i h)\n    if curr == '\\\"' then\n      mkNodeToken strLitKind startPos c s\n    else if curr == '\\\\' then andthenFn quotedCharFn (strLitFnAux startPos) c s\n    else strLitFnAux startPos c s", "start": [618, 1], "end": [628, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.decimalNumberFn", "code": "def decimalNumberFn (startPos : String.Pos) (c : ParserContext) : ParserState \u2192 ParserState := fun s =>\n  let s     := takeWhileFn (fun c => c.isDigit) c s\n  let input := c.input\n  let i     := s.pos\n  let curr  := input.get i\n  if curr == '.' || curr == 'e' || curr == 'E' then\n    let s := parseOptDot s\n    let s := parseOptExp s\n    mkNodeToken scientificLitKind startPos c s\n  else\n    mkNodeToken numLitKind startPos c s\nwhere\n  parseOptDot s :=\n    let input := c.input\n    let i     := s.pos\n    let curr  := input.get i\n    if curr == '.' then\n      let i    := input.next i\n      let curr := input.get i\n      if curr.isDigit then\n        takeWhileFn (fun c => c.isDigit) c (s.setPos i)\n      else\n        s.setPos i\n    else\n      s\n\n  parseOptExp s :=\n    let input := c.input\n    let i     := s.pos\n    let curr  := input.get i\n    if curr == 'e' || curr == 'E' then\n      let i    := input.next i\n      let i    := if input.get i == '-' || input.get i == '+' then input.next i else i\n      let curr := input.get i\n      if curr.isDigit then\n        takeWhileFn (fun c => c.isDigit) c (s.setPos i)\n      else\n        s.mkUnexpectedError \"missing exponent digits in scientific literal\"\n    else\n      s", "start": [630, 1], "end": [669, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.binNumberFn", "code": "def binNumberFn (startPos : String.Pos) : ParserFn := fun c s =>\n  let s := takeWhile1Fn (fun c => c == '0' || c == '1') \"binary number\" c s\n  mkNodeToken numLitKind startPos c s", "start": [671, 1], "end": [673, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.octalNumberFn", "code": "def octalNumberFn (startPos : String.Pos) : ParserFn := fun c s =>\n  let s := takeWhile1Fn (fun c => '0' \u2264 c && c \u2264 '7') \"octal number\" c s\n  mkNodeToken numLitKind startPos c s", "start": [675, 1], "end": [677, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.hexNumberFn", "code": "def hexNumberFn (startPos : String.Pos) : ParserFn := fun c s =>\n  let s := takeWhile1Fn (fun c => ('0' \u2264 c && c \u2264 '9') || ('a' \u2264 c && c \u2264 'f') || ('A' \u2264 c && c \u2264 'F')) \"hexadecimal number\" c s\n  mkNodeToken numLitKind startPos c s", "start": [679, 1], "end": [681, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.numberFnAux", "code": "def numberFnAux : ParserFn := fun c s =>\n  let input    := c.input\n  let startPos := s.pos\n  if h : input.atEnd startPos then s.mkEOIError\n  else\n    let curr := input.get' startPos h\n    if curr == '0' then\n      let i    := input.next' startPos h\n      let curr := input.get i\n      if curr == 'b' || curr == 'B' then\n        binNumberFn startPos c (s.next input i)\n      else if curr == 'o' || curr == 'O' then\n        octalNumberFn startPos c (s.next input i)\n      else if curr == 'x' || curr == 'X' then\n        hexNumberFn startPos c (s.next input i)\n      else\n        decimalNumberFn startPos c (s.setPos i)\n    else if curr.isDigit then\n      decimalNumberFn startPos c (s.next input startPos)\n    else\n      s.mkError \"numeral\"", "start": [683, 1], "end": [703, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.isIdCont", "code": "def isIdCont : String \u2192 ParserState \u2192 Bool := fun input s =>\n  let i    := s.pos\n  let curr := input.get i\n  if curr == '.' then\n    let i := input.next i\n    if input.atEnd i then\n      false\n    else\n      let curr := input.get i\n      isIdFirst curr || isIdBeginEscape curr\n  else\n    false", "start": [705, 1], "end": [716, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.isToken", "code": "private def isToken (idStartPos idStopPos : String.Pos) (tk : Option Token) : Bool :=\n  match tk with\n  | none    => false\n  | some tk =>\n     tk.endPos \u2265 idStopPos - idStartPos", "start": [718, 1], "end": [724, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkTokenAndFixPos", "code": "def mkTokenAndFixPos (startPos : String.Pos) (tk : Option Token) : ParserFn := fun c s =>\n  match tk with\n  | none    => s.mkErrorAt \"token\" startPos\n  | some tk =>\n    if c.forbiddenTk? == some tk then\n      s.mkErrorAt \"forbidden token\" startPos\n    else\n      let input     := c.input\n      let leading   := mkEmptySubstringAt input startPos\n      let stopPos   := startPos + tk\n      let s         := s.setPos stopPos\n      let s         := whitespace c s\n      let wsStopPos := s.pos\n      let trailing  := { str := input, startPos := stopPos, stopPos := wsStopPos : Substring }\n      let atom      := mkAtom (SourceInfo.original leading startPos trailing stopPos) tk\n      s.pushSyntax atom", "start": [727, 1], "end": [742, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkIdResult", "code": "def mkIdResult (startPos : String.Pos) (tk : Option Token) (val : Name) : ParserFn := fun c s =>\n  let stopPos           := s.pos\n  if isToken startPos stopPos tk then\n    mkTokenAndFixPos startPos tk c s\n  else\n    let input           := c.input\n    let rawVal          := { str := input, startPos := startPos, stopPos := stopPos  : Substring }\n    let s               := whitespace c s\n    let trailingStopPos := s.pos\n    let leading         := mkEmptySubstringAt input startPos\n    let trailing        := { str := input, startPos := stopPos, stopPos := trailingStopPos : Substring }\n    let info            := SourceInfo.original leading startPos trailing stopPos\n    let atom            := mkIdent info rawVal val\n    s.pushSyntax atom", "start": [744, 1], "end": [757, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.identFnAux", "code": "partial def identFnAux (startPos : String.Pos) (tk : Option Token) (r : Name) : ParserFn :=\n  let rec parse (r : Name) (c s) :=\n    let input := c.input\n    let i     := s.pos\n    if h : input.atEnd i then\n      s.mkEOIError\n    else\n      let curr := input.get' i h\n      if isIdBeginEscape curr then\n        let startPart := input.next' i h\n        let s         := takeUntilFn isIdEndEscape c (s.setPos startPart)\n        if h : input.atEnd s.pos then\n          s.mkUnexpectedErrorAt \"unterminated identifier escape\" startPart\n        else\n          let stopPart  := s.pos\n          let s         := s.next' c.input s.pos h\n          let r := .str r (input.extract startPart stopPart)\n          if isIdCont input s then\n            let s := s.next input s.pos\n            parse r c s\n          else\n            mkIdResult startPos tk r c s\n      else if isIdFirst curr then\n        let startPart := i\n        let s         := takeWhileFn isIdRest c (s.next input i)\n        let stopPart  := s.pos\n        let r := .str r (input.extract startPart stopPart)\n        if isIdCont input s then\n          let s := s.next input s.pos\n          parse r c s\n        else\n          mkIdResult startPos tk r c s\n      else\n        mkTokenAndFixPos startPos tk c s\n  parse r", "start": [759, 1], "end": [793, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.isIdFirstOrBeginEscape", "code": "private def isIdFirstOrBeginEscape (c : Char) : Bool :=\n  isIdFirst c || isIdBeginEscape c", "start": [795, 1], "end": [796, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nameLitAux", "code": "private def nameLitAux (startPos : String.Pos) : ParserFn := fun c s =>\n  let input := c.input\n  let s     := identFnAux startPos none .anonymous c (s.next input startPos)\n  if s.hasError then\n    s\n  else\n    let stx := s.stxStack.back\n    match stx with\n    | .ident info rawStr _ _ =>\n      let s := s.popSyntax\n      s.pushSyntax (Syntax.mkNameLit rawStr.toString info)\n    | _ => s.mkError \"invalid Name literal\"", "start": [798, 1], "end": [809, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.tokenFnAux", "code": "private def tokenFnAux : ParserFn := fun c s =>\n  let input := c.input\n  let i     := s.pos\n  let curr  := input.get i\n  if curr == '\\\"' then\n    strLitFnAux i c (s.next input i)\n  else if curr == '\\'' && getNext input i != '\\'' then\n    charLitFnAux i c (s.next input i)\n  else if curr.isDigit then\n    numberFnAux c s\n  else if curr == '`' && isIdFirstOrBeginEscape (getNext input i) then\n    nameLitAux i c s\n  else\n    let tk := c.tokens.matchPrefix input i\n    identFnAux i tk .anonymous c s", "start": [811, 1], "end": [825, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.updateTokenCache", "code": "private def updateTokenCache (startPos : String.Pos) (s : ParserState) : ParserState :=\n  match s with\n  | \u27e8stack, lhsPrec, pos, \u27e8_, catCache\u27e9, none\u27e9 =>\n    if stack.size == 0 then s\n    else\n      let tk := stack.back\n      \u27e8stack, lhsPrec, pos, \u27e8{ startPos := startPos, stopPos := pos, token := tk }, catCache\u27e9, none\u27e9\n  | other => other", "start": [827, 1], "end": [835, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.tokenFn", "code": "def tokenFn (expected : List String := []) : ParserFn := fun c s =>\n  let input := c.input\n  let i     := s.pos\n  if input.atEnd i then s.mkEOIError expected\n  else\n    let tkc := s.cache.tokenCache\n    if tkc.startPos == i then\n      let s := s.pushSyntax tkc.token\n      s.setPos tkc.stopPos\n    else\n      let s := tokenFnAux c s\n      updateTokenCache i s", "start": [837, 1], "end": [848, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.peekTokenAux", "code": "def peekTokenAux (c : ParserContext) (s : ParserState) : ParserState \u00d7 Except ParserState Syntax :=\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let s      := tokenFn [] c s\n  if let some _ := s.errorMsg then (s.restore iniSz iniPos, .error s)\n  else\n    let stx := s.stxStack.back\n    (s.restore iniSz iniPos, .ok stx)", "start": [850, 1], "end": [857, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.peekToken", "code": "def peekToken (c : ParserContext) (s : ParserState) : ParserState \u00d7 Except ParserState Syntax :=\n  let tkc := s.cache.tokenCache\n  if tkc.startPos == s.pos then\n    (s, .ok tkc.token)\n  else\n    peekTokenAux c s", "start": [859, 1], "end": [864, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.rawIdentFn", "code": "def rawIdentFn : ParserFn := fun c s =>\n  let input := c.input\n  let i     := s.pos\n  if input.atEnd i then s.mkEOIError\n  else identFnAux i none .anonymous c s", "start": [866, 1], "end": [871, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.satisfySymbolFn", "code": "def satisfySymbolFn (p : String \u2192 Bool) (expected : List String) : ParserFn := fun c s => Id.run do\n  let iniPos := s.pos\n  let s := tokenFn expected c s\n  if s.hasError then\n    return s\n  if let .atom _ sym := s.stxStack.back then\n    if p sym then\n      return s\n  s.mkUnexpectedTokenErrors expected iniPos", "start": [873, 1], "end": [882, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.symbolFnAux", "code": "def symbolFnAux (sym : String) (errorMsg : String) : ParserFn :=\n  satisfySymbolFn (fun s => s == sym) [errorMsg]", "start": [884, 1], "end": [885, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.symbolInfo", "code": "def symbolInfo (sym : String) : ParserInfo := {\n  collectTokens := fun tks => sym :: tks\n  firstTokens   := FirstTokens.tokens [ sym ]\n}", "start": [887, 1], "end": [890, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.symbolFn", "code": "def symbolFn (sym : String) : ParserFn :=\n  symbolFnAux sym (\"'\" ++ sym ++ \"'\")", "start": [892, 1], "end": [893, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.symbolNoAntiquot", "code": "def symbolNoAntiquot (sym : String) : Parser :=\n  let sym := sym.trim\n  { info := symbolInfo sym\n    fn   := symbolFn sym }", "start": [895, 1], "end": [898, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkTailNoWs", "code": "def checkTailNoWs (prev : Syntax) : Bool :=\n  match prev.getTailInfo with\n  | .original _ _ trailing _ => trailing.stopPos == trailing.startPos\n  | _                        => false", "start": [900, 1], "end": [903, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nonReservedSymbolFnAux", "code": "def nonReservedSymbolFnAux (sym : String) (errorMsg : String) : ParserFn := fun c s => Id.run do\n  let s := tokenFn [errorMsg] c s\n  if s.hasError then\n    return s\n  match s.stxStack.back with\n  | .atom _ sym' =>\n    if sym == sym' then\n      return s\n  | .ident info rawVal _ _ =>\n    if sym == rawVal.toString then\n      let s := s.popSyntax\n      return s.pushSyntax (Syntax.atom info sym)\n  | _ => ()\n  s.mkUnexpectedTokenError errorMsg", "start": [905, 1], "end": [925, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nonReservedSymbolFn", "code": "def nonReservedSymbolFn (sym : String) : ParserFn :=\n  nonReservedSymbolFnAux sym (\"'\" ++ sym ++ \"'\")", "start": [927, 1], "end": [928, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nonReservedSymbolInfo", "code": "def nonReservedSymbolInfo (sym : String) (includeIdent : Bool) : ParserInfo := {\n  firstTokens  :=\n    if includeIdent then\n      .tokens [ sym, \"ident\" ]\n    else\n      .tokens [ sym ]\n}", "start": [930, 1], "end": [936, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nonReservedSymbolNoAntiquot", "code": "def nonReservedSymbolNoAntiquot (sym : String) (includeIdent := false) : Parser :=\n  let sym := sym.trim\n  { info := nonReservedSymbolInfo sym includeIdent,\n    fn   := nonReservedSymbolFn sym }", "start": [938, 1], "end": [941, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.strAux", "code": "partial def strAux (sym : String) (errorMsg : String) (j : String.Pos) :ParserFn :=\n  let rec parse (j c s) :=\n    if h\u2081 : sym.atEnd j then s\n    else\n      let i := s.pos\n      let input := c.input\n      if h\u2082 : input.atEnd i then s.mkError errorMsg\n      else if sym.get' j h\u2081 != input.get' i h\u2082 then s.mkError errorMsg\n      else parse (sym.next' j h\u2081) c (s.next' input i h\u2082)\n  parse j", "start": [943, 1], "end": [952, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkTailWs", "code": "def checkTailWs (prev : Syntax) : Bool :=\n  match prev.getTailInfo with\n  | .original _ _ trailing _ => trailing.stopPos > trailing.startPos\n  | _                        => false", "start": [954, 1], "end": [957, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkWsBeforeFn", "code": "def checkWsBeforeFn (errorMsg : String) : ParserFn := fun _ s =>\n  let prev := s.stxStack.back\n  if checkTailWs prev then s else s.mkError errorMsg", "start": [959, 1], "end": [961, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkWsBefore", "code": "def checkWsBefore (errorMsg : String := \"space before\") : Parser where\n  info := epsilonInfo\n  fn   := checkWsBeforeFn errorMsg", "start": [963, 1], "end": [969, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkTailLinebreak", "code": "def checkTailLinebreak (prev : Syntax) : Bool :=\n  match prev.getTailInfo with\n  | .original _ _ trailing _ => trailing.contains '\\n'\n  | _ => false", "start": [971, 1], "end": [974, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkLinebreakBeforeFn", "code": "def checkLinebreakBeforeFn (errorMsg : String) : ParserFn := fun _ s =>\n  let prev := s.stxStack.back\n  if checkTailLinebreak prev then s else s.mkError errorMsg", "start": [976, 1], "end": [978, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkLinebreakBefore", "code": "def checkLinebreakBefore (errorMsg : String := \"line break\") : Parser where\n  info := epsilonInfo\n  fn   := checkLinebreakBeforeFn errorMsg", "start": [980, 1], "end": [986, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.pickNonNone", "code": "private def pickNonNone (stack : SyntaxStack) : Syntax :=\n  match stack.toSubarray.findRev? fun stx => !stx.isNone with\n  | none => Syntax.missing\n  | some stx => stx", "start": [988, 1], "end": [991, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkNoWsBeforeFn", "code": "def checkNoWsBeforeFn (errorMsg : String) : ParserFn := fun _ s =>\n  let prev := pickNonNone s.stxStack\n  if checkTailNoWs prev then s else s.mkError errorMsg", "start": [993, 1], "end": [995, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkNoWsBefore", "code": "def checkNoWsBefore (errorMsg : String := \"no space before\") : Parser := {\n  info := epsilonInfo\n  fn   := checkNoWsBeforeFn errorMsg\n}", "start": [997, 1], "end": [1007, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.unicodeSymbolFnAux", "code": "def unicodeSymbolFnAux (sym asciiSym : String) (expected : List String) : ParserFn :=\n  satisfySymbolFn (fun s => s == sym || s == asciiSym) expected", "start": [1009, 1], "end": [1010, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.unicodeSymbolInfo", "code": "def unicodeSymbolInfo (sym asciiSym : String) : ParserInfo := {\n  collectTokens := fun tks => sym :: asciiSym :: tks\n  firstTokens   := FirstTokens.tokens [ sym, asciiSym ]\n}", "start": [1012, 1], "end": [1015, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.unicodeSymbolFn", "code": "def unicodeSymbolFn (sym asciiSym : String) : ParserFn :=\n  unicodeSymbolFnAux sym asciiSym [\"'\" ++ sym ++ \"', '\" ++ asciiSym ++ \"'\"]", "start": [1017, 1], "end": [1018, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.unicodeSymbolNoAntiquot", "code": "def unicodeSymbolNoAntiquot (sym asciiSym : String) : Parser :=\n  let sym := sym.trim\n  let asciiSym := asciiSym.trim\n  { info := unicodeSymbolInfo sym asciiSym\n    fn   := unicodeSymbolFn sym asciiSym }", "start": [1020, 1], "end": [1024, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkAtomicInfo", "code": "def mkAtomicInfo (k : String) : ParserInfo :=\n  { firstTokens := FirstTokens.tokens [ k ] }", "start": [1026, 1], "end": [1027, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.expectTokenFn", "code": "def expectTokenFn (k : SyntaxNodeKind) (desc : String) : ParserFn := fun c s =>\n  let s := tokenFn [desc] c s\n  if !s.hasError && !(s.stxStack.back.isOfKind k) then s.mkUnexpectedTokenError desc else s", "start": [1029, 1], "end": [1034, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.numLitFn", "code": "def numLitFn : ParserFn := expectTokenFn numLitKind \"numeral\"", "start": [1036, 1], "end": [1036, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.numLitNoAntiquot", "code": "def numLitNoAntiquot : Parser := {\n  fn   := numLitFn\n  info := mkAtomicInfo \"num\"\n}", "start": [1038, 1], "end": [1041, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.scientificLitFn", "code": "def scientificLitFn : ParserFn := expectTokenFn scientificLitKind \"scientific number\"", "start": [1043, 1], "end": [1043, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.scientificLitNoAntiquot", "code": "def scientificLitNoAntiquot : Parser := {\n  fn   := scientificLitFn\n  info := mkAtomicInfo \"scientific\"\n}", "start": [1045, 1], "end": [1048, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.strLitFn", "code": "def strLitFn : ParserFn := expectTokenFn strLitKind \"string literal\"", "start": [1050, 1], "end": [1050, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.strLitNoAntiquot", "code": "def strLitNoAntiquot : Parser := {\n  fn   := strLitFn\n  info := mkAtomicInfo \"str\"\n}", "start": [1052, 1], "end": [1055, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.charLitFn", "code": "def charLitFn : ParserFn := expectTokenFn charLitKind \"character literal\"", "start": [1057, 1], "end": [1057, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.charLitNoAntiquot", "code": "def charLitNoAntiquot : Parser := {\n  fn   := charLitFn\n  info := mkAtomicInfo \"char\"\n}", "start": [1059, 1], "end": [1062, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nameLitFn", "code": "def nameLitFn : ParserFn := expectTokenFn nameLitKind \"Name literal\"", "start": [1064, 1], "end": [1064, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nameLitNoAntiquot", "code": "def nameLitNoAntiquot : Parser := {\n  fn   := nameLitFn\n  info := mkAtomicInfo \"name\"\n}", "start": [1066, 1], "end": [1069, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.identFn", "code": "def identFn : ParserFn := expectTokenFn identKind \"identifier\"", "start": [1071, 1], "end": [1071, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.identNoAntiquot", "code": "def identNoAntiquot : Parser := {\n  fn   := identFn\n  info := mkAtomicInfo \"ident\"\n}", "start": [1073, 1], "end": [1076, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.rawIdentNoAntiquot", "code": "def rawIdentNoAntiquot : Parser := {\n  fn := rawIdentFn\n}", "start": [1078, 1], "end": [1080, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.identEqFn", "code": "def identEqFn (id : Name) : ParserFn := fun c s =>\n  let s      := tokenFn [\"identifier\"] c s\n  if s.hasError then\n    s\n  else match s.stxStack.back with\n    | .ident _ _ val _ => if val != id then s.mkUnexpectedTokenError s!\"identifier '{id}'\" else s\n    | _ => s.mkUnexpectedTokenError \"identifier\"", "start": [1082, 1], "end": [1088, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.identEq", "code": "def identEq (id : Name) : Parser := {\n  fn   := identEqFn id\n  info := mkAtomicInfo \"ident\"\n}", "start": [1090, 1], "end": [1093, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.hygieneInfoFn", "code": "def hygieneInfoFn : ParserFn := fun c s => Id.run do\n  let input := c.input\n  let finish pos str trailing s :=\n    let info  := SourceInfo.original str pos trailing pos\n    let ident := mkIdent info str .anonymous\n    let stx   := mkNode hygieneInfoKind #[ident]\n    s.pushSyntax stx\n  if !s.stxStack.isEmpty then\n    let prev := s.stxStack.back\n    if let .original leading pos trailing endPos := prev.getTailInfo then\n      let str := mkEmptySubstringAt input endPos\n      let s := s.popSyntax.pushSyntax <| prev.setTailInfo (.original leading pos str endPos)\n      return finish endPos str trailing s\n  let str := mkEmptySubstringAt input s.pos\n  finish s.pos str str s", "start": [1095, 1], "end": [1118, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.hygieneInfoNoAntiquot", "code": "def hygieneInfoNoAntiquot : Parser := {\n  fn   := hygieneInfoFn\n  info := nodeInfo hygieneInfoKind epsilonInfo\n}", "start": [1120, 1], "end": [1123, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.keepTop", "code": "def keepTop (s : SyntaxStack) (startStackSize : Nat) : SyntaxStack :=\n  let node  := s.back\n  s.shrink startStackSize |>.push node", "start": [1127, 1], "end": [1129, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.keepNewError", "code": "def keepNewError (s : ParserState) (oldStackSize : Nat) : ParserState :=\n  match s with\n  | \u27e8stack, lhsPrec, pos, cache, err\u27e9 => \u27e8keepTop stack oldStackSize, lhsPrec, pos, cache, err\u27e9", "start": [1131, 1], "end": [1133, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.keepPrevError", "code": "def keepPrevError (s : ParserState) (oldStackSize : Nat) (oldStopPos : String.Pos) (oldError : Option Error) (oldLhsPrec : Nat) : ParserState :=\n  match s with\n  | \u27e8stack, _, _, cache, _\u27e9 => \u27e8stack.shrink oldStackSize, oldLhsPrec, oldStopPos, cache, oldError\u27e9", "start": [1135, 1], "end": [1137, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.mergeErrors", "code": "def mergeErrors (s : ParserState) (oldStackSize : Nat) (oldError : Error) : ParserState :=\n  match s with\n  | \u27e8stack, lhsPrec, pos, cache, some err\u27e9 =>\n    \u27e8stack.shrink oldStackSize, lhsPrec, pos, cache, if oldError == err then some err else some (oldError.merge err)\u27e9\n  | other                         => other", "start": [1139, 1], "end": [1143, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.keepLatest", "code": "def keepLatest (s : ParserState) (startStackSize : Nat) : ParserState :=\n  match s with\n  | \u27e8stack, lhsPrec, pos, cache, _\u27e9 => \u27e8keepTop stack startStackSize, lhsPrec, pos, cache, none\u27e9", "start": [1145, 1], "end": [1147, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserState.replaceLongest", "code": "def replaceLongest (s : ParserState) (startStackSize : Nat) : ParserState :=\n  s.keepLatest startStackSize", "start": [1149, 1], "end": [1150, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.invalidLongestMatchParser", "code": "def invalidLongestMatchParser (s : ParserState) : ParserState :=\n  s.mkError \"longestMatch parsers must generate exactly one Syntax node\"", "start": [1154, 1], "end": [1155, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.runLongestMatchParser", "code": "def runLongestMatchParser (left? : Option Syntax) (startLhsPrec : Nat) (p : ParserFn) : ParserFn := fun c s => Id.run do\n  \n  let mut s := { s with lhsPrec := if left?.isSome then startLhsPrec else maxPrec }\n  let startSize := s.stackSize\n  if let some left := left? then\n    s := s.pushSyntax left\n  s := p c s\n  if s.stackSize == startSize + 1 then\n    s else if s.hasError then\n    s.shrinkStack startSize |>.pushSyntax Syntax.missing\n  else\n    invalidLongestMatchParser s", "start": [1157, 1], "end": [1187, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.longestMatchStep", "code": "def longestMatchStep (left? : Option Syntax) (startSize startLhsPrec : Nat) (startPos : String.Pos) (prevPrio : Nat) (prio : Nat) (p : ParserFn)\n    : ParserContext \u2192 ParserState \u2192 ParserState \u00d7 Nat := fun c s =>\n  let score (s : ParserState) (prio : Nat) :=\n    (s.pos.byteIdx, if s.errorMsg.isSome then (0 : Nat) else 1, prio)\n  let previousScore := score s prevPrio\n  let prevErrorMsg  := s.errorMsg\n  let prevStopPos   := s.pos\n  let prevSize      := s.stackSize\n  let prevLhsPrec   := s.lhsPrec\n  let s             := s.restore prevSize startPos\n  let s             := runLongestMatchParser left? startLhsPrec p c s\n  match (let _ := @lexOrd; compare previousScore (score s prio)) with\n  | .lt => (s.keepNewError startSize, prio)\n  | .gt => (s.keepPrevError prevSize prevStopPos prevErrorMsg prevLhsPrec, prevPrio)\n  | .eq =>\n    match prevErrorMsg with\n    | none =>\n      ({s with lhsPrec := s.lhsPrec.min prevLhsPrec }, prio)\n    | some oldError => (s.mergeErrors prevSize oldError, prio)", "start": [1189, 1], "end": [1208, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.longestMatchMkResult", "code": "def longestMatchMkResult (startSize : Nat) (s : ParserState) : ParserState :=\n  if s.stackSize > startSize + 1 then s.mkNode choiceKind startSize else s", "start": [1210, 1], "end": [1211, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.longestMatchFnAux", "code": "def longestMatchFnAux (left? : Option Syntax) (startSize startLhsPrec : Nat) (startPos : String.Pos) (prevPrio : Nat) (ps : List (Parser \u00d7 Nat)) : ParserFn :=\n  let rec parse (prevPrio : Nat) (ps : List (Parser \u00d7 Nat)) :=\n    match ps with\n    | []    => fun _ s => longestMatchMkResult startSize s\n    | p::ps => fun c s =>\n      let (s, prevPrio) := longestMatchStep left? startSize startLhsPrec startPos prevPrio p.2 p.1.fn c s\n      parse prevPrio ps c s\n  parse prevPrio ps", "start": [1213, 1], "end": [1220, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.longestMatchFn", "code": "def longestMatchFn (left? : Option Syntax) : List (Parser \u00d7 Nat) \u2192 ParserFn\n  | []    => fun _ s => s.mkError \"longestMatch: empty list\"\n  | [p]   => fun c s => runLongestMatchParser left? s.lhsPrec p.1.fn c s\n  | p::ps => fun c s =>\n    let startSize := s.stackSize\n    let startLhsPrec := s.lhsPrec\n    let startPos  := s.pos\n    let s         := runLongestMatchParser left? s.lhsPrec p.1.fn c s\n    longestMatchFnAux left? startSize startLhsPrec startPos p.2 ps c s", "start": [1222, 1], "end": [1230, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.anyOfFn", "code": "def anyOfFn : List Parser \u2192 ParserFn\n  | [],    _, s => s.mkError \"anyOf: empty list\"\n  | [p],   c, s => p.fn c s\n  | p::ps, c, s => orelseFn p.fn (anyOfFn ps) c s", "start": [1232, 1], "end": [1235, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkColEqFn", "code": "def checkColEqFn (errorMsg : String) : ParserFn := fun c s =>\n  match c.savedPos? with\n  | none => s\n  | some savedPos =>\n    let savedPos := c.fileMap.toPosition savedPos\n    let pos      := c.fileMap.toPosition s.pos\n    if pos.column = savedPos.column then s\n    else s.mkError errorMsg", "start": [1237, 1], "end": [1244, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkColEq", "code": "def checkColEq (errorMsg : String := \"checkColEq\") : Parser where\n  fn := checkColEqFn errorMsg", "start": [1246, 1], "end": [1252, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkColGeFn", "code": "def checkColGeFn (errorMsg : String) : ParserFn := fun c s =>\n  match c.savedPos? with\n  | none => s\n  | some savedPos =>\n    let savedPos := c.fileMap.toPosition savedPos\n    let pos      := c.fileMap.toPosition s.pos\n    if pos.column \u2265 savedPos.column then s\n    else s.mkError errorMsg", "start": [1254, 1], "end": [1261, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkColGe", "code": "def checkColGe (errorMsg : String := \"checkColGe\") : Parser where\n  fn := checkColGeFn errorMsg", "start": [1263, 1], "end": [1271, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkColGtFn", "code": "def checkColGtFn (errorMsg : String) : ParserFn := fun c s =>\n  match c.savedPos? with\n  | none => s\n  | some savedPos =>\n    let savedPos := c.fileMap.toPosition savedPos\n    let pos      := c.fileMap.toPosition s.pos\n    if pos.column > savedPos.column then s\n    else s.mkError errorMsg", "start": [1273, 1], "end": [1280, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkColGt", "code": "def checkColGt (errorMsg : String := \"checkColGt\") : Parser where\n  fn := checkColGtFn errorMsg", "start": [1282, 1], "end": [1295, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkLineEqFn", "code": "def checkLineEqFn (errorMsg : String) : ParserFn := fun c s =>\n  match c.savedPos? with\n  | none => s\n  | some savedPos =>\n    let savedPos := c.fileMap.toPosition savedPos\n    let pos      := c.fileMap.toPosition s.pos\n    if pos.line == savedPos.line then s\n    else s.mkError errorMsg", "start": [1297, 1], "end": [1304, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkLineEq", "code": "def checkLineEq (errorMsg : String := \"checkLineEq\") : Parser where\n  fn := checkLineEqFn errorMsg", "start": [1306, 1], "end": [1313, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withPosition", "code": "def withPosition : Parser \u2192 Parser := withFn fun f c s =>\n    adaptCacheableContextFn ({ \u00b7 with savedPos? := s.pos }) f c s", "start": [1315, 1], "end": [1329, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withPositionAfterLinebreak", "code": "def withPositionAfterLinebreak : Parser \u2192 Parser := withFn fun f c s =>\n  let prev := s.stxStack.back\n  adaptCacheableContextFn (fun c => if checkTailLinebreak prev then { c with savedPos? := s.pos } else c) f c s", "start": [1331, 1], "end": [1333, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withoutPosition", "code": "def withoutPosition (p : Parser) : Parser :=\n  adaptCacheableContext ({ \u00b7 with savedPos? := none }) p", "start": [1335, 1], "end": [1341, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withForbidden", "code": "def withForbidden (tk : Token) (p : Parser) : Parser :=\n  adaptCacheableContext ({ \u00b7 with forbiddenTk? := tk }) p", "start": [1343, 1], "end": [1351, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withoutForbidden", "code": "def withoutForbidden (p : Parser) : Parser :=\n  adaptCacheableContext ({ \u00b7 with forbiddenTk? := none }) p", "start": [1353, 1], "end": [1359, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.eoiFn", "code": "def eoiFn : ParserFn := fun c s =>\n  let i := s.pos\n  if c.input.atEnd i then s\n  else s.mkError \"expected end of file\"", "start": [1361, 1], "end": [1364, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.eoi", "code": "def eoi : Parser := {\n  fn := eoiFn\n}", "start": [1366, 1], "end": [1368, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.TokenMap", "code": "def TokenMap (\u03b1 : Type) := RBMap Name (List \u03b1) Name.quickCmp", "start": [1370, 1], "end": [1371, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.TokenMap.insert", "code": "def insert (map : TokenMap \u03b1) (k : Name) (v : \u03b1) : TokenMap \u03b1 :=\n  match map.find? k with\n  | none    => .insert map k [v]\n  | some vs => .insert map k (v::vs)", "start": [1375, 1], "end": [1378, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.PrattParsingTables", "code": "structure PrattParsingTables where\n  leadingTable    : TokenMap (Parser \u00d7 Nat) := {}\n  leadingParsers  : List (Parser \u00d7 Nat) := [] trailingTable   : TokenMap (Parser \u00d7 Nat) := {}\n  trailingParsers : List (Parser \u00d7 Nat) := []", "start": [1389, 1], "end": [1393, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.LeadingIdentBehavior", "code": "inductive LeadingIdentBehavior where\n  \n  | default\n  \n  | symbol\n  \n  | both\n  deriving Inhabited, BEq, Repr", "start": [1398, 1], "end": [1426, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserCategory", "code": "structure ParserCategory where\n  \n  declName : Name\n  \n  kinds    : SyntaxNodeKindSet := {}\n  \n  tables   : PrattParsingTables := {}\n  \n  behavior : LeadingIdentBehavior\n  deriving Inhabited", "start": [1428, 1], "end": [1459, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserCategories", "code": "abbrev ParserCategories := PersistentHashMap Name ParserCategory", "start": [1461, 1], "end": [1461, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.indexed", "code": "def indexed {\u03b1 : Type} (map : TokenMap \u03b1) (c : ParserContext) (s : ParserState) (behavior : LeadingIdentBehavior) : ParserState \u00d7 List \u03b1 :=\n  let (s, stx) := peekToken c s\n  let find (n : Name) : ParserState \u00d7 List \u03b1 :=\n    match map.find? n with\n    | some as => (s, as)\n    | _       => (s, [])\n  match stx with\n  | .ok (.atom _ sym)      => find (.mkSimple sym)\n  | .ok (.ident _ _ val _) =>\n    match behavior with\n    | .default => find identKind\n    | .symbol =>\n      match map.find? val with\n      | some as => (s, as)\n      | none    => find identKind\n    | .both =>\n      match map.find? val with\n      | some as =>\n        if val == identKind then\n          (s, as)  else\n          match map.find? identKind with\n          | some as' => (s, as ++ as')\n          | _        => (s, as)\n      | none    => find identKind\n  | .ok (.node _ k _) => find k\n  | .ok _             => (s, [])\n  | .error s'         => (s', [])", "start": [1463, 1], "end": [1490, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.CategoryParserFn", "code": "abbrev CategoryParserFn := Name \u2192 ParserFn", "start": [1492, 1], "end": [1492, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.categoryParserFn", "code": "def categoryParserFn (catName : Name) : ParserFn := fun ctx s =>\n  categoryParserFnExtension.getState ctx.env catName ctx s", "start": [1498, 1], "end": [1499, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.categoryParser", "code": "def categoryParser (catName : Name) (prec : Nat) : Parser where\n  fn := adaptCacheableContextFn ({ \u00b7 with prec }) (withCacheFn catName (categoryParserFn catName))", "start": [1501, 1], "end": [1502, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.termParser", "code": "def termParser (prec : Nat := 0) : Parser :=\n  categoryParser `term prec", "start": [1505, 1], "end": [1506, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.checkNoImmediateColon", "code": "def checkNoImmediateColon : Parser := {\n  fn := fun c s =>\n    let prev := s.stxStack.back\n    if checkTailNoWs prev then\n      let input := c.input\n      let i     := s.pos\n      if h : input.atEnd i then s\n      else\n        let curr := input.get' i h\n        if curr == ':' then\n          s.mkUnexpectedError \"unexpected ':'\"\n        else s\n    else s\n}", "start": [1512, 1], "end": [1526, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.setExpectedFn", "code": "def setExpectedFn (expected : List String) (p : ParserFn) : ParserFn := fun c s =>\n  match p c s with\n    | s'@{ errorMsg := some msg, .. } => { s' with errorMsg := some { msg with expected } }\n    | s'                              => s'", "start": [1528, 1], "end": [1531, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.setExpected", "code": "def setExpected (expected : List String) : Parser \u2192 Parser := withFn (setExpectedFn expected)", "start": [1533, 1], "end": [1533, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.pushNone", "code": "def pushNone : Parser := {\n  fn := fun _ s => s.pushSyntax mkNullNode\n}", "start": [1535, 1], "end": [1537, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.antiquotNestedExpr", "code": "def antiquotNestedExpr : Parser := node `antiquotNestedExpr (symbolNoAntiquot \"(\" >> decQuotDepth termParser >> symbolNoAntiquot \")\")", "start": [1540, 1], "end": [1540, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.antiquotExpr", "code": "def antiquotExpr : Parser       := identNoAntiquot <|> symbolNoAntiquot \"_\" <|> antiquotNestedExpr", "start": [1541, 1], "end": [1541, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.tokenAntiquotFn", "code": "def tokenAntiquotFn : ParserFn := fun c s => Id.run do\n  if s.hasError then\n    return s\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let s      := (checkNoWsBefore >> symbolNoAntiquot \"%\" >> symbolNoAntiquot \"$\" >> checkNoWsBefore >> antiquotExpr).fn c s\n  if s.hasError then\n    return s.restore iniSz iniPos\n  s.mkNode (`token_antiquot) (iniSz - 1)", "start": [1543, 1], "end": [1551, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.tokenWithAntiquot", "code": "def tokenWithAntiquot : Parser \u2192 Parser := withFn fun f c s =>\n  let s := f c s\n  if c.input.get s.pos == '%' then\n    tokenAntiquotFn c s\n  else\n    s", "start": [1553, 1], "end": [1559, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.symbol", "code": "def symbol (sym : String) : Parser :=\n  tokenWithAntiquot (symbolNoAntiquot sym)", "start": [1561, 1], "end": [1562, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nonReservedSymbol", "code": "def nonReservedSymbol (sym : String) (includeIdent := false) : Parser :=\n  tokenWithAntiquot (nonReservedSymbolNoAntiquot sym includeIdent)", "start": [1567, 1], "end": [1568, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.unicodeSymbol", "code": "def unicodeSymbol (sym asciiSym : String) : Parser :=\n  tokenWithAntiquot (unicodeSymbolNoAntiquot sym asciiSym)", "start": [1570, 1], "end": [1571, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkAntiquot", "code": "def mkAntiquot (name : String) (kind : SyntaxNodeKind) (anonymous := true) (isPseudoKind := false) : Parser :=\n  let kind := kind ++ (if isPseudoKind then `pseudo else .anonymous) ++ `antiquot\n  let nameP := node `antiquotName <| checkNoWsBefore (\"no space before ':\" ++ name ++ \"'\") >> symbol \":\" >> nonReservedSymbol name\n  let nameP := if anonymous then nameP <|> checkNoImmediateColon >> pushNone else nameP\n  leadingNode kind maxPrec <| atomic <|\n    setExpected [] \"$\" >>\n    manyNoAntiquot (checkNoWsBefore \"\" >> \"$\") >>\n    checkNoWsBefore \"no space before spliced term\" >> antiquotExpr >>\n    nameP", "start": [1573, 1], "end": [1588, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withAntiquotFn", "code": "def withAntiquotFn (antiquotP p : ParserFn) (isCatAntiquot := false) : ParserFn := fun c s =>\n  if c.input.get s.pos == '$' then\n    orelseFnCore (antiquotBehavior := if isCatAntiquot then .acceptLhs else .takeLongest) antiquotP p c s\n  else\n    p c s", "start": [1590, 1], "end": [1599, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withAntiquot", "code": "def withAntiquot (antiquotP p : Parser) : Parser := {\n  fn := withAntiquotFn antiquotP.fn p.fn\n  info := orelseInfo antiquotP.info p.info\n}", "start": [1601, 1], "end": [1605, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withoutInfo", "code": "def withoutInfo (p : Parser) : Parser := {\n  fn := p.fn\n}", "start": [1607, 1], "end": [1609, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkAntiquotSplice", "code": "def mkAntiquotSplice (kind : SyntaxNodeKind) (p suffix : Parser) : Parser :=\n  let kind := kind ++ `antiquot_scope\n  leadingNode kind maxPrec <| atomic <|\n    setExpected [] \"$\" >>\n    manyNoAntiquot (checkNoWsBefore \"\" >> \"$\") >>\n    checkNoWsBefore \"no space before spliced term\" >> symbol \"[\" >> node nullKind p >> symbol \"]\" >>\n    suffix", "start": [1611, 1], "end": [1618, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withAntiquotSuffixSpliceFn", "code": "private def withAntiquotSuffixSpliceFn (kind : SyntaxNodeKind) (suffix : ParserFn) : ParserFn := fun c s => Id.run do\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let s      := suffix c s\n  if s.hasError then\n    return s.restore iniSz iniPos\n  s.mkNode (kind ++ `antiquot_suffix_splice) (s.stxStack.size - 2)", "start": [1620, 1], "end": [1626, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withAntiquotSuffixSplice", "code": "def withAntiquotSuffixSplice (kind : SyntaxNodeKind) (p suffix : Parser) : Parser where\n  info := andthenInfo p.info suffix.info\n  fn c s :=\n    let s := p.fn c s\n    if !s.hasError && s.stxStack.back.isAntiquots then\n      withAntiquotSuffixSpliceFn kind suffix.fn c s\n    else\n      s", "start": [1628, 1], "end": [1637, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withAntiquotSpliceAndSuffix", "code": "def withAntiquotSpliceAndSuffix (kind : SyntaxNodeKind) (p suffix : Parser) :=\n  withAntiquot (mkAntiquotSplice kind (withoutInfo p) suffix) (withAntiquotSuffixSplice kind p suffix)", "start": [1639, 1], "end": [1641, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nodeWithAntiquot", "code": "def nodeWithAntiquot (name : String) (kind : SyntaxNodeKind) (p : Parser) (anonymous := false) : Parser :=\n  withAntiquot (mkAntiquot name kind anonymous) $ node kind p", "start": [1643, 1], "end": [1644, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepByElemParser", "code": "def sepByElemParser (p : Parser) (sep : String) : Parser :=\n  withAntiquotSpliceAndSuffix `sepBy p (symbol (sep.trim ++ \"*\"))", "start": [1650, 1], "end": [1651, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepBy", "code": "def sepBy (p : Parser) (sep : String) (psep : Parser := symbol sep) (allowTrailingSep : Bool := false) : Parser :=\n  sepByNoAntiquot (sepByElemParser p sep) psep allowTrailingSep", "start": [1653, 1], "end": [1654, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepBy1", "code": "def sepBy1 (p : Parser) (sep : String) (psep : Parser := symbol sep) (allowTrailingSep : Bool := false) : Parser :=\n  sepBy1NoAntiquot (sepByElemParser p sep) psep allowTrailingSep", "start": [1656, 1], "end": [1657, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkResult", "code": "private def mkResult (s : ParserState) (iniSz : Nat) : ParserState :=\n  if s.stackSize == iniSz + 1 then s\n  else s.mkNode nullKind iniSz", "start": [1659, 1], "end": [1661, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.leadingParserAux", "code": "def leadingParserAux (kind : Name) (tables : PrattParsingTables) (behavior : LeadingIdentBehavior) : ParserFn := fun c s => Id.run do\n  let iniSz   := s.stackSize\n  let (s, ps) := indexed tables.leadingTable c s behavior\n  if s.hasError then\n    return s\n  let ps      := tables.leadingParsers ++ ps\n  if ps.isEmpty then\n    let s := tokenFn [toString kind] c s\n    if s.hasError then\n      return s\n    return s.mkUnexpectedTokenError (toString kind)\n  let s := longestMatchFn none ps c s\n  mkResult s iniSz", "start": [1663, 1], "end": [1676, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.leadingParser", "code": "def leadingParser (kind : Name) (tables : PrattParsingTables) (behavior : LeadingIdentBehavior) (antiquotParser : ParserFn) : ParserFn :=\n  withAntiquotFn (isCatAntiquot := true) antiquotParser (leadingParserAux kind tables behavior)", "start": [1678, 1], "end": [1679, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.trailingLoopStep", "code": "def trailingLoopStep (tables : PrattParsingTables) (left : Syntax) (ps : List (Parser \u00d7 Nat)) : ParserFn := fun c s =>\n  longestMatchFn left (ps ++ tables.trailingParsers) c s", "start": [1681, 1], "end": [1682, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.trailingLoop", "code": "partial def trailingLoop (tables : PrattParsingTables) (c : ParserContext) (s : ParserState) : ParserState := Id.run do\n  let iniSz  := s.stackSize\n  let iniPos := s.pos\n  let (s, ps)       := indexed tables.trailingTable c s LeadingIdentBehavior.default\n  if s.hasError then\n    return s.restore iniSz iniPos\n  if ps.isEmpty && tables.trailingParsers.isEmpty then\n    return s let left   := s.stxStack.back\n  let s      := s.popSyntax\n  let s      := trailingLoopStep tables left ps c s\n  if s.hasError then\n    return if s.pos == iniPos then s.restore (iniSz - 1) iniPos |>.pushSyntax left else s\n  trailingLoop tables c s", "start": [1684, 1], "end": [1702, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.prattParser", "code": "def prattParser (kind : Name) (tables : PrattParsingTables) (behavior : LeadingIdentBehavior) (antiquotParser : ParserFn) : ParserFn := fun c s =>\n  let s := leadingParser kind tables behavior antiquotParser c s\n  if s.hasError then\n    s\n  else\n    trailingLoop tables c s", "start": [1704, 1], "end": [1730, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.fieldIdxFn", "code": "def fieldIdxFn : ParserFn := fun c s =>\n  let initStackSz := s.stackSize\n  let iniPos := s.pos\n  let curr     := c.input.get iniPos\n  if curr.isDigit && curr != '0' then\n    let s     := takeWhileFn (fun c => c.isDigit) c s\n    mkNodeToken fieldIdxKind iniPos c s\n  else\n    s.mkErrorAt \"field index\" iniPos initStackSz", "start": [1732, 1], "end": [1740, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.fieldIdx", "code": "def fieldIdx : Parser :=\n  withAntiquot (mkAntiquot \"fieldIdx\" `fieldIdx) {\n    fn   := fieldIdxFn\n    info := mkAtomicInfo \"fieldIdx\"\n  }", "start": [1742, 1], "end": [1746, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.skip", "code": "def skip : Parser := {\n  fn   := fun _ s => s\n  info := epsilonInfo\n}", "start": [1748, 1], "end": [1751, 2], "kind": "commanddeclaration"}, {"full_name": "Syntax.foldArgsM", "code": "def foldArgsM (s : Syntax) (f : Syntax \u2192 \u03b2 \u2192 m \u03b2) (b : \u03b2) : m \u03b2 :=\n  s.getArgs.foldlM (flip f) b", "start": [1760, 1], "end": [1761, 30], "kind": "commanddeclaration"}, {"full_name": "Syntax.foldArgs", "code": "def foldArgs (s : Syntax) (f : Syntax \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) : \u03b2 :=\n  Id.run (s.foldArgsM f b)", "start": [1763, 1], "end": [1764, 27], "kind": "commanddeclaration"}, {"full_name": "Syntax.forArgsM", "code": "def forArgsM (s : Syntax) (f : Syntax \u2192 m Unit) : m Unit :=\n  s.foldArgsM (fun s _ => f s) ()", "start": [1766, 1], "end": [1767, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/DocString.lean", "imports": ["lake-packages/lean4/src/lean/Lean/MonadEnv.lean", "lake-packages/lean4/src/lean/Lean/DeclarationRange.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.findLeadingSpacesSize", "code": "private def findLeadingSpacesSize (s : String) : Nat :=\n  let it := s.iter\n  let it := it.find (\u00b7 == '\\n') |>.next\n  consumeSpaces it 0 s.length\nwhere\n  consumeSpaces (it : String.Iterator) (curr min : Nat) : Nat :=\n    if it.atEnd then min\n    else if it.curr == ' ' || it.curr == '\\t' then consumeSpaces it.next (curr + 1) min\n    else if it.curr == '\\n' then findNextLine it.next min\n    else findNextLine it.next (Nat.min curr min)\n  findNextLine (it : String.Iterator) (min : Nat) : Nat :=\n    if it.atEnd then min\n    else if it.curr == '\\n' then consumeSpaces it.next 0 min\n    else findNextLine it.next min", "start": [14, 1], "end": [27, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.removeNumLeadingSpaces", "code": "private def removeNumLeadingSpaces (n : Nat) (s : String) : String :=\n  consumeSpaces n s.iter \"\"\nwhere\n  consumeSpaces (n : Nat) (it : String.Iterator) (r : String) : String :=\n     match n with\n     | 0 => saveLine it r\n     | n+1 =>\n       if it.atEnd then r\n       else if it.curr == ' ' || it.curr == '\\t' then consumeSpaces n it.next r\n       else saveLine it r\n  saveLine (it : String.Iterator) (r : String) : String :=\n    if it.atEnd then r\n    else if it.curr == '\\n' then consumeSpaces n it.next (r.push '\\n')\n    else saveLine it.next (r.push it.curr)\ntermination_by\n  consumeSpaces n it r => (it, 1)\n  saveLine it r => (it, 0)", "start": [29, 1], "end": [45, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.removeLeadingSpaces", "code": "def removeLeadingSpaces (s : String) : String :=\n  let n := findLeadingSpacesSize s\n  if n == 0 then s else removeNumLeadingSpaces n s", "start": [47, 1], "end": [49, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.addBuiltinDocString", "code": "def addBuiltinDocString (declName : Name) (docString : String) : IO Unit :=\n  builtinDocStrings.modify (\u00b7.insert declName (removeLeadingSpaces docString))", "start": [51, 1], "end": [52, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.addDocString", "code": "def addDocString [MonadEnv m] (declName : Name) (docString : String) : m Unit :=\n  modifyEnv fun env => docStringExt.insert env declName (removeLeadingSpaces docString)", "start": [54, 1], "end": [55, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.addDocString'", "code": "def addDocString' [Monad m] [MonadEnv m] (declName : Name) (docString? : Option String) : m Unit :=\n  match docString? with\n  | some docString => addDocString declName docString\n  | none => return ()", "start": [57, 1], "end": [60, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.findDocString?", "code": "def findDocString? (env : Environment) (declName : Name) (includeBuiltin := true) : IO (Option String) :=\n  if let some docStr := docStringExt.find? env declName then\n    return some docStr\n  else if includeBuiltin then\n    return (\u2190 builtinDocStrings.get).find? declName\n  else\n    return none", "start": [62, 1], "end": [68, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.ModuleDoc", "code": "structure ModuleDoc where\n  doc : String\n  declarationRange : DeclarationRange", "start": [70, 1], "end": [72, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.addMainModuleDoc", "code": "def addMainModuleDoc (env : Environment) (doc : ModuleDoc) : Environment :=\n  moduleDocExt.addEntry env doc", "start": [80, 1], "end": [81, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.getMainModuleDoc", "code": "def getMainModuleDoc (env : Environment) : PersistentArray ModuleDoc :=\n  moduleDocExt.getState env", "start": [83, 1], "end": [84, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.getModuleDoc?", "code": "def getModuleDoc? (env : Environment) (moduleName : Name) : Option (Array ModuleDoc) :=\n  env.getModuleIdx? moduleName |>.map fun modIdx => moduleDocExt.getModuleEntries env modIdx", "start": [86, 1], "end": [87, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.getDocStringText", "code": "def getDocStringText [Monad m] [MonadError m] [MonadRef m] (stx : TSyntax `Lean.Parser.Command.docComment) : m String :=\n  match stx.raw[1] with\n  | Syntax.atom _ val => return val.extract 0 (val.endPos - \u27e82\u27e9)\n  | _                 => throwErrorAt stx \"unexpected doc string{indentD stx.raw[1]}\"", "start": [89, 1], "end": [92, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.TSyntax.getDocString", "code": "def TSyntax.getDocString (stx : TSyntax `Lean.Parser.Command.docComment) : String :=\n  match stx.raw[1] with\n  | Syntax.atom _ val => val.extract 0 (val.endPos - \u27e82\u27e9)\n  | _                 => \"\"", "start": [94, 1], "end": [97, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/KeyedDeclsAttribute.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/IR/CompilerM.lean", "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean", "lake-packages/lean4/src/lean/Lean/Compiler/InitAttr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.KeyedDeclsAttribute.Key", "code": "abbrev Key := Name", "start": [23, 1], "end": [23, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.Def", "code": "structure Def (\u03b3 : Type) where\n  \n  builtinName   : Name := Name.anonymous\n  \n  name          : Name\n  \n  descr         : String\n  valueTypeName : Name\n  \n  evalKey (builtin : Bool) (stx : Syntax) : AttrM Key := do\n    let stx \u2190 Attribute.Builtin.getIdent stx\n    let kind := stx.getId\n    if (\u2190 getEnv).contains kind && (\u2190 Elab.getInfoState).enabled then\n      Elab.addConstInfo stx kind none\n    pure kind\n  onAdded (builtin : Bool) (declName : Name) : AttrM Unit := pure ()\n  deriving Inhabited", "start": [25, 1], "end": [45, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.OLeanEntry", "code": "structure OLeanEntry where\n  key      : Key\n  \n  declName : Name\n  deriving Inhabited", "start": [47, 1], "end": [51, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.AttributeEntry", "code": "structure AttributeEntry (\u03b3 : Type) extends OLeanEntry where\n  \n  value : \u03b3", "start": [53, 1], "end": [56, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.Table", "code": "abbrev Table (\u03b3 : Type) := SMap Key (List (AttributeEntry \u03b3))", "start": [58, 1], "end": [58, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.ExtensionState", "code": "structure ExtensionState (\u03b3 : Type) where\n  newEntries : List OLeanEntry := []\n  table      : Table \u03b3 := {}\n  declNames  : PHashSet Name := {}\n  erased     : PHashSet Name := {}\n  deriving Inhabited", "start": [60, 1], "end": [65, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.Extension", "code": "abbrev Extension (\u03b3 : Type) := ScopedEnvExtension OLeanEntry (AttributeEntry \u03b3) (ExtensionState \u03b3)", "start": [67, 1], "end": [67, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute", "code": "structure KeyedDeclsAttribute (\u03b3 : Type) where\n  defn : KeyedDeclsAttribute.Def \u03b3\n  tableRef : IO.Ref (KeyedDeclsAttribute.Table \u03b3)\n  ext : KeyedDeclsAttribute.Extension \u03b3\n  deriving Nonempty", "start": [71, 1], "end": [77, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.Table.insert", "code": "private def Table.insert (table : Table \u03b3) (v : AttributeEntry \u03b3) : Table \u03b3 :=\n  match table.find? v.key with\n  | some vs => SMap.insert table v.key (v::vs)\n  | none    => SMap.insert table v.key [v]", "start": [81, 1], "end": [84, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.ExtensionState.insert", "code": "def ExtensionState.insert (s : ExtensionState \u03b3) (v : AttributeEntry \u03b3) :  ExtensionState \u03b3 := {\n  table      := s.table.insert v\n  newEntries := v.toOLeanEntry :: s.newEntries\n  declNames  := s.declNames.insert v.declName\n  erased     := s.erased.erase v.declName\n}", "start": [86, 1], "end": [91, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.addBuiltin", "code": "def addBuiltin (attr : KeyedDeclsAttribute \u03b3) (key : Key) (declName : Name) (value : \u03b3) : IO Unit :=\n  attr.tableRef.modify fun m => m.insert { key, declName, value }", "start": [93, 1], "end": [94, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.mkStateOfTable", "code": "def mkStateOfTable (table : Table \u03b3) : ExtensionState \u03b3 := {\n  table\n  declNames := table.fold (init := {}) fun s _ es => es.foldl (init := s) fun s e => s.insert e.declName\n}", "start": [96, 1], "end": [99, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.ExtensionState.erase", "code": "def ExtensionState.erase (s : ExtensionState \u03b3) (attrName : Name) (declName : Name) : CoreM (ExtensionState \u03b3) := do\n  unless s.declNames.contains declName do\n    throwError \"'{declName}' does not have [{attrName}] attribute\"\n  return { s with erased := s.erased.insert declName, declNames := s.declNames.erase declName }", "start": [101, 1], "end": [104, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.init", "code": "protected unsafe def init {\u03b3} (df : Def \u03b3) (attrDeclName : Name := by exact decl_name%) : IO (KeyedDeclsAttribute \u03b3) := do\n  let tableRef \u2190 IO.mkRef ({} : Table \u03b3)\n  let ext : Extension \u03b3 \u2190 registerScopedEnvExtension {\n    name         := attrDeclName\n    mkInitial    := return mkStateOfTable (\u2190 tableRef.get)\n    ofOLeanEntry := fun _ entry => do\n      let ctx \u2190 read\n      match ctx.env.evalConstCheck \u03b3 ctx.opts df.valueTypeName entry.declName with\n      | Except.ok f     => return { toOLeanEntry := entry, value := f }\n      | Except.error ex => throw (IO.userError ex)\n    addEntry     := fun s e => s.insert e\n    toOLeanEntry := (\u00b7.toOLeanEntry)\n  }\n  unless df.builtinName.isAnonymous do\n    registerBuiltinAttribute {\n      ref   := attrDeclName\n      name  := df.builtinName\n      descr := \"(builtin) \" ++ df.descr\n      add   := fun declName stx kind => do\n        unless kind == AttributeKind.global do throwError \"invalid attribute '{df.builtinName}', must be global\"\n        let key \u2190 df.evalKey true stx\n        let decl \u2190 getConstInfo declName\n        match decl.type with\n        | Expr.const c _ =>\n          if c != df.valueTypeName then throwError \"unexpected type at '{declName}', '{df.valueTypeName}' expected\"\n          else\n            \n            let val := mkAppN (mkConst ``addBuiltin) #[mkConst df.valueTypeName, mkConst attrDeclName, toExpr key, toExpr declName, mkConst declName]\n            declareBuiltin declName val\n            df.onAdded true declName\n        | _ => throwError \"unexpected type at '{declName}', '{df.valueTypeName}' expected\"\n      applicationTime := AttributeApplicationTime.afterCompilation\n    }\n  registerBuiltinAttribute {\n    ref             := attrDeclName\n    name            := df.name\n    descr           := df.descr\n    erase           := fun declName => do\n      let s := ext.getState (\u2190 getEnv)\n      let s \u2190 s.erase df.name declName\n      modifyEnv fun env => ext.modifyState env fun _ => s\n    add             := fun declName stx attrKind => do\n      let key \u2190 df.evalKey false stx\n      match IR.getSorryDep (\u2190 getEnv) declName with\n      | none =>\n        let val \u2190 evalConstCheck \u03b3 df.valueTypeName declName\n        ext.add { key := key, declName := declName, value := val } attrKind\n        df.onAdded false declName\n      | _ =>\n        pure ()\n    applicationTime := AttributeApplicationTime.afterCompilation\n  }\n  pure { defn := df, tableRef := tableRef, ext := ext }", "start": [106, 1], "end": [159, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.getEntries", "code": "def getEntries {\u03b3} (attr : KeyedDeclsAttribute \u03b3) (env : Environment) (key : Name) : List (AttributeEntry \u03b3) :=\n  let s := attr.ext.getState env\n  let attrs := s.table.findD key []\n  if s.erased.isEmpty then\n    attrs\n  else\n    attrs.filter fun attr => !s.erased.contains attr.declName", "start": [161, 1], "end": [168, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.KeyedDeclsAttribute.getValues", "code": "def getValues {\u03b3} (attr : KeyedDeclsAttribute \u03b3) (env : Environment) (key : Name) : List \u03b3 :=\n  (getEntries attr env key).map AttributeEntry.value", "start": [170, 1], "end": [172, 53], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Extension.lean", "imports": ["lake-packages/lean4/src/lean/Lean/DocString.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/InitAttr.lean", "lake-packages/lean4/src/lean/Lean/Parser/Basic.lean", "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean"], "premises": [{"full_name": "Lean.Parser.registerBuiltinNodeKind", "code": "def registerBuiltinNodeKind (k : SyntaxNodeKind) : IO Unit :=\n  builtinSyntaxNodeKindSetRef.modify fun s => s.insert k", "start": [21, 1], "end": [22, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.throwParserCategoryAlreadyDefined", "code": "private def throwParserCategoryAlreadyDefined {\u03b1} (catName : Name) : ExceptT String Id \u03b1 :=\n  throw s!\"parser category '{catName}' has already been defined\"", "start": [35, 1], "end": [36, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addParserCategoryCore", "code": "private def addParserCategoryCore (categories : ParserCategories) (catName : Name) (initial : ParserCategory) : Except String ParserCategories :=\n  if categories.contains catName then\n    throwParserCategoryAlreadyDefined catName\n  else\n    pure $ categories.insert catName initial", "start": [38, 1], "end": [42, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addBuiltinParserCategory", "code": "private def addBuiltinParserCategory (catName declName : Name) (behavior : LeadingIdentBehavior) : IO Unit := do\n  let categories \u2190 builtinParserCategoriesRef.get\n  let categories \u2190 IO.ofExcept $ addParserCategoryCore categories catName { declName, behavior }\n  builtinParserCategoriesRef.set categories", "start": [44, 1], "end": [49, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserExtension.OLeanEntry", "code": "inductive OLeanEntry where\n  | token     (val : Token) : OLeanEntry\n  | kind      (val : SyntaxNodeKind) : OLeanEntry\n  | category  (catName : Name) (declName : Name) (behavior : LeadingIdentBehavior)\n  | parser    (catName : Name) (declName : Name) (prio : Nat) : OLeanEntry\n  deriving Inhabited", "start": [53, 1], "end": [58, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserExtension.Entry", "code": "inductive Entry where\n  | token     (val : Token) : Entry\n  | kind      (val : SyntaxNodeKind) : Entry\n  | category  (catName : Name) (declName : Name) (behavior : LeadingIdentBehavior)\n  | parser    (catName : Name) (declName : Name) (leading : Bool) (p : Parser) (prio : Nat) : Entry\n  deriving Inhabited", "start": [60, 1], "end": [65, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserExtension.Entry.toOLeanEntry", "code": "def Entry.toOLeanEntry : Entry \u2192 OLeanEntry\n  | token v             => OLeanEntry.token v\n  | kind v              => OLeanEntry.kind v\n  | category c d b      => OLeanEntry.category c d b\n  | parser c d _ _ prio => OLeanEntry.parser c d prio", "start": [67, 1], "end": [71, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserExtension.State", "code": "structure State where\n  tokens      : TokenTable := {}\n  kinds       : SyntaxNodeKindSet := {}\n  categories  : ParserCategories := {}\n  deriving Inhabited", "start": [73, 1], "end": [77, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserExtension", "code": "abbrev ParserExtension := ScopedEnvExtension OLeanEntry Entry State", "start": [82, 1], "end": [82, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserExtension.mkInitial", "code": "private def ParserExtension.mkInitial : IO ParserExtension.State := do\n  let tokens     \u2190 builtinTokenTable.get\n  let kinds      \u2190 builtinSyntaxNodeKindSetRef.get\n  let categories \u2190 builtinParserCategoriesRef.get\n  pure { tokens := tokens, kinds := kinds, categories := categories }", "start": [84, 1], "end": [88, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addTokenConfig", "code": "private def addTokenConfig (tokens : TokenTable) (tk : Token) : Except String TokenTable := do\n  if tk == \"\" then throw \"invalid empty symbol\"\n  else match tokens.find? tk with\n    | none   => pure $ tokens.insert tk tk\n    | some _ => pure tokens", "start": [90, 1], "end": [94, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.throwUnknownParserCategory", "code": "def throwUnknownParserCategory {\u03b1} (catName : Name) : ExceptT String Id \u03b1 :=\n  throw s!\"unknown parser category '{catName}'\"", "start": [96, 1], "end": [97, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getCategory", "code": "abbrev getCategory (categories : ParserCategories) (catName : Name) : Option ParserCategory :=\n  categories.find? catName", "start": [99, 1], "end": [100, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addLeadingParser", "code": "def addLeadingParser (categories : ParserCategories) (catName declName : Name) (p : Parser) (prio : Nat) : Except String ParserCategories :=\n  match getCategory categories catName with\n  | none     =>\n    throwUnknownParserCategory catName\n  | some cat =>\n    let kinds := cat.kinds.insert declName\n    let addTokens (tks : List Token) : Except String ParserCategories :=\n      let tks    := tks.map Name.mkSimple\n      let tables := tks.eraseDups.foldl (init := cat.tables) fun tables tk =>\n        { tables with leadingTable := tables.leadingTable.insert tk (p, prio) }\n      pure $ categories.insert catName { cat with kinds, tables }\n    match p.info.firstTokens with\n    | FirstTokens.tokens tks    => addTokens tks\n    | FirstTokens.optTokens tks => addTokens tks\n    | _ =>\n      let tables := { cat.tables with leadingParsers := (p, prio) :: cat.tables.leadingParsers }\n      pure $ categories.insert catName { cat with kinds, tables }", "start": [102, 1], "end": [118, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addTrailingParserAux", "code": "private def addTrailingParserAux (tables : PrattParsingTables) (p : TrailingParser) (prio : Nat) : PrattParsingTables :=\n  let addTokens (tks : List Token) : PrattParsingTables :=\n    let tks := tks.map fun tk => Name.mkSimple tk\n    tks.eraseDups.foldl (init := tables) fun tables tk =>\n      { tables with trailingTable := tables.trailingTable.insert tk (p, prio) }\n  match p.info.firstTokens with\n  | FirstTokens.tokens tks    => addTokens tks\n  | FirstTokens.optTokens tks => addTokens tks\n  | _                         => { tables with trailingParsers := (p, prio) :: tables.trailingParsers }", "start": [120, 1], "end": [128, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addTrailingParser", "code": "def addTrailingParser (categories : ParserCategories) (catName declName : Name) (p : TrailingParser) (prio : Nat) : Except String ParserCategories :=\n  match getCategory categories catName with\n  | none     => throwUnknownParserCategory catName\n  | some cat =>\n    let kinds := cat.kinds.insert declName\n    let tables := addTrailingParserAux cat.tables p prio\n    pure $ categories.insert catName { cat with kinds, tables }", "start": [130, 1], "end": [136, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addParser", "code": "def addParser (categories : ParserCategories) (catName declName : Name)\n    (leading : Bool) (p : Parser) (prio : Nat) : Except String ParserCategories := do\n  match leading, p with\n  | true, p  => addLeadingParser categories catName declName p prio\n  | false, p => addTrailingParser categories catName declName p prio", "start": [138, 1], "end": [142, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addParserTokens", "code": "def addParserTokens (tokenTable : TokenTable) (info : ParserInfo) : Except String TokenTable :=\n  let newTokens := info.collectTokens []\n  newTokens.foldlM addTokenConfig tokenTable", "start": [144, 1], "end": [146, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.updateBuiltinTokens", "code": "private def updateBuiltinTokens (info : ParserInfo) (declName : Name) : IO Unit := do\n  let tokenTable \u2190 builtinTokenTable.swap {}\n  match addParserTokens tokenTable info with\n  | Except.ok tokenTable => builtinTokenTable.set tokenTable\n  | Except.error msg     => throw (IO.userError s!\"invalid builtin parser '{declName}', {msg}\")", "start": [148, 1], "end": [152, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserExtension.addEntryImpl", "code": "def ParserExtension.addEntryImpl (s : State) (e : Entry) : State :=\n  match e with\n  | Entry.token tk =>\n    match addTokenConfig s.tokens tk with\n    | Except.ok tokens => { s with tokens }\n    | _                => unreachable!\n  | Entry.kind k =>\n    { s with kinds := s.kinds.insert k }\n  | Entry.category catName declName behavior =>\n    if s.categories.contains catName then s\n    else { s with\n           categories := s.categories.insert catName { declName, behavior } }\n  | Entry.parser catName declName leading parser prio =>\n    match addParser s.categories catName declName leading parser prio with\n    | Except.ok categories => { s with categories }\n    | _ => unreachable!", "start": [154, 1], "end": [169, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.AliasValue", "code": "inductive AliasValue (\u03b1 : Type) where\n  | const  (p : \u03b1)\n  | unary  (p : \u03b1 \u2192 \u03b1)\n  | binary (p : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "start": [171, 1], "end": [175, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.AliasTable", "code": "abbrev AliasTable (\u03b1) := NameMap (AliasValue \u03b1)", "start": [177, 1], "end": [177, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.registerAliasCore", "code": "def registerAliasCore {\u03b1} (mapRef : IO.Ref (AliasTable \u03b1)) (aliasName : Name) (value : AliasValue \u03b1) : IO Unit := do\n  unless (\u2190 initializing) do throw \u2191\"aliases can only be registered during initialization\"\n  if (\u2190 mapRef.get).contains aliasName then\n    throw \u2191s!\"alias '{aliasName}' has already been declared\"\n  mapRef.modify (\u00b7.insert aliasName value)", "start": [179, 1], "end": [183, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getAlias", "code": "def getAlias {\u03b1} (mapRef : IO.Ref (AliasTable \u03b1)) (aliasName : Name) : IO (Option (AliasValue \u03b1)) := do\n  return (\u2190 mapRef.get).find? aliasName", "start": [185, 1], "end": [186, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getConstAlias", "code": "def getConstAlias {\u03b1} (mapRef : IO.Ref (AliasTable \u03b1)) (aliasName : Name) : IO \u03b1 := do\n  match (\u2190 getAlias mapRef aliasName) with\n  | some (AliasValue.const v)  => pure v\n  | some (AliasValue.unary _)  => throw \u2191s!\"parser '{aliasName}' is not a constant, it takes one argument\"\n  | some (AliasValue.binary _) => throw \u2191s!\"parser '{aliasName}' is not a constant, it takes two arguments\"\n  | none   => throw \u2191s!\"parser '{aliasName}' was not found\"", "start": [188, 1], "end": [193, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getUnaryAlias", "code": "def getUnaryAlias {\u03b1} (mapRef : IO.Ref (AliasTable \u03b1)) (aliasName : Name) : IO (\u03b1 \u2192 \u03b1) := do\n  match (\u2190 getAlias mapRef aliasName) with\n  | some (AliasValue.unary v) => pure v\n  | some _ => throw \u2191s!\"parser '{aliasName}' does not take one argument\"\n  | none   => throw \u2191s!\"parser '{aliasName}' was not found\"", "start": [195, 1], "end": [199, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getBinaryAlias", "code": "def getBinaryAlias {\u03b1} (mapRef : IO.Ref (AliasTable \u03b1)) (aliasName : Name) : IO (\u03b1 \u2192 \u03b1 \u2192 \u03b1) := do\n  match (\u2190 getAlias mapRef aliasName) with\n  | some (AliasValue.binary v) => pure v\n  | some _ => throw \u2191s!\"parser '{aliasName}' does not take two arguments\"\n  | none   => throw \u2191s!\"parser '{aliasName}' was not found\"", "start": [201, 1], "end": [205, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserAliasValue", "code": "abbrev ParserAliasValue := AliasValue Parser", "start": [207, 1], "end": [207, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserAliasInfo", "code": "structure ParserAliasInfo where\n  declName : Name := .anonymous\n  \n  stackSz? : Option Nat := some 1\n  \n  autoGroupArgs : Bool := stackSz?.isSome", "start": [209, 1], "end": [214, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getParserAliasInfo", "code": "def getParserAliasInfo (aliasName : Name) : IO ParserAliasInfo := do\n  return (\u2190 parserAliases2infoRef.get).findD aliasName {}", "start": [220, 1], "end": [221, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.registerAlias", "code": "def registerAlias (aliasName declName : Name) (p : ParserAliasValue) (kind? : Option SyntaxNodeKind := none) (info : ParserAliasInfo := {}) : IO Unit := do\n  registerAliasCore parserAliasesRef aliasName p\n  if let some kind := kind? then\n    parserAlias2kindRef.modify (\u00b7.insert aliasName kind)\n  parserAliases2infoRef.modify (\u00b7.insert aliasName { info with declName })", "start": [224, 1], "end": [228, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.isParserAlias", "code": "def isParserAlias (aliasName : Name) : IO Bool := do\n  match (\u2190 getAlias parserAliasesRef aliasName) with\n  | some _ => pure true\n  | _      => pure false", "start": [234, 1], "end": [237, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getSyntaxKindOfParserAlias?", "code": "def getSyntaxKindOfParserAlias? (aliasName : Name) : IO (Option SyntaxNodeKind) :=\n  return (\u2190 parserAlias2kindRef.get).find? aliasName", "start": [239, 1], "end": [240, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ensureUnaryParserAlias", "code": "def ensureUnaryParserAlias (aliasName : Name) : IO Unit :=\n  discard $ getUnaryAlias parserAliasesRef aliasName", "start": [242, 1], "end": [243, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ensureBinaryParserAlias", "code": "def ensureBinaryParserAlias (aliasName : Name) : IO Unit :=\n  discard $ getBinaryAlias parserAliasesRef aliasName", "start": [245, 1], "end": [246, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ensureConstantParserAlias", "code": "def ensureConstantParserAlias (aliasName : Name) : IO Unit :=\n  discard $ getConstAlias parserAliasesRef aliasName", "start": [248, 1], "end": [249, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkParserOfConstantUnsafe", "code": "unsafe def mkParserOfConstantUnsafe (constName : Name) (compileParserDescr : ParserDescr \u2192 ImportM Parser) : ImportM (Bool \u00d7 Parser) := do\n  let env  := (\u2190 read).env\n  let opts := (\u2190 read).opts\n  match env.find? constName with\n  | none      => throw \u2191s!\"unknown constant '{constName}'\"\n  | some info =>\n    match info.type with\n    | Expr.const `Lean.Parser.TrailingParser _ =>\n      let p \u2190 IO.ofExcept $ env.evalConst Parser opts constName\n      pure \u27e8false, p\u27e9\n    | Expr.const `Lean.Parser.Parser _ =>\n      let p \u2190 IO.ofExcept $ env.evalConst Parser opts constName\n      pure \u27e8true, p\u27e9\n    | Expr.const `Lean.ParserDescr _ =>\n      let d \u2190 IO.ofExcept $ env.evalConst ParserDescr opts constName\n      let p \u2190 compileParserDescr d\n      pure \u27e8true, p\u27e9\n    | Expr.const `Lean.TrailingParserDescr _ =>\n      let d \u2190 IO.ofExcept $ env.evalConst TrailingParserDescr opts constName\n      let p \u2190 compileParserDescr d\n      pure \u27e8false, p\u27e9\n    | _ => throw \u2191s!\"unexpected parser type at '{constName}' (`ParserDescr`, `TrailingParserDescr`, `Parser` or `TrailingParser` expected)\"", "start": [251, 1], "end": [272, 140], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkParserOfConstantAux", "code": "@[implemented_by mkParserOfConstantUnsafe]\nopaque mkParserOfConstantAux (constName : Name) (compileParserDescr : ParserDescr \u2192 ImportM Parser) : ImportM (Bool \u00d7 Parser)", "start": [274, 1], "end": [275, 126], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.compileParserDescr", "code": "partial def compileParserDescr (categories : ParserCategories) (d : ParserDescr) : ImportM Parser :=\n  let rec visit : ParserDescr \u2192 ImportM Parser\n    | ParserDescr.const n                             => getConstAlias parserAliasesRef n\n    | ParserDescr.unary n d                           => return (\u2190 getUnaryAlias parserAliasesRef n) (\u2190 visit d)\n    | ParserDescr.binary n d\u2081 d\u2082                      => return (\u2190 getBinaryAlias parserAliasesRef n) (\u2190 visit d\u2081) (\u2190 visit d\u2082)\n    | ParserDescr.node k prec d                       => return leadingNode k prec (\u2190 visit d)\n    | ParserDescr.nodeWithAntiquot n k d              => return withCache k (nodeWithAntiquot n k (\u2190 visit d) (anonymous := true))\n    | ParserDescr.sepBy p sep psep trail              => return sepBy (\u2190 visit p) sep (\u2190 visit psep) trail\n    | ParserDescr.sepBy1 p sep psep trail             => return sepBy1 (\u2190 visit p) sep (\u2190 visit psep) trail\n    | ParserDescr.trailingNode k prec lhsPrec d       => return trailingNode k prec lhsPrec (\u2190 visit d)\n    | ParserDescr.symbol tk                           => return symbol tk\n    | ParserDescr.nonReservedSymbol tk includeIdent   => return nonReservedSymbol tk includeIdent\n    | ParserDescr.parser constName                    => do\n      let (_, p) \u2190 mkParserOfConstantAux constName visit;\n      pure p\n    | ParserDescr.cat catName prec                    =>\n      match getCategory categories catName with\n      | some _ => pure $ categoryParser catName prec\n      | none   => IO.ofExcept $ throwUnknownParserCategory catName\n  visit d", "start": [277, 1], "end": [296, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkParserOfConstant", "code": "def mkParserOfConstant (categories : ParserCategories) (constName : Name) : ImportM (Bool \u00d7 Parser) :=\n  mkParserOfConstantAux constName (compileParserDescr categories)", "start": [298, 1], "end": [299, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserAttributeHook", "code": "structure ParserAttributeHook where\n  \n  postAdd (catName : Name) (declName : Name) (builtin : Bool) : AttrM Unit", "start": [301, 1], "end": [303, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.registerParserAttributeHook", "code": "def registerParserAttributeHook (hook : ParserAttributeHook) : IO Unit := do\n  parserAttributeHooks.modify fun hooks => hook::hooks", "start": [307, 1], "end": [308, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.runParserAttributeHooks", "code": "def runParserAttributeHooks (catName : Name) (declName : Name) (builtin : Bool) : AttrM Unit := do\n  let hooks \u2190 parserAttributeHooks.get\n  hooks.forM fun hook => hook.postAdd catName declName builtin", "start": [310, 1], "end": [312, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserExtension.OLeanEntry.toEntry", "code": "private def ParserExtension.OLeanEntry.toEntry (s : State) : OLeanEntry \u2192 ImportM Entry\n  | token tk       => return Entry.token tk\n  | kind k         => return Entry.kind k\n  | category c d l => return Entry.category c d l\n  | parser catName declName prio => do\n    let (leading, p) \u2190 mkParserOfConstant s.categories declName\n    return Entry.parser catName declName leading p prio", "start": [332, 1], "end": [338, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.isParserCategory", "code": "def isParserCategory (env : Environment) (catName : Name) : Bool :=\n  (parserExtension.getState env).categories.contains catName", "start": [348, 1], "end": [349, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addParserCategory", "code": "def addParserCategory (env : Environment) (catName declName : Name) (behavior : LeadingIdentBehavior) : Except String Environment := do\n  if isParserCategory env catName then\n    throwParserCategoryAlreadyDefined catName\n  else\n    return parserExtension.addEntry env <| ParserExtension.Entry.category catName declName behavior", "start": [351, 1], "end": [355, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.leadingIdentBehavior", "code": "def leadingIdentBehavior (env : Environment) (catName : Name) : LeadingIdentBehavior :=\n  match getCategory (parserExtension.getState env).categories catName with\n  | none     => LeadingIdentBehavior.default\n  | some cat => cat.behavior", "start": [357, 1], "end": [360, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.evalParserConstUnsafe", "code": "unsafe def evalParserConstUnsafe (declName : Name) : ParserFn := fun ctx s => unsafeBaseIO do\n  let categories := (parserExtension.getState ctx.env).categories\n  match (\u2190 (mkParserOfConstant categories declName { env := ctx.env, opts := ctx.options }).toBaseIO) with\n  | .ok (_, p) =>\n    return adaptUncacheableContextFn (fun ctx => { ctx with tokens := p.info.collectTokens [] |>.foldl (fun tks tk => tks.insert tk tk) ctx.tokens }) p.fn ctx s\n  | .error e   => return s.mkUnexpectedError e.toString", "start": [362, 1], "end": [368, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.evalParserConst", "code": "@[implemented_by evalParserConstUnsafe]\nopaque evalParserConst (declName : Name) : ParserFn", "start": [370, 1], "end": [371, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.evalInsideQuot", "code": "def evalInsideQuot (declName : Name) : Parser \u2192 Parser := withFn fun f c s =>\n  if c.quotDepth > 0 && !c.suppressInsideQuot && internal.parseQuotWithCurrentStage.get c.options && c.env.contains declName then\n    evalParserConst declName c s\n  else\n    f c s", "start": [379, 1], "end": [384, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addBuiltinParser", "code": "def addBuiltinParser (catName : Name) (declName : Name) (leading : Bool) (p : Parser) (prio : Nat) : IO Unit := do\n  let p := evalInsideQuot declName p\n  let categories \u2190 builtinParserCategoriesRef.get\n  let categories \u2190 IO.ofExcept $ addParser categories catName declName leading p prio\n  builtinParserCategoriesRef.set categories\n  builtinSyntaxNodeKindSetRef.modify p.info.collectKinds\n  updateBuiltinTokens p.info declName", "start": [386, 1], "end": [392, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addBuiltinLeadingParser", "code": "def addBuiltinLeadingParser (catName : Name) (declName : Name) (p : Parser) (prio : Nat) : IO Unit :=\n  addBuiltinParser catName declName true p prio", "start": [394, 1], "end": [395, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addBuiltinTrailingParser", "code": "def addBuiltinTrailingParser (catName : Name) (declName : Name) (p : TrailingParser) (prio : Nat) : IO Unit :=\n  addBuiltinParser catName declName false p prio", "start": [397, 1], "end": [398, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkCategoryAntiquotParser", "code": "def mkCategoryAntiquotParser (kind : Name) : Parser :=\n  mkAntiquot kind.toString kind (isPseudoKind := true)", "start": [400, 1], "end": [401, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkCategoryAntiquotParserFn", "code": "@[inline] private def mkCategoryAntiquotParserFn (kind : Name) : ParserFn :=\n  (mkCategoryAntiquotParser kind).fn", "start": [404, 1], "end": [405, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.categoryParserFnImpl", "code": "def categoryParserFnImpl (catName : Name) : ParserFn := fun ctx s =>\n  let catName := if catName == `syntax then `stx else catName let categories := (parserExtension.getState ctx.env).categories\n  match getCategory categories catName with\n  | some cat =>\n    prattParser catName cat.tables cat.behavior (mkCategoryAntiquotParserFn catName) ctx s\n  | none     => s.mkUnexpectedError (\"unknown parser category '\" ++ toString catName ++ \"'\")", "start": [407, 1], "end": [413, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addToken", "code": "def addToken (tk : Token) (kind : AttributeKind) : AttrM Unit := do\n  discard <| ofExcept <| addTokenConfig (parserExtension.getState (\u2190 getEnv)).tokens tk\n  parserExtension.add (ParserExtension.Entry.token tk) kind", "start": [418, 1], "end": [422, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.addSyntaxNodeKind", "code": "def addSyntaxNodeKind (env : Environment) (k : SyntaxNodeKind) : Environment :=\n  parserExtension.addEntry env <| ParserExtension.Entry.kind k", "start": [424, 1], "end": [425, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.isValidSyntaxNodeKind", "code": "def isValidSyntaxNodeKind (env : Environment) (k : SyntaxNodeKind) : Bool :=\n  let kinds := (parserExtension.getState env).kinds\n  kinds.contains k || (Internal.isStage0 () && env.contains k)", "start": [427, 1], "end": [431, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getSyntaxNodeKinds", "code": "def getSyntaxNodeKinds (env : Environment) : List SyntaxNodeKind :=\n  let kinds := (parserExtension.getState env).kinds\n  kinds.foldl (fun ks k _ => k::ks) []", "start": [433, 1], "end": [435, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getTokenTable", "code": "def getTokenTable (env : Environment) : TokenTable :=\n  (parserExtension.getState env).tokens", "start": [437, 1], "end": [438, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkInputContext", "code": "def mkInputContext (input : String) (fileName : String) : InputContext := {\n  input    := input,\n  fileName := fileName,\n  fileMap  := input.toFileMap\n}", "start": [440, 1], "end": [444, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkParserState", "code": "def mkParserState (input : String) : ParserState :=\n  { cache := initCacheForInput input }", "start": [446, 1], "end": [447, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.runParserCategory", "code": "def runParserCategory (env : Environment) (catName : Name) (input : String) (fileName := \"<input>\") : Except String Syntax :=\n  let p := andthenFn whitespace (categoryParserFnImpl catName)\n  let ictx := mkInputContext input fileName\n  let s := p.run ictx { env, options := {} } (getTokenTable env) (mkParserState input)\n  if s.hasError then\n    Except.error (s.toErrorMsg ictx)\n  else if input.atEnd s.pos then\n    Except.ok s.stxStack.back\n  else\n    Except.error ((s.mkError \"end of input\").toErrorMsg ictx)", "start": [449, 1], "end": [459, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.declareBuiltinParser", "code": "def declareBuiltinParser (addFnName : Name) (catName : Name) (declName : Name) (prio : Nat) : CoreM Unit :=\n  let val := mkAppN (mkConst addFnName) #[toExpr catName, toExpr declName, mkConst declName, mkRawNatLit prio]\n  declareBuiltin declName val", "start": [461, 1], "end": [463, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.declareLeadingBuiltinParser", "code": "def declareLeadingBuiltinParser (catName : Name) (declName : Name) (prio : Nat) : CoreM Unit :=\n  declareBuiltinParser `Lean.Parser.addBuiltinLeadingParser catName declName prio", "start": [465, 1], "end": [466, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.declareTrailingBuiltinParser", "code": "def declareTrailingBuiltinParser (catName : Name) (declName : Name) (prio : Nat) : CoreM Unit :=\n  declareBuiltinParser `Lean.Parser.addBuiltinTrailingParser catName declName prio", "start": [468, 1], "end": [469, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.getParserPriority", "code": "def getParserPriority (args : Syntax) : Except String Nat :=\n  match args.getNumArgs with\n  | 0 => pure 0\n  | 1 => match (args.getArg 0).isNatLit? with\n    | some prio => pure prio\n    | none => throw \"invalid parser attribute, numeral expected\"\n  | _ => throw \"invalid parser attribute, no argument or numeral expected\"", "start": [471, 1], "end": [477, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.BuiltinParserAttribute.add", "code": "private def BuiltinParserAttribute.add (attrName : Name) (catName : Name)\n    (declName : Name) (stx : Syntax) (kind : AttributeKind) : AttrM Unit := do\n  let prio \u2190 Attribute.Builtin.getPrio stx\n  unless kind == AttributeKind.global do throwError \"invalid attribute '{attrName}', must be global\"\n  let decl \u2190 getConstInfo declName\n  match decl.type with\n  | Expr.const `Lean.Parser.TrailingParser _ =>\n    declareTrailingBuiltinParser catName declName prio\n  | Expr.const `Lean.Parser.Parser _ =>\n    declareLeadingBuiltinParser catName declName prio\n  | _ => throwError \"unexpected parser type at '{declName}' (`Parser` or `TrailingParser` expected)\"\n  if let some doc \u2190 findDocString? (\u2190 getEnv) declName (includeBuiltin := false) then\n    declareBuiltin (declName ++ `docString) (mkAppN (mkConst ``addBuiltinDocString) #[toExpr declName, toExpr doc])\n  if let some declRanges \u2190 findDeclarationRanges? declName then\n    declareBuiltin (declName ++ `declRange) (mkAppN (mkConst ``addBuiltinDeclarationRanges) #[toExpr declName, toExpr declRanges])\n  runParserAttributeHooks catName declName (builtin := true)", "start": [479, 1], "end": [494, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.registerBuiltinParserAttribute", "code": "def registerBuiltinParserAttribute (attrName declName : Name)\n    (behavior := LeadingIdentBehavior.default) : IO Unit := do\n  let .str ``Lean.Parser.Category s := declName\n    | throw (IO.userError \"`declName` should be in Lean.Parser.Category\")\n  let catName := Name.mkSimple s\n  addBuiltinParserCategory catName declName behavior\n  registerBuiltinAttribute {\n    ref             := declName\n    name            := attrName\n    descr           := \"Builtin parser\"\n    add             := fun declName stx kind => liftM $ BuiltinParserAttribute.add attrName catName declName stx kind\n    applicationTime := AttributeApplicationTime.afterCompilation\n  }", "start": [496, 1], "end": [511, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserAttribute.add", "code": "private def ParserAttribute.add (_attrName : Name) (catName : Name) (declName : Name) (stx : Syntax) (attrKind : AttributeKind) : AttrM Unit := do\n  let prio \u2190 Attribute.Builtin.getPrio stx\n  let env \u2190 getEnv\n  let categories := (parserExtension.getState env).categories\n  let p \u2190 mkParserOfConstant categories declName\n  let leading    := p.1\n  let parser     := p.2\n  let tokens     := parser.info.collectTokens []\n  tokens.forM fun token => do\n    try\n      addToken token attrKind\n    catch\n      | Exception.error _   msg => throwError \"invalid parser '{declName}', {msg}\"\n      | ex => throw ex\n  let kinds := parser.info.collectKinds {}\n  kinds.forM fun kind _ => modifyEnv fun env => addSyntaxNodeKind env kind\n  let entry := ParserExtension.Entry.parser catName declName leading parser prio\n  match addParser categories catName declName leading parser prio with\n  | Except.error ex => throwError ex\n  | Except.ok _     => parserExtension.add entry attrKind\n  runParserAttributeHooks catName declName (builtin := false)", "start": [513, 1], "end": [533, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkParserAttributeImpl", "code": "def mkParserAttributeImpl (attrName catName : Name) (ref : Name := by exact decl_name%) : AttributeImpl where\n  ref                       := ref\n  name                      := attrName\n  descr                     := \"parser\"\n  add declName stx attrKind := ParserAttribute.add attrName catName declName stx attrKind\n  applicationTime           := AttributeApplicationTime.afterCompilation", "start": [535, 1], "end": [540, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.registerBuiltinDynamicParserAttribute", "code": "def registerBuiltinDynamicParserAttribute (attrName catName : Name) (ref : Name := by exact decl_name%) : IO Unit := do\n  registerBuiltinAttribute (mkParserAttributeImpl attrName catName ref)", "start": [542, 1], "end": [544, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.registerParserCategory", "code": "def registerParserCategory (env : Environment) (attrName catName : Name)\n    (behavior := LeadingIdentBehavior.default) (ref : Name := by exact decl_name%) : IO Environment := do\n  let env \u2190 IO.ofExcept $ addParserCategory env catName ref behavior\n  registerAttributeOfBuilder env `parserAttr ref [DataValue.ofName attrName, DataValue.ofName catName]", "start": [552, 1], "end": [555, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.commandParser", "code": "@[inline] def commandParser (rbp : Nat := 0) : Parser :=\n  categoryParser `command rbp", "start": [568, 1], "end": [569, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withNamespaces", "code": "private def withNamespaces (ids : Array Name) (addOpenSimple : Bool) : ParserFn \u2192 ParserFn := adaptUncacheableContextFn fun c =>\n  let c := ids.foldl (init := c) fun c id =>\n    let nss := ResolveName.resolveNamespace c.env c.currNamespace c.openDecls id\n    let (env, openDecls) := nss.foldl (init := (c.env, c.openDecls)) fun (env, openDecls) ns =>\n      let openDecls := if addOpenSimple then OpenDecl.simple ns [] :: openDecls else openDecls\n      let env := parserExtension.activateScoped env ns\n      (env, openDecls)\n    { c with env, openDecls }\n  let tokens := parserExtension.getState c.env |>.tokens\n  { c with tokens }", "start": [571, 1], "end": [580, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withOpenDeclFnCore", "code": "def withOpenDeclFnCore (openDeclStx : Syntax) (p : ParserFn) : ParserFn := fun c s =>\n  if openDeclStx.getKind == `Lean.Parser.Command.openSimple then\n    withNamespaces (openDeclStx[0].getArgs.map fun stx => stx.getId) (addOpenSimple := true) p c s\n  else if openDeclStx.getKind == `Lean.Parser.Command.openScoped then\n    withNamespaces (openDeclStx[1].getArgs.map fun stx => stx.getId) (addOpenSimple := false) p c s\n  else if openDeclStx.getKind == `Lean.Parser.Command.openOnly then\n    p c s\n  else if openDeclStx.getKind == `Lean.Parser.Command.openHiding then\n    p c s\n  else\n    p c s", "start": [582, 1], "end": [594, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withOpenFn", "code": "def withOpenFn (p : ParserFn) : ParserFn := fun c s =>\n  if s.stxStack.size > 0 then\n    let stx := s.stxStack.back\n    if stx.getKind == `Lean.Parser.Command.open then\n      withOpenDeclFnCore stx[1] p c s\n    else\n      p c s\n  else\n    p c s", "start": [596, 1], "end": [605, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withOpen", "code": "@[inline] def withOpen : Parser \u2192 Parser := withFn withOpenFn", "start": [608, 1], "end": [608, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withOpenDeclFn", "code": "def withOpenDeclFn (p : ParserFn) : ParserFn := fun c s =>\n  if s.stxStack.size > 0 then\n    let stx := s.stxStack.back\n    withOpenDeclFnCore stx p c s\n  else\n    p c s", "start": [610, 1], "end": [616, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.withOpenDecl", "code": "@[inline] def withOpenDecl : Parser \u2192 Parser := withFn withOpenDeclFn", "start": [618, 1], "end": [618, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserName", "code": "inductive ParserName\n  | category (cat : Name)\n  | parser (decl : Name) (isDescr : Bool)\n  deriving Repr", "start": [620, 1], "end": [624, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.resolveParserNameCore", "code": "def resolveParserNameCore (env : Environment) (currNamespace : Name)\n    (openDecls : List OpenDecl) (ident : Ident) : List ParserName := Id.run do\n  let \u27e8.ident (val := val) (preresolved := pre) ..\u27e9 := ident | return []\n\n  let rec isParser (name : Name) : Option Bool :=\n    (env.find? name).bind fun ci =>\n      match ci.type with\n      | .const ``Parser _ | .const ``TrailingParser _ => some false\n      | .const ``ParserDescr _ | .const ``TrailingParserDescr _ => some true\n      | _ => none\n\n  for pre in pre do\n    if let .decl n [] := pre then\n      if let some isDescr := isParser n then\n        return [.parser n isDescr]\n\n  let erased := val.eraseMacroScopes\n\n  if isParserCategory env erased then\n    return [.category erased]\n\n  ResolveName.resolveGlobalName env currNamespace openDecls val |>.filterMap fun\n      | (name, []) => (isParser name).map fun isDescr => .parser name isDescr\n      | _ => none", "start": [626, 1], "end": [650, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ParserContext.resolveParserName", "code": "def ParserContext.resolveParserName (ctx : ParserContext) (id : Ident) : List ParserName :=\n  Parser.resolveParserNameCore ctx.env ctx.currNamespace ctx.openDecls id", "start": [652, 1], "end": [654, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.resolveParserName", "code": "def resolveParserName (id : Ident) : CoreM (List ParserName) :=\n  return resolveParserNameCore (\u2190 getEnv) (\u2190 getCurrNamespace) (\u2190 getOpenDecls) id", "start": [656, 1], "end": [658, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.parserOfStackFn", "code": "def parserOfStackFn (offset : Nat) : ParserFn := fun ctx s => Id.run do\n  let stack := s.stxStack\n  if stack.size < offset + 1 then\n    return s.mkUnexpectedError (\"failed to determine parser using syntax stack, stack is too small\")\n  let parserName@(.ident ..) := stack.get! (stack.size - offset - 1)\n    | s.mkUnexpectedError (\"failed to determine parser using syntax stack, the specified element on the stack is not an identifier\")\n  match ctx.resolveParserName \u27e8parserName\u27e9 with\n  | [.category cat] =>\n    categoryParserFn cat ctx s\n  | [.parser parserName _] =>\n    let iniSz := s.stackSize\n    let s := adaptUncacheableContextFn (fun ctx =>\n      if !internal.parseQuotWithCurrentStage.get ctx.options then\n        { ctx with options := ctx.options.setBool `interpreter.prefer_native true }\n      else ctx) (evalParserConst parserName) ctx s\n    if !s.hasError && s.stackSize != iniSz + 1 then\n      s.mkUnexpectedError \"expected parser to return exactly one syntax object\"\n    else\n      s\n  | _::_::_ => s.mkUnexpectedError s!\"ambiguous parser name {parserName}\"\n  | [] => s.mkUnexpectedError s!\"unknown parser {parserName}\"", "start": [660, 1], "end": [682, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.parserOfStack", "code": "def parserOfStack (offset : Nat) (prec : Nat := 0) : Parser where\n  fn := adaptCacheableContextFn ({ \u00b7 with prec }) (parserOfStackFn offset)", "start": [684, 1], "end": [685, 75], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/StrInterpolation.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.isQuotableCharForStrInterpolant", "code": "def isQuotableCharForStrInterpolant (c : Char) : Bool :=\n  c == '{' || isQuotableCharDefault c", "start": [9, 1], "end": [10, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.interpolatedStrFn", "code": "partial def interpolatedStrFn (p : ParserFn) : ParserFn := fun c s =>\n  let input     := c.input\n  let stackSize := s.stackSize\n  let rec parse (startPos : String.Pos) (c : ParserContext) (s : ParserState) : ParserState :=\n    let i     := s.pos\n    if input.atEnd i then\n      let s := s.mkError \"unterminated string literal\"\n      s.mkNode interpolatedStrKind stackSize\n    else\n      let curr := input.get i\n      let s    := s.setPos (input.next i)\n      if curr == '\\\"' then\n        let s := mkNodeToken interpolatedStrLitKind startPos c s\n        s.mkNode interpolatedStrKind stackSize\n      else if curr == '\\\\' then\n        andthenFn (quotedCharCoreFn isQuotableCharForStrInterpolant) (parse startPos) c s\n      else if curr == '{' then\n        let s := mkNodeToken interpolatedStrLitKind startPos c s\n        let s := p c s\n        if s.hasError then s\n        else\n          let i := s.pos\n          let curr := input.get i\n          if curr == '}' then\n            let s := s.setPos (input.next i)\n            parse i c s\n          else\n            let s := s.mkError \"'}'\"\n            s.mkNode interpolatedStrKind stackSize\n      else\n        parse startPos c s\n  let startPos := s.pos\n  if input.atEnd startPos then\n    s.mkEOIError\n  else\n    let curr  := input.get s.pos;\n    if curr != '\\\"' then\n      s.mkError \"interpolated string\"\n    else\n      let s := s.next input startPos\n      parse startPos c s", "start": [12, 1], "end": [52, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.interpolatedStrNoAntiquot", "code": "@[inline] def interpolatedStrNoAntiquot (p : Parser) : Parser := {\n  fn   := interpolatedStrFn (withoutPosition p).fn,\n  info := mkAtomicInfo \"interpolatedStr\"\n}", "start": [54, 1], "end": [57, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.interpolatedStr", "code": "def interpolatedStr (p : Parser) : Parser :=\n  withAntiquot (mkAntiquot \"interpolatedStr\" interpolatedStrKind) $ interpolatedStrNoAntiquot p", "start": [59, 1], "end": [71, 96], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/ParserCompiler/Attribute.lean", "imports": ["lake-packages/lean4/src/lean/Lean/ToExpr.lean", "lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Lean/Compiler/InitAttr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ParserCompiler.CombinatorAttribute", "code": "structure CombinatorAttribute where\n  impl : AttributeImpl\n  ext  : SimplePersistentEnvExtension (Name \u00d7 Name) (NameMap Name)\n  deriving Inhabited", "start": [14, 1], "end": [17, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.registerCombinatorAttribute", "code": "def registerCombinatorAttribute (name : Name) (descr : String) (ref : Name := by exact decl_name%)\n    : IO CombinatorAttribute := do\n  let ext : SimplePersistentEnvExtension (Name \u00d7 Name) (NameMap Name) \u2190 registerSimplePersistentEnvExtension {\n    name            := ref,\n    addImportedFn   := mkStateFromImportedEntries (fun s p => s.insert p.1 p.2) {},\n    addEntryFn      := fun (s : NameMap Name) (p : Name \u00d7 Name) => s.insert p.1 p.2,\n  }\n  let attrImpl : AttributeImpl := {\n    ref   := ref,\n    name  := name,\n    descr := descr,\n    add   := fun decl stx _ => do\n      let env \u2190 getEnv\n      let parserDeclName \u2190 Elab.resolveGlobalConstNoOverloadWithInfo (\u2190 Attribute.Builtin.getIdent stx)\n      setEnv <| ext.addEntry env (parserDeclName, decl)\n  }\n  registerBuiltinAttribute attrImpl\n  pure { impl := attrImpl, ext := ext }", "start": [20, 1], "end": [37, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.CombinatorAttribute.getDeclFor?", "code": "def getDeclFor? (attr : CombinatorAttribute) (env : Environment) (parserDecl : Name) : Option Name :=\n  (attr.ext.getState env).find? parserDecl", "start": [41, 1], "end": [42, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.CombinatorAttribute.setDeclFor", "code": "def setDeclFor (attr : CombinatorAttribute) (env : Environment) (parserDecl : Name) (decl : Name) : Environment :=\n  attr.ext.addEntry env (parserDecl, decl)", "start": [44, 1], "end": [45, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.CombinatorAttribute.runDeclFor", "code": "unsafe def runDeclFor {\u03b1} (attr : CombinatorAttribute) (parserDecl : Name) : CoreM \u03b1 := do\n  match attr.getDeclFor? (\u2190 getEnv) parserDecl with\n  | some d => evalConst \u03b1 d\n  | _      => throwError \"no declaration of attribute [{attr.impl.name}] found for '{parserDecl}'\"", "start": [47, 1], "end": [50, 99], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/KeyedDeclsAttribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PrettyPrinter.runForNodeKind", "code": "unsafe def runForNodeKind {\u03b1} (attr : KeyedDeclsAttribute \u03b1) (k : SyntaxNodeKind) (interp : ParserDescr \u2192 CoreM \u03b1) : CoreM \u03b1 := do\n  match attr.getValues (\u2190 getEnv) k with\n  | p::_ => pure p\n  | _ =>\n    let info \u2190 getConstInfo k\n    if info.type.isConstOf ``ParserDescr || info.type.isConstOf ``TrailingParserDescr then\n      let d \u2190 evalConst ParserDescr k\n      interp d\n    else\n      throwError \"no declaration of attribute [{attr.defn.name}] found for '{k}'\"", "start": [15, 1], "end": [25, 82], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Parenthesizer.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter/Basic.lean", "lake-packages/lean4/src/lean/Lean/ParserCompiler/Attribute.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Parser/StrInterpolation.lean", "lake-packages/lean4/src/lean/Lean/Parser/Extension.lean"], "premises": [{"full_name": "Lean.PrettyPrinter.Parenthesizer.Context", "code": "structure Context where\n  cat : Name := Name.anonymous", "start": [83, 1], "end": [85, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.State", "code": "structure State where\n  stxTrav : Syntax.Traverser\n  contPrec : Option Nat := none\n  contCat : Name := Name.anonymous\n  minPrec : Option Nat := none\n  trailPrec : Option Nat := none\n  trailCat : Name := Name.anonymous\n  visitedToken : Bool := false", "start": [87, 1], "end": [98, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ParenthesizerM", "code": "abbrev ParenthesizerM := ReaderT Parenthesizer.Context $ StateRefT Parenthesizer.State CoreM", "start": [102, 1], "end": [102, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer", "code": "abbrev Parenthesizer := ParenthesizerM Unit", "start": [103, 1], "end": [103, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ParenthesizerM.orElse", "code": "@[inline] def ParenthesizerM.orElse (p\u2081 : ParenthesizerM \u03b1) (p\u2082 : Unit \u2192 ParenthesizerM \u03b1) : ParenthesizerM \u03b1 := do\n  let s \u2190 get\n  catchInternalId backtrackExceptionId\n    p\u2081\n    (fun _ => do set s; p\u2082 ())", "start": [105, 1], "end": [109, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.mkParenthesizerAttribute", "code": "unsafe def mkParenthesizerAttribute : IO (KeyedDeclsAttribute Parenthesizer) :=\n  KeyedDeclsAttribute.init {\n    builtinName := `builtin_parenthesizer,\n    name := `parenthesizer,\n    descr := \"Register a parenthesizer for a parser.\n\n  [parenthesizer k] registers a declaration of type `Lean.PrettyPrinter.Parenthesizer` for the `SyntaxNodeKind` `k`.\",\n    valueTypeName := `Lean.PrettyPrinter.Parenthesizer,\n    evalKey := fun builtin stx => do\n      let env \u2190 getEnv\n      let stx \u2190 Attribute.Builtin.getIdent stx\n      let id := stx.getId\n      unless (builtin && (env.find? id).isSome) || Parser.isValidSyntaxNodeKind env id do\n        throwError \"invalid [parenthesizer] argument, unknown syntax kind '{id}'\"\n      if (\u2190 getEnv).contains id && (\u2190 Elab.getInfoState).enabled then\n        Elab.addConstInfo stx id none\n      pure id\n  } `Lean.PrettyPrinter.parenthesizerAttribute", "start": [113, 1], "end": [132, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.parenthesizerAttribute", "code": "@[builtin_init mkParenthesizerAttribute] opaque parenthesizerAttribute : KeyedDeclsAttribute Parenthesizer", "start": [133, 1], "end": [133, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.CategoryParenthesizer", "code": "abbrev CategoryParenthesizer := (prec : Nat) \u2192 Parenthesizer", "start": [135, 1], "end": [135, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.mkCategoryParenthesizerAttribute", "code": "unsafe def mkCategoryParenthesizerAttribute : IO (KeyedDeclsAttribute CategoryParenthesizer) :=\n  KeyedDeclsAttribute.init {\n    builtinName := `builtin_category_parenthesizer,\n    name := `category_parenthesizer,\n    descr := \"Register a parenthesizer for a syntax category.\n\n  [category_parenthesizer cat] registers a declaration of type `Lean.PrettyPrinter.CategoryParenthesizer` for the category `cat`,\n  which is used when parenthesizing calls of `categoryParser cat prec`. Implementations should call `maybeParenthesize`\n  with the precedence and `cat`. If no category parenthesizer is registered, the category will never be parenthesized,\n  but still be traversed for parenthesizing nested categories.\",\n    valueTypeName := `Lean.PrettyPrinter.CategoryParenthesizer,\n    evalKey := fun _ stx => do\n      let env \u2190 getEnv\n      let stx \u2190 Attribute.Builtin.getIdent stx\n      let id := stx.getId\n      let some cat := (Parser.parserExtension.getState env).categories.find? id\n        | throwError \"invalid [category_parenthesizer] argument, unknown parser category '{toString id}'\"\n      if (\u2190 Elab.getInfoState).enabled && (\u2190 getEnv).contains cat.declName then\n        Elab.addConstInfo stx cat.declName none\n      pure id\n  } `Lean.PrettyPrinter.categoryParenthesizerAttribute", "start": [137, 1], "end": [157, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.categoryParenthesizerAttribute", "code": "@[builtin_init mkCategoryParenthesizerAttribute] opaque categoryParenthesizerAttribute : KeyedDeclsAttribute CategoryParenthesizer", "start": [158, 1], "end": [158, 131], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.mkCombinatorParenthesizerAttribute", "code": "unsafe def mkCombinatorParenthesizerAttribute : IO ParserCompiler.CombinatorAttribute :=\n  ParserCompiler.registerCombinatorAttribute\n    `combinator_parenthesizer\n    \"Register a parenthesizer for a parser combinator.\n\n  [combinator_parenthesizer c] registers a declaration of type `Lean.PrettyPrinter.Parenthesizer` for the `Parser` declaration `c`.\n  Note that, unlike with [parenthesizer], this is not a node kind since combinators usually do not introduce their own node kinds.\n  The tagged declaration may optionally accept parameters corresponding to (a prefix of) those of `c`, where `Parser` is replaced\n  with `Parenthesizer` in the parameter types.\"", "start": [160, 1], "end": [168, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.combinatorParenthesizerAttribute", "code": "@[builtin_init mkCombinatorParenthesizerAttribute] opaque combinatorParenthesizerAttribute : ParserCompiler.CombinatorAttribute", "start": [169, 1], "end": [169, 128], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.throwBacktrack", "code": "def throwBacktrack {\u03b1} : ParenthesizerM \u03b1 :=\nthrow $ Exception.internal backtrackExceptionId", "start": [176, 1], "end": [177, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.addPrecCheck", "code": "def addPrecCheck (prec : Nat) : ParenthesizerM Unit :=\n  modify fun st => { st with contPrec := Nat.min (st.contPrec.getD prec) prec, minPrec := Nat.min (st.minPrec.getD prec) prec }", "start": [187, 1], "end": [188, 128], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.visitArgs", "code": "def visitArgs (x : ParenthesizerM Unit) : ParenthesizerM Unit := do\n  let stx \u2190 getCur\n  if stx.getArgs.size > 0 then\n    goDown (stx.getArgs.size - 1) *> x <* goUp\n  goLeft", "start": [190, 1], "end": [195, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.maybeParenthesize", "code": "def maybeParenthesize (cat : Name) (canJuxtapose : Bool) (mkParen : Syntax \u2192 Syntax) (prec : Nat) (x : ParenthesizerM Unit) : ParenthesizerM Unit := do\n  let stx \u2190 getCur\n  let idx \u2190 getIdx\n  let st \u2190 get\n  set { stxTrav := st.stxTrav : State }\n  trace[PrettyPrinter.parenthesize] \"parenthesizing (cont := {(st.contPrec, st.contCat)}){indentD (format stx)}\"\n  x\n  let { minPrec := some minPrec, trailPrec := trailPrec, trailCat := trailCat, .. } \u2190 get\n    | trace[PrettyPrinter.parenthesize] \"visited a syntax tree without precedences?!{line ++ format stx}\"\n  trace[PrettyPrinter.parenthesize] (m!\"...precedences are {prec} >? {minPrec}\" ++ if canJuxtapose then m!\", {(trailPrec, trailCat)} <=? {(st.contPrec, st.contCat)}\" else \"\")\n  if (prec > minPrec || canJuxtapose && match trailPrec, st.contPrec with | some trailPrec, some contPrec => trailCat == st.contCat && trailPrec <= contPrec | _, _ => false) then\n      if idx > 0 then goRight\n      let mut stx \u2190 getCur\n      if let SourceInfo.original _ pos trail endPos := stx.getHeadInfo then\n        stx := stx.setHeadInfo (SourceInfo.original \"\".toSubstring pos trail endPos)\n      if let SourceInfo.original lead pos _ endPos := stx.getTailInfo then\n        stx := stx.setTailInfo (SourceInfo.original lead pos \"\".toSubstring endPos)\n      let mut stx' := mkParen stx\n      if let SourceInfo.original lead pos _ endPos := stx.getHeadInfo then\n        stx' := stx'.setHeadInfo (SourceInfo.original lead pos \"\".toSubstring endPos)\n      if let SourceInfo.original _ pos trail endPos := stx.getTailInfo then\n        stx' := stx'.setTailInfo (SourceInfo.original \"\".toSubstring pos trail endPos)\n      trace[PrettyPrinter.parenthesize] \"parenthesized: {stx'.formatStx none}\"\n      setCur stx'\n      goLeft\n      modify (fun st => { st with contPrec := Parser.maxPrec, contCat := cat, trailPrec := none })\n  let { trailPrec := trailPrec, .. } \u2190 get\n  if st.visitedToken then\n    modify fun stP => { stP with trailPrec := st.trailPrec, trailCat := st.trailCat }\n  else\n    let trailPrec := match trailPrec with\n    | some trailPrec => Nat.min trailPrec prec\n    | _              => prec\n    modify fun stP => { stP with trailPrec := trailPrec, trailCat := cat }\n  modify fun stP => { stP with minPrec := st.minPrec }", "start": [205, 1], "end": [251, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.visitToken", "code": "def visitToken : Parenthesizer := do\n  modify fun st => { st with contPrec := none, contCat := Name.anonymous, visitedToken := true }\n  goLeft", "start": [253, 1], "end": [256, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer", "code": "@[combinator_parenthesizer orelse] partial def orelse.parenthesizer (p1 p2 : Parenthesizer) : Parenthesizer := do\n  let stx \u2190 getCur\n  if stx.getKind == `choice then\n    visitArgs $ stx.getArgs.size.forM fun _ => do\n      orelse.parenthesizer p1 p2\n  else\n    p1 <|> p2", "start": [258, 1], "end": [267, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.mkAntiquot.parenthesizer'", "code": "@[extern \"lean_mk_antiquot_parenthesizer\"]\nopaque mkAntiquot.parenthesizer' (name : String) (kind : SyntaxNodeKind) (anonymous := true) (isPseudoKind := false) : Parenthesizer", "start": [273, 1], "end": [274, 133], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.liftCoreM", "code": "@[inline] def liftCoreM {\u03b1} (x : CoreM \u03b1) : ParenthesizerM \u03b1 :=\n  liftM x", "start": [276, 1], "end": [277, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.interpretParserDescr'", "code": "@[extern \"lean_pretty_printer_parenthesizer_interpret_parser_descr\"]\nopaque interpretParserDescr' : ParserDescr \u2192 CoreM Parenthesizer", "start": [280, 1], "end": [281, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.parenthesizerForKindUnsafe", "code": "unsafe def parenthesizerForKindUnsafe (k : SyntaxNodeKind) : Parenthesizer := do\n  if k == `missing then\n    pure ()\n  else\n    let p \u2190 runForNodeKind parenthesizerAttribute k interpretParserDescr'\n    p", "start": [283, 1], "end": [288, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.parenthesizerForKind", "code": "@[implemented_by parenthesizerForKindUnsafe]\nopaque parenthesizerForKind (k : SyntaxNodeKind) : Parenthesizer", "start": [290, 1], "end": [291, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer", "code": "@[combinator_parenthesizer withAntiquot]\ndef withAntiquot.parenthesizer (antiP p : Parenthesizer) : Parenthesizer := do\n  let stx \u2190 getCur\n  if stx.isAntiquot || stx.isAntiquotSplice then\n    orelse.parenthesizer antiP p\n  else\n    p", "start": [293, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.withAntiquotSuffixSplice.parenthesizer", "code": "@[combinator_parenthesizer withAntiquotSuffixSplice]\ndef withAntiquotSuffixSplice.parenthesizer (_ : SyntaxNodeKind) (p suffix : Parenthesizer) : Parenthesizer := do\n  if (\u2190 getCur).isAntiquotSuffixSplice then\n    visitArgs <| suffix *> p\n  else\n    p", "start": [302, 1], "end": [307, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer", "code": "@[combinator_parenthesizer tokenWithAntiquot]\ndef tokenWithAntiquot.parenthesizer (p : Parenthesizer) : Parenthesizer := do\n  if (\u2190 getCur).isTokenAntiquot then\n    visitArgs p\n  else\n    p", "start": [309, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore", "code": "partial def parenthesizeCategoryCore (cat : Name) (_prec : Nat) : Parenthesizer :=\n  withReader (fun ctx => { ctx with cat := cat }) do\n    let stx \u2190 getCur\n    if stx.getKind == `choice then\n      visitArgs $ stx.getArgs.size.forM fun _ => do\n        parenthesizeCategoryCore cat _prec\n    else\n      withAntiquot.parenthesizer (mkAntiquot.parenthesizer' cat.toString cat (isPseudoKind := true)) (parenthesizerForKind stx.getKind)\n    modify fun st => { st with contCat := cat }", "start": [316, 1], "end": [324, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer", "code": "@[combinator_parenthesizer categoryParser]\ndef categoryParser.parenthesizer (cat : Name) (prec : Nat) : Parenthesizer := do\n  let env \u2190 getEnv\n  match categoryParenthesizerAttribute.getValues env cat with\n  | p::_ => p prec\n  | _    => parenthesizeCategoryCore cat prec", "start": [326, 1], "end": [333, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.parserOfStack.parenthesizer", "code": "@[combinator_parenthesizer parserOfStack]\ndef parserOfStack.parenthesizer (offset : Nat) (_prec : Nat := 0) : Parenthesizer := do\n  let st \u2190 get\n  let stx := st.stxTrav.parents.back.getArg (st.stxTrav.idxs.back - offset)\n  parenthesizerForKind stx.getKind", "start": [335, 1], "end": [339, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.term.parenthesizer", "code": "@[builtin_category_parenthesizer term]\ndef term.parenthesizer : CategoryParenthesizer | prec => do\n  maybeParenthesize `term true (fun stx => Unhygienic.run `(($(\u27e8stx\u27e9)))) prec $\n    parenthesizeCategoryCore `term prec", "start": [341, 1], "end": [344, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.tactic.parenthesizer", "code": "@[builtin_category_parenthesizer tactic]\ndef tactic.parenthesizer : CategoryParenthesizer | prec => do\n  maybeParenthesize `tactic false (fun stx => Unhygienic.run `(tactic|($(\u27e8stx\u27e9)))) prec $\n    parenthesizeCategoryCore `tactic prec", "start": [346, 1], "end": [349, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.level.parenthesizer", "code": "@[builtin_category_parenthesizer level]\ndef level.parenthesizer : CategoryParenthesizer | prec => do\n  maybeParenthesize `level false (fun stx => Unhygienic.run `(level|($(\u27e8stx\u27e9)))) prec $\n    parenthesizeCategoryCore `level prec", "start": [351, 1], "end": [354, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.rawStx.parenthesizer", "code": "@[builtin_category_parenthesizer rawStx]\ndef rawStx.parenthesizer : CategoryParenthesizer | _ => do\n  goLeft", "start": [356, 1], "end": [358, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.error.parenthesizer", "code": "@[combinator_parenthesizer error]\ndef error.parenthesizer (_msg : String) : Parenthesizer :=\n  pure ()", "start": [360, 1], "end": [362, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.errorAtSavedPos.parenthesizer", "code": "@[combinator_parenthesizer errorAtSavedPos]\ndef errorAtSavedPos.parenthesizer (_msg : String) (_delta : Bool) : Parenthesizer :=\n  pure ()", "start": [364, 1], "end": [366, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer", "code": "@[combinator_parenthesizer atomic]\ndef atomic.parenthesizer (p : Parenthesizer) : Parenthesizer :=\n  p", "start": [368, 1], "end": [370, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer", "code": "@[combinator_parenthesizer lookahead]\ndef lookahead.parenthesizer (_ : Parenthesizer) : Parenthesizer :=\n  pure ()", "start": [372, 1], "end": [374, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer", "code": "@[combinator_parenthesizer notFollowedBy]\ndef notFollowedBy.parenthesizer (_ : Parenthesizer) : Parenthesizer :=\n  pure ()", "start": [376, 1], "end": [378, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer", "code": "@[combinator_parenthesizer andthen]\ndef andthen.parenthesizer (p1 p2 : Parenthesizer) : Parenthesizer :=\n  p2 *> p1", "start": [380, 1], "end": [382, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkKind", "code": "def checkKind (k : SyntaxNodeKind) : Parenthesizer := do\n  let stx \u2190 getCur\n  if k != stx.getKind then\n    trace[PrettyPrinter.parenthesize.backtrack] \"unexpected node kind '{stx.getKind}', expected '{k}'\"\n    throwBacktrack", "start": [384, 1], "end": [389, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.node.parenthesizer", "code": "@[combinator_parenthesizer node]\ndef node.parenthesizer (k : SyntaxNodeKind) (p : Parenthesizer) : Parenthesizer := do\n  checkKind k\n  visitArgs p", "start": [391, 1], "end": [394, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer", "code": "@[combinator_parenthesizer checkPrec]\ndef checkPrec.parenthesizer (prec : Nat) : Parenthesizer :=\n  addPrecCheck prec", "start": [396, 1], "end": [398, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.withFn.parenthesizer", "code": "@[combinator_parenthesizer withFn]\ndef withFn.parenthesizer (_ : ParserFn \u2192 ParserFn) (p : Parenthesizer) : Parenthesizer := p", "start": [400, 1], "end": [401, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer", "code": "@[combinator_parenthesizer leadingNode]\ndef leadingNode.parenthesizer (k : SyntaxNodeKind) (prec : Nat) (p : Parenthesizer) : Parenthesizer := do\n  node.parenthesizer k p\n  addPrecCheck prec\n  modify fun st => { st with contPrec := Nat.min (Parser.maxPrec-1) prec }", "start": [403, 1], "end": [410, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer", "code": "@[combinator_parenthesizer trailingNode]\ndef trailingNode.parenthesizer (k : SyntaxNodeKind) (prec lhsPrec : Nat) (p : Parenthesizer) : Parenthesizer := do\n  checkKind k\n  visitArgs do\n    p\n    addPrecCheck prec\n    let ctx \u2190 read\n    modify fun st => { st with contCat := ctx.cat }\n    categoryParser.parenthesizer ctx.cat lhsPrec", "start": [412, 1], "end": [424, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.rawCh.parenthesizer", "code": "@[combinator_parenthesizer rawCh] def rawCh.parenthesizer (_ch : Char) := visitToken", "start": [426, 1], "end": [426, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.symbolNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer symbolNoAntiquot] def symbolNoAntiquot.parenthesizer (_sym : String) := visitToken", "start": [428, 1], "end": [428, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.unicodeSymbolNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer unicodeSymbolNoAntiquot] def unicodeSymbolNoAntiquot.parenthesizer (_sym _asciiSym : String) := visitToken", "start": [429, 1], "end": [429, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.identNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer identNoAntiquot] def identNoAntiquot.parenthesizer := do checkKind identKind; visitToken", "start": [431, 1], "end": [431, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.rawIdentNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer rawIdentNoAntiquot] def rawIdentNoAntiquot.parenthesizer := visitToken", "start": [432, 1], "end": [432, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.identEq.parenthesizer", "code": "@[combinator_parenthesizer identEq] def identEq.parenthesizer (_id : Name) := visitToken", "start": [433, 1], "end": [433, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.nonReservedSymbolNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer nonReservedSymbolNoAntiquot] def nonReservedSymbolNoAntiquot.parenthesizer (_sym : String) (_includeIdent : Bool) := visitToken", "start": [434, 1], "end": [434, 155], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.charLitNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer charLitNoAntiquot] def charLitNoAntiquot.parenthesizer := visitToken", "start": [436, 1], "end": [436, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.strLitNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer strLitNoAntiquot] def strLitNoAntiquot.parenthesizer := visitToken", "start": [437, 1], "end": [437, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.nameLitNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer nameLitNoAntiquot] def nameLitNoAntiquot.parenthesizer := visitToken", "start": [438, 1], "end": [438, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.numLitNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer numLitNoAntiquot] def numLitNoAntiquot.parenthesizer := visitToken", "start": [439, 1], "end": [439, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.scientificLitNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer scientificLitNoAntiquot] def scientificLitNoAntiquot.parenthesizer := visitToken", "start": [440, 1], "end": [440, 108], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer", "code": "@[combinator_parenthesizer fieldIdx] def fieldIdx.parenthesizer := visitToken", "start": [441, 1], "end": [441, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer manyNoAntiquot]\ndef manyNoAntiquot.parenthesizer (p : Parenthesizer) : Parenthesizer := do\n  let stx \u2190 getCur\n  visitArgs $ stx.getArgs.size.forM fun _ => p", "start": [443, 1], "end": [446, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.many1NoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer many1NoAntiquot]\ndef many1NoAntiquot.parenthesizer (p : Parenthesizer) : Parenthesizer := do\n  manyNoAntiquot.parenthesizer p", "start": [448, 1], "end": [450, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.many1Unbox.parenthesizer", "code": "@[combinator_parenthesizer many1Unbox]\ndef many1Unbox.parenthesizer (p : Parenthesizer) : Parenthesizer := do\n  let stx \u2190 getCur\n  if stx.getKind == nullKind then\n    manyNoAntiquot.parenthesizer p\n  else\n    p", "start": [452, 1], "end": [458, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.optionalNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer optionalNoAntiquot]\ndef optionalNoAntiquot.parenthesizer (p : Parenthesizer) : Parenthesizer := do\n  visitArgs p", "start": [460, 1], "end": [462, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.sepByNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer sepByNoAntiquot]\ndef sepByNoAntiquot.parenthesizer (p pSep : Parenthesizer) : Parenthesizer := do\n  let stx \u2190 getCur\n  visitArgs <| (List.range stx.getArgs.size).reverse.forM fun i => if i % 2 == 0 then p else pSep", "start": [464, 1], "end": [467, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.sepBy1NoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer sepBy1NoAntiquot] def sepBy1NoAntiquot.parenthesizer := sepByNoAntiquot.parenthesizer", "start": [469, 1], "end": [469, 113], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer", "code": "@[combinator_parenthesizer withPosition] def withPosition.parenthesizer (p : Parenthesizer) : Parenthesizer := do\n  modify fun st => { st with contPrec := none }\n  p", "start": [471, 1], "end": [474, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.withPositionAfterLinebreak.parenthesizer", "code": "@[combinator_parenthesizer withPositionAfterLinebreak] def withPositionAfterLinebreak.parenthesizer (p : Parenthesizer) : Parenthesizer :=\n  withPosition.parenthesizer p", "start": [475, 1], "end": [477, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.withoutInfo.parenthesizer", "code": "@[combinator_parenthesizer withoutInfo] def withoutInfo.parenthesizer (p : Parenthesizer) : Parenthesizer := p", "start": [479, 1], "end": [479, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkStackTop.parenthesizer", "code": "@[combinator_parenthesizer checkStackTop] def checkStackTop.parenthesizer : Parenthesizer := pure ()", "start": [481, 1], "end": [481, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer", "code": "@[combinator_parenthesizer checkWsBefore] def checkWsBefore.parenthesizer : Parenthesizer := pure ()", "start": [482, 1], "end": [482, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer", "code": "@[combinator_parenthesizer checkNoWsBefore] def checkNoWsBefore.parenthesizer : Parenthesizer := pure ()", "start": [483, 1], "end": [483, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkLinebreakBefore.parenthesizer", "code": "@[combinator_parenthesizer checkLinebreakBefore] def checkLinebreakBefore.parenthesizer : Parenthesizer := pure ()", "start": [484, 1], "end": [484, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkTailWs.parenthesizer", "code": "@[combinator_parenthesizer checkTailWs] def checkTailWs.parenthesizer : Parenthesizer := pure ()", "start": [485, 1], "end": [485, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkColEq.parenthesizer", "code": "@[combinator_parenthesizer checkColEq] def checkColEq.parenthesizer : Parenthesizer := pure ()", "start": [486, 1], "end": [486, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer", "code": "@[combinator_parenthesizer checkColGe] def checkColGe.parenthesizer : Parenthesizer := pure ()", "start": [487, 1], "end": [487, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer", "code": "@[combinator_parenthesizer checkColGt] def checkColGt.parenthesizer : Parenthesizer := pure ()", "start": [488, 1], "end": [488, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer", "code": "@[combinator_parenthesizer checkLineEq] def checkLineEq.parenthesizer : Parenthesizer := pure ()", "start": [489, 1], "end": [489, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.eoi.parenthesizer", "code": "@[combinator_parenthesizer eoi] def eoi.parenthesizer : Parenthesizer := pure ()", "start": [490, 1], "end": [490, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.checkNoImmediateColon.parenthesizer", "code": "@[combinator_parenthesizer checkNoImmediateColon] def checkNoImmediateColon.parenthesizer : Parenthesizer := pure ()", "start": [491, 1], "end": [491, 117], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer", "code": "@[combinator_parenthesizer skip] def skip.parenthesizer : Parenthesizer := pure ()", "start": [492, 1], "end": [492, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer", "code": "@[combinator_parenthesizer pushNone] def pushNone.parenthesizer : Parenthesizer := goLeft", "start": [494, 1], "end": [494, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.hygieneInfoNoAntiquot.parenthesizer", "code": "@[combinator_parenthesizer hygieneInfoNoAntiquot] def hygieneInfoNoAntiquot.parenthesizer : Parenthesizer := goLeft", "start": [495, 1], "end": [495, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.interpolatedStr.parenthesizer", "code": "@[combinator_parenthesizer interpolatedStr]\ndef interpolatedStr.parenthesizer (p : Parenthesizer) : Parenthesizer := do\n  visitArgs $ (\u2190 getCur).getArgs.reverse.forM fun chunk =>\n    if chunk.isOfKind interpolatedStrLitKind then\n      goLeft\n    else\n      p", "start": [497, 1], "end": [503, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.ite", "code": "@[combinator_parenthesizer _root_.ite, macro_inline] def ite {_ : Type} (c : Prop) [Decidable c] (t e : Parenthesizer) : Parenthesizer :=\n  if c then t else e", "start": [505, 1], "end": [506, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.ParenthesizerAliasValue", "code": "abbrev ParenthesizerAliasValue := AliasValue Parenthesizer", "start": [510, 1], "end": [510, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.registerAlias", "code": "def registerAlias (aliasName : Name) (v : ParenthesizerAliasValue) : IO Unit := do\n  Parser.registerAliasCore parenthesizerAliasesRef aliasName v", "start": [514, 1], "end": [515, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.parenthesize", "code": "def parenthesize (parenthesizer : Parenthesizer) (stx : Syntax) : CoreM Syntax := do\n  trace[PrettyPrinter.parenthesize.input] \"{format stx}\"\n  catchInternalId backtrackExceptionId\n    (do\n      let (_, st) \u2190 (parenthesizer {}).run { stxTrav := Syntax.Traverser.fromSyntax stx }\n      pure st.stxTrav.cur)\n    (fun _ => throwError \"parenthesize: uncaught backtrack exception\")", "start": [524, 1], "end": [531, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.parenthesizeCategory", "code": "def parenthesizeCategory (cat : Name) := parenthesize <| categoryParser.parenthesizer cat 0", "start": [533, 1], "end": [533, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.parenthesizeTerm", "code": "def parenthesizeTerm := parenthesizeCategory `term", "start": [535, 1], "end": [535, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.parenthesizeTactic", "code": "def parenthesizeTactic := parenthesizeCategory `tactic", "start": [536, 1], "end": [536, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.parenthesizeCommand", "code": "def parenthesizeCommand := parenthesizeCategory `command", "start": [537, 1], "end": [537, 57], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Formatter.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter/Basic.lean", "lake-packages/lean4/src/lean/Lean/ParserCompiler/Attribute.lean", "lake-packages/lean4/src/lean/Lean/CoreM.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Parser/StrInterpolation.lean", "lake-packages/lean4/src/lean/Lean/KeyedDeclsAttribute.lean", "lake-packages/lean4/src/lean/Lean/Parser/Extension.lean"], "premises": [{"full_name": "Lean.PrettyPrinter.Formatter.Context", "code": "structure Context where\n  options : Options\n  table   : Parser.TokenTable", "start": [26, 1], "end": [28, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.State", "code": "structure State where\n  stxTrav  : Syntax.Traverser\n  leadWord : String := \"\"\n  isUngrouped : Bool := false\n  mustBeGrouped : Bool := true\n  stack    : Array Format := #[]", "start": [30, 1], "end": [42, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.FormatterM", "code": "abbrev FormatterM := ReaderT Formatter.Context $ StateRefT Formatter.State CoreM", "start": [46, 1], "end": [46, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.FormatterM.orElse", "code": "@[inline] def FormatterM.orElse {\u03b1} (p\u2081 : FormatterM \u03b1) (p\u2082 : Unit \u2192 FormatterM \u03b1) : FormatterM \u03b1 := do\n  let s \u2190 get\n  catchInternalId backtrackExceptionId\n    p\u2081\n    (fun _ => do set s; p\u2082 ())", "start": [48, 1], "end": [52, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter", "code": "abbrev Formatter := FormatterM Unit", "start": [56, 1], "end": [56, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.mkFormatterAttribute", "code": "unsafe def mkFormatterAttribute : IO (KeyedDeclsAttribute Formatter) :=\n  KeyedDeclsAttribute.init {\n    builtinName := `builtin_formatter,\n    name := `formatter,\n    descr := \"Register a formatter for a parser.\n\n  [formatter k] registers a declaration of type `Lean.PrettyPrinter.Formatter` for the `SyntaxNodeKind` `k`.\",\n    valueTypeName := `Lean.PrettyPrinter.Formatter,\n    evalKey := fun builtin stx => do\n      let env \u2190 getEnv\n      let stx \u2190 Attribute.Builtin.getIdent stx\n      let id := stx.getId\n      unless (builtin && (env.find? id).isSome) || Parser.isValidSyntaxNodeKind env id do\n        throwError \"invalid [formatter] argument, unknown syntax kind '{id}'\"\n      if (\u2190 getEnv).contains id && (\u2190 Elab.getInfoState).enabled then\n        Elab.addConstInfo stx id none\n      pure id\n  } `Lean.PrettyPrinter.formatterAttribute", "start": [58, 1], "end": [77, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.formatterAttribute", "code": "@[builtin_init mkFormatterAttribute] opaque formatterAttribute : KeyedDeclsAttribute Formatter", "start": [78, 1], "end": [78, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.mkCombinatorFormatterAttribute", "code": "unsafe def mkCombinatorFormatterAttribute : IO ParserCompiler.CombinatorAttribute :=\n  ParserCompiler.registerCombinatorAttribute\n    `combinator_formatter\n    \"Register a formatter for a parser combinator.\n\n  [combinator_formatter c] registers a declaration of type `Lean.PrettyPrinter.Formatter` for the `Parser` declaration `c`.\n  Note that, unlike with [formatter], this is not a node kind since combinators usually do not introduce their own node kinds.\n  The tagged declaration may optionally accept parameters corresponding to (a prefix of) those of `c`, where `Parser` is replaced\n  with `Formatter` in the parameter types.\"", "start": [80, 1], "end": [88, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.combinatorFormatterAttribute", "code": "@[builtin_init mkCombinatorFormatterAttribute] opaque combinatorFormatterAttribute : ParserCompiler.CombinatorAttribute", "start": [89, 1], "end": [89, 120], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.throwBacktrack", "code": "def throwBacktrack {\u03b1} : FormatterM \u03b1 :=\nthrow $ Exception.internal backtrackExceptionId", "start": [96, 1], "end": [97, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.getStack", "code": "def getStack : FormatterM (Array Format) := do\n  let st \u2190 get\n  pure st.stack", "start": [107, 1], "end": [109, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.getStackSize", "code": "def getStackSize : FormatterM Nat := do\n  let stack \u2190 getStack;\n  pure stack.size", "start": [111, 1], "end": [113, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.setStack", "code": "def setStack (stack : Array Format) : FormatterM Unit :=\n  modify fun st => { st with stack := stack }", "start": [115, 1], "end": [116, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.push", "code": "private def push (f : Format) : FormatterM Unit :=\n  modify fun st => { st with stack := st.stack.push f, isUngrouped := false }", "start": [118, 1], "end": [119, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.pushWhitespace", "code": "def pushWhitespace (f : Format) : FormatterM Unit := do\n  push f\n  modify fun st => { st with leadWord := \"\", isUngrouped := false }", "start": [121, 1], "end": [123, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.pushLine", "code": "def pushLine : FormatterM Unit :=\n  pushWhitespace Format.line", "start": [125, 1], "end": [126, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.pushAlign", "code": "def pushAlign (force : Bool) : FormatterM Unit :=\n  pushWhitespace (.align force)", "start": [128, 1], "end": [129, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.visitArgs", "code": "def visitArgs (x : FormatterM Unit) : FormatterM Unit := do\n  let stx \u2190 getCur\n  if stx.getArgs.size > 0 then\n    goDown (stx.getArgs.size - 1) *> x <* goUp\n  goLeft", "start": [131, 1], "end": [136, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.fold", "code": "def fold (fn : Array Format \u2192 Format) (x : FormatterM Unit) : FormatterM Unit := do\n  let sp \u2190 getStackSize\n  x\n  let stack \u2190 getStack\n  let f := fn $ stack.extract sp stack.size\n  setStack $ (stack.shrink sp).push f", "start": [138, 1], "end": [144, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.concat", "code": "def concat (x : FormatterM Unit) : FormatterM Unit := do\n  fold (Array.foldl (fun acc f => if acc.isNil then f else f ++ acc) Format.nil) x", "start": [146, 1], "end": [148, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.indent", "code": "def indent (x : Formatter) (indent : Option Int := none) : Formatter := do\n  concat x\n  let ctx \u2190 read\n  let indent := indent.getD $ Std.Format.getIndent ctx.options\n  modify fun st => { st with stack := st.stack.modify (st.stack.size - 1) (Format.nest indent) }", "start": [150, 1], "end": [154, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.fill", "code": "def fill (x : Formatter) : Formatter := do\n  concat x\n  modify fun st => { st with\n    stack := st.stack.modify (st.stack.size - 1) Format.fill\n    isUngrouped := false\n  }", "start": [156, 1], "end": [161, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.group", "code": "def group (x : Formatter) : Formatter := do\n  concat x\n  modify fun st => { st with\n    stack := st.stack.modify (st.stack.size - 1) Format.group\n    isUngrouped := false\n  }", "start": [163, 1], "end": [168, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.withMaybeTag", "code": "def withMaybeTag (pos? : Option String.Pos) (x : FormatterM Unit) : Formatter := do\n  if let some p := pos? then\n    concat x\n    modify fun st => {\n      st with stack := st.stack.modify (st.stack.size - 1) fun fmt =>\n        if fmt matches Format.tag .. then fmt\n        else Format.tag p.byteIdx fmt\n    }\n  else\n    x", "start": [170, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.orelse.formatter", "code": "@[combinator_formatter orelse] partial def orelse.formatter (p1 p2 : Formatter) : Formatter := do\n  let stx \u2190 getCur\n  if stx.getKind == `choice then\n    visitArgs do\n      orelse.formatter p1 p2\n  else\n    p1 <|> p2", "start": [183, 1], "end": [194, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.mkAntiquot.formatter'", "code": "@[extern \"lean_mk_antiquot_formatter\"]\nopaque mkAntiquot.formatter' (name : String) (kind : SyntaxNodeKind) (anonymous := true) (isPseudoKind := false) : Formatter", "start": [200, 1], "end": [201, 125], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.interpretParserDescr'", "code": "@[extern \"lean_pretty_printer_formatter_interpret_parser_descr\"]\nopaque interpretParserDescr' : ParserDescr \u2192 CoreM Formatter", "start": [204, 1], "end": [205, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.SourceInfo.getExprPos?", "code": "private def SourceInfo.getExprPos? : SourceInfo \u2192 Option String.Pos\n  | SourceInfo.synthetic (pos := pos) .. => pos\n  | _ => none", "start": [207, 1], "end": [209, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.getExprPos?", "code": "private def getExprPos? : Syntax \u2192 Option String.Pos\n  | Syntax.node info _ _ => SourceInfo.getExprPos? info\n  | Syntax.atom info _ => SourceInfo.getExprPos? info\n  | Syntax.ident info _ _ _ => SourceInfo.getExprPos? info\n  | Syntax.missing => none", "start": [211, 1], "end": [215, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.formatterForKindUnsafe", "code": "unsafe def formatterForKindUnsafe (k : SyntaxNodeKind) : Formatter := do\n  if k == `missing then\n    push \"<missing>\"\n    goLeft\n  else\n    let stx \u2190 getCur\n    let f \u2190 runForNodeKind formatterAttribute k interpretParserDescr'\n    withMaybeTag (getExprPos? stx) f", "start": [217, 1], "end": [224, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.formatterForKind", "code": "@[implemented_by formatterForKindUnsafe]\nopaque formatterForKind (k : SyntaxNodeKind) : Formatter", "start": [226, 1], "end": [227, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.withAntiquot.formatter", "code": "@[combinator_formatter withAntiquot]\ndef withAntiquot.formatter (antiP p : Formatter) : Formatter :=\n  orelse.formatter antiP p", "start": [229, 1], "end": [233, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.withAntiquotSuffixSplice.formatter", "code": "@[combinator_formatter withAntiquotSuffixSplice]\ndef withAntiquotSuffixSplice.formatter (_ : SyntaxNodeKind) (p suffix : Formatter) : Formatter := do\n  if (\u2190 getCur).isAntiquotSuffixSplice then\n    visitArgs <| suffix *> p\n  else\n    p", "start": [235, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter", "code": "@[combinator_formatter tokenWithAntiquot]\ndef tokenWithAntiquot.formatter (p : Formatter) : Formatter := do\n  if (\u2190 getCur).isTokenAntiquot then\n    visitArgs p\n  else\n    p", "start": [242, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.categoryFormatterCore", "code": "def categoryFormatterCore (cat : Name) : Formatter := do\n  modify fun st => { st with mustBeGrouped := true, isUngrouped := false }\n  let stx \u2190 getCur\n  trace[PrettyPrinter.format] \"formatting {indentD (format stx)}\"\n  if stx.getKind == `choice then\n    visitArgs do\n      formatterForKind (\u2190 getCur).getKind\n  else if cat == `rawStx then\n    withAntiquot.formatter (mkAntiquot.formatter' cat.toString cat (isPseudoKind := true)) (push stx.formatStx *> goLeft)\n  else\n    withAntiquot.formatter (mkAntiquot.formatter' cat.toString cat (isPseudoKind := true)) (formatterForKind stx.getKind)\n  modify fun st => { st with mustBeGrouped := true, isUngrouped := !st.mustBeGrouped }", "start": [249, 1], "end": [262, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.categoryParser.formatter", "code": "@[combinator_formatter categoryParser]\ndef categoryParser.formatter (cat : Name) : Formatter := do\n  concat <| categoryFormatterCore cat\n  unless (\u2190 get).isUngrouped do\n    let indent := Std.Format.getIndent (\u2190 read).options\n    modify fun st => { st with\n      stack := st.stack.modify (st.stack.size - 1) fun fmt =>\n        fmt.nest indent |>.fill\n    }", "start": [264, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.categoryFormatter", "code": "def categoryFormatter (cat : Name) : Formatter :=\n  fill <| indent <| categoryFormatterCore cat", "start": [274, 1], "end": [275, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.parserOfStack.formatter", "code": "@[combinator_formatter parserOfStack]\ndef parserOfStack.formatter (offset : Nat) (_prec : Nat := 0) : Formatter := do\n  let st \u2190 get\n  let stx := st.stxTrav.parents.back.getArg (st.stxTrav.idxs.back - offset)\n  formatterForKind stx.getKind", "start": [277, 1], "end": [281, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.error.formatter", "code": "@[combinator_formatter error]\ndef error.formatter (_msg : String) : Formatter := pure ()", "start": [283, 1], "end": [284, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.errorAtSavedPos.formatter", "code": "@[combinator_formatter errorAtSavedPos]\ndef errorAtSavedPos.formatter (_msg : String) (_delta : Bool) : Formatter := pure ()", "start": [285, 1], "end": [286, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.lookahead.formatter", "code": "@[combinator_formatter lookahead]\ndef lookahead.formatter (_ : Formatter) : Formatter := pure ()", "start": [287, 1], "end": [288, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.notFollowedBy.formatter", "code": "@[combinator_formatter notFollowedBy]\ndef notFollowedBy.formatter (_ : Formatter) : Formatter := pure ()", "start": [290, 1], "end": [291, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.andthen.formatter", "code": "@[combinator_formatter andthen]\ndef andthen.formatter (p1 p2 : Formatter) : Formatter := p2 *> p1", "start": [293, 1], "end": [294, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkKind", "code": "def checkKind (k : SyntaxNodeKind) : FormatterM Unit := do\n  let stx \u2190 getCur\n  if k != stx.getKind then\n    trace[PrettyPrinter.format.backtrack] \"unexpected node kind '{stx.getKind}', expected '{k}'\"\n    throwBacktrack", "start": [296, 1], "end": [300, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.node.formatter", "code": "@[combinator_formatter node]\ndef node.formatter (k : SyntaxNodeKind) (p : Formatter) : Formatter := do\n  checkKind k;\n  visitArgs p", "start": [302, 1], "end": [305, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.withFn.formatter", "code": "@[combinator_formatter withFn]\ndef withFn.formatter (_ : ParserFn \u2192 ParserFn) (p : Formatter) : Formatter := p", "start": [307, 1], "end": [308, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.trailingNode.formatter", "code": "@[combinator_formatter trailingNode]\ndef trailingNode.formatter (k : SyntaxNodeKind) (_ _ : Nat) (p : Formatter) : Formatter := do\n  checkKind k\n  visitArgs do\n    p;\n    categoryParser.formatter `foo", "start": [310, 1], "end": [316, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.parseToken", "code": "def parseToken (s : String) : FormatterM ParserState :=\n  return (Parser.andthenFn Parser.whitespace (Parser.tokenFn [])).run {\n    input := s,\n    fileName := \"\",\n    fileMap := FileMap.ofString \"\"\n  } {\n    env := \u2190 getEnv,\n    options := \u2190 getOptions\n  } ((\u2190 read).table) (Parser.mkParserState s)", "start": [318, 1], "end": [327, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.pushToken", "code": "def pushToken (info : SourceInfo) (tk : String) : FormatterM Unit := do\n  match info with\n  | SourceInfo.original _ _ ss _ =>\n    let ss' := ss.trim\n    if !ss'.isEmpty then\n      let ws := { ss with startPos := ss'.stopPos }\n      if ws.contains '\\n' then\n        push s!\"\\n{ss'}\"\n      else\n        push s!\"  {ss'}\"\n      modify fun st => { st with leadWord := \"\" }\n  | _ => pure ()\n\n  let st \u2190 get\n  if st.leadWord != \"\" && tk.trimRight == tk then\n    let tk' := tk.trimLeft\n    let t \u2190 parseToken $ tk' ++ st.leadWord\n    if t.pos <= tk'.endPos then\n      push tk\n      modify fun st => { st with leadWord := if tk.trimLeft == tk then tk ++ st.leadWord else \"\" }\n    else\n      push $ tk ++ \" \"\n      modify fun st => { st with leadWord := if tk.trimLeft == tk then tk else \"\" }\n  else\n    if st.leadWord == \"\" then\n      push tk.trimRight\n    else if tk.endsWith \" \" then\n      pushLine\n      push tk.trimRight\n    else\n      push tk modify fun st => { st with leadWord := if tk.trimLeft == tk then tk else \"\" }\n\n  match info with\n  | SourceInfo.original ss _ _ _ =>\n    let ss' := ss.trim\n    if !ss'.isEmpty then\n      let ws := { ss with startPos := ss'.stopPos }\n      if ws.contains '\\n' then do\n        indent (push s!\"{ss'}\\n\") (some ((0:Int) - Std.Format.getIndent (\u2190 getOptions)))\n      else\n        pushLine\n        push ss'.toString\n      modify fun st => { st with leadWord := \"\" }\n  | _ => pure ()", "start": [329, 1], "end": [381, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter", "code": "@[combinator_formatter symbolNoAntiquot]\ndef symbolNoAntiquot.formatter (sym : String) : Formatter := do\n  let stx \u2190 getCur\n  if stx.isToken sym then do\n    let (Syntax.atom info _) \u2190 pure stx | unreachable!\n    withMaybeTag (getExprPos? stx) (pushToken info sym)\n    goLeft\n  else do\n    trace[PrettyPrinter.format.backtrack] \"unexpected syntax '{format stx}', expected symbol '{sym}'\"\n    throwBacktrack", "start": [383, 1], "end": [392, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.nonReservedSymbolNoAntiquot.formatter", "code": "@[combinator_formatter nonReservedSymbolNoAntiquot] def nonReservedSymbolNoAntiquot.formatter := symbolNoAntiquot.formatter", "start": [394, 1], "end": [394, 124], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.rawCh.formatter", "code": "@[combinator_formatter rawCh] def rawCh.formatter (ch : Char) := symbolNoAntiquot.formatter ch.toString", "start": [396, 1], "end": [396, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.unicodeSymbolNoAntiquot.formatter", "code": "@[combinator_formatter unicodeSymbolNoAntiquot]\ndef unicodeSymbolNoAntiquot.formatter (sym asciiSym : String) : Formatter := do\n  let Syntax.atom info val \u2190 getCur\n    | throwError m!\"not an atom: {\u2190 getCur}\"\n  if val == sym.trim then\n    pushToken info sym\n  else\n    pushToken info asciiSym;\n  goLeft", "start": [398, 1], "end": [406, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.identNoAntiquot.formatter", "code": "@[combinator_formatter identNoAntiquot]\ndef identNoAntiquot.formatter : Formatter := do\n  checkKind identKind\n  let stx@(Syntax.ident info _ id _) \u2190 getCur\n    | throwError m!\"not an ident: {\u2190 getCur}\"\n  let id := id.simpMacroScopes\n  withMaybeTag (getExprPos? stx) (pushToken info id.toString)\n  goLeft", "start": [408, 1], "end": [415, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.rawIdentNoAntiquot.formatter", "code": "@[combinator_formatter rawIdentNoAntiquot] def rawIdentNoAntiquot.formatter : Formatter := do\n  checkKind identKind\n  let Syntax.ident info _ id _ \u2190 getCur\n    | throwError m!\"not an ident: {\u2190 getCur}\"\n  pushToken info id.toString\n  goLeft", "start": [417, 1], "end": [422, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.identEq.formatter", "code": "@[combinator_formatter identEq] def identEq.formatter (_id : Name) := rawIdentNoAntiquot.formatter", "start": [424, 1], "end": [424, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.visitAtom", "code": "def visitAtom (k : SyntaxNodeKind) : Formatter := do\n  let stx \u2190 getCur\n  if k != Name.anonymous then\n    checkKind k\n  let Syntax.atom info val \u2190 pure $ stx.ifNode (fun n => n.getArg 0) (fun _ => stx)\n    | throwError m!\"not an atom: {stx}\"\n  pushToken info val\n  goLeft", "start": [426, 1], "end": [433, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.charLitNoAntiquot.formatter", "code": "@[combinator_formatter charLitNoAntiquot] def charLitNoAntiquot.formatter := visitAtom charLitKind", "start": [435, 1], "end": [435, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.strLitNoAntiquot.formatter", "code": "@[combinator_formatter strLitNoAntiquot] def strLitNoAntiquot.formatter := visitAtom strLitKind", "start": [436, 1], "end": [436, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.nameLitNoAntiquot.formatter", "code": "@[combinator_formatter nameLitNoAntiquot] def nameLitNoAntiquot.formatter := visitAtom nameLitKind", "start": [437, 1], "end": [437, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.numLitNoAntiquot.formatter", "code": "@[combinator_formatter numLitNoAntiquot] def numLitNoAntiquot.formatter := visitAtom numLitKind", "start": [438, 1], "end": [438, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.scientificLitNoAntiquot.formatter", "code": "@[combinator_formatter scientificLitNoAntiquot] def scientificLitNoAntiquot.formatter := visitAtom scientificLitKind", "start": [439, 1], "end": [439, 117], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.fieldIdx.formatter", "code": "@[combinator_formatter fieldIdx] def fieldIdx.formatter := visitAtom fieldIdxKind", "start": [440, 1], "end": [440, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter", "code": "@[combinator_formatter manyNoAntiquot]\ndef manyNoAntiquot.formatter (p : Formatter) : Formatter := do\n  let stx \u2190 getCur\n  visitArgs $ stx.getArgs.size.forM fun _ => p", "start": [442, 1], "end": [445, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.many1NoAntiquot.formatter", "code": "@[combinator_formatter many1NoAntiquot] def many1NoAntiquot.formatter (p : Formatter) : Formatter := manyNoAntiquot.formatter p", "start": [447, 1], "end": [447, 128], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.optionalNoAntiquot.formatter", "code": "@[combinator_formatter optionalNoAntiquot]\ndef optionalNoAntiquot.formatter (p : Formatter) : Formatter := visitArgs p", "start": [449, 1], "end": [450, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.many1Unbox.formatter", "code": "@[combinator_formatter many1Unbox]\ndef many1Unbox.formatter (p : Formatter) : Formatter := do\n  let stx \u2190 getCur\n  if stx.getKind == nullKind then do\n    manyNoAntiquot.formatter p\n  else\n    p", "start": [452, 1], "end": [458, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.sepByNoAntiquot.formatter", "code": "@[combinator_formatter sepByNoAntiquot]\ndef sepByNoAntiquot.formatter (p pSep : Formatter) : Formatter := do\n  let stx \u2190 getCur\n  visitArgs <| (List.range stx.getArgs.size).reverse.forM fun i => if i % 2 == 0 then p else pSep", "start": [460, 1], "end": [463, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.sepBy1NoAntiquot.formatter", "code": "@[combinator_formatter sepBy1NoAntiquot] def sepBy1NoAntiquot.formatter := sepByNoAntiquot.formatter", "start": [465, 1], "end": [465, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.withoutInfo.formatter", "code": "@[combinator_formatter withoutInfo] def withoutInfo.formatter (p : Formatter) : Formatter := p", "start": [467, 1], "end": [467, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkWsBefore.formatter", "code": "@[combinator_formatter checkWsBefore] def checkWsBefore.formatter : Formatter := do\n  let st \u2190 get\n  if st.leadWord != \"\" then\n    pushLine", "start": [468, 1], "end": [471, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkPrec.formatter", "code": "@[combinator_formatter checkPrec] def checkPrec.formatter : Formatter := pure ()", "start": [473, 1], "end": [473, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkLhsPrec.formatter", "code": "@[combinator_formatter checkLhsPrec] def checkLhsPrec.formatter : Formatter := pure ()", "start": [474, 1], "end": [474, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.setLhsPrec.formatter", "code": "@[combinator_formatter setLhsPrec] def setLhsPrec.formatter : Formatter := pure ()", "start": [475, 1], "end": [475, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkStackTop.formatter", "code": "@[combinator_formatter checkStackTop] def checkStackTop.formatter : Formatter := pure ()", "start": [476, 1], "end": [476, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter", "code": "@[combinator_formatter checkNoWsBefore] def checkNoWsBefore.formatter : Formatter :=\n  modify fun st => { st with leadWord := \"\" }", "start": [477, 1], "end": [479, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkLinebreakBefore.formatter", "code": "@[combinator_formatter checkLinebreakBefore] def checkLinebreakBefore.formatter : Formatter := pure ()", "start": [480, 1], "end": [480, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkTailWs.formatter", "code": "@[combinator_formatter checkTailWs] def checkTailWs.formatter : Formatter := pure ()", "start": [481, 1], "end": [481, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkColEq.formatter", "code": "@[combinator_formatter checkColEq] def checkColEq.formatter : Formatter := pure ()", "start": [482, 1], "end": [482, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkColGe.formatter", "code": "@[combinator_formatter checkColGe] def checkColGe.formatter : Formatter := pure ()", "start": [483, 1], "end": [483, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkColGt.formatter", "code": "@[combinator_formatter checkColGt] def checkColGt.formatter : Formatter := pure ()", "start": [484, 1], "end": [484, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkLineEq.formatter", "code": "@[combinator_formatter checkLineEq] def checkLineEq.formatter : Formatter := pure ()", "start": [485, 1], "end": [485, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.eoi.formatter", "code": "@[combinator_formatter eoi] def eoi.formatter : Formatter := pure ()", "start": [487, 1], "end": [487, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.checkNoImmediateColon.formatter", "code": "@[combinator_formatter checkNoImmediateColon] def checkNoImmediateColon.formatter : Formatter := pure ()", "start": [488, 1], "end": [488, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.skip.formatter", "code": "@[combinator_formatter skip] def skip.formatter : Formatter := pure ()", "start": [489, 1], "end": [489, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.pushNone.formatter", "code": "@[combinator_formatter pushNone] def pushNone.formatter : Formatter := goLeft", "start": [491, 1], "end": [491, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.hygieneInfoNoAntiquot.formatter", "code": "@[combinator_formatter hygieneInfoNoAntiquot] def hygieneInfoNoAntiquot.formatter : Formatter := goLeft", "start": [492, 1], "end": [492, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.interpolatedStr.formatter", "code": "@[combinator_formatter interpolatedStr]\ndef interpolatedStr.formatter (p : Formatter) : Formatter := do\n  visitArgs $ (\u2190 getCur).getArgs.reverse.forM fun chunk =>\n    match chunk.isLit? interpolatedStrLitKind with\n    | some str => push str *> goLeft\n    | none     => p", "start": [494, 1], "end": [499, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.ite", "code": "@[combinator_formatter _root_.ite, macro_inline] def ite {_ : Type} (c : Prop) [Decidable c] (t e : Formatter) : Formatter :=\n  if c then t else e", "start": [501, 1], "end": [502, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.FormatterAliasValue", "code": "abbrev FormatterAliasValue := AliasValue Formatter", "start": [504, 1], "end": [504, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.registerAlias", "code": "def registerAlias (aliasName : Name) (v : FormatterAliasValue) : IO Unit := do\n  Parser.registerAliasCore formatterAliasesRef aliasName v", "start": [508, 1], "end": [509, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.format", "code": "def format (formatter : Formatter) (stx : Syntax) : CoreM Format := do\n  trace[PrettyPrinter.format.input] \"{Std.format stx}\"\n  let options \u2190 getOptions\n  let table \u2190 Parser.builtinTokenTable.get\n  catchInternalId backtrackExceptionId\n    (do\n      let (_, st) \u2190 (concat formatter { table, options }).run { stxTrav := .fromSyntax stx }\n      let mut f := st.stack[0]!\n      if pp.oneline.get options then\n        let mut s := f.pretty' options |>.trim\n        let lineEnd := s.find (\u00b7 == '\\n')\n        if lineEnd < s.endPos then\n          s := s.extract 0 lineEnd ++ \" [...]\"\n        f := s\n      return .fill f)\n    (fun _ => throwError \"format: uncaught backtrack exception\")", "start": [524, 1], "end": [540, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.formatCategory", "code": "def formatCategory (cat : Name) := format <| categoryFormatter cat", "start": [542, 1], "end": [542, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.formatTerm", "code": "def formatTerm := formatCategory `term", "start": [544, 1], "end": [544, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.formatTactic", "code": "def formatTactic := formatCategory `tactic", "start": [545, 1], "end": [545, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.formatCommand", "code": "def formatCommand := formatCategory `command", "start": [546, 1], "end": [546, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/GlobalInstances.lean", "imports": ["lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.addGlobalInstance", "code": "def addGlobalInstance (declName : Name) (attrKind : AttributeKind) : MetaM Unit := do\n  globalInstanceExtension.add declName attrKind", "start": [17, 1], "end": [18, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isGlobalInstance", "code": "@[export lean_is_instance]\ndef isGlobalInstance (env : Environment) (declName : Name) : Bool :=\n  globalInstanceExtension.getState env |>.contains declName", "start": [20, 1], "end": [22, 60], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Extra.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter/Formatter.lean", "lake-packages/lean4/src/lean/Lean/Parser/Extension.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Parenthesizer.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.optional", "code": "@[run_builtin_parser_attribute_hooks] def optional (p : Parser) : Parser :=\n  optionalNoAntiquot (withAntiquotSpliceAndSuffix `optional p (symbol \"?\"))", "start": [24, 1], "end": [34, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.many", "code": "@[run_builtin_parser_attribute_hooks] def many (p : Parser) : Parser :=\n  manyNoAntiquot (withAntiquotSpliceAndSuffix `many p (symbol \"*\"))", "start": [36, 1], "end": [44, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.many1", "code": "@[run_builtin_parser_attribute_hooks] def many1 (p : Parser) : Parser :=\n  many1NoAntiquot (withAntiquotSpliceAndSuffix `many p (symbol \"*\"))", "start": [46, 1], "end": [59, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ident", "code": "@[run_builtin_parser_attribute_hooks] def ident : Parser :=\n  withAntiquot (mkAntiquot \"ident\" identKind) identNoAntiquot", "start": [61, 1], "end": [73, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.rawIdent", "code": "@[run_builtin_parser_attribute_hooks] def rawIdent : Parser :=\n  withAntiquot (mkAntiquot \"ident\" identKind) rawIdentNoAntiquot", "start": [76, 1], "end": [77, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.hygieneInfo", "code": "@[run_builtin_parser_attribute_hooks] def hygieneInfo : Parser :=\n  withAntiquot (mkAntiquot \"hygieneInfo\" hygieneInfoKind (anonymous := false)) hygieneInfoNoAntiquot", "start": [79, 1], "end": [92, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.numLit", "code": "@[run_builtin_parser_attribute_hooks] def numLit : Parser :=\n  withAntiquot (mkAntiquot \"num\" numLitKind) numLitNoAntiquot", "start": [94, 1], "end": [105, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.scientificLit", "code": "@[run_builtin_parser_attribute_hooks] def scientificLit : Parser :=\n  withAntiquot (mkAntiquot \"scientific\" scientificLitKind) scientificLitNoAntiquot", "start": [107, 1], "end": [113, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.strLit", "code": "@[run_builtin_parser_attribute_hooks] def strLit : Parser :=\n  withAntiquot (mkAntiquot \"str\" strLitKind) strLitNoAntiquot", "start": [115, 1], "end": [123, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.charLit", "code": "@[run_builtin_parser_attribute_hooks] def charLit : Parser :=\n  withAntiquot (mkAntiquot \"char\" charLitKind) charLitNoAntiquot", "start": [125, 1], "end": [134, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.nameLit", "code": "@[run_builtin_parser_attribute_hooks] def nameLit : Parser :=\n  withAntiquot (mkAntiquot \"name\" nameLitKind) nameLitNoAntiquot", "start": [136, 1], "end": [143, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.group", "code": "@[run_builtin_parser_attribute_hooks, inline] def group (p : Parser) : Parser :=\n  node groupKind p", "start": [145, 1], "end": [152, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.many1Indent", "code": "@[run_builtin_parser_attribute_hooks, inline] def many1Indent (p : Parser) : Parser :=\n  withPosition $ many1 (checkColGe \"irrelevant\" >> p)", "start": [154, 1], "end": [161, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.manyIndent", "code": "@[run_builtin_parser_attribute_hooks, inline] def manyIndent (p : Parser) : Parser :=\n  withPosition $ many (checkColGe \"irrelevant\" >> p)", "start": [163, 1], "end": [170, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepByIndent", "code": "@[inline] def sepByIndent (p : Parser) (sep : String) (psep : Parser := symbol sep) (allowTrailingSep : Bool := false) : Parser :=\n  let p := withAntiquotSpliceAndSuffix `sepBy p (symbol \"*\")\n  withPosition $ sepBy (checkColGe \"irrelevant\" >> p) sep (psep <|> checkColEq \"irrelevant\" >> checkLinebreakBefore >> pushNone) allowTrailingSep", "start": [172, 1], "end": [174, 146], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepBy1Indent", "code": "@[inline] def sepBy1Indent (p : Parser) (sep : String) (psep : Parser := symbol sep) (allowTrailingSep : Bool := false) : Parser :=\n  let p := withAntiquotSpliceAndSuffix `sepBy p (symbol \"*\")\n  withPosition $ sepBy1 (checkColGe \"irrelevant\" >> p) sep (psep <|> checkColEq \"irrelevant\" >> checkLinebreakBefore >> pushNone) allowTrailingSep", "start": [176, 1], "end": [178, 147], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepByIndent.formatter", "code": "@[combinator_formatter sepByIndent]\ndef sepByIndent.formatter (p : Formatter) (_sep : String) (pSep : Formatter) : Formatter := do\n  let stx \u2190 getCur\n  let hasNewlineSep := stx.getArgs.mapIdx (fun \u27e8i, _\u27e9 n =>\n    i % 2 == 1 && n.matchesNull 0 && i != stx.getArgs.size - 1) |>.any id\n  visitArgs do\n    for i in (List.range stx.getArgs.size).reverse do\n      if i % 2 == 0 then p else pSep <|>\n        ((if i == stx.getArgs.size - 1 then pure () else pushWhitespace \"\\n\") *> goLeft)\n  if hasNewlineSep then\n    pushAlign (force := true)", "start": [181, 1], "end": [194, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.sepBy1Indent.formatter", "code": "@[combinator_formatter sepBy1Indent] def sepBy1Indent.formatter := sepByIndent.formatter", "start": [196, 1], "end": [196, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.notSymbol", "code": "@[run_builtin_parser_attribute_hooks] abbrev notSymbol (s : String) : Parser :=\n  notFollowedBy (symbol s) s", "start": [200, 1], "end": [201, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.patternIgnore", "code": "@[inline, run_builtin_parser_attribute_hooks] def patternIgnore : Parser \u2192 Parser := node `patternIgnore", "start": [203, 1], "end": [204, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppHardSpace", "code": "@[inline] def ppHardSpace : Parser := skip", "start": [206, 1], "end": [207, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppSpace", "code": "@[inline] def ppSpace : Parser := skip", "start": [208, 1], "end": [209, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppLine", "code": "@[inline] def ppLine : Parser := skip", "start": [210, 1], "end": [211, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppRealFill", "code": "@[inline] def ppRealFill : Parser \u2192 Parser := id", "start": [212, 1], "end": [213, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppRealGroup", "code": "@[inline] def ppRealGroup : Parser \u2192 Parser := id", "start": [214, 1], "end": [215, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppIndent", "code": "@[inline] def ppIndent : Parser \u2192 Parser := id", "start": [216, 1], "end": [217, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppGroup", "code": "@[inline] def ppGroup (p : Parser) : Parser := ppRealFill (ppIndent p)", "start": [218, 1], "end": [221, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppDedent", "code": "@[inline] def ppDedent : Parser \u2192 Parser := id", "start": [222, 1], "end": [225, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppAllowUngrouped", "code": "@[inline] def ppAllowUngrouped : Parser := skip", "start": [227, 1], "end": [237, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppDedentIfGrouped", "code": "@[inline] def ppDedentIfGrouped : Parser \u2192 Parser := id", "start": [239, 1], "end": [243, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ppHardLineUnlessUngrouped", "code": "@[inline] def ppHardLineUnlessUngrouped : Parser := skip", "start": [245, 1], "end": [249, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.ppHardSpace.formatter", "code": "@[combinator_formatter ppHardSpace] def ppHardSpace.formatter : Formatter := Formatter.pushWhitespace \" \"", "start": [256, 1], "end": [256, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.ppSpace.formatter", "code": "@[combinator_formatter ppSpace] def ppSpace.formatter : Formatter := Formatter.pushLine", "start": [257, 1], "end": [257, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.ppLine.formatter", "code": "@[combinator_formatter ppLine] def ppLine.formatter : Formatter := Formatter.pushWhitespace \"\\n\"", "start": [258, 1], "end": [258, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.ppRealFill.formatter", "code": "@[combinator_formatter ppRealFill] def ppRealFill.formatter (p : Formatter) : Formatter := Formatter.fill p", "start": [259, 1], "end": [259, 108], "kind": "commanddeclaration"}, {"full_name": "Lean.ppRealGroup.formatter", "code": "@[combinator_formatter ppRealGroup] def ppRealGroup.formatter (p : Formatter) : Formatter := Formatter.group p", "start": [260, 1], "end": [260, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.ppIndent.formatter", "code": "@[combinator_formatter ppIndent] def ppIndent.formatter (p : Formatter) : Formatter := Formatter.indent p", "start": [261, 1], "end": [261, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.ppDedent.formatter", "code": "@[combinator_formatter ppDedent] def ppDedent.formatter (p : Formatter) : Formatter := do\n  let opts \u2190 getOptions\n  Formatter.indent p (some ((0:Int) - Std.Format.getIndent opts))", "start": [262, 1], "end": [264, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.ppAllowUngrouped.formatter", "code": "@[combinator_formatter ppAllowUngrouped] def ppAllowUngrouped.formatter : Formatter := do\n  modify ({ \u00b7 with mustBeGrouped := false })", "start": [266, 1], "end": [267, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.ppDedentIfGrouped.formatter", "code": "@[combinator_formatter ppDedentIfGrouped] def ppDedentIfGrouped.formatter (p : Formatter) : Formatter := do\n  Formatter.concat p\n  let indent := Std.Format.getIndent (\u2190 getOptions)\n  unless (\u2190 get).isUngrouped do\n    modify fun st => { st with stack := st.stack.modify (st.stack.size - 1) (\u00b7.nest (0 - indent)) }", "start": [268, 1], "end": [272, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.ppHardLineUnlessUngrouped.formatter", "code": "@[combinator_formatter ppHardLineUnlessUngrouped] def ppHardLineUnlessUngrouped.formatter : Formatter := do\n  if (\u2190 get).isUngrouped then\n    Formatter.pushLine\n  else\n    ppLine.formatter", "start": [273, 1], "end": [277, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/FunInfo.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.checkFunInfoCache", "code": "@[inline] private def checkFunInfoCache (fn : Expr) (maxArgs? : Option Nat) (k : MetaM FunInfo) : MetaM FunInfo := do\n  let t \u2190 getTransparency\n  match (\u2190 get).cache.funInfo.find? \u27e8t, fn, maxArgs?\u27e9 with\n  | some finfo => pure finfo\n  | none       => do\n    let finfo \u2190 k\n    modify fun s => { s with cache := { s.cache with funInfo := s.cache.funInfo.insert \u27e8t, fn, maxArgs?\u27e9 finfo } }\n    pure finfo", "start": [11, 1], "end": [18, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whenHasVar", "code": "@[inline] private def whenHasVar {\u03b1} (e : Expr) (deps : \u03b1) (k : \u03b1 \u2192 \u03b1) : \u03b1 :=\n  if e.hasFVar then k deps else deps", "start": [20, 1], "end": [21, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.collectDeps", "code": "private def collectDeps (fvars : Array Expr) (e : Expr) : Array Nat :=\n  let rec visit (e : Expr) (deps : Array Nat) : Array Nat :=\n    match e with\n    | .app f a         => whenHasVar e deps (visit a \u2218 visit f)\n    | .forallE _ d b _ => whenHasVar e deps (visit b \u2218 visit d)\n    | .lam _ d b _     => whenHasVar e deps (visit b \u2218 visit d)\n    | .letE _ t v b _  => whenHasVar e deps (visit b \u2218 visit v \u2218 visit t)\n    | .proj _ _ e      => visit e deps\n    | .mdata _ e       => visit e deps\n    | .fvar ..         =>\n      match fvars.indexOf? e with\n      | none   => deps\n      | some i => if deps.contains i.val then deps else deps.push i.val\n    | _ => deps\n  let deps := visit e #[]\n  deps.qsort (fun i j => i < j)", "start": [23, 1], "end": [38, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.updateHasFwdDeps", "code": "private def updateHasFwdDeps (pinfo : Array ParamInfo) (backDeps : Array Nat) : Array ParamInfo :=\n  if backDeps.size == 0 then\n    pinfo\n  else\n    pinfo.mapIdx fun i info =>\n      if info.hasFwdDeps then\n        info\n      else if backDeps.contains i then\n        { info with hasFwdDeps := true }\n      else\n        info", "start": [40, 1], "end": [52, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getFunInfoAux", "code": "private def getFunInfoAux (fn : Expr) (maxArgs? : Option Nat) : MetaM FunInfo :=\n  checkFunInfoCache fn maxArgs? do\n    let fnType \u2190 inferType fn\n    withTransparency TransparencyMode.default do\n      forallBoundedTelescope fnType maxArgs? fun fvars type => do\n        let mut paramInfo := #[]\n        let mut higherOrderOutParams : FVarIdSet := {}\n        for i in [:fvars.size] do\n          let fvar := fvars[i]!\n          let decl \u2190 getFVarLocalDecl fvar\n          let backDeps := collectDeps fvars decl.type\n          let dependsOnHigherOrderOutParam :=\n            !higherOrderOutParams.isEmpty\n            && Option.isSome (decl.type.find? fun e => e.isFVar && higherOrderOutParams.contains e.fvarId!)\n          paramInfo := updateHasFwdDeps paramInfo backDeps\n          paramInfo := paramInfo.push {\n            backDeps, dependsOnHigherOrderOutParam\n            binderInfo := decl.binderInfo\n            isProp     := (\u2190 isProp decl.type)\n            isDecInst  := (\u2190 forallTelescopeReducing decl.type fun _ type => return type.isAppOf ``Decidable)\n          }\n          if decl.binderInfo == .instImplicit then\n            \n            if let some className \u2190 isClass? decl.type then\n              if let some outParamPositions := getOutParamPositions? (\u2190 getEnv) className then\n                unless outParamPositions.isEmpty do\n                  let args := decl.type.getAppArgs\n                  for i in [:args.size] do\n                    if outParamPositions.contains i then\n                      let arg := args[i]!\n                      if let some idx := fvars.indexOf? arg then\n                        if (\u2190 whnf (\u2190 inferType arg)).isForall then\n                          paramInfo := paramInfo.modify idx fun info => { info with higherOrderOutParam := true }\n                          higherOrderOutParams := higherOrderOutParams.insert arg.fvarId!\n        let resultDeps := collectDeps fvars type\n        paramInfo := updateHasFwdDeps paramInfo resultDeps\n        return { resultDeps, paramInfo }", "start": [54, 1], "end": [90, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getFunInfo", "code": "def getFunInfo (fn : Expr) : MetaM FunInfo :=\n  getFunInfoAux fn none", "start": [92, 1], "end": [93, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getFunInfoNArgs", "code": "def getFunInfoNArgs (fn : Expr) (nargs : Nat) : MetaM FunInfo :=\n  getFunInfoAux fn (some nargs)", "start": [95, 1], "end": [96, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FunInfo.getArity", "code": "def FunInfo.getArity (info : FunInfo) : Nat :=\n  info.paramInfo.size", "start": [98, 1], "end": [99, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Structure.lean", "imports": ["lake-packages/lean4/src/lean/Lean/ProjFns.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.StructureFieldInfo", "code": "structure StructureFieldInfo where\n  fieldName  : Name\n  projFn     : Name\n  \n  subobject? : Option Name\n  binderInfo : BinderInfo\n  autoParam? : Option Expr := none\n  deriving Inhabited, Repr", "start": [13, 1], "end": [20, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.StructureFieldInfo.lt", "code": "def StructureFieldInfo.lt (i\u2081 i\u2082 : StructureFieldInfo) : Bool :=\n  Name.quickLt i\u2081.fieldName i\u2082.fieldName", "start": [22, 1], "end": [23, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.StructureInfo", "code": "structure StructureInfo where\n  structName : Name\n  fieldNames : Array Name := #[] fieldInfo  : Array StructureFieldInfo := #[] deriving Inhabited", "start": [25, 1], "end": [29, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.StructureInfo.lt", "code": "def StructureInfo.lt (i\u2081 i\u2082 : StructureInfo) : Bool :=\n  Name.quickLt i\u2081.structName i\u2082.structName", "start": [31, 1], "end": [32, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.StructureInfo.getProjFn?", "code": "def StructureInfo.getProjFn? (info : StructureInfo) (i : Nat) : Option Name :=\n  if h : i < info.fieldNames.size then\n    let fieldName := info.fieldNames.get \u27e8i, h\u27e9\n    info.fieldInfo.binSearch { fieldName := fieldName, projFn := default, subobject? := none, binderInfo := default } StructureFieldInfo.lt |>.map (\u00b7.projFn)\n  else\n    none", "start": [34, 1], "end": [39, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.StructureState", "code": "private structure StructureState where\n  map : PersistentHashMap Name StructureInfo := {}\n  deriving Inhabited", "start": [41, 1], "end": [44, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.StructureDescr", "code": "structure StructureDescr where\n  structName : Name\n  fields     : Array StructureFieldInfo deriving Inhabited", "start": [52, 1], "end": [55, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.registerStructure", "code": "def registerStructure (env : Environment) (e : StructureDescr) : Environment :=\n  structureExt.addEntry env {\n    structName := e.structName\n    fieldNames := e.fields.map fun e => e.fieldName\n    fieldInfo  := e.fields.qsort StructureFieldInfo.lt\n  }", "start": [57, 1], "end": [62, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.getStructureInfo?", "code": "def getStructureInfo? (env : Environment) (structName : Name) : Option StructureInfo :=\n  match env.getModuleIdxFor? structName with\n  | some modIdx => structureExt.getModuleEntries env modIdx |>.binSearch { structName } StructureInfo.lt\n  | none        => structureExt.getState env |>.map.find? structName", "start": [64, 1], "end": [67, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.getStructureCtor", "code": "def getStructureCtor (env : Environment) (constName : Name) : ConstructorVal :=\n  match env.find? constName with\n  | some (.inductInfo { isRec := false, ctors := [ctorName], .. }) =>\n    match env.find? ctorName with\n    | some (ConstantInfo.ctorInfo val) => val\n    | _ => panic! \"ill-formed environment\"\n  | _ => panic! \"structure expected\"", "start": [69, 1], "end": [75, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.getStructureFields", "code": "def getStructureFields (env : Environment) (structName : Name) : Array Name :=\n  if let some info := getStructureInfo? env structName then\n    info.fieldNames\n  else\n    panic! \"structure expected\"", "start": [77, 1], "end": [82, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.getFieldInfo?", "code": "def getFieldInfo? (env : Environment) (structName : Name) (fieldName : Name) : Option StructureFieldInfo :=\n  if let some info := getStructureInfo? env structName then\n    info.fieldInfo.binSearch { fieldName := fieldName, projFn := default, subobject? := none, binderInfo := default } StructureFieldInfo.lt\n  else\n    none", "start": [84, 1], "end": [88, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.isSubobjectField?", "code": "def isSubobjectField? (env : Environment) (structName : Name) (fieldName : Name) : Option Name :=\n  if let some fieldInfo := getFieldInfo? env structName fieldName then\n    fieldInfo.subobject?\n  else\n    none", "start": [90, 1], "end": [95, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.getParentStructures", "code": "def getParentStructures (env : Environment) (structName : Name) : Array Name :=\n  let fieldNames := getStructureFields env structName;\n  fieldNames.foldl (init := #[]) fun acc fieldName =>\n      match isSubobjectField? env structName fieldName with\n      | some parentStructName => acc.push parentStructName\n      | none                  => acc", "start": [97, 1], "end": [103, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.getAllParentStructures", "code": "partial def getAllParentStructures (env : Environment) (structName : Name) : Array Name :=\n  visit structName |>.run #[] |>.2\nwhere\n  visit (structName : Name) : StateT (Array Name) Id Unit := do\n    for p in getParentStructures env structName do\n      modify fun s => s.push p\n      visit p", "start": [105, 1], "end": [112, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.findField?", "code": "partial def findField? (env : Environment) (structName : Name) (fieldName : Name) : Option Name :=\n  if (getStructureFields env structName).contains fieldName then\n    some structName\n  else\n    getParentStructures env structName |>.findSome? fun parentStructName => findField? env parentStructName fieldName", "start": [114, 1], "end": [119, 118], "kind": "commanddeclaration"}, {"full_name": "Lean.getStructureFieldsFlattenedAux", "code": "private partial def getStructureFieldsFlattenedAux (env : Environment) (structName : Name) (fullNames : Array Name) (includeSubobjectFields : Bool) : Array Name :=\n  (getStructureFields env structName).foldl (init := fullNames) fun fullNames fieldName =>\n    match isSubobjectField? env structName fieldName with\n    | some parentStructName =>\n      let fullNames := if includeSubobjectFields then fullNames.push fieldName else fullNames\n      getStructureFieldsFlattenedAux env parentStructName fullNames includeSubobjectFields\n    | none                  => fullNames.push fieldName", "start": [121, 1], "end": [127, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.getStructureFieldsFlattened", "code": "def getStructureFieldsFlattened (env : Environment) (structName : Name) (includeSubobjectFields := true) : Array Name :=\n  getStructureFieldsFlattenedAux env structName #[] includeSubobjectFields", "start": [129, 1], "end": [139, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.isStructure", "code": "def isStructure (env : Environment) (constName : Name) : Bool :=\n  getStructureInfo? env constName |>.isSome", "start": [141, 1], "end": [148, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.getProjFnForField?", "code": "def getProjFnForField? (env : Environment) (structName : Name) (fieldName : Name) : Option Name :=\n  if let some fieldInfo := getFieldInfo? env structName fieldName then\n    some fieldInfo.projFn\n  else\n    none", "start": [150, 1], "end": [154, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.getProjFnInfoForField?", "code": "def getProjFnInfoForField? (env : Environment) (structName : Name) (fieldName : Name) : Option (Name \u00d7 ProjectionFunctionInfo) :=\n  if let some projFn := getProjFnForField? env structName fieldName then\n    (projFn, \u00b7) <$> env.getProjectionFnInfo? projFn\n  else\n    none", "start": [156, 1], "end": [160, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.mkDefaultFnOfProjFn", "code": "def mkDefaultFnOfProjFn (projFn : Name) : Name :=\n  projFn ++ `_default", "start": [162, 1], "end": [163, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.getDefaultFnForField?", "code": "def getDefaultFnForField? (env : Environment) (structName : Name) (fieldName : Name) : Option Name :=\n  if let some projName := getProjFnForField? env structName fieldName then\n    let defFn := mkDefaultFnOfProjFn projName\n    if env.contains defFn then defFn else none\n  else\n    let defFn := mkDefaultFnOfProjFn (structName ++ fieldName)\n    if env.contains defFn then defFn else none", "start": [165, 1], "end": [172, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.getPathToBaseStructureAux", "code": "partial def getPathToBaseStructureAux (env : Environment) (baseStructName : Name) (structName : Name) (path : List Name) : Option (List Name) :=\n  if baseStructName == structName then\n    some path.reverse\n  else\n    let fieldNames := getStructureFields env structName;\n    fieldNames.findSome? fun fieldName =>\n      match isSubobjectField? env structName fieldName with\n      | none                  => none\n      | some parentStructName =>\n        match getProjFnForField? env structName fieldName with\n        | none        => none\n        | some projFn => getPathToBaseStructureAux env baseStructName parentStructName (projFn :: path)", "start": [174, 1], "end": [185, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.getPathToBaseStructure?", "code": "def getPathToBaseStructure? (env : Environment) (baseStructName : Name) (structName : Name) : Option (List Name) :=\n  getPathToBaseStructureAux env baseStructName structName []", "start": [187, 1], "end": [192, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.isStructureLike", "code": "def isStructureLike (env : Environment) (constName : Name) : Bool :=\n  match env.find? constName with\n  | some (.inductInfo { isRec := false, ctors := [_], numIndices := 0, .. }) => true\n  | _ => false", "start": [194, 1], "end": [198, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.getStructureLikeNumFields", "code": "def getStructureLikeNumFields (env : Environment) (constName : Name) : Nat :=\n  match env.find? constName with\n  | some (.inductInfo { isRec := false, ctors := [ctor], numIndices := 0, .. }) =>\n    match env.find? ctor with\n    | some (.ctorInfo { numFields := n, .. }) => n\n    | _ => 0\n  | _ => 0", "start": [200, 1], "end": [207, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/GetUnfoldableConst.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/GlobalInstances.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.canUnfoldDefault", "code": "private def canUnfoldDefault (cfg : Config) (info : ConstantInfo) : CoreM Bool := do\n  match cfg.transparency with\n  | .all => return true\n  | .default => return !(\u2190 isIrreducible info.name)\n  | m =>\n    if (\u2190 isReducible info.name) then\n      return true\n    else if m == .instances && isGlobalInstance (\u2190 getEnv) info.name then\n      return true\n    else\n      return false", "start": [10, 1], "end": [20, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.canUnfold", "code": "def canUnfold (info : ConstantInfo) : MetaM Bool := do\n  let ctx \u2190 read\n  if let some f := ctx.canUnfold? then\n    f ctx.config info\n  else\n    canUnfoldDefault ctx.config info", "start": [22, 1], "end": [27, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getUnfoldableConst?", "code": "def getUnfoldableConst? (constName : Name) : MetaM (Option ConstantInfo) := do\n  match (\u2190 getEnv).find? constName with\n  | some (info@(.thmInfo _))  => getTheoremInfo info\n  | some (info@(.defnInfo _)) => if (\u2190 canUnfold info) then return info else return none\n  | some info                 => return some info\n  | none                      => throwUnknownConstant constName", "start": [29, 1], "end": [42, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getUnfoldableConstNoEx?", "code": "def getUnfoldableConstNoEx? (constName : Name) : MetaM (Option ConstantInfo) := do\n  match (\u2190 getEnv).find? constName with\n  | some (info@(.thmInfo _))  => getTheoremInfo info\n  | some (info@(.defnInfo _)) => if (\u2190 canUnfold info) then return info else return none\n  | some info                 => return some info\n  | none                      => return none", "start": [44, 1], "end": [52, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/MatcherInfo.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.Match.DiscrInfo", "code": "structure DiscrInfo where\n  \n  hName? : Option Name := none\n  deriving Inhabited", "start": [11, 1], "end": [14, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherInfo", "code": "structure MatcherInfo where\n  numParams    : Nat\n  numDiscrs    : Nat\n  altNumParams : Array Nat\n  uElimPos?    : Option Nat\n  \n  discrInfos   : Array DiscrInfo", "start": [16, 1], "end": [33, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherInfo.numAlts", "code": "def MatcherInfo.numAlts (info : MatcherInfo) : Nat :=\n  info.altNumParams.size", "start": [35, 1], "end": [36, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherInfo.arity", "code": "def MatcherInfo.arity (info : MatcherInfo) : Nat :=\n  info.numParams + 1 + info.numDiscrs + info.numAlts", "start": [38, 1], "end": [39, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherInfo.getFirstDiscrPos", "code": "def MatcherInfo.getFirstDiscrPos (info : MatcherInfo) : Nat :=\n  info.numParams + 1", "start": [41, 1], "end": [42, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherInfo.getDiscrRange", "code": "def MatcherInfo.getDiscrRange (info : MatcherInfo) : Std.Range :=\n  { start := info.getFirstDiscrPos, stop := info.getFirstDiscrPos + info.numDiscrs }", "start": [44, 1], "end": [45, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherInfo.getFirstAltPos", "code": "def MatcherInfo.getFirstAltPos (info : MatcherInfo) : Nat :=\n  info.numParams + 1 + info.numDiscrs", "start": [47, 1], "end": [48, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherInfo.getAltRange", "code": "def MatcherInfo.getAltRange (info : MatcherInfo) : Std.Range :=\n  { start := info.getFirstAltPos, stop := info.getFirstAltPos + info.numAlts }", "start": [50, 1], "end": [51, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherInfo.getMotivePos", "code": "def MatcherInfo.getMotivePos (info : MatcherInfo) : Nat :=\n  info.numParams", "start": [53, 1], "end": [54, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.getNumEqsFromDiscrInfos", "code": "def getNumEqsFromDiscrInfos (infos : Array DiscrInfo) : Nat := Id.run do\n  let mut r := 0\n  for info in infos do\n    if info.hName?.isSome then\n      r := r + 1\n  return r", "start": [56, 1], "end": [61, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherInfo.getNumDiscrEqs", "code": "def MatcherInfo.getNumDiscrEqs (info : MatcherInfo) : Nat :=\n  getNumEqsFromDiscrInfos info.discrInfos", "start": [63, 1], "end": [64, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Extension.Entry", "code": "structure Entry where\n  name : Name\n  info : MatcherInfo", "start": [68, 1], "end": [70, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Extension.State", "code": "structure State where\n  map : SMap Name MatcherInfo := {}", "start": [72, 1], "end": [73, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Extension.State.addEntry", "code": "def State.addEntry (s : State) (e : Entry) : State := { s with map  := s.map.insert e.name e.info }", "start": [77, 1], "end": [77, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Extension.State.switch", "code": "def State.switch (s : State) : State :=  { s with map := s.map.switch }", "start": [78, 1], "end": [78, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Extension.addMatcherInfo", "code": "def addMatcherInfo (env : Environment) (matcherName : Name) (info : MatcherInfo) : Environment :=\n  extension.addEntry env { name := matcherName, info := info }", "start": [86, 1], "end": [87, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Extension.getMatcherInfo?", "code": "def getMatcherInfo? (env : Environment) (declName : Name) : Option MatcherInfo :=\n  (extension.getState env).map.find? declName", "start": [89, 1], "end": [90, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.addMatcherInfo", "code": "def addMatcherInfo (matcherName : Name) (info : MatcherInfo) : MetaM Unit :=\n  modifyEnv fun env => Extension.addMatcherInfo env matcherName info", "start": [94, 1], "end": [95, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMatcherInfoCore?", "code": "def getMatcherInfoCore? (env : Environment) (declName : Name) : Option MatcherInfo :=\n  Match.Extension.getMatcherInfo? env declName", "start": [101, 1], "end": [102, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMatcherInfo?", "code": "def getMatcherInfo? [Monad m] [MonadEnv m] (declName : Name) : m (Option MatcherInfo) :=\n  return getMatcherInfoCore? (\u2190 getEnv) declName", "start": [104, 1], "end": [105, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isMatcherCore", "code": "@[export lean_is_matcher]\ndef isMatcherCore (env : Environment) (declName : Name) : Bool :=\n  getMatcherInfoCore? env declName |>.isSome", "start": [107, 1], "end": [109, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isMatcher", "code": "def isMatcher [Monad m] [MonadEnv m] (declName : Name) : m Bool :=\n  return isMatcherCore (\u2190 getEnv) declName", "start": [111, 1], "end": [112, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isMatcherAppCore?", "code": "def isMatcherAppCore? (env : Environment) (e : Expr) : Option MatcherInfo :=\n  let fn := e.getAppFn\n  if fn.isConst then\n    if let some matcherInfo := getMatcherInfoCore? env fn.constName! then\n      if e.getAppNumArgs \u2265 matcherInfo.arity then some matcherInfo else none\n    else\n      none\n  else\n    none", "start": [114, 1], "end": [122, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isMatcherAppCore", "code": "def isMatcherAppCore (env : Environment) (e : Expr) : Bool :=\n  isMatcherAppCore? env e |>.isSome", "start": [124, 1], "end": [125, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isMatcherApp", "code": "def isMatcherApp [Monad m] [MonadEnv m] (e : Expr) : m Bool :=\n  return isMatcherAppCore (\u2190 getEnv) e", "start": [127, 1], "end": [128, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MatcherApp", "code": "structure MatcherApp where\n  matcherName   : Name\n  matcherLevels : Array Level\n  uElimPos?     : Option Nat\n  params        : Array Expr\n  motive        : Expr\n  discrs        : Array Expr\n  altNumParams  : Array Nat\n  alts          : Array Expr\n  remaining     : Array Expr", "start": [130, 1], "end": [139, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchMatcherApp?", "code": "def matchMatcherApp? [Monad m] [MonadEnv m] (e : Expr) : m (Option MatcherApp) := do\n  match e.getAppFn with\n  | Expr.const declName declLevels =>\n    match (\u2190 getMatcherInfo? declName) with\n    | none => return none\n    | some info =>\n      let args := e.getAppArgs\n      if args.size < info.arity then\n        return none\n      else\n        return some {\n          matcherName   := declName\n          matcherLevels := declLevels.toArray\n          uElimPos?     := info.uElimPos?\n          params        := args.extract 0 info.numParams\n          motive        := args[info.getMotivePos]!\n          discrs        := args[info.numParams + 1 : info.numParams + 1 + info.numDiscrs]\n          altNumParams  := info.altNumParams\n          alts          := args[info.numParams + 1 + info.numDiscrs : info.numParams + 1 + info.numDiscrs + info.numAlts]\n          remaining     := args[info.numParams + 1 + info.numDiscrs + info.numAlts : args.size]\n        }\n  | _ => return none", "start": [141, 1], "end": [162, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.MatcherApp.toExpr", "code": "def MatcherApp.toExpr (matcherApp : MatcherApp) : Expr :=\n  let result := mkAppN (mkConst matcherApp.matcherName matcherApp.matcherLevels.toList) matcherApp.params\n  let result := mkApp result matcherApp.motive\n  let result := mkAppN result matcherApp.discrs\n  let result := mkAppN result matcherApp.alts\n  mkAppN result matcherApp.remaining", "start": [164, 1], "end": [169, 37], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/MatchPatternAttr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.hasMatchPatternAttribute", "code": "@[export lean_has_match_pattern_attribute]\ndef hasMatchPatternAttribute (env : Environment) (n : Name) : Bool :=\n  matchPatternAttr.hasTag env n", "start": [13, 1], "end": [15, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/Recognizers.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.const?", "code": "@[inline] def const? (e : Expr) : Option (Name \u00d7 List Level) :=\n  match e with\n  | Expr.const n us => some (n, us)\n  | _ => none", "start": [11, 1], "end": [14, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.app1?", "code": "@[inline] def app1? (e : Expr) (fName : Name) : Option Expr :=\n  if e.isAppOfArity fName 1 then\n    some e.appArg!\n  else\n    none", "start": [16, 1], "end": [20, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.app2?", "code": "@[inline] def app2? (e : Expr) (fName : Name) : Option (Expr \u00d7 Expr) :=\n  if e.isAppOfArity fName 2 then\n    some (e.appFn!.appArg!, e.appArg!)\n  else\n    none", "start": [22, 1], "end": [26, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.app3?", "code": "@[inline] def app3? (e : Expr) (fName : Name) : Option (Expr \u00d7 Expr \u00d7 Expr) :=\n  if e.isAppOfArity fName 3 then\n    some (e.appFn!.appFn!.appArg!, e.appFn!.appArg!, e.appArg!)\n  else\n    none", "start": [28, 1], "end": [32, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.app4?", "code": "@[inline] def app4? (e : Expr) (fName : Name) : Option (Expr \u00d7 Expr \u00d7 Expr \u00d7 Expr) :=\n  if e.isAppOfArity fName 4 then\n    some (e.appFn!.appFn!.appFn!.appArg!, e.appFn!.appFn!.appArg!, e.appFn!.appArg!, e.appArg!)\n  else\n    none", "start": [34, 1], "end": [38, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.eq?", "code": "@[inline] def eq? (p : Expr) : Option (Expr \u00d7 Expr \u00d7 Expr) :=\n  p.app3? ``Eq", "start": [40, 1], "end": [41, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ne?", "code": "@[inline] def ne? (p : Expr) : Option (Expr \u00d7 Expr \u00d7 Expr) :=\n  p.app3? ``Ne", "start": [43, 1], "end": [44, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.iff?", "code": "@[inline] def iff? (p : Expr) : Option (Expr \u00d7 Expr) :=\n  p.app2? ``Iff", "start": [46, 1], "end": [47, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.eqOrIff?", "code": "@[inline] def eqOrIff? (p : Expr) : Option (Expr \u00d7 Expr) :=\n  if let some (_, lhs, rhs) := p.app3? ``Eq then\n    some (lhs, rhs)\n  else\n    p.iff?", "start": [49, 1], "end": [53, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.not?", "code": "@[inline] def not? (p : Expr) : Option Expr :=\n  p.app1? ``Not", "start": [55, 1], "end": [56, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.notNot?", "code": "@[inline] def notNot? (p : Expr) : Option Expr :=\n  match p.not? with\n  | some p => p.not?\n  | none => none", "start": [58, 1], "end": [61, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.and?", "code": "@[inline] def and? (p : Expr) : Option (Expr \u00d7 Expr) :=\n  p.app2? ``And", "start": [63, 1], "end": [64, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.heq?", "code": "@[inline] def heq? (p : Expr) : Option (Expr \u00d7 Expr \u00d7 Expr \u00d7 Expr) :=\n  p.app4? ``HEq", "start": [66, 1], "end": [67, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.natAdd?", "code": "def natAdd? (e : Expr) : Option (Expr \u00d7 Expr) :=\n  e.app2? ``Nat.add", "start": [69, 1], "end": [70, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.arrow?", "code": "@[inline] def arrow? : Expr \u2192 Option (Expr \u00d7 Expr)\n  | Expr.forallE _ \u03b1 \u03b2 _ => if \u03b2.hasLooseBVars then none else some (\u03b1, \u03b2)\n  | _                    => none", "start": [72, 1], "end": [74, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isEq", "code": "def isEq (e : Expr) :=\n  e.isAppOfArity ``Eq 3", "start": [76, 1], "end": [77, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isHEq", "code": "def isHEq (e : Expr) :=\n  e.isAppOfArity ``HEq 4", "start": [79, 1], "end": [80, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isIte", "code": "def isIte (e : Expr) :=\n  e.isAppOfArity ``ite 5", "start": [82, 1], "end": [83, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isDIte", "code": "def isDIte (e : Expr) :=\n  e.isAppOfArity ``dite 5", "start": [85, 1], "end": [86, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.listLit?", "code": "partial def listLit? (e : Expr) : Option (Expr \u00d7 List Expr) :=\n  let rec loop (e : Expr) (acc : List Expr) :=\n    if e.isAppOfArity' ``List.nil 1 then\n      some (e.appArg!', acc.reverse)\n    else if e.isAppOfArity' ``List.cons 3 then\n      loop e.appArg!' (e.appFn!'.appArg!' :: acc)\n    else\n      none\n  loop e []", "start": [88, 1], "end": [96, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.arrayLit?", "code": "def arrayLit? (e : Expr) : Option (Expr \u00d7 List Expr) :=\n  if e.isAppOfArity' ``List.toArray 2 then\n    listLit? e.appArg!'\n  else\n    none", "start": [98, 1], "end": [102, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.prod?", "code": "def prod? (e : Expr) : Option (Expr \u00d7 Expr) :=\n  e.app2? ``Prod", "start": [104, 1], "end": [106, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getConstructorVal?", "code": "private def getConstructorVal? (env : Environment) (ctorName : Name) : Option ConstructorVal :=\n  match env.find? ctorName with\n  | some (ConstantInfo.ctorInfo v) => v\n  | _                              => none", "start": [108, 1], "end": [111, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isConstructorApp?", "code": "def isConstructorApp? (env : Environment) (e : Expr) : Option ConstructorVal :=\n  match e with\n  | Expr.lit (Literal.natVal n) => if n == 0 then getConstructorVal? env `Nat.zero else getConstructorVal? env `Nat.succ\n  | _ =>\n    match e.getAppFn with\n    | Expr.const n _ => match getConstructorVal? env n with\n      | some v => if v.numParams + v.numFields == e.getAppNumArgs then some v else none\n      | none   => none\n    | _ => none", "start": [113, 1], "end": [121, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isConstructorApp", "code": "def isConstructorApp (env : Environment) (e : Expr) : Bool :=\n  e.isConstructorApp? env |>.isSome", "start": [123, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.constructorApp?", "code": "def constructorApp? (env : Environment) (e : Expr) (useRaw := false) : Option (ConstructorVal \u00d7 Array Expr) := do\n  match e with\n  | Expr.lit (Literal.natVal n) =>\n    if n == 0 then do\n      let v \u2190 getConstructorVal? env `Nat.zero\n      pure (v, #[])\n    else do\n      let v \u2190 getConstructorVal? env `Nat.succ\n      pure (v, #[if useRaw then mkRawNatLit (n-1) else mkNatLit (n-1)])\n  | _ =>\n    match e.getAppFn with\n    | Expr.const n _ => do\n      let v \u2190 getConstructorVal? env n\n      if v.numParams + v.numFields == e.getAppNumArgs then\n        pure (v, e.getAppArgs)\n      else\n        none\n    | _ => none", "start": [126, 1], "end": [152, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Level.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Extra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.levelParser", "code": "@[inline] def levelParser (rbp : Nat := 0) : Parser :=\n  categoryParser `level rbp", "start": [14, 1], "end": [15, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Level.paren", "code": "@[builtin_level_parser] def paren  := leading_parser\n  \"(\" >> withoutPosition levelParser >> \")\"", "start": [19, 1], "end": [20, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Level.max", "code": "@[builtin_level_parser] def max    := leading_parser\n  nonReservedSymbol \"max\" true  >> many1 (ppSpace >> levelParser maxPrec)", "start": [21, 1], "end": [22, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Level.imax", "code": "@[builtin_level_parser] def imax   := leading_parser\n  nonReservedSymbol \"imax\" true >> many1 (ppSpace >> levelParser maxPrec)", "start": [23, 1], "end": [24, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Level.hole", "code": "@[builtin_level_parser] def hole   := leading_parser\n  \"_\"", "start": [25, 1], "end": [26, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Level.num", "code": "@[builtin_level_parser] def num    :=\n  checkPrec maxPrec >> numLit", "start": [27, 1], "end": [28, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Level.ident", "code": "@[builtin_level_parser] def ident  :=\n  checkPrec maxPrec >> Parser.ident", "start": [29, 1], "end": [30, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Level.addLit", "code": "@[builtin_level_parser] def addLit := trailing_parser:65\n  \" + \" >> numLit", "start": [31, 1], "end": [32, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Attr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Extra.lean", "lake-packages/lean4/src/lean/Lean/Parser/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.priorityParser", "code": "@[inline] def priorityParser (rbp : Nat := 0) : Parser :=\n  categoryParser `prio rbp", "start": [19, 1], "end": [20, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.attrParser", "code": "@[inline] def attrParser (rbp : Nat := 0) : Parser :=\n  categoryParser `attr rbp", "start": [22, 1], "end": [23, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Priority.numPrio", "code": "@[builtin_prio_parser] def numPrio  := checkPrec maxPrec >> numLit", "start": [29, 1], "end": [29, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.simple", "code": "@[builtin_attr_parser] def simple     := leading_parser ident >> optional (ppSpace >> (priorityParser <|> ident))", "start": [35, 1], "end": [35, 114], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.macro", "code": "@[builtin_attr_parser] def \u00abmacro\u00bb    := leading_parser \"macro \" >> ident", "start": [37, 1], "end": [37, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.export", "code": "@[builtin_attr_parser] def \u00abexport\u00bb   := leading_parser \"export \" >> ident", "start": [38, 1], "end": [38, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.recursor", "code": "@[builtin_attr_parser] def recursor         := leading_parser nonReservedSymbol \"recursor \" >> numLit", "start": [41, 1], "end": [41, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.class", "code": "@[builtin_attr_parser] def \u00abclass\u00bb          := leading_parser \"class\"", "start": [42, 1], "end": [42, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.instance", "code": "@[builtin_attr_parser] def \u00abinstance\u00bb       := leading_parser \"instance\" >> optional (ppSpace >> priorityParser)", "start": [43, 1], "end": [43, 113], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.default_instance", "code": "@[builtin_attr_parser] def default_instance := leading_parser nonReservedSymbol \"default_instance\" >> optional (ppSpace >> priorityParser)", "start": [44, 1], "end": [44, 139], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.specialize", "code": "@[builtin_attr_parser] def \u00abspecialize\u00bb     := leading_parser (nonReservedSymbol \"specialize\") >> many (ppSpace >> (ident <|> numLit))", "start": [45, 1], "end": [45, 135], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.externEntry", "code": "def externEntry := leading_parser\n  optional (ident >> ppSpace) >> optional (nonReservedSymbol \"inline \") >> strLit", "start": [47, 1], "end": [48, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Attr.extern", "code": "@[builtin_attr_parser] def extern     := leading_parser\n  nonReservedSymbol \"extern\" >> optional (ppSpace >> numLit) >> many (ppSpace >> externEntry)", "start": [49, 1], "end": [50, 94], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.TransformStep", "code": "inductive TransformStep where\n  \n  | done (e : Expr)\n  \n  | visit (e : Expr)\n  \n  | continue (e? : Option Expr := none)", "start": [10, 1], "end": [22, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.transform", "code": "partial def transform {m} [Monad m] [MonadLiftT CoreM m] [MonadControlT CoreM m]\n    (input : Expr)\n    (pre   : Expr \u2192 m TransformStep := fun _ => return .continue)\n    (post  : Expr \u2192 m TransformStep := fun e => return .done e)\n    : m Expr :=\n  let _ : STWorld IO.RealWorld m := \u27e8\u27e9\n  let _ : MonadLiftT (ST IO.RealWorld) m := { monadLift := fun x => liftM (m := CoreM) (liftM (m := ST IO.RealWorld) x) }\n  let rec visit (e : Expr) : MonadCacheT ExprStructEq Expr m Expr :=\n    checkCache { val := e : ExprStructEq } fun _ => Core.withIncRecDepth do\n      let rec visitPost (e : Expr) : MonadCacheT ExprStructEq Expr m Expr := do\n        match (\u2190 post e) with\n        | .done e      => pure e\n        | .visit e     => visit e\n        | .continue e? => pure (e?.getD e)\n      match (\u2190 pre e) with\n      | .done e  => pure e\n      | .visit e => visitPost (\u2190 visit e)\n      | .continue e? =>\n        let e := e?.getD e\n        match e with\n        | Expr.forallE _ d b _ => visitPost (e.updateForallE! (\u2190 visit d) (\u2190 visit b))\n        | Expr.lam _ d b _     => visitPost (e.updateLambdaE! (\u2190 visit d) (\u2190 visit b))\n        | Expr.letE _ t v b _  => visitPost (e.updateLet! (\u2190 visit t) (\u2190 visit v) (\u2190 visit b))\n        | Expr.app ..          => e.withApp fun f args => do visitPost (mkAppN (\u2190 visit f) (\u2190 args.mapM visit))\n        | Expr.mdata _ b       => visitPost (e.updateMData! (\u2190 visit b))\n        | Expr.proj _ _ b      => visitPost (e.updateProj! (\u2190 visit b))\n        | _                    => visitPost e\n  visit input |>.run", "start": [26, 1], "end": [65, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.betaReduce", "code": "def betaReduce (e : Expr) : CoreM Expr :=\n  transform e (pre := fun e => return if e.isHeadBetaTarget then .visit e.headBeta else .continue)", "start": [67, 1], "end": [68, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.transform", "code": "partial def transform {m} [Monad m] [MonadLiftT MetaM m] [MonadControlT MetaM m] [MonadTrace m] [MonadRef m] [MonadOptions m] [AddMessageContext m]\n    (input : Expr)\n    (pre   : Expr \u2192 m TransformStep := fun _ => return .continue)\n    (post  : Expr \u2192 m TransformStep := fun e => return .done e)\n    (usedLetOnly := false)\n    : m Expr := do\n  let _ : STWorld IO.RealWorld m := \u27e8\u27e9\n  let _ : MonadLiftT (ST IO.RealWorld) m := { monadLift := fun x => liftM (m := MetaM) (liftM (m := ST IO.RealWorld) x) }\n  let rec visit (e : Expr) : MonadCacheT ExprStructEq Expr m Expr :=\n    checkCache { val := e : ExprStructEq } fun _ => Meta.withIncRecDepth do\n      let rec visitPost (e : Expr) : MonadCacheT ExprStructEq Expr m Expr := do\n        match (\u2190 post e) with\n        | .done e      => pure e\n        | .visit e     => visit e\n        | .continue e? => pure (e?.getD e)\n      let rec visitLambda (fvars : Array Expr) (e : Expr) : MonadCacheT ExprStructEq Expr m Expr := do\n        match e with\n        | Expr.lam n d b c =>\n          withLocalDecl n c (\u2190 visit (d.instantiateRev fvars)) fun x =>\n            visitLambda (fvars.push x) b\n        | e => visitPost (\u2190 mkLambdaFVars (usedLetOnly := usedLetOnly) fvars (\u2190 visit (e.instantiateRev fvars)))\n      let rec visitForall (fvars : Array Expr) (e : Expr) : MonadCacheT ExprStructEq Expr m Expr := do\n        match e with\n        | Expr.forallE n d b c =>\n          withLocalDecl n c (\u2190 visit (d.instantiateRev fvars)) fun x =>\n            visitForall (fvars.push x) b\n        | e => visitPost (\u2190 mkForallFVars (usedLetOnly := usedLetOnly) fvars (\u2190 visit (e.instantiateRev fvars)))\n      let rec visitLet (fvars : Array Expr) (e : Expr) : MonadCacheT ExprStructEq Expr m Expr := do\n        match e with\n        | Expr.letE n t v b _ =>\n          withLetDecl n (\u2190 visit (t.instantiateRev fvars)) (\u2190 visit (v.instantiateRev fvars)) fun x =>\n            visitLet (fvars.push x) b\n        | e => visitPost (\u2190 mkLetFVars (usedLetOnly := usedLetOnly) fvars (\u2190 visit (e.instantiateRev fvars)))\n      let visitApp (e : Expr) : MonadCacheT ExprStructEq Expr m Expr :=\n        e.withApp fun f args => do\n          visitPost (mkAppN (\u2190 visit f) (\u2190 args.mapM visit))\n      match (\u2190 pre e) with\n      | .done e  => pure e\n      | .visit e => visit e\n      | .continue e? =>\n        let e := e?.getD e\n        match e with\n        | Expr.forallE ..    => visitForall #[] e\n        | Expr.lam ..        => visitLambda #[] e\n        | Expr.letE ..       => visitLet #[] e\n        | Expr.app ..        => visitApp e\n        | Expr.mdata _ b     => visitPost (e.updateMData! (\u2190 visit b))\n        | Expr.proj _ _ b    => visitPost (e.updateProj! (\u2190 visit b))\n        | _                  => visitPost e\n  visit input |>.run", "start": [74, 1], "end": [126, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.zetaReduce", "code": "def zetaReduce (e : Expr) : MetaM Expr := do\n  let pre (e : Expr) : MetaM TransformStep := do\n    match e with\n    | Expr.fvar fvarId =>\n      match (\u2190 getLCtx).find? fvarId with\n      | none => return TransformStep.done e\n      | some localDecl =>\n        if let some value := localDecl.value? then\n          return TransformStep.visit value\n        else\n          return TransformStep.done e\n    | _ => return .continue\n  transform e (pre := pre) (usedLetOnly := true)", "start": [128, 1], "end": [140, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldDeclsFrom", "code": "def unfoldDeclsFrom (biggerEnv : Environment) (e : Expr) : CoreM Expr := do\n  withoutModifyingEnv do\n    let env \u2190 getEnv\n    setEnv biggerEnv let pre (e : Expr) : CoreM TransformStep := do\n      match e with\n      | Expr.const declName us .. =>\n        if env.contains declName then\n          return TransformStep.done e\n        else if let some info := biggerEnv.find? declName then\n          if info.hasValue then\n            return TransformStep.visit (\u2190 instantiateValueLevelParams info us)\n          else\n            return TransformStep.done e\n        else\n          return TransformStep.done e\n      | _ => return .continue\n    Core.transform e (pre := pre)", "start": [142, 1], "end": [160, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.eraseInaccessibleAnnotations", "code": "def eraseInaccessibleAnnotations (e : Expr) : CoreM Expr :=\n  Core.transform e (post := fun e => return TransformStep.done <| if let some e := inaccessible? e then e else e)", "start": [162, 1], "end": [163, 114], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.erasePatternRefAnnotations", "code": "def erasePatternRefAnnotations (e : Expr) : CoreM Expr :=\n  Core.transform e (post := fun e => return TransformStep.done <| if let some (_, e) := patternWithRef? e then e else e)", "start": [165, 1], "end": [166, 121], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/DiscrTreeTypes.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.DiscrTree.Key", "code": "inductive Key (simpleReduce : Bool) where\n  | const : Name \u2192 Nat \u2192 Key simpleReduce\n  | fvar  : FVarId \u2192 Nat \u2192 Key simpleReduce\n  | lit   : Literal \u2192 Key simpleReduce\n  | star  : Key simpleReduce\n  | other : Key simpleReduce\n  | arrow : Key simpleReduce\n  | proj  : Name \u2192 Nat \u2192 Nat \u2192 Key simpleReduce\n  deriving Inhabited, BEq, Repr", "start": [13, 1], "end": [24, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Key.hash", "code": "protected def Key.hash : Key s \u2192 UInt64\n  | Key.const n a   => mixHash 5237 $ mixHash (hash n) (hash a)\n  | Key.fvar n a    => mixHash 3541 $ mixHash (hash n) (hash a)\n  | Key.lit v       => mixHash 1879 $ hash v\n  | Key.star        => 7883\n  | Key.other       => 2411\n  | Key.arrow       => 17\n  | Key.proj s i a  =>  mixHash (hash a) $ mixHash (hash s) (hash i)", "start": [26, 1], "end": [33, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie", "code": "inductive Trie (\u03b1 : Type) (simpleReduce : Bool) where\n  | node (vs : Array \u03b1) (children : Array (Key simpleReduce \u00d7 Trie \u03b1 simpleReduce)) : Trie \u03b1 simpleReduce", "start": [37, 1], "end": [41, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree", "code": "structure DiscrTree (\u03b1 : Type) (simpleReduce : Bool) where\n  root : PersistentHashMap (Key simpleReduce) (Trie \u03b1 simpleReduce) := {}", "start": [47, 1], "end": [84, 74], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/WHNF.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Recognizers.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatchPatternAttr.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatcherInfo.lean", "lake-packages/lean4/src/lean/Lean/Meta/GetUnfoldableConst.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Structure.lean", "lake-packages/lean4/src/lean/Lean/Meta/FunInfo.lean"], "premises": [{"full_name": "Lean.Meta.getStructuralRecArgPos?", "code": "@[extern \"lean_get_structural_rec_arg_pos\"]\nopaque getStructuralRecArgPos? (declName : Name) : CoreM (Option Nat)", "start": [19, 1], "end": [25, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.smartUnfoldingSuffix", "code": "def smartUnfoldingSuffix := \"_sunfold\"", "start": [27, 1], "end": [27, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSmartUnfoldingNameFor", "code": "@[inline] def mkSmartUnfoldingNameFor (declName : Name) : Name :=\n  Name.mkStr declName smartUnfoldingSuffix", "start": [29, 1], "end": [30, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.hasSmartUnfoldingDecl", "code": "def hasSmartUnfoldingDecl (env : Environment) (declName : Name) : Bool :=\n  env.contains (mkSmartUnfoldingNameFor declName)", "start": [32, 1], "end": [33, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.markSmartUnfoldingMatch", "code": "def markSmartUnfoldingMatch (e : Expr) : Expr :=\n  mkAnnotation `sunfoldMatch e", "start": [40, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.smartUnfoldingMatch?", "code": "def smartUnfoldingMatch? (e : Expr) : Option Expr :=\n  annotation? `sunfoldMatch e", "start": [44, 1], "end": [45, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.markSmartUnfoldingMatchAlt", "code": "def markSmartUnfoldingMatchAlt (e : Expr) : Expr :=\n  mkAnnotation `sunfoldMatchAlt e", "start": [47, 1], "end": [49, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.smartUnfoldingMatchAlt?", "code": "def smartUnfoldingMatchAlt? (e : Expr) : Option Expr :=\n  annotation? `sunfoldMatchAlt e", "start": [51, 1], "end": [52, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isAuxDef", "code": "def isAuxDef (constName : Name) : MetaM Bool := do\n  let env \u2190 getEnv\n  return isAuxRecursor env constName || isNoConfusion env constName", "start": [58, 1], "end": [60, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchConstAux", "code": "@[inline] private def matchConstAux {\u03b1} (e : Expr) (failK : Unit \u2192 MetaM \u03b1) (k : ConstantInfo \u2192 List Level \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  match e with\n  | Expr.const name lvls => do\n    let (some cinfo) \u2190 getUnfoldableConst? name | failK ()\n    k cinfo lvls\n  | _ => failK ()", "start": [62, 1], "end": [67, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getFirstCtor", "code": "private def getFirstCtor (d : Name) : MetaM (Option Name) := do\n  let some (ConstantInfo.inductInfo { ctors := ctor::_, ..}) \u2190 getUnfoldableConstNoEx? d | pure none\n  return some ctor", "start": [73, 1], "end": [75, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkNullaryCtor", "code": "private def mkNullaryCtor (type : Expr) (nparams : Nat) : MetaM (Option Expr) := do\n  match type.getAppFn with\n  | Expr.const d lvls =>\n    let (some ctor) \u2190 getFirstCtor d | pure none\n    return mkAppN (mkConst ctor lvls) (type.getAppArgs.shrink nparams)\n  | _ =>\n    return none", "start": [77, 1], "end": [83, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getRecRuleFor", "code": "private def getRecRuleFor (recVal : RecursorVal) (major : Expr) : Option RecursorRule :=\n  match major.getAppFn with\n  | Expr.const fn _ => recVal.rules.find? fun r => r.ctor == fn\n  | _               => none", "start": [85, 1], "end": [88, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.toCtorWhenK", "code": "private def toCtorWhenK (recVal : RecursorVal) (major : Expr) : MetaM Expr := do\n  let majorType \u2190 inferType major\n  let majorType \u2190 instantiateMVars (\u2190 whnf majorType)\n  let majorTypeI := majorType.getAppFn\n  if !majorTypeI.isConstOf recVal.getInduct then\n    return major\n  else if majorType.hasExprMVar && majorType.getAppArgs[recVal.numParams:].any Expr.hasExprMVar then\n    return major\n  else do\n    let (some newCtorApp) \u2190 mkNullaryCtor majorType recVal.numParams | pure major\n    let newType \u2190 inferType newCtorApp\n    \n    if (\u2190 withAtLeastTransparency TransparencyMode.default <| withNewMCtxDepth <| isDefEq majorType newType) then\n      return newCtorApp\n    else\n      return major", "start": [90, 1], "end": [111, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkProjFn", "code": "def mkProjFn (ctorVal : ConstructorVal) (us : List Level) (params : Array Expr) (i : Nat) (major : Expr) : CoreM Expr := do\n  match getStructureInfo? (\u2190 getEnv) ctorVal.induct with\n  | none => return mkProj ctorVal.induct i major\n  | some info => match info.getProjFn? i with\n    | none => return mkProj ctorVal.induct i major\n    | some projFn => return mkApp (mkAppN (mkConst projFn us) params) major", "start": [113, 1], "end": [122, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.toCtorWhenStructure", "code": "private def toCtorWhenStructure (inductName : Name) (major : Expr) : MetaM Expr := do\n  unless (\u2190 useEtaStruct inductName) do\n    return major\n  let env \u2190 getEnv\n  if !isStructureLike env inductName then\n    return major\n  else if let some _ := major.isConstructorApp? env then\n    return major\n  else\n    let majorType \u2190 inferType major\n    let majorType \u2190 instantiateMVars (\u2190 whnf majorType)\n    let majorTypeI := majorType.getAppFn\n    if !majorTypeI.isConstOf inductName then\n      return major\n    match majorType.getAppFn with\n    | Expr.const d us =>\n      if (\u2190 whnfD (\u2190 inferType majorType)) == mkSort levelZero then\n        return major else\n        let some ctorName \u2190 getFirstCtor d | pure major\n        let ctorInfo \u2190 getConstInfoCtor ctorName\n        let params := majorType.getAppArgs.shrink ctorInfo.numParams\n        let mut result := mkAppN (mkConst ctorName us) params\n        for i in [:ctorInfo.numFields] do\n          result := mkApp result (\u2190 mkProjFn ctorInfo us params i major)\n        return result\n    | _ => return major", "start": [124, 1], "end": [156, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isWFRec", "code": "private def isWFRec (declName : Name) : Bool :=\n  declName == ``Acc.rec || declName == ``WellFounded.rec", "start": [160, 1], "end": [161, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceRec", "code": "private def reduceRec (recVal : RecursorVal) (recLvls : List Level) (recArgs : Array Expr) (failK : Unit \u2192 MetaM \u03b1) (successK : Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  let majorIdx := recVal.getMajorIdx\n  if h : majorIdx < recArgs.size then do\n    let major := recArgs.get \u27e8majorIdx, h\u27e9\n    let mut major \u2190 if isWFRec recVal.name && (\u2190 getTransparency) == TransparencyMode.default then\n      withTransparency .all <| whnf major\n    else\n      whnf major\n    if recVal.k then\n      major \u2190 toCtorWhenK recVal major\n    major := major.toCtorIfLit\n    major \u2190 toCtorWhenStructure recVal.getInduct major\n    match getRecRuleFor recVal major with\n    | some rule =>\n      let majorArgs := major.getAppArgs\n      if recLvls.length != recVal.levelParams.length then\n        failK ()\n      else\n        let rhs := rule.rhs.instantiateLevelParams recVal.levelParams recLvls\n        let rhs := mkAppRange rhs 0 (recVal.numParams+recVal.numMotives+recVal.numMinors) recArgs\n        \n        let nparams := majorArgs.size - rule.nfields\n        let rhs := mkAppRange rhs nparams majorArgs.size majorArgs\n        let rhs := mkAppRange rhs (majorIdx + 1) recArgs.size recArgs\n        successK rhs\n    | none => failK ()\n  else\n    failK ()", "start": [163, 1], "end": [198, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceQuotRec", "code": "private def reduceQuotRec (recVal  : QuotVal) (recLvls : List Level) (recArgs : Array Expr) (failK : Unit \u2192 MetaM \u03b1) (successK : Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  let process (majorPos argPos : Nat) : MetaM \u03b1 :=\n    if h : majorPos < recArgs.size then do\n      let major := recArgs.get \u27e8majorPos, h\u27e9\n      let major \u2190 whnf major\n      match major with\n      | Expr.app (Expr.app (Expr.app (Expr.const majorFn _) _) _) majorArg => do\n        let some (ConstantInfo.quotInfo { kind := QuotKind.ctor, .. }) \u2190 getUnfoldableConstNoEx? majorFn | failK ()\n        let f := recArgs[argPos]!\n        let r := mkApp f majorArg\n        let recArity := majorPos + 1\n        successK <| mkAppRange r recArity recArgs.size recArgs\n      | _ => failK ()\n    else\n      failK ()\n  match recVal.kind with\n  | QuotKind.lift => process 5 3\n  | QuotKind.ind  => process 4 3\n  | _             => failK ()", "start": [204, 1], "end": [223, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isRecStuck?", "code": "private partial def isRecStuck? (recVal : RecursorVal) (recArgs : Array Expr) : MetaM (Option MVarId) :=\n    if recVal.k then\n      return none\n    else do\n      let majorIdx := recVal.getMajorIdx\n      if h : majorIdx < recArgs.size then do\n        let major := recArgs.get \u27e8majorIdx, h\u27e9\n        let major \u2190 whnf major\n        getStuckMVar? major\n      else\n        return none", "start": [230, 3], "end": [241, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isQuotRecStuck?", "code": "private partial def isQuotRecStuck? (recVal : QuotVal) (recArgs : Array Expr) : MetaM (Option MVarId) :=\n    let process? (majorPos : Nat) : MetaM (Option MVarId) :=\n      if h : majorPos < recArgs.size then do\n        let major := recArgs.get \u27e8majorPos, h\u27e9\n        let major \u2190 whnf major\n        getStuckMVar? major\n      else\n        return none\n    match recVal.kind with\n    | QuotKind.lift => process? 5\n    | QuotKind.ind  => process? 4\n    | _             => return none", "start": [243, 3], "end": [254, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getStuckMVar?", "code": "partial def getStuckMVar? (e : Expr) : MetaM (Option MVarId) := do\n    match e with\n    | .mdata _ e  => getStuckMVar? e\n    | .proj _ _ e => getStuckMVar? (\u2190 whnf e)\n    | .mvar .. =>\n      let e \u2190 instantiateMVars e\n      match e with\n      | .mvar mvarId => return some mvarId\n      | _ => getStuckMVar? e\n    | .app f .. =>\n      let f := f.getAppFn\n      match f with\n      | .mvar .. =>\n        let e \u2190 instantiateMVars e\n        match e.getAppFn with\n        | .mvar mvarId => return some mvarId\n        | _ => getStuckMVar? e\n      | .const fName _ =>\n        match (\u2190 getUnfoldableConstNoEx? fName) with\n        | some <| .recInfo recVal  => isRecStuck? recVal e.getAppArgs\n        | some <| .quotInfo recVal => isQuotRecStuck? recVal e.getAppArgs\n        | _  =>\n          unless e.hasExprMVar do return none\n          let some projInfo \u2190 getProjectionFnInfo? fName | return none\n          unless projInfo.fromClass do return none\n          let args := e.getAppArgs\n          if let some major := args.get? projInfo.numParams then\n            if let some mvarId \u2190 getStuckMVar? major then\n              return mvarId\n          \n          let info \u2190 getFunInfo f\n          for pinfo in info.paramInfo, arg in args do\n            if pinfo.isExplicit then\n              if let some mvarId \u2190 getStuckMVar? arg then\n                return some mvarId\n          return none\n      | .proj _ _ e => getStuckMVar? (\u2190 whnf e)\n      | _ => return none\n    | _ => return none", "start": [256, 3], "end": [303, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfEasyCases", "code": "@[specialize] partial def whnfEasyCases (e : Expr) (k : Expr \u2192 MetaM Expr) : MetaM Expr := do\n  match e with\n  | .forallE ..    => return e\n  | .lam ..        => return e\n  | .sort ..       => return e\n  | .lit ..        => return e\n  | .bvar ..       => panic! \"loose bvar in expression\"\n  | .letE ..       => k e\n  | .const ..      => k e\n  | .app ..        => k e\n  | .proj ..       => k e\n  | .mdata _ e     => whnfEasyCases e k\n  | .fvar fvarId   =>\n    let decl \u2190 fvarId.getDecl\n    match decl with\n    | .cdecl .. => return e\n    | .ldecl (value := v) (nonDep := nonDep) .. =>\n      let cfg \u2190 getConfig\n      if nonDep && !cfg.zetaNonDep then\n        return e\n      else\n        if cfg.trackZeta then\n          modify fun s => { s with zetaFVarIds := s.zetaFVarIds.insert fvarId }\n        whnfEasyCases v k\n  | .mvar mvarId   =>\n    match (\u2190 getExprMVarAssignment? mvarId) with\n    | some v => whnfEasyCases v k\n    | none   => return e", "start": [310, 1], "end": [338, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.deltaDefinition", "code": "@[specialize] private def deltaDefinition (c : ConstantInfo) (lvls : List Level)\n    (failK : Unit \u2192 MetaM \u03b1) (successK : Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  if c.levelParams.length != lvls.length then\n    failK ()\n  else\n    successK (\u2190 instantiateValueLevelParams c lvls)", "start": [340, 1], "end": [345, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.deltaBetaDefinition", "code": "@[specialize] private def deltaBetaDefinition (c : ConstantInfo) (lvls : List Level) (revArgs : Array Expr)\n    (failK : Unit \u2192 MetaM \u03b1) (successK : Expr \u2192 MetaM \u03b1) (preserveMData := false) : MetaM \u03b1 := do\n  if c.levelParams.length != lvls.length then\n    failK ()\n  else\n    let val \u2190 instantiateValueLevelParams c lvls\n    let val := val.betaRev revArgs (preserveMData := preserveMData)\n    successK val", "start": [347, 1], "end": [354, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ReduceMatcherResult", "code": "inductive ReduceMatcherResult where\n  | reduced (val : Expr)\n  | stuck   (val : Expr)\n  | notMatcher\n  | partialApp", "start": [356, 1], "end": [360, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.canUnfoldAtMatcher", "code": "def canUnfoldAtMatcher (cfg : Config) (info : ConstantInfo) : CoreM Bool := do\n  match cfg.transparency with\n  | TransparencyMode.all     => return true\n  | TransparencyMode.default => return !(\u2190 isIrreducible info.name)\n  | _ =>\n    if (\u2190 isReducible info.name) || isGlobalInstance (\u2190 getEnv) info.name then\n      return true\n    else if hasMatchPatternAttribute (\u2190 getEnv) info.name then\n      return true\n    else\n      return info.name == ``ite\n       || info.name == ``dite\n       || info.name == ``decEq\n       || info.name == ``Nat.decEq\n       || info.name == ``Char.ofNat   || info.name == ``Char.ofNatAux\n       || info.name == ``String.decEq || info.name == ``List.hasDecEq\n       || info.name == ``Fin.ofNat\n       || info.name == ``UInt8.ofNat  || info.name == ``UInt8.decEq\n       || info.name == ``UInt16.ofNat || info.name == ``UInt16.decEq\n       || info.name == ``UInt32.ofNat || info.name == ``UInt32.decEq\n       || info.name == ``UInt64.ofNat || info.name == ``UInt64.decEq\n       \n       || info.name == ``HMod.hMod || info.name == ``Mod.mod", "start": [362, 1], "end": [413, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfMatcher", "code": "private def whnfMatcher (e : Expr) : MetaM Expr := do\n  \n  if (\u2190 getTransparency) matches .instances | .reducible then\n    withTransparency .instances <| withReader (fun ctx => { ctx with canUnfold? := canUnfoldAtMatcher }) do\n      whnf e\n  else\n    whnf e", "start": [415, 1], "end": [429, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceMatcher?", "code": "def reduceMatcher? (e : Expr) : MetaM ReduceMatcherResult := do\n  match e.getAppFn with\n  | Expr.const declName declLevels =>\n    let some info \u2190 getMatcherInfo? declName\n      | return ReduceMatcherResult.notMatcher\n    let args := e.getAppArgs\n    let prefixSz := info.numParams + 1 + info.numDiscrs\n    if args.size < prefixSz + info.numAlts then\n      return ReduceMatcherResult.partialApp\n    else\n      let constInfo \u2190 getConstInfo declName\n      let f \u2190 instantiateValueLevelParams constInfo declLevels\n      let auxApp := mkAppN f args[0:prefixSz]\n      let auxAppType \u2190 inferType auxApp\n      forallBoundedTelescope auxAppType info.numAlts fun hs _ => do\n        let auxApp \u2190 whnfMatcher (mkAppN auxApp hs)\n        let auxAppFn := auxApp.getAppFn\n        let mut i := prefixSz\n        for h in hs do\n          if auxAppFn == h then\n            let result := mkAppN args[i]! auxApp.getAppArgs\n            let result := mkAppN result args[prefixSz + info.numAlts:args.size]\n            return ReduceMatcherResult.reduced result.headBeta\n          i := i + 1\n        return ReduceMatcherResult.stuck auxApp\n  | _ => pure ReduceMatcherResult.notMatcher", "start": [431, 1], "end": [456, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.projectCore?", "code": "private def projectCore? (e : Expr) (i : Nat) : MetaM (Option Expr) := do\n  let e := e.toCtorIfLit\n  matchConstCtor e.getAppFn (fun _ => pure none) fun ctorVal _ =>\n    let numArgs := e.getAppNumArgs\n    let idx := ctorVal.numParams + i\n    if idx < numArgs then\n      return some (e.getArg! idx)\n    else\n      return none", "start": [458, 1], "end": [466, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.project?", "code": "def project? (e : Expr) (i : Nat) : MetaM (Option Expr) := do\n  projectCore? (\u2190 whnf e) i", "start": [468, 1], "end": [469, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceProj?", "code": "def reduceProj? (e : Expr) : MetaM (Option Expr) := do\n  match e with\n  | Expr.proj _ i c => project? c i\n  | _               => return none", "start": [471, 1], "end": [475, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfDelayedAssigned?", "code": "private def whnfDelayedAssigned? (f' : Expr) (e : Expr) : MetaM (Option Expr) := do\n  if f'.isMVar then\n    match (\u2190 getDelayedMVarAssignment? f'.mvarId!) with\n    | none => return none\n    | some { fvars, mvarIdPending } =>\n      let args := e.getAppArgs\n      if fvars.size > args.size then\n        return none\n      else\n        let newVal \u2190 instantiateMVars (mkMVar mvarIdPending)\n        if newVal.hasExprMVar then\n           return none\n        else\n           let newVal := newVal.abstract fvars\n           let result := newVal.instantiateRevRange 0 fvars.size args\n           return mkAppRange result fvars.size args.size args\n  else\n    return none", "start": [477, 1], "end": [500, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfCore", "code": "partial def whnfCore (e : Expr) (deltaAtProj : Bool := true) (simpleReduceOnly := false) : MetaM Expr :=\n  go e\nwhere\n  go (e : Expr) : MetaM Expr :=\n    whnfEasyCases e fun e => do\n      trace[Meta.whnf] e\n      match e with\n      | Expr.const ..  => pure e\n      | Expr.letE _ _ v b _ => go <| b.instantiate1 v\n      | Expr.app f ..       =>\n        let f := f.getAppFn\n        let f' \u2190 go f\n        if f'.isLambda then\n          let revArgs := e.getAppRevArgs\n          go <| f'.betaRev revArgs\n        else if let some eNew \u2190 whnfDelayedAssigned? f' e then\n          go eNew\n        else\n          let e := if f == f' then e else e.updateFn f'\n          if simpleReduceOnly then\n            return e\n          else\n            match (\u2190 reduceMatcher? e) with\n            | ReduceMatcherResult.reduced eNew => go eNew\n            | ReduceMatcherResult.partialApp   => pure e\n            | ReduceMatcherResult.stuck _      => pure e\n            | ReduceMatcherResult.notMatcher   =>\n              matchConstAux f' (fun _ => return e) fun cinfo lvls =>\n                match cinfo with\n                | ConstantInfo.recInfo rec    => reduceRec rec lvls e.getAppArgs (fun _ => return e) go\n                | ConstantInfo.quotInfo rec   => reduceQuotRec rec lvls e.getAppArgs (fun _ => return e) go\n                | c@(ConstantInfo.defnInfo _) => do\n                  if (\u2190 isAuxDef c.name) then\n                    deltaBetaDefinition c lvls e.getAppRevArgs (fun _ => return e) go\n                  else\n                    return e\n                | _ => return e\n      | Expr.proj _ i c =>\n        if simpleReduceOnly then\n          return e\n        else\n          let c \u2190 if deltaAtProj then whnf c else whnfCore c\n          match (\u2190 projectCore? c i) with\n          | some e => go e\n          | none => return e\n      | _ => unreachable!", "start": [502, 1], "end": [557, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.smartUnfoldingReduce?", "code": "partial def smartUnfoldingReduce? (e : Expr) : MetaM (Option Expr) :=\n  go e |>.run\nwhere\n  go (e : Expr) : OptionT MetaM Expr := do\n    match e with\n    | Expr.letE n t v b _ => withLetDecl n t (\u2190 go v) fun x => do mkLetFVars #[x] (\u2190 go (b.instantiate1 x))\n    | Expr.lam .. => lambdaTelescope e fun xs b => do mkLambdaFVars xs (\u2190 go b)\n    | Expr.app f a .. => return mkApp (\u2190 go f) (\u2190 go a)\n    | Expr.proj _ _ s => return e.updateProj! (\u2190 go s)\n    | Expr.mdata _ b  =>\n      if let some m := smartUnfoldingMatch? e then\n        goMatch m\n      else\n        return e.updateMData! (\u2190 go b)\n    | _ => return e\n\n  goMatch (e : Expr) : OptionT MetaM Expr := do\n    match (\u2190 reduceMatcher? e) with\n    | ReduceMatcherResult.reduced e =>\n      if let some alt := smartUnfoldingMatchAlt? e then\n        return alt\n      else\n        go e\n    | ReduceMatcherResult.stuck e' =>\n      let mvarId \u2190 getStuckMVar? e'\n      \n      if (\u2190 Meta.synthPending mvarId) then\n        goMatch e\n      else\n        failure\n    | _ => failure", "start": [559, 1], "end": [619, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldProjInst?", "code": "partial def unfoldProjInst? (e : Expr) : MetaM (Option Expr) := do\n    match e.getAppFn with\n    | Expr.const declName .. =>\n      match (\u2190 getProjectionFnInfo? declName) with\n      | some { fromClass := true, .. } =>\n        match (\u2190 withDefault <| unfoldDefinition? e) with\n        | none   => return none\n        | some e =>\n          match (\u2190 withReducibleAndInstances <| reduceProj? e.getAppFn) with\n          | none   => return none\n          | some r => return mkAppN r e.getAppArgs |>.headBeta\n      | _ => return none\n    | _ => return none", "start": [623, 3], "end": [638, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldProjInstWhenIntances?", "code": "partial def unfoldProjInstWhenIntances? (e : Expr) : MetaM (Option Expr) := do\n    if (\u2190 getTransparency) != TransparencyMode.instances then\n      return none\n    else\n      unfoldProjInst? e", "start": [640, 3], "end": [649, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldDefinition?", "code": "partial def unfoldDefinition? (e : Expr) : MetaM (Option Expr) :=\n    match e with\n    | Expr.app f _ =>\n      matchConstAux f.getAppFn (fun _ => unfoldProjInstWhenIntances? e) fun fInfo fLvls => do\n        if fInfo.levelParams.length != fLvls.length then\n          return none\n        else\n          let unfoldDefault (_ : Unit) : MetaM (Option Expr) :=\n            if fInfo.hasValue then\n              deltaBetaDefinition fInfo fLvls e.getAppRevArgs (fun _ => pure none) (fun e => pure (some e))\n            else\n              return none\n          if smartUnfolding.get (\u2190 getOptions) then\n            match ((\u2190 getEnv).find? (mkSmartUnfoldingNameFor fInfo.name)) with\n            | some fAuxInfo@(ConstantInfo.defnInfo _) =>\n              deltaBetaDefinition fAuxInfo fLvls e.getAppRevArgs (preserveMData := true) (fun _ => pure none) fun e\u2081 => do\n                let some r \u2190 smartUnfoldingReduce? e\u2081 | return none\n                \n                let some recArgPos \u2190 getStructuralRecArgPos? fInfo.name | return some r\n                let numArgs := e.getAppNumArgs\n                if recArgPos >= numArgs then return none\n                let recArg := e.getArg! recArgPos numArgs\n                if !(\u2190 whnfMatcher recArg).isConstructorApp (\u2190 getEnv) then return none\n                return some r\n            | _ =>\n              if (\u2190 getMatcherInfo? fInfo.name).isSome then\n                return none\n              else\n                unfoldDefault ()\n          else\n            unfoldDefault ()\n    | Expr.const declName lvls => do\n      if smartUnfolding.get (\u2190 getOptions) && (\u2190 getEnv).contains (mkSmartUnfoldingNameFor declName) then\n        return none\n      else\n        let some cinfo \u2190 getUnfoldableConstNoEx? declName | pure none\n        unless cinfo.hasValue do return none\n        deltaDefinition cinfo lvls\n          (fun _ => pure none)\n          (fun e => pure (some e))\n    | _ => return none", "start": [651, 3], "end": [731, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldDefinition", "code": "def unfoldDefinition (e : Expr) : MetaM Expr := do\n  let some e \u2190 unfoldDefinition? e | throwError \"failed to unfold definition{indentExpr e}\"\n  return e", "start": [734, 1], "end": [736, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfHeadPred", "code": "@[specialize] partial def whnfHeadPred (e : Expr) (pred : Expr \u2192 MetaM Bool) : MetaM Expr :=\n  whnfEasyCases e fun e => do\n    let e \u2190 whnfCore e\n    if (\u2190 pred e) then\n        match (\u2190 unfoldDefinition? e) with\n        | some e => whnfHeadPred e pred\n        | none   => return e\n    else\n      return e", "start": [738, 1], "end": [746, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfUntil", "code": "def whnfUntil (e : Expr) (declName : Name) : MetaM (Option Expr) := do\n  let e \u2190 whnfHeadPred e (fun e => return !e.isAppOf declName)\n  if e.isAppOf declName then\n    return e\n  else\n    return none", "start": [748, 1], "end": [753, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceRecMatcher?", "code": "def reduceRecMatcher? (e : Expr) : MetaM (Option Expr) := do\n  if !e.isApp then\n    return none\n  else match (\u2190 reduceMatcher? e) with\n    | ReduceMatcherResult.reduced e => return e\n    | _ => matchConstAux e.getAppFn (fun _ => pure none) fun cinfo lvls => do\n      match cinfo with\n      | ConstantInfo.recInfo \u00abrec\u00bb  => reduceRec \u00abrec\u00bb lvls e.getAppArgs (fun _ => pure none) (fun e => pure (some e))\n      | ConstantInfo.quotInfo \u00abrec\u00bb => reduceQuotRec \u00abrec\u00bb lvls e.getAppArgs (fun _ => pure none) (fun e => pure (some e))\n      | c@(ConstantInfo.defnInfo _) =>\n        if (\u2190 isAuxDef c.name) then\n          deltaBetaDefinition c lvls e.getAppRevArgs (fun _ => pure none) (fun e => pure (some e))\n        else\n          return none\n      | _ => return none", "start": [755, 1], "end": [770, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceBoolNativeUnsafe", "code": "unsafe def reduceBoolNativeUnsafe (constName : Name) : MetaM Bool := evalConstCheck Bool `Bool constName", "start": [772, 1], "end": [772, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceNatNativeUnsafe", "code": "unsafe def reduceNatNativeUnsafe (constName : Name) : MetaM Nat := evalConstCheck Nat `Nat constName", "start": [773, 1], "end": [773, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceBoolNative", "code": "@[implemented_by reduceBoolNativeUnsafe] opaque reduceBoolNative (constName : Name) : MetaM Bool", "start": [774, 1], "end": [774, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceNatNative", "code": "@[implemented_by reduceNatNativeUnsafe] opaque reduceNatNative (constName : Name) : MetaM Nat", "start": [775, 1], "end": [775, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceNative?", "code": "def reduceNative? (e : Expr) : MetaM (Option Expr) :=\n  match e with\n  | Expr.app (Expr.const fName _) (Expr.const argName _) =>\n    if fName == ``Lean.reduceBool then do\n      return toExpr (\u2190 reduceBoolNative argName)\n    else if fName == ``Lean.reduceNat then do\n      return toExpr (\u2190 reduceNatNative argName)\n    else\n      return none\n  | _ =>\n    return none", "start": [777, 1], "end": [787, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNatValue", "code": "@[inline] def withNatValue {\u03b1} (a : Expr) (k : Nat \u2192 MetaM (Option \u03b1)) : MetaM (Option \u03b1) := do\n  let a \u2190 whnf a\n  match a with\n  | Expr.const `Nat.zero _      => k 0\n  | Expr.lit (Literal.natVal v) => k v\n  | _                           => return none", "start": [789, 1], "end": [794, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceUnaryNatOp", "code": "def reduceUnaryNatOp (f : Nat \u2192 Nat) (a : Expr) : MetaM (Option Expr) :=\n  withNatValue a fun a =>\n  return mkRawNatLit <| f a", "start": [796, 1], "end": [798, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceBinNatOp", "code": "def reduceBinNatOp (f : Nat \u2192 Nat \u2192 Nat) (a b : Expr) : MetaM (Option Expr) :=\n  withNatValue a fun a =>\n  withNatValue b fun b => do\n  trace[Meta.isDefEq.whnf.reduceBinOp] \"{a} op {b}\"\n  return mkRawNatLit <| f a b", "start": [800, 1], "end": [804, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceBinNatPred", "code": "def reduceBinNatPred (f : Nat \u2192 Nat \u2192 Bool) (a b : Expr) : MetaM (Option Expr) := do\n  withNatValue a fun a =>\n  withNatValue b fun b =>\n  return toExpr <| f a b", "start": [806, 1], "end": [809, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceNat?", "code": "def reduceNat? (e : Expr) : MetaM (Option Expr) :=\n  if e.hasFVar || e.hasMVar then\n    return none\n  else match e with\n    | Expr.app (Expr.const fn _) a                =>\n      if fn == ``Nat.succ then\n        reduceUnaryNatOp Nat.succ a\n      else\n        return none\n    | Expr.app (Expr.app (Expr.const fn _) a1) a2 =>\n      if fn == ``Nat.add then reduceBinNatOp Nat.add a1 a2\n      else if fn == ``Nat.sub then reduceBinNatOp Nat.sub a1 a2\n      else if fn == ``Nat.mul then reduceBinNatOp Nat.mul a1 a2\n      else if fn == ``Nat.div then reduceBinNatOp Nat.div a1 a2\n      else if fn == ``Nat.mod then reduceBinNatOp Nat.mod a1 a2\n      else if fn == ``Nat.pow then reduceBinNatOp Nat.pow a1 a2\n      else if fn == ``Nat.gcd then reduceBinNatOp Nat.gcd a1 a2\n      else if fn == ``Nat.beq then reduceBinNatPred Nat.beq a1 a2\n      else if fn == ``Nat.ble then reduceBinNatPred Nat.ble a1 a2\n      else return none\n    | _ =>\n      return none", "start": [811, 1], "end": [832, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.useWHNFCache", "code": "@[inline] private def useWHNFCache (e : Expr) : MetaM Bool := do\n  if e.hasFVar || e.hasExprMVar || (\u2190 read).canUnfold?.isSome then\n    return false\n  else\n    match (\u2190 getConfig).transparency with\n    | TransparencyMode.default => return true\n    | TransparencyMode.all     => return true\n    | _                        => return false", "start": [835, 1], "end": [844, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.cached?", "code": "@[inline] private def cached? (useCache : Bool) (e : Expr) : MetaM (Option Expr) := do\n  if useCache then\n    match (\u2190 getConfig).transparency with\n    | TransparencyMode.default => return (\u2190 get).cache.whnfDefault.find? e\n    | TransparencyMode.all     => return (\u2190 get).cache.whnfAll.find? e\n    | _                        => unreachable!\n  else\n    return none", "start": [846, 1], "end": [853, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.cache", "code": "private def cache (useCache : Bool) (e r : Expr) : MetaM Expr := do\n  if useCache then\n    match (\u2190 getConfig).transparency with\n    | TransparencyMode.default => modify fun s => { s with cache.whnfDefault := s.cache.whnfDefault.insert e r }\n    | TransparencyMode.all     => modify fun s => { s with cache.whnfAll     := s.cache.whnfAll.insert e r }\n    | _                        => unreachable!\n  return r", "start": [855, 1], "end": [861, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whnfImp", "code": "@[export lean_whnf]\npartial def whnfImp (e : Expr) : MetaM Expr :=\n  withIncRecDepth <| whnfEasyCases e fun e => do\n    checkMaxHeartbeats \"whnf\"\n    let useCache \u2190 useWHNFCache e\n    match (\u2190 cached? useCache e) with\n    | some e' => pure e'\n    | none    =>\n      let e' \u2190 whnfCore e\n      match (\u2190 reduceNat? e') with\n      | some v => cache useCache e v\n      | none   =>\n        match (\u2190 reduceNative? e') with\n        | some v => cache useCache e v\n        | none   =>\n          match (\u2190 unfoldDefinition? e') with\n          | some e'' => cache useCache e (\u2190 whnfImp e'')\n          | none => cache useCache e e'", "start": [863, 1], "end": [880, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceProjOf?", "code": "def reduceProjOf? (e : Expr) (p : Name \u2192 Bool) : MetaM (Option Expr) := do\n  if !e.isApp then\n    pure none\n  else match e.getAppFn with\n    | Expr.const name .. => do\n      let env \u2190 getEnv\n      match env.getProjectionStructureName? name with\n      | some structName =>\n        if p structName then\n          Meta.unfoldDefinition? e\n        else\n          pure none\n      | none => pure none\n    | _ => pure none", "start": [882, 1], "end": [896, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/CollectMVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.CollectMVars.State", "code": "structure State where\n  visitedExpr  : ExprSet      := {}\n  result       : Array MVarId := #[]", "start": [12, 1], "end": [14, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectMVars.Visitor", "code": "abbrev Visitor := State \u2192 State", "start": [18, 1], "end": [18, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectMVars.visit", "code": "partial def visit (e : Expr) : Visitor := fun s =>\n    if !e.hasMVar || s.visitedExpr.contains e then s\n    else main e { s with visitedExpr := s.visitedExpr.insert e }", "start": [21, 3], "end": [23, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectMVars.main", "code": "partial def main : Expr \u2192 Visitor\n    | Expr.proj _ _ e      => visit e\n    | Expr.forallE _ d b _ => visit b \u2218 visit d\n    | Expr.lam _ d b _     => visit b \u2218 visit d\n    | Expr.letE _ t v b _  => visit b \u2218 visit v \u2218 visit t\n    | Expr.app f a         => visit a \u2218 visit f\n    | Expr.mdata _ b       => visit b\n    | Expr.mvar mvarId     => fun s => { s with result := s.result.push mvarId }\n    | _                    => id", "start": [25, 3], "end": [33, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.collectMVars", "code": "def Expr.collectMVars (s : CollectMVars.State) (e : Expr) : CollectMVars.State :=\n  CollectMVars.visit e s", "start": [38, 1], "end": [39, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Attr.lean", "lake-packages/lean4/src/lean/Lean/Parser/Level.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.Command.commentBody", "code": "def commentBody : Parser :=\n{ fn := rawFn (finishCommentBlock (pushMissingOnError := true) 1) (trailingWs := true) }", "start": [13, 1], "end": [14, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.commentBody.parenthesizer", "code": "@[combinator_parenthesizer commentBody]\ndef commentBody.parenthesizer := PrettyPrinter.Parenthesizer.visitToken", "start": [16, 1], "end": [17, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.commentBody.formatter", "code": "@[combinator_formatter commentBody]\ndef commentBody.formatter := PrettyPrinter.Formatter.visitAtom Name.anonymous", "start": [18, 1], "end": [19, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.docComment", "code": "def docComment := leading_parser\n  ppDedent $ \"", "start": [21, 1], "end": [27, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.tacticParser", "code": "@[inline] def tacticParser (rbp : Nat := 0) : Parser :=\n  categoryParser `tactic rbp", "start": [34, 1], "end": [35, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.convParser", "code": "@[inline] def convParser (rbp : Nat := 0) : Parser :=\n  categoryParser `conv rbp", "start": [37, 1], "end": [38, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.sepByIndentSemicolon", "code": "@[run_builtin_parser_attribute_hooks]\ndef sepByIndentSemicolon (p : Parser) : Parser :=\n  sepByIndent p \"; \" (allowTrailingSep := true)", "start": [42, 1], "end": [53, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.sepBy1IndentSemicolon", "code": "@[run_builtin_parser_attribute_hooks]\ndef sepBy1IndentSemicolon (p : Parser) : Parser :=\n  sepBy1Indent p \"; \" (allowTrailingSep := true)", "start": [55, 1], "end": [66, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.tacticSeq1Indented", "code": "def tacticSeq1Indented : Parser := leading_parser\n  sepBy1IndentSemicolon tacticParser", "start": [72, 1], "end": [73, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.tacticSeqBracketed", "code": "def tacticSeqBracketed : Parser := leading_parser\n  \"{\" >> sepByIndentSemicolon tacticParser >> ppDedent (ppLine >> \"}\")", "start": [74, 1], "end": [77, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.tacticSeq", "code": "def tacticSeq := leading_parser\n  tacticSeqBracketed <|> tacticSeq1Indented", "start": [79, 1], "end": [82, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.tacticSeqIndentGt", "code": "def tacticSeqIndentGt := withAntiquot (mkAntiquot \"tacticSeq\" ``tacticSeq) <| node ``tacticSeq <|\n  tacticSeqBracketed <|> (checkColGt \"indented tactic sequence\" >> tacticSeq1Indented)", "start": [84, 1], "end": [88, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.seq1", "code": "def seq1 :=\n  node `Lean.Parser.Tactic.seq1 $ sepBy1 tacticParser \";\\n\" (allowTrailingSep := true)", "start": [91, 1], "end": [92, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.darrow", "code": "def darrow : Parser := \" => \"", "start": [96, 1], "end": [96, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.semicolonOrLinebreak", "code": "def semicolonOrLinebreak := \";\" <|> checkLinebreakBefore >> pushNone", "start": [97, 1], "end": [97, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.byTactic", "code": "@[builtin_term_parser] def byTactic := leading_parser:leadPrec\n  ppAllowUngrouped >> \"by \" >> Tactic.tacticSeqIndentGt", "start": [103, 1], "end": [105, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.byTactic'", "code": "def byTactic' := leading_parser\n  \"by \" >> Tactic.tacticSeqIndentGt", "start": [113, 1], "end": [114, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.optSemicolon", "code": "def optSemicolon (p : Parser) : Parser :=\n  ppDedent $ semicolonOrLinebreak >> ppLine >> p", "start": [117, 1], "end": [118, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.ident", "code": "@[builtin_term_parser] def ident :=\n  checkPrec maxPrec >> Parser.ident", "start": [121, 1], "end": [122, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.num", "code": "@[builtin_term_parser] def num : Parser :=\n  checkPrec maxPrec >> numLit", "start": [123, 1], "end": [124, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.scientific", "code": "@[builtin_term_parser] def scientific : Parser :=\n  checkPrec maxPrec >> scientificLit", "start": [125, 1], "end": [126, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.str", "code": "@[builtin_term_parser] def str : Parser :=\n  checkPrec maxPrec >> strLit", "start": [127, 1], "end": [128, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.char", "code": "@[builtin_term_parser] def char : Parser :=\n  checkPrec maxPrec >> charLit", "start": [129, 1], "end": [130, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.type", "code": "@[builtin_term_parser] def type := leading_parser\n  \"Type\" >> optional (checkWsBefore \"\" >> checkPrec leadPrec >> checkColGt >> levelParser maxPrec)", "start": [131, 1], "end": [133, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.sort", "code": "@[builtin_term_parser] def sort := leading_parser\n  \"Sort\" >> optional (checkWsBefore \"\" >> checkPrec leadPrec >> checkColGt >> levelParser maxPrec)", "start": [134, 1], "end": [136, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.prop", "code": "@[builtin_term_parser] def prop := leading_parser\n  \"Prop\"", "start": [137, 1], "end": [139, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.hole", "code": "@[builtin_term_parser] def hole := leading_parser\n  \"_\"", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.syntheticHole", "code": "@[builtin_term_parser] def syntheticHole := leading_parser\n  \"?\" >> (ident <|> hole)", "start": [143, 1], "end": [146, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.binderIdent", "code": "def binderIdent : Parser  := ident <|> hole", "start": [147, 1], "end": [147, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.sorry", "code": "@[builtin_term_parser] def \u00absorry\u00bb := leading_parser\n  \"sorry\"", "start": [148, 1], "end": [150, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.cdot", "code": "@[builtin_term_parser] def cdot   := leading_parser\n  symbol \"\u00b7\" <|> \".\"", "start": [151, 1], "end": [156, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.typeAscription", "code": "@[builtin_term_parser] def typeAscription := leading_parser\n  \"(\" >> (withoutPosition (withoutForbidden (termParser >> \" :\" >> optional (ppSpace >> termParser)))) >> \")\"", "start": [157, 1], "end": [164, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.tuple", "code": "@[builtin_term_parser] def tuple := leading_parser\n  \"(\" >> optional (withoutPosition (withoutForbidden (termParser >> \", \" >> sepBy1 termParser \", \"))) >> \")\"", "start": [165, 1], "end": [167, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.paren", "code": "@[builtin_term_parser] def paren := leading_parser\n  \"(\" >> withoutPosition (withoutForbidden (ppDedentIfGrouped termParser)) >> \")\"", "start": [168, 1], "end": [178, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.anonymousCtor", "code": "@[builtin_term_parser] def anonymousCtor := leading_parser\n  \"\u27e8\" >> withoutPosition (withoutForbidden (sepBy termParser \", \")) >> \"\u27e9\"", "start": [179, 1], "end": [187, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.optIdent", "code": "def optIdent : Parser :=\n  optional (atomic (ident >> \" : \"))", "start": [188, 1], "end": [189, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.fromTerm", "code": "def fromTerm   := leading_parser\n  \"from \" >> termParser", "start": [190, 1], "end": [191, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.showRhs", "code": "def showRhs := fromTerm <|> byTactic'", "start": [192, 1], "end": [192, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.sufficesDecl", "code": "def sufficesDecl := leading_parser\n  (atomic (group (binderIdent >> \" : \")) <|> hygieneInfo) >> termParser >> ppSpace >> showRhs", "start": [193, 1], "end": [196, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.suffices", "code": "@[builtin_term_parser] def \u00absuffices\u00bb := leading_parser:leadPrec\n  withPosition (\"suffices \" >> sufficesDecl) >> optSemicolon termParser", "start": [197, 1], "end": [198, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.show", "code": "@[builtin_term_parser] def \u00abshow\u00bb     := leading_parser:leadPrec \"show \" >> termParser >> ppSpace >> showRhs", "start": [199, 1], "end": [199, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.structInstArrayRef", "code": "def structInstArrayRef := leading_parser\n  \"[\" >> withoutPosition termParser >> \"]\"", "start": [200, 1], "end": [201, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.structInstLVal", "code": "def structInstLVal   := leading_parser\n  (ident <|> fieldIdx <|> structInstArrayRef) >>\n  many (group (\".\" >> (ident <|> fieldIdx)) <|> structInstArrayRef)", "start": [202, 1], "end": [204, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.structInstField", "code": "def structInstField  := ppGroup $ leading_parser\n  structInstLVal >> \" := \" >> termParser", "start": [205, 1], "end": [206, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.structInstFieldAbbrev", "code": "def structInstFieldAbbrev := leading_parser\n  atomic (ident >> notFollowedBy (\".\" <|> \":=\" <|> symbol \"[\") \"invalid field abbreviation\")", "start": [207, 1], "end": [209, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.optEllipsis", "code": "def optEllipsis      := leading_parser\n  optional \" ..\"", "start": [210, 1], "end": [211, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.structInst", "code": "@[builtin_term_parser] def structInst := leading_parser\n  \"{ \" >> withoutPosition (optional (atomic (sepBy1 termParser \", \" >> \" with \"))\n    >> sepByIndent (structInstFieldAbbrev <|> structInstField) \", \" (allowTrailingSep := true)\n    >> optEllipsis\n    >> optional (\" : \" >> termParser)) >> \" }\"", "start": [212, 1], "end": [225, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.typeSpec", "code": "def typeSpec := leading_parser \" : \" >> termParser", "start": [226, 1], "end": [226, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.optType", "code": "def optType : Parser := optional typeSpec", "start": [227, 1], "end": [227, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.explicit", "code": "@[builtin_term_parser] def explicit := leading_parser\n  \"@\" >> termParser maxPrec", "start": [228, 1], "end": [233, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.inaccessible", "code": "@[builtin_term_parser] def inaccessible := leading_parser\n  \".(\" >> withoutPosition termParser >> \")\"", "start": [234, 1], "end": [239, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.binderType", "code": "def binderType (requireType := false) : Parser :=\n  if requireType then node nullKind (\" : \" >> termParser) else optional (\" : \" >> termParser)", "start": [240, 1], "end": [241, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.binderTactic", "code": "def binderTactic  := leading_parser\n  atomic (symbol \" := \" >> \" by \") >> Tactic.tacticSeq", "start": [242, 1], "end": [243, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.binderDefault", "code": "def binderDefault := leading_parser\n  \" := \" >> termParser", "start": [244, 1], "end": [245, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.binderDefault.parenthesizer", "code": "@[combinator_parenthesizer Lean.Parser.Term.binderDefault] def binderDefault.parenthesizer : Parenthesizer := do\n  let prec := match (\u2190 getCur) with\n    | `(binderDefault| := by $_) => maxPrec\n    | _                          => 0\n  visitArgs do\n    term.parenthesizer prec\n    visitToken", "start": [248, 1], "end": [255, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.explicitBinder", "code": "def explicitBinder (requireType := false) := ppGroup $ leading_parser\n  \"(\" >> withoutPosition (many1 binderIdent >> binderType requireType >> optional (binderTactic <|> binderDefault)) >> \")\"", "start": [257, 1], "end": [258, 123], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.implicitBinder", "code": "def implicitBinder (requireType := false) := ppGroup $ leading_parser\n  \"{\" >> withoutPosition (many1 binderIdent >> binderType requireType) >> \"}\"", "start": [259, 1], "end": [264, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.strictImplicitLeftBracket", "code": "def strictImplicitLeftBracket := atomic (group (symbol \"{\" >> \"{\")) <|> \"\u2983\"", "start": [265, 1], "end": [265, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.strictImplicitRightBracket", "code": "def strictImplicitRightBracket := atomic (group (symbol \"}\" >> \"}\")) <|> \"\u2984\"", "start": [266, 1], "end": [266, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.strictImplicitBinder", "code": "def strictImplicitBinder (requireType := false) := ppGroup <| leading_parser\n  strictImplicitLeftBracket >> many1 binderIdent >>\n  binderType requireType >> strictImplicitRightBracket", "start": [267, 1], "end": [274, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.instBinder", "code": "def instBinder := ppGroup <| leading_parser\n  \"[\" >> withoutPosition (optIdent >> termParser) >> \"]\"", "start": [275, 1], "end": [280, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.bracketedBinder", "code": "def bracketedBinder (requireType := false) :=\n  withAntiquot (mkAntiquot \"bracketedBinder\" decl_name% (isPseudoKind := true)) <|\n    explicitBinder requireType <|> strictImplicitBinder requireType <|>\n    implicitBinder requireType <|> instBinder", "start": [281, 1], "end": [290, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.depArrow", "code": "@[builtin_term_parser] def depArrow := leading_parser:25\n  bracketedBinder true >> unicodeSymbol \" \u2192 \" \" -> \" >> termParser", "start": [307, 1], "end": [308, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.forall", "code": "@[builtin_term_parser]\ndef \u00abforall\u00bb := leading_parser:leadPrec\n  unicodeSymbol \"\u2200\" \"forall\" >>\n  many1 (ppSpace >> (binderIdent <|> bracketedBinder)) >>\n  optType >> \", \" >> termParser", "start": [310, 1], "end": [314, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.matchAlt", "code": "def matchAlt (rhsParser : Parser := termParser) : Parser :=\n  leading_parser (withAnonymousAntiquot := false)\n    \"| \" >> ppIndent (\n      sepBy1 (sepBy1 termParser \", \") \" | \" >> darrow >>\n      checkColGe \"alternative right-hand-side to start in a column greater than or equal to the corresponding '|'\" >>\n      rhsParser)", "start": [316, 1], "end": [321, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.matchAltExpr", "code": "def matchAltExpr := matchAlt", "start": [322, 1], "end": [325, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.matchAlts", "code": "def matchAlts (rhsParser : Parser := termParser) : Parser :=\n  leading_parser withPosition $ many1Indent (ppLine >> matchAlt rhsParser)", "start": [330, 1], "end": [331, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.matchDiscr", "code": "def matchDiscr := leading_parser\n  optional (atomic (ident >> \" : \")) >> termParser", "start": [333, 1], "end": [336, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.trueVal", "code": "def trueVal  := leading_parser nonReservedSymbol \"true\"", "start": [338, 1], "end": [338, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.falseVal", "code": "def falseVal := leading_parser nonReservedSymbol \"false\"", "start": [339, 1], "end": [339, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.generalizingParam", "code": "def generalizingParam := leading_parser\n  atomic (\"(\" >> nonReservedSymbol \"generalizing\") >> \" := \" >>\n    (trueVal <|> falseVal)  >> \")\" >> ppSpace", "start": [340, 1], "end": [342, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.motive", "code": "def motive := leading_parser\n  atomic (\"(\" >> nonReservedSymbol \"motive\" >> \" := \") >>\n    withoutPosition termParser >> \")\" >> ppSpace", "start": [344, 1], "end": [346, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.match", "code": "@[builtin_term_parser] def \u00abmatch\u00bb := leading_parser:leadPrec\n  \"match \" >> optional generalizingParam >> optional motive >> sepBy1 matchDiscr \", \" >>\n  \" with\" >> ppDedent matchAlts", "start": [348, 1], "end": [380, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.nomatch", "code": "@[builtin_term_parser] def \u00abnomatch\u00bb := leading_parser:leadPrec \"nomatch \" >> termParser", "start": [381, 1], "end": [386, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.funImplicitBinder", "code": "def funImplicitBinder := withAntiquot (mkAntiquot \"implicitBinder\" ``implicitBinder) <|\n  atomic (lookahead (\"{\" >> many1 binderIdent >> (symbol \" : \" <|> \"}\"))) >> implicitBinder", "start": [388, 1], "end": [389, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.funStrictImplicitBinder", "code": "def funStrictImplicitBinder :=\n  atomic (lookahead (\n    strictImplicitLeftBracket >> many1 binderIdent >>\n    (symbol \" : \" <|> strictImplicitRightBracket))) >>\n  strictImplicitBinder", "start": [390, 1], "end": [394, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.funBinder", "code": "def funBinder : Parser :=\n  withAntiquot (mkAntiquot \"funBinder\" decl_name% (isPseudoKind := true)) <|\n    funStrictImplicitBinder <|> funImplicitBinder <|> instBinder <|> termParser maxPrec", "start": [395, 1], "end": [397, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.basicFun", "code": "def basicFun : Parser := leading_parser (withAnonymousAntiquot := false)\n  ppGroup (many1 (ppSpace >> funBinder) >> optType >> unicodeSymbol \" \u21a6\" \" =>\") >> ppSpace >> termParser", "start": [400, 1], "end": [401, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.fun", "code": "@[builtin_term_parser] def \u00abfun\u00bb := leading_parser:maxPrec\n  ppAllowUngrouped >> unicodeSymbol \"\u03bb\" \"fun\" >> (basicFun <|> matchAlts)", "start": [402, 1], "end": [403, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.optExprPrecedence", "code": "def optExprPrecedence := optional (atomic \":\" >> termParser maxPrec)", "start": [405, 1], "end": [405, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.withAnonymousAntiquot", "code": "def withAnonymousAntiquot := leading_parser\n  atomic (\" (\" >> nonReservedSymbol \"withAnonymousAntiquot\" >> \" := \") >>\n  (trueVal <|> falseVal) >> \")\"", "start": [406, 1], "end": [408, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.leading_parser", "code": "@[builtin_term_parser] def \u00ableading_parser\u00bb  := leading_parser:leadPrec\n  \"leading_parser\" >> optExprPrecedence >> optional withAnonymousAntiquot >> ppSpace >> termParser", "start": [409, 1], "end": [410, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.trailing_parser", "code": "@[builtin_term_parser] def \u00abtrailing_parser\u00bb := leading_parser:leadPrec\n  \"trailing_parser\" >> optExprPrecedence >> optExprPrecedence >> ppSpace >> termParser", "start": [411, 1], "end": [412, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.borrowed", "code": "@[builtin_term_parser] def borrowed   := leading_parser\n  \"@& \" >> termParser leadPrec", "start": [414, 1], "end": [415, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.quotedName", "code": "@[builtin_term_parser] def quotedName := leading_parser nameLit", "start": [416, 1], "end": [417, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doubleQuotedName", "code": "@[builtin_term_parser] def doubleQuotedName := leading_parser\n  \"`\" >> checkNoWsBefore >> rawCh '`' (trailingWs := false) >> ident", "start": [418, 1], "end": [425, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letIdBinder", "code": "def letIdBinder :=\n  withAntiquot (mkAntiquot \"letIdBinder\" decl_name% (isPseudoKind := true)) <|\n    binderIdent <|> bracketedBinder", "start": [427, 1], "end": [429, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letIdLhs", "code": "def letIdLhs    : Parser :=\n  binderIdent >> notFollowedBy (checkNoWsBefore \"\" >> \"[\")\n    \"space is required before instance '[...]' binders to distinguish them from array updates `let x[i] := e; ...`\" >>\n  many (ppSpace >> letIdBinder) >> optType", "start": [431, 1], "end": [434, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letIdDecl", "code": "def letIdDecl   := leading_parser (withAnonymousAntiquot := false)\n  atomic (letIdLhs >> \" := \") >> termParser", "start": [435, 1], "end": [436, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letPatDecl", "code": "def letPatDecl  := leading_parser (withAnonymousAntiquot := false)\n  atomic (termParser >> pushNone >> optType >> \" := \") >> termParser", "start": [437, 1], "end": [438, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letEqnsDecl", "code": "def letEqnsDecl := leading_parser (withAnonymousAntiquot := false)\n  letIdLhs >> (\" := \" <|> matchAlts)", "start": [455, 1], "end": [456, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letDecl", "code": "def letDecl     := leading_parser (withAnonymousAntiquot := false)\n  notFollowedBy (nonReservedSymbol \"rec\") \"rec\" >>\n  (letIdDecl <|> letPatDecl <|> letEqnsDecl)", "start": [457, 1], "end": [465, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.let", "code": "@[builtin_term_parser] def \u00ablet\u00bb := leading_parser:leadPrec\n  withPosition (\"let \" >> letDecl) >> optSemicolon termParser", "start": [466, 1], "end": [488, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.let_fun", "code": "@[builtin_term_parser] def \u00ablet_fun\u00bb     := leading_parser:leadPrec\n  withPosition ((symbol \"let_fun \" <|> \"let_\u03bb \") >> letDecl) >> optSemicolon termParser", "start": [489, 1], "end": [495, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.let_delayed", "code": "@[builtin_term_parser] def \u00ablet_delayed\u00bb := leading_parser:leadPrec\n  withPosition (\"let_delayed \" >> letDecl) >> optSemicolon termParser", "start": [496, 1], "end": [500, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.let_tmp", "code": "@[builtin_term_parser] def \u00ablet_tmp\u00bb := leading_parser:leadPrec\n  withPosition (\"let_tmp \" >> letDecl) >> optSemicolon termParser", "start": [501, 1], "end": [506, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.haveIdLhs", "code": "def haveIdLhs    := ((ppSpace >> binderIdent) <|> hygieneInfo) >> many (ppSpace >> letIdBinder) >> optType", "start": [509, 1], "end": [509, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.haveIdDecl", "code": "def haveIdDecl   := leading_parser (withAnonymousAntiquot := false)\n  atomic (haveIdLhs >> \" := \") >> termParser", "start": [510, 1], "end": [511, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.haveEqnsDecl", "code": "def haveEqnsDecl := leading_parser (withAnonymousAntiquot := false)\n  haveIdLhs >> matchAlts", "start": [512, 1], "end": [513, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.haveDecl", "code": "def haveDecl     := leading_parser (withAnonymousAntiquot := false)\n  haveIdDecl <|> (ppSpace >> letPatDecl) <|> haveEqnsDecl", "start": [514, 1], "end": [518, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.have", "code": "@[builtin_term_parser] def \u00abhave\u00bb := leading_parser:leadPrec\n  withPosition (\"have\" >> haveDecl) >> optSemicolon termParser", "start": [519, 1], "end": [520, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.scoped", "code": "def \u00abscoped\u00bb := leading_parser \"scoped \"", "start": [522, 1], "end": [522, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.local", "code": "def \u00ablocal\u00bb  := leading_parser \"local \"", "start": [523, 1], "end": [523, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.attrKind", "code": "def attrKind := leading_parser optional (\u00abscoped\u00bb <|> \u00ablocal\u00bb)", "start": [524, 1], "end": [525, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.attrInstance", "code": "def attrInstance     := ppGroup $ leading_parser attrKind >> attrParser", "start": [526, 1], "end": [526, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.attributes", "code": "def attributes       := leading_parser\n  \"@[\" >> withoutPosition (sepBy1 attrInstance \", \") >> \"] \"", "start": [528, 1], "end": [529, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letRecDecl", "code": "def letRecDecl       := leading_parser\n  optional Command.docComment >> optional \u00abattributes\u00bb >> letDecl", "start": [530, 1], "end": [533, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letRecDecls", "code": "def letRecDecls      := leading_parser\n  sepBy1 letRecDecl \", \"", "start": [534, 1], "end": [536, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letrec", "code": "@[builtin_term_parser]\ndef \u00abletrec\u00bb := leading_parser:leadPrec\n  withPosition (group (\"let \" >> nonReservedSymbol \"rec \") >> letRecDecls) >>\n  optSemicolon termParser", "start": [537, 1], "end": [540, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.whereDecls", "code": "@[run_builtin_parser_attribute_hooks]\ndef whereDecls := leading_parser\n  ppDedent ppLine >> \"where\" >> sepBy1Indent (ppGroup letRecDecl) \"; \" (allowTrailingSep := true)", "start": [542, 1], "end": [544, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.matchAltsWhereDecls", "code": "@[run_builtin_parser_attribute_hooks]\ndef matchAltsWhereDecls := leading_parser\n  matchAlts >> optional whereDecls", "start": [546, 1], "end": [548, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.noindex", "code": "@[builtin_term_parser] def noindex := leading_parser\n  \"no_index \" >> termParser maxPrec", "start": [550, 1], "end": [551, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.binrel", "code": "@[builtin_term_parser] def binrel := leading_parser\n  \"binrel% \" >> ident >> ppSpace >> termParser maxPrec >> ppSpace >> termParser maxPrec", "start": [553, 1], "end": [554, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.binrel_no_prop", "code": "@[builtin_term_parser] def binrel_no_prop := leading_parser\n  \"binrel_no_prop% \" >> ident >> ppSpace >> termParser maxPrec >> ppSpace >> termParser maxPrec", "start": [555, 1], "end": [557, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.binop", "code": "@[builtin_term_parser] def binop  := leading_parser\n  \"binop% \" >> ident >> ppSpace >> termParser maxPrec >> ppSpace >> termParser maxPrec", "start": [558, 1], "end": [559, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.binop_lazy", "code": "@[builtin_term_parser] def binop_lazy  := leading_parser\n  \"binop_lazy% \" >> ident >> ppSpace >> termParser maxPrec >> ppSpace >> termParser maxPrec", "start": [560, 1], "end": [561, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.unop", "code": "@[builtin_term_parser] def unop  := leading_parser\n  \"unop% \" >> ident >> ppSpace >> termParser maxPrec", "start": [562, 1], "end": [563, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.forInMacro", "code": "@[builtin_term_parser] def forInMacro := leading_parser\n  \"for_in% \" >> termParser maxPrec >> termParser maxPrec >> ppSpace >> termParser maxPrec", "start": [565, 1], "end": [566, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.forInMacro'", "code": "@[builtin_term_parser] def forInMacro' := leading_parser\n  \"for_in'% \" >> termParser maxPrec >> termParser maxPrec >> ppSpace >> termParser maxPrec", "start": [567, 1], "end": [568, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.declName", "code": "@[builtin_term_parser] def declName := leading_parser \"decl_name%\"", "start": [570, 1], "end": [571, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.withDeclName", "code": "@[builtin_term_parser] def withDeclName := leading_parser\n  \"with_decl_name% \" >> optional \"?\" >> ident >> ppSpace >> termParser", "start": [573, 1], "end": [580, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.typeOf", "code": "@[builtin_term_parser] def typeOf := leading_parser\n  \"type_of% \" >> termParser maxPrec", "start": [581, 1], "end": [582, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.ensureTypeOf", "code": "@[builtin_term_parser] def ensureTypeOf := leading_parser\n  \"ensure_type_of% \" >> termParser maxPrec >> strLit >> ppSpace >> termParser", "start": [583, 1], "end": [584, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.ensureExpectedType", "code": "@[builtin_term_parser] def ensureExpectedType := leading_parser\n  \"ensure_expected_type% \" >> strLit >> ppSpace >> termParser maxPrec", "start": [585, 1], "end": [586, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.noImplicitLambda", "code": "@[builtin_term_parser] def noImplicitLambda := leading_parser\n  \"no_implicit_lambda% \" >> termParser maxPrec", "start": [587, 1], "end": [588, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.clear", "code": "@[builtin_term_parser] def clear := leading_parser\n  \"clear% \" >> ident >> semicolonOrLinebreak >> ppDedent ppLine >> termParser", "start": [590, 1], "end": [595, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letMVar", "code": "@[builtin_term_parser] def letMVar := leading_parser\n  \"let_mvar% \" >> \"?\" >> ident >> \" := \" >> termParser >> \"; \" >> termParser", "start": [597, 1], "end": [598, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.waitIfTypeMVar", "code": "@[builtin_term_parser] def waitIfTypeMVar := leading_parser\n  \"wait_if_type_mvar% \" >> \"?\" >> ident >> \"; \" >> termParser", "start": [599, 1], "end": [600, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.waitIfTypeContainsMVar", "code": "@[builtin_term_parser] def waitIfTypeContainsMVar := leading_parser\n  \"wait_if_type_contains_mvar% \" >> \"?\" >> ident >> \"; \" >> termParser", "start": [601, 1], "end": [602, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.waitIfContainsMVar", "code": "@[builtin_term_parser] def waitIfContainsMVar := leading_parser\n  \"wait_if_contains_mvar% \" >> \"?\" >> ident >> \"; \" >> termParser", "start": [603, 1], "end": [604, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.defaultOrOfNonempty", "code": "@[builtin_term_parser] def defaultOrOfNonempty := leading_parser\n  \"default_or_ofNonempty% \" >> optional \"unsafe\"", "start": [606, 1], "end": [607, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.noErrorIfUnused", "code": "@[builtin_term_parser] def noErrorIfUnused := leading_parser\n  \"no_error_if_unused% \" >> termParser", "start": [609, 1], "end": [614, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.namedArgument", "code": "def namedArgument  := leading_parser (withAnonymousAntiquot := false)\n  atomic (\"(\" >> ident >> \" := \") >> withoutPosition termParser >> \")\"", "start": [616, 1], "end": [617, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.ellipsis", "code": "def ellipsis       := leading_parser (withAnonymousAntiquot := false)\n  \"..\" >> notFollowedBy \".\" \"`.` immediately after `..`\"", "start": [618, 1], "end": [619, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.argument", "code": "def argument       :=\n  checkWsBefore \"expected space\" >>\n  checkColGt \"expected to be indented\" >>\n  (namedArgument <|> ellipsis <|> termParser argPrec)", "start": [620, 1], "end": [623, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.app", "code": "@[builtin_term_parser] def app := trailing_parser:leadPrec:maxPrec many1 argument", "start": [627, 1], "end": [627, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.proj", "code": "@[builtin_term_parser] def proj     := trailing_parser\n  checkNoWsBefore >> \".\" >> checkNoWsBefore >> (fieldIdx <|> rawIdent)", "start": [629, 1], "end": [642, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.completion", "code": "@[builtin_term_parser] def completion := trailing_parser\n  checkNoWsBefore >> \".\"", "start": [643, 1], "end": [644, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.arrow", "code": "@[builtin_term_parser] def arrow    := trailing_parser\n  checkPrec 25 >> unicodeSymbol \" \u2192 \" \" -> \" >> termParser 25", "start": [645, 1], "end": [646, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.isIdent", "code": "def isIdent (stx : Syntax) : Bool :=\n  stx.isAntiquot || stx.isIdent", "start": [648, 1], "end": [650, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.explicitUniv", "code": "@[builtin_term_parser] def explicitUniv : TrailingParser := trailing_parser\n  checkStackTop isIdent \"expected preceding identifier\" >>\n  checkNoWsBefore \"no space before '.{'\" >> \".{\" >>\n  sepBy1 levelParser \", \" >> \"}\"", "start": [652, 1], "end": [656, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.namedPattern", "code": "@[builtin_term_parser] def namedPattern : TrailingParser := trailing_parser\n  checkStackTop isIdent \"expected preceding identifier\" >>\n  checkNoWsBefore \"no space before '@'\" >> \"@\" >>\n  optional (atomic (ident >> \":\")) >> termParser maxPrec", "start": [657, 1], "end": [661, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.pipeProj", "code": "@[builtin_term_parser] def pipeProj   := trailing_parser:minPrec\n  \" |>.\" >> checkNoWsBefore >> (fieldIdx <|> rawIdent) >> many argument", "start": [663, 1], "end": [668, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.pipeCompletion", "code": "@[builtin_term_parser] def pipeCompletion := trailing_parser:minPrec\n  \" |>.\"", "start": [669, 1], "end": [670, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.subst", "code": "@[builtin_term_parser] def subst := trailing_parser:75\n  \" \u25b8 \" >> sepBy1 (termParser 75) \" \u25b8 \"", "start": [672, 1], "end": [681, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.bracketedBinderF", "code": "def bracketedBinderF := bracketedBinder", "start": [683, 1], "end": [683, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.panic", "code": "@[builtin_term_parser] def panic := leading_parser:leadPrec\n  \"panic! \" >> termParser", "start": [686, 1], "end": [695, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.unreachable", "code": "@[builtin_term_parser] def unreachable := leading_parser:leadPrec\n  \"unreachable!\"", "start": [696, 1], "end": [698, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.dbgTrace", "code": "@[builtin_term_parser] def dbgTrace := leading_parser:leadPrec\n  withPosition (\"dbg_trace\" >> (interpolatedStr termParser <|> termParser)) >>\n  optSemicolon termParser", "start": [699, 1], "end": [705, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.assert", "code": "@[builtin_term_parser] def assert := leading_parser:leadPrec\n  withPosition (\"assert! \" >> termParser) >> optSemicolon termParser", "start": [706, 1], "end": [708, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.macroArg", "code": "def macroArg       := termParser maxPrec", "start": [711, 1], "end": [711, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.macroDollarArg", "code": "def macroDollarArg := leading_parser \"$\" >> termParser 10", "start": [712, 1], "end": [712, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.macroLastArg", "code": "def macroLastArg   := macroDollarArg <|> macroArg", "start": [713, 1], "end": [713, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.stateRefT", "code": "@[builtin_term_parser] def stateRefT := leading_parser\n  \"StateRefT \" >> macroArg >> ppSpace >> macroLastArg", "start": [716, 1], "end": [717, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.dynamicQuot", "code": "@[builtin_term_parser] def dynamicQuot := withoutPosition <| leading_parser\n  \"`(\" >> ident >> \"| \" >> incQuotDepth (parserOfStack 1) >> \")\"", "start": [719, 1], "end": [720, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.dotIdent", "code": "@[builtin_term_parser] def dotIdent := leading_parser\n  \".\" >> checkNoWsBefore >> rawIdent", "start": [722, 1], "end": [723, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.quot", "code": "@[builtin_term_parser default+1] def Tactic.quot : Parser := leading_parser\n  \"`(tactic| \" >> withoutPosition (incQuotDepth tacticParser) >> \")\"", "start": [727, 1], "end": [728, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.quotSeq", "code": "@[builtin_term_parser] def Tactic.quotSeq : Parser := leading_parser\n  \"`(tactic| \" >> withoutPosition (incQuotDepth Tactic.seq1) >> \")\"", "start": [729, 1], "end": [730, 68], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/DiscrTree.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/WHNF.lean", "lake-packages/lean4/src/lean/Lean/Meta/DiscrTreeTypes.lean", "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.DiscrTree.Key.ctorIdx", "code": "def Key.ctorIdx : Key s \u2192 Nat\n  | .star     => 0\n  | .other    => 1\n  | .lit ..   => 2\n  | .fvar ..  => 3\n  | .const .. => 4\n  | .arrow    => 5\n  | .proj ..  => 6", "start": [51, 1], "end": [58, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Key.lt", "code": "def Key.lt : Key s \u2192 Key s \u2192 Bool\n  | .lit v\u2081,        .lit v\u2082        => v\u2081 < v\u2082\n  | .fvar n\u2081 a\u2081,    .fvar n\u2082 a\u2082    => Name.quickLt n\u2081.name n\u2082.name || (n\u2081 == n\u2082 && a\u2081 < a\u2082)\n  | .const n\u2081 a\u2081,   .const n\u2082 a\u2082   => Name.quickLt n\u2081 n\u2082 || (n\u2081 == n\u2082 && a\u2081 < a\u2082)\n  | .proj s\u2081 i\u2081 a\u2081, .proj s\u2082 i\u2082 a\u2082 => Name.quickLt s\u2081 s\u2082 || (s\u2081 == s\u2082 && i\u2081 < i\u2082) || (s\u2081 == s\u2082 && i\u2081 == i\u2082 && a\u2081 < a\u2082)\n  | k\u2081,             k\u2082             => k\u2081.ctorIdx < k\u2082.ctorIdx", "start": [60, 1], "end": [65, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Key.format", "code": "def Key.format : Key s \u2192 Format\n  | .star                   => \"*\"\n  | .other                  => \"\u25fe\"\n  | .lit (Literal.natVal v) => Std.format v\n  | .lit (Literal.strVal v) => repr v\n  | .const k _              => Std.format k\n  | .proj s i _             => Std.format s ++ \".\" ++ Std.format i\n  | .fvar k _               => Std.format k.name\n  | .arrow                  => \"\u2192\"", "start": [70, 1], "end": [78, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Key.arity", "code": "def Key.arity : (Key s) \u2192 Nat\n  | .const _ a  => a\n  | .fvar _ a   => a\n  | .arrow      => 2\n  | .proj _ _ a => 1 + a\n  | _           => 0", "start": [82, 1], "end": [87, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.empty", "code": "def empty : DiscrTree \u03b1 s := { root := {} }", "start": [91, 1], "end": [91, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.format", "code": "partial def Trie.format [ToFormat \u03b1] : Trie \u03b1 s \u2192 Format\n  | .node vs cs => Format.group $ Format.paren $\n    \"node\" ++ (if vs.isEmpty then Format.nil else \" \" ++ Std.format vs)\n    ++ Format.join (cs.toList.map fun \u27e8k, c\u27e9 => Format.line ++ Format.paren (Std.format k ++ \" => \" ++ format c))", "start": [93, 1], "end": [96, 114], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.format", "code": "partial def format [ToFormat \u03b1] (d : DiscrTree \u03b1 s) : Format :=\n  let (_, r) := d.root.foldl\n    (fun (p : Bool \u00d7 Format) k c =>\n      (false, p.2 ++ (if p.1 then Format.nil else Format.line) ++ Format.paren (Std.format k ++ \" => \" ++ Std.format c)))\n    (true, Format.nil)\n  Format.group r", "start": [100, 1], "end": [105, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.tmpMVarId", "code": "private def tmpMVarId : MVarId := { name := `_discr_tree_tmp }", "start": [109, 1], "end": [111, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.tmpStar", "code": "private def tmpStar := mkMVar tmpMVarId", "start": [112, 1], "end": [112, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.ignoreArg", "code": "private def ignoreArg (a : Expr) (i : Nat) (infos : Array ParamInfo) : MetaM Bool := do\n  if h : i < infos.size then\n    let info := infos.get \u27e8i, h\u27e9\n    if info.isInstImplicit then\n      return true\n    else if info.isImplicit || info.isStrictImplicit then\n      return not (\u2190 isType a)\n    else\n      isProof a\n  else\n    isProof a", "start": [117, 1], "end": [157, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.pushArgsAux", "code": "private partial def pushArgsAux (infos : Array ParamInfo) : Nat \u2192 Expr \u2192 Array Expr \u2192 MetaM (Array Expr)\n  | i, .app f a, todo => do\n    if (\u2190 ignoreArg a i infos) then\n      pushArgsAux infos (i-1) f (todo.push tmpStar)\n    else\n      pushArgsAux infos (i-1) f (todo.push a)\n  | _, _, todo => return todo", "start": [159, 1], "end": [165, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.isNumeral", "code": "private partial def isNumeral (e : Expr) : Bool :=\n  if e.isNatLit then true\n  else\n    let f := e.getAppFn\n    if !f.isConst then false\n    else\n      let fName := f.constName!\n      if fName == ``Nat.succ && e.getAppNumArgs == 1 then isNumeral e.appArg!\n      else if fName == ``OfNat.ofNat && e.getAppNumArgs == 3 then isNumeral (e.getArg! 1)\n      else if fName == ``Nat.zero && e.getAppNumArgs == 0 then true\n      else false", "start": [167, 1], "end": [183, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.toNatLit?", "code": "private partial def toNatLit? (e : Expr) : Option Literal :=\n  if isNumeral e then\n    if let some n := loop e then\n      some (.natVal n)\n    else\n      none\n  else\n    none\nwhere\n  loop (e : Expr) : OptionT Id Nat := do\n    let f := e.getAppFn\n    match f with\n    | .lit (.natVal n) => return n\n    | .const fName .. =>\n      if fName == ``Nat.succ && e.getAppNumArgs == 1 then\n        let r \u2190 loop e.appArg!\n        return r+1\n      else if fName == ``OfNat.ofNat && e.getAppNumArgs == 3 then\n        loop (e.getArg! 1)\n      else if fName == ``Nat.zero && e.getAppNumArgs == 0 then\n        return 0\n      else\n        failure\n    | _ => failure", "start": [185, 1], "end": [208, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.isNatType", "code": "private def isNatType (e : Expr) : MetaM Bool :=\n  return (\u2190 whnf e).isConstOf ``Nat", "start": [210, 1], "end": [211, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.isOffset", "code": "private def isOffset (fName : Name) (e : Expr) : MetaM Bool := do\n  if fName == ``Nat.add && e.getAppNumArgs == 2 then\n    return isNumeral e.appArg!\n  else if fName == ``Add.add && e.getAppNumArgs == 4 then\n    if (\u2190 isNatType (e.getArg! 0)) then return isNumeral e.appArg! else return false\n  else if fName == ``HAdd.hAdd && e.getAppNumArgs == 6 then\n    if (\u2190 isNatType (e.getArg! 1)) then return isNumeral e.appArg! else return false\n  else\n    return fName == ``Nat.succ && e.getAppNumArgs == 1", "start": [213, 1], "end": [229, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.shouldAddAsStar", "code": "private def shouldAddAsStar (fName : Name) (e : Expr) : MetaM Bool := do\n  isOffset fName e", "start": [231, 1], "end": [242, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.mkNoindexAnnotation", "code": "def mkNoindexAnnotation (e : Expr) : Expr :=\n  mkAnnotation `noindex e", "start": [244, 1], "end": [245, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.hasNoindexAnnotation", "code": "def hasNoindexAnnotation (e : Expr) : Bool :=\n  annotation? `noindex e |>.isSome", "start": [247, 1], "end": [248, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.reduce", "code": "partial def reduce (e : Expr) (simpleReduce : Bool) : MetaM Expr := do\n  let e \u2190 whnfCore e (simpleReduceOnly := simpleReduce)\n  match (\u2190 unfoldDefinition? e) with\n  | some e => reduce e simpleReduce\n  | none => match e.etaExpandedStrict? with\n    | some e => reduce e simpleReduce\n    | none   => return e", "start": [250, 1], "end": [262, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.isBadKey", "code": "private def isBadKey (fn : Expr) : Bool :=\n  match fn with\n  | .lit ..   => false\n  | .const .. => false\n  | .fvar ..  => false\n  | .proj ..  => false\n  | .forallE _ _ b _ => b.hasLooseBVars\n  | _ => true", "start": [264, 1], "end": [277, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.elimLooseBVarsByBeta", "code": "private def elimLooseBVarsByBeta (e : Expr) : CoreM Expr :=\n  Core.transform e\n    (pre := fun e => do\n      if !e.hasLooseBVars then\n        return .done e\n      else if e.isHeadBetaTarget then\n        return .visit e.headBeta\n      else\n        return .continue)", "start": [279, 1], "end": [304, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.reduceUntilBadKey", "code": "private partial def reduceUntilBadKey (e : Expr) (simpleReduce : Bool) : MetaM Expr := do\n  let e \u2190 step e\n  match e.etaExpandedStrict? with\n  | some e => reduceUntilBadKey e simpleReduce\n  | none   => return e\nwhere\n  step (e : Expr) := do\n    let e \u2190 whnfCore e (simpleReduceOnly := simpleReduce)\n    match (\u2190 unfoldDefinition? e) with\n    | some e' => if isBadKey e'.getAppFn then return e else step e'\n    | none    => return e", "start": [306, 1], "end": [320, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.reduceDT", "code": "def reduceDT (e : Expr) (root : Bool) (simpleReduce : Bool) : MetaM Expr :=\n  if root then reduceUntilBadKey e simpleReduce else reduce e simpleReduce", "start": [322, 1], "end": [324, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.pushArgs", "code": "private def pushArgs (root : Bool) (todo : Array Expr) (e : Expr) : MetaM (Key s \u00d7 Array Expr) := do\n  if hasNoindexAnnotation e then\n    return (.star, todo)\n  else\n    let e \u2190 reduceDT e root (simpleReduce := s)\n    let fn := e.getAppFn\n    let push (k : Key s) (nargs : Nat) (todo : Array Expr): MetaM (Key s \u00d7 Array Expr) := do\n      let info \u2190 getFunInfoNArgs fn nargs\n      let todo \u2190 pushArgsAux info.paramInfo (nargs-1) e todo\n      return (k, todo)\n    match fn with\n    | .lit v     =>\n      return (.lit v, todo)\n    | .const c _ =>\n      unless root do\n        if let some v := toNatLit? e then\n          return (.lit v, todo)\n        if (\u2190 shouldAddAsStar c e) then\n          return (.star, todo)\n      let nargs := e.getAppNumArgs\n      push (.const c nargs) nargs todo\n    | .proj s i a =>\n      \n      let a := if isClass (\u2190 getEnv) s then mkNoindexAnnotation a else a\n      let nargs := e.getAppNumArgs\n      push (.proj s i nargs) nargs (todo.push a)\n    | .fvar fvarId   =>\n      let nargs := e.getAppNumArgs\n      push (.fvar fvarId nargs) nargs todo\n    | .mvar mvarId   =>\n      if mvarId == tmpMVarId then\n        return (.star, todo)\n      else if (\u2190 mvarId.isReadOnlyOrSyntheticOpaque) then\n        return (.other, todo)\n      else\n        return (.star, todo)\n    | .forallE _ d b _ =>\n      let b \u2190 if b.hasLooseBVars then elimLooseBVarsByBeta b else pure b\n      if b.hasLooseBVars then\n        return (.other, todo)\n      else\n        return (.arrow, todo.push d |>.push b)\n    | _ =>\n      return (.other, todo)", "start": [328, 1], "end": [378, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.mkPathAux", "code": "partial def mkPathAux (root : Bool) (todo : Array Expr) (keys : Array (Key s)) : MetaM (Array (Key s)) := do\n  if todo.isEmpty then\n    return keys\n  else\n    let e    := todo.back\n    let todo := todo.pop\n    let (k, todo) \u2190 pushArgs root todo e\n    mkPathAux false todo (keys.push k)", "start": [380, 1], "end": [387, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.initCapacity", "code": "private def initCapacity := 8", "start": [389, 1], "end": [389, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.mkPath", "code": "def mkPath (e : Expr) : MetaM (Array (Key s)) := do\n  withReducible do\n    let todo : Array Expr := .mkEmpty initCapacity\n    let keys : Array (Key s) := .mkEmpty initCapacity\n    mkPathAux (root := true) (todo.push e) keys", "start": [391, 1], "end": [395, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.createNodes", "code": "private partial def createNodes (keys : Array (Key s)) (v : \u03b1) (i : Nat) : Trie \u03b1 s :=\n  if h : i < keys.size then\n    let k := keys.get \u27e8i, h\u27e9\n    let c := createNodes keys v (i+1)\n    .node #[] #[(k, c)]\n  else\n    .node #[v] #[]", "start": [397, 1], "end": [403, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.insertVal", "code": "private def insertVal [BEq \u03b1] (vs : Array \u03b1) (v : \u03b1) : Array \u03b1 :=\n  loop 0\nwhere\n  loop (i : Nat) : Array \u03b1 :=\n    if h : i < vs.size then\n      if v == vs[i] then\n        vs.set \u27e8i,h\u27e9 v\n      else\n        loop (i+1)\n    else\n      vs.push v\ntermination_by loop i => vs.size - i", "start": [405, 1], "end": [422, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.insertAux", "code": "private partial def insertAux [BEq \u03b1] (keys : Array (Key s)) (v : \u03b1) : Nat \u2192 Trie \u03b1 s \u2192 Trie \u03b1 s\n  | i, .node vs cs =>\n    if h : i < keys.size then\n      let k := keys.get \u27e8i, h\u27e9\n      let c := Id.run $ cs.binInsertM\n          (fun a b => a.1 < b.1)\n          (fun \u27e8_, s\u27e9 => let c := insertAux keys v (i+1) s; (k, c)) (fun _ => let c := createNodes keys v (i+1); (k, c))\n          (k, default)\n      .node vs c\n    else\n      .node (insertVal vs v) cs", "start": [424, 1], "end": [435, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.insertCore", "code": "def insertCore [BEq \u03b1] (d : DiscrTree \u03b1 s) (keys : Array (Key s)) (v : \u03b1) : DiscrTree \u03b1 s :=\n  if keys.isEmpty then panic! \"invalid key sequence\"\n  else\n    let k := keys[0]!\n    match d.root.find? k with\n    | none =>\n      let c := createNodes keys v 1\n      { root := d.root.insert k c }\n    | some c =>\n      let c := insertAux keys v 1 c\n      { root := d.root.insert k c }", "start": [437, 1], "end": [447, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.insert", "code": "def insert [BEq \u03b1] (d : DiscrTree \u03b1 s) (e : Expr) (v : \u03b1) : MetaM (DiscrTree \u03b1 s) := do\n  let keys \u2190 mkPath e\n  return d.insertCore keys v", "start": [449, 1], "end": [451, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getKeyArgs", "code": "private def getKeyArgs (e : Expr) (isMatch root : Bool) : MetaM (Key s \u00d7 Array Expr) := do\n  let e \u2190 reduceDT e root (simpleReduce := s)\n  unless root do\n    if let some v := toNatLit? e then\n      return (.lit v, #[])\n  match e.getAppFn with\n  | .lit v         => return (.lit v, #[])\n  | .const c _     =>\n    if (\u2190 getConfig).isDefEqStuckEx && e.hasExprMVar then\n      if (\u2190 isReducible c) then\n        \n        Meta.throwIsDefEqStuck\n      else if let some matcherInfo := isMatcherAppCore? (\u2190 getEnv) e then\n        let args := e.getAppArgs\n        for arg in args[matcherInfo.getFirstDiscrPos: matcherInfo.getFirstDiscrPos + matcherInfo.numDiscrs] do\n          if arg.hasExprMVar then\n            Meta.throwIsDefEqStuck\n      else if (\u2190 isRec c) then\n        \n        Meta.throwIsDefEqStuck\n    let nargs := e.getAppNumArgs\n    return (.const c nargs, e.getAppRevArgs)\n  | .fvar fvarId   =>\n    let nargs := e.getAppNumArgs\n    return (.fvar fvarId nargs, e.getAppRevArgs)\n  | .mvar mvarId   =>\n    if isMatch then\n      return (.other, #[])\n    else do\n      let ctx \u2190 read\n      if ctx.config.isDefEqStuckEx then\n        \n        return (.star, #[])\n      else if (\u2190 mvarId.isReadOnlyOrSyntheticOpaque) then\n        return (.other, #[])\n      else\n        return (.star, #[])\n  | .proj s i a .. =>\n    let nargs := e.getAppNumArgs\n    return (.proj s i nargs, #[a] ++ e.getAppRevArgs)\n  | .forallE _ d b _ =>\n    let b \u2190 if b.hasLooseBVars then elimLooseBVarsByBeta b else pure b\n    if b.hasLooseBVars then\n      return (.other, #[])\n    else\n      return (.arrow, #[d, b])\n  | _ =>\n    return (.other, #[])", "start": [453, 1], "end": [531, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getMatchKeyArgs", "code": "private abbrev getMatchKeyArgs (e : Expr) (root : Bool) : MetaM (Key s \u00d7 Array Expr) :=\n  getKeyArgs e (isMatch := true) (root := root)", "start": [533, 1], "end": [534, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getUnifyKeyArgs", "code": "private abbrev getUnifyKeyArgs (e : Expr) (root : Bool) : MetaM (Key s \u00d7 Array Expr) :=\n  getKeyArgs e (isMatch := false) (root := root)", "start": [536, 1], "end": [537, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getStarResult", "code": "private def getStarResult (d : DiscrTree \u03b1 s) : Array \u03b1 :=\n  let result : Array \u03b1 := .mkEmpty initCapacity\n  match d.root.find? .star with\n  | none                  => result\n  | some (.node vs _) => result ++ vs", "start": [539, 1], "end": [543, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.findKey", "code": "private abbrev findKey (cs : Array (Key s \u00d7 Trie \u03b1 s)) (k : Key s) : Option (Key s \u00d7 Trie \u03b1 s) :=\n  cs.binSearch (k, default) (fun a b => a.1 < b.1)", "start": [545, 1], "end": [546, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getMatchLoop", "code": "private partial def getMatchLoop (todo : Array Expr) (c : Trie \u03b1 s) (result : Array \u03b1) : MetaM (Array \u03b1) := do\n  match c with\n  | .node vs cs =>\n    if todo.isEmpty then\n      return result ++ vs\n    else if cs.isEmpty then\n      return result\n    else\n      let e     := todo.back\n      let todo  := todo.pop\n      let first := cs[0]! \n      let (k, args) \u2190 getMatchKeyArgs e (root := false)\n      \n      let visitStar (result : Array \u03b1) : MetaM (Array \u03b1) :=\n        if first.1 == .star then\n          getMatchLoop todo first.2 result\n        else\n          return result\n      let visitNonStar (k : Key s) (args : Array Expr) (result : Array \u03b1) : MetaM (Array \u03b1) :=\n        match findKey cs k with\n        | none   => return result\n        | some c => getMatchLoop (todo ++ args) c.2 result\n      let result \u2190 visitStar result\n      match k with\n      | .star  => return result\n      \n      | .arrow => visitNonStar .other #[] (\u2190 visitNonStar k args result)\n      | _      => visitNonStar k args result", "start": [548, 1], "end": [581, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getMatchRoot", "code": "private def getMatchRoot (d : DiscrTree \u03b1 s) (k : Key s) (args : Array Expr) (result : Array \u03b1) : MetaM (Array \u03b1) :=\n  match d.root.find? k with\n  | none   => return result\n  | some c => getMatchLoop args c result", "start": [583, 1], "end": [586, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getMatchCore", "code": "private def getMatchCore (d : DiscrTree \u03b1 s) (e : Expr) : MetaM (Key s \u00d7 Array \u03b1) :=\n  withReducible do\n    let result := getStarResult d\n    let (k, args) \u2190 getMatchKeyArgs e (root := true)\n    match k with\n    | .star  => return (k, result)\n    \n    | .arrow => return (k, (\u2190 getMatchRoot d k args (\u2190 getMatchRoot d .other #[] result)))\n    | _      => return (k, (\u2190 getMatchRoot d k args result))", "start": [588, 1], "end": [596, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getMatch", "code": "def getMatch (d : DiscrTree \u03b1 s) (e : Expr) : MetaM (Array \u03b1) :=\n  return (\u2190 getMatchCore d e).2", "start": [598, 1], "end": [602, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getMatchWithExtra", "code": "partial def getMatchWithExtra (d : DiscrTree \u03b1 s) (e : Expr) : MetaM (Array (\u03b1 \u00d7 Nat)) := do\n  let (k, result) \u2190 getMatchCore d e\n  let result := result.map (\u00b7, 0)\n  if !e.isApp then\n    return result\n  else if !(\u2190 mayMatchPrefix k) then\n    return result\n  else\n    go e.appFn! 1 result\nwhere\n  mayMatchPrefix (k : Key s) : MetaM Bool :=\n    let cont (k : Key s) : MetaM Bool :=\n      if d.root.find? k |>.isSome then\n        return true\n      else\n        mayMatchPrefix k\n    match k with\n    | .const f (n+1)  => cont (.const f n)\n    | .fvar f (n+1)   => cont (.fvar f n)\n    | .proj s i (n+1) => cont (.proj s i n)\n    | _               => return false\n\n  go (e : Expr) (numExtra : Nat) (result : Array (\u03b1 \u00d7 Nat)) : MetaM (Array (\u03b1 \u00d7 Nat)) := do\n    let result := result ++ (\u2190 getMatch d e).map (., numExtra)\n    if e.isApp then\n      go e.appFn! (numExtra + 1) result\n    else\n      return result", "start": [604, 1], "end": [634, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getUnify", "code": "partial def getUnify (d : DiscrTree \u03b1 s) (e : Expr) : MetaM (Array \u03b1) :=\n  withReducible do\n    let (k, args) \u2190 getUnifyKeyArgs e (root := true)\n    match k with\n    | .star => d.root.foldlM (init := #[]) fun result k c => process k.arity #[] c result\n    | _ =>\n      let result := getStarResult d\n      match d.root.find? k with\n      | none   => return result\n      | some c => process 0 args c result\nwhere\n  process (skip : Nat) (todo : Array Expr) (c : Trie \u03b1 s) (result : Array \u03b1) : MetaM (Array \u03b1) := do\n    match skip, c with\n    | skip+1, .node _  cs =>\n      if cs.isEmpty then\n        return result\n      else\n        cs.foldlM (init := result) fun result \u27e8k, c\u27e9 => process (skip + k.arity) todo c result\n    | 0, .node vs cs => do\n      if todo.isEmpty then\n        return result ++ vs\n      else if cs.isEmpty then\n        return result\n      else\n        let e     := todo.back\n        let todo  := todo.pop\n        let (k, args) \u2190 getUnifyKeyArgs e (root := false)\n        let visitStar (result : Array \u03b1) : MetaM (Array \u03b1) :=\n          let first := cs[0]!\n          if first.1 == .star then\n            process 0 todo first.2 result\n          else\n            return result\n        let visitNonStar (k : Key s) (args : Array Expr) (result : Array \u03b1) : MetaM (Array \u03b1) :=\n          match findKey cs k with\n          | none   => return result\n          | some c => process 0 (todo ++ args) c.2 result\n        match k with\n        | .star  => cs.foldlM (init := result) fun result \u27e8k, c\u27e9 => process k.arity todo c result\n        | .arrow => visitNonStar .other #[] (\u2190 visitNonStar k args (\u2190 visitStar result))\n        | _      => visitNonStar k args (\u2190 visitStar result)", "start": [636, 1], "end": [677, 61], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/CollectMVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/CollectMVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.collectMVars", "code": "partial def collectMVars (e : Expr) : StateRefT CollectMVars.State MetaM Unit := do\n  let e \u2190 instantiateMVars e\n  let s \u2190 get\n  let resultSavedSize := s.result.size\n  let s := e.collectMVars s\n  set s\n  for mvarId in s.result[resultSavedSize:] do\n    match (\u2190 getDelayedMVarAssignment? mvarId) with\n    | none   => pure ()\n    | some d => collectMVars (mkMVar d.mvarIdPending)", "start": [11, 1], "end": [29, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMVars", "code": "def getMVars (e : Expr) : MetaM (Array MVarId) := do\n  let (_, s) \u2190 (collectMVars e).run {}\n  pure s.result", "start": [31, 1], "end": [34, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMVarsNoDelayed", "code": "def getMVarsNoDelayed (e : Expr) : MetaM (Array MVarId) := do\n  let mvarIds \u2190 getMVars e\n  mvarIds.filterM fun mvarId => not <$> mvarId.isDelayedAssigned", "start": [36, 1], "end": [39, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.collectMVarsAtDecl", "code": "def collectMVarsAtDecl (d : Declaration) : StateRefT CollectMVars.State MetaM Unit :=\n  d.forExprM collectMVars", "start": [41, 1], "end": [42, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMVarsAtDecl", "code": "def getMVarsAtDecl (d : Declaration) : MetaM (Array MVarId) := do\n  let (_, s) \u2190 (collectMVarsAtDecl d).run {}\n  pure s.result", "start": [44, 1], "end": [46, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Do.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.doElemParser", "code": "@[inline] def doElemParser (rbp : Nat := 0) : Parser :=\n  categoryParser `doElem rbp", "start": [14, 1], "end": [15, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.leftArrow", "code": "def leftArrow : Parser := unicodeSymbol \"\u2190 \" \"<- \"", "start": [18, 1], "end": [18, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.liftMethod", "code": "@[builtin_term_parser] def liftMethod := leading_parser:minPrec\n  leftArrow >> termParser", "start": [19, 1], "end": [20, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doSeqItem", "code": "def doSeqItem      := leading_parser\n  ppLine >> doElemParser >> optional \"; \"", "start": [22, 1], "end": [23, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doSeqIndent", "code": "def doSeqIndent    := leading_parser\n  many1Indent doSeqItem", "start": [24, 1], "end": [25, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doSeqBracketed", "code": "def doSeqBracketed := leading_parser\n  \"{\" >> withoutPosition (many1 doSeqItem) >> ppLine >> \"}\"", "start": [26, 1], "end": [27, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doSeq", "code": "def doSeq          :=\n  withAntiquot (mkAntiquot \"doSeq\" decl_name% (isPseudoKind := true)) <|\n    doSeqBracketed <|> doSeqIndent", "start": [28, 1], "end": [34, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.termBeforeDo", "code": "def termBeforeDo := withForbidden \"do\" termParser", "start": [35, 1], "end": [39, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.notFollowedByRedefinedTermToken", "code": "def notFollowedByRedefinedTermToken :=\n  notFollowedBy (\"set_option\" <|> \"open\" <|> \"if\" <|> \"match\" <|> \"let\" <|> \"have\" <|>\n      \"do\" <|> \"dbg_trace\" <|> \"assert!\" <|> \"for\" <|> \"unless\" <|> \"return\" <|> symbol \"try\")\n    \"token at 'do' element\"", "start": [47, 1], "end": [54, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doLet", "code": "@[builtin_doElem_parser] def doLet      := leading_parser\n  \"let \" >> optional \"mut \" >> letDecl", "start": [56, 1], "end": [57, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doLetElse", "code": "@[builtin_doElem_parser] def doLetElse  := leading_parser\n  \"let \" >> optional \"mut \" >> termParser >> \" := \" >> termParser >>\n  checkColGt >> \" | \" >> doSeq", "start": [58, 1], "end": [60, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doLetRec", "code": "@[builtin_doElem_parser] def doLetRec   := leading_parser\n  group (\"let \" >> nonReservedSymbol \"rec \") >> letRecDecls", "start": [62, 1], "end": [63, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doIdDecl", "code": "def doIdDecl   := leading_parser\n  atomic (ident >> optType >> ppSpace >> leftArrow) >>\n  doElemParser", "start": [64, 1], "end": [66, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doPatDecl", "code": "def doPatDecl  := leading_parser\n  atomic (termParser >> ppSpace >> leftArrow) >>\n  doElemParser >> optional (checkColGt >> \" | \" >> doSeq)", "start": [67, 1], "end": [69, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doLetArrow", "code": "@[builtin_doElem_parser] def doLetArrow      := leading_parser\n  withPosition (\"let \" >> optional \"mut \" >> (doIdDecl <|> doPatDecl))", "start": [70, 1], "end": [71, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.letIdDeclNoBinders", "code": "def letIdDeclNoBinders := node ``letIdDecl <|\n  atomic (ident >> pushNone >> optType >> \" := \") >> termParser", "start": [75, 1], "end": [76, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doReassign", "code": "@[builtin_doElem_parser] def doReassign      := leading_parser\n  notFollowedByRedefinedTermToken >> (letIdDeclNoBinders <|> letPatDecl)", "start": [78, 1], "end": [79, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doReassignArrow", "code": "@[builtin_doElem_parser] def doReassignArrow := leading_parser\n  notFollowedByRedefinedTermToken >> (doIdDecl <|> doPatDecl)", "start": [80, 1], "end": [81, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doHave", "code": "@[builtin_doElem_parser] def doHave     := leading_parser\n  \"have\" >> Term.haveDecl", "start": [82, 1], "end": [83, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.elseIf", "code": "def elseIf := atomic (group (withPosition (\"else \" >> checkLineEq >> \" if \")))", "start": [114, 1], "end": [114, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doIfLetPure", "code": "def doIfLetPure := leading_parser \" := \" >> termParser", "start": [116, 1], "end": [116, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doIfLetBind", "code": "def doIfLetBind := leading_parser \" \u2190 \" >> termParser", "start": [117, 1], "end": [117, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doIfLet", "code": "def doIfLet     := leading_parser (withAnonymousAntiquot := false)\n  \"let \" >> termParser >> (doIfLetPure <|> doIfLetBind)", "start": [118, 1], "end": [119, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doIfProp", "code": "def doIfProp    := leading_parser (withAnonymousAntiquot := false)\n  optIdent >> termParser", "start": [120, 1], "end": [121, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doIfCond", "code": "def doIfCond    :=\n  withAntiquot (mkAntiquot \"doIfCond\" decl_name% (anonymous := false) (isPseudoKind := true)) <|\n    doIfLet <|> doIfProp", "start": [122, 1], "end": [124, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doIf", "code": "@[builtin_doElem_parser] def doIf := leading_parser withResetCache <| withPositionAfterLinebreak <| ppRealGroup <|\n  ppRealFill (ppIndent (\"if \" >> doIfCond >> \" then\") >> ppSpace >> doSeq) >>\n  many (checkColGe \"'else if' in 'do' must be indented\" >>\n    group (ppDedent ppSpace >> ppRealFill (elseIf >> doIfCond >> \" then \" >> doSeq))) >>\n  optional (checkColGe \"'else' in 'do' must be indented\" >>\n    ppDedent ppSpace >> ppRealFill (\"else \" >> doSeq))", "start": [127, 1], "end": [132, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doUnless", "code": "@[builtin_doElem_parser] def doUnless := leading_parser\n  \"unless \" >> withForbidden \"do\" termParser >> \" do \" >> doSeq", "start": [133, 1], "end": [134, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doForDecl", "code": "def doForDecl := leading_parser\n  optional (atomic (ident >> \" : \")) >> termParser >> \" in \" >> withForbidden \"do\" termParser", "start": [135, 1], "end": [136, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doFor", "code": "@[builtin_doElem_parser] def doFor    := leading_parser\n  \"for \" >> sepBy1 doForDecl \", \" >> \"do \" >> doSeq", "start": [137, 1], "end": [145, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doMatchAlts", "code": "def doMatchAlts := ppDedent <| matchAlts (rhsParser := doSeq)", "start": [147, 1], "end": [147, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doMatch", "code": "@[builtin_doElem_parser] def doMatch := leading_parser:leadPrec\n  \"match \" >> optional Term.generalizingParam >> optional Term.motive >>\n  sepBy1 matchDiscr \", \" >> \" with\" >> doMatchAlts", "start": [148, 1], "end": [150, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doCatch", "code": "def doCatch      := leading_parser\n  ppDedent ppLine >> atomic (\"catch \" >> binderIdent) >> optional (\" : \" >> termParser) >> darrow >> doSeq", "start": [152, 1], "end": [153, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doCatchMatch", "code": "def doCatchMatch := leading_parser\n  ppDedent ppLine >> \"catch \" >> doMatchAlts", "start": [154, 1], "end": [155, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doFinally", "code": "def doFinally    := leading_parser\n  ppDedent ppLine >> \"finally \" >> doSeq", "start": [156, 1], "end": [157, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doTry", "code": "@[builtin_doElem_parser] def doTry    := leading_parser\n  \"try \" >> doSeq >> many (doCatch <|> doCatchMatch) >> optional doFinally", "start": [158, 1], "end": [159, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doBreak", "code": "@[builtin_doElem_parser] def doBreak     := leading_parser \"break\"", "start": [161, 1], "end": [162, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doContinue", "code": "@[builtin_doElem_parser] def doContinue  := leading_parser \"continue\"", "start": [163, 1], "end": [164, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doReturn", "code": "@[builtin_doElem_parser] def doReturn    := leading_parser:leadPrec\n  withPosition (\"return\" >> optional (ppSpace >> checkLineEq >> termParser))", "start": [165, 1], "end": [176, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doDbgTrace", "code": "@[builtin_doElem_parser] def doDbgTrace  := leading_parser:leadPrec\n  \"dbg_trace \" >> ((interpolatedStr termParser) <|> termParser)", "start": [177, 1], "end": [178, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doAssert", "code": "@[builtin_doElem_parser] def doAssert    := leading_parser:leadPrec\n  \"assert! \" >> termParser", "start": [179, 1], "end": [180, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doExpr", "code": "@[builtin_doElem_parser] def doExpr   := leading_parser\n  notFollowedByRedefinedTermToken >> termParser >>\n  notFollowedBy (symbol \":=\" <|> symbol \"\u2190\" <|> symbol \"<-\")\n    \"unexpected token after 'expr' in 'do' block\"", "start": [198, 1], "end": [201, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.doNested", "code": "@[builtin_doElem_parser] def doNested := leading_parser\n  \"do \" >> doSeq", "start": [202, 1], "end": [203, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.do", "code": "@[builtin_term_parser] def \u00abdo\u00bb  := leading_parser:argPrec\n  ppAllowUngrouped >> \"do \" >> doSeq", "start": [205, 1], "end": [206, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.termUnless", "code": "@[builtin_term_parser] def termUnless := leading_parser\n  \"unless \" >> withForbidden \"do\" termParser >> \" do \" >> doSeq", "start": [213, 1], "end": [215, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.termFor", "code": "@[builtin_term_parser] def termFor := leading_parser\n  \"for \" >> sepBy1 doForDecl \", \" >> \" do \" >> doSeq", "start": [216, 1], "end": [217, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.termTry", "code": "@[builtin_term_parser] def termTry    := leading_parser\n  \"try \" >> doSeq >> many (doCatch <|> doCatchMatch) >> optional doFinally", "start": [218, 1], "end": [219, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.termReturn", "code": "@[builtin_term_parser] def termReturn := leading_parser:leadPrec\n  withPosition (\"return\" >> optional (ppSpace >> checkLineEq >> termParser))", "start": [220, 1], "end": [225, 77], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.ensureType", "code": "private def ensureType (e : Expr) : MetaM Unit := do\n  discard <| getLevel e", "start": [15, 1], "end": [16, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwLetTypeMismatchMessage", "code": "def throwLetTypeMismatchMessage {\u03b1} (fvarId : FVarId) : MetaM \u03b1 := do\n  let lctx \u2190 getLCtx\n  match lctx.find? fvarId with\n  | some (LocalDecl.ldecl _ _ _ t v _ _) => do\n    let vType \u2190 inferType v\n    throwError \"invalid let declaration, term{indentExpr v}\\nhas type{indentExpr vType}\\nbut is expected to have type{indentExpr t}\"\n  | _ => unreachable!", "start": [18, 1], "end": [24, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkConstant", "code": "private def checkConstant (constName : Name) (us : List Level) : MetaM Unit := do\n  let cinfo \u2190 getConstInfo constName\n  unless us.length == cinfo.levelParams.length do\n    throwIncorrectNumberOfLevels constName us", "start": [26, 1], "end": [29, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getFunctionDomain", "code": "private def getFunctionDomain (f : Expr) : MetaM (Expr \u00d7 BinderInfo) := do\n  let fType \u2190 inferType f\n  let fType \u2190 whnfD fType\n  match fType with\n  | Expr.forallE _ d _ c => return (d, c)\n  | _                    => throwFunctionExpected f", "start": [31, 1], "end": [36, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addPPExplicitToExposeDiff", "code": "partial def addPPExplicitToExposeDiff (a b : Expr) : MetaM (Expr \u00d7 Expr) := do\n  if (\u2190 getOptions).getBool `pp.all false || (\u2190 getOptions).getBool `pp.explicit false then\n    return (a, b)\n  else\n    visit (\u2190 instantiateMVars a) (\u2190 instantiateMVars b)\nwhere\n  visit (a b : Expr) : MetaM (Expr \u00d7 Expr) := do\n    try\n      if !a.isApp || !b.isApp then\n        return (a, b)\n      else if a.getAppNumArgs != b.getAppNumArgs then\n        return (a, b)\n      else if not (\u2190 isDefEq a.getAppFn b.getAppFn) then\n        return (a, b)\n      else\n        let fType \u2190 inferType a.getAppFn\n        forallBoundedTelescope fType a.getAppNumArgs fun xs _ => do\n          let mut as := a.getAppArgs\n          let mut bs := b.getAppArgs\n          if let some (as', bs') \u2190 hasExplicitDiff? xs as bs then\n            return (mkAppN a.getAppFn as', mkAppN b.getAppFn bs')\n          else\n            for i in [:as.size] do\n              unless (\u2190 isDefEq as[i]! bs[i]!) do\n                let (ai, bi) \u2190 visit as[i]! bs[i]!\n                as := as.set! i ai\n                bs := bs.set! i bi\n            let a := mkAppN a.getAppFn as\n            let b := mkAppN b.getAppFn bs\n            return (a.setAppPPExplicit, b.setAppPPExplicit)\n    catch _ =>\n      return (a, b)\n\n  hasExplicitDiff? (xs as bs : Array Expr) : MetaM (Option (Array Expr \u00d7 Array Expr)) := do\n    for i in [:xs.size] do\n      let localDecl \u2190 xs[i]!.fvarId!.getDecl\n      if localDecl.binderInfo.isExplicit then\n         unless (\u2190 isDefEq as[i]! bs[i]!) do\n           let (ai, bi) \u2190 visit as[i]! bs[i]!\n           return some (as.set! i ai, bs.set! i bi)\n    return none", "start": [38, 1], "end": [112, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkHasTypeButIsExpectedMsg", "code": "def mkHasTypeButIsExpectedMsg (givenType expectedType : Expr) : MetaM MessageData := do\n  try\n    let givenTypeType \u2190 inferType givenType\n    let expectedTypeType \u2190 inferType expectedType\n    let (givenType, expectedType) \u2190 addPPExplicitToExposeDiff givenType expectedType\n    let (givenTypeType, expectedTypeType) \u2190 addPPExplicitToExposeDiff givenTypeType expectedTypeType\n    return m!\"has type{indentD m!\"{givenType} : {givenTypeType}\"}\\nbut is expected to have type{indentD m!\"{expectedType} : {expectedTypeType}\"}\"\n  catch _ =>\n    let (givenType, expectedType) \u2190 addPPExplicitToExposeDiff givenType expectedType\n    return m!\"has type{indentExpr givenType}\\nbut is expected to have type{indentExpr expectedType}\"", "start": [114, 1], "end": [126, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwAppTypeMismatch", "code": "def throwAppTypeMismatch (f a : Expr) : MetaM \u03b1 := do\n  let (expectedType, binfo) \u2190 getFunctionDomain f\n  let mut e := mkApp f a\n  unless binfo.isExplicit do\n    e := e.setAppPPExplicit\n  let aType \u2190 inferType a\n  throwError \"application type mismatch{indentExpr e}\\nargument{indentExpr a}\\n{\u2190 mkHasTypeButIsExpectedMsg aType expectedType}\"", "start": [128, 1], "end": [134, 129], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkApp", "code": "def checkApp (f a : Expr) : MetaM Unit := do\n  let fType \u2190 inferType f\n  let fType \u2190 whnf fType\n  match fType with\n  | Expr.forallE _ d _ _ =>\n    let aType \u2190 inferType a\n    unless (\u2190 isDefEq d aType) do\n      throwAppTypeMismatch f a\n  | _ => throwFunctionExpected (mkApp f a)", "start": [136, 1], "end": [144, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkAux", "code": "private partial def checkAux (e : Expr) : MetaM Unit := do\n  check e |>.run\nwhere\n  check (e : Expr) : MonadCacheT ExprStructEq Unit MetaM Unit :=\n    checkCache { val := e : ExprStructEq } fun _ => do\n      match e with\n      | .forallE ..      => checkForall e\n      | .lam ..          => checkLambdaLet e\n      | .letE ..         => checkLambdaLet e\n      | .const c lvls    => checkConstant c lvls\n      | .app f a         => check f; check a; checkApp f a\n      | .mdata _ e       => check e\n      | .proj _ _ e      => check e\n      | _                => return ()\n\n  checkLambdaLet (e : Expr) : MonadCacheT ExprStructEq Unit MetaM Unit :=\n    lambdaLetTelescope e fun xs b => do\n      xs.forM fun x => do\n        let xDecl \u2190 getFVarLocalDecl x;\n        match xDecl with\n        | .cdecl (type := t) .. =>\n          ensureType t\n          check t\n        | .ldecl (type := t) (value := v) .. =>\n          ensureType t\n          check t\n          let vType \u2190 inferType v\n          unless (\u2190 isDefEq t vType) do throwLetTypeMismatchMessage x.fvarId!\n          check v\n      check b\n\n  checkForall (e : Expr) : MonadCacheT ExprStructEq Unit MetaM Unit :=\n    forallTelescope e fun xs b => do\n      xs.forM fun x => do\n        let xDecl \u2190 getFVarLocalDecl x\n        ensureType xDecl.type\n        check xDecl.type\n      ensureType b\n      check b", "start": [146, 1], "end": [184, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.check", "code": "def check (e : Expr) : MetaM Unit :=\n  withTraceNode `Meta.check (fun res =>\n      return m!\"{if res.isOk then checkEmoji else crossEmoji} {e}\") do\n    try\n      withTransparency TransparencyMode.all $ checkAux e\n    catch ex =>\n      trace[Meta.check] ex.toMessageData\n      throw ex", "start": [186, 1], "end": [196, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isTypeCorrect", "code": "def isTypeCorrect (e : Expr) : MetaM Bool := do\n  try\n    check e\n    pure true\n  catch _ =>\n    pure false", "start": [198, 1], "end": [206, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Instances.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/CollectMVars.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Lean/Meta/GlobalInstances.lean", "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean"], "premises": [{"full_name": "Lean.Meta.InstanceKey", "code": "abbrev InstanceKey := DiscrTree.Key (simpleReduce := false)", "start": [40, 1], "end": [40, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.InstanceEntry", "code": "structure InstanceEntry where\n  keys        : Array InstanceKey\n  val         : Expr\n  priority    : Nat\n  globalName? : Option Name := none\n  \n  synthOrder  : Array Nat\n  \n  attrKind    : AttributeKind\n  deriving Inhabited", "start": [42, 1], "end": [56, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.InstanceTree", "code": "abbrev InstanceTree := DiscrTree InstanceEntry (simpleReduce := false)", "start": [66, 1], "end": [66, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Instances", "code": "structure Instances where\n  discrTree     : InstanceTree := DiscrTree.empty\n  instanceNames : PHashMap Name InstanceEntry := {}\n  erased        : PHashSet Name := {}\n  deriving Inhabited", "start": [68, 1], "end": [72, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addInstanceEntry", "code": "def addInstanceEntry (d : Instances) (e : InstanceEntry) : Instances :=\n  match e.globalName? with\n  | some n => { d with discrTree := d.discrTree.insertCore e.keys e, instanceNames := d.instanceNames.insert n e, erased := d.erased.erase n }\n  | none   => { d with discrTree := d.discrTree.insertCore e.keys e }", "start": [74, 1], "end": [77, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Instances.eraseCore", "code": "def Instances.eraseCore (d : Instances) (declName : Name) : Instances :=\n  { d with erased := d.erased.insert declName, instanceNames := d.instanceNames.erase declName }", "start": [79, 1], "end": [80, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Instances.erase", "code": "def Instances.erase [Monad m] [MonadError m] (d : Instances) (declName : Name) : m Instances := do\n  unless d.instanceNames.contains declName do\n    throwError \"'{declName}' does not have [instance] attribute\"\n  return d.eraseCore declName", "start": [82, 1], "end": [85, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInstanceKey", "code": "private def mkInstanceKey (e : Expr) : MetaM (Array InstanceKey) := do\n  let type \u2190 inferType e\n  withNewMCtxDepth do\n    let (_, _, type) \u2190 forallMetaTelescopeReducing type\n    DiscrTree.mkPath type", "start": [93, 1], "end": [97, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.computeSynthOrder", "code": "partial def computeSynthOrder (inst : Expr) : MetaM (Array Nat) :=\n  withReducible do\n  let instTy \u2190 inferType inst\n\n  let rec getSemiOutParamPositionsOf (classTy : Expr) : MetaM (Array Nat) := do\n    if let .const className .. := classTy.getAppFn then\n      forallTelescopeReducing (\u2190 inferType classTy.getAppFn) fun args _ => do\n      let mut pos := (getOutParamPositions? (\u2190 getEnv) className).getD #[]\n      for arg in args, i in [:args.size] do\n        if (\u2190 inferType arg).isAppOf ``semiOutParam then\n          pos := pos.push i\n      return pos\n    else\n      return #[]\n\n  let (argMVars, argBIs, ty) \u2190 forallMetaTelescopeReducing instTy\n  let ty \u2190 whnf ty\n  forallTelescopeReducing instTy fun argVars _ => do\n\n  let rec assignMVarsIn (e : Expr) : MetaM Unit := do\n    for mvarId in \u2190 getMVars e do\n      if let some i := argMVars.findIdx? (\u00b7.mvarId! == mvarId) then\n        mvarId.assign argVars[i]!\n      assignMVarsIn (\u2190 inferType (.mvar mvarId))\n\n  let tyOutParams \u2190 getSemiOutParamPositionsOf ty\n  let tyArgs := ty.getAppArgs\n  for tyArg in tyArgs, i in [:tyArgs.size] do\n    unless tyOutParams.contains i do assignMVarsIn tyArg\n\n  let mut synthed := #[]\n  let mut toSynth := List.range argMVars.size |>.filter (argBIs[\u00b7]! == .instImplicit) |>.toArray\n  while !toSynth.isEmpty do\n    let next? \u2190 toSynth.findM? fun i => do\n      forallTelescopeReducing (\u2190 instantiateMVars (\u2190 inferType argMVars[i]!)) fun _ argTy => do\n      let argTy \u2190 whnf argTy\n      let argOutParams \u2190 getSemiOutParamPositionsOf argTy\n      let argTyArgs := argTy.getAppArgs\n      for i in [:argTyArgs.size], argTyArg in argTyArgs do\n        if !argOutParams.contains i && argTyArg.hasExprMVar then\n          return false\n      return true\n    let next \u2190\n      match next? with\n      | some next => pure next\n      | none =>\n        if synthInstance.checkSynthOrder.get (\u2190 getOptions) then\n          let typeLines := (\"\" : MessageData).joinSep <| Array.toList <| \u2190 toSynth.mapM fun i => do\n            let ty \u2190 instantiateMVars (\u2190 inferType argMVars[i]!)\n            return indentExpr (ty.setPPExplicit true)\n          logError m!\"cannot find synthesization order for instance {inst} with type{indentExpr instTy}\\nall remaining arguments have metavariables:{typeLines}\"\n        pure toSynth[0]!\n    synthed := synthed.push next\n    toSynth := toSynth.filter (\u00b7 != next)\n    assignMVarsIn (\u2190 inferType argMVars[next]!)\n    assignMVarsIn argMVars[next]!\n\n  if synthInstance.checkSynthOrder.get (\u2190 getOptions) then\n    let ty \u2190 instantiateMVars ty\n    if ty.hasExprMVar then\n      logError m!\"instance does not provide concrete values for (semi-)out-params{indentExpr (ty.setPPExplicit true)}\"\n\n  trace[Meta.synthOrder] \"synthesizing the arguments of {inst} in the order {synthed}:{(\"\" : MessageData).joinSep (\u2190 synthed.mapM fun i => return indentExpr (\u2190 inferType argVars[i]!)).toList}\"\n\n  return synthed", "start": [99, 1], "end": [188, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addInstance", "code": "def addInstance (declName : Name) (attrKind : AttributeKind) (prio : Nat) : MetaM Unit := do\n  let c \u2190 mkConstWithLevelParams declName\n  let keys \u2190 mkInstanceKey c\n  addGlobalInstance declName attrKind\n  let synthOrder \u2190 computeSynthOrder c\n  instanceExtension.add { keys, val := c, priority := prio, globalName? := declName, attrKind, synthOrder } attrKind", "start": [190, 1], "end": [195, 117], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getGlobalInstancesIndex", "code": "def getGlobalInstancesIndex : CoreM (DiscrTree InstanceEntry (simpleReduce := false)) :=\n  return Meta.instanceExtension.getState (\u2190 getEnv) |>.discrTree", "start": [210, 1], "end": [211, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getErasedInstances", "code": "def getErasedInstances : CoreM (PHashSet Name) :=\n  return Meta.instanceExtension.getState (\u2190 getEnv) |>.erased", "start": [213, 1], "end": [214, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isInstance", "code": "def isInstance (declName : Name) : CoreM Bool :=\n  return Meta.instanceExtension.getState (\u2190 getEnv) |>.instanceNames.contains declName", "start": [216, 1], "end": [217, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getInstancePriority?", "code": "def getInstancePriority? (declName : Name) : CoreM (Option Nat) := do\n  let some entry := Meta.instanceExtension.getState (\u2190 getEnv) |>.instanceNames.find? declName | return none\n  return entry.priority", "start": [219, 1], "end": [221, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getInstanceAttrKind?", "code": "def getInstanceAttrKind? (declName : Name) : CoreM (Option AttributeKind) := do\n  let some entry := Meta.instanceExtension.getState (\u2190 getEnv) |>.instanceNames.find? declName | return none\n  return entry.attrKind", "start": [223, 1], "end": [225, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DefaultInstanceEntry", "code": "structure DefaultInstanceEntry where\n  className    : Name\n  instanceName : Name\n  priority     : Nat", "start": [229, 1], "end": [232, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.PrioritySet", "code": "abbrev PrioritySet := RBTree Nat (fun x y => compare y x)", "start": [234, 1], "end": [234, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DefaultInstances", "code": "structure DefaultInstances where\n  defaultInstances : NameMap (List (Name \u00d7 Nat)) := {}\n  priorities       : PrioritySet := {}\n  deriving Inhabited", "start": [236, 1], "end": [239, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addDefaultInstanceEntry", "code": "def addDefaultInstanceEntry (d : DefaultInstances) (e : DefaultInstanceEntry) : DefaultInstances :=\n  let d := { d with priorities := d.priorities.insert e.priority }\n  match d.defaultInstances.find? e.className with\n  | some insts => { d with defaultInstances := d.defaultInstances.insert e.className <| (e.instanceName, e.priority) :: insts }\n  | none       => { d with defaultInstances := d.defaultInstances.insert e.className [(e.instanceName, e.priority)] }", "start": [241, 1], "end": [245, 118], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addDefaultInstance", "code": "def addDefaultInstance (declName : Name) (prio : Nat := 0) : MetaM Unit := do\n  match (\u2190 getEnv).find? declName with\n  | none => throwError \"unknown constant '{declName}'\"\n  | some info =>\n    forallTelescopeReducing info.type fun _ type => do\n      match type.getAppFn with\n      | Expr.const className _ =>\n        unless isClass (\u2190 getEnv) className do\n          throwError \"invalid default instance '{declName}', it has type '({className} ...)', but {className}' is not a type class\"\n        setEnv <| defaultInstanceExtension.addEntry (\u2190 getEnv) { className := className, instanceName := declName, priority := prio }\n      | _ => throwError \"invalid default instance '{declName}', type must be of the form '(C ...)' where 'C' is a type class\"", "start": [253, 1], "end": [263, 126], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getDefaultInstancesPriorities", "code": "def getDefaultInstancesPriorities [Monad m] [MonadEnv m] : m PrioritySet :=\n  return defaultInstanceExtension.getState (\u2190 getEnv) |>.priorities", "start": [276, 1], "end": [277, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getDefaultInstances", "code": "def getDefaultInstances [Monad m] [MonadEnv m] (className : Name) : m (List (Name \u00d7 Nat)) :=\n  return defaultInstanceExtension.getState (\u2190 getEnv) |>.defaultInstances.find? className |>.getD []", "start": [279, 1], "end": [280, 101], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/AbstractMVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.AbstractMVarsResult", "code": "structure AbstractMVarsResult where\n  paramNames : Array Name\n  numMVars   : Nat\n  expr       : Expr\n  deriving Inhabited, BEq", "start": [10, 1], "end": [14, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractMVars.State", "code": "structure State where\n  ngen         : NameGenerator\n  lctx         : LocalContext\n  mctx         : MetavarContext\n  nextParamIdx : Nat := 0\n  paramNames   : Array Name := #[]\n  fvars        : Array Expr  := #[]\n  lmap         : HashMap LMVarId Level := {}\n  emap         : HashMap MVarId Expr  := {}", "start": [18, 1], "end": [26, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractMVars.M", "code": "abbrev M := StateM State", "start": [28, 1], "end": [28, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractMVars.mkFreshId", "code": "def mkFreshId : M Name := do\n  let s \u2190 get\n  let fresh := s.ngen.curr\n  modify fun s => { s with ngen := s.ngen.next }\n  pure fresh", "start": [35, 1], "end": [39, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractMVars.mkFreshFVarId", "code": "def mkFreshFVarId : M FVarId :=\n  return { name := (\u2190 mkFreshId) }", "start": [41, 1], "end": [42, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractMVars.abstractLevelMVars", "code": "private partial def abstractLevelMVars (u : Level) : M Level := do\n  if !u.hasMVar then\n    return u\n  else\n    match u with\n    | Level.zero        => return u\n    | Level.param _     => return u\n    | Level.succ v      => return u.updateSucc! (\u2190 abstractLevelMVars v)\n    | Level.max v w     => return u.updateMax! (\u2190 abstractLevelMVars v) (\u2190 abstractLevelMVars w)\n    | Level.imax v w    => return u.updateIMax! (\u2190 abstractLevelMVars v) (\u2190 abstractLevelMVars w)\n    | Level.mvar mvarId =>\n      let s \u2190 get\n      let depth := s.mctx.getLevelDepth mvarId;\n      if depth != s.mctx.depth then\n        return u else\n        match s.lmap.find? mvarId with\n        | some u => pure u\n        | none   =>\n          let paramId := Name.mkNum `_abstMVar s.nextParamIdx\n          let u := mkLevelParam paramId\n          modify fun s => { s with nextParamIdx := s.nextParamIdx + 1, lmap := s.lmap.insert mvarId u, paramNames := s.paramNames.push paramId }\n          return u", "start": [44, 1], "end": [66, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractMVars.abstractExprMVars", "code": "partial def abstractExprMVars (e : Expr) : M Expr := do\n  if !e.hasMVar then\n    return e\n  else\n    match e with\n    | e@(Expr.lit _)           => return e\n    | e@(Expr.bvar _)          => return e\n    | e@(Expr.fvar _)          => return e\n    | e@(Expr.sort u)          => return e.updateSort! (\u2190 abstractLevelMVars u)\n    | e@(Expr.const _ us)      => return e.updateConst! (\u2190 us.mapM abstractLevelMVars)\n    | e@(Expr.proj _ _ s)      => return e.updateProj! (\u2190 abstractExprMVars s)\n    | e@(Expr.app f a)         => return e.updateApp! (\u2190 abstractExprMVars f) (\u2190 abstractExprMVars a)\n    | e@(Expr.mdata _ b)       => return e.updateMData! (\u2190 abstractExprMVars b)\n    | e@(Expr.lam _ d b _)     => return e.updateLambdaE! (\u2190 abstractExprMVars d) (\u2190 abstractExprMVars b)\n    | e@(Expr.forallE _ d b _) => return e.updateForallE! (\u2190 abstractExprMVars d) (\u2190 abstractExprMVars b)\n    | e@(Expr.letE _ t v b _)  => return e.updateLet! (\u2190 abstractExprMVars t) (\u2190 abstractExprMVars v) (\u2190 abstractExprMVars b)\n    | e@(Expr.mvar mvarId)     =>\n      let decl := (\u2190 getMCtx).getDecl mvarId\n      if decl.depth != (\u2190 getMCtx).depth then\n        return e\n      else\n        let eNew \u2190 instantiateMVars e\n        if e != eNew then\n          abstractExprMVars eNew\n        else\n          match (\u2190 get).emap.find? mvarId with\n          | some e =>\n            return e\n          | none   =>\n            let type   \u2190 abstractExprMVars decl.type\n            let fvarId \u2190 mkFreshFVarId\n            let fvar := mkFVar fvarId;\n            let userName := if decl.userName.isAnonymous then (`x).appendIndexAfter (\u2190 get).fvars.size else decl.userName\n            modify fun s => {\n              s with\n              emap  := s.emap.insert mvarId fvar,\n              fvars := s.fvars.push fvar,\n              lctx  := s.lctx.mkLocalDecl fvarId userName type }\n            return fvar", "start": [68, 1], "end": [106, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.abstractMVars", "code": "def abstractMVars (e : Expr) : MetaM AbstractMVarsResult := do\n  let e \u2190 instantiateMVars e\n  let (e, s) := AbstractMVars.abstractExprMVars e { mctx := (\u2190 getMCtx), lctx := (\u2190 getLCtx), ngen := (\u2190 getNGen) }\n  setNGen s.ngen\n  setMCtx s.mctx\n  let e := s.lctx.mkLambda s.fvars e\n  pure { paramNames := s.paramNames, numMVars := s.fvars.size, expr := e }", "start": [110, 1], "end": [134, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.openAbstractMVarsResult", "code": "def openAbstractMVarsResult (a : AbstractMVarsResult) : MetaM (Array Expr \u00d7 Array BinderInfo \u00d7 Expr) := do\n  let us \u2190 a.paramNames.mapM fun _ => mkFreshLevelMVar\n  let e := a.expr.instantiateLevelParamsArray a.paramNames us\n  lambdaMetaTelescope e (some a.numMVars)", "start": [136, 1], "end": [139, 42], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Exception.lean", "imports": ["lake-packages/lean4/src/lean/Lean/InternalExceptionId.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.throwPostpone", "code": "def throwPostpone [MonadExceptOf Exception m] : m \u03b1 :=\n  throw $ Exception.internal postponeExceptionId", "start": [18, 1], "end": [19, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.throwUnsupportedSyntax", "code": "def throwUnsupportedSyntax [MonadExceptOf Exception m] : m \u03b1 :=\n  throw $ Exception.internal unsupportedSyntaxExceptionId", "start": [21, 1], "end": [22, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.throwIllFormedSyntax", "code": "def throwIllFormedSyntax [Monad m] [MonadError m] : m \u03b1 :=\n  throwError \"ill-formed syntax\"", "start": [24, 1], "end": [25, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.throwAutoBoundImplicitLocal", "code": "def throwAutoBoundImplicitLocal [MonadExceptOf Exception m] (n : Name) : m \u03b1 :=\n  throw $ Exception.internal autoBoundImplicitExceptionId <| KVMap.empty.insert `localId n", "start": [27, 1], "end": [28, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.isAutoBoundImplicitLocalException?", "code": "def isAutoBoundImplicitLocalException? (ex : Exception) : Option Name :=\n  match ex with\n  | Exception.internal id k =>\n    if id == autoBoundImplicitExceptionId then\n      some <| k.getName `localId `x\n    else\n      none\n  | _ => none", "start": [30, 1], "end": [37, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.throwAlreadyDeclaredUniverseLevel", "code": "def throwAlreadyDeclaredUniverseLevel [Monad m] [MonadError m] (u : Name) : m \u03b1 :=\n  throwError \"a universe level named '{u}' has already been declared\"", "start": [39, 1], "end": [40, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.throwAbortCommand", "code": "def throwAbortCommand {\u03b1 m} [MonadExcept Exception m] : m \u03b1 :=\n  throw <| Exception.internal abortCommandExceptionId", "start": [43, 1], "end": [44, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.throwAbortTerm", "code": "def throwAbortTerm {\u03b1 m} [MonadExcept Exception m] : m \u03b1 :=\n  throw <| Exception.internal abortTermExceptionId", "start": [47, 1], "end": [48, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.throwAbortTactic", "code": "def throwAbortTactic {\u03b1 m} [MonadExcept Exception m] : m \u03b1 :=\n  throw <| Exception.internal abortTacticExceptionId", "start": [51, 1], "end": [52, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.isAbortTacticException", "code": "def isAbortTacticException (ex : Exception) : Bool :=\n  match ex with\n  | Exception.internal id .. => id == abortTacticExceptionId\n  | _ => false", "start": [54, 1], "end": [57, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.isAbortExceptionId", "code": "def isAbortExceptionId (id : InternalExceptionId) : Bool :=\n  id == abortCommandExceptionId || id == abortTermExceptionId || id == abortTacticExceptionId", "start": [59, 1], "end": [60, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkMessageCore", "code": "def mkMessageCore (fileName : String) (fileMap : FileMap) (data : MessageData) (severity : MessageSeverity) (pos : String.Pos) (endPos : String.Pos) : Message :=\n  let pos := fileMap.toPosition pos\n  let endPos := fileMap.toPosition endPos\n  { fileName, pos, endPos, data, severity }", "start": [62, 1], "end": [65, 44], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Command.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Lean/Parser/Do.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.Term.quot", "code": "@[builtin_term_parser] def Term.quot := leading_parser\n  \"`(\" >> withoutPosition (incQuotDepth termParser) >> \")\"", "start": [12, 1], "end": [14, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.precheckedQuot", "code": "@[builtin_term_parser] def Term.precheckedQuot := leading_parser\n  \"`\" >> Term.quot", "start": [15, 1], "end": [16, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.quot", "code": "@[builtin_term_parser low] def quot := leading_parser\n  \"`(\" >> withoutPosition (incQuotDepth (many1Unbox commandParser)) >> \")\"", "start": [20, 1], "end": [29, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.terminationHintMany", "code": "def terminationHintMany (p : Parser) := leading_parser\n  atomic (lookahead (ident >> \" => \")) >>\n  many1Indent (group (ppLine >> ppIndent (ident >> \" => \" >> p >> optional \";\")))", "start": [38, 1], "end": [40, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.terminationHint1", "code": "def terminationHint1 (p : Parser) := leading_parser p", "start": [41, 1], "end": [41, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.terminationHint", "code": "def terminationHint (p : Parser) := terminationHintMany p <|> terminationHint1 p", "start": [42, 1], "end": [42, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.terminationByCore", "code": "def terminationByCore := leading_parser\n  ppDedent ppLine >> \"termination_by' \" >> terminationHint termParser", "start": [44, 1], "end": [45, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.decreasingBy", "code": "def decreasingBy := leading_parser\n  ppDedent ppLine >> \"decreasing_by \" >> terminationHint Tactic.tacticSeq", "start": [46, 1], "end": [47, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.terminationByElement", "code": "def terminationByElement   := leading_parser\n  ppLine >> (ident <|> Term.hole) >> many (ppSpace >> (ident <|> Term.hole)) >>\n  \" => \" >> termParser >> optional \";\"", "start": [49, 1], "end": [51, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.terminationBy", "code": "def terminationBy          := leading_parser\n  ppDedent ppLine >> \"termination_by\" >> many1Indent terminationByElement", "start": [52, 1], "end": [53, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.terminationSuffix", "code": "def terminationSuffix :=\n  optional (terminationBy <|> terminationByCore) >> optional decreasingBy", "start": [55, 1], "end": [56, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.moduleDoc", "code": "@[builtin_command_parser]\ndef moduleDoc := leading_parser ppDedent <|\n  \"", "start": [58, 1], "end": [60, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.namedPrio", "code": "def namedPrio := leading_parser\n  atomic (\" (\" >> nonReservedSymbol \"priority\") >> \" := \" >> withoutPosition priorityParser >> \")\"", "start": [62, 1], "end": [63, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.optNamedPrio", "code": "def optNamedPrio := optional namedPrio", "start": [64, 1], "end": [64, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.private", "code": "def \u00abprivate\u00bb        := leading_parser \"private \"", "start": [66, 1], "end": [66, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.protected", "code": "def \u00abprotected\u00bb      := leading_parser \"protected \"", "start": [67, 1], "end": [67, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.visibility", "code": "def visibility       := \u00abprivate\u00bb <|> \u00abprotected\u00bb", "start": [68, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.noncomputable", "code": "def \u00abnoncomputable\u00bb  := leading_parser \"noncomputable \"", "start": [69, 1], "end": [69, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.unsafe", "code": "def \u00abunsafe\u00bb         := leading_parser \"unsafe \"", "start": [70, 1], "end": [70, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.partial", "code": "def \u00abpartial\u00bb        := leading_parser \"partial \"", "start": [71, 1], "end": [71, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.nonrec", "code": "def \u00abnonrec\u00bb         := leading_parser \"nonrec \"", "start": [72, 1], "end": [72, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.declModifiers", "code": "def declModifiers (inline : Bool) := leading_parser\n  optional docComment >>\n  optional (Term.\u00abattributes\u00bb >> if inline then skip else ppDedent ppLine) >>\n  optional visibility >>\n  optional \u00abnoncomputable\u00bb >>\n  optional \u00abunsafe\u00bb >>\n  optional (\u00abpartial\u00bb <|> \u00abnonrec\u00bb)", "start": [74, 1], "end": [93, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.declId", "code": "def declId           := leading_parser\n  ident >> optional (\".{\" >> sepBy1 ident \", \" >> \"}\")", "start": [94, 1], "end": [96, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.declSig", "code": "def declSig          := leading_parser\n  many (ppSpace >> (Term.binderIdent <|> Term.bracketedBinder)) >> Term.typeSpec", "start": [97, 1], "end": [99, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.optDeclSig", "code": "def optDeclSig       := leading_parser\n  many (ppSpace >> (Term.binderIdent <|> Term.bracketedBinder)) >> Term.optType", "start": [100, 1], "end": [102, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.declValSimple", "code": "def declValSimple    := leading_parser\n  \" :=\" >> ppHardLineUnlessUngrouped >> termParser >> optional Term.whereDecls", "start": [103, 1], "end": [104, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.declValEqns", "code": "def declValEqns      := leading_parser\n  Term.matchAltsWhereDecls", "start": [105, 1], "end": [106, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.whereStructField", "code": "def whereStructField := leading_parser\n  Term.letDecl", "start": [107, 1], "end": [108, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.whereStructInst", "code": "def whereStructInst  := leading_parser\n  ppIndent ppSpace >> \"where\" >> sepByIndent (ppGroup whereStructField) \"; \" (allowTrailingSep := true) >>\n  optional Term.whereDecls", "start": [109, 1], "end": [111, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.declVal", "code": "def declVal          :=\n  withAntiquot (mkAntiquot \"declVal\" `Lean.Parser.Command.declVal (isPseudoKind := true)) <|\n    declValSimple <|> declValEqns <|> whereStructInst", "start": [112, 1], "end": [122, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.abbrev", "code": "def \u00ababbrev\u00bb         := leading_parser\n  \"abbrev \" >> declId >> ppIndent optDeclSig >> declVal >> terminationSuffix", "start": [123, 1], "end": [124, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.optDefDeriving", "code": "def optDefDeriving   :=\n  optional (ppDedent ppLine >> atomic (\"deriving \" >> notSymbol \"instance\") >> sepBy1 ident \", \")", "start": [125, 1], "end": [126, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.def", "code": "def \u00abdef\u00bb            := leading_parser\n  \"def \" >> declId >> ppIndent optDeclSig >> declVal >> optDefDeriving >> terminationSuffix", "start": [127, 1], "end": [128, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.theorem", "code": "def \u00abtheorem\u00bb        := leading_parser\n  \"theorem \" >> declId >> ppIndent declSig >> declVal >> terminationSuffix", "start": [129, 1], "end": [130, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.opaque", "code": "def \u00abopaque\u00bb         := leading_parser\n  \"opaque \" >> declId >> ppIndent declSig >> optional declValSimple", "start": [131, 1], "end": [132, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.instance", "code": "def \u00abinstance\u00bb       := leading_parser\n  Term.attrKind >> \"instance\" >> optNamedPrio >>\n  optional (ppSpace >> declId) >> ppIndent declSig >> declVal >> terminationSuffix", "start": [135, 1], "end": [137, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.axiom", "code": "def \u00abaxiom\u00bb          := leading_parser\n  \"axiom \" >> declId >> ppIndent declSig", "start": [138, 1], "end": [139, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.example", "code": "def \u00abexample\u00bb        := leading_parser\n  \"example\" >> ppIndent optDeclSig >> declVal", "start": [141, 1], "end": [142, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.ctor", "code": "def ctor             := leading_parser\n  atomic (optional docComment >> \"\\n| \") >>\n  ppGroup (declModifiers true >> rawIdent >> optDeclSig)", "start": [143, 1], "end": [145, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.derivingClasses", "code": "def derivingClasses  := sepBy1 (group (ident >> optional (\" with \" >> ppIndent Term.structInst))) \", \"", "start": [146, 1], "end": [146, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.optDeriving", "code": "def optDeriving      := leading_parser\n  optional (ppLine >> atomic (\"deriving \" >> notSymbol \"instance\") >> derivingClasses)", "start": [147, 1], "end": [148, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.computedField", "code": "def computedField    := leading_parser\n  declModifiers true >> ident >> \" : \" >> termParser >> Term.matchAlts", "start": [149, 1], "end": [150, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.computedFields", "code": "def computedFields   := leading_parser\n  \"with\" >> manyIndent (ppLine >> ppGroup computedField)", "start": [151, 1], "end": [152, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.inductive", "code": "def \u00abinductive\u00bb      := leading_parser\n  \"inductive \" >> declId >> ppIndent optDeclSig >> optional (symbol \" :=\" <|> \" where\") >>\n  many ctor >> optional (ppDedent ppLine >> computedFields) >> optDeriving", "start": [153, 1], "end": [173, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.classInductive", "code": "def classInductive   := leading_parser\n  atomic (group (symbol \"class \" >> \"inductive \")) >>\n  declId >> ppIndent optDeclSig >>\n  optional (symbol \" :=\" <|> \" where\") >> many ctor >> optDeriving", "start": [174, 1], "end": [177, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.structExplicitBinder", "code": "def structExplicitBinder := leading_parser\n  atomic (declModifiers true >> \"(\") >>\n  withoutPosition (many1 ident >> ppIndent optDeclSig >>\n    optional (Term.binderTactic <|> Term.binderDefault)) >> \")\"", "start": [178, 1], "end": [181, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.structImplicitBinder", "code": "def structImplicitBinder := leading_parser\n  atomic (declModifiers true >> \"{\") >> withoutPosition (many1 ident >> declSig) >> \"}\"", "start": [182, 1], "end": [183, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.structInstBinder", "code": "def structInstBinder     := leading_parser\n  atomic (declModifiers true >> \"[\") >> withoutPosition (many1 ident >> declSig) >> \"]\"", "start": [184, 1], "end": [185, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.structSimpleBinder", "code": "def structSimpleBinder   := leading_parser\n  atomic (declModifiers true >> ident) >> optDeclSig >>\n  optional (Term.binderTactic <|> Term.binderDefault)", "start": [186, 1], "end": [188, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.structFields", "code": "def structFields         := leading_parser\n  manyIndent <|\n    ppLine >> checkColGe >> ppGroup (\n      structExplicitBinder <|> structImplicitBinder <|>\n      structInstBinder <|> structSimpleBinder)", "start": [189, 1], "end": [193, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.structCtor", "code": "def structCtor           := leading_parser\n  atomic (ppIndent (declModifiers true >> ident >> \" :: \"))", "start": [194, 1], "end": [195, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.structureTk", "code": "def structureTk          := leading_parser\n  \"structure \"", "start": [196, 1], "end": [197, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.classTk", "code": "def classTk              := leading_parser\n  \"class \"", "start": [198, 1], "end": [199, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.extends", "code": "def \u00abextends\u00bb            := leading_parser\n  \" extends \" >> sepBy1 termParser \", \"", "start": [200, 1], "end": [201, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.structure", "code": "def \u00abstructure\u00bb          := leading_parser\n    (structureTk <|> classTk) >> declId >>\n    ppIndent (many (ppSpace >> Term.bracketedBinder) >> optional \u00abextends\u00bb >> Term.optType) >>\n    optional ((symbol \" := \" <|> \" where \") >> optional structCtor >> structFields) >>\n    optDeriving", "start": [202, 1], "end": [206, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.declaration", "code": "@[builtin_command_parser] def declaration := leading_parser\n  declModifiers false >>\n  (\u00ababbrev\u00bb <|> \u00abdef\u00bb <|> \u00abtheorem\u00bb <|> \u00abopaque\u00bb <|> \u00abinstance\u00bb <|> \u00abaxiom\u00bb <|> \u00abexample\u00bb <|>\n   \u00abinductive\u00bb <|> classInductive <|> \u00abstructure\u00bb)", "start": [207, 1], "end": [210, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.deriving", "code": "@[builtin_command_parser] def \u00abderiving\u00bb     := leading_parser\n  \"deriving \" >> \"instance \" >> derivingClasses >> \" for \" >> sepBy1 ident \", \"", "start": [211, 1], "end": [212, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.noncomputableSection", "code": "@[builtin_command_parser] def noncomputableSection := leading_parser\n  \"noncomputable \" >> \"section\" >> optional (ppSpace >> ident)", "start": [213, 1], "end": [214, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.section", "code": "@[builtin_command_parser] def \u00absection\u00bb      := leading_parser\n  \"section\" >> optional (ppSpace >> ident)", "start": [215, 1], "end": [216, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.namespace", "code": "@[builtin_command_parser] def \u00abnamespace\u00bb    := leading_parser\n  \"namespace \" >> ident", "start": [217, 1], "end": [218, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.end", "code": "@[builtin_command_parser] def \u00abend\u00bb          := leading_parser\n  \"end\" >> optional (ppSpace >> ident)", "start": [219, 1], "end": [220, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.variable", "code": "@[builtin_command_parser] def \u00abvariable\u00bb     := leading_parser\n  \"variable\" >> many1 (ppSpace >> Term.bracketedBinder)", "start": [221, 1], "end": [222, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.universe", "code": "@[builtin_command_parser] def \u00abuniverse\u00bb     := leading_parser\n  \"universe\" >> many1 (ppSpace >> ident)", "start": [223, 1], "end": [224, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.check", "code": "@[builtin_command_parser] def check          := leading_parser\n  \"#check \" >> termParser", "start": [225, 1], "end": [226, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.check_failure", "code": "@[builtin_command_parser] def check_failure  := leading_parser\n  \"#check_failure \" >> termParser", "start": [227, 1], "end": [228, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.reduce", "code": "@[builtin_command_parser] def reduce         := leading_parser\n  \"#reduce \" >> termParser", "start": [229, 1], "end": [230, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.eval", "code": "@[builtin_command_parser] def eval           := leading_parser\n  \"#eval \" >> termParser", "start": [231, 1], "end": [232, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.synth", "code": "@[builtin_command_parser] def synth          := leading_parser\n  \"#synth \" >> termParser", "start": [233, 1], "end": [234, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.exit", "code": "@[builtin_command_parser] def exit           := leading_parser\n  \"#exit\"", "start": [235, 1], "end": [236, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.print", "code": "@[builtin_command_parser] def print          := leading_parser\n  \"#print \" >> (ident <|> strLit)", "start": [237, 1], "end": [238, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.printAxioms", "code": "@[builtin_command_parser] def printAxioms    := leading_parser\n  \"#print \" >> nonReservedSymbol \"axioms \" >> ident", "start": [239, 1], "end": [240, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.init_quot", "code": "@[builtin_command_parser] def \u00abinit_quot\u00bb    := leading_parser\n  \"init_quot\"", "start": [241, 1], "end": [242, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.optionValue", "code": "def optionValue := nonReservedSymbol \"true\" <|> nonReservedSymbol \"false\" <|> strLit <|> numLit", "start": [243, 1], "end": [243, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.set_option", "code": "@[builtin_command_parser] def \u00abset_option\u00bb   := leading_parser\n  \"set_option \" >> ident >> ppSpace >> optionValue", "start": [244, 1], "end": [245, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.eraseAttr", "code": "def eraseAttr := leading_parser\n  \"-\" >> rawIdent", "start": [246, 1], "end": [247, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.attribute", "code": "@[builtin_command_parser] def \u00abattribute\u00bb    := leading_parser\n  \"attribute \" >> \"[\" >>\n    withoutPosition (sepBy1 (eraseAttr <|> Term.attrInstance) \", \") >>\n  \"]\" >> many1 (ppSpace >> ident)", "start": [248, 1], "end": [251, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.export", "code": "@[builtin_command_parser] def \u00abexport\u00bb       := leading_parser\n  \"export \" >> ident >> \" (\" >> many1 ident >> \")\"", "start": [252, 1], "end": [253, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.import", "code": "@[builtin_command_parser] def \u00abimport\u00bb       := leading_parser\n  \"import\"", "start": [254, 1], "end": [255, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.openHiding", "code": "def openHiding       := leading_parser\n  ppSpace >> atomic (ident >> \" hiding\") >> many1 (ppSpace >> checkColGt >> ident)", "start": [256, 1], "end": [257, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.openRenamingItem", "code": "def openRenamingItem := leading_parser\n  ident >> unicodeSymbol \" \u2192 \" \" -> \" >> checkColGt >> ident", "start": [258, 1], "end": [259, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.openRenaming", "code": "def openRenaming     := leading_parser\n  ppSpace >> atomic (ident >> \" renaming \") >> sepBy1 openRenamingItem \", \"", "start": [260, 1], "end": [261, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.openOnly", "code": "def openOnly         := leading_parser\n  ppSpace >> atomic (ident >> \" (\") >> many1 ident >> \")\"", "start": [262, 1], "end": [263, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.openSimple", "code": "def openSimple       := leading_parser\n  many1 (ppSpace >> checkColGt >> ident)", "start": [264, 1], "end": [265, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.openScoped", "code": "def openScoped       := leading_parser\n  \" scoped\" >> many1 (ppSpace >> checkColGt >> ident)", "start": [266, 1], "end": [267, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.openDecl", "code": "def openDecl         :=\n  withAntiquot (mkAntiquot \"openDecl\" `Lean.Parser.Command.openDecl (isPseudoKind := true)) <|\n    openHiding <|> openRenaming <|> openOnly <|> openSimple <|> openScoped", "start": [268, 1], "end": [271, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.open", "code": "@[builtin_command_parser] def \u00abopen\u00bb    := leading_parser\n  withPosition (\"open\" >> openDecl)", "start": [272, 1], "end": [273, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.mutual", "code": "@[builtin_command_parser] def \u00abmutual\u00bb := leading_parser\n  \"mutual\" >> many1 (ppLine >> notSymbol \"end\" >> commandParser) >>\n  ppDedent (ppLine >> \"end\") >> terminationSuffix", "start": [275, 1], "end": [277, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.initializeKeyword", "code": "def initializeKeyword := leading_parser\n  \"initialize \" <|> \"builtin_initialize \"", "start": [278, 1], "end": [279, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.initialize", "code": "@[builtin_command_parser] def \u00abinitialize\u00bb := leading_parser\n  declModifiers false >> initializeKeyword >>\n  optional (atomic (ident >> Term.typeSpec >> ppSpace >> Term.leftArrow)) >> Term.doSeq", "start": [280, 1], "end": [282, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.in", "code": "@[builtin_command_parser] def \u00abin\u00bb  := trailing_parser\n  withOpen (ppDedent (\" in \" >> commandParser))", "start": [284, 1], "end": [285, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.addDocString", "code": "@[builtin_command_parser] def addDocString := leading_parser\n  docComment >> \"add_decl_doc \" >> ident", "start": [287, 1], "end": [288, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.genInjectiveTheorems", "code": "@[builtin_command_parser] def genInjectiveTheorems := leading_parser\n  \"gen_injective_theorems% \" >> ident", "start": [290, 1], "end": [295, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.eoi", "code": "@[run_builtin_parser_attribute_hooks] def eoi : Parser := leading_parser \"\"", "start": [297, 1], "end": [298, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.declModifiersF", "code": "@[run_builtin_parser_attribute_hooks, inherit_doc declModifiers]\nabbrev declModifiersF := declModifiers false", "start": [303, 1], "end": [304, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.declModifiersT", "code": "@[run_builtin_parser_attribute_hooks, inherit_doc declModifiers]\nabbrev declModifiersT := declModifiers true", "start": [305, 1], "end": [306, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.open", "code": "@[builtin_term_parser] def \u00abopen\u00bb := leading_parser:leadPrec\n  \"open\" >> Command.openDecl >> withOpenDecl (\" in \" >> termParser)", "start": [321, 1], "end": [326, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Term.set_option", "code": "@[builtin_term_parser] def \u00abset_option\u00bb := leading_parser:leadPrec\n  \"set_option \" >> ident >> ppSpace >> Command.optionValue >> \" in \" >> termParser", "start": [328, 1], "end": [333, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.open", "code": "@[builtin_tactic_parser] def \u00abopen\u00bb := leading_parser:leadPrec\n  \"open \" >> Command.openDecl >> withOpenDecl (\" in \" >> tacticSeq)", "start": [337, 1], "end": [340, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.set_option", "code": "@[builtin_tactic_parser] def \u00abset_option\u00bb := leading_parser:leadPrec\n  \"set_option \" >> ident >> ppSpace >> Command.optionValue >> \" in \" >> tacticSeq", "start": [342, 1], "end": [345, 82], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/SynthInstance.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/AbstractMVars.lean", "lake-packages/lean4/src/lean/Lean/Util/Profile.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Instances.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "lake-packages/lean4/src/lean/Lean/Meta/WHNF.lean"], "premises": [{"full_name": "Lean.Meta.SynthInstance.getMaxHeartbeats", "code": "def getMaxHeartbeats (opts : Options) : Nat :=\n  synthInstance.maxHeartbeats.get opts * 1000", "start": [29, 1], "end": [30, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.Instance", "code": "structure Instance where\n  val : Expr\n  synthOrder : Array Nat\n  deriving Inhabited", "start": [32, 1], "end": [35, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.GeneratorNode", "code": "structure GeneratorNode where\n  mvar            : Expr\n  key             : Expr\n  mctx            : MetavarContext\n  instances       : Array Instance\n  currInstanceIdx : Nat\n  deriving Inhabited", "start": [37, 1], "end": [43, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.ConsumerNode", "code": "structure ConsumerNode where\n  mvar     : Expr\n  key      : Expr\n  mctx     : MetavarContext\n  subgoals : List Expr\n  size     : Nat deriving Inhabited", "start": [45, 1], "end": [51, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.Waiter", "code": "inductive Waiter where\n  | consumerNode : ConsumerNode \u2192 Waiter\n  | root         : Waiter", "start": [53, 1], "end": [55, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.Waiter.isRoot", "code": "def Waiter.isRoot : Waiter \u2192 Bool\n  | Waiter.consumerNode _ => false\n  | Waiter.root           => true", "start": [57, 1], "end": [59, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.MkTableKey.State", "code": "structure State where\n  nextIdx : Nat := 0\n  lmap    : HashMap LMVarId Level := {}\n  emap    : HashMap MVarId Expr := {}\n  mctx    : MetavarContext", "start": [83, 1], "end": [87, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.MkTableKey.M", "code": "abbrev M := StateM State", "start": [89, 1], "end": [89, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.MkTableKey.normLevel", "code": "partial def normLevel (u : Level) : M Level := do\n  if !u.hasMVar then\n    return u\n  else match u with\n    | Level.succ v      => return u.updateSucc! (\u2190 normLevel v)\n    | Level.max v w     => return u.updateMax! (\u2190 normLevel v) (\u2190 normLevel w)\n    | Level.imax v w    => return u.updateIMax! (\u2190 normLevel v) (\u2190 normLevel w)\n    | Level.mvar mvarId =>\n      if (\u2190 getMCtx).getLevelDepth mvarId != (\u2190 getMCtx).depth then\n        return u\n      else\n        let s \u2190 get\n        match (\u2190 get).lmap.find? mvarId with\n        | some u' => pure u'\n        | none    =>\n          let u' := mkLevelParam <| Name.mkNum `_tc s.nextIdx\n          modify fun s => { s with nextIdx := s.nextIdx + 1, lmap := s.lmap.insert mvarId u' }\n          return u'\n    | u => return u", "start": [96, 1], "end": [114, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.MkTableKey.normExpr", "code": "partial def normExpr (e : Expr) : M Expr := do\n  if !e.hasMVar then\n    pure e\n  else match e with\n    | Expr.const _ us      => return e.updateConst! (\u2190 us.mapM normLevel)\n    | Expr.sort u          => return e.updateSort! (\u2190 normLevel u)\n    | Expr.app f a         => return e.updateApp! (\u2190 normExpr f) (\u2190 normExpr a)\n    | Expr.letE _ t v b _  => return e.updateLet! (\u2190 normExpr t) (\u2190 normExpr v) (\u2190 normExpr b)\n    | Expr.forallE _ d b _ => return e.updateForallE! (\u2190 normExpr d) (\u2190 normExpr b)\n    | Expr.lam _ d b _     => return e.updateLambdaE! (\u2190 normExpr d) (\u2190 normExpr b)\n    | Expr.mdata _ b       => return e.updateMData! (\u2190 normExpr b)\n    | Expr.proj _ _ b      => return e.updateProj! (\u2190 normExpr b)\n    | Expr.mvar mvarId     =>\n      if !(\u2190 mvarId.isAssignable) then\n        return e\n      else\n        let s \u2190 get\n        match s.emap.find? mvarId with\n        | some e' => pure e'\n        | none    => do\n          let e' := mkFVar { name := Name.mkNum `_tc s.nextIdx }\n          modify fun s => { s with nextIdx := s.nextIdx + 1, emap := s.emap.insert mvarId e' }\n          return e'\n    | _ => return e", "start": [116, 1], "end": [139, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.mkTableKey", "code": "def mkTableKey [Monad m] [MonadMCtx m] (e : Expr) : m Expr := do\n  let (r, s) := MkTableKey.normExpr e |>.run { mctx := (\u2190 getMCtx) }\n  setMCtx s.mctx\n  return r", "start": [143, 1], "end": [147, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.Answer", "code": "structure Answer where\n  result     : AbstractMVarsResult\n  resultType : Expr\n  size       : Nat\n  deriving Inhabited", "start": [149, 1], "end": [153, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.TableEntry", "code": "structure TableEntry where\n  waiters : Array Waiter\n  answers : Array Answer := #[]", "start": [155, 1], "end": [157, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.Context", "code": "structure Context where\n  maxResultSize : Nat\n  maxHeartbeats : Nat", "start": [159, 1], "end": [161, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.State", "code": "structure State where\n  result?        : Option AbstractMVarsResult    := none\n  generatorStack : Array GeneratorNode           := #[]\n  resumeStack    : Array (ConsumerNode \u00d7 Answer) := #[]\n  tableEntries   : HashMap Expr TableEntry       := {}", "start": [163, 1], "end": [174, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.SynthM", "code": "abbrev SynthM := ReaderT Context $ StateRefT State MetaM", "start": [176, 1], "end": [176, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.checkMaxHeartbeats", "code": "def checkMaxHeartbeats : SynthM Unit := do\n  Core.checkMaxHeartbeatsCore \"typeclass\" `synthInstance.maxHeartbeats (\u2190 read).maxHeartbeats", "start": [178, 1], "end": [179, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.mapMetaM", "code": "@[inline] def mapMetaM (f : forall {\u03b1}, MetaM \u03b1 \u2192 MetaM \u03b1) {\u03b1} : SynthM \u03b1 \u2192 SynthM \u03b1 :=\n  monadMap @f", "start": [181, 1], "end": [182, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.getInstances", "code": "def getInstances (type : Expr) : MetaM (Array Instance) := do\n  let localInstances \u2190 getLocalInstances\n  forallTelescopeReducing type fun _ type => do\n    let className? \u2190 isClass? type\n    match className? with\n    | none   => throwError \"type class instance expected{indentExpr type}\"\n    | some className =>\n      let globalInstances \u2190 getGlobalInstancesIndex\n      let result \u2190 globalInstances.getUnify type\n      let result := result.insertionSort fun e\u2081 e\u2082 => e\u2081.priority < e\u2082.priority\n      let erasedInstances \u2190 getErasedInstances\n      let mut result \u2190 result.filterMapM fun e => match e.val with\n        | Expr.const constName us =>\n          if erasedInstances.contains constName then\n            return none\n          else\n            return some {\n              val := e.val.updateConst! (\u2190 us.mapM (fun _ => mkFreshLevelMVar))\n              synthOrder := e.synthOrder\n            }\n        | _ => panic! \"global instance is not a constant\"\n      for linst in localInstances do\n        if linst.className == className then\n          let synthOrder \u2190 forallTelescopeReducing (\u2190 inferType linst.fvar) fun xs _ => do\n            if xs.isEmpty then return #[]\n            let mut order := #[]\n            for i in [:xs.size], x in xs do\n              if (\u2190 getFVarLocalDecl x).binderInfo == .instImplicit then\n                order := order.push i\n            return order\n          result := result.push { val := linst.fvar, synthOrder }\n      trace[Meta.synthInstance.instances] result.map (\u00b7.val)\n      return result", "start": [187, 1], "end": [223, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.mkGeneratorNode?", "code": "def mkGeneratorNode? (key mvar : Expr) : MetaM (Option GeneratorNode) := do\n  let mvarType  \u2190 inferType mvar\n  let mvarType  \u2190 instantiateMVars mvarType\n  let instances \u2190 getInstances mvarType\n  if instances.isEmpty then\n    return none\n  else\n    let mctx \u2190 getMCtx\n    return some {\n      mvar, key, mctx, instances\n      currInstanceIdx := instances.size\n    }", "start": [225, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.newSubgoal", "code": "def newSubgoal (mctx : MetavarContext) (key : Expr) (mvar : Expr) (waiter : Waiter) : SynthM Unit :=\n  withMCtx mctx do withTraceNode' `Meta.synthInstance do\n    match (\u2190 mkGeneratorNode? key mvar) with\n    | none      => pure ((), m!\"no instances for {key}\")\n    | some node =>\n      let entry : TableEntry := { waiters := #[waiter] }\n      modify fun s =>\n       { s with\n         generatorStack := s.generatorStack.push node\n         tableEntries   := s.tableEntries.insert key entry }\n      pure ((), m!\"new goal {key}\")", "start": [238, 1], "end": [251, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.findEntry?", "code": "def findEntry? (key : Expr) : SynthM (Option TableEntry) := do\n  return (\u2190 get).tableEntries.find? key", "start": [253, 1], "end": [254, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.getEntry", "code": "def getEntry (key : Expr) : SynthM TableEntry := do\n  match (\u2190 findEntry? key) with\n  | none       => panic! \"invalid key at synthInstance\"\n  | some entry => pure entry", "start": [256, 1], "end": [259, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.mkTableKeyFor", "code": "def mkTableKeyFor (mctx : MetavarContext) (mvar : Expr) : SynthM Expr :=\n  withMCtx mctx do\n    let mvarType \u2190 inferType mvar\n    let mvarType \u2190 instantiateMVars mvarType\n    mkTableKey mvarType", "start": [261, 1], "end": [270, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.SubgoalsResult", "code": "structure SubgoalsResult where\n  subgoals     : List Expr\n  instVal      : Expr\n  instTypeBody : Expr", "start": [272, 1], "end": [281, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.getSubgoals", "code": "def getSubgoals (lctx : LocalContext) (localInsts : LocalInstances) (xs : Array Expr) (inst : Instance) : MetaM SubgoalsResult := do\n  let mut instVal := inst.val\n  let mut instType \u2190 inferType instVal\n  let mut mvars := #[]\n  let mut subst := #[]\n  repeat do\n    if let .forallE _ d b _ := instType then\n      let d := d.instantiateRev subst\n      let mvar \u2190 mkFreshExprMVarAt lctx localInsts (\u2190 mkForallFVars xs d)\n      subst := subst.push (mkAppN mvar xs)\n      instVal := mkApp instVal (mkAppN mvar xs)\n      instType := b\n      mvars := mvars.push mvar\n    else\n      instType \u2190 whnf (instType.instantiateRev subst)\n      instVal := instVal.instantiateRev subst\n      subst := #[]\n      unless instType.isForall do break\n  return {\n    instVal := instVal.instantiateRev subst\n    instTypeBody := instType.instantiateRev subst\n    subgoals := inst.synthOrder.map (mvars[\u00b7]!) |>.toList\n  }", "start": [283, 1], "end": [320, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.tryResolve", "code": "def tryResolve (mvar : Expr) (inst : Instance) : MetaM (Option (MetavarContext \u00d7 List Expr)) := do\n  let mvarType   \u2190 inferType mvar\n  let lctx       \u2190 getLCtx\n  let localInsts \u2190 getLocalInstances\n  forallTelescopeReducing mvarType fun xs mvarTypeBody => do\n    let \u27e8subgoals, instVal, instTypeBody\u27e9 \u2190 getSubgoals lctx localInsts xs inst\n    withTraceNode `Meta.synthInstance.tryResolve (withMCtx (\u2190 getMCtx) do\n        return m!\"{exceptOptionEmoji \u00b7} {\u2190 instantiateMVars mvarTypeBody} \u225f {\u2190 instantiateMVars instTypeBody}\") do\n    if (\u2190 isDefEq mvarTypeBody instTypeBody) then\n      let instVal \u2190 mkLambdaFVars xs instVal\n      if (\u2190 isDefEq mvar instVal) then\n        return some ((\u2190 getMCtx), subgoals)\n    return none", "start": [322, 1], "end": [339, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.tryAnswer", "code": "def tryAnswer (mctx : MetavarContext) (mvar : Expr) (answer : Answer) : SynthM (Option MetavarContext) :=\n  withMCtx mctx do\n    let (_, _, val) \u2190 openAbstractMVarsResult answer.result\n    if (\u2190 isDefEq mvar val) then\n      return some (\u2190 getMCtx)\n    else\n      return none", "start": [341, 1], "end": [350, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.wakeUp", "code": "def wakeUp (answer : Answer) : Waiter \u2192 SynthM Unit\n  | Waiter.root               => do\n    \n    if answer.result.numMVars == 0 then\n      modify fun s => { s with result? := answer.result }\n    else\n      let (_, _, answerExpr) \u2190 openAbstractMVarsResult answer.result\n      trace[Meta.synthInstance] \"skip answer containing metavariables {answerExpr}\"\n  | Waiter.consumerNode cNode =>\n    modify fun s => { s with resumeStack := s.resumeStack.push (cNode, answer) }", "start": [352, 1], "end": [365, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.isNewAnswer", "code": "def isNewAnswer (oldAnswers : Array Answer) (answer : Answer) : Bool :=\n  oldAnswers.all fun oldAnswer =>\n    oldAnswer.resultType != answer.resultType", "start": [367, 1], "end": [371, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.mkAnswer", "code": "private def mkAnswer (cNode : ConsumerNode) : MetaM Answer :=\n  withMCtx cNode.mctx do\n    let val \u2190 instantiateMVars cNode.mvar\n    trace[Meta.synthInstance.newAnswer] \"size: {cNode.size}, val: {val}\"\n    let result \u2190 abstractMVars val let resultType \u2190 inferType result.expr\n    return { result, resultType, size := cNode.size + 1 }", "start": [373, 1], "end": [379, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.addAnswer", "code": "def addAnswer (cNode : ConsumerNode) : SynthM Unit := do\n  withMCtx cNode.mctx do\n  if cNode.size \u2265 (\u2190 read).maxResultSize then\n      trace[Meta.synthInstance.answer] \"{crossEmoji} {\u2190 instantiateMVars (\u2190 inferType cNode.mvar)}{Format.line}(size: {cNode.size} \u2265 {(\u2190 read).maxResultSize})\"\n  else\n    withTraceNode `Meta.synthInstance.answer\n      (fun _ => return m!\"{checkEmoji} {\u2190 instantiateMVars (\u2190 inferType cNode.mvar)}\") do\n    let answer \u2190 mkAnswer cNode\n    let key := cNode.key\n    let entry \u2190 getEntry key\n    if isNewAnswer entry.answers answer then\n      let newEntry := { entry with answers := entry.answers.push answer }\n      modify fun s => { s with tableEntries := s.tableEntries.insert key newEntry }\n      entry.waiters.forM (wakeUp answer)", "start": [381, 1], "end": [399, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.hasUnusedArguments", "code": "private def hasUnusedArguments : Expr \u2192 Bool\n  | Expr.forallE _ _ b _ => !b.hasLooseBVar 0 || hasUnusedArguments b\n  | _ => false", "start": [401, 1], "end": [408, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.removeUnusedArguments?", "code": "private def removeUnusedArguments? (mctx : MetavarContext) (mvar : Expr) : MetaM (Option (Expr \u00d7 Expr)) :=\n  withMCtx mctx do\n    let mvarType \u2190 instantiateMVars (\u2190 inferType mvar)\n    if !hasUnusedArguments mvarType then\n      return none\n    else\n      forallTelescope mvarType fun xs body => do\n        let ys \u2190 xs.foldrM (init := []) fun x ys => do\n          if body.containsFVar x.fvarId! then\n            return x :: ys\n          else if (\u2190 ys.anyM fun y => return (\u2190 inferType y).containsFVar x.fvarId!) then\n            return x :: ys\n          else\n            return ys\n        let ys := ys.toArray\n        let mvarType' \u2190 mkForallFVars ys body\n        withLocalDeclD `redf mvarType' fun f => do\n          let transformer \u2190 mkLambdaFVars #[f] (\u2190 mkLambdaFVars xs (mkAppN f ys))\n          trace[Meta.synthInstance.unusedArgs] \"{mvarType}\\nhas unused arguments, reduced type{indentExpr mvarType'}\\nTransformer{indentExpr transformer}\"\n          return some (mvarType', transformer)", "start": [410, 1], "end": [451, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.consume", "code": "def consume (cNode : ConsumerNode) : SynthM Unit := do\n  \n  let cNode := { cNode with\n    subgoals := \u2190 withMCtx cNode.mctx do\n      cNode.subgoals.filterM (not <$> \u00b7.mvarId!.isAssigned)\n  }\n  match cNode.subgoals with\n  | []      => addAnswer cNode\n  | mvar::_ =>\n     let waiter := Waiter.consumerNode cNode\n     let key \u2190 mkTableKeyFor cNode.mctx mvar\n     let entry? \u2190 findEntry? key\n     match entry? with\n     | none       =>\n       match (\u2190 removeUnusedArguments? cNode.mctx mvar) with\n       | none => newSubgoal cNode.mctx key mvar waiter\n       | some (mvarType', transformer) =>\n         let key' \u2190 withMCtx cNode.mctx <| mkTableKey mvarType'\n         match (\u2190 findEntry? key') with\n         | none =>\n           let (mctx', mvar') \u2190 withMCtx cNode.mctx do\n             let mvar' \u2190 mkFreshExprMVar mvarType'\n             return (\u2190 getMCtx, mvar')\n           newSubgoal mctx' key' mvar' (Waiter.consumerNode { cNode with mctx := mctx', subgoals := mvar'::cNode.subgoals })\n         | some entry' =>\n           let answers' \u2190 entry'.answers.mapM fun a => withMCtx cNode.mctx do\n             let trAnswr := Expr.betaRev transformer #[\u2190 instantiateMVars a.result.expr]\n             let trAnswrType \u2190 inferType trAnswr\n             pure { a with result.expr := trAnswr, resultType := trAnswrType }\n           modify fun s =>\n             { s with\n               resumeStack  := answers'.foldl (fun s answer => s.push (cNode, answer)) s.resumeStack,\n               tableEntries := s.tableEntries.insert key' { entry' with waiters := entry'.waiters.push waiter } }\n     | some entry => modify fun s =>\n       { s with\n         resumeStack  := entry.answers.foldl (fun s answer => s.push (cNode, answer)) s.resumeStack,\n         tableEntries := s.tableEntries.insert key { entry with waiters := entry.waiters.push waiter } }", "start": [453, 1], "end": [501, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.getTop", "code": "def getTop : SynthM GeneratorNode :=\n  return (\u2190 get).generatorStack.back", "start": [503, 1], "end": [504, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.modifyTop", "code": "@[inline] def modifyTop (f : GeneratorNode \u2192 GeneratorNode) : SynthM Unit :=\n  modify fun s => { s with generatorStack := s.generatorStack.modify (s.generatorStack.size - 1) f }", "start": [506, 1], "end": [507, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.generate", "code": "def generate : SynthM Unit := do\n  let gNode \u2190 getTop\n  if gNode.currInstanceIdx == 0  then\n    modify fun s => { s with generatorStack := s.generatorStack.pop }\n  else\n    let key  := gNode.key\n    let idx  := gNode.currInstanceIdx - 1\n    let inst := gNode.instances.get! idx\n    let mctx := gNode.mctx\n    let mvar := gNode.mvar\n    discard do withMCtx mctx do\n      withTraceNode `Meta.synthInstance\n        (return m!\"{exceptOptionEmoji \u00b7} apply {inst.val} to {\u2190 instantiateMVars (\u2190 inferType mvar)}\") do\n      modifyTop fun gNode => { gNode with currInstanceIdx := idx }\n      if let some (mctx, subgoals) \u2190 tryResolve mvar inst then\n        consume { key, mvar, subgoals, mctx, size := 0 }\n        return some ()\n      return none", "start": [509, 1], "end": [527, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.getNextToResume", "code": "def getNextToResume : SynthM (ConsumerNode \u00d7 Answer) := do\n  let r := (\u2190 get).resumeStack.back\n  modify fun s => { s with resumeStack := s.resumeStack.pop }\n  return r", "start": [529, 1], "end": [532, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.resume", "code": "def resume : SynthM Unit := do\n  let (cNode, answer) \u2190 getNextToResume\n  match cNode.subgoals with\n  | []         => panic! \"resume found no remaining subgoals\"\n  | mvar::rest =>\n    match (\u2190 tryAnswer cNode.mctx mvar answer) with\n    | none      => return ()\n    | some mctx =>\n      withMCtx mctx do\n      let goal    \u2190 inferType cNode.mvar\n      let subgoal \u2190 inferType mvar\n      withTraceNode `Meta.synthInstance.resume\n        (fun _ => withMCtx cNode.mctx do\n          return m!\"propagating {\u2190 instantiateMVars answer.resultType} to subgoal {\u2190 instantiateMVars subgoal} of {\u2190 instantiateMVars goal}\") do\n      trace[Meta.synthInstance.resume] \"size: {cNode.size + answer.size}\"\n      consume { key := cNode.key, mvar := cNode.mvar, subgoals := rest, mctx, size := cNode.size + answer.size }", "start": [534, 1], "end": [552, 113], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.step", "code": "def step : SynthM Bool := do\n  checkMaxHeartbeats\n  let s \u2190 get\n  if !s.resumeStack.isEmpty then\n    resume\n    return true\n  else if !s.generatorStack.isEmpty then\n    generate\n    return true\n  else\n    return false", "start": [554, 1], "end": [564, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.getResult", "code": "def getResult : SynthM (Option AbstractMVarsResult) :=\n  return (\u2190 get).result?", "start": [566, 1], "end": [567, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.synth", "code": "partial def synth : SynthM (Option AbstractMVarsResult) := do\n  if (\u2190 step) then\n    match (\u2190 getResult) with\n    | none        => synth\n    | some result => return result\n  else\n    return none", "start": [569, 1], "end": [575, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SynthInstance.main", "code": "def main (type : Expr) (maxResultSize : Nat) : MetaM (Option AbstractMVarsResult) :=\n  withCurrHeartbeats do\n     let mvar \u2190 mkFreshExprMVar type\n     let key  \u2190 mkTableKey type\n     let action : SynthM (Option AbstractMVarsResult) := do\n       newSubgoal (\u2190 getMCtx) key mvar Waiter.root\n       synth\n     try\n       action.run { maxResultSize := maxResultSize, maxHeartbeats := getMaxHeartbeats (\u2190 getOptions) } |>.run' {}\n     catch ex =>\n       if ex.isMaxHeartbeat then\n         throwError \"failed to synthesize{indentExpr type}\\n{ex.toMessageData}\"\n       else\n         throw ex", "start": [577, 1], "end": [590, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.preprocess", "code": "private def preprocess (type : Expr) : MetaM Expr :=\n  forallTelescopeReducing type fun xs type => do\n    let type \u2190 whnf type\n    mkForallFVars xs type", "start": [607, 1], "end": [610, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.preprocessLevels", "code": "private def preprocessLevels (us : List Level) : MetaM (List Level \u00d7 Bool) := do\n  let mut r := #[]\n  let mut modified := false\n  for u in us do\n    let u \u2190 instantiateLevelMVars u\n    if u.hasMVar then\n      r := r.push (\u2190 mkFreshLevelMVar)\n      modified := true\n    else\n      r := r.push u\n  return (r.toList, modified)", "start": [612, 1], "end": [622, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.preprocessArgs", "code": "private partial def preprocessArgs (type : Expr) (i : Nat) (args : Array Expr) (outParamsPos : Array Nat) : MetaM (Array Expr) := do\n  if h : i < args.size then\n    let type \u2190 whnf type\n    match type with\n    | .forallE _ d b _ => do\n      let arg := args.get \u27e8i, h\u27e9\n      \n      let arg \u2190 if outParamsPos.contains i then mkFreshExprMVar d else pure arg\n      let args := args.set \u27e8i, h\u27e9 arg\n      preprocessArgs (b.instantiate1 arg) (i+1) args outParamsPos\n    | _ =>\n      throwError \"type class resolution failed, insufficient number of arguments\" else\n    return args", "start": [624, 1], "end": [640, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.preprocessOutParam", "code": "private def preprocessOutParam (type : Expr) : MetaM Expr :=\n  forallTelescope type fun xs typeBody => do\n    match typeBody.getAppFn with\n    | c@(Expr.const declName _) =>\n      let env \u2190 getEnv\n      if let some outParamsPos := getOutParamPositions? env declName then\n        unless outParamsPos.isEmpty do\n          let args := typeBody.getAppArgs\n          let cType \u2190 inferType c\n          let args \u2190 preprocessArgs cType 0 args outParamsPos\n          return (\u2190 mkForallFVars xs (mkAppN c args))\n      return type\n    | _ =>\n      return type", "start": [642, 1], "end": [655, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.synthInstance?", "code": "def synthInstance? (type : Expr) (maxResultSize? : Option Nat := none) : MetaM (Option Expr) := do profileitM Exception \"typeclass inference\" (\u2190 getOptions) (decl := type.getAppFn.constName?.getD .anonymous) do\n  let opts \u2190 getOptions\n  let maxResultSize := maxResultSize?.getD (synthInstance.maxSize.get opts)\n  withTraceNode `Meta.synthInstance\n    (return m!\"{exceptOptionEmoji \u00b7} {\u2190 instantiateMVars type}\") do\n  withConfig (fun config => { config with isDefEqStuckEx := true, transparency := TransparencyMode.instances,\n                                          foApprox := true, ctxApprox := true, constApprox := false }) do\n    let localInsts \u2190 getLocalInstances\n    let type \u2190 instantiateMVars type\n    let type \u2190 preprocess type\n    let s \u2190 get\n    let rec assignOutParams (result : Expr) : MetaM Bool := do\n      let resultType \u2190 inferType result\n      \n      let defEq \u2190 withDefault <| withAssignableSyntheticOpaque <| isDefEq type resultType\n      unless defEq do\n        trace[Meta.synthInstance] \"{crossEmoji} result type{indentExpr resultType}\\nis not definitionally equal to{indentExpr type}\"\n      return defEq\n    match s.cache.synthInstance.find? (localInsts, type) with\n    | some result =>\n      trace[Meta.synthInstance] \"result {result} (cached)\"\n      if let some inst := result then\n        unless (\u2190 assignOutParams inst) do\n          return none\n      pure result\n    | none        =>\n      let result? \u2190 withNewMCtxDepth (allowLevelAssignments := true) do\n        let normType \u2190 preprocessOutParam type\n        SynthInstance.main normType maxResultSize\n      let result? \u2190 match result? with\n        | none        => pure none\n        | some result => do\n          let (_, _, result) \u2190 openAbstractMVarsResult result\n          trace[Meta.synthInstance] \"result {result}\"\n          if (\u2190 assignOutParams result) then\n            let result \u2190 instantiateMVars result\n            \n            check result\n            pure (some result)\n          else\n            pure none\n      modify fun s => { s with cache.synthInstance := s.cache.synthInstance.insert (localInsts, type) result? }\n      pure result?", "start": [662, 1], "end": [730, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.trySynthInstance", "code": "def trySynthInstance (type : Expr) (maxResultSize? : Option Nat := none) : MetaM (LOption Expr) := do\n  catchInternalId isDefEqStuckExceptionId\n    (toLOptionM <| synthInstance? type maxResultSize?)\n    (fun _ => pure LOption.undef)", "start": [732, 1], "end": [738, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.synthInstance", "code": "def synthInstance (type : Expr) (maxResultSize? : Option Nat := none) : MetaM Expr :=\n  catchInternalId isDefEqStuckExceptionId\n    (do\n      let result? \u2190 synthInstance? type maxResultSize?\n      match result? with\n      | some result => pure result\n      | none        => throwError \"failed to synthesize{indentExpr type}\")\n    (fun _ => throwError \"failed to synthesize{indentExpr type}\")", "start": [740, 1], "end": [747, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.synthPendingImp", "code": "@[export lean_synth_pending]\nprivate def synthPendingImp (mvarId : MVarId) : MetaM Bool := withIncRecDepth <| mvarId.withContext do\n  let mvarDecl \u2190 mvarId.getDecl\n  match mvarDecl.kind with\n  | MetavarKind.syntheticOpaque =>\n    return false\n  | _ =>\n    \n    match (\u2190 isClass? mvarDecl.type) with\n    | none   =>\n      return false\n    | some _ =>\n      \n      if (\u2190 read).synthPendingDepth > 1 then\n        trace[Meta.synthPending] \"too many nested synthPending invocations\"\n        return false\n      else\n        withReader (fun ctx => { ctx with synthPendingDepth := ctx.synthPendingDepth + 1 }) do\n          trace[Meta.synthPending] \"synthPending {mkMVar mvarId}\"\n          let val? \u2190 catchInternalId isDefEqStuckExceptionId (synthInstance? mvarDecl.type (maxResultSize? := none)) (fun _ => pure none)\n          match val? with\n          | none     =>\n            return false\n          | some val =>\n            if (\u2190 mvarId.isAssigned) then\n              return false\n            else\n              mvarId.assign val\n              return true", "start": [749, 1], "end": [778, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/DecLevel.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.DecLevelContext", "code": "structure DecLevelContext where\n  \n  canAssignMVars : Bool := true", "start": [11, 1], "end": [16, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.decAux?", "code": "private partial def decAux? : Level \u2192 ReaderT DecLevelContext MetaM (Option Level)\n  | Level.zero        => return none\n  | Level.param _     => return none\n  | Level.mvar mvarId => do\n    match (\u2190 getLevelMVarAssignment? mvarId) with\n    | some u => decAux? u\n    | none   =>\n      if (\u2190 mvarId.isReadOnly) || !(\u2190 read).canAssignMVars then\n        return none\n      else\n        let u \u2190 mkFreshLevelMVar\n        trace[Meta.isLevelDefEq.step] \"decAux?, {mkLevelMVar mvarId} := {mkLevelSucc u}\"\n        assignLevelMVar mvarId (mkLevelSucc u)\n        return u\n  | Level.succ u  => return u\n  | u =>\n    let processMax (u v : Level) : ReaderT DecLevelContext MetaM (Option Level) := do\n      \n      withReader (fun _ => { canAssignMVars := false }) do\n        match (\u2190 decAux? u) with\n        | none   => return none\n        | some u => do\n          match (\u2190 decAux? v) with\n          | none   => return none\n          | some v => return mkLevelMax' u v\n    match u with\n    | Level.max u v  => processMax u v\n    \n    | Level.imax u v => processMax u v\n    | _              => unreachable!", "start": [18, 1], "end": [51, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.decLevel?", "code": "def decLevel? (u : Level) : MetaM (Option Level) := do\n  let mctx \u2190 getMCtx\n  match (\u2190 decAux? u |>.run {}) with\n  | some v => return some v\n  | none   => do\n    modify fun s => { s with mctx := mctx }\n    return none", "start": [53, 1], "end": [59, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.decLevel", "code": "def decLevel (u : Level) : MetaM Level := do\n  match (\u2190 decLevel? u) with\n  | some u => return u\n  | none   => throwError \"invalid universe level, {u} is not greater than 0\"", "start": [61, 1], "end": [64, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getDecLevel", "code": "def getDecLevel (type : Expr) : MetaM Level := do\n  decLevel (\u2190 getLevel type)", "start": [66, 1], "end": [70, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Util.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Command.lean", "lake-packages/lean4/src/lean/Lean/Elab/Exception.lean", "lake-packages/lean4/src/lean/Lean/KeyedDeclsAttribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Syntax.prettyPrint", "code": "def Syntax.prettyPrint (stx : Syntax) : Format :=\n  match stx.unsetTrailing.reprint with | some str => format str.toFormat\n  | none     => format stx", "start": [12, 1], "end": [15, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.MacroScopesView.format", "code": "def MacroScopesView.format (view : MacroScopesView) (mainModule : Name) : Format :=\n  Std.format <|\n    if view.scopes.isEmpty then\n      view.name\n    else if view.mainModule == mainModule then\n      view.scopes.foldl Name.mkNum (view.name ++ view.imported)\n    else\n      view.scopes.foldl Name.mkNum (view.name ++ view.imported ++ view.mainModule)", "start": [17, 1], "end": [24, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.expandOptNamedPrio", "code": "def expandOptNamedPrio (stx : Syntax) : MacroM Nat :=\n  if stx.isNone then\n    return eval_prio default\n  else match stx[0] with\n    | `(Parser.Command.namedPrio| (priority := $prio)) => evalPrio prio\n    | _ => Macro.throwUnsupported", "start": [28, 1], "end": [33, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.MacroStackElem", "code": "structure MacroStackElem where\n  before : Syntax\n  after : Syntax", "start": [35, 1], "end": [37, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.MacroStack", "code": "abbrev MacroStack := List MacroStackElem", "start": [39, 1], "end": [39, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.getBetterRef", "code": "def getBetterRef (ref : Syntax) (macroStack : MacroStack) : Syntax :=\n  match ref.getPos? with\n  | some _ => ref\n  | none   =>\n    match macroStack.find? (\u00b7.before.getPos? != none) with\n    | some elem => elem.before\n    | none      => ref", "start": [41, 1], "end": [48, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addMacroStack", "code": "def addMacroStack {m} [Monad m] [MonadOptions m] (msgData : MessageData) (macroStack : MacroStack) : m MessageData := do\n  if !pp.macroStack.get (\u2190 getOptions) then pure msgData else\n  match macroStack with\n  | []             => pure msgData\n  | stack@(top::_) =>\n    let msgData := msgData ++ Format.line ++ \"with resulting expansion\" ++ indentD top.after\n    pure $ stack.foldl\n      (fun (msgData : MessageData) (elem : MacroStackElem) =>\n        msgData ++ Format.line ++ \"while expanding\" ++ indentD elem.before)\n      msgData", "start": [56, 1], "end": [65, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.checkSyntaxNodeKind", "code": "def checkSyntaxNodeKind [Monad m] [MonadEnv m] [MonadError m] (k : Name) : m Name := do\n  if Parser.isValidSyntaxNodeKind (\u2190 getEnv) k then pure k\n  else throwError \"failed\"", "start": [67, 1], "end": [69, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.checkSyntaxNodeKindAtNamespaces", "code": "def checkSyntaxNodeKindAtNamespaces [Monad m] [MonadEnv m] [MonadError m] (k : Name) : Name \u2192 m Name\n  | n@(.str p _) => checkSyntaxNodeKind (n ++ k) <|> checkSyntaxNodeKindAtNamespaces k p\n  | .anonymous   => checkSyntaxNodeKind k\n  | _ => throwError \"failed\"", "start": [71, 1], "end": [74, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.checkSyntaxNodeKindAtCurrentNamespaces", "code": "def checkSyntaxNodeKindAtCurrentNamespaces (k : Name) : AttrM Name := do\n  let ctx \u2190 read\n  checkSyntaxNodeKindAtNamespaces k ctx.currNamespace", "start": [76, 1], "end": [78, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.syntaxNodeKindOfAttrParam", "code": "def syntaxNodeKindOfAttrParam (defaultParserNamespace : Name) (stx : Syntax) : AttrM SyntaxNodeKind := do\n  let k \u2190 Attribute.Builtin.getId stx\n  checkSyntaxNodeKindAtCurrentNamespaces k\n  <|>\n  checkSyntaxNodeKind (defaultParserNamespace ++ k)\n  <|>\n  throwError \"invalid syntax node kind '{k}'\"", "start": [80, 1], "end": [86, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.evalSyntaxConstantUnsafe", "code": "private unsafe def evalSyntaxConstantUnsafe (env : Environment) (opts : Options) (constName : Name) : ExceptT String Id Syntax :=\n  env.evalConstCheck Syntax opts `Lean.Syntax constName", "start": [88, 1], "end": [89, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.evalSyntaxConstant", "code": "@[implemented_by evalSyntaxConstantUnsafe]\nopaque evalSyntaxConstant (env : Environment) (opts : Options) (constName : Name) : ExceptT String Id Syntax := throw \"\"", "start": [91, 1], "end": [92, 121], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkElabAttribute", "code": "unsafe def mkElabAttribute (\u03b3) (attrBuiltinName attrName : Name) (parserNamespace : Name) (typeName : Name) (kind : String)\n    (attrDeclName : Name := by exact decl_name%) : IO (KeyedDeclsAttribute \u03b3) :=\n  KeyedDeclsAttribute.init {\n    builtinName   := attrBuiltinName\n    name          := attrName\n    descr         := kind ++ \" elaborator\"\n    valueTypeName := typeName\n    evalKey       := fun _ stx => do\n      let kind \u2190 syntaxNodeKindOfAttrParam parserNamespace stx\n      \n      if (\u2190 getEnv).contains kind && (\u2190 getInfoState).enabled then\n        addConstInfo stx[1] kind none\n      return kind\n    onAdded       := fun builtin declName => do\n      if builtin then\n        if let some doc \u2190 findDocString? (\u2190 getEnv) declName (includeBuiltin := false) then\n          declareBuiltin (declName ++ `docString) (mkAppN (mkConst ``addBuiltinDocString) #[toExpr declName, toExpr doc])\n        if let some declRanges \u2190 findDeclarationRanges? declName then\n          declareBuiltin (declName ++ `declRange) (mkAppN (mkConst ``addBuiltinDeclarationRanges) #[toExpr declName, toExpr declRanges])\n  } attrDeclName", "start": [94, 1], "end": [113, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkMacroAttributeUnsafe", "code": "unsafe def mkMacroAttributeUnsafe (ref : Name) : IO (KeyedDeclsAttribute Macro) :=\n  mkElabAttribute Macro `builtin_macro `macro Name.anonymous `Lean.Macro \"macro\" ref", "start": [115, 1], "end": [116, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkMacroAttribute", "code": "@[implemented_by mkMacroAttributeUnsafe]\nopaque mkMacroAttribute (ref : Name) : IO (KeyedDeclsAttribute Macro)", "start": [118, 1], "end": [119, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.expandMacroImpl?", "code": "def expandMacroImpl? (env : Environment) : Syntax \u2192 MacroM (Option (Name \u00d7 Except Macro.Exception Syntax)) := fun stx => do\n  for e in macroAttribute.getEntries env stx.getKind do\n    try\n      let stx' \u2190 withFreshMacroScope (e.value stx)\n      return (e.declName, Except.ok stx')\n    catch\n      | Macro.Exception.unsupportedSyntax => pure ()\n      | ex                                => return (e.declName, Except.error ex)\n  return none", "start": [123, 1], "end": [135, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.MonadMacroAdapter", "code": "class MonadMacroAdapter (m : Type \u2192 Type) where\n  getCurrMacroScope                  : m MacroScope\n  getNextMacroScope                  : m MacroScope\n  setNextMacroScope                  : MacroScope \u2192 m Unit", "start": [137, 1], "end": [140, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.liftMacroM", "code": "def liftMacroM [Monad m] [MonadMacroAdapter m] [MonadEnv m] [MonadRecDepth m] [MonadError m] [MonadResolveName m] [MonadTrace m] [MonadOptions m] [AddMessageContext m] [MonadLiftT IO m] (x : MacroM \u03b1) : m \u03b1 := do\n  let env  \u2190 getEnv\n  let currNamespace \u2190 getCurrNamespace\n  let openDecls \u2190 getOpenDecls\n  let methods := Macro.mkMethods {\n    expandMacro?     := fun stx => do\n      match (\u2190 expandMacroImpl? env stx) with\n      | some (_, stx?) => liftExcept stx?\n      | none           => return none\n    hasDecl          := fun declName => return env.contains declName\n    getCurrNamespace := return currNamespace\n    resolveNamespace := fun n => return ResolveName.resolveNamespace env currNamespace openDecls n\n    resolveGlobalName := fun n => return ResolveName.resolveGlobalName env currNamespace openDecls n\n  }\n  match x { methods        := methods\n            ref            := \u2190 getRef\n            currMacroScope := \u2190 MonadMacroAdapter.getCurrMacroScope\n            mainModule     := env.mainModule\n            currRecDepth   := \u2190 MonadRecDepth.getRecDepth\n            maxRecDepth    := \u2190 MonadRecDepth.getMaxRecDepth\n          } { macroScope := (\u2190 MonadMacroAdapter.getNextMacroScope) } with\n  | EStateM.Result.error Macro.Exception.unsupportedSyntax _ => throwUnsupportedSyntax\n  | EStateM.Result.error (Macro.Exception.error ref msg) _   =>\n    if msg == maxRecDepthErrorMessage then\n      throwMaxRecDepthAt ref\n    else\n      throwErrorAt ref msg\n  | EStateM.Result.ok a s =>\n    MonadMacroAdapter.setNextMacroScope s.macroScope\n    s.traceMsgs.reverse.forM fun (clsName, msg) => trace clsName fun _ => msg\n    return a", "start": [149, 1], "end": [181, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.adaptMacro", "code": "@[inline] def adaptMacro {m : Type \u2192 Type} [Monad m] [MonadMacroAdapter m] [MonadEnv m] [MonadRecDepth m] [MonadError m]  [MonadResolveName m] [MonadTrace m] [MonadOptions m] [AddMessageContext m] [MonadLiftT IO m] (x : Macro) (stx : Syntax) : m Syntax :=\n  liftMacroM (x stx)", "start": [183, 1], "end": [184, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkUnusedBaseName", "code": "partial def mkUnusedBaseName (baseName : Name) : MacroM Name := do\n  let currNamespace \u2190 Macro.getCurrNamespace\n  if \u2190 Macro.hasDecl (currNamespace ++ baseName) then\n    let rec loop (idx : Nat) := do\n      let name := baseName.appendIndexAfter idx\n      if \u2190 Macro.hasDecl (currNamespace ++ name) then\n        loop (idx+1)\n      else\n        return name\n    loop 1\n  else\n    return baseName", "start": [186, 1], "end": [197, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.logException", "code": "def logException [Monad m] [MonadLog m] [AddMessageContext m] [MonadOptions m] [MonadLiftT IO m] (ex : Exception) : m Unit := do\n  match ex with\n  | Exception.error ref msg => logErrorAt ref msg\n  | Exception.internal id _ =>\n    unless isAbortExceptionId id do\n      let name \u2190 id.getName\n      logError m!\"internal exception: {name}\"", "start": [199, 1], "end": [205, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.withLogging", "code": "def withLogging [Monad m] [MonadLog m] [MonadExcept Exception m] [AddMessageContext m] [MonadOptions m] [MonadLiftT IO m]\n    (x : m Unit) : m Unit := do\n  try x catch ex => logException ex", "start": [207, 1], "end": [209, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.nestedExceptionToMessageData", "code": "def nestedExceptionToMessageData [Monad m] [MonadLog m] (ex : Exception) : m MessageData := do\n  let pos \u2190 getRefPos\n  match ex.getRef.getPos? with\n  | none       => return ex.toMessageData\n  | some exPos =>\n    if pos == exPos then\n      return ex.toMessageData\n    else\n      let exPosition := (\u2190 getFileMap).toPosition exPos\n      return m!\"{exPosition.line}:{exPosition.column} {ex.toMessageData}\"", "start": [211, 1], "end": [220, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.throwErrorWithNestedErrors", "code": "def throwErrorWithNestedErrors [MonadError m] [Monad m] [MonadLog m] (msg : MessageData) (exs : Array Exception) : m \u03b1 := do\n  throwError \"{msg}, errors {toMessageList (\u2190 exs.mapM fun | ex => nestedExceptionToMessageData ex)}\"", "start": [222, 1], "end": [223, 102], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Linter/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Linter.getLinterAll", "code": "def getLinterAll (o : Options) (defValue := linter.all.defValue) : Bool := o.get linter.all.name defValue", "start": [10, 1], "end": [10, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.getLinterValue", "code": "def getLinterValue (opt : Lean.Option Bool) (o : Options) : Bool := o.get opt.name (getLinterAll o opt.defValue)", "start": [12, 1], "end": [12, 113], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Recognizers.lean", "lake-packages/lean4/src/lean/Lean/Meta/DecLevel.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Structure.lean", "lake-packages/lean4/src/lean/Lean/Meta/SynthInstance.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean"], "premises": [{"full_name": "Lean.Meta.mkId", "code": "def mkId (e : Expr) : MetaM Expr := do\n  let type \u2190 inferType e\n  let u    \u2190 getLevel type\n  return mkApp2 (mkConst ``id [u]) type e", "start": [14, 1], "end": [18, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkExpectedTypeHint", "code": "def mkExpectedTypeHint (e : Expr) (expectedType : Expr) : MetaM Expr := do\n  let u \u2190 getLevel expectedType\n  return mkApp2 (mkConst ``id [u]) expectedType e", "start": [20, 1], "end": [25, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEq", "code": "def mkEq (a b : Expr) : MetaM Expr := do\n  let aType \u2190 inferType a\n  let u \u2190 getLevel aType\n  return mkApp3 (mkConst ``Eq [u]) aType a b", "start": [27, 1], "end": [31, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkHEq", "code": "def mkHEq (a b : Expr) : MetaM Expr := do\n  let aType \u2190 inferType a\n  let bType \u2190 inferType b\n  let u \u2190 getLevel aType\n  return mkApp4 (mkConst ``HEq [u]) aType a bType b", "start": [33, 1], "end": [38, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqHEq", "code": "def mkEqHEq (a b : Expr) : MetaM Expr := do\n  let aType \u2190 inferType a\n  let bType \u2190 inferType b\n  let u \u2190 getLevel aType\n  if (\u2190 isDefEq aType bType) then\n    return mkApp3 (mkConst ``Eq [u]) aType a b\n  else\n    return mkApp4 (mkConst ``HEq [u]) aType a bType b", "start": [40, 1], "end": [50, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqRefl", "code": "def mkEqRefl (a : Expr) : MetaM Expr := do\n  let aType \u2190 inferType a\n  let u \u2190 getLevel aType\n  return mkApp2 (mkConst ``Eq.refl [u]) aType a", "start": [52, 1], "end": [56, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkHEqRefl", "code": "def mkHEqRefl (a : Expr) : MetaM Expr := do\n  let aType \u2190 inferType a\n  let u \u2190 getLevel aType\n  return mkApp2 (mkConst ``HEq.refl [u]) aType a", "start": [58, 1], "end": [62, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAbsurd", "code": "def mkAbsurd (e : Expr) (hp hnp : Expr) : MetaM Expr := do\n  let p \u2190 inferType hp\n  let u \u2190 getLevel e\n  return mkApp4 (mkConst ``absurd [u]) p e hp hnp", "start": [64, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFalseElim", "code": "def mkFalseElim (e : Expr) (h : Expr) : MetaM Expr := do\n  let u \u2190 getLevel e\n  return mkApp2 (mkConst ``False.elim [u]) e h", "start": [70, 1], "end": [73, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.infer", "code": "private def infer (h : Expr) : MetaM Expr := do\n  let hType \u2190 inferType h\n  whnfD hType", "start": [75, 1], "end": [77, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.hasTypeMsg", "code": "private def hasTypeMsg (e type : Expr) : MessageData :=\n  m!\"{indentExpr e}\\nhas type{indentExpr type}\"", "start": [79, 1], "end": [80, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwAppBuilderException", "code": "private def throwAppBuilderException {\u03b1} (op : Name) (msg : MessageData) : MetaM \u03b1 :=\n  throwError \"AppBuilder for '{op}', {msg}\"", "start": [82, 1], "end": [83, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqSymm", "code": "def mkEqSymm (h : Expr) : MetaM Expr := do\n  if h.isAppOf ``Eq.refl then\n    return h\n  else\n    let hType \u2190 infer h\n    match hType.eq? with\n    | some (\u03b1, a, b) =>\n      let u \u2190 getLevel \u03b1\n      return mkApp4 (mkConst ``Eq.symm [u]) \u03b1 a b h\n    | none => throwAppBuilderException ``Eq.symm (\"equality proof expected\" ++ hasTypeMsg h hType)", "start": [85, 1], "end": [95, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqTrans", "code": "def mkEqTrans (h\u2081 h\u2082 : Expr) : MetaM Expr := do\n  if h\u2081.isAppOf ``Eq.refl then\n    return h\u2082\n  else if h\u2082.isAppOf ``Eq.refl then\n    return h\u2081\n  else\n    let hType\u2081 \u2190 infer h\u2081\n    let hType\u2082 \u2190 infer h\u2082\n    match hType\u2081.eq?, hType\u2082.eq? with\n    | some (\u03b1, a, b), some (_, _, c) =>\n      let u \u2190 getLevel \u03b1\n      return mkApp6 (mkConst ``Eq.trans [u]) \u03b1 a b c h\u2081 h\u2082\n    | none, _ => throwAppBuilderException ``Eq.trans (\"equality proof expected\" ++ hasTypeMsg h\u2081 hType\u2081)\n    | _, none => throwAppBuilderException ``Eq.trans (\"equality proof expected\" ++ hasTypeMsg h\u2082 hType\u2082)", "start": [97, 1], "end": [111, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkHEqSymm", "code": "def mkHEqSymm (h : Expr) : MetaM Expr := do\n  if h.isAppOf ``HEq.refl then\n    return h\n  else\n    let hType \u2190 infer h\n    match hType.heq? with\n    | some (\u03b1, a, \u03b2, b) =>\n      let u \u2190 getLevel \u03b1\n      return mkApp5 (mkConst ``HEq.symm [u]) \u03b1 \u03b2 a b h\n    | none =>\n      throwAppBuilderException ``HEq.symm (\"heterogeneous equality proof expected\" ++ hasTypeMsg h hType)", "start": [113, 1], "end": [124, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkHEqTrans", "code": "def mkHEqTrans (h\u2081 h\u2082 : Expr) : MetaM Expr := do\n  if h\u2081.isAppOf ``HEq.refl then\n    return h\u2082\n  else if h\u2082.isAppOf ``HEq.refl then\n    return h\u2081\n  else\n    let hType\u2081 \u2190 infer h\u2081\n    let hType\u2082 \u2190 infer h\u2082\n    match hType\u2081.heq?, hType\u2082.heq? with\n    | some (\u03b1, a, \u03b2, b), some (_, _, \u03b3, c) =>\n      let u \u2190 getLevel \u03b1\n      return mkApp8 (mkConst ``HEq.trans [u]) \u03b1 \u03b2 \u03b3 a b c h\u2081 h\u2082\n    | none, _ => throwAppBuilderException ``HEq.trans (\"heterogeneous equality proof expected\" ++ hasTypeMsg h\u2081 hType\u2081)\n    | _, none => throwAppBuilderException ``HEq.trans (\"heterogeneous equality proof expected\" ++ hasTypeMsg h\u2082 hType\u2082)", "start": [126, 1], "end": [140, 120], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqOfHEq", "code": "def mkEqOfHEq (h : Expr) : MetaM Expr := do\n  let hType \u2190 infer h\n  match hType.heq? with\n  | some (\u03b1, a, \u03b2, b) =>\n    unless (\u2190 isDefEq \u03b1 \u03b2) do\n      throwAppBuilderException ``eq_of_heq m!\"heterogeneous equality types are not definitionally equal{indentExpr \u03b1}\\nis not definitionally equal to{indentExpr \u03b2}\"\n    let u \u2190 getLevel \u03b1\n    return mkApp4 (mkConst ``eq_of_heq [u]) \u03b1 a b h\n  | _ =>\n    throwAppBuilderException ``HEq.trans m!\"heterogeneous equality proof expected{indentExpr h}\"", "start": [142, 1], "end": [152, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkCongrArg", "code": "def mkCongrArg (f h : Expr) : MetaM Expr := do\n  if h.isAppOf ``Eq.refl then\n    mkEqRefl (mkApp f h.appArg!)\n  else\n    let hType \u2190 infer h\n    let fType \u2190 infer f\n    match fType.arrow?, hType.eq? with\n    | some (\u03b1, \u03b2), some (_, a, b) =>\n      let u \u2190 getLevel \u03b1\n      let v \u2190 getLevel \u03b2\n      return mkApp6 (mkConst ``congrArg [u, v]) \u03b1 \u03b2 a b f h\n    | none, _ => throwAppBuilderException ``congrArg (\"non-dependent function expected\" ++ hasTypeMsg f fType)\n    | _, none => throwAppBuilderException ``congrArg (\"equality proof expected\" ++ hasTypeMsg h hType)", "start": [154, 1], "end": [167, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkCongrFun", "code": "def mkCongrFun (h a : Expr) : MetaM Expr := do\n  if h.isAppOf ``Eq.refl then\n    mkEqRefl (mkApp h.appArg! a)\n  else\n    let hType \u2190 infer h\n    match hType.eq? with\n    | some (\u03c1, f, g) => do\n      let \u03c1 \u2190 whnfD \u03c1\n      match \u03c1 with\n      | Expr.forallE n \u03b1 \u03b2 _ =>\n        let \u03b2' := Lean.mkLambda n BinderInfo.default \u03b1 \u03b2\n        let u \u2190 getLevel \u03b1\n        let v \u2190 getLevel (mkApp \u03b2' a)\n        return mkApp6 (mkConst ``congrFun [u, v]) \u03b1 \u03b2' f g h a\n      | _ => throwAppBuilderException ``congrFun (\"equality proof between functions expected\" ++ hasTypeMsg h hType)\n    | _ => throwAppBuilderException ``congrFun (\"equality proof expected\" ++ hasTypeMsg h hType)", "start": [169, 1], "end": [185, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkCongr", "code": "def mkCongr (h\u2081 h\u2082 : Expr) : MetaM Expr := do\n  if h\u2081.isAppOf ``Eq.refl then\n    mkCongrArg h\u2081.appArg! h\u2082\n  else if h\u2082.isAppOf ``Eq.refl then\n    mkCongrFun h\u2081 h\u2082.appArg!\n  else\n    let hType\u2081 \u2190 infer h\u2081\n    let hType\u2082 \u2190 infer h\u2082\n    match hType\u2081.eq?, hType\u2082.eq? with\n    | some (\u03c1, f, g), some (\u03b1, a, b) =>\n      let \u03c1 \u2190 whnfD \u03c1\n      match \u03c1.arrow? with\n      | some (_, \u03b2) => do\n        let u \u2190 getLevel \u03b1\n        let v \u2190 getLevel \u03b2\n        return mkApp8 (mkConst ``congr [u, v]) \u03b1 \u03b2 f g a b h\u2081 h\u2082\n      | _ => throwAppBuilderException ``congr (\"non-dependent function expected\" ++ hasTypeMsg h\u2081 hType\u2081)\n    | none, _ => throwAppBuilderException ``congr (\"equality proof expected\" ++ hasTypeMsg h\u2081 hType\u2081)\n    | _, none => throwAppBuilderException ``congr (\"equality proof expected\" ++ hasTypeMsg h\u2082 hType\u2082)", "start": [187, 1], "end": [206, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAppMFinal", "code": "private def mkAppMFinal (methodName : Name) (f : Expr) (args : Array Expr) (instMVars : Array MVarId) : MetaM Expr := do\n  instMVars.forM fun mvarId => do\n    let mvarDecl \u2190 mvarId.getDecl\n    let mvarVal  \u2190 synthInstance mvarDecl.type\n    mvarId.assign mvarVal\n  let result \u2190 instantiateMVars (mkAppN f args)\n  if (\u2190 hasAssignableMVar result) then throwAppBuilderException methodName (\"result contains metavariables\" ++ indentExpr result)\n  return result", "start": [208, 1], "end": [215, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAppMArgs", "code": "private partial def mkAppMArgs (f : Expr) (fType : Expr) (xs : Array Expr) : MetaM Expr :=\n  let rec loop (type : Expr) (i : Nat) (j : Nat) (args : Array Expr) (instMVars : Array MVarId) : MetaM Expr := do\n    if i >= xs.size then\n      mkAppMFinal `mkAppM f args instMVars\n    else match type with\n      | Expr.forallE n d b bi =>\n        let d  := d.instantiateRevRange j args.size args\n        match bi with\n        | BinderInfo.implicit     =>\n          let mvar \u2190 mkFreshExprMVar d MetavarKind.natural n\n          loop b i j (args.push mvar) instMVars\n        | BinderInfo.strictImplicit     =>\n          let mvar \u2190 mkFreshExprMVar d MetavarKind.natural n\n          loop b i j (args.push mvar) instMVars\n        | BinderInfo.instImplicit =>\n          let mvar \u2190 mkFreshExprMVar d MetavarKind.synthetic n\n          loop b i j (args.push mvar) (instMVars.push mvar.mvarId!)\n        | _ =>\n          let x := xs[i]!\n          let xType \u2190 inferType x\n          if (\u2190 isDefEq d xType) then\n            loop b (i+1) j (args.push x) instMVars\n          else\n            throwAppTypeMismatch (mkAppN f args) x\n      | type =>\n        let type := type.instantiateRevRange j args.size args\n        let type \u2190 whnfD type\n        if type.isForall then\n          loop type i args.size args instMVars\n        else\n          throwAppBuilderException `mkAppM m!\"too many explicit arguments provided to{indentExpr f}\\narguments{indentD xs}\"\n  loop fType 0 0 #[] #[]", "start": [217, 1], "end": [248, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFun", "code": "private def mkFun (constName : Name) : MetaM (Expr \u00d7 Expr) := do\n  let cinfo \u2190 getConstInfo constName\n  let us \u2190 cinfo.levelParams.mapM fun _ => mkFreshLevelMVar\n  let f := mkConst constName us\n  let fType \u2190 instantiateTypeLevelParams cinfo us\n  return (f, fType)", "start": [250, 1], "end": [255, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withAppBuilderTrace", "code": "private def withAppBuilderTrace [ToMessageData \u03b1] [ToMessageData \u03b2]\n    (f : \u03b1) (xs : \u03b2) (k : MetaM Expr) : MetaM Expr :=\n  let emoji | .ok .. => checkEmoji | .error .. => crossEmoji\n  withTraceNode `Meta.appBuilder (return m!\"{emoji \u00b7} f: {f}, xs: {xs}\") do\n    try\n      let res \u2190 k\n      trace[Meta.appBuilder.result] res\n      pure res\n    catch ex =>\n      trace[Meta.appBuilder.error] ex.toMessageData\n      throw ex", "start": [257, 1], "end": [267, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAppM", "code": "def mkAppM (constName : Name) (xs : Array Expr) : MetaM Expr := do\n  withAppBuilderTrace constName xs do withNewMCtxDepth do\n    let (f, fType) \u2190 mkFun constName\n    mkAppMArgs f fType xs", "start": [269, 1], "end": [281, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAppM'", "code": "def mkAppM' (f : Expr) (xs : Array Expr) : MetaM Expr := do\n  let fType \u2190 inferType f\n  withAppBuilderTrace f xs do withNewMCtxDepth do\n    mkAppMArgs f fType xs", "start": [283, 1], "end": [287, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAppOptMAux", "code": "private partial def mkAppOptMAux (f : Expr) (xs : Array (Option Expr)) : Nat \u2192 Array Expr \u2192 Nat \u2192 Array MVarId \u2192 Expr \u2192 MetaM Expr\n  | i, args, j, instMVars, Expr.forallE n d b bi => do\n    let d  := d.instantiateRevRange j args.size args\n    if h : i < xs.size then\n      match xs.get \u27e8i, h\u27e9 with\n      | none =>\n        match bi with\n        | BinderInfo.instImplicit => do\n          let mvar \u2190 mkFreshExprMVar d MetavarKind.synthetic n\n          mkAppOptMAux f xs (i+1) (args.push mvar) j (instMVars.push mvar.mvarId!) b\n        | _                       => do\n          let mvar \u2190 mkFreshExprMVar d MetavarKind.natural n\n          mkAppOptMAux f xs (i+1) (args.push mvar) j instMVars b\n      | some x =>\n        let xType \u2190 inferType x\n        if (\u2190 isDefEq d xType) then\n          mkAppOptMAux f xs (i+1) (args.push x) j instMVars b\n        else\n          throwAppTypeMismatch (mkAppN f args) x\n    else\n      mkAppMFinal `mkAppOptM f args instMVars\n  | i, args, j, instMVars, type => do\n    let type := type.instantiateRevRange j args.size args\n    let type \u2190 whnfD type\n    if type.isForall then\n      mkAppOptMAux f xs i args args.size instMVars type\n    else if i == xs.size then\n      mkAppMFinal `mkAppOptM f args instMVars\n    else do\n      let xs : Array Expr := xs.foldl (fun r x? => match x? with | none => r | some x => r.push x) #[]\n      throwAppBuilderException `mkAppOptM (\"too many arguments provided to\" ++ indentExpr f ++ Format.line ++ \"arguments\" ++ xs)", "start": [289, 1], "end": [319, 129], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAppOptM", "code": "def mkAppOptM (constName : Name) (xs : Array (Option Expr)) : MetaM Expr := do\n  withAppBuilderTrace constName xs do withNewMCtxDepth do\n    let (f, fType) \u2190 mkFun constName\n    mkAppOptMAux f xs 0 #[] 0 #[] fType", "start": [321, 1], "end": [338, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAppOptM'", "code": "def mkAppOptM' (f : Expr) (xs : Array (Option Expr)) : MetaM Expr := do\n  let fType \u2190 inferType f\n  withAppBuilderTrace f xs do withNewMCtxDepth do\n    mkAppOptMAux f xs 0 #[] 0 #[] fType", "start": [340, 1], "end": [344, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqNDRec", "code": "def mkEqNDRec (motive h1 h2 : Expr) : MetaM Expr := do\n  if h2.isAppOf ``Eq.refl then\n    return h1\n  else\n    let h2Type \u2190 infer h2\n    match h2Type.eq? with\n    | none => throwAppBuilderException ``Eq.ndrec (\"equality proof expected\" ++ hasTypeMsg h2 h2Type)\n    | some (\u03b1, a, b) =>\n      let u2 \u2190 getLevel \u03b1\n      let motiveType \u2190 infer motive\n      match motiveType with\n      | Expr.forallE _ _ (Expr.sort u1) _ =>\n        return mkAppN (mkConst ``Eq.ndrec [u1, u2]) #[\u03b1, a, motive, h1, b, h2]\n      | _ => throwAppBuilderException ``Eq.ndrec (\"invalid motive\" ++ indentExpr motive)", "start": [346, 1], "end": [359, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqRec", "code": "def mkEqRec (motive h1 h2 : Expr) : MetaM Expr := do\n  if h2.isAppOf ``Eq.refl then\n    return h1\n  else\n    let h2Type \u2190 infer h2\n    match h2Type.eq? with\n    | none => throwAppBuilderException ``Eq.rec (\"equality proof expected\" ++ indentExpr h2)\n    | some (\u03b1, a, b) =>\n      let u2 \u2190 getLevel \u03b1\n      let motiveType \u2190 infer motive\n      match motiveType with\n      | Expr.forallE _ _ (Expr.forallE _ _ (Expr.sort u1) _) _ =>\n        return mkAppN (mkConst ``Eq.rec [u1, u2]) #[\u03b1, a, motive, h1, b, h2]\n      | _ =>\n        throwAppBuilderException ``Eq.rec (\"invalid motive\" ++ indentExpr motive)", "start": [361, 1], "end": [375, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqMP", "code": "def mkEqMP (eqProof pr : Expr) : MetaM Expr :=\n  mkAppM ``Eq.mp #[eqProof, pr]", "start": [377, 1], "end": [378, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqMPR", "code": "def mkEqMPR (eqProof pr : Expr) : MetaM Expr :=\n  mkAppM ``Eq.mpr #[eqProof, pr]", "start": [380, 1], "end": [381, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkNoConfusion", "code": "def mkNoConfusion (target : Expr) (h : Expr) : MetaM Expr := do\n  let type \u2190 inferType h\n  let type \u2190 whnf type\n  match type.eq? with\n  | none           => throwAppBuilderException `noConfusion (\"equality expected\" ++ hasTypeMsg h type)\n  | some (\u03b1, a, b) =>\n    let \u03b1 \u2190 whnfD \u03b1\n    matchConstInduct \u03b1.getAppFn (fun _ => throwAppBuilderException `noConfusion (\"inductive type expected\" ++ indentExpr \u03b1)) fun v us => do\n      let u \u2190 getLevel target\n      return mkAppN (mkConst (Name.mkStr v.name \"noConfusion\") (u :: us)) (\u03b1.getAppArgs ++ #[target, a, b, h])", "start": [383, 1], "end": [392, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkPure", "code": "def mkPure (monad : Expr) (e : Expr) : MetaM Expr :=\n  mkAppOptM ``Pure.pure #[monad, none, none, e]", "start": [394, 1], "end": [396, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkProjection", "code": "partial def mkProjection (s : Expr) (fieldName : Name) : MetaM Expr := do\n  let type \u2190 inferType s\n  let type \u2190 whnf type\n  match type.getAppFn with\n  | Expr.const structName us =>\n    let env \u2190 getEnv\n    unless isStructure env structName do\n      throwAppBuilderException `mkProjection (\"structure expected\" ++ hasTypeMsg s type)\n    match getProjFnForField? env structName fieldName with\n    | some projFn =>\n      let params := type.getAppArgs\n      return mkApp (mkAppN (mkConst projFn us) params) s\n    | none =>\n      let fields := getStructureFields env structName\n      let r? \u2190 fields.findSomeM? fun fieldName' => do\n        match isSubobjectField? env structName fieldName' with\n        | none   => pure none\n        | some _ =>\n          let parent \u2190 mkProjection s fieldName'\n          (do let r \u2190 mkProjection parent fieldName; return some r)\n          <|>\n          pure none\n      match r? with\n      | some r => pure r\n      | none   => throwAppBuilderException `mkProjection (\"invalid field name '\" ++ toString fieldName ++ \"' for\" ++ hasTypeMsg s type)\n  | _ => throwAppBuilderException `mkProjection (\"structure expected\" ++ hasTypeMsg s type)", "start": [398, 1], "end": [426, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkListLitAux", "code": "private def mkListLitAux (nil : Expr) (cons : Expr) : List Expr \u2192 Expr\n  | []    => nil\n  | x::xs => mkApp (mkApp cons x) (mkListLitAux nil cons xs)", "start": [428, 1], "end": [430, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkListLit", "code": "def mkListLit (type : Expr) (xs : List Expr) : MetaM Expr := do\n  let u   \u2190 getDecLevel type\n  let nil := mkApp (mkConst ``List.nil [u]) type\n  match xs with\n  | [] => return nil\n  | _  =>\n    let cons := mkApp (mkConst ``List.cons [u]) type\n    return mkListLitAux nil cons xs", "start": [432, 1], "end": [439, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkArrayLit", "code": "def mkArrayLit (type : Expr) (xs : List Expr) : MetaM Expr := do\n  let u \u2190 getDecLevel type\n  let listLit \u2190 mkListLit type xs\n  return mkApp (mkApp (mkConst ``List.toArray [u]) type) listLit", "start": [441, 1], "end": [444, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSorry", "code": "def mkSorry (type : Expr) (synthetic : Bool) : MetaM Expr := do\n  let u \u2190 getLevel type\n  return mkApp2 (mkConst ``sorryAx [u]) type (toExpr synthetic)", "start": [446, 1], "end": [448, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkDecide", "code": "def mkDecide (p : Expr) : MetaM Expr :=\n  mkAppOptM ``Decidable.decide #[p, none]", "start": [450, 1], "end": [452, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkDecideProof", "code": "def mkDecideProof (p : Expr) : MetaM Expr := do\n  let decP      \u2190 mkDecide p\n  let decEqTrue \u2190 mkEq decP (mkConst ``Bool.true)\n  let h         \u2190 mkEqRefl (mkConst ``Bool.true)\n  let h         \u2190 mkExpectedTypeHint h decEqTrue\n  mkAppM ``of_decide_eq_true #[h]", "start": [454, 1], "end": [460, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLt", "code": "def mkLt (a b : Expr) : MetaM Expr :=\n  mkAppM ``LT.lt #[a, b]", "start": [462, 1], "end": [464, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLe", "code": "def mkLe (a b : Expr) : MetaM Expr :=\n  mkAppM ``LE.le #[a, b]", "start": [466, 1], "end": [468, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkDefault", "code": "def mkDefault (\u03b1 : Expr) : MetaM Expr :=\n  mkAppOptM ``Inhabited.default #[\u03b1, none]", "start": [470, 1], "end": [472, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkOfNonempty", "code": "def mkOfNonempty (\u03b1 : Expr) : MetaM Expr := do\n  mkAppOptM ``Classical.ofNonempty #[\u03b1, none]", "start": [474, 1], "end": [476, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSyntheticSorry", "code": "def mkSyntheticSorry (type : Expr) : MetaM Expr :=\n  return mkApp2 (mkConst ``sorryAx [\u2190 getLevel type]) type (mkConst ``Bool.true)", "start": [478, 1], "end": [480, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFunExt", "code": "def mkFunExt (h : Expr) : MetaM Expr :=\n  mkAppM ``funext #[h]", "start": [482, 1], "end": [484, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkPropExt", "code": "def mkPropExt (h : Expr) : MetaM Expr :=\n  mkAppM ``propext #[h]", "start": [486, 1], "end": [488, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLetCongr", "code": "def mkLetCongr (h\u2081 h\u2082 : Expr) : MetaM Expr :=\n  mkAppM ``let_congr #[h\u2081, h\u2082]", "start": [490, 1], "end": [492, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLetValCongr", "code": "def mkLetValCongr (b h : Expr) : MetaM Expr :=\n  mkAppM ``let_val_congr #[b, h]", "start": [494, 1], "end": [496, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLetBodyCongr", "code": "def mkLetBodyCongr (a h : Expr) : MetaM Expr :=\n  mkAppM ``let_body_congr #[a, h]", "start": [498, 1], "end": [500, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkOfEqTrue", "code": "def mkOfEqTrue (h : Expr) : MetaM Expr :=\n  mkAppM ``of_eq_true #[h]", "start": [502, 1], "end": [504, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqTrue", "code": "def mkEqTrue (h : Expr) : MetaM Expr :=\n  mkAppM ``eq_true #[h]", "start": [506, 1], "end": [508, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqFalse", "code": "def mkEqFalse (h : Expr) : MetaM Expr :=\n  mkAppM ``eq_false #[h]", "start": [510, 1], "end": [515, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqFalse'", "code": "def mkEqFalse' (h : Expr) : MetaM Expr :=\n  mkAppM ``eq_false' #[h]", "start": [517, 1], "end": [522, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkImpCongr", "code": "def mkImpCongr (h\u2081 h\u2082 : Expr) : MetaM Expr :=\n  mkAppM ``implies_congr #[h\u2081, h\u2082]", "start": [524, 1], "end": [525, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkImpCongrCtx", "code": "def mkImpCongrCtx (h\u2081 h\u2082 : Expr) : MetaM Expr :=\n  mkAppM ``implies_congr_ctx #[h\u2081, h\u2082]", "start": [527, 1], "end": [528, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkImpDepCongrCtx", "code": "def mkImpDepCongrCtx (h\u2081 h\u2082 : Expr) : MetaM Expr :=\n  mkAppM ``implies_dep_congr_ctx #[h\u2081, h\u2082]", "start": [530, 1], "end": [531, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkForallCongr", "code": "def mkForallCongr (h : Expr) : MetaM Expr :=\n  mkAppM ``forall_congr #[h]", "start": [533, 1], "end": [534, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isMonad?", "code": "def isMonad? (m : Expr) : MetaM (Option Expr) :=\n  try\n    let monadType \u2190 mkAppM `Monad #[m]\n    let result    \u2190 trySynthInstance monadType\n    match result with\n    | LOption.some inst => pure inst\n    | _                 => pure none\n  catch _ =>\n    pure none", "start": [536, 1], "end": [545, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkNumeral", "code": "def mkNumeral (type : Expr) (n : Nat) : MetaM Expr := do\n  let u \u2190 getDecLevel type\n  let inst \u2190 synthInstance (mkApp2 (mkConst ``OfNat [u]) type (mkRawNatLit n))\n  return mkApp3 (mkConst ``OfNat.ofNat [u]) type (mkRawNatLit n) inst", "start": [547, 1], "end": [551, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkBinaryOp", "code": "private def mkBinaryOp (className : Name) (opName : Name) (a b : Expr) : MetaM Expr := do\n  let aType \u2190 inferType a\n  let u \u2190 getDecLevel aType\n  let inst \u2190 synthInstance (mkApp3 (mkConst className [u, u, u]) aType aType aType)\n  return mkApp6 (mkConst opName [u, u, u]) aType aType aType inst a b", "start": [553, 1], "end": [563, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAdd", "code": "def mkAdd (a b : Expr) : MetaM Expr := mkBinaryOp ``HAdd ``HAdd.hAdd a b", "start": [565, 1], "end": [566, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSub", "code": "def mkSub (a b : Expr) : MetaM Expr := mkBinaryOp ``HSub ``HSub.hSub a b", "start": [568, 1], "end": [569, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkMul", "code": "def mkMul (a b : Expr) : MetaM Expr := mkBinaryOp ``HMul ``HMul.hMul a b", "start": [571, 1], "end": [572, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkBinaryRel", "code": "private def mkBinaryRel (className : Name) (rName : Name) (a b : Expr) : MetaM Expr := do\n  let aType \u2190 inferType a\n  let u \u2190 getDecLevel aType\n  let inst \u2190 synthInstance (mkApp (mkConst className [u]) aType)\n  return mkApp4 (mkConst rName [u]) aType inst a b", "start": [574, 1], "end": [584, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLE", "code": "def mkLE (a b : Expr) : MetaM Expr := mkBinaryRel ``LE ``LE.le a b", "start": [586, 1], "end": [587, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLT", "code": "def mkLT (a b : Expr) : MetaM Expr := mkBinaryRel ``LT ``LT.lt a b", "start": [589, 1], "end": [590, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkIffOfEq", "code": "def mkIffOfEq (h : Expr) : MetaM Expr := do\n  if h.isAppOfArity ``propext 3 then\n    return h.appArg!\n  else\n    mkAppM ``Iff.of_eq #[h]", "start": [592, 1], "end": [597, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/AutoBound.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.isValidAutoBoundSuffix", "code": "private def isValidAutoBoundSuffix (s : String) : Bool :=\n  s.toSubstring.drop 1 |>.all fun c => c.isDigit || isSubScriptAlnum c || c == '_' || c == '\\''", "start": [23, 1], "end": [24, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.isValidAutoBoundImplicitName", "code": "def isValidAutoBoundImplicitName (n : Name) (relaxed : Bool) : Bool :=\n  match n with\n  | .str .anonymous s => s.length > 0 && (relaxed || isValidAutoBoundSuffix s)\n  | _ => false", "start": [40, 1], "end": [43, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.isValidAutoBoundLevelName", "code": "def isValidAutoBoundLevelName (n : Name) (relaxed : Bool) : Bool :=\n  match n with\n  | .str .anonymous s => s.length > 0 && (relaxed || (s.front.isLower && isValidAutoBoundSuffix s))\n  | _ => false", "start": [45, 1], "end": [48, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Attributes.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Util.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Attribute", "code": "structure Attribute where\n  kind  : AttributeKind := AttributeKind.global\n  name  : Name\n  stx   : Syntax := Syntax.missing\n  deriving Inhabited", "start": [9, 1], "end": [13, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.toAttributeKind", "code": "def toAttributeKind (attrKindStx : Syntax) : MacroM AttributeKind := do\n  if attrKindStx[0].isNone then\n    return AttributeKind.global\n  else if attrKindStx[0][0].getKind == ``Lean.Parser.Term.scoped then\n    if (\u2190 Macro.getCurrNamespace).isAnonymous then\n      throw <| Macro.Exception.error (\u2190 getRef) \"scoped attributes must be used inside namespaces\"\n    return AttributeKind.scoped\n  else\n    return AttributeKind.local", "start": [23, 1], "end": [36, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkAttrKindGlobal", "code": "def mkAttrKindGlobal : Syntax :=\n  mkNode ``Lean.Parser.Term.attrKind #[mkNullNode]", "start": [38, 1], "end": [39, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.elabAttr", "code": "def elabAttr [Monad m] [MonadEnv m] [MonadResolveName m] [MonadError m] [MonadMacroAdapter m] [MonadRecDepth m] [MonadTrace m] [MonadOptions m] [AddMessageContext m] [MonadInfoTree m] [MonadLiftT IO m] (attrInstance : Syntax) : m Attribute := do\n  \n  let attrKind \u2190 liftMacroM <| toAttributeKind attrInstance[0]\n  let attr := attrInstance[1]\n  let attr \u2190 liftMacroM <| expandMacros attr\n  let attrName \u2190 if attr.getKind == ``Parser.Attr.simple then\n    pure attr[0].getId.eraseMacroScopes\n  else match attr.getKind with\n    | .str _ s => pure <| Name.mkSimple s\n    | _ => throwErrorAt attr  \"unknown attribute\"\n  let .ok _impl := getAttributeImpl (\u2190 getEnv) attrName\n    | throwError \"unknown attribute [{attrName}]\"\n  \n  return { kind := attrKind, name := attrName, stx := attr }", "start": [41, 1], "end": [55, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.elabAttrs", "code": "def elabAttrs [Monad m] [MonadEnv m] [MonadResolveName m] [MonadError m] [MonadMacroAdapter m] [MonadRecDepth m] [MonadTrace m] [MonadOptions m] [AddMessageContext m] [MonadLog m] [MonadInfoTree m] [MonadLiftT IO m] (attrInstances : Array Syntax) : m (Array Attribute) := do\n  let mut attrs := #[]\n  for attr in attrInstances do\n    try\n      attrs := attrs.push (\u2190 withRef attr do elabAttr attr)\n    catch ex =>\n      logException ex\n  return attrs", "start": [57, 1], "end": [64, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.elabDeclAttrs", "code": "def elabDeclAttrs [Monad m] [MonadEnv m] [MonadResolveName m] [MonadError m] [MonadMacroAdapter m] [MonadRecDepth m] [MonadTrace m] [MonadOptions m] [AddMessageContext m] [MonadLog m] [MonadInfoTree m] [MonadLiftT IO m] (stx : Syntax) : m (Array Attribute) :=\n  elabAttrs stx[1].getSepArgs", "start": [67, 1], "end": [68, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/SubExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.SubExpr.Pos", "code": "def SubExpr.Pos := Nat", "start": [12, 1], "end": [21, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.maxChildren", "code": "def maxChildren := 4", "start": [25, 1], "end": [25, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.typeCoord", "code": "def typeCoord : Nat := maxChildren - 1", "start": [27, 1], "end": [29, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.asNat", "code": "def asNat : Pos \u2192 Nat := id", "start": [31, 1], "end": [31, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.root", "code": "def root : Pos := (1 : Nat)", "start": [33, 1], "end": [34, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.isRoot", "code": "def isRoot (p : Pos) : Bool := p.asNat < maxChildren", "start": [38, 1], "end": [38, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.head", "code": "def head (p : Pos) : Nat :=\n  if p.isRoot then panic! \"already at top\"\n  else p.asNat % maxChildren", "start": [40, 1], "end": [43, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.tail", "code": "def tail (p : Pos) : Pos :=\n  if p.isRoot then panic! \"already at top\"\n  else (p.asNat - p.head) / maxChildren", "start": [45, 1], "end": [47, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.push", "code": "def push (p : Pos) (c : Nat) : Pos :=\n  if c >= maxChildren then panic! s!\"invalid coordinate {c}\"\n  else p.asNat * maxChildren + c", "start": [49, 1], "end": [51, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.foldl", "code": "partial def foldl  (f : \u03b1 \u2192 Nat \u2192 \u03b1) (a : \u03b1) (p : Pos) : \u03b1 :=\n  if p.isRoot then a else f (foldl f a p.tail) p.head", "start": [55, 1], "end": [57, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.foldr", "code": "partial def foldr  (f : Nat \u2192 \u03b1 \u2192 \u03b1) (p : Pos) (a : \u03b1) : \u03b1 :=\n  if p.isRoot then a else foldr f p.tail (f p.head a)", "start": [59, 1], "end": [61, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.foldlM", "code": "partial def foldlM  [Monad M] (f : \u03b1 \u2192 Nat \u2192 M \u03b1) (a : \u03b1) (p : Pos) : M \u03b1 :=\n  have : Inhabited (M \u03b1) := inferInstance\n  if p.isRoot then pure a else do foldlM f a p.tail >>= (f \u00b7 p.head)", "start": [63, 1], "end": [66, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.foldrM", "code": "partial def foldrM [Monad M] (f : Nat \u2192 \u03b1 \u2192 M \u03b1) (p : Pos) (a : \u03b1) : M \u03b1 :=\n  if p.isRoot then pure a else f p.head a >>= foldrM f p.tail", "start": [68, 1], "end": [70, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.depth", "code": "def depth (p : Pos) :=\n  p.foldr (fun _ => Nat.succ) 0", "start": [72, 1], "end": [73, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.all", "code": "def all (pred : Nat \u2192 Bool) (p : Pos) : Bool :=\n  OptionT.run (m := Id) (foldrM (fun n a => if pred n then pure a else failure) p ()) |>.isSome", "start": [75, 1], "end": [77, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.append", "code": "def append : Pos \u2192 Pos \u2192 Pos := foldl push", "start": [79, 1], "end": [79, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.ofArray", "code": "def ofArray (ps : Array Nat) : Pos :=\n  ps.foldl push root", "start": [81, 1], "end": [85, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.toArray", "code": "def toArray (p : Pos) : Array Nat :=\n  foldl Array.push #[] p", "start": [87, 1], "end": [90, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushBindingDomain", "code": "def pushBindingDomain (p : Pos) := p.push 0", "start": [92, 1], "end": [92, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushBindingBody", "code": "def pushBindingBody   (p : Pos) := p.push 1", "start": [93, 1], "end": [93, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushLetVarType", "code": "def pushLetVarType    (p : Pos) := p.push 0", "start": [94, 1], "end": [94, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushLetValue", "code": "def pushLetValue      (p : Pos) := p.push 1", "start": [95, 1], "end": [95, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushLetBody", "code": "def pushLetBody       (p : Pos) := p.push 2", "start": [96, 1], "end": [96, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushAppFn", "code": "def pushAppFn         (p : Pos) := p.push 0", "start": [97, 1], "end": [97, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushAppArg", "code": "def pushAppArg        (p : Pos) := p.push 1", "start": [98, 1], "end": [98, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushProj", "code": "def pushProj          (p : Pos) := p.push 0", "start": [99, 1], "end": [99, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushNaryFn", "code": "def pushNaryFn (numArgs : Nat) (p : Pos) : Pos :=\n  p.asNat * (maxChildren ^ numArgs)", "start": [101, 1], "end": [102, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushNaryArg", "code": "def pushNaryArg (numArgs argIdx : Nat) (p : Pos) : Pos :=\n  show Nat from p.asNat * (maxChildren ^ (numArgs - argIdx)) + 1", "start": [104, 1], "end": [105, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushNthBindingDomain", "code": "def pushNthBindingDomain : (binderIdx : Nat) \u2192 Pos \u2192 Pos\n  | 0, p => p.pushBindingDomain\n  | (n+1), p => pushNthBindingDomain n p.pushBindingBody", "start": [107, 1], "end": [109, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.pushNthBindingBody", "code": "def pushNthBindingBody : (numBinders : Nat) \u2192 Pos \u2192 Pos\n  | 0, p => p\n  | (n+1), p => pushNthBindingBody n p.pushBindingBody", "start": [111, 1], "end": [113, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.toString", "code": "protected def toString (p : Pos) : String :=\n  p.toArray.toList\n  |>.map toString\n  |> String.intercalate \"/\"\n  |> (\"/\" ++ \u00b7)", "start": [115, 1], "end": [119, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.ofStringCoord", "code": "private def ofStringCoord : String \u2192 Except String Nat\n  | \"0\" => ok 0 | \"1\" => ok 1 | \"2\" => ok 2 | \"3\" => ok 3\n  | c => error s!\"Invalid coordinate {c}\"", "start": [122, 1], "end": [124, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.fromString?", "code": "protected def fromString? : String \u2192 Except String Pos\n  | \"/\" => Except.ok Pos.root\n  | s =>\n    match String.splitOn s \"/\" with\n    | \"\" :: tail => Pos.ofArray <$> tail.toArray.mapM ofStringCoord\n    | ss => error s!\"malformed {ss}\"", "start": [127, 1], "end": [132, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.Pos.fromString!", "code": "protected def fromString! (s : String) : Pos :=\n  match Pos.fromString? s with\n  | Except.ok a => a\n  | Except.error e => panic! e", "start": [134, 1], "end": [137, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr", "code": "structure SubExpr where\n  \n  expr : Expr\n  \n  pos  : SubExpr.Pos\n  deriving Inhabited", "start": [154, 1], "end": [161, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.mkRoot", "code": "def mkRoot (e : Expr) : SubExpr := \u27e8e, Pos.root\u27e9", "start": [165, 1], "end": [165, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.isRoot", "code": "def isRoot (s : SubExpr) : Bool := s.pos.isRoot", "start": [167, 1], "end": [168, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.PosMap", "code": "abbrev PosMap (\u03b1 : Type u) := RBMap Pos \u03b1 compare", "start": [170, 1], "end": [171, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.bindingBody!", "code": "def bindingBody! : SubExpr \u2192 SubExpr\n  | \u27e8.forallE _ _ b _, p\u27e9 => \u27e8b, p.pushBindingBody\u27e9\n  | \u27e8.lam _ _ b _, p\u27e9 => \u27e8b, p.pushBindingBody\u27e9\n  | _ => panic! \"subexpr is not a binder\"", "start": [173, 1], "end": [176, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.bindingDomain!", "code": "def bindingDomain! : SubExpr \u2192 SubExpr\n  | \u27e8.forallE _ t _ _, p\u27e9 => \u27e8t, p.pushBindingDomain\u27e9\n  | \u27e8.lam _ t _ _, p\u27e9 => \u27e8t, p.pushBindingDomain\u27e9\n  | _ => panic! \"subexpr is not a binder\"", "start": [178, 1], "end": [181, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.GoalLocation", "code": "inductive GoalLocation where\n  \n  | hyp : FVarId \u2192 GoalLocation\n  \n  | hypType : FVarId \u2192 SubExpr.Pos \u2192 GoalLocation\n  \n  | hypValue : FVarId \u2192 SubExpr.Pos \u2192 GoalLocation\n  \n  | target : SubExpr.Pos \u2192 GoalLocation\n  deriving FromJson, ToJson", "start": [188, 1], "end": [198, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.SubExpr.GoalsLocation", "code": "structure GoalsLocation where\n  \n  mvarId : MVarId\n  loc    : GoalLocation\n  deriving FromJson, ToJson", "start": [200, 1], "end": [206, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.traverseAppWithPos", "code": "def Expr.traverseAppWithPos {M} [Monad M] (visit : Pos \u2192 Expr \u2192 M Expr) (p : Pos) (e : Expr) : M Expr :=\n  match e with\n  | Expr.app f a =>\n    e.updateApp!\n      <$> traverseAppWithPos visit p.pushAppFn f\n      <*> visit p.pushAppArg a\n  | e => visit p e", "start": [211, 1], "end": [219, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Linter/Deprecated.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Linter/Basic.lean", "lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Linter.isDeprecated", "code": "def isDeprecated (env : Environment) (declName : Name) : Bool :=\n  Option.isSome <| deprecatedAttr.getParam? env declName", "start": [30, 1], "end": [31, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.MessageData.isDeprecationWarning", "code": "def _root_.Lean.MessageData.isDeprecationWarning (msg : MessageData) : Bool :=\n  msg.hasTag (\u00b7 == ``deprecatedAttr)", "start": [33, 1], "end": [34, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.getDeprecatedNewName", "code": "def getDeprecatedNewName (env : Environment) (declName : Name) : Option Name :=\n  (deprecatedAttr.getParam? env declName).getD none", "start": [36, 1], "end": [37, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.checkDeprecated", "code": "def checkDeprecated [Monad m] [MonadEnv m] [MonadLog m] [AddMessageContext m] [MonadOptions m] (declName : Name) : m Unit := do\n  if getLinterValue linter.deprecated (\u2190 getOptions) then\n    match deprecatedAttr.getParam? (\u2190 getEnv) declName with\n    | none => pure ()\n    | some none => logWarning <| .tagged ``deprecatedAttr m!\"`{declName}` has been deprecated\"\n    | some (some newName) => logWarning <| .tagged ``deprecatedAttr m!\"`{declName}` has been deprecated, use `{newName}` instead\"", "start": [39, 1], "end": [44, 130], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Coe.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/SynthInstance.lean", "lake-packages/lean4/src/lean/Lean/Meta/WHNF.lean"], "premises": [{"full_name": "Lean.Meta.isCoeDecl", "code": "def isCoeDecl (env : Environment) (declName : Name) : Bool :=\n  coeDeclAttr.hasTag env declName", "start": [16, 1], "end": [21, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.expandCoe", "code": "partial def expandCoe (e : Expr) : MetaM Expr :=\n  withReducibleAndInstances do\n    transform e fun e => do\n      let f := e.getAppFn\n      if f.isConst then\n        let declName := f.constName!\n        if isCoeDecl (\u2190 getEnv) declName then\n          if let some e \u2190 unfoldDefinition? e then\n            return .visit e.headBeta\n      return .continue", "start": [23, 1], "end": [33, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.coerceSimple?", "code": "def coerceSimple? (expr expectedType : Expr) : MetaM (LOption Expr) := do\n  let eType \u2190 inferType expr\n  let u \u2190 getLevel eType\n  let v \u2190 getLevel expectedType\n  let coeTInstType := mkAppN (mkConst ``CoeT [u, v]) #[eType, expr, expectedType]\n  match \u2190 trySynthInstance coeTInstType with\n  | .some inst =>\n    let result \u2190 expandCoe (mkAppN (mkConst ``CoeT.coe [u, v]) #[eType, expr, expectedType, inst])\n    unless \u2190 isDefEq (\u2190 inferType result) expectedType do\n      throwError \"could not coerce{indentExpr expr}\\nto{indentExpr expectedType}\\ncoerced expression has wrong type:{indentExpr result}\"\n    return .some result\n  | .undef => return .undef\n  | .none => return .none", "start": [40, 1], "end": [53, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.coerceToFunction?", "code": "def coerceToFunction? (expr : Expr) : MetaM (Option Expr) := do\n  let \u03b1 \u2190 inferType expr\n  let u \u2190 getLevel \u03b1\n  let v \u2190 mkFreshLevelMVar\n  let \u03b3 \u2190 mkFreshExprMVar (\u2190 mkArrow \u03b1 (mkSort v))\n  let .some inst \u2190 trySynthInstance (mkApp2 (.const ``CoeFun [u,v]) \u03b1 \u03b3) | return none\n  let expanded \u2190 expandCoe (mkApp4 (.const ``CoeFun.coe [u,v]) \u03b1 \u03b3 inst expr)\n  unless (\u2190 whnf (\u2190 inferType expanded)).isForall do\n    throwError \"failed to coerce{indentExpr expr}\\nto a function, after applying `CoeFun.coe`, result is still not a function{indentExpr expanded}\\nthis is often due to incorrect `CoeFun` instances, the synthesized instance was{indentExpr inst}\"\n  return expanded", "start": [55, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.coerceToSort?", "code": "def coerceToSort? (expr : Expr) : MetaM (Option Expr) := do\n  let \u03b1 \u2190 inferType expr\n  let u \u2190 getLevel \u03b1\n  let v \u2190 mkFreshLevelMVar\n  let \u03b2 \u2190 mkFreshExprMVar (mkSort v)\n  let .some inst \u2190 trySynthInstance (mkApp2 (.const ``CoeSort [u,v]) \u03b1 \u03b2) | return none\n  let expanded \u2190 expandCoe (mkApp4 (.const ``CoeSort.coe [u,v]) \u03b1 \u03b2 inst expr)\n  unless (\u2190 whnf (\u2190 inferType expanded)).isSort do\n    throwError \"failed to coerce{indentExpr expr}\\nto a type, after applying `CoeSort.coe`, result is still not a type{indentExpr expanded}\\nthis is often due to incorrect `CoeSort` instances, the synthesized instance was{indentExpr inst}\"\n  return expanded", "start": [68, 1], "end": [79, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isTypeApp?", "code": "def isTypeApp? (type : Expr) : MetaM (Option (Expr \u00d7 Expr)) := do\n  let type \u2190 withReducible <| whnf type\n  match type with\n  | .app m \u03b1 => return some ((\u2190 instantiateMVars m), (\u2190 instantiateMVars \u03b1))\n  | _        => return none", "start": [81, 1], "end": [86, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isMonadApp", "code": "def isMonadApp (type : Expr) : MetaM Bool := do\n  let some (m, _) \u2190 isTypeApp? type | return false\n  return (\u2190 isMonad? m).isSome", "start": [88, 1], "end": [94, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.coerceMonadLift?", "code": "def coerceMonadLift? (e expectedType : Expr) : MetaM (Option Expr) := do\n  let expectedType \u2190 instantiateMVars expectedType\n  let eType \u2190 instantiateMVars (\u2190 inferType e)\n  let some (n, \u03b2) \u2190 isTypeApp? expectedType | return none\n  let some (m, \u03b1) \u2190 isTypeApp? eType | return none\n  if (\u2190 isDefEq m n) then\n    let some monadInst \u2190 isMonad? n | return none\n    try expandCoe (\u2190 mkAppOptM ``Lean.Internal.coeM #[m, \u03b1, \u03b2, none, monadInst, e]) catch _ => return none\n  else if autoLift.get (\u2190 getOptions) then\n    try\n      let .forallE _ (.sort um\u2081) (.sort um\u2082) _ \u2190 whnf (\u2190 inferType m) | return none\n      let .forallE _ (.sort un\u2081) (.sort un\u2082) _ \u2190 whnf (\u2190 inferType n) | return none\n      let u \u2190 decLevel um\u2081\n      let .true \u2190 isLevelDefEq u (\u2190 decLevel un\u2081) | return none\n      let v \u2190 decLevel um\u2082\n      let w \u2190 decLevel un\u2082\n      let monadLiftType := mkAppN (.const ``MonadLiftT [u, v, w]) #[m, n]\n      let .some monadLiftVal \u2190 trySynthInstance monadLiftType | return none\n      let u_1 \u2190 getDecLevel \u03b1\n      let u_2 \u2190 getDecLevel eType\n      let u_3 \u2190 getDecLevel expectedType\n      let eNew := mkAppN (Lean.mkConst ``liftM [u_1, u_2, u_3]) #[m, n, monadLiftVal, \u03b1, e]\n      let eNewType \u2190 inferType eNew\n      if (\u2190 isDefEq expectedType eNewType) then\n        return some eNew else\n        let some monadInst \u2190 isMonad? n | return none\n        let u \u2190 getLevel \u03b1\n        let v \u2190 getLevel \u03b2\n        let coeTInstType := Lean.mkForall `a BinderInfo.default \u03b1 <| mkAppN (mkConst ``CoeT [u, v]) #[\u03b1, mkBVar 0, \u03b2]\n        let .some coeTInstVal \u2190 trySynthInstance coeTInstType | return none\n        let eNew \u2190 expandCoe (mkAppN (Lean.mkConst ``Lean.Internal.liftCoeM [u_1, u_2, u_3]) #[m, n, \u03b1, \u03b2, monadLiftVal, coeTInstVal, monadInst, e])\n        let eNewType \u2190 inferType eNew\n        unless (\u2190 isDefEq expectedType eNewType) do return none\n        return some eNew catch _ =>\n      \n      return none\n  else\n    return none", "start": [96, 1], "end": [197, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.coerce?", "code": "def coerce? (expr expectedType : Expr) : MetaM (LOption Expr) := do\n  if let some lifted \u2190 coerceMonadLift? expr expectedType then\n    return .some lifted\n  if (\u2190 whnfR expectedType).isForall then\n    if let some fn \u2190 coerceToFunction? expr then\n      if \u2190 isDefEq (\u2190 inferType fn) expectedType then\n        return .some fn\n  coerceSimple? expr expectedType", "start": [199, 1], "end": [210, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Config.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.setElabConfig", "code": "def setElabConfig (cfg : Meta.Config) : Meta.Config :=\n  { cfg with foApprox := true, ctxApprox := true, constApprox := false, quasiPatternApprox := false }", "start": [10, 1], "end": [57, 102], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Level.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Level.lean", "lake-packages/lean4/src/lean/Lean/Log.lean", "lake-packages/lean4/src/lean/Lean/Elab/AutoBound.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Exception.lean"], "premises": [{"full_name": "Lean.Elab.Level.Context", "code": "structure Context where\n  options           : Options\n  ref               : Syntax\n  autoBoundImplicit : Bool", "start": [13, 1], "end": [16, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Level.State", "code": "structure State where\n  ngen       : NameGenerator\n  mctx       : MetavarContext\n  levelNames : List Name", "start": [18, 1], "end": [21, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Level.LevelElabM", "code": "abbrev LevelElabM := ReaderT Context (EStateM Exception State)", "start": [23, 1], "end": [23, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Level.mkFreshLevelMVar", "code": "def mkFreshLevelMVar : LevelElabM Level := do\n  let mvarId \u2190 mkFreshLMVarId\n  modify fun s => { s with mctx := s.mctx.addLevelMVarDecl mvarId }\n  return mkLevelMVar mvarId", "start": [41, 1], "end": [44, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Level.checkUniverseOffset", "code": "private def checkUniverseOffset [Monad m] [MonadError m] [MonadOptions m] (n : Nat) : m Unit := do\n  let max := maxUniverseOffset.get (\u2190 getOptions)\n  unless n <= max do\n    throwError \"maximum universe level offset threshold ({max}) has been reached, you can increase the limit using option `set_option maxUniverseOffset <limit>`, but you are probably misusing universe levels since offsets are usually small natural numbers\"", "start": [51, 1], "end": [54, 257], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Level.elabLevel", "code": "partial def elabLevel (stx : Syntax) : LevelElabM Level := withRef stx do\n  let kind := stx.getKind\n  if kind == ``Lean.Parser.Level.paren then\n    elabLevel (stx.getArg 1)\n  else if kind == ``Lean.Parser.Level.max then\n    let args := stx.getArg 1 |>.getArgs\n    args[:args.size - 1].foldrM (init := \u2190 elabLevel args.back) fun stx lvl =>\n      return mkLevelMax' (\u2190 elabLevel stx) lvl\n  else if kind == ``Lean.Parser.Level.imax then\n    let args := stx.getArg 1 |>.getArgs\n    args[:args.size - 1].foldrM (init := \u2190 elabLevel args.back) fun stx lvl =>\n      return mkLevelIMax' (\u2190 elabLevel stx) lvl\n  else if kind == ``Lean.Parser.Level.hole then\n    mkFreshLevelMVar\n  else if kind == numLitKind then\n    match stx.isNatLit? with\n    | some val => checkUniverseOffset val; return Level.ofNat val\n    | none     => throwIllFormedSyntax\n  else if kind == identKind then\n    let paramName := stx.getId\n    unless (\u2190 get).levelNames.contains paramName do\n      if (\u2190 read).autoBoundImplicit && isValidAutoBoundLevelName paramName (relaxedAutoImplicit.get (\u2190 read).options) then\n        modify fun s => { s with levelNames := paramName :: s.levelNames }\n      else\n        throwError \"unknown universe level '{paramName}'\"\n    return mkLevelParam paramName\n  else if kind == `Lean.Parser.Level.addLit then\n    let lvl \u2190 elabLevel (stx.getArg 0)\n    match stx.getArg 2 |>.isNatLit? with\n    | some val => checkUniverseOffset val; return lvl.addOffset val\n    | none     => throwIllFormedSyntax\n  else\n    throwError \"unexpected universe level syntax kind\"", "start": [56, 1], "end": [88, 55], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/DeclModifiers.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Structure.lean", "lake-packages/lean4/src/lean/Lean/Elab/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.checkNotAlreadyDeclared", "code": "def checkNotAlreadyDeclared {m} [Monad m] [MonadEnv m] [MonadError m] [MonadInfoTree m] (declName : Name) : m Unit := do\n  let env \u2190 getEnv\n  let addInfo declName := do\n    pushInfoLeaf <| .ofTermInfo {\n      elaborator := .anonymous, lctx := {}, expectedType? := none\n      stx := (\u2190 getRef)\n      expr := (\u2190 mkConstWithLevelParams declName)\n    }\n  if env.contains declName then\n    addInfo declName\n    match privateToUserName? declName with\n    | none          => throwError \"'{declName}' has already been declared\"\n    | some declName => throwError \"private declaration '{declName}' has already been declared\"\n  if env.contains (mkPrivateName env declName) then\n    addInfo (mkPrivateName env declName)\n    throwError \"a private declaration '{declName}' has already been declared\"\n  match privateToUserName? declName with\n  | none => pure ()\n  | some declName =>\n    if env.contains declName then\n      addInfo declName\n      throwError \"a non-private declaration '{declName}' has already been declared\"", "start": [11, 1], "end": [37, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Visibility", "code": "inductive Visibility where\n  | regular | \u00abprotected\u00bb | \u00abprivate\u00bb\n  deriving Inhabited", "start": [39, 1], "end": [42, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.RecKind", "code": "inductive RecKind where\n  | \u00abpartial\u00bb | \u00abnonrec\u00bb | default\n  deriving Inhabited", "start": [50, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Modifiers", "code": "structure Modifiers where\n  docString?      : Option String := none\n  visibility      : Visibility := Visibility.regular\n  isNoncomputable : Bool := false\n  recKind         : RecKind := RecKind.default\n  isUnsafe        : Bool := false\n  attrs           : Array Attribute := #[]\n  deriving Inhabited", "start": [55, 1], "end": [63, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Modifiers.isPrivate", "code": "def Modifiers.isPrivate : Modifiers \u2192 Bool\n  | { visibility := .private, .. } => true\n  | _                              => false", "start": [65, 1], "end": [67, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Modifiers.isProtected", "code": "def Modifiers.isProtected : Modifiers \u2192 Bool\n  | { visibility := .protected, .. } => true\n  | _                                => false", "start": [69, 1], "end": [71, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Modifiers.isPartial", "code": "def Modifiers.isPartial : Modifiers \u2192 Bool\n  | { recKind := .partial, .. } => true\n  | _                           => false", "start": [73, 1], "end": [75, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Modifiers.isNonrec", "code": "def Modifiers.isNonrec : Modifiers \u2192 Bool\n  | { recKind := .nonrec, .. } => true\n  | _                          => false", "start": [77, 1], "end": [79, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Modifiers.addAttribute", "code": "def Modifiers.addAttribute (modifiers : Modifiers) (attr : Attribute) : Modifiers :=\n  { modifiers with attrs := modifiers.attrs.push attr }", "start": [81, 1], "end": [83, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.expandOptDocComment?", "code": "def expandOptDocComment? [Monad m] [MonadError m] (optDocComment : Syntax) : m (Option String) :=\n  match optDocComment.getOptional? with\n  | none   => return none\n  | some s => match s[1] with\n    | .atom _ val => return some (val.extract 0 (val.endPos - \u27e82\u27e9))\n    | _           => throwErrorAt s \"unexpected doc string{indentD s[1]}\"", "start": [102, 1], "end": [110, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.elabModifiers", "code": "def elabModifiers (stx : Syntax) : m Modifiers := do\n  let docCommentStx := stx[0]\n  let attrsStx      := stx[1]\n  let visibilityStx := stx[2]\n  let noncompStx    := stx[3]\n  let unsafeStx     := stx[4]\n  let recKind       :=\n    if stx[5].isNone then\n      RecKind.default\n    else if stx[5][0].getKind == ``Parser.Command.partial then\n      RecKind.partial\n    else\n      RecKind.nonrec\n  let docString? \u2190 match docCommentStx.getOptional? with\n    | none   => pure none\n    | some s => pure (some (\u2190 getDocStringText \u27e8s\u27e9))\n  let visibility \u2190 match visibilityStx.getOptional? with\n    | none   => pure Visibility.regular\n    | some v =>\n      let kind := v.getKind\n      if kind == ``Parser.Command.private then pure Visibility.private\n      else if kind == ``Parser.Command.protected then pure Visibility.protected\n      else throwErrorAt v \"unexpected visibility modifier\"\n  let attrs \u2190 match attrsStx.getOptional? with\n    | none       => pure #[]\n    | some attrs => elabDeclAttrs attrs\n  return {\n    docString?, visibility, recKind, attrs,\n    isUnsafe        := !unsafeStx.isNone\n    isNoncomputable := !noncompStx.isNone\n  }", "start": [116, 1], "end": [147, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.applyVisibility", "code": "def applyVisibility (visibility : Visibility) (declName : Name) : m Name := do\n  match visibility with\n  | .private =>\n    let declName := mkPrivateName (\u2190 getEnv) declName\n    checkNotAlreadyDeclared declName\n    return declName\n  | .protected =>\n    checkNotAlreadyDeclared declName\n    modifyEnv fun env => addProtected env declName\n    return declName\n  | _ =>\n    checkNotAlreadyDeclared declName\n    pure declName", "start": [149, 1], "end": [166, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.checkIfShadowingStructureField", "code": "def checkIfShadowingStructureField (declName : Name) : m Unit := do\n  match declName with\n  | Name.str pre .. =>\n    if isStructure (\u2190 getEnv) pre then\n      let fieldNames := getStructureFieldsFlattened (\u2190 getEnv) pre\n      for fieldName in fieldNames do\n        if pre ++ fieldName == declName then\n          throwError \"invalid declaration name '{declName}', structure '{pre}' has field '{fieldName}'\"\n  | _ => pure ()", "start": [168, 1], "end": [176, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.mkDeclName", "code": "def mkDeclName (currNamespace : Name) (modifiers : Modifiers) (shortName : Name) : m (Name \u00d7 Name) := do\n  let mut shortName := shortName\n  let mut currNamespace := currNamespace\n  let view := extractMacroScopes shortName\n  let name := view.name\n  let isRootName := (`_root_).isPrefixOf name\n  if name == `_root_ then\n    throwError \"invalid declaration name `_root_`, `_root_` is a prefix used to refer to the 'root' namespace\"\n  let declName := if isRootName then { view with name := name.replacePrefix `_root_ Name.anonymous }.review else currNamespace ++ shortName\n  if isRootName then\n    let .str p s := name | throwError \"invalid declaration name '{name}'\"\n    shortName := Name.mkSimple s\n    currNamespace := p.replacePrefix `_root_ Name.anonymous\n  checkIfShadowingStructureField declName\n  let declName \u2190 applyVisibility modifiers.visibility declName\n  match modifiers.visibility with\n  | Visibility.protected =>\n    match currNamespace with\n    | .str _ s => return (declName, Name.mkSimple s ++ shortName)\n    | _ =>\n      if shortName.isAtomic then\n        throwError \"protected declarations must be in a namespace\"\n      return (declName, shortName)\n  | _ => return (declName, shortName)", "start": [178, 1], "end": [201, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.expandDeclIdCore", "code": "def expandDeclIdCore (declId : Syntax) : Name \u00d7 Syntax :=\n  if declId.isIdent then\n    (declId.getId, mkNullNode)\n  else\n    let id             := declId[0].getId\n    let optUnivDeclStx := declId[1]\n    (id, optUnivDeclStx)", "start": [203, 1], "end": [216, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.ExpandDeclIdResult", "code": "structure ExpandDeclIdResult where\n  \n  shortName  : Name\n  \n  declName   : Name\n  \n  levelNames : List Name", "start": [218, 1], "end": [225, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.expandDeclId", "code": "def expandDeclId (currNamespace : Name) (currLevelNames : List Name) (declId : Syntax) (modifiers : Modifiers) : m ExpandDeclIdResult := do\n  let (shortName, optUnivDeclStx) := expandDeclIdCore declId\n  let levelNames \u2190 if optUnivDeclStx.isNone then\n    pure currLevelNames\n  else\n    let extraLevels := optUnivDeclStx[1].getArgs.getEvenElems\n    extraLevels.foldlM\n      (fun levelNames idStx =>\n        let id := idStx.getId\n        if levelNames.elem id then\n          withRef idStx <| throwAlreadyDeclaredUniverseLevel id\n        else\n          pure (id :: levelNames))\n      currLevelNames\n  let (declName, shortName) \u2190 withRef declId <| mkDeclName currNamespace modifiers shortName\n  addDocString' declName modifiers.docString?\n  return { shortName := shortName, declName := declName, levelNames := levelNames }", "start": [227, 1], "end": [254, 84], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/SubExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/SubExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.PrettyPrinter.Delaborator.OptionsPerPos", "code": "abbrev OptionsPerPos := RBMap SubExpr.Pos Options compare", "start": [18, 1], "end": [18, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.getExpr", "code": "def getExpr : m Expr := return (\u2190 readThe SubExpr).expr", "start": [33, 1], "end": [33, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.getPos", "code": "def getPos  : m Pos  := return (\u2190 readThe SubExpr).pos", "start": [34, 1], "end": [34, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.descend", "code": "def descend (child : Expr) (childIdx : Nat) (x : m \u03b1) : m \u03b1 :=\n  withTheReader SubExpr (fun cfg => { cfg with expr := child, pos := cfg.pos.push childIdx }) x", "start": [36, 1], "end": [37, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn", "code": "def withAppFn   (x : m \u03b1) : m \u03b1 := do descend (\u2190 getExpr).appFn!  0 x", "start": [39, 1], "end": [39, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg", "code": "def withAppArg  (x : m \u03b1) : m \u03b1 := do descend (\u2190 getExpr).appArg! 1 x", "start": [40, 1], "end": [40, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withType", "code": "def withType (x : m \u03b1) : m \u03b1 := do\n  descend (\u2190 Meta.inferType (\u2190 getExpr)) Pos.typeCoord x", "start": [42, 1], "end": [43, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withAppFnArgs", "code": "partial def withAppFnArgs (xf : m \u03b1) (xa : \u03b1 \u2192 m \u03b1) : m \u03b1 := do\n  if (\u2190 getExpr).isApp then\n    let acc \u2190 withAppFn (withAppFnArgs xf xa)\n    withAppArg (xa acc)\n  else xf", "start": [45, 1], "end": [49, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain", "code": "def withBindingDomain (x : m \u03b1) : m \u03b1 := do descend (\u2190 getExpr).bindingDomain! 0 x", "start": [51, 1], "end": [51, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody", "code": "def withBindingBody (n : Name) (x : m \u03b1) : m \u03b1 := do\n  let e \u2190 getExpr\n  Meta.withLocalDecl n e.binderInfo e.bindingDomain! fun fvar =>\n    descend (e.bindingBody!.instantiate1 fvar) 1 x", "start": [53, 1], "end": [56, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withProj", "code": "def withProj (x : m \u03b1) : m \u03b1 := do\n  let Expr.proj _ _ e \u2190 getExpr | unreachable!\n  descend e 0 x", "start": [58, 1], "end": [60, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withMDataExpr", "code": "def withMDataExpr (x : m \u03b1) : m \u03b1 := do\n  let Expr.mdata _ e \u2190 getExpr | unreachable!\n  withTheReader SubExpr (fun ctx => { ctx with expr := e }) x", "start": [62, 1], "end": [64, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withLetVarType", "code": "def withLetVarType (x : m \u03b1) : m \u03b1 := do\n  let Expr.letE _ t _ _ _ \u2190 getExpr | unreachable!\n  descend t 0 x", "start": [66, 1], "end": [68, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withLetValue", "code": "def withLetValue (x : m \u03b1) : m \u03b1 := do\n  let Expr.letE _ _ v _ _ \u2190 getExpr | unreachable!\n  descend v 1 x", "start": [70, 1], "end": [72, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withLetBody", "code": "def withLetBody (x : m \u03b1) : m \u03b1 := do\n  let Expr.letE n t v b _ \u2190 getExpr | unreachable!\n  Meta.withLetDecl n t v fun fvar =>\n    let b := b.instantiate1 fvar\n    descend b 2 x", "start": [74, 1], "end": [78, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withNaryFn", "code": "def withNaryFn (x : m \u03b1) : m \u03b1 := do\n  let e \u2190 getExpr\n  let newPos := (\u2190 getPos).pushNaryFn e.getAppNumArgs\n  withTheReader SubExpr (fun cfg => { cfg with expr := e.getAppFn, pos := newPos }) x", "start": [80, 1], "end": [83, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.withNaryArg", "code": "def withNaryArg (argIdx : Nat) (x : m \u03b1) : m \u03b1 := do\n  let e \u2190 getExpr\n  let args := e.getAppArgs\n  let newPos := (\u2190 getPos).pushNaryArg args.size argIdx\n  withTheReader SubExpr (fun cfg => { cfg with expr := args[argIdx]!, pos := newPos }) x", "start": [85, 1], "end": [89, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator", "code": "structure HoleIterator where\n  curr : Nat := 2\n  top  : Nat := Pos.maxChildren\n  deriving Inhabited", "start": [93, 1], "end": [96, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.toPos", "code": "def HoleIterator.toPos (iter : HoleIterator) : Pos :=\n  iter.curr", "start": [104, 1], "end": [105, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.next", "code": "def HoleIterator.next (iter : HoleIterator) : HoleIterator :=\n  if (iter.curr+1) == iter.top then\n    \u27e82*iter.top, Pos.maxChildren*iter.top\u27e9\n  else \u27e8iter.curr+1, iter.top\u27e9", "start": [107, 1], "end": [110, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.SubExpr.nextExtraPos", "code": "def nextExtraPos : m Pos := do\n  let iter \u2190 getThe HoleIterator\n  let pos := iter.toPos\n  modifyThe HoleIterator HoleIterator.next\n  return pos", "start": [112, 1], "end": [119, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/FindMVar.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.FindMVar.Visitor", "code": "abbrev Visitor := Option MVarId \u2192 Option MVarId", "start": [12, 1], "end": [12, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.FindMVar.visit", "code": "partial def visit (p : MVarId \u2192 Bool) (e : Expr) : Visitor := fun s =>\n    if s.isSome || !e.hasMVar then s else main p e s", "start": [15, 3], "end": [16, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.FindMVar.main", "code": "partial def main (p : MVarId \u2192 Bool) : Expr \u2192 Visitor\n    | Expr.proj _ _ e      => visit p e\n    | Expr.forallE _ d b _ => visit p b \u2218 visit p d\n    | Expr.lam _ d b _     => visit p b \u2218 visit p d\n    | Expr.letE _ t v b _  => visit p b \u2218 visit p v \u2218 visit p t\n    | Expr.app f a         => visit p a \u2218 visit p f\n    | Expr.mdata _ b       => visit p b\n    | Expr.mvar mvarId     => fun s => if s.isNone && p mvarId then some mvarId else s\n    | _                    => id", "start": [18, 3], "end": [26, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.findMVar?", "code": "@[inline] def Expr.findMVar? (e : Expr) (p : MVarId \u2192 Bool) : Option MVarId :=\n  FindMVar.main p e none", "start": [31, 1], "end": [32, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/FindLevelMVar.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.FindLevelMVar.Visitor", "code": "abbrev Visitor := Option LMVarId \u2192 Option LMVarId", "start": [12, 1], "end": [12, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.FindLevelMVar.visit", "code": "partial def visit (p : LMVarId \u2192 Bool) (e : Expr) : Visitor := fun s =>\n    if s.isSome || !e.hasLevelMVar then s else main p e s", "start": [15, 3], "end": [16, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.FindLevelMVar.main", "code": "partial def main (p : LMVarId \u2192 Bool) : Expr \u2192 Visitor\n    | .sort l          => visitLevel p l\n    | .const _ ls      => ls.foldr (init := id) fun l acc => visitLevel p l \u2218 acc\n    | .forallE _ d b _ => visit p b \u2218 visit p d\n    | .lam _ d b _     => visit p b \u2218 visit p d\n    | .letE _ t v b _  => visit p b \u2218 visit p v \u2218 visit p t\n    | .app f a         => visit p a \u2218 visit p f\n    | .mdata _ b       => visit p b\n    | .proj _ _ e      => visit p e\n    | _                    => id", "start": [18, 3], "end": [27, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.FindLevelMVar.visitLevel", "code": "partial def visitLevel (p : LMVarId \u2192 Bool) (l : Level) : Visitor := fun s =>\n    if s.isSome || !l.hasMVar then s else mainLevel p l s", "start": [29, 3], "end": [30, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.FindLevelMVar.mainLevel", "code": "partial def mainLevel (p : LMVarId \u2192 Bool) : Level \u2192 Visitor\n    | .zero        => id\n    | .succ l      => visitLevel p l\n    | .max l\u2081 l\u2082   => visitLevel p l\u2081 \u2218 visitLevel p l\u2082\n    | .imax l\u2081 l\u2082  => visitLevel p l\u2081 \u2218 visitLevel p l\u2082\n    | .param _     => id\n    | .mvar mvarId => fun s => if p mvarId then some mvarId else s", "start": [32, 3], "end": [38, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.findLevelMVar?", "code": "@[inline] def Expr.findLevelMVar? (e : Expr) (p : LMVarId \u2192 Bool) : Option LMVarId :=\n  FindLevelMVar.main p e none", "start": [43, 1], "end": [44, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/CollectLevelParams.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.CollectLevelParams.State", "code": "structure State where\n  visitedLevel : LevelSet   := {}\n  visitedExpr  : ExprSet    := {}\n  params       : Array Name := #[]", "start": [12, 1], "end": [15, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectLevelParams.Visitor", "code": "abbrev Visitor := State \u2192 State", "start": [19, 1], "end": [19, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectLevelParams.visitLevel", "code": "partial def visitLevel (u : Level) : Visitor := fun s =>\n    if !u.hasParam || s.visitedLevel.contains u then s\n    else collect u { s with visitedLevel := s.visitedLevel.insert u }", "start": [22, 3], "end": [24, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectLevelParams.collect", "code": "partial def collect : Level \u2192 Visitor\n    | .succ v    => visitLevel v\n    | .max u v   => visitLevel v \u2218 visitLevel u\n    | .imax u v  => visitLevel v \u2218 visitLevel u\n    | .param n   => fun s => { s with params := s.params.push n }\n    | _          => id", "start": [26, 3], "end": [31, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectLevelParams.visitLevels", "code": "def visitLevels (us : List Level) : Visitor :=\n  fun s => us.foldl (fun s u => visitLevel u s) s", "start": [34, 1], "end": [35, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectLevelParams.visitExpr", "code": "partial def visitExpr (e : Expr) : Visitor := fun s =>\n    if !e.hasLevelParam then s\n    else if s.visitedExpr.contains e then s\n    else main e { s with visitedExpr := s.visitedExpr.insert e }", "start": [38, 3], "end": [41, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectLevelParams.main", "code": "partial def main : Expr \u2192 Visitor\n    | .proj _ _ s      => visitExpr s\n    | .forallE _ d b _ => visitExpr b \u2218 visitExpr d\n    | .lam _ d b _     => visitExpr b \u2218 visitExpr d\n    | .letE _ t v b _  => visitExpr b \u2218 visitExpr v \u2218 visitExpr t\n    | .app f a         => visitExpr a \u2218 visitExpr f\n    | .mdata _ b       => visitExpr b\n    | .const _ us      => visitLevels us\n    | .sort u          => visitLevel u\n    | _                => id", "start": [43, 3], "end": [52, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectLevelParams.State.getUnusedLevelParam", "code": "partial def State.getUnusedLevelParam (s : CollectLevelParams.State) (pre : Name := `v) : Level :=\n  let v := mkLevelParam pre;\n  if s.visitedLevel.contains v then\n    let rec loop (i : Nat) :=\n      let v := mkLevelParam (pre.appendIndexAfter i);\n      if s.visitedLevel.contains v then loop (i+1) else v\n    loop 1\n  else\n    v", "start": [55, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.collectLevelParams", "code": "def collectLevelParams (s : CollectLevelParams.State) (e : Expr) : CollectLevelParams.State :=\n  CollectLevelParams.main e s", "start": [67, 1], "end": [68, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectLevelParams.State.collect", "code": "def CollectLevelParams.State.collect (s : CollectLevelParams.State) (e : Expr) : CollectLevelParams.State :=\n  collectLevelParams s e", "start": [70, 1], "end": [71, 25], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Options.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.getPPAll", "code": "def getPPAll (o : Options) : Bool := o.get pp.all.name false", "start": [182, 1], "end": [182, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPFunBinderTypes", "code": "def getPPFunBinderTypes (o : Options) : Bool := o.get pp.funBinderTypes.name (getPPAll o)", "start": [183, 1], "end": [183, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPPiBinderTypes", "code": "def getPPPiBinderTypes (o : Options) : Bool := o.get pp.piBinderTypes.name pp.piBinderTypes.defValue", "start": [184, 1], "end": [184, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPLetVarTypes", "code": "def getPPLetVarTypes (o : Options) : Bool := o.get pp.letVarTypes.name (getPPAll o)", "start": [185, 1], "end": [185, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPCoercions", "code": "def getPPCoercions (o : Options) : Bool := o.get pp.coercions.name (!getPPAll o)", "start": [186, 1], "end": [186, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPExplicit", "code": "def getPPExplicit (o : Options) : Bool := o.get pp.explicit.name (getPPAll o)", "start": [187, 1], "end": [187, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPNotation", "code": "def getPPNotation (o : Options) : Bool := o.get pp.notation.name (!getPPAll o)", "start": [188, 1], "end": [188, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPUnicodeFun", "code": "def getPPUnicodeFun (o : Options) : Bool := o.get pp.unicode.fun.name false", "start": [189, 1], "end": [189, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPMatch", "code": "def getPPMatch (o : Options) : Bool := o.get pp.match.name (!getPPAll o)", "start": [190, 1], "end": [190, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPStructureProjections", "code": "def getPPStructureProjections (o : Options) : Bool := o.get pp.structureProjections.name (!getPPAll o)", "start": [191, 1], "end": [191, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPStructureInstances", "code": "def getPPStructureInstances (o : Options) : Bool := o.get pp.structureInstances.name (!getPPAll o)", "start": [192, 1], "end": [192, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPStructureInstanceType", "code": "def getPPStructureInstanceType (o : Options) : Bool := o.get pp.structureInstanceTypes.name (getPPAll o)", "start": [193, 1], "end": [193, 105], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPTagAppFns", "code": "def getPPTagAppFns (o : Options) : Bool := o.get pp.tagAppFns.name (getPPAll o)", "start": [194, 1], "end": [194, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPUniverses", "code": "def getPPUniverses (o : Options) : Bool := o.get pp.universes.name (getPPAll o)", "start": [195, 1], "end": [195, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPFullNames", "code": "def getPPFullNames (o : Options) : Bool := o.get pp.fullNames.name (getPPAll o)", "start": [196, 1], "end": [196, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPPrivateNames", "code": "def getPPPrivateNames (o : Options) : Bool := o.get pp.privateNames.name (getPPAll o)", "start": [197, 1], "end": [197, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPInstantiateMVars", "code": "def getPPInstantiateMVars (o : Options) : Bool := o.get pp.instantiateMVars.name pp.instantiateMVars.defValue", "start": [198, 1], "end": [198, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPSafeShadowing", "code": "def getPPSafeShadowing (o : Options) : Bool := o.get pp.safeShadowing.name pp.safeShadowing.defValue", "start": [199, 1], "end": [199, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPProofs", "code": "def getPPProofs (o : Options) : Bool := o.get pp.proofs.name (getPPAll o)", "start": [200, 1], "end": [200, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPProofsWithType", "code": "def getPPProofsWithType (o : Options) : Bool := o.get pp.proofs.withType.name pp.proofs.withType.defValue", "start": [201, 1], "end": [201, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPMotivesPi", "code": "def getPPMotivesPi (o : Options) : Bool := o.get pp.motives.pi.name pp.motives.pi.defValue", "start": [202, 1], "end": [202, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPMotivesNonConst", "code": "def getPPMotivesNonConst (o : Options) : Bool := o.get pp.motives.nonConst.name pp.motives.nonConst.defValue", "start": [203, 1], "end": [203, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPMotivesAll", "code": "def getPPMotivesAll (o : Options) : Bool := o.get pp.motives.all.name pp.motives.all.defValue", "start": [204, 1], "end": [204, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPInstances", "code": "def getPPInstances (o : Options) : Bool := o.get pp.instances.name pp.instances.defValue", "start": [205, 1], "end": [205, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPInstanceTypes", "code": "def getPPInstanceTypes (o : Options) : Bool := o.get pp.instanceTypes.name pp.instanceTypes.defValue", "start": [206, 1], "end": [206, 101], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/ReplaceLevel.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Level.replace", "code": "partial def replace (f? : Level \u2192 Option Level) (u : Level) : Level :=\n  match f? u with\n  | some v => v\n  | none   => match u with\n    | max v\u2081 v\u2082  => mkLevelMax' (replace f? v\u2081) (replace f? v\u2082)\n    | imax v\u2081 v\u2082 => mkLevelIMax' (replace f? v\u2081) (replace f? v\u2082)\n    | succ v     => mkLevelSucc (replace f? v)\n    | _          => u", "start": [11, 1], "end": [18, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceLevelImpl.cacheSize", "code": "abbrev cacheSize : USize := 8192 - 1", "start": [26, 1], "end": [26, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceLevelImpl.State", "code": "structure State where\n  keys    : Array Expr results : Array Expr", "start": [28, 1], "end": [30, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceLevelImpl.ReplaceM", "code": "abbrev ReplaceM := StateM State", "start": [32, 1], "end": [32, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceLevelImpl.cache", "code": "unsafe def cache (i : USize) (key : Expr) (result : Expr) : ReplaceM Expr := do\n  modify fun s => { keys := s.keys.uset i key lcProof, results := s.results.uset i result lcProof };\n  pure result", "start": [34, 1], "end": [36, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceLevelImpl.replaceUnsafeM", "code": "unsafe def replaceUnsafeM (f? : Level \u2192 Option Level) (size : USize) (e : Expr) : ReplaceM Expr := do\n  let rec visit (e : Expr) := do\n    let c \u2190 get\n    let h := ptrAddrUnsafe e\n    let i := h % size\n    if ptrAddrUnsafe (c.keys.uget i lcProof) == h then\n      pure <| c.results.uget i lcProof\n    else match e with\n        | Expr.forallE _ d b _   => cache i e <| e.updateForallE! (\u2190 visit d) (\u2190 visit b)\n        | Expr.lam _ d b _       => cache i e <| e.updateLambdaE! (\u2190 visit d) (\u2190 visit b)\n        | Expr.mdata _ b         => cache i e <| e.updateMData! (\u2190 visit b)\n        | Expr.letE _ t v b _    => cache i e <| e.updateLet! (\u2190 visit t) (\u2190 visit v) (\u2190 visit b)\n        | Expr.app f a           => cache i e <| e.updateApp! (\u2190 visit f) (\u2190 visit a)\n        | Expr.proj _ _ b        => cache i e <| e.updateProj! (\u2190 visit b)\n        | Expr.sort u            => cache i e <| e.updateSort! (u.replace f?)\n        | Expr.const _ us        => cache i e <| e.updateConst! (us.map (Level.replace f?))\n        | e                      => pure e\n  visit e", "start": [38, 1], "end": [55, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceLevelImpl.initCache", "code": "unsafe def initCache : State :=\n  { keys    := mkArray cacheSize.toNat (cast lcProof ()), results := mkArray cacheSize.toNat default }", "start": [57, 1], "end": [59, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.ReplaceLevelImpl.replaceUnsafe", "code": "unsafe def replaceUnsafe (f? : Level \u2192 Option Level) (e : Expr) : Expr :=\n  (replaceUnsafeM f? cacheSize e).run' initCache", "start": [61, 1], "end": [62, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.replaceLevel", "code": "@[implemented_by ReplaceLevelImpl.replaceUnsafe]\npartial def replaceLevel (f? : Level \u2192 Option Level) : Expr \u2192 Expr\n  | e@(Expr.forallE _ d b _)   => let d := replaceLevel f? d; let b := replaceLevel f? b; e.updateForallE! d b\n  | e@(Expr.lam _ d b _)       => let d := replaceLevel f? d; let b := replaceLevel f? b; e.updateLambdaE! d b\n  | e@(Expr.mdata _ b)         => let b := replaceLevel f? b; e.updateMData! b\n  | e@(Expr.letE _ t v b _)    => let t := replaceLevel f? t; let v := replaceLevel f? v; let b := replaceLevel f? b; e.updateLet! t v b\n  | e@(Expr.app f a)           => let f := replaceLevel f? f; let a := replaceLevel f? a; e.updateApp! f a\n  | e@(Expr.proj _ _ b)        => let b := replaceLevel f? b; e.updateProj! b\n  | e@(Expr.sort u)            => e.updateSort! (u.replace f?)\n  | e@(Expr.const _ us)        => e.updateConst! (us.map (Level.replace f?))\n  | e                          => e", "start": [66, 1], "end": [76, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/ForEachExprWhere.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Util/MonadCache.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ForEachExprWhere.cacheSize", "code": "abbrev cacheSize : USize := 8192 - 1", "start": [21, 1], "end": [21, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.ForEachExprWhere.State", "code": "structure State where\n  \n  visited : Array Expr   \n  checked : HashSet Expr", "start": [23, 1], "end": [32, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.ForEachExprWhere.initCache", "code": "unsafe def initCache : State := {\n  visited := mkArray cacheSize.toNat (cast lcProof ())\n  checked := {}\n}", "start": [34, 1], "end": [37, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.ForEachExprWhere.ForEachM", "code": "abbrev ForEachM {\u03c9 : Type} (m : Type \u2192 Type) [STWorld \u03c9 m] [MonadLiftT (ST \u03c9) m] [Monad m] := StateRefT' \u03c9 State m", "start": [39, 1], "end": [39, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.ForEachExprWhere.visited", "code": "unsafe def visited (e : Expr) : ForEachM m Bool := do\n  let s \u2190 get\n  let h := ptrAddrUnsafe e\n  let i := h % cacheSize\n  let k := s.visited.uget i lcProof\n  if ptrAddrUnsafe k == h then\n    return true\n  else\n    modify fun s => { s with visited := s.visited.uset i e lcProof }\n    return false", "start": [41, 1], "end": [50, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.ForEachExprWhere.checked", "code": "def checked (e : Expr) : ForEachM m Bool := do\n  if (\u2190 get).checked.contains e then\n    return true\n  else\n    modify fun s => { s with checked := s.checked.insert e }\n    return false", "start": [52, 1], "end": [57, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.ForEachExprWhere.visit", "code": "unsafe def visit (p : Expr \u2192 Bool) (f : Expr \u2192 m Unit) (e : Expr) : m Unit := do\n  go e |>.run' initCache\nwhere\n  go (e : Expr) : StateRefT' \u03c9 State m Unit := do\n    unless (\u2190 visited e) do\n      if p e then\n        unless (\u2190 checked e) do\n          f e\n      match e with\n      | .forallE _ d b _   => go d; go b\n      | .lam _ d b _       => go d; go b\n      | .letE _ t v b _    => go t; go v; go b\n      | .app f a           => go f; go a\n      | .mdata _ b         => go b\n      | .proj _ _ b        => go b\n      | _                  => return ()", "start": [59, 1], "end": [75, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.forEachWhere", "code": "@[implemented_by ForEachExprWhere.visit]\nopaque Expr.forEachWhere {\u03c9 : Type} {m : Type \u2192 Type} [STWorld \u03c9 m] [MonadLiftT (ST \u03c9) m] [Monad m] (p : Expr \u2192 Bool) (f : Expr \u2192 m Unit) (e : Expr) : m Unit", "start": [79, 1], "end": [83, 158], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "lake-packages/lean4/src/lean/Lean/Meta/CollectMVars.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclModifiers.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Level.lean", "lake-packages/lean4/src/lean/Lean/Elab/Config.lean", "lake-packages/lean4/src/lean/Lean/Meta/Coe.lean", "lake-packages/lean4/src/lean/Lean/Linter/Deprecated.lean"], "premises": [{"full_name": "Lean.Elab.Term.SavedContext", "code": "structure SavedContext where\n  declName?  : Option Name\n  options    : Options\n  openDecls  : List OpenDecl\n  macroStack : MacroStack\n  errToSorry : Bool\n  levelNames : List Name", "start": [18, 1], "end": [25, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.SyntheticMVarKind", "code": "inductive SyntheticMVarKind where\n  \n  | typeClass\n  \n  | coe (header? : Option String) (expectedType : Expr) (e : Expr) (f? : Option Expr)\n  \n  | tactic (tacticCode : Syntax) (ctx : SavedContext)\n  \n  | postponed (ctx : SavedContext)\n  deriving Inhabited", "start": [27, 1], "end": [40, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.SyntheticMVarDecl", "code": "structure SyntheticMVarDecl where\n  stx : Syntax\n  kind : SyntheticMVarKind\n  deriving Inhabited", "start": [49, 1], "end": [52, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MVarErrorKind", "code": "inductive MVarErrorKind where\n  \n  | implicitArg (ctx : Expr)\n  \n  | hole\n  \n  | custom (msgData : MessageData)\n  deriving Inhabited", "start": [54, 1], "end": [65, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MVarErrorInfo", "code": "structure MVarErrorInfo where\n  mvarId    : MVarId\n  ref       : Syntax\n  kind      : MVarErrorKind\n  argName?  : Option Name := none\n  deriving Inhabited", "start": [73, 1], "end": [81, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.LetRecToLift", "code": "structure LetRecToLift where\n  ref            : Syntax\n  fvarId         : FVarId\n  attrs          : Array Attribute\n  shortDeclName  : Name\n  declName       : Name\n  lctx           : LocalContext\n  localInstances : LocalInstances\n  type           : Expr\n  val            : Expr\n  mvarId         : MVarId\n  deriving Inhabited", "start": [83, 1], "end": [98, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.State", "code": "structure State where\n  levelNames        : List Name       := []\n  syntheticMVars    : MVarIdMap SyntheticMVarDecl := {}\n  pendingMVars      : List MVarId := {}\n  mvarErrorInfos    : MVarIdMap MVarErrorInfo := {}\n  letRecsToLift     : List LetRecToLift := []\n  deriving Inhabited", "start": [100, 1], "end": [109, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.State", "code": "structure State where\n  goals : List MVarId\n  deriving Inhabited", "start": [115, 1], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Snapshot", "code": "structure Snapshot where\n  core   : Core.State\n  meta   : Meta.State\n  term   : Term.State\n  tactic : Tactic.State\n  stx    : Syntax", "start": [122, 1], "end": [133, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.CacheKey", "code": "structure CacheKey where\n  mvarId : MVarId pos    : String.Pos\n  deriving BEq, Hashable, Inhabited", "start": [135, 1], "end": [141, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Cache", "code": "structure Cache where\n   pre  : PHashMap CacheKey Snapshot := {}\n   post : PHashMap CacheKey Snapshot := {}\n   deriving Inhabited", "start": [143, 1], "end": [149, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Context", "code": "structure Context where\n  declName? : Option Name := none\n  \n  auxDeclToFullName : FVarIdMap Name  := {}\n  macroStack        : MacroStack      := []\n  \n  mayPostpone : Bool := true\n  \n  errToSorry : Bool := true\n  \n  autoBoundImplicit  : Bool            := false\n  autoBoundImplicits : PArray Expr := {}\n  \n  autoBoundImplicitForbidden : Name \u2192 Bool := fun _ => false\n  \n  sectionVars        : NameMap Name    := {}\n  \n  sectionFVars       : NameMap Expr    := {}\n  \n  implicitLambda     : Bool            := true\n  \n  isNoncomputableSection : Bool        := false\n  \n  ignoreTCFailures : Bool := false\n  \n  inPattern        : Bool := false\n  \n  tacticCache?     : Option (IO.Ref Tactic.Cache) := none\n  \n  saveRecAppSyntax : Bool := true\n  \n  holesAsSyntheticOpaque : Bool := false", "start": [155, 1], "end": [219, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.TermElabM", "code": "abbrev TermElabM := ReaderT Context $ StateRefT State MetaM", "start": [221, 1], "end": [221, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.TermElab", "code": "abbrev TermElab  := Syntax \u2192 Option Expr \u2192 TermElabM Expr", "start": [222, 1], "end": [222, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.SavedState", "code": "structure SavedState where\n  meta   : Meta.SavedState\n  \u00abelab\u00bb : State\n  deriving Nonempty", "start": [238, 1], "end": [244, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.saveState", "code": "protected def saveState : TermElabM SavedState :=\n  return { meta := (\u2190 Meta.saveState), \u00abelab\u00bb := (\u2190 get) }", "start": [246, 1], "end": [247, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.SavedState.restore", "code": "def SavedState.restore (s : SavedState) (restoreInfo : Bool := false) : TermElabM Unit := do\n  let traceState \u2190 getTraceState let infoState \u2190 getInfoState s.meta.restore\n  set s.elab\n  setTraceState traceState\n  unless restoreInfo do\n    setInfoState infoState", "start": [249, 1], "end": [256, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.TermElabResult", "code": "abbrev TermElabResult (\u03b1 : Type) := EStateM.Result Exception SavedState \u03b1", "start": [262, 1], "end": [262, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.observing", "code": "def observing (x : TermElabM \u03b1) : TermElabM (TermElabResult \u03b1) := do\n  let s \u2190 saveState\n  try\n    let e \u2190 x\n    let sNew \u2190 saveState\n    s.restore (restoreInfo := true)\n    return EStateM.Result.ok e sNew\n  catch\n    | ex@(.error ..) =>\n      let sNew \u2190 saveState\n      s.restore (restoreInfo := true)\n      return .error ex sNew\n    | ex@(.internal id _) =>\n      if id == postponeExceptionId then\n        s.restore (restoreInfo := true)\n      throw ex", "start": [264, 1], "end": [286, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.applyResult", "code": "def applyResult (result : TermElabResult \u03b1) : TermElabM \u03b1 := do\n  match result with\n  | .ok a r     => r.restore (restoreInfo := true); return a\n  | .error ex r => r.restore (restoreInfo := true); throw ex", "start": [288, 1], "end": [294, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.commitIfDidNotPostpone", "code": "def commitIfDidNotPostpone (x : TermElabM \u03b1) : TermElabM \u03b1 := do\n  let r \u2190 observing x\n  applyResult r", "start": [296, 1], "end": [303, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getLevelNames", "code": "def getLevelNames : TermElabM (List Name) :=\n  return (\u2190 get).levelNames", "start": [305, 1], "end": [309, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getFVarLocalDecl!", "code": "def getFVarLocalDecl! (fvar : Expr) : TermElabM LocalDecl := do\n  match (\u2190 getLCtx).find? fvar.fvarId! with\n  | some d => pure d\n  | none   => unreachable!", "start": [311, 1], "end": [318, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo", "code": "def withoutModifyingElabMetaStateWithInfo (x : TermElabM \u03b1) : TermElabM \u03b1 := do\n  let s \u2190 get\n  let sMeta \u2190 getThe Meta.State\n  try\n    withSaveInfoContext x\n  finally\n    set s\n    set sMeta", "start": [328, 1], "end": [342, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withoutModifyingStateWithInfoAndMessagesImpl", "code": "private def withoutModifyingStateWithInfoAndMessagesImpl (x : TermElabM \u03b1) : TermElabM \u03b1 := do\n  let saved \u2190 saveState\n  try\n    withSaveInfoContext x\n  finally\n    let saved := { saved with meta.core.infoState := (\u2190 getInfoState), meta.core.messages := (\u2190 getThe Core.State).messages }\n    restoreState saved", "start": [344, 1], "end": [353, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withoutSavingRecAppSyntax", "code": "def withoutSavingRecAppSyntax (x : TermElabM \u03b1) : TermElabM \u03b1 :=\n  withReader (fun ctx => { ctx with saveRecAppSyntax := false }) x", "start": [355, 1], "end": [359, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkTermElabAttributeUnsafe", "code": "unsafe def mkTermElabAttributeUnsafe (ref : Name) : IO (KeyedDeclsAttribute TermElab) :=\n  mkElabAttribute TermElab `builtin_term_elab `term_elab `Lean.Parser.Term `Lean.Elab.Term.TermElab \"term\" ref", "start": [361, 1], "end": [362, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkTermElabAttribute", "code": "@[implemented_by mkTermElabAttributeUnsafe]\nopaque mkTermElabAttribute (ref : Name) : IO (KeyedDeclsAttribute TermElab)", "start": [364, 1], "end": [365, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.LVal", "code": "inductive LVal where\n  | fieldIdx  (ref : Syntax) (i : Nat)\n  \n  | fieldName (ref : Syntax) (name : String) (suffix? : Option Name) (targetStx : Syntax)", "start": [369, 1], "end": [379, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.LVal.getRef", "code": "def LVal.getRef : LVal \u2192 Syntax\n  | .fieldIdx ref _    => ref\n  | .fieldName ref ..  => ref", "start": [381, 1], "end": [383, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.LVal.isFieldName", "code": "def LVal.isFieldName : LVal \u2192 Bool\n  | .fieldName .. => true\n  | _ => false", "start": [385, 1], "end": [387, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getDeclName?", "code": "def getDeclName? : TermElabM (Option Name) := return (\u2190 read).declName?", "start": [394, 1], "end": [395, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getLetRecsToLift", "code": "def getLetRecsToLift : TermElabM (List LetRecToLift) := return (\u2190 get).letRecsToLift", "start": [396, 1], "end": [397, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getMVarDecl", "code": "def getMVarDecl (mvarId : MVarId) : TermElabM MetavarDecl := return (\u2190 getMCtx).getDecl mvarId", "start": [398, 1], "end": [399, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withDeclName", "code": "def withDeclName (name : Name) (x : TermElabM \u03b1) : TermElabM \u03b1 :=\n  withReader (fun ctx => { ctx with declName? := name }) x", "start": [401, 1], "end": [403, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.setLevelNames", "code": "def setLevelNames (levelNames : List Name) : TermElabM Unit :=\n  modify fun s => { s with levelNames := levelNames }", "start": [405, 1], "end": [407, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withLevelNames", "code": "def withLevelNames (levelNames : List Name) (x : TermElabM \u03b1) : TermElabM \u03b1 := do\n  let levelNamesSaved \u2190 getLevelNames\n  setLevelNames levelNames\n  try x finally setLevelNames levelNamesSaved", "start": [409, 1], "end": [413, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withAuxDecl", "code": "def withAuxDecl (shortDeclName : Name) (type : Expr) (declName : Name) (k : Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  withLocalDecl shortDeclName .default (kind := .auxDecl) type fun x =>\n    withReader (fun ctx => { ctx with auxDeclToFullName := ctx.auxDeclToFullName.insert x.fvarId! declName }) do\n      k x", "start": [415, 1], "end": [422, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withoutErrToSorryImp", "code": "def withoutErrToSorryImp (x : TermElabM \u03b1) : TermElabM \u03b1 :=\n  withReader (fun ctx => { ctx with errToSorry := false }) x", "start": [424, 1], "end": [425, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withoutErrToSorry", "code": "def withoutErrToSorry [MonadFunctorT TermElabM m] : m \u03b1 \u2192 m \u03b1 :=\n  monadMap (m := TermElabM) withoutErrToSorryImp", "start": [427, 1], "end": [432, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.throwErrorIfErrors", "code": "def throwErrorIfErrors : TermElabM Unit := do\n  if (\u2190 MonadLog.hasErrors) then\n    throwError \"Error(s)\"", "start": [434, 1], "end": [437, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.traceAtCmdPos", "code": "def traceAtCmdPos (cls : Name) (msg : Unit \u2192 MessageData) : TermElabM Unit :=\n  withRef Syntax.missing <| trace cls msg", "start": [439, 1], "end": [440, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ppGoal", "code": "def ppGoal (mvarId : MVarId) : TermElabM Format :=\n  Meta.ppGoal mvarId", "start": [442, 1], "end": [443, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.liftLevelM", "code": "def liftLevelM (x : LevelElabM \u03b1) : TermElabM \u03b1 := do\n  let ctx \u2190 read\n  let mctx \u2190 getMCtx\n  let ngen \u2190 getNGen\n  let lvlCtx : Level.Context := { options := (\u2190 getOptions), ref := (\u2190 getRef), autoBoundImplicit := ctx.autoBoundImplicit }\n  match (x lvlCtx).run { ngen := ngen, mctx := mctx, levelNames := (\u2190 getLevelNames) } with\n  | .ok a newS  => setMCtx newS.mctx; setNGen newS.ngen; setLevelNames newS.levelNames; pure a\n  | .error ex _ => throw ex", "start": [447, 1], "end": [454, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLevel", "code": "def elabLevel (stx : Syntax) : TermElabM Level :=\n  liftLevelM <| Level.elabLevel stx", "start": [456, 1], "end": [457, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withPushMacroExpansionStack", "code": "def withPushMacroExpansionStack (beforeStx afterStx : Syntax) (x : TermElabM \u03b1) : TermElabM \u03b1 :=\n  withReader (fun ctx => { ctx with macroStack := { before := beforeStx, after := afterStx } :: ctx.macroStack }) x", "start": [459, 1], "end": [461, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withMacroExpansion", "code": "def withMacroExpansion (beforeStx afterStx : Syntax) (x : TermElabM \u03b1) : TermElabM \u03b1 :=\n  withMacroExpansionInfo beforeStx afterStx do\n    withPushMacroExpansionStack beforeStx afterStx x", "start": [463, 1], "end": [466, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerSyntheticMVar", "code": "def registerSyntheticMVar (stx : Syntax) (mvarId : MVarId) (kind : SyntheticMVarKind) : TermElabM Unit := do\n  modify fun s => { s with syntheticMVars := s.syntheticMVars.insert mvarId { stx, kind }, pendingMVars := mvarId :: s.pendingMVars }", "start": [468, 1], "end": [472, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerSyntheticMVarWithCurrRef", "code": "def registerSyntheticMVarWithCurrRef (mvarId : MVarId) (kind : SyntheticMVarKind) : TermElabM Unit := do\n  registerSyntheticMVar (\u2190 getRef) mvarId kind", "start": [474, 1], "end": [475, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerMVarErrorInfo", "code": "def registerMVarErrorInfo (mvarErrorInfo : MVarErrorInfo) : TermElabM Unit :=\n  modify fun s => { s with mvarErrorInfos := s.mvarErrorInfos.insert mvarErrorInfo.mvarId mvarErrorInfo }", "start": [477, 1], "end": [478, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerMVarErrorHoleInfo", "code": "def registerMVarErrorHoleInfo (mvarId : MVarId) (ref : Syntax) : TermElabM Unit :=\n  registerMVarErrorInfo { mvarId, ref, kind := .hole }", "start": [480, 1], "end": [481, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerMVarErrorImplicitArgInfo", "code": "def registerMVarErrorImplicitArgInfo (mvarId : MVarId) (ref : Syntax) (app : Expr) : TermElabM Unit := do\n  registerMVarErrorInfo { mvarId, ref, kind := .implicitArg app }", "start": [483, 1], "end": [484, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerMVarErrorCustomInfo", "code": "def registerMVarErrorCustomInfo (mvarId : MVarId) (ref : Syntax) (msgData : MessageData) : TermElabM Unit := do\n  registerMVarErrorInfo { mvarId, ref, kind := .custom msgData }", "start": [486, 1], "end": [487, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getMVarErrorInfo?", "code": "def getMVarErrorInfo? (mvarId : MVarId) : TermElabM (Option MVarErrorInfo) := do\n  return (\u2190 get).mvarErrorInfos.find? mvarId", "start": [489, 1], "end": [490, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerCustomErrorIfMVar", "code": "def registerCustomErrorIfMVar (e : Expr) (ref : Syntax) (msgData : MessageData) : TermElabM Unit :=\n  match e.getAppFn with\n  | Expr.mvar mvarId => registerMVarErrorCustomInfo mvarId ref msgData\n  | _ => pure ()", "start": [492, 1], "end": [495, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.throwMVarError", "code": "def throwMVarError (m : MessageData) : TermElabM \u03b1 := do\n  if (\u2190 MonadLog.hasErrors) then\n    throwAbortTerm\n  else\n    throwError m", "start": [497, 1], "end": [506, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.MVarErrorInfo.logError", "code": "def MVarErrorInfo.logError (mvarErrorInfo : MVarErrorInfo) (extraMsg? : Option MessageData) : TermElabM Unit := do\n  match mvarErrorInfo.kind with\n  | MVarErrorKind.implicitArg app => do\n    let app \u2190 instantiateMVars app\n    let msg := addArgName \"don't know how to synthesize implicit argument\"\n    let msg := msg ++ m!\"{indentExpr app.setAppPPExplicitForExposingMVars}\" ++ Format.line ++ \"context:\" ++ Format.line ++ MessageData.ofGoal mvarErrorInfo.mvarId\n    logErrorAt mvarErrorInfo.ref (appendExtra msg)\n  | MVarErrorKind.hole => do\n    let msg := addArgName \"don't know how to synthesize placeholder\" \" for argument\"\n    let msg := msg ++ Format.line ++ \"context:\" ++ Format.line ++ MessageData.ofGoal mvarErrorInfo.mvarId\n    logErrorAt mvarErrorInfo.ref (MessageData.tagged `Elab.synthPlaceholder <| appendExtra msg)\n  | MVarErrorKind.custom msg =>\n    logErrorAt mvarErrorInfo.ref (appendExtra msg)\nwhere\n  \n  addArgName (msg : MessageData) (extra : String := \"\") : MessageData :=\n    match mvarErrorInfo.argName? with\n    | none => msg\n    | some argName => if argName.hasMacroScopes then msg else msg ++ extra ++ m!\" '{argName}'\"\n\n  appendExtra (msg : MessageData) : MessageData :=\n    match extraMsg? with\n    | none => msg\n    | some extraMsg => msg ++ extraMsg", "start": [508, 1], "end": [532, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.logUnassignedUsingErrorInfos", "code": "def logUnassignedUsingErrorInfos (pendingMVarIds : Array MVarId) (extraMsg? : Option MessageData := none) : TermElabM Bool := do\n  if pendingMVarIds.isEmpty then\n    return false\n  else\n    let hasOtherErrors \u2190 MonadLog.hasErrors\n    let mut hasNewErrors := false\n    let mut alreadyVisited : MVarIdSet := {}\n    let mut errors : Array MVarErrorInfo := #[]\n    for (_, mvarErrorInfo) in (\u2190 get).mvarErrorInfos do\n      let mvarId := mvarErrorInfo.mvarId\n      unless alreadyVisited.contains mvarId do\n        alreadyVisited := alreadyVisited.insert mvarId\n        \n        let mvarDeps \u2190 getMVars (mkMVar mvarId)\n        if mvarDeps.any pendingMVarIds.contains then do\n          unless hasOtherErrors do\n            errors := errors.push mvarErrorInfo\n          hasNewErrors := true\n    for error in errors do\n      error.mvarId.withContext do\n        error.logError extraMsg?\n    return hasNewErrors", "start": [534, 1], "end": [565, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ensureNoUnassignedMVars", "code": "def ensureNoUnassignedMVars (decl : Declaration) : TermElabM Unit := do\n  let pendingMVarIds \u2190 getMVarsAtDecl decl\n  if (\u2190 logUnassignedUsingErrorInfos pendingMVarIds) then\n    throwAbortCommand", "start": [567, 1], "end": [571, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withoutPostponing", "code": "def withoutPostponing (x : TermElabM \u03b1) : TermElabM \u03b1 :=\n  withReader (fun ctx => { ctx with mayPostpone := false }) x", "start": [573, 1], "end": [577, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkExplicitBinder", "code": "def mkExplicitBinder (ident : Syntax) (type : Syntax) : Syntax :=\n  mkNode ``Lean.Parser.Term.explicitBinder #[mkAtom \"(\", mkNullNode #[ident], mkNullNode #[mkAtom \":\", type], mkNullNode, mkAtom \")\"]", "start": [579, 1], "end": [581, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.levelMVarToParam", "code": "def levelMVarToParam (e : Expr) (except : LMVarId \u2192 Bool := fun _ => false) : TermElabM Expr := do\n  let levelNames \u2190 getLevelNames\n  let r := (\u2190 getMCtx).levelMVarToParam (fun n => levelNames.elem n) except e `u 1\n  setLevelNames (levelNames ++ r.newParamNames.toList)\n  setMCtx r.mctx\n  return r.expr", "start": [583, 1], "end": [591, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkFreshBinderName", "code": "def mkFreshBinderName [Monad m] [MonadQuotation m] : m Name :=\n  withFreshMacroScope <| MonadQuotation.addMacroScope `x", "start": [593, 1], "end": [597, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkFreshIdent", "code": "def mkFreshIdent [Monad m] [MonadQuotation m] (ref : Syntax) (canonical := false) : m Ident :=\n  return mkIdentFrom ref (\u2190 mkFreshBinderName) canonical", "start": [599, 1], "end": [604, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.applyAttributesCore", "code": "private def applyAttributesCore\n    (declName : Name) (attrs : Array Attribute)\n    (applicationTime? : Option AttributeApplicationTime) : TermElabM Unit := do profileitM Exception \"attribute application\" (\u2190 getOptions) do\n  for attr in attrs do\n    withRef attr.stx do withLogging do\n    let env \u2190 getEnv\n    match getAttributeImpl env attr.name with\n    | Except.error errMsg => throwError errMsg\n    | Except.ok attrImpl  =>\n      let runAttr := attrImpl.add declName attr.stx attr.kind\n      let runAttr := do\n        let elaborator := attrImpl.ref\n        if (\u2190 getInfoState).enabled && (\u2190 getEnv).contains elaborator then\n          withInfoContext (mkInfo := return .ofCommandInfo { elaborator, stx := attr.stx }) do\n            try runAttr\n            finally if attr.stx[0].isIdent || attr.stx[0].isAtom then\n              pushInfoLeaf <| .ofCommandInfo { elaborator, stx := attr.stx[0] }\n        else\n          runAttr\n      match applicationTime? with\n      | none => runAttr\n      | some applicationTime =>\n        if applicationTime == attrImpl.applicationTime then\n          runAttr", "start": [606, 1], "end": [632, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.applyAttributesAt", "code": "def applyAttributesAt (declName : Name) (attrs : Array Attribute) (applicationTime : AttributeApplicationTime) : TermElabM Unit :=\n  applyAttributesCore declName attrs applicationTime", "start": [634, 1], "end": [636, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.applyAttributes", "code": "def applyAttributes (declName : Name) (attrs : Array Attribute) : TermElabM Unit :=\n  applyAttributesCore declName attrs none", "start": [638, 1], "end": [639, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkTypeMismatchError", "code": "def mkTypeMismatchError (header? : Option String) (e : Expr) (eType : Expr) (expectedType : Expr) : TermElabM MessageData := do\n  let header : MessageData := match header? with\n    | some header => m!\"{header} \"\n    | none        => m!\"type mismatch{indentExpr e}\\n\"\n  return m!\"{header}{\u2190 mkHasTypeButIsExpectedMsg eType expectedType}\"", "start": [641, 1], "end": [645, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.throwTypeMismatchError", "code": "def throwTypeMismatchError (header? : Option String) (expectedType : Expr) (eType : Expr) (e : Expr)\n    (f? : Option Expr := none) (extraMsg? : Option MessageData := none) : TermElabM \u03b1 := do\n  \n  let extraMsg := Format.nil\n  \n  match f? with\n  | none   => throwError \"{\u2190 mkTypeMismatchError header? e eType expectedType}{extraMsg}\"\n  | some f => Meta.throwAppTypeMismatch f e", "start": [647, 1], "end": [666, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withoutMacroStackAtErr", "code": "def withoutMacroStackAtErr (x : TermElabM \u03b1) : TermElabM \u03b1 :=\n  withTheReader Core.Context (fun (ctx : Core.Context) => { ctx with options := pp.macroStack.set ctx.options false }) x", "start": [668, 1], "end": [669, 121], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ContainsPendingMVar.M", "code": "abbrev M := MonadCacheT Expr Unit (OptionT MetaM)", "start": [673, 1], "end": [673, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ContainsPendingMVar.visit", "code": "partial def visit (e : Expr) : M Unit := do\n  checkCache e fun _ => do\n    match e with\n    | .forallE _ d b _   => visit d; visit b\n    | .lam _ d b _       => visit d; visit b\n    | .letE _ t v b _    => visit t; visit v; visit b\n    | .app f a           => visit f; visit a\n    | .mdata _ b         => visit b\n    | .proj _ _ b        => visit b\n    | .fvar fvarId ..    =>\n      match (\u2190 fvarId.getDecl) with\n      | .cdecl .. => return ()\n      | .ldecl (value := v) .. => visit v\n    | .mvar mvarId ..    =>\n      let e' \u2190 instantiateMVars e\n      if e' != e then\n        visit e'\n      else\n        match (\u2190 getDelayedMVarAssignment? mvarId) with\n        | some d => visit (mkMVar d.mvarIdPending)\n        | none   => failure\n    | _ => return ()", "start": [675, 1], "end": [697, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.containsPendingMVar", "code": "def containsPendingMVar (e : Expr) : MetaM Bool := do\n  match (\u2190 ContainsPendingMVar.visit e |>.run.run) with\n  | some _ => return false\n  | none   => return true", "start": [701, 1], "end": [705, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeInstMVarCore", "code": "def synthesizeInstMVarCore (instMVar : MVarId) (maxResultSize? : Option Nat := none) : TermElabM Bool := do\n  let instMVarDecl \u2190 getMVarDecl instMVar\n  let type := instMVarDecl.type\n  let type \u2190 instantiateMVars type\n  let result \u2190 trySynthInstance type maxResultSize?\n  match result with\n  | LOption.some val =>\n    if (\u2190 instMVar.isAssigned) then\n      let oldVal \u2190 instantiateMVars (mkMVar instMVar)\n      unless (\u2190 isDefEq oldVal val) do\n        if (\u2190 containsPendingMVar oldVal <||> containsPendingMVar val) then\n          \n          return false let oldValType \u2190 inferType oldVal\n        let valType \u2190 inferType val\n        unless (\u2190 isDefEq oldValType valType) do\n          throwError \"synthesized type class instance type is not definitionally equal to expected type, synthesized{indentExpr val}\\nhas type{indentExpr valType}\\nexpected{indentExpr oldValType}\"\n        throwError \"synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized{indentExpr val}\\ninferred{indentExpr oldVal}\"\n    else\n      unless (\u2190 isDefEq (mkMVar instMVar) val) do\n        throwError \"failed to assign synthesized type class instance{indentExpr val}\"\n    return true\n  | .undef => return false | .none  =>\n    if (\u2190 read).ignoreTCFailures then\n      return false\n    else\n      throwError \"failed to synthesize instance{indentExpr type}\"", "start": [707, 1], "end": [759, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkCoe", "code": "def mkCoe (expectedType : Expr) (e : Expr) (f? : Option Expr := none) (errorMsgHeader? : Option String := none) : TermElabM Expr := do\n  withTraceNode `Elab.coe (fun _ => return m!\"adding coercion for {e} : {\u2190 inferType e} =?= {expectedType}\") do\n  try\n    withoutMacroStackAtErr do\n      match \u2190 coerce? e expectedType with\n      | .some eNew => return eNew\n      | .none => failure\n      | .undef =>\n        let mvarAux \u2190 mkFreshExprMVar expectedType MetavarKind.syntheticOpaque\n        registerSyntheticMVarWithCurrRef mvarAux.mvarId! (.coe errorMsgHeader? expectedType e f?)\n        return mvarAux\n  catch\n    | .error _ msg => throwTypeMismatchError errorMsgHeader? expectedType (\u2190 inferType e) e f? msg\n    | _            => throwTypeMismatchError errorMsgHeader? expectedType (\u2190 inferType e) e f?", "start": [761, 1], "end": [774, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ensureHasType", "code": "def ensureHasType (expectedType? : Option Expr) (e : Expr)\n    (errorMsgHeader? : Option String := none) (f? : Option Expr := none) : TermElabM Expr := do\n  let some expectedType := expectedType? | return e\n  if (\u2190 isDefEq (\u2190 inferType e) expectedType) then\n    return e\n  else\n    mkCoe expectedType e f? errorMsgHeader?", "start": [776, 1], "end": [787, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkSyntheticSorryFor", "code": "private def mkSyntheticSorryFor (expectedType? : Option Expr) : TermElabM Expr := do\n  let expectedType \u2190 match expectedType? with\n    | none              => mkFreshTypeMVar\n    | some expectedType => pure expectedType\n  mkSyntheticSorry expectedType", "start": [789, 1], "end": [797, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.exceptionToSorry", "code": "def exceptionToSorry (ex : Exception) (expectedType? : Option Expr) : TermElabM Expr := do\n  let syntheticSorry \u2190 mkSyntheticSorryFor expectedType?\n  logException ex\n  pure syntheticSorry", "start": [799, 1], "end": [806, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.tryPostpone", "code": "def tryPostpone : TermElabM Unit := do\n  if (\u2190 read).mayPostpone then\n    throwPostpone", "start": [808, 1], "end": [811, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isMVarApp", "code": "def isMVarApp (e : Expr) : TermElabM Bool :=\n  return (\u2190 whnfR e).getAppFn.isMVar", "start": [813, 1], "end": [815, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.tryPostponeIfMVar", "code": "def tryPostponeIfMVar (e : Expr) : TermElabM Unit := do\n  if (\u2190 isMVarApp e) then\n    tryPostpone", "start": [817, 1], "end": [820, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.tryPostponeIfNoneOrMVar", "code": "def tryPostponeIfNoneOrMVar (e? : Option Expr) : TermElabM Unit :=\n  match e? with\n  | some e => tryPostponeIfMVar e\n  | none   => tryPostpone", "start": [822, 1], "end": [826, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.tryPostponeIfHasMVars?", "code": "def tryPostponeIfHasMVars? (expectedType? : Option Expr) : TermElabM (Option Expr) := do\n  tryPostponeIfNoneOrMVar expectedType?\n  let some expectedType := expectedType? | return none\n  let expectedType \u2190 instantiateMVars expectedType\n  if expectedType.hasExprMVar then\n    tryPostpone\n    return none\n  return some expectedType", "start": [828, 1], "end": [839, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.tryPostponeIfHasMVars", "code": "def tryPostponeIfHasMVars (expectedType? : Option Expr) (msg : String) : TermElabM Expr := do\n  let some expectedType \u2190 tryPostponeIfHasMVars? expectedType? |\n    throwError \"{msg}, expected type contains metavariables{indentD expectedType?}\"\n  return expectedType", "start": [841, 1], "end": [848, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.saveContext", "code": "def saveContext : TermElabM SavedContext :=\n  return {\n    macroStack := (\u2190 read).macroStack\n    declName?  := (\u2190 read).declName?\n    options    := (\u2190 getOptions)\n    openDecls  := (\u2190 getOpenDecls)\n    errToSorry := (\u2190 read).errToSorry\n    levelNames := (\u2190 get).levelNames\n  }", "start": [850, 1], "end": [861, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withSavedContext", "code": "def withSavedContext (savedCtx : SavedContext) (x : TermElabM \u03b1) : TermElabM \u03b1 := do\n  withReader (fun ctx => { ctx with declName? := savedCtx.declName?, macroStack := savedCtx.macroStack, errToSorry := savedCtx.errToSorry }) <|\n    withTheReader Core.Context (fun ctx => { ctx with options := savedCtx.options, openDecls := savedCtx.openDecls }) <|\n      withLevelNames savedCtx.levelNames x", "start": [863, 1], "end": [869, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.postponeElabTermCore", "code": "private def postponeElabTermCore (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr := do\n  trace[Elab.postpone] \"{stx} : {expectedType?}\"\n  let mvar \u2190 mkFreshExprMVar expectedType? MetavarKind.syntheticOpaque\n  registerSyntheticMVar stx mvar.mvarId! (SyntheticMVarKind.postponed (\u2190 saveContext))\n  return mvar", "start": [871, 1], "end": [880, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getSyntheticMVarDecl?", "code": "def getSyntheticMVarDecl? (mvarId : MVarId) : TermElabM (Option SyntheticMVarDecl) :=\n  return (\u2190 get).syntheticMVars.find? mvarId", "start": [882, 1], "end": [883, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkSaveInfoAnnotation", "code": "def mkSaveInfoAnnotation (e : Expr) : Expr :=\n  if e.isMVar then\n    mkAnnotation `save_info e\n  else\n    e", "start": [885, 1], "end": [906, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isSaveInfoAnnotation?", "code": "def isSaveInfoAnnotation? (e : Expr) : Option Expr :=\n  annotation? `save_info e", "start": [908, 1], "end": [909, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.removeSaveInfoAnnotation", "code": "partial def removeSaveInfoAnnotation (e : Expr) : Expr :=\n  match isSaveInfoAnnotation? e with\n  | some e => removeSaveInfoAnnotation e\n  | _ => e", "start": [911, 1], "end": [914, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isTacticOrPostponedHole?", "code": "def isTacticOrPostponedHole? (e : Expr) : TermElabM (Option MVarId) := do\n  match e with\n  | Expr.mvar mvarId =>\n    match (\u2190 getSyntheticMVarDecl? mvarId) with\n    | some { kind := .tactic .., .. }    => return mvarId\n    | some { kind := .postponed .., .. } => return mvarId\n    | _                                  => return none\n  | _ => pure none", "start": [916, 1], "end": [928, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkTermInfo", "code": "def mkTermInfo (elaborator : Name) (stx : Syntax) (e : Expr) (expectedType? : Option Expr := none) (lctx? : Option LocalContext := none) (isBinder := false) : TermElabM (Sum Info MVarId) := do\n  match (\u2190 isTacticOrPostponedHole? e) with\n  | some mvarId => return Sum.inr mvarId\n  | none =>\n    let e := removeSaveInfoAnnotation e\n    return Sum.inl <| Info.ofTermInfo { elaborator, lctx := lctx?.getD (\u2190 getLCtx), expr := e, stx, expectedType?, isBinder }", "start": [930, 1], "end": [935, 126], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addTermInfo", "code": "def addTermInfo (stx : Syntax) (e : Expr) (expectedType? : Option Expr := none)\n    (lctx? : Option LocalContext := none) (elaborator := Name.anonymous)\n    (isBinder := false) (force := false) : TermElabM Expr := do\n  if (\u2190 read).inPattern && !force then\n    return mkPatternWithRef e stx\n  else\n    withInfoContext' (pure ()) (fun _ => mkTermInfo elaborator stx e expectedType? lctx? isBinder) |> discard\n    return e", "start": [937, 1], "end": [959, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addTermInfo'", "code": "def addTermInfo' (stx : Syntax) (e : Expr) (expectedType? : Option Expr := none) (lctx? : Option LocalContext := none) (elaborator := Name.anonymous) (isBinder := false) : TermElabM Unit :=\n  discard <| addTermInfo stx e expectedType? lctx? elaborator isBinder", "start": [961, 1], "end": [962, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withInfoContext'", "code": "def withInfoContext' (stx : Syntax) (x : TermElabM Expr) (mkInfo : Expr \u2192 TermElabM (Sum Info MVarId)) : TermElabM Expr := do\n  if (\u2190 read).inPattern then\n    let e \u2190 x\n    return mkPatternWithRef e stx\n  else\n    Elab.withInfoContext' x mkInfo", "start": [964, 1], "end": [969, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.postponeElabTerm", "code": "def postponeElabTerm (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr := do\n  withInfoContext' stx (mkInfo := mkTermInfo .anonymous (expectedType? := expectedType?) stx) do\n    postponeElabTermCore stx expectedType?", "start": [971, 1], "end": [978, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabUsingElabFnsAux", "code": "private def elabUsingElabFnsAux (s : SavedState) (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone : Bool)\n    : List (KeyedDeclsAttribute.AttributeEntry TermElab) \u2192 TermElabM Expr\n  | []                => do throwError \"unexpected syntax{indentD stx}\"\n  | (elabFn::elabFns) =>\n    try\n      withInfoContext' stx (mkInfo := mkTermInfo elabFn.declName (expectedType? := expectedType?) stx)\n        (try\n          elabFn.value stx expectedType?\n        catch ex => match ex with\n          | .error .. =>\n            if (\u2190 read).errToSorry then\n              exceptionToSorry ex expectedType?\n            else\n              throw ex\n          | .internal id _ =>\n            if (\u2190 read).errToSorry && id == abortTermExceptionId then\n              exceptionToSorry ex expectedType?\n            else if id == unsupportedSyntaxExceptionId then\n              throw ex  else if catchExPostpone && id == postponeExceptionId then\n              \n              s.restore\n              postponeElabTermCore stx expectedType?\n            else\n              throw ex)\n    catch ex => match ex with\n      | .internal id _ =>\n        if id == unsupportedSyntaxExceptionId then\n          s.restore  elabUsingElabFnsAux s stx expectedType? catchExPostpone elabFns\n        else\n          throw ex\n      | _ => throw ex", "start": [980, 1], "end": [1029, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabUsingElabFns", "code": "private def elabUsingElabFns (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone : Bool) : TermElabM Expr := do\n  let s \u2190 saveState\n  let k := stx.getKind\n  match termElabAttribute.getEntries (\u2190 getEnv) k with\n  | []      => throwError \"elaboration function for '{k}' has not been implemented{indentD stx}\"\n  | elabFns => elabUsingElabFnsAux s stx expectedType? catchExPostpone elabFns", "start": [1031, 1], "end": [1036, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isExplicit", "code": "private def isExplicit (stx : Syntax) : Bool :=\n  match stx with\n  | `(@$_) => true\n  | _      => false", "start": [1043, 1], "end": [1046, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isExplicitApp", "code": "private def isExplicitApp (stx : Syntax) : Bool :=\n  stx.getKind == ``Lean.Parser.Term.app && isExplicit stx[0]", "start": [1048, 1], "end": [1049, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isLambdaWithImplicit", "code": "private def isLambdaWithImplicit (stx : Syntax) : Bool :=\n  match stx with\n  | `(fun $binders* => $_) => binders.raw.any fun b => b.isOfKind ``Lean.Parser.Term.implicitBinder || b.isOfKind `Lean.Parser.Term.instBinder\n  | _                      => false", "start": [1051, 1], "end": [1057, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.dropTermParens", "code": "private partial def dropTermParens : Syntax \u2192 Syntax := fun stx =>\n  match stx with\n  | `(($stx)) => dropTermParens stx\n  | _         => stx", "start": [1059, 1], "end": [1062, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isHole", "code": "private def isHole (stx : Syntax) : Bool :=\n  match stx with\n  | `(_)          => true\n  | `(? _)        => true\n  | `(? $_:ident) => true\n  | _             => false", "start": [1064, 1], "end": [1069, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isTacticBlock", "code": "private def isTacticBlock (stx : Syntax) : Bool :=\n  match stx with\n  | `(by $_:tacticSeq) => true\n  | _ => false", "start": [1071, 1], "end": [1074, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isNoImplicitLambda", "code": "private def isNoImplicitLambda (stx : Syntax) : Bool :=\n  match stx with\n  | `(no_implicit_lambda% $_:term) => true\n  | _ => false", "start": [1076, 1], "end": [1079, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isTypeAscription", "code": "private def isTypeAscription (stx : Syntax) : Bool :=\n  match stx with\n  | `(($_ : $_)) => true\n  | _            => false", "start": [1081, 1], "end": [1084, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.hasNoImplicitLambdaAnnotation", "code": "def hasNoImplicitLambdaAnnotation (type : Expr) : Bool :=\n  annotation? `noImplicitLambda type |>.isSome", "start": [1086, 1], "end": [1087, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkNoImplicitLambdaAnnotation", "code": "def mkNoImplicitLambdaAnnotation (type : Expr) : Expr :=\n  if hasNoImplicitLambdaAnnotation type then\n    type\n  else\n    mkAnnotation `noImplicitLambda type", "start": [1089, 1], "end": [1093, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.blockImplicitLambda", "code": "def blockImplicitLambda (stx : Syntax) : Bool :=\n  let stx := dropTermParens stx\n  isExplicit stx || isExplicitApp stx || isLambdaWithImplicit stx || isHole stx || isTacticBlock stx ||\n  isNoImplicitLambda stx || isTypeAscription stx", "start": [1095, 1], "end": [1100, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.resolveLocalName", "code": "def resolveLocalName (n : Name) : TermElabM (Option (Expr \u00d7 List String)) := do\n  let lctx \u2190 getLCtx\n  let auxDeclToFullName := (\u2190 read).auxDeclToFullName\n  let currNamespace \u2190 getCurrNamespace\n  let view := extractMacroScopes n\n  \n  let matchLocalDecl? (localDecl : LocalDecl) (givenName : Name) : Option LocalDecl := do\n    guard (localDecl.userName == givenName)\n    return localDecl\n  \n  let matchAuxRecDecl? (localDecl : LocalDecl) (fullDeclName : Name) (givenNameView : MacroScopesView) : Option LocalDecl := do\n    let fullDeclView := extractMacroScopes fullDeclName\n    \n    let fullDeclView := { fullDeclView with name := (privateToUserName? fullDeclView.name).getD fullDeclView.name }\n    let fullDeclName := fullDeclView.review\n    let localDeclNameView := extractMacroScopes localDecl.userName\n    \n    if currNamespace.isPrefixOf fullDeclName then\n      \n      guard (localDeclNameView.isSuffixOf givenNameView)\n      guard (givenNameView.isSuffixOf fullDeclView)\n      return localDecl\n    else\n      \n      let rec go (ns : Name) : Option LocalDecl := do\n        if { givenNameView with name := ns ++ givenNameView.name }.review == fullDeclName then\n          return localDecl\n        match ns with\n        | .str pre .. => go pre\n        | _ => failure\n      return (\u2190 go currNamespace)\n  \n  let findLocalDecl? (givenNameView : MacroScopesView) (skipAuxDecl : Bool) : Option LocalDecl :=\n    let givenName := givenNameView.review\n    let localDecl? := lctx.decls.findSomeRev? fun localDecl? => do\n      let localDecl \u2190 localDecl?\n      if localDecl.isAuxDecl then\n        guard (not skipAuxDecl)\n        if let some fullDeclName := auxDeclToFullName.find? localDecl.fvarId then\n          matchAuxRecDecl? localDecl fullDeclName givenNameView\n        else\n          matchLocalDecl? localDecl givenName\n      else\n        matchLocalDecl? localDecl givenName\n    if localDecl?.isSome || skipAuxDecl then\n      localDecl?\n    else\n      lctx.decls.findSomeRev? fun localDecl? => do\n        let localDecl \u2190 localDecl?\n        guard localDecl.isAuxDecl\n        matchLocalDecl? localDecl givenName\n  \n  let rec loop (n : Name) (projs : List String) (globalDeclFound : Bool) := do\n    let givenNameView := { view with name := n }\n    let mut globalDeclFound := globalDeclFound\n    unless globalDeclFound do\n      let r \u2190 resolveGlobalName givenNameView.review\n      let r := r.filter fun (_, fieldList) => fieldList.isEmpty\n      unless r.isEmpty do\n        globalDeclFound := true\n    match findLocalDecl? givenNameView (skipAuxDecl := globalDeclFound && not projs.isEmpty) with\n    | some decl => return some (decl.toExpr, projs)\n    | none => match n with\n      | .str pre s => loop pre (s::projs) globalDeclFound\n      | _ => return none\n  loop view.name [] (globalDeclFound := false)", "start": [1102, 1], "end": [1250, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isLocalIdent?", "code": "def isLocalIdent? (stx : Syntax) : TermElabM (Option Expr) :=\n  match stx with\n  | Syntax.ident _ _ val _ => do\n    let r? \u2190 resolveLocalName val\n    match r? with\n    | some (fvar, []) => return some fvar\n    | _               => return none\n  | _ => return none", "start": [1252, 1], "end": [1260, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.UseImplicitLambdaResult", "code": "inductive UseImplicitLambdaResult where\n  | no\n  | yes (expectedType : Expr)\n  | postpone", "start": [1262, 1], "end": [1265, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.useImplicitLambda", "code": "private def useImplicitLambda (stx : Syntax) (expectedType? : Option Expr) : TermElabM UseImplicitLambdaResult := do\n  if blockImplicitLambda stx then\n    return .no\n  let some expectedType := expectedType? | return .no\n  if hasNoImplicitLambdaAnnotation expectedType then\n    return .no\n  let expectedType \u2190 whnfForall expectedType\n  let .forallE _ _ _ c := expectedType | return .no\n  unless c.isImplicit || c.isInstImplicit do\n    return .no\n  if let some x \u2190 isLocalIdent? stx then\n    if (\u2190 isMVarApp (\u2190 inferType x)) then\n      \n      return .postpone\n  return .yes expectedType", "start": [1267, 1], "end": [1309, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.decorateErrorMessageWithLambdaImplicitVars", "code": "private def decorateErrorMessageWithLambdaImplicitVars (ex : Exception) (impFVars : Array Expr) : TermElabM Exception := do\n  match ex with\n  | .error ref msg =>\n    if impFVars.isEmpty then\n      return Exception.error ref msg\n    else\n      let mut msg := m!\"{msg}\\nthe following variables have been introduced by the implicit lambda feature\"\n      for impFVar in impFVars do\n        let auxMsg := m!\"{impFVar} : {\u2190 inferType impFVar}\"\n        let auxMsg \u2190 addMessageContext auxMsg\n        msg := m!\"{msg}{indentD auxMsg}\"\n      msg := m!\"{msg}\\nyou can disable implicit lambdas using `@` or writing a lambda expression with `\\{}` or `[]` binder annotations.\"\n      return Exception.error ref msg\n  | _ => return ex", "start": [1311, 1], "end": [1324, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabImplicitLambdaAux", "code": "private def elabImplicitLambdaAux (stx : Syntax) (catchExPostpone : Bool) (expectedType : Expr) (impFVars : Array Expr) : TermElabM Expr := do\n  let body \u2190 elabUsingElabFns stx expectedType catchExPostpone\n  try\n    let body \u2190 ensureHasType expectedType body\n    let r \u2190 mkLambdaFVars impFVars body\n    trace[Elab.implicitForall] r\n    return r\n  catch ex =>\n    throw (\u2190 decorateErrorMessageWithLambdaImplicitVars ex impFVars)", "start": [1326, 1], "end": [1334, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabImplicitLambda", "code": "private partial def elabImplicitLambda (stx : Syntax) (catchExPostpone : Bool) (type : Expr) : TermElabM Expr :=\n  loop type #[]\nwhere\n  loop (type : Expr) (fvars : Array Expr) : TermElabM Expr := do\n    match (\u2190 whnfForall type) with\n    | .forallE n d b c =>\n      if c.isExplicit then\n        elabImplicitLambdaAux stx catchExPostpone type fvars\n      else withFreshMacroScope do\n        let n \u2190 MonadQuotation.addMacroScope n\n        withLocalDecl n c d fun fvar => do\n          let type := b.instantiate1 fvar\n          loop type (fvars.push fvar)\n    | _ =>\n      elabImplicitLambdaAux stx catchExPostpone type fvars", "start": [1336, 1], "end": [1350, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabTermAux", "code": "private partial def elabTermAux (expectedType? : Option Expr) (catchExPostpone : Bool) (implicitLambda : Bool) : Syntax \u2192 TermElabM Expr\n  | .missing => mkSyntheticSorryFor expectedType?\n  | stx => withFreshMacroScope <| withIncRecDepth do\n    withTraceNode `Elab.step (fun _ => return m!\"expected type: {expectedType?}, term\\n{stx}\") do\n    checkMaxHeartbeats \"elaborator\"\n    let env \u2190 getEnv\n    let result \u2190 match (\u2190 liftMacroM (expandMacroImpl? env stx)) with\n    | some (decl, stxNew?) =>\n      let stxNew \u2190 liftMacroM <| liftExcept stxNew?\n      withInfoContext' stx (mkInfo := mkTermInfo decl (expectedType? := expectedType?) stx) <|\n        withMacroExpansion stx stxNew <|\n          withRef stxNew <|\n            elabTermAux expectedType? catchExPostpone implicitLambda stxNew\n    | _ =>\n      let useImplicitResult \u2190 if implicitLambda && (\u2190 read).implicitLambda then useImplicitLambda stx expectedType? else pure .no\n      match useImplicitResult with\n      | .yes expectedType => elabImplicitLambda stx catchExPostpone expectedType\n      | .no => elabUsingElabFns stx expectedType? catchExPostpone\n      | .postpone =>\n        \n        if (\u2190 read).mayPostpone then\n          if catchExPostpone then\n            postponeElabTerm stx expectedType?\n          else\n            throwPostpone\n        else\n          elabUsingElabFns stx expectedType? catchExPostpone\n    trace[Elab.step.result] result\n    pure result", "start": [1352, 1], "end": [1384, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addDotCompletionInfo", "code": "def addDotCompletionInfo (stx : Syntax) (e : Expr) (expectedType? : Option Expr) (field? : Option Syntax := none) : TermElabM Unit := do\n  addCompletionInfo <| CompletionInfo.dot { expr := e, stx, lctx := (\u2190 getLCtx), elaborator := .anonymous, expectedType? } (field? := field?) (expectedType? := expectedType?)", "start": [1386, 1], "end": [1388, 175], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabTerm", "code": "def elabTerm (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone := true) (implicitLambda := true) : TermElabM Expr :=\n  withRef stx <| elabTermAux expectedType? catchExPostpone implicitLambda stx", "start": [1390, 1], "end": [1408, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabTermEnsuringType", "code": "def elabTermEnsuringType (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone := true) (implicitLambda := true) (errorMsgHeader? : Option String := none) : TermElabM Expr := do\n  let e \u2190 elabTerm stx expectedType? catchExPostpone implicitLambda\n  withRef stx <| ensureHasType expectedType? e errorMsgHeader?", "start": [1410, 1], "end": [1412, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.commitIfNoErrors?", "code": "def commitIfNoErrors? (x : TermElabM \u03b1) : TermElabM (Option \u03b1) := do\n  let saved \u2190 saveState\n  Core.resetMessageLog\n  try\n    let a \u2190 x\n    if (\u2190 MonadLog.hasErrors) then\n      restoreState saved\n      return none\n    else\n      Core.setMessageLog (saved.meta.core.messages ++ (\u2190 Core.getMessageLog))\n      return a\n  catch _ =>\n    restoreState saved\n    return none", "start": [1414, 1], "end": [1428, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.adaptExpander", "code": "def adaptExpander (exp : Syntax \u2192 TermElabM Syntax) : TermElab := fun stx expectedType? => do\n  let stx' \u2190 exp stx\n  withMacroExpansion stx stx' <| elabTerm stx' expectedType?", "start": [1430, 1], "end": [1433, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkInstMVar", "code": "def mkInstMVar (type : Expr) : TermElabM Expr := do\n  let mvar \u2190 mkFreshExprMVar type MetavarKind.synthetic\n  let mvarId := mvar.mvarId!\n  unless (\u2190 synthesizeInstMVarCore mvarId) do\n    registerSyntheticMVarWithCurrRef mvarId SyntheticMVarKind.typeClass\n  return mvar", "start": [1435, 1], "end": [1445, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ensureType", "code": "def ensureType (e : Expr) : TermElabM Expr := do\n  if (\u2190 isType e) then\n    return e\n  else\n    let eType \u2190 inferType e\n    let u \u2190 mkFreshLevelMVar\n    if (\u2190 isDefEq eType (mkSort u)) then\n      return e\n    else if let some coerced \u2190 coerceToSort? e then\n      return coerced\n    else\n      if (\u2190 instantiateMVars e).hasSyntheticSorry then\n        throwAbortTerm\n      throwError \"type expected, got\\n  ({\u2190 instantiateMVars e} : {\u2190 instantiateMVars eType})\"", "start": [1447, 1], "end": [1463, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabType", "code": "def elabType (stx : Syntax) : TermElabM Expr := do\n  let u \u2190 mkFreshLevelMVar\n  let type \u2190 elabTerm stx (mkSort u)\n  withRef stx <| ensureType type", "start": [1465, 1], "end": [1469, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withAutoBoundImplicit", "code": "partial def withAutoBoundImplicit (k : TermElabM \u03b1) : TermElabM \u03b1 := do\n  let flag := autoImplicit.get (\u2190 getOptions)\n  if flag then\n    withReader (fun ctx => { ctx with autoBoundImplicit := flag, autoBoundImplicits := {} }) do\n      let rec loop (s : SavedState) : TermElabM \u03b1 := do\n        try\n          k\n        catch\n          | ex => match isAutoBoundImplicitLocalException? ex with\n            | some n =>\n              s.restore\n              withLocalDecl n .implicit (\u2190 mkFreshTypeMVar) fun x =>\n                withReader (fun ctx => { ctx with autoBoundImplicits := ctx.autoBoundImplicits.push x } ) do\n                  loop (\u2190 saveState)\n            | none   => throw ex\n      loop (\u2190 saveState)\n  else\n    k", "start": [1471, 1], "end": [1492, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withoutAutoBoundImplicit", "code": "def withoutAutoBoundImplicit (k : TermElabM \u03b1) : TermElabM \u03b1 := do\n  withReader (fun ctx => { ctx with autoBoundImplicit := false, autoBoundImplicits := {} }) k", "start": [1494, 1], "end": [1495, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withAutoBoundImplicitForbiddenPred", "code": "partial def withAutoBoundImplicitForbiddenPred (p : Name \u2192 Bool) (x : TermElabM \u03b1) : TermElabM \u03b1 := do\n  withReader (fun ctx => { ctx with autoBoundImplicitForbidden := fun n => p n || ctx.autoBoundImplicitForbidden n }) x", "start": [1497, 1], "end": [1498, 120], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.collectUnassignedMVars", "code": "partial def collectUnassignedMVars (type : Expr) (init : Array Expr := #[]) (except : MVarId \u2192 Bool := fun _ => false)\n    : TermElabM (Array Expr) := do\n  let mvarIds \u2190 getMVars type\n  if mvarIds.isEmpty then\n    return init\n  else\n    go mvarIds.toList init init\nwhere\n  go (mvarIds : List MVarId) (result visited : Array Expr) : TermElabM (Array Expr) := do\n    match mvarIds with\n    | [] => return result\n    | mvarId :: mvarIds => do\n      let visited := visited.push (mkMVar mvarId)\n      if (\u2190 mvarId.isAssigned) then\n        go mvarIds result visited\n      else if result.contains (mkMVar mvarId) || except mvarId then\n        go mvarIds result visited\n      else\n        let mvarType := (\u2190 getMVarDecl mvarId).type\n        let mvarIdsNew \u2190 getMVars mvarType\n        let mvarIdsNew := mvarIdsNew.filter fun mvarId => !visited.contains (mkMVar mvarId)\n        if mvarIdsNew.isEmpty then\n          go mvarIds (result.push (mkMVar mvarId)) visited\n        else\n          go (mvarIdsNew.toList ++ mvarId :: mvarIds) result visited", "start": [1500, 1], "end": [1527, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addAutoBoundImplicits", "code": "def addAutoBoundImplicits (xs : Array Expr) : TermElabM (Array Expr) := do\n  let autos := (\u2190 read).autoBoundImplicits\n  go autos.toList #[]\nwhere\n  go (todo : List Expr) (autos : Array Expr) : TermElabM (Array Expr) := do\n    match todo with\n    | [] =>\n      for auto in autos do\n        if auto.isFVar then\n          let localDecl \u2190 auto.fvarId!.getDecl\n          for x in xs do\n            if (\u2190 localDeclDependsOn localDecl x.fvarId!) then\n              throwError \"invalid auto implicit argument '{auto}', it depends on explicitly provided argument '{x}'\"\n      return autos ++ xs\n    | auto :: todo =>\n      let autos \u2190 collectUnassignedMVars (\u2190 inferType auto) autos\n      go todo (autos.push auto)", "start": [1529, 1], "end": [1554, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addAutoBoundImplicits'", "code": "def addAutoBoundImplicits' (xs : Array Expr) (type : Expr) (k : Array Expr \u2192 Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  let xs \u2190 addAutoBoundImplicits xs\n  if xs.all (\u00b7.isFVar) then\n    k xs type\n  else\n    forallBoundedTelescope (\u2190 mkForallFVars xs type) xs.size fun xs type => k xs type", "start": [1556, 1], "end": [1567, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkAuxName", "code": "def mkAuxName (suffix : Name) : TermElabM Name := do\n  match (\u2190 read).declName? with\n  | none          => throwError \"auxiliary declaration cannot be created when declaration name is not available\"\n  | some declName => Lean.mkAuxName (declName ++ suffix) 1", "start": [1569, 1], "end": [1572, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isLetRecAuxMVar", "code": "def isLetRecAuxMVar (mvarId : MVarId) : TermElabM Bool := do\n  trace[Elab.letrec] \"mvarId: {mkMVar mvarId} letrecMVars: {(\u2190 get).letRecsToLift.map (mkMVar $ \u00b7.mvarId)}\"\n  let mvarId \u2190 getDelayedMVarRoot mvarId\n  trace[Elab.letrec] \"mvarId root: {mkMVar mvarId}\"\n  return (\u2190 get).letRecsToLift.any (\u00b7.mvarId == mvarId)", "start": [1576, 1], "end": [1582, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkConst", "code": "def mkConst (constName : Name) (explicitLevels : List Level := []) : TermElabM Expr := do\n  let cinfo \u2190 getConstInfo constName\n  if explicitLevels.length > cinfo.levelParams.length then\n    throwError \"too many explicit universe levels for '{constName}'\"\n  else\n    let numMissingLevels := cinfo.levelParams.length - explicitLevels.length\n    let us \u2190 mkFreshLevelMVars numMissingLevels\n    return Lean.mkConst constName (explicitLevels ++ us)", "start": [1584, 1], "end": [1595, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkConsts", "code": "private def mkConsts (candidates : List (Name \u00d7 List String)) (explicitLevels : List Level) : TermElabM (List (Expr \u00d7 List String)) := do\n  candidates.foldlM (init := []) fun result (declName, projs) => do\n    Linter.checkDeprecated declName let const \u2190 mkConst declName explicitLevels\n    return (const, projs) :: result", "start": [1597, 1], "end": [1602, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.resolveName", "code": "def resolveName (stx : Syntax) (n : Name) (preresolved : List Syntax.Preresolved) (explicitLevels : List Level) (expectedType? : Option Expr := none) : TermElabM (List (Expr \u00d7 List String)) := do\n  addCompletionInfo <| CompletionInfo.id stx stx.getId (danglingDot := false) (\u2190 getLCtx) expectedType?\n  if let some (e, projs) \u2190 resolveLocalName n then\n    unless explicitLevels.isEmpty do\n      throwError \"invalid use of explicit universe parameters, '{e}' is a local\"\n    return [(e, projs)]\n  let preresolved := preresolved.filterMap fun\n    | .decl n projs => some (n, projs)\n    | _             => none\n  let ctx \u2190 read\n  if let some (e, projs) := preresolved.findSome? fun (n, projs) => ctx.sectionFVars.find? n |>.map (\u00b7, projs) then\n    return [(e, projs)]  if preresolved.isEmpty then\n    process (\u2190 resolveGlobalName n)\n  else\n    process preresolved\nwhere\n  process (candidates : List (Name \u00d7 List String)) : TermElabM (List (Expr \u00d7 List String)) := do\n    if candidates.isEmpty then\n      if (\u2190 read).autoBoundImplicit &&\n           !(\u2190 read).autoBoundImplicitForbidden n &&\n           isValidAutoBoundImplicitName n (relaxedAutoImplicit.get (\u2190 getOptions)) then\n        throwAutoBoundImplicitLocal n\n      else\n        throwError \"unknown identifier '{Lean.mkConst n}'\"\n    mkConsts candidates explicitLevels", "start": [1604, 1], "end": [1630, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.resolveName'", "code": "def resolveName' (ident : Syntax) (explicitLevels : List Level) (expectedType? : Option Expr := none) : TermElabM (List (Expr \u00d7 Syntax \u00d7 List Syntax)) := do\n  match ident with\n  | .ident _ _ n preresolved =>\n    let r \u2190 resolveName ident n preresolved explicitLevels expectedType?\n    r.mapM fun (c, fields) => do\n      let ids := ident.identComponents (nFields? := fields.length)\n      return (c, ids.head!, ids.tail!)\n  | _ => throwError \"identifier expected\"", "start": [1632, 1], "end": [1643, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.resolveId?", "code": "def resolveId? (stx : Syntax) (kind := \"term\") (withInfo := false) : TermElabM (Option Expr) :=\n  match stx with\n  | .ident _ _ val preresolved => do\n    let rs \u2190 try resolveName stx val preresolved [] catch _ => pure []\n    let rs := rs.filter fun \u27e8_, projs\u27e9 => projs.isEmpty\n    let fs := rs.map fun (f, _) => f\n    match fs with\n    | []  => return none\n    | [f] =>\n      let f \u2190 if withInfo then addTermInfo stx f else pure f\n      return some f\n    | _   => throwError \"ambiguous {kind}, use fully qualified name, possible interpretations {fs}\"\n  | _ => throwError \"identifier expected\"", "start": [1645, 1], "end": [1657, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.TermElabM.run", "code": "def TermElabM.run (x : TermElabM \u03b1) (ctx : Context := {}) (s : State := {}) : MetaM (\u03b1 \u00d7 State) :=\n  withConfig setElabConfig (x ctx |>.run s)", "start": [1660, 1], "end": [1661, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.TermElabM.run'", "code": "@[inline] def TermElabM.run' (x : TermElabM \u03b1) (ctx : Context := {}) (s : State := {}) : MetaM \u03b1 :=\n  (\u00b7.1) <$> x.run ctx s", "start": [1663, 1], "end": [1664, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.TermElabM.toIO", "code": "def TermElabM.toIO (x : TermElabM \u03b1)\n    (ctxCore : Core.Context) (sCore : Core.State)\n    (ctxMeta : Meta.Context) (sMeta : Meta.State)\n    (ctx : Context) (s : State) : IO (\u03b1 \u00d7 Core.State \u00d7 Meta.State \u00d7 State) := do\n  let ((a, s), sCore, sMeta) \u2190 (x.run ctx s).toIO ctxCore sCore ctxMeta sMeta\n  return (a, sCore, sMeta, s)", "start": [1666, 1], "end": [1671, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.universeConstraintsCheckpoint", "code": "def universeConstraintsCheckpoint (x : TermElabM \u03b1) : TermElabM \u03b1 := do\n  let a \u2190 x\n  discard <| processPostponed (mayPostpone := true) (exceptionOnFailure := true)\n  return a", "start": [1680, 1], "end": [1687, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandDeclId", "code": "def expandDeclId (currNamespace : Name) (currLevelNames : List Name) (declId : Syntax) (modifiers : Modifiers) : TermElabM ExpandDeclIdResult := do\n  let r \u2190 Elab.expandDeclId currNamespace currLevelNames declId modifiers\n  if (\u2190 read).sectionVars.contains r.shortName then\n    throwError \"invalid declaration name '{r.shortName}', there is a section variable with the same name\"\n  return r", "start": [1689, 1], "end": [1693, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.exprToSyntax", "code": "def exprToSyntax (e : Expr) : TermElabM Term := withFreshMacroScope do\n  let result \u2190 `(?m)\n  let eType \u2190 inferType e\n  let mvar \u2190 elabTerm result eType\n  mvar.mvarId!.assign e\n  return result", "start": [1695, 1], "end": [1709, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.withoutModifyingStateWithInfoAndMessages", "code": "def withoutModifyingStateWithInfoAndMessages [MonadControlT TermElabM m] [Monad m] (x : m \u03b1) : m \u03b1 := do\n  controlAt TermElabM fun runInBase => withoutModifyingStateWithInfoAndMessagesImpl <| runInBase x", "start": [1714, 1], "end": [1715, 99], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/TopDownAnalyze.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ReplaceLevel.lean", "lake-packages/lean4/src/lean/Lean/Data/RBMap.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Options.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectLevelParams.lean", "lake-packages/lean4/src/lean/Lean/Util/FindLevelMVar.lean", "lake-packages/lean4/src/lean/Lean/Util/FindMVar.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/SubExpr.lean", "lake-packages/lean4/src/lean/Lean/Elab/Config.lean", "lake-packages/lean4/src/lean/Lean/Meta/SynthInstance.lean"], "premises": [{"full_name": "Lean.getPPAnalyze", "code": "def getPPAnalyze                            (o : Options) : Bool := o.get pp.analyze.name pp.analyze.defValue", "start": [105, 1], "end": [105, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeCheckInstances", "code": "def getPPAnalyzeCheckInstances              (o : Options) : Bool := o.get pp.analyze.checkInstances.name pp.analyze.checkInstances.defValue", "start": [106, 1], "end": [106, 140], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeTypeAscriptions", "code": "def getPPAnalyzeTypeAscriptions             (o : Options) : Bool := o.get pp.analyze.typeAscriptions.name pp.analyze.typeAscriptions.defValue", "start": [107, 1], "end": [107, 142], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeTrustSubst", "code": "def getPPAnalyzeTrustSubst                  (o : Options) : Bool := o.get pp.analyze.trustSubst.name pp.analyze.trustSubst.defValue", "start": [108, 1], "end": [108, 132], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeTrustOfNat", "code": "def getPPAnalyzeTrustOfNat                  (o : Options) : Bool := o.get pp.analyze.trustOfNat.name pp.analyze.trustOfNat.defValue", "start": [109, 1], "end": [109, 132], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeTrustOfScientific", "code": "def getPPAnalyzeTrustOfScientific           (o : Options) : Bool := o.get pp.analyze.trustOfScientific.name pp.analyze.trustOfScientific.defValue", "start": [110, 1], "end": [110, 146], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeTrustId", "code": "def getPPAnalyzeTrustId                     (o : Options) : Bool := o.get pp.analyze.trustId.name pp.analyze.trustId.defValue", "start": [111, 1], "end": [111, 126], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeTrustSubtypeMk", "code": "def getPPAnalyzeTrustSubtypeMk              (o : Options) : Bool := o.get pp.analyze.trustSubtypeMk.name pp.analyze.trustSubtypeMk.defValue", "start": [112, 1], "end": [112, 140], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeTrustKnownFOType2TypeHOFuns", "code": "def getPPAnalyzeTrustKnownFOType2TypeHOFuns (o : Options) : Bool := o.get pp.analyze.trustKnownFOType2TypeHOFuns.name pp.analyze.trustKnownFOType2TypeHOFuns.defValue", "start": [113, 1], "end": [113, 166], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeOmitMax", "code": "def getPPAnalyzeOmitMax                     (o : Options) : Bool := o.get pp.analyze.omitMax.name pp.analyze.omitMax.defValue", "start": [114, 1], "end": [114, 126], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeKnowsType", "code": "def getPPAnalyzeKnowsType                   (o : Options) : Bool := o.get pp.analyze.knowsType.name pp.analyze.knowsType.defValue", "start": [115, 1], "end": [115, 130], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalyzeExplicitHoles", "code": "def getPPAnalyzeExplicitHoles               (o : Options) : Bool := o.get pp.analyze.explicitHoles.name pp.analyze.explicitHoles.defValue", "start": [116, 1], "end": [116, 138], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalysisSkip", "code": "def getPPAnalysisSkip            (o : Options) : Bool := o.get `pp.analysis.skip false", "start": [118, 1], "end": [118, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalysisHole", "code": "def getPPAnalysisHole            (o : Options) : Bool := o.get `pp.analysis.hole false", "start": [119, 1], "end": [119, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalysisNamedArg", "code": "def getPPAnalysisNamedArg        (o : Options) : Bool := o.get `pp.analysis.namedArg false", "start": [120, 1], "end": [120, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalysisLetVarType", "code": "def getPPAnalysisLetVarType      (o : Options) : Bool := o.get `pp.analysis.letVarType false", "start": [121, 1], "end": [121, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalysisNeedsType", "code": "def getPPAnalysisNeedsType       (o : Options) : Bool := o.get `pp.analysis.needsType false", "start": [122, 1], "end": [122, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.getPPAnalysisBlockImplicit", "code": "def getPPAnalysisBlockImplicit   (o : Options) : Bool := o.get `pp.analysis.blockImplicit false", "start": [123, 1], "end": [123, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.returnsPi", "code": "def returnsPi (motive : Expr) : MetaM Bool := do\n  lambdaTelescope motive fun _ b => return b.isForall", "start": [127, 1], "end": [128, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.isNonConstFun", "code": "def isNonConstFun (motive : Expr) : MetaM Bool := do\n  match motive with\n  | Expr.lam _    _ b _ => isNonConstFun b\n  | _ => return motive.hasLooseBVars", "start": [130, 1], "end": [133, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.isSimpleHOFun", "code": "def isSimpleHOFun (motive : Expr) : MetaM Bool :=\n  return not (\u2190 returnsPi motive) && not (\u2190 isNonConstFun motive)", "start": [135, 1], "end": [136, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.isType2Type", "code": "def isType2Type (motive : Expr) : MetaM Bool := do\n  match \u2190 inferType motive with\n  | Expr.forallE _ (Expr.sort ..) (Expr.sort ..) .. => return true\n  | _ => return false", "start": [138, 1], "end": [141, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.isFOLike", "code": "def isFOLike (motive : Expr) : MetaM Bool := do\n  let f := motive.getAppFn\n  return f.isFVar || f.isConst", "start": [143, 1], "end": [145, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.isIdLike", "code": "def isIdLike (arg : Expr) : Bool :=\n  match arg with\n  | Expr.lam _ _ (Expr.bvar ..) .. => true\n  | _ => false", "start": [147, 1], "end": [151, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.isStructureInstance", "code": "def isStructureInstance (e : Expr) : MetaM Bool := do\n  match e.isConstructorApp? (\u2190 getEnv) with\n  | some s => return isStructure (\u2190 getEnv) s.induct\n  | none   => return false", "start": [153, 1], "end": [156, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth", "code": "partial def hasMVarAtCurrDepth (e : Expr) : MetaM Bool := do\n  let mctx \u2190 getMCtx\n  return Option.isSome <| e.findMVar? fun mvarId =>\n    match mctx.findDecl? mvarId with\n    | some mdecl => mdecl.depth == mctx.depth\n    | _ => false", "start": [160, 1], "end": [165, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasLevelMVarAtCurrDepth", "code": "partial def hasLevelMVarAtCurrDepth (e : Expr) : MetaM Bool := do\n  let mctx \u2190 getMCtx\n  return Option.isSome <| e.findLevelMVar? fun mvarId =>\n    mctx.findLevelDepth? mvarId == some mctx.depth", "start": [167, 1], "end": [170, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.valUnknown", "code": "private def valUnknown (e : Expr) : MetaM Bool := do\n  hasMVarAtCurrDepth (\u2190 instantiateMVars e)", "start": [172, 1], "end": [173, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.typeUnknown", "code": "private def typeUnknown (e : Expr) : MetaM Bool := do\n  valUnknown (\u2190 inferType e)", "start": [175, 1], "end": [176, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHBinOp", "code": "def isHBinOp (e : Expr) : Bool := Id.run do\n  if e.getAppNumArgs != 6 then return false\n  let f := e.getAppFn\n  if !f.isConst then return false\n\n  let ops := #[\n    `HOr.hOr, `HXor.hXor, `HAnd.hAnd,\n    `HAppend.hAppend, `HOrElse.hOrElse, `HAndThen.hAndThen,\n    `HAdd.hAdd, `HSub.hSub, `HMul.hMul, `HDiv.hDiv, `HMod.hMod,\n    `HShiftLeft.hShiftLeft, `HShiftRight]\n  ops.any fun op => op == f.constName!", "start": [178, 1], "end": [192, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.replaceLPsWithVars", "code": "def replaceLPsWithVars (e : Expr) : MetaM Expr := do\n  if !e.hasLevelParam then return e\n  let lps := collectLevelParams {} e |>.params\n  let mut replaceMap : HashMap Name Level := {}\n  for lp in lps do replaceMap := replaceMap.insert lp (\u2190 mkFreshLevelMVar)\n  return e.replaceLevel fun\n    | Level.param n .. => replaceMap.find! n\n    | l => if !l.hasParam then some l else none", "start": [194, 1], "end": [201, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isDefEqAssigning", "code": "def isDefEqAssigning (t s : Expr) : MetaM Bool := do\n  withReader (fun ctx => { ctx with config := { ctx.config with assignSyntheticOpaque := true }}) $\n    Meta.isDefEq t s", "start": [203, 1], "end": [205, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.checkpointDefEq", "code": "def checkpointDefEq (t s : Expr) : MetaM Bool := do\n  Meta.checkpointDefEq (mayPostpone := false) do\n    isDefEqAssigning t s", "start": [207, 1], "end": [209, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHigherOrder", "code": "def isHigherOrder (type : Expr) : MetaM Bool := do\n  forallTelescopeReducing type fun xs b => return xs.size > 0 && b.isSort", "start": [211, 1], "end": [212, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isFunLike", "code": "def isFunLike (e : Expr) : MetaM Bool := do\n  forallTelescopeReducing (\u2190 inferType e) fun xs _ => return xs.size > 0", "start": [214, 1], "end": [215, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isSubstLike", "code": "def isSubstLike (e : Expr) : Bool :=\n  e.isAppOfArity ``Eq.ndrec 6 || e.isAppOfArity ``Eq.rec 6", "start": [217, 1], "end": [218, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.nameNotRoundtrippable", "code": "def nameNotRoundtrippable (n : Name) : Bool :=\n  n.hasMacroScopes || isPrivateName n || containsNum n\nwhere\n  containsNum\n    | Name.str p .. => containsNum p\n    | Name.num ..   => true\n    | Name.anonymous => false", "start": [220, 1], "end": [226, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.mvarName", "code": "def mvarName (mvar : Expr) : MetaM Name :=\n  return (\u2190  mvar.mvarId!.getDecl).userName", "start": [228, 1], "end": [229, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.containsBadMax", "code": "def containsBadMax : Level \u2192 Bool\n  | Level.succ u ..   => containsBadMax u\n  | Level.max u v ..  => (u.hasParam && v.hasParam) || containsBadMax u || containsBadMax v\n  | Level.imax u v .. => (u.hasParam && v.hasParam) || containsBadMax u || containsBadMax v\n  | _                 => false", "start": [231, 1], "end": [235, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context", "code": "structure Context where\n  knowsType   : Bool\n  knowsLevel  : Bool inBottomUp  : Bool := false\n  parentIsApp : Bool := false\n  subExpr     : SubExpr\n  deriving Inhabited", "start": [239, 1], "end": [245, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State", "code": "structure State where\n  annotations : OptionsPerPos := {}\n  postponed   : Array (Expr \u00d7 Expr) := #[]", "start": [247, 1], "end": [249, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM", "code": "abbrev AnalyzeM := ReaderT Context (StateRefT State MetaM)", "start": [251, 1], "end": [251, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify", "code": "def tryUnify (e\u2081 e\u2082 : Expr) : AnalyzeM Unit := do\n  try\n    let r \u2190 isDefEqAssigning e\u2081 e\u2082\n    if !r then modify fun s => { s with postponed := s.postponed.push (e\u2081, e\u2082) }\n    pure ()\n  catch _ =>\n    modify fun s => { s with postponed := s.postponed.push (e\u2081, e\u2082) }", "start": [259, 1], "end": [265, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.inspectOutParams", "code": "partial def inspectOutParams (arg mvar : Expr) : AnalyzeM Unit := do\n  let argType  \u2190 inferType arg let mvarType \u2190 inferType mvar\n  let fType \u2190 inferType argType.getAppFn let mType \u2190 inferType mvarType.getAppFn\n  inspectAux fType mType 0 argType.getAppArgs mvarType.getAppArgs\nwhere\n  inspectAux (fType mType : Expr) (i : Nat) (args mvars : Array Expr) := do\n    let fType \u2190 whnf fType\n    let mType \u2190 whnf mType\n    if not (i < args.size) then return ()\n    match fType, mType with\n    | Expr.forallE _ fd fb _, Expr.forallE _ _  mb _ => do\n      if fd.isOutParam then\n        tryUnify (args[i]!) (mvars[i]!)\n      inspectAux (fb.instantiate1 args[i]!) (mb.instantiate1 mvars[i]!) (i+1) args mvars\n    | _, _ => return ()", "start": [267, 1], "end": [285, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isTrivialBottomUp", "code": "partial def isTrivialBottomUp (e : Expr) : AnalyzeM Bool := do\n  let opts \u2190 getOptions\n  return e.isFVar\n         || e.isConst || e.isMVar || e.isNatLit || e.isStringLit || e.isSort\n         || (getPPAnalyzeTrustOfNat opts && e.isAppOfArity ``OfNat.ofNat 3)\n         || (getPPAnalyzeTrustOfScientific opts && e.isAppOfArity ``OfScientific.ofScientific 5)", "start": [287, 1], "end": [292, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.canBottomUp", "code": "partial def canBottomUp (e : Expr) (mvar? : Option Expr := none) (fuel : Nat := 10) : AnalyzeM Bool := do\n  match fuel with\n  | 0 => return false\n  | fuel + 1 =>\n    if \u2190 isTrivialBottomUp e then return true\n    let f := e.getAppFn\n    if !f.isConst && !f.isFVar then return false\n    let args := e.getAppArgs\n    let fType \u2190 replaceLPsWithVars (\u2190 inferType e.getAppFn)\n    let (mvars, bInfos, resultType) \u2190 forallMetaBoundedTelescope fType e.getAppArgs.size\n    for i in [:mvars.size] do\n      if bInfos[i]! == BinderInfo.instImplicit then\n        inspectOutParams args[i]! mvars[i]!\n      else if bInfos[i]! == BinderInfo.default then\n        if \u2190 isTrivialBottomUp args[i]! then tryUnify args[i]! mvars[i]!\n        else if \u2190 typeUnknown mvars[i]! <&&> canBottomUp args[i]! (some mvars[i]!) fuel then tryUnify args[i]! mvars[i]!\n    if \u2190 (pure (isHBinOp e) <&&> (valUnknown mvars[0]! <||> valUnknown mvars[1]!)) then tryUnify mvars[0]! mvars[1]!\n    if mvar?.isSome then tryUnify resultType (\u2190 inferType mvar?.get!)\n    return !(\u2190 valUnknown resultType)", "start": [294, 1], "end": [315, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.withKnowing", "code": "def withKnowing (knowsType knowsLevel : Bool) (x : AnalyzeM \u03b1) : AnalyzeM \u03b1 := do\n  withReader (fun ctx => { ctx with knowsType := knowsType, knowsLevel := knowsLevel }) x", "start": [317, 1], "end": [318, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.checkKnowsType", "code": "def checkKnowsType : AnalyzeM Unit := do\n  if not (\u2190 read).knowsType then\n    throw $ Exception.internal analyzeFailureId", "start": [322, 1], "end": [324, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBoolAt", "code": "def annotateBoolAt (n : Name) (pos : Pos) : AnalyzeM Unit := do\n  let opts := (\u2190 get).annotations.findD pos {} |>.setBool n true\n  trace[pp.analyze.annotate] \"{pos} {n}\"\n  modify fun s => { s with annotations := s.annotations.insert pos opts }", "start": [326, 1], "end": [329, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool", "code": "def annotateBool (n : Name) : AnalyzeM Unit := do\n  annotateBoolAt n (\u2190 getPos)", "start": [331, 1], "end": [332, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context", "code": "structure App.Context where\n  f               : Expr\n  fType           : Expr\n  args            : Array Expr\n  mvars           : Array Expr\n  bInfos          : Array BinderInfo\n  forceRegularApp : Bool", "start": [334, 1], "end": [340, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State", "code": "structure App.State where\n  bottomUps       : Array Bool\n  higherOrders    : Array Bool\n  funBinders      : Array Bool\n  provideds       : Array Bool\n  namedArgs       : Array Name := #[]", "start": [342, 1], "end": [347, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM", "code": "abbrev AnalyzeAppM := ReaderT App.Context (StateT App.State AnalyzeM)", "start": [349, 1], "end": [349, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze", "code": "partial def analyze (parentIsApp : Bool := false) : AnalyzeM Unit := do\n    checkMaxHeartbeats \"Delaborator.topDownAnalyze\"\n    trace[pp.analyze] \"{(\u2190 read).knowsType}.{(\u2190 read).knowsLevel}\"\n    let e \u2190 getExpr\n    let opts \u2190 getOptions\n    if \u2190 (pure !e.isAtomic) <&&> pure !(getPPProofs opts) <&&> (try Meta.isProof e catch _ => pure false) then\n      if getPPProofsWithType opts then\n        withType $ withKnowing true true $ analyze\n      return ()\n    else\n      withReader (fun ctx => { ctx with parentIsApp := parentIsApp }) do\n        match (\u2190 getExpr) with\n        | Expr.app ..     => analyzeApp\n        | Expr.forallE .. => analyzePi\n        | Expr.lam ..     => analyzeLam\n        | Expr.const ..   => analyzeConst\n        | Expr.sort ..    => analyzeSort\n        | Expr.proj ..    => analyzeProj\n        | Expr.fvar ..    => analyzeFVar\n        | Expr.mdata ..   => analyzeMData\n        | Expr.letE ..    => analyzeLet\n        | Expr.lit ..     => pure ()\n        | Expr.mvar ..    => pure ()\n        | Expr.bvar ..    => pure ()\n  where\n    analyzeApp := do\n      let mut willKnowType := (\u2190 read).knowsType\n      if !(\u2190 read).knowsType && !(\u2190 canBottomUp (\u2190 getExpr)) then\n        annotateBool `pp.analysis.needsType\n        withType $ withKnowing true false $ analyze\n        willKnowType := true\n\n      else if \u2190 (pure !(\u2190 read).knowsType <||> pure (\u2190 read).inBottomUp) <&&> isStructureInstance (\u2190 getExpr) then\n        withType do\n          annotateBool `pp.structureInstanceTypes\n          withKnowing true false $ analyze\n        willKnowType := true\n\n      withKnowing willKnowType true $ analyzeAppStaged (\u2190 getExpr).getAppFn (\u2190 getExpr).getAppArgs\n\n    analyzeAppStaged (f : Expr) (args : Array Expr) : AnalyzeM Unit := do\n      let fType \u2190 replaceLPsWithVars (\u2190 inferType f)\n      let (mvars, bInfos, resultType) \u2190 forallMetaBoundedTelescope fType args.size\n      let rest := args.extract mvars.size args.size\n      let args := args.shrink mvars.size\n\n      if (\u2190 read).knowsType then tryUnify (\u2190 inferType (mkAppN f args)) resultType\n\n      let forceRegularApp : Bool :=\n        (getPPAnalyzeTrustSubst (\u2190 getOptions) && isSubstLike (\u2190 getExpr))\n        || (getPPAnalyzeTrustSubtypeMk (\u2190 getOptions) && (\u2190 getExpr).isAppOfArity ``Subtype.mk 4)\n\n      analyzeAppStagedCore { f, fType, args, mvars, bInfos, forceRegularApp } |>.run' {\n        bottomUps    := mkArray args.size false,\n        higherOrders := mkArray args.size false,\n        provideds    := mkArray args.size false,\n        funBinders   := mkArray args.size false\n      }\n\n      if not rest.isEmpty then\n        if !args.isEmpty then\n          analyzeAppStaged (mkAppN f args) rest\n\n    maybeAddBlockImplicit : AnalyzeM Unit := do\n      if !(\u2190 read).parentIsApp then\n        let type \u2190 inferType (\u2190 getExpr)\n        if type.isForall && type.bindingInfo! == BinderInfo.implicit then\n          annotateBool `pp.analysis.blockImplicit\n\n    analyzeConst : AnalyzeM Unit := do\n      let Expr.const _ ls .. \u2190 getExpr | unreachable!\n      if !(\u2190 read).knowsLevel && !ls.isEmpty then\n        unless getPPAnalyzeOmitMax (\u2190 getOptions) && ls.any containsBadMax do\n        annotateBool `pp.universes\n      maybeAddBlockImplicit\n\n    analyzePi : AnalyzeM Unit := do\n      withBindingDomain $ withKnowing true false analyze\n      withBindingBody Name.anonymous analyze\n\n    analyzeLam : AnalyzeM Unit := do\n      if !(\u2190 read).knowsType then annotateBool `pp.funBinderTypes\n      withBindingDomain $ withKnowing true false analyze\n      withBindingBody Name.anonymous analyze\n\n    analyzeLet : AnalyzeM Unit := do\n      let Expr.letE _ _ v _    .. \u2190 getExpr | unreachable!\n      if !(\u2190 canBottomUp v) then\n        annotateBool `pp.analysis.letVarType\n        withLetVarType $ withKnowing true false analyze\n        withLetValue $ withKnowing true true analyze\n      else\n        withReader (fun ctx => { ctx with inBottomUp := true }) do\n          withLetValue $ withKnowing true true analyze\n\n      withLetBody analyze\n\n    analyzeSort  : AnalyzeM Unit := pure ()\n    analyzeProj  : AnalyzeM Unit := withProj analyze\n    analyzeFVar  : AnalyzeM Unit := maybeAddBlockImplicit\n    analyzeMData : AnalyzeM Unit := withMDataExpr analyze", "start": [353, 3], "end": [457, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore", "code": "partial def analyzeAppStagedCore : AnalyzeAppM Unit := do\n    collectBottomUps\n    checkOutParams\n    collectHigherOrders\n    hBinOpHeuristic\n    collectTrivialBottomUps\n    discard <| processPostponed (mayPostpone := true)\n    applyFunBinderHeuristic\n    analyzeFn\n    for i in [:(\u2190 read).args.size] do analyzeArg i\n    maybeSetExplicit\n\n  where\n    collectBottomUps := do\n      let { args, mvars, bInfos, ..} \u2190 read\n      for target in [fun _ => none, fun i => some mvars[i]!] do\n        for i in [:args.size] do\n          if bInfos[i]! == BinderInfo.default then\n            if \u2190 typeUnknown mvars[i]! <&&> canBottomUp args[i]! (target i) then\n              tryUnify args[i]! mvars[i]!\n              modify fun s => { s with bottomUps := s.bottomUps.set! i true }\n\n    checkOutParams := do\n      let { args, mvars, bInfos, ..} \u2190 read\n      for i in [:args.size] do\n        if bInfos[i]! == BinderInfo.instImplicit then inspectOutParams args[i]! mvars[i]!\n\n    collectHigherOrders := do\n      let { args, mvars, bInfos, ..} \u2190 read\n      for i in [:args.size] do\n        if not (bInfos[i]! == BinderInfo.implicit || bInfos[i]! == BinderInfo.strictImplicit) then continue\n        if not (\u2190 isHigherOrder (\u2190 inferType args[i]!)) then continue\n        if getPPAnalyzeTrustId (\u2190 getOptions) && isIdLike args[i]! then continue\n\n        if getPPAnalyzeTrustKnownFOType2TypeHOFuns (\u2190 getOptions) && not (\u2190 valUnknown mvars[i]!)\n          && (\u2190 isType2Type (args[i]!)) && (\u2190 isFOLike (args[i]!)) then continue\n\n        tryUnify args[i]! mvars[i]!\n        modify fun s => { s with higherOrders := s.higherOrders.set! i true }\n\n    hBinOpHeuristic := do\n      let { mvars, ..} \u2190 read\n      if \u2190 (pure (isHBinOp (\u2190 getExpr)) <&&> (valUnknown mvars[0]! <||> valUnknown mvars[1]!)) then\n        tryUnify mvars[0]! mvars[1]!\n\n    collectTrivialBottomUps := do\n      let { args, mvars, bInfos, ..} \u2190 read\n      for i in [:args.size] do\n        if bInfos[i]! == BinderInfo.default then\n          if \u2190 valUnknown mvars[i]! <&&> isTrivialBottomUp args[i]! then\n            tryUnify args[i]! mvars[i]!\n            modify fun s => { s with bottomUps := s.bottomUps.set! i true }\n\n    applyFunBinderHeuristic := do\n      let { args, mvars, bInfos, .. } \u2190 read\n\n      let rec core (argIdx : Nat) (mvarType : Expr) : AnalyzeAppM Bool := do\n        match \u2190 getExpr, mvarType with\n        | Expr.lam .., Expr.forallE _ t b .. =>\n          let mut annotated := false\n          for i in [:argIdx] do\n            if \u2190 pure (bInfos[i]! == BinderInfo.implicit) <&&> valUnknown mvars[i]! <&&> withNewMCtxDepth (checkpointDefEq t mvars[i]!) then\n              annotateBool `pp.funBinderTypes\n              tryUnify args[i]! mvars[i]!\n              annotated := true\n              break\n          let annotatedBody \u2190 withBindingBody Name.anonymous (core argIdx b)\n          return annotated || annotatedBody\n\n        | _, _ => return false\n\n      for i in [:args.size] do\n        if bInfos[i]! == BinderInfo.default then\n          let b \u2190 withNaryArg i (core i (\u2190 inferType mvars[i]!))\n          if b then modify fun s => { s with funBinders := s.funBinders.set! i true }\n\n    analyzeFn := do\n      let {f, fType, forceRegularApp ..} \u2190 read\n      if !f.isApp then withKnowing false (forceRegularApp || !(\u2190 hasLevelMVarAtCurrDepth (\u2190 instantiateMVars fType))) $ withNaryFn (analyze (parentIsApp := true))\n\n    annotateNamedArg (n : Name) : AnalyzeAppM Unit := do\n      annotateBool `pp.analysis.namedArg\n      modify fun s => { s with namedArgs := s.namedArgs.push n }\n\n    analyzeArg (i : Nat) := do\n      let { f, args, mvars, bInfos, forceRegularApp ..} \u2190 read\n      let { bottomUps, higherOrders, funBinders, ..} \u2190 get\n      let arg := args[i]!\n      let argType \u2190 inferType arg\n\n      let processNaturalImplicit : AnalyzeAppM Unit := do\n        if (\u2190 valUnknown mvars[i]! <||> pure higherOrders[i]!) && !forceRegularApp then\n          annotateNamedArg (\u2190 mvarName mvars[i]!)\n          modify fun s => { s with provideds := s.provideds.set! i true }\n        else\n          annotateBool `pp.analysis.skip\n\n      withNaryArg (f.getAppNumArgs + i) do\n        withTheReader Context (fun ctx => { ctx with inBottomUp := ctx.inBottomUp || bottomUps[i]! }) do\n\n          match bInfos[i]! with\n          | BinderInfo.default =>\n            if \u2190 pure (getPPAnalyzeExplicitHoles (\u2190 getOptions)) <&&> pure !(\u2190 valUnknown mvars[i]!) <&&> pure !(\u2190 readThe Context).inBottomUp <&&> pure !(\u2190 isFunLike arg) <&&> pure !funBinders[i]! <&&> checkpointDefEq mvars[i]! arg then\n              annotateBool `pp.analysis.hole\n            else\n              modify fun s => { s with provideds := s.provideds.set! i true }\n\n          | BinderInfo.implicit => processNaturalImplicit\n          | BinderInfo.strictImplicit => processNaturalImplicit\n\n          | BinderInfo.instImplicit =>\n            let mut provided := true\n            if !getPPInstances (\u2190 getOptions) then\n              annotateBool `pp.analysis.skip\n              provided := false\n            else if getPPAnalyzeCheckInstances (\u2190 getOptions) then\n              let instResult \u2190 try trySynthInstance argType catch _ => pure LOption.undef\n              match instResult with\n              | LOption.some inst =>\n                if \u2190 checkpointDefEq inst arg then annotateBool `pp.analysis.skip; provided := false\n                else annotateNamedArg (\u2190 mvarName mvars[i]!)\n              | _                 => annotateNamedArg (\u2190 mvarName mvars[i]!)\n            else annotateBool `pp.analysis.skip; provided := false\n            modify fun s => { s with provideds := s.provideds.set! i provided }\n          if (\u2190 get).provideds[i]! then withKnowing (not (\u2190 typeUnknown mvars[i]!)) true analyze\n          tryUnify mvars[i]! args[i]!\n\n    maybeSetExplicit := do\n      let { f, args, bInfos, ..} \u2190 read\n      if (\u2190 get).namedArgs.any nameNotRoundtrippable then\n        annotateBool `pp.explicit\n        for i in [:args.size] do\n          if !(\u2190 get).provideds[i]! then\n            withNaryArg (f.getAppNumArgs + i) do annotateBool `pp.analysis.hole\n          if bInfos[i]! == BinderInfo.instImplicit && getPPInstanceTypes (\u2190 getOptions) then\n            withType (withKnowing true false analyze)", "start": [459, 3], "end": [601, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.topDownAnalyze", "code": "def topDownAnalyze (e : Expr) : MetaM OptionsPerPos := do\n  let s\u2080 \u2190 get\n  withTraceNode `pp.analyze (fun _ => return e) do\n    withReader (fun ctx => { ctx with config := Elab.Term.setElabConfig ctx.config }) do\n      let \u03d5 : AnalyzeM OptionsPerPos := do withNewMCtxDepth analyze; pure (\u2190 get).annotations\n      try\n        let knowsType := getPPAnalyzeKnowsType (\u2190 getOptions)\n        \u03d5 { knowsType := knowsType, knowsLevel := knowsType, subExpr := mkRoot e }\n          |>.run' { : TopDownAnalyze.State }\n      catch e =>\n        trace[pp.analyze.error] \"failed {e.toMessageData}\"\n        pure {}\n      finally set s\u2080", "start": [609, 1], "end": [621, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Syntax.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.precedenceParser", "code": "@[inline] def precedenceParser (rbp : Nat := 0) : Parser :=\n  categoryParser `prec rbp", "start": [19, 1], "end": [20, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.syntaxParser", "code": "@[inline] def syntaxParser (rbp : Nat := 0) : Parser :=\n  categoryParser `stx rbp", "start": [22, 1], "end": [23, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.precedence", "code": "def \u00abprecedence\u00bb := leading_parser\n  \":\" >> precedenceParser maxPrec", "start": [25, 1], "end": [26, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.optPrecedence", "code": "def optPrecedence := optional (atomic \u00abprecedence\u00bb)", "start": [27, 1], "end": [27, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Syntax.numPrec", "code": "@[builtin_prec_parser] def numPrec := checkPrec maxPrec >> numLit", "start": [30, 1], "end": [30, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Syntax.paren", "code": "@[builtin_syntax_parser] def paren           := leading_parser\n  \"(\" >> withoutPosition (many1 syntaxParser) >> \")\"", "start": [32, 1], "end": [33, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Syntax.cat", "code": "@[builtin_syntax_parser] def cat             := leading_parser\n  ident >> optPrecedence", "start": [34, 1], "end": [35, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Syntax.unary", "code": "@[builtin_syntax_parser] def unary           := leading_parser\n  ident >> checkNoWsBefore >> \"(\" >> withoutPosition (many1 syntaxParser) >> \")\"", "start": [36, 1], "end": [37, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Syntax.binary", "code": "@[builtin_syntax_parser] def binary          := leading_parser\n  ident >> checkNoWsBefore >> \"(\" >> withoutPosition (many1 syntaxParser >> \", \" >> many1 syntaxParser) >> \")\"", "start": [38, 1], "end": [39, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Syntax.sepBy", "code": "@[builtin_syntax_parser] def sepBy           := leading_parser\n  \"sepBy(\" >> withoutPosition (many1 syntaxParser >> \", \" >> strLit >>\n    optional (\", \" >> many1 syntaxParser) >> optional (\", \" >> nonReservedSymbol \"allowTrailingSep\")) >> \")\"", "start": [40, 1], "end": [42, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Syntax.sepBy1", "code": "@[builtin_syntax_parser] def sepBy1          := leading_parser\n  \"sepBy1(\" >> withoutPosition (many1 syntaxParser >> \", \" >> strLit >>\n    optional (\", \" >> many1 syntaxParser) >> optional (\", \" >> nonReservedSymbol \"allowTrailingSep\")) >> \")\"", "start": [43, 1], "end": [45, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Syntax.atom", "code": "@[builtin_syntax_parser] def atom            := leading_parser\n  strLit", "start": [46, 1], "end": [47, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Syntax.nonReserved", "code": "@[builtin_syntax_parser] def nonReserved     := leading_parser\n  \"&\" >> strLit", "start": [48, 1], "end": [49, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.namedName", "code": "def namedName := leading_parser\n  atomic (\" (\" >> nonReservedSymbol \"name\") >> \" := \" >> ident >> \")\"", "start": [55, 1], "end": [56, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.optNamedName", "code": "def optNamedName := optional namedName", "start": [57, 1], "end": [57, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.prefix", "code": "def \u00abprefix\u00bb   := leading_parser \"prefix\"", "start": [59, 1], "end": [59, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.infix", "code": "def \u00abinfix\u00bb    := leading_parser \"infix\"", "start": [60, 1], "end": [60, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.infixl", "code": "def \u00abinfixl\u00bb   := leading_parser \"infixl\"", "start": [61, 1], "end": [61, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.infixr", "code": "def \u00abinfixr\u00bb   := leading_parser \"infixr\"", "start": [62, 1], "end": [62, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.postfix", "code": "def \u00abpostfix\u00bb  := leading_parser \"postfix\"", "start": [63, 1], "end": [63, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.mixfixKind", "code": "def mixfixKind := \u00abprefix\u00bb <|> \u00abinfix\u00bb <|> \u00abinfixl\u00bb <|> \u00abinfixr\u00bb <|> \u00abpostfix\u00bb", "start": [64, 1], "end": [64, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.mixfix", "code": "@[builtin_command_parser] def \u00abmixfix\u00bb   := leading_parser\n  optional docComment >> optional Term.\u00abattributes\u00bb >> Term.attrKind >> mixfixKind >>\n  precedence >> optNamedName >> optNamedPrio >> ppSpace >> strLit >> darrow >> termParser", "start": [65, 1], "end": [67, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.identPrec", "code": "def identPrec  := leading_parser ident >> optPrecedence", "start": [70, 1], "end": [70, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.optKind", "code": "def optKind : Parser := optional (\" (\" >> nonReservedSymbol \"kind\" >> \":=\" >> ident >> \")\")", "start": [72, 1], "end": [72, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.notationItem", "code": "def notationItem := ppSpace >> withAntiquot (mkAntiquot \"notationItem\" decl_name%) (strLit <|> identPrec)", "start": [74, 1], "end": [74, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.notation", "code": "@[builtin_command_parser] def \u00abnotation\u00bb    := leading_parser\n  optional docComment >> optional Term.\u00abattributes\u00bb >> Term.attrKind >>\n  \"notation\" >> optPrecedence >> optNamedName >> optNamedPrio >> many notationItem >> darrow >> termParser", "start": [75, 1], "end": [77, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.macro_rules", "code": "@[builtin_command_parser] def \u00abmacro_rules\u00bb := suppressInsideQuot <| leading_parser\n  optional docComment >> optional Term.\u00abattributes\u00bb >> Term.attrKind >>\n  \"macro_rules\" >> optKind >> Term.matchAlts", "start": [78, 1], "end": [80, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.syntax", "code": "@[builtin_command_parser] def \u00absyntax\u00bb      := leading_parser\n  optional docComment >> optional Term.\u00abattributes\u00bb >> Term.attrKind >>\n  \"syntax \" >> optPrecedence >> optNamedName >> optNamedPrio >> many1 (ppSpace >> syntaxParser argPrec) >> \" : \" >> ident", "start": [81, 1], "end": [83, 122], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.syntaxAbbrev", "code": "@[builtin_command_parser] def syntaxAbbrev  := leading_parser\n  optional docComment >> \"syntax \" >> ident >> \" := \" >> many1 syntaxParser", "start": [84, 1], "end": [85, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.catBehaviorBoth", "code": "def catBehaviorBoth   := leading_parser nonReservedSymbol \"both\"", "start": [86, 1], "end": [86, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.catBehaviorSymbol", "code": "def catBehaviorSymbol := leading_parser nonReservedSymbol \"symbol\"", "start": [87, 1], "end": [87, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.catBehavior", "code": "def catBehavior := optional (\" (\" >> nonReservedSymbol \"behavior\" >> \" := \" >> (catBehaviorBoth <|> catBehaviorSymbol) >> \")\")", "start": [88, 1], "end": [88, 127], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.syntaxCat", "code": "@[builtin_command_parser] def syntaxCat := leading_parser\n  optional docComment >> \"declare_syntax_cat \" >> ident >> catBehavior", "start": [89, 1], "end": [90, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.macroArg", "code": "def macroArg  := leading_parser\n  optional (atomic (ident >> checkNoWsBefore \"no space before ':'\" >> \":\")) >> syntaxParser argPrec", "start": [91, 1], "end": [92, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.macroRhs", "code": "def macroRhs : Parser := leading_parser withPosition termParser", "start": [93, 1], "end": [93, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.macroTail", "code": "def macroTail := leading_parser atomic (\" : \" >> ident) >> darrow >> macroRhs", "start": [94, 1], "end": [94, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.macro", "code": "@[builtin_command_parser] def \u00abmacro\u00bb       := leading_parser suppressInsideQuot <|\n  optional docComment >> optional Term.\u00abattributes\u00bb >> Term.attrKind >>\n  \"macro\" >> optPrecedence >> optNamedName >> optNamedPrio >> many1 (ppSpace >> macroArg) >> macroTail", "start": [95, 1], "end": [97, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.elab_rules", "code": "@[builtin_command_parser] def \u00abelab_rules\u00bb := leading_parser suppressInsideQuot <|\n  optional docComment >> optional Term.\u00abattributes\u00bb >> Term.attrKind >>\n  \"elab_rules\" >> optKind >> optional (\" : \" >> ident) >> optional (\" <= \" >> ident) >> Term.matchAlts", "start": [98, 1], "end": [100, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.elabArg", "code": "def elabArg  := macroArg", "start": [101, 1], "end": [101, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.elabTail", "code": "def elabTail := leading_parser atomic (\" : \" >> ident >> optional (\" <= \" >> ident)) >> darrow >> withPosition termParser", "start": [102, 1], "end": [102, 122], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Command.elab", "code": "@[builtin_command_parser] def \u00abelab\u00bb       := leading_parser suppressInsideQuot <|\n  optional docComment >> optional Term.\u00abattributes\u00bb >> Term.attrKind >>\n  \"elab\" >> optPrecedence >> optNamedName >> optNamedPrio >> many1 (ppSpace >> elabArg) >> elabTail", "start": [103, 1], "end": [105, 100], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Tactic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.Tactic.unknown", "code": "@[builtin_tactic_parser] def \u00abunknown\u00bb    := leading_parser\n  withPosition (ident >> errorAtSavedPos \"unknown tactic\" true)", "start": [22, 1], "end": [23, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.nestedTactic", "code": "@[builtin_tactic_parser] def nestedTactic := tacticSeqBracketed", "start": [25, 1], "end": [25, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.matchRhs", "code": "def matchRhs  := Term.hole <|> Term.syntheticHole <|> tacticSeq", "start": [27, 1], "end": [27, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.matchAlts", "code": "def matchAlts := Term.matchAlts (rhsParser := matchRhs)", "start": [28, 1], "end": [28, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.match", "code": "@[builtin_tactic_parser] def \u00abmatch\u00bb := leading_parser:leadPrec\n  \"match \" >> optional Term.generalizingParam >>\n  optional Term.motive >> sepBy1 Term.matchDiscr \", \" >>\n  \" with \" >> ppDedent matchAlts", "start": [30, 1], "end": [46, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.introMatch", "code": "@[builtin_tactic_parser] def introMatch := leading_parser\n  nonReservedSymbol \"intro\" >> matchAlts", "start": [48, 1], "end": [66, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.decide", "code": "@[builtin_tactic_parser] def decide := leading_parser\n  nonReservedSymbol \"decide\"", "start": [68, 1], "end": [77, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.nativeDecide", "code": "@[builtin_tactic_parser] def nativeDecide := leading_parser\n  nonReservedSymbol \"native_decide\"", "start": [79, 1], "end": [93, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser/Module.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Command.lean", "lake-packages/lean4/src/lean/Lean/Message.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.Module.prelude", "code": "def \u00abprelude\u00bb  := leading_parser \"prelude\"", "start": [13, 1], "end": [13, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Module.import", "code": "def \u00abimport\u00bb   := leading_parser \"import \" >> optional \"runtime\" >> ident", "start": [14, 1], "end": [14, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Module.header", "code": "def header     := leading_parser optional (\u00abprelude\u00bb >> ppLine) >> many (\u00abimport\u00bb >> ppLine) >> ppLine", "start": [15, 1], "end": [15, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Module.module", "code": "@[run_builtin_parser_attribute_hooks]\ndef module     := leading_parser header >> many (commandParser >> ppLine >> ppLine)", "start": [16, 1], "end": [21, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Module.updateTokens", "code": "def updateTokens (tokens : TokenTable) : TokenTable :=\n  match addParserTokens tokens header.info with\n    | Except.ok tables => tables\n    | Except.error _   => unreachable!", "start": [23, 1], "end": [26, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.ModuleParserState", "code": "structure ModuleParserState where\n  pos        : String.Pos := 0\n  recovering : Bool       := false\n  deriving Inhabited", "start": [30, 1], "end": [33, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkErrorMessage", "code": "private def mkErrorMessage (c : InputContext) (s : ParserState) (e : Parser.Error) : Message := Id.run do\n  let mut pos := s.pos\n  let mut endPos? := none\n  let mut e := e\n  unless e.unexpectedTk.isMissing do\n    if let some r := e.unexpectedTk.getRange? then\n      pos := r.start\n      endPos? := some r.stop\n    let unexpected := match e.unexpectedTk with\n      | .ident .. => \"unexpected identifier\"\n      | .atom _ v => s!\"unexpected token '{v}'\"\n      | _         => \"unexpected token\"  e := { e with unexpected }\n    if let .original (trailing := trailing) .. := s.stxStack.back.getTailInfo then\n      if trailing.stopPos == pos then\n        pos := trailing.startPos\n  { fileName := c.fileName\n    pos := c.fileMap.toPosition pos\n    endPos := c.fileMap.toPosition <$> endPos?\n    keepFullRange := true\n    data := toString e }", "start": [35, 1], "end": [58, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.parseHeader", "code": "def parseHeader (inputCtx : InputContext) : IO (Syntax \u00d7 ModuleParserState \u00d7 MessageLog) := do\n  let dummyEnv \u2190 mkEmptyEnvironment\n  let p   := andthenFn whitespace Module.header.fn\n  let tokens := Module.updateTokens (getTokenTable dummyEnv)\n  let s   := p.run inputCtx { env := dummyEnv, options := {} } tokens (mkParserState inputCtx.input)\n  let stx := if s.stxStack.isEmpty then .missing else s.stxStack.back\n  match s.errorMsg with\n  | some errorMsg =>\n    let msg := mkErrorMessage inputCtx s errorMsg\n    pure (stx, { pos := s.pos, recovering := true }, { : MessageLog }.add msg)\n  | none =>\n    pure (stx, { pos := s.pos }, {})", "start": [60, 1], "end": [71, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.mkEOI", "code": "private def mkEOI (pos : String.Pos) : Syntax :=\n  let atom := mkAtom (SourceInfo.original \"\".toSubstring pos \"\".toSubstring pos) \"\"\n  mkNode ``Command.eoi #[atom]", "start": [73, 1], "end": [75, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.isTerminalCommand", "code": "def isTerminalCommand (s : Syntax) : Bool :=\n  s.isOfKind ``Command.exit || s.isOfKind ``Command.import || s.isOfKind ``Command.eoi", "start": [77, 1], "end": [78, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.consumeInput", "code": "private def consumeInput (inputCtx : InputContext) (pmctx : ParserModuleContext) (pos : String.Pos) : String.Pos :=\n  let s : ParserState := { cache := initCacheForInput inputCtx.input, pos := pos }\n  let s := tokenFn [] |>.run inputCtx pmctx (getTokenTable pmctx.env) s\n  match s.errorMsg with\n  | some _ => pos + ' '\n  | none   => s.pos", "start": [80, 1], "end": [85, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.topLevelCommandParserFn", "code": "def topLevelCommandParserFn : ParserFn :=\n  commandParser.fn", "start": [87, 1], "end": [88, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.parseCommand", "code": "partial def parseCommand (inputCtx : InputContext) (pmctx : ParserModuleContext) (mps : ModuleParserState) (messages : MessageLog) : Syntax \u00d7 ModuleParserState \u00d7 MessageLog := Id.run do\n  let mut pos := mps.pos\n  let mut recovering := mps.recovering\n  let mut messages := messages\n  let mut stx := Syntax.missing  repeat\n    if inputCtx.input.atEnd pos then\n      stx := mkEOI pos\n      break\n    let pos' := pos\n    let p := andthenFn whitespace topLevelCommandParserFn\n    let s := p.run inputCtx pmctx (getTokenTable pmctx.env) { cache := initCacheForInput inputCtx.input, pos }\n    pos := s.pos\n    if recovering && !s.stxStack.isEmpty && s.stxStack.back.isAntiquot then\n      continue\n    match s.errorMsg with\n    | none =>\n      stx := s.stxStack.back\n      recovering := false\n      break\n    | some errorMsg =>\n      if pos == pos' then\n        pos := consumeInput inputCtx pmctx pos\n      \n      let ignore := s.stxStack.isEmpty || s.stxStack.back.getPos?.isNone\n      unless recovering && ignore do\n        messages := messages.add <| mkErrorMessage inputCtx s errorMsg\n      recovering := true\n      if ignore then\n        continue\n      else\n        stx := s.stxStack.back\n        break\n  return (stx, { pos, recovering }, messages)", "start": [90, 1], "end": [127, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.testParseModuleAux", "code": "partial def testParseModuleAux (env : Environment) (inputCtx : InputContext) (s : ModuleParserState) (msgs : MessageLog) (stxs  : Array Syntax) : IO (Array Syntax) :=\n  let rec parse (state : ModuleParserState) (msgs : MessageLog) (stxs : Array Syntax) :=\n    match parseCommand inputCtx { env := env, options := {} } state msgs with\n    | (stx, state, msgs) =>\n      if isTerminalCommand stx then\n        if msgs.isEmpty then\n          pure stxs\n        else do\n          msgs.forM fun msg => msg.toString >>= IO.println\n          throw (IO.userError \"failed to parse file\")\n      else\n        parse state msgs (stxs.push stx)\n  parse s msgs stxs", "start": [131, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.testParseModule", "code": "def testParseModule (env : Environment) (fname contents : String) : IO (TSyntax ``Parser.Module.module) := do\n  let inputCtx := mkInputContext contents fname\n  let (header, state, messages) \u2190 parseHeader inputCtx\n  let cmds \u2190 testParseModuleAux env inputCtx state messages #[]\n  let stx := mkNode `Lean.Parser.Module.module #[header, mkListNode cmds]\n  pure \u27e8stx.raw.updateLeading\u27e9", "start": [145, 1], "end": [150, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.testParseFile", "code": "def testParseFile (env : Environment) (fname : System.FilePath) : IO (TSyntax ``Parser.Module.module) := do\n  let contents \u2190 IO.FS.readFile fname\n  testParseModule env fname.toString contents", "start": [152, 1], "end": [154, 46], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ForEachExprWhere.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/PPGoal.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.MVarId.getTag", "code": "def _root_.Lean.MVarId.getTag (mvarId : MVarId) : MetaM Name :=\n  return (\u2190 mvarId.getDecl).userName", "start": [13, 1], "end": [15, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMVarTag", "code": "@[deprecated MVarId.getTag]\ndef getMVarTag (mvarId : MVarId) : MetaM Name :=\n  mvarId.getTag", "start": [17, 1], "end": [19, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.setTag", "code": "def _root_.Lean.MVarId.setTag (mvarId : MVarId) (tag : Name) : MetaM Unit := do\n  modify fun s => { s with mctx := s.mctx.setMVarUserName mvarId tag }", "start": [21, 1], "end": [22, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.setMVarTag", "code": "@[deprecated MVarId.setTag]\ndef setMVarTag (mvarId : MVarId) (tag : Name) : MetaM Unit := do\n  mvarId.setTag tag", "start": [24, 1], "end": [26, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.appendTag", "code": "def appendTag (tag : Name) (suffix : Name) : Name :=\n  tag.modifyBase (\u00b7 ++ suffix.eraseMacroScopes)", "start": [28, 1], "end": [29, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.appendTagSuffix", "code": "def appendTagSuffix (mvarId : MVarId) (suffix : Name) : MetaM Unit := do\n  let tag \u2190 mvarId.getTag\n  mvarId.setTag (appendTag tag suffix)", "start": [31, 1], "end": [33, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshExprSyntheticOpaqueMVar", "code": "def mkFreshExprSyntheticOpaqueMVar (type : Expr) (tag : Name := Name.anonymous) : MetaM Expr :=\n  mkFreshExprMVar type MetavarKind.syntheticOpaque tag", "start": [35, 1], "end": [36, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwTacticEx", "code": "def throwTacticEx (tacticName : Name) (mvarId : MVarId) (msg : MessageData) : MetaM \u03b1 :=\n  if msg.isEmpty then\n    throwError \"tactic '{tacticName}' failed\\n{mvarId}\"\n  else\n    throwError \"tactic '{tacticName}' failed, {msg}\\n{mvarId}\"", "start": [38, 1], "end": [42, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwNestedTacticEx", "code": "def throwNestedTacticEx {\u03b1} (tacticName : Name) (ex : Exception) : MetaM \u03b1 := do\n  throwError \"tactic '{tacticName}' failed, nested error:\\n{ex.toMessageData}\"", "start": [44, 1], "end": [45, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.checkNotAssigned", "code": "def _root_.Lean.MVarId.checkNotAssigned (mvarId : MVarId) (tacticName : Name) : MetaM Unit := do\n  if (\u2190 mvarId.isAssigned) then\n    throwTacticEx tacticName mvarId \"metavariable has already been assigned\"", "start": [47, 1], "end": [50, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkNotAssigned", "code": "@[deprecated MVarId.checkNotAssigned]\ndef checkNotAssigned (mvarId : MVarId) (tacticName : Name) : MetaM Unit := do\n  mvarId.checkNotAssigned tacticName", "start": [52, 1], "end": [54, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.getType", "code": "def _root_.Lean.MVarId.getType (mvarId : MVarId) : MetaM Expr :=\n  return (\u2190 mvarId.getDecl).type", "start": [56, 1], "end": [58, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMVarType", "code": "@[deprecated MVarId.getType]\ndef getMVarType (mvarId : MVarId) : MetaM Expr :=\n  mvarId.getType", "start": [60, 1], "end": [62, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.getType'", "code": "def _root_.Lean.MVarId.getType' (mvarId : MVarId) : MetaM Expr := do\n  instantiateMVars (\u2190 whnf (\u2190 mvarId.getType))", "start": [64, 1], "end": [70, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMVarType'", "code": "@[deprecated MVarId.getType']\ndef getMVarType' (mvarId : MVarId) : MetaM Expr := do\n  mvarId.getType'", "start": [72, 1], "end": [74, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.admit", "code": "def _root_.Lean.MVarId.admit (mvarId : MVarId) (synthetic := true) : MetaM Unit :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `admit\n    let mvarType \u2190 mvarId.getType\n    let val \u2190 mkSorry mvarType synthetic\n    mvarId.assign val", "start": [78, 1], "end": [84, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.admit", "code": "@[deprecated MVarId.admit]\ndef admit (mvarId : MVarId) (synthetic := true) : MetaM Unit :=\n  mvarId.admit synthetic", "start": [86, 1], "end": [88, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.headBetaType", "code": "def _root_.Lean.MVarId.headBetaType (mvarId : MVarId) : MetaM Unit := do\n  mvarId.setType (\u2190 mvarId.getType).headBeta", "start": [90, 1], "end": [92, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.headBetaMVarType", "code": "@[deprecated MVarId.headBetaType]\ndef headBetaMVarType (mvarId : MVarId) : MetaM Unit := do\n  mvarId.headBetaType", "start": [94, 1], "end": [96, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.getNondepPropHyps", "code": "def _root_.Lean.MVarId.getNondepPropHyps (mvarId : MVarId) : MetaM (Array FVarId) :=\n  let removeDeps (e : Expr) (candidates : FVarIdHashSet) : MetaM FVarIdHashSet := do\n    let e \u2190 instantiateMVars e\n    let visit : StateRefT FVarIdHashSet MetaM FVarIdHashSet := do\n      e.forEachWhere Expr.isFVar fun e => modify fun s => s.erase e.fvarId!\n      get\n    visit |>.run' candidates\n  mvarId.withContext do\n    let mut candidates : FVarIdHashSet := {}\n    for localDecl in (\u2190 getLCtx) do\n      unless localDecl.isImplementationDetail do\n        candidates \u2190 removeDeps localDecl.type candidates\n        match localDecl.value? with\n        | none => pure ()\n        | some value => candidates \u2190 removeDeps value candidates\n        if (\u2190 isProp localDecl.type) && !localDecl.hasValue then\n          candidates := candidates.insert localDecl.fvarId\n    candidates \u2190 removeDeps (\u2190 mvarId.getType) candidates\n    if candidates.isEmpty then\n      return #[]\n    else\n      let mut result := #[]\n      for localDecl in (\u2190 getLCtx) do\n        if candidates.contains localDecl.fvarId then\n          result := result.push localDecl.fvarId\n      return result", "start": [98, 1], "end": [124, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getNondepPropHyps", "code": "@[deprecated MVarId.getNondepPropHyps]\ndef getNondepPropHyps (mvarId : MVarId) : MetaM (Array FVarId) :=\n  mvarId.getNondepPropHyps", "start": [126, 1], "end": [128, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.saturate", "code": "partial def saturate (mvarId : MVarId) (x : MVarId \u2192 MetaM (Option (List MVarId))) : MetaM (List MVarId) := do\n  let (_, r) \u2190 go mvarId |>.run #[]\n  return r.toList\nwhere\n  go (mvarId : MVarId) : StateRefT (Array MVarId) MetaM Unit :=\n    withIncRecDepth do\n      match (\u2190 x mvarId) with\n      | none => modify fun s => s.push mvarId\n      | some mvarIds => mvarIds.forM go", "start": [130, 1], "end": [138, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.exactlyOne", "code": "def exactlyOne (mvarIds : List MVarId) (msg : MessageData := \"unexpected number of goals\") : MetaM MVarId :=\n  match mvarIds with\n  | [mvarId] => return mvarId\n  | _        => throwError msg", "start": [140, 1], "end": [143, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ensureAtMostOne", "code": "def ensureAtMostOne (mvarIds : List MVarId) (msg : MessageData := \"unexpected number of goals\") : MetaM (Option MVarId) :=\n  match mvarIds with\n  | []       => return none\n  | [mvarId] => return some mvarId\n  | _        => throwError msg", "start": [145, 1], "end": [149, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getPropHyps", "code": "def getPropHyps : MetaM (Array FVarId) := do\n  let mut result := #[]\n  for localDecl in (\u2190 getLCtx) do\n    unless localDecl.isImplementationDetail do\n      if (\u2190 isProp localDecl.type) then\n        result := result.push localDecl.fvarId\n  return result", "start": [151, 1], "end": [158, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.inferInstance", "code": "def _root_.Lean.MVarId.inferInstance (mvarId : MVarId) : MetaM Unit := mvarId.withContext do\n  mvarId.checkNotAssigned `infer_instance\n  let synthVal \u2190 synthInstance (\u2190 mvarId.getType)\n  unless (\u2190 isDefEq (mkMVar mvarId) synthVal) do\n    throwTacticEx `infer_instance mvarId \"`infer_instance` tactic failed to assign instance\"", "start": [160, 1], "end": [164, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.TacticResultCNM", "code": "inductive TacticResultCNM where\n  | closed\n  | noChange\n  | modified (mvarId : MVarId)", "start": [166, 1], "end": [169, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Options.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/TopDownAnalyze.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/SubExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean"], "premises": [{"full_name": "Lean.PrettyPrinter.Delaborator.Context", "code": "structure Context where\n  optionsPerPos  : OptionsPerPos\n  currNamespace  : Name\n  openDecls      : List OpenDecl\n  inPattern      : Bool := false subExpr        : SubExpr", "start": [37, 1], "end": [42, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.State", "code": "structure State where\n  \n  infos    : PosMap Info := {}\n  \n  holeIter : SubExpr.HoleIterator := {}", "start": [44, 1], "end": [50, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.DelabM", "code": "abbrev DelabM := ReaderT Context (StateRefT State MetaM)", "start": [56, 1], "end": [56, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.Delab", "code": "abbrev Delab := DelabM Term", "start": [57, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.orElse", "code": "@[inline] protected def orElse (d\u2081 : DelabM \u03b1) (d\u2082 : Unit \u2192 DelabM \u03b1) : DelabM \u03b1 := do\n  catchInternalId delabFailureId d\u2081 fun _ => d\u2082 ()", "start": [62, 1], "end": [63, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.failure", "code": "protected def failure : DelabM \u03b1 :=\n  throw $ Exception.internal delabFailureId", "start": [65, 1], "end": [66, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.mkDelabAttribute", "code": "unsafe def mkDelabAttribute : IO (KeyedDeclsAttribute Delab) :=\n  KeyedDeclsAttribute.init {\n    builtinName := `builtin_delab,\n    name := `delab,\n    descr    := \"Register a delaborator.\n\n  [delab k] registers a declaration of type `Lean.PrettyPrinter.Delaborator.Delab` for the `Lean.Expr`\n  constructor `k`. Multiple delaborators for a single constructor are tried in turn until\n  the first success. If the term to be delaborated is an application of a constant `c`,\n  elaborators for `app.c` are tried first; this is also done for `Expr.const`s (\\\"nullary applications\\\")\n  to reduce special casing. If the term is an `Expr.mdata` with a single key `k`, `mdata.k`\n  is tried first.\",\n    valueTypeName := `Lean.PrettyPrinter.Delaborator.Delab\n    evalKey := fun _ stx => do\n      let stx \u2190 Attribute.Builtin.getIdent stx\n      let kind := stx.getId\n      if (\u2190 Elab.getInfoState).enabled && kind.getRoot == `app then\n        let c := kind.replacePrefix `app .anonymous\n        if (\u2190 getEnv).contains c then\n          Elab.addConstInfo stx c none\n      pure kind\n  } `Lean.PrettyPrinter.Delaborator.delabAttribute", "start": [95, 1], "end": [116, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabAttribute", "code": "@[builtin_init mkDelabAttribute] opaque delabAttribute : KeyedDeclsAttribute Delab", "start": [117, 1], "end": [117, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.getExprKind", "code": "def getExprKind : DelabM Name := do\n  let e \u2190 getExpr\n  pure $ match e with\n  | Expr.bvar _          => `bvar\n  | Expr.fvar _          => `fvar\n  | Expr.mvar _          => `mvar\n  | Expr.sort _          => `sort\n  | Expr.const c _       =>\n    `app ++ c\n  | Expr.app fn _        => match fn.getAppFn with\n    | Expr.const c _   => `app ++ c\n    | _                => `app\n  | Expr.lam _ _ _ _     => `lam\n  | Expr.forallE _ _ _ _ => `forallE\n  | Expr.letE _ _ _ _ _  => `letE\n  | Expr.lit _           => `lit\n  | Expr.mdata m _       => match m.entries with\n    | [(key, _)] => `mdata ++ key\n    | _   => `mdata\n  | Expr.proj _ _ _      => `proj", "start": [119, 1], "end": [139, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.getOptionsAtCurrPos", "code": "def getOptionsAtCurrPos : DelabM Options := do\n  let ctx \u2190 read\n  let mut opts \u2190 getOptions\n  if let some opts' := ctx.optionsPerPos.find? (\u2190 getPos) then\n    for (k, v) in opts' do\n      opts := opts.insert k v\n  return opts", "start": [141, 1], "end": [147, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.getPPOption", "code": "def getPPOption (opt : Options \u2192 Bool) : DelabM Bool := do\n  return opt (\u2190 getOptionsAtCurrPos)", "start": [149, 1], "end": [151, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.whenPPOption", "code": "def whenPPOption (opt : Options \u2192 Bool) (d : Delab) : Delab := do\n  let b \u2190 getPPOption opt\n  if b then d else failure", "start": [153, 1], "end": [155, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.whenNotPPOption", "code": "def whenNotPPOption (opt : Options \u2192 Bool) (d : Delab) : Delab := do\n  let b \u2190 getPPOption opt\n  if b then failure else d", "start": [157, 1], "end": [159, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.withOptionAtCurrPos", "code": "def withOptionAtCurrPos (k : Name) (v : DataValue) (x : DelabM \u03b1) : DelabM \u03b1 := do\n  let pos \u2190 getPos\n  withReader\n    (fun ctx =>\n      let opts' := ctx.optionsPerPos.find? pos |>.getD {} |>.insert k v\n      { ctx with optionsPerPos := ctx.optionsPerPos.insert pos opts' })\n    x", "start": [161, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.annotatePos", "code": "def annotatePos (pos : Pos) (stx : Term) : Term :=\n  \u27e8stx.raw.setInfo (SourceInfo.synthetic \u27e8pos\u27e9 \u27e8pos\u27e9)\u27e9", "start": [170, 1], "end": [171, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.annotateCurPos", "code": "def annotateCurPos (stx : Term) : Delab :=\n  return annotatePos (\u2190 getPos) stx", "start": [173, 1], "end": [174, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.getUnusedName", "code": "def getUnusedName (suggestion : Name) (body : Expr) : DelabM Name := do\n  let suggestion := if suggestion.isAnonymous then `a else suggestion\n  let suggestion := suggestion.eraseMacroScopes\n  let lctx \u2190 getLCtx\n  if !lctx.usesUserName suggestion then\n    return suggestion\n  else if (\u2190 getPPOption getPPSafeShadowing) && !bodyUsesSuggestion lctx suggestion then\n    return suggestion\n  else\n    return lctx.getUnusedName suggestion\nwhere\n  bodyUsesSuggestion (lctx : LocalContext) (suggestion' : Name) : Bool :=\n    Option.isSome <| body.find? fun\n      | Expr.fvar fvarId =>\n        match lctx.find? fvarId with\n        | none      => false\n        | some decl => decl.userName == suggestion'\n      | _ => false", "start": [176, 1], "end": [195, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.withBindingBodyUnusedName", "code": "def withBindingBodyUnusedName {\u03b1} (d : Syntax \u2192 DelabM \u03b1) : DelabM \u03b1 := do\n  let n \u2190 getUnusedName (\u2190 getExpr).bindingName! (\u2190 getExpr).bindingBody!\n  let stxN \u2190 annotateCurPos (mkIdent n)\n  withBindingBody n $ d stxN", "start": [197, 1], "end": [200, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.liftMetaM", "code": "@[inline] def liftMetaM {\u03b1} (x : MetaM \u03b1) : DelabM \u03b1 :=\n  liftM x", "start": [202, 1], "end": [203, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.addTermInfo", "code": "def addTermInfo (pos : Pos) (stx : Syntax) (e : Expr) (isBinder : Bool := false) : DelabM Unit := do\n  let info \u2190 mkTermInfo stx e isBinder\n  modify fun s => { s with infos := s.infos.insert pos info }\nwhere\n  mkTermInfo stx e isBinder := return Info.ofTermInfo {\n    elaborator := `Delab,\n    stx := stx,\n    lctx := (\u2190 getLCtx),\n    expectedType? := none,\n    expr := e,\n    isBinder := isBinder\n }", "start": [205, 1], "end": [216, 3], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.addFieldInfo", "code": "def addFieldInfo (pos : Pos) (projName fieldName : Name) (stx : Syntax) (val : Expr) : DelabM Unit := do\n  let info \u2190 mkFieldInfo projName fieldName stx val\n  modify fun s => { s with infos := s.infos.insert pos info }\nwhere\n  mkFieldInfo projName fieldName stx val := return Info.ofFieldInfo {\n    projName := projName,\n    fieldName := fieldName,\n    lctx := (\u2190 getLCtx),\n    val := val,\n    stx := stx\n  }", "start": [218, 1], "end": [228, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.annotateTermInfo", "code": "def annotateTermInfo (stx : Term) : Delab := do\n  let stx \u2190 annotateCurPos stx\n  addTermInfo (\u2190 getPos) stx (\u2190 getExpr)\n  pure stx", "start": [230, 1], "end": [233, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabFor", "code": "partial def delabFor : Name \u2192 Delab\n  | Name.anonymous => failure\n  | k              =>\n    (do annotateTermInfo (\u2190 (delabAttribute.getValues (\u2190 getEnv) k).firstM id))\n    <|> if k.isAtomic then failure else delabFor k.getRoot", "start": [235, 1], "end": [240, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delab", "code": "partial def delab : Delab := do\n  checkMaxHeartbeats \"delab\"\n  let e \u2190 getExpr\n\n  if \u2190 pure !e.isAtomic <&&> pure !(\u2190 getPPOption getPPProofs) <&&> (try Meta.isProof e catch _ => pure false) then\n    if \u2190 getPPOption getPPProofsWithType then\n      let stx \u2190 withType delab\n      return \u2190 annotateTermInfo (\u2190 `((_ : $stx)))\n    else\n      return \u2190 annotateTermInfo (\u2190 ``(_))\n  let k \u2190 getExprKind\n  let stx \u2190 delabFor k <|> (liftM $ show MetaM _ from throwError \"don't know how to delaborate '{k}'\")\n  if \u2190 getPPOption getPPAnalyzeTypeAscriptions <&&> getPPOption getPPAnalysisNeedsType <&&> pure !e.isMData then\n    let typeStx \u2190 withType delab\n    `(($stx : $typeStx)) >>= annotateCurPos\n  else\n    return stx", "start": [242, 1], "end": [259, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.mkAppUnexpanderAttribute", "code": "unsafe def mkAppUnexpanderAttribute : IO (KeyedDeclsAttribute Unexpander) :=\n  KeyedDeclsAttribute.init {\n    name  := `app_unexpander,\n    descr := \"Register an unexpander for applications of a given constant.\n\n[app_unexpander c] registers a `Lean.PrettyPrinter.Unexpander` for applications of the constant `c`. The unexpander is\npassed the result of pre-pretty printing the application *without* implicitly passed arguments. If `pp.explicit` is set\nto true or `pp.notation` is set to false, it will not be called at all.\",\n    valueTypeName := `Lean.PrettyPrinter.Unexpander\n    evalKey := fun _ stx => do\n      Elab.resolveGlobalConstNoOverloadWithInfo (\u2190 Attribute.Builtin.getIdent stx)\n  } `Lean.PrettyPrinter.Delaborator.appUnexpanderAttribute", "start": [261, 1], "end": [272, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.appUnexpanderAttribute", "code": "@[builtin_init mkAppUnexpanderAttribute] opaque appUnexpanderAttribute : KeyedDeclsAttribute Unexpander", "start": [273, 1], "end": [273, 104], "kind": "commanddeclaration"}, {"full_name": "delabCore", "code": "def delabCore (e : Expr) (optionsPerPos : OptionsPerPos := {}) (delab := Delaborator.delab) : MetaM (Term \u00d7 PosMap Elab.Info) := do\n  \n  let e \u2190 Meta.erasePatternRefAnnotations e\n  trace[PrettyPrinter.delab.input] \"{Std.format e}\"\n  let mut opts \u2190 getOptions\n  if pp.proofs.get? opts == none &&\n      !e.isConst then\n    try if \u2190 Meta.isProof e then opts := pp.proofs.set opts true\n    catch _ => pure ()\n  withOptions (fun _ => opts) do\n    let e \u2190 if getPPInstantiateMVars opts then instantiateMVars e else pure e\n    let optionsPerPos \u2190\n      if !getPPAll opts && getPPAnalyze opts && optionsPerPos.isEmpty then\n        topDownAnalyze e\n      else pure optionsPerPos\n    let (stx, {infos := infos, ..}) \u2190 catchInternalId Delaborator.delabFailureId\n        (delab\n          { optionsPerPos := optionsPerPos\n            currNamespace := (\u2190 getCurrNamespace)\n            openDecls := (\u2190 getOpenDecls)\n            subExpr := SubExpr.mkRoot e\n            inPattern := opts.getInPattern }\n          |>.run { : Delaborator.State })\n        (fun _ => unreachable!)\n    return (stx, infos)", "start": [280, 1], "end": [307, 24], "kind": "commanddeclaration"}, {"full_name": "delab", "code": "def delab (e : Expr) (optionsPerPos : OptionsPerPos := {}) : MetaM Term := do\n  let (stx, _) \u2190 delabCore e optionsPerPos\n  return stx", "start": [309, 1], "end": [312, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Parser.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Level.lean", "lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Lean/Parser/Command.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Parser/Module.lean", "lake-packages/lean4/src/lean/Lean/Parser/Do.lean", "lake-packages/lean4/src/lean/Lean/Parser/Tactic.lean", "lake-packages/lean4/src/lean/Lean/Parser/Basic.lean", "lake-packages/lean4/src/lean/Lean/Parser/Syntax.lean"], "premises": [{"full_name": "Lean.PrettyPrinter.Parenthesizer.mkAntiquot.parenthesizer", "code": "@[export lean_mk_antiquot_parenthesizer]\ndef mkAntiquot.parenthesizer (name : String) (kind : SyntaxNodeKind) (anonymous := true) (isPseudoKind := true) : Parenthesizer :=\n  Parser.mkAntiquot.parenthesizer name kind anonymous isPseudoKind", "start": [60, 1], "end": [62, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.ident.parenthesizer", "code": "@[builtin_parenthesizer ident] def ident.parenthesizer : Parenthesizer := Parser.Term.ident.parenthesizer", "start": [66, 1], "end": [66, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.numLit.parenthesizer", "code": "@[builtin_parenthesizer num] def numLit.parenthesizer : Parenthesizer := Parser.Term.num.parenthesizer", "start": [67, 1], "end": [67, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.scientificLit.parenthesizer", "code": "@[builtin_parenthesizer scientific] def scientificLit.parenthesizer : Parenthesizer := Parser.Term.scientific.parenthesizer", "start": [68, 1], "end": [68, 124], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.charLit.parenthesizer", "code": "@[builtin_parenthesizer char] def charLit.parenthesizer : Parenthesizer := Parser.Term.char.parenthesizer", "start": [69, 1], "end": [69, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.strLit.parenthesizer", "code": "@[builtin_parenthesizer str] def strLit.parenthesizer : Parenthesizer := Parser.Term.str.parenthesizer", "start": [70, 1], "end": [70, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Parenthesizer.interpretParserDescr", "code": "@[export lean_pretty_printer_parenthesizer_interpret_parser_descr]\nunsafe def interpretParserDescr : ParserDescr \u2192 CoreM Parenthesizer\n  | ParserDescr.const n                             => getConstAlias parenthesizerAliasesRef n\n  | ParserDescr.unary n d                           => return (\u2190 getUnaryAlias parenthesizerAliasesRef n) (\u2190 interpretParserDescr d)\n  | ParserDescr.binary n d\u2081 d\u2082                      => return (\u2190 getBinaryAlias parenthesizerAliasesRef n) (\u2190 interpretParserDescr d\u2081) (\u2190 interpretParserDescr d\u2082)\n  | ParserDescr.node k prec d                       => return leadingNode.parenthesizer k prec (\u2190 interpretParserDescr d)\n  | ParserDescr.nodeWithAntiquot n k d              => return withAntiquot.parenthesizer (mkAntiquot.parenthesizer' n k (anonymous := true)) <|\n                                                                node.parenthesizer k (\u2190 interpretParserDescr d)\n  | ParserDescr.sepBy p sep psep trail              => return sepBy.parenthesizer (\u2190 interpretParserDescr p) sep (\u2190 interpretParserDescr psep) trail\n  | ParserDescr.sepBy1 p sep psep trail             => return sepBy1.parenthesizer (\u2190 interpretParserDescr p) sep (\u2190 interpretParserDescr psep) trail\n  | ParserDescr.trailingNode k prec lhsPrec d       => return trailingNode.parenthesizer k prec lhsPrec (\u2190 interpretParserDescr d)\n  | ParserDescr.symbol tk                           => return symbol.parenthesizer tk\n  | ParserDescr.nonReservedSymbol tk includeIdent   => return nonReservedSymbol.parenthesizer tk includeIdent\n  | ParserDescr.parser constName                    => combinatorParenthesizerAttribute.runDeclFor constName\n  | ParserDescr.cat catName prec                    => return categoryParser.parenthesizer catName prec", "start": [74, 1], "end": [88, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.mkAntiquot.formatter", "code": "@[export lean_mk_antiquot_formatter]\ndef mkAntiquot.formatter (name : String) (kind : SyntaxNodeKind) (anonymous := true) (isPseudoKind := true) : Formatter :=\n  Parser.mkAntiquot.formatter name kind anonymous isPseudoKind", "start": [94, 1], "end": [96, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.ident.formatter", "code": "@[builtin_formatter ident] def ident.formatter : Formatter := Parser.Term.ident.formatter", "start": [98, 1], "end": [98, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.numLit.formatter", "code": "@[builtin_formatter num] def numLit.formatter : Formatter := Parser.Term.num.formatter", "start": [99, 1], "end": [99, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.scientificLit.formatter", "code": "@[builtin_formatter scientific] def scientificLit.formatter : Formatter := Parser.Term.scientific.formatter", "start": [100, 1], "end": [100, 108], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.charLit.formatter", "code": "@[builtin_formatter char] def charLit.formatter : Formatter := Parser.Term.char.formatter", "start": [101, 1], "end": [101, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.strLit.formatter", "code": "@[builtin_formatter str] def strLit.formatter : Formatter := Parser.Term.str.formatter", "start": [102, 1], "end": [102, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Formatter.interpretParserDescr", "code": "@[export lean_pretty_printer_formatter_interpret_parser_descr]\nunsafe def interpretParserDescr : ParserDescr \u2192 CoreM Formatter\n  | ParserDescr.const n                             => getConstAlias formatterAliasesRef n\n  | ParserDescr.unary n d                           => return (\u2190 getUnaryAlias formatterAliasesRef n) (\u2190 interpretParserDescr d)\n  | ParserDescr.binary n d\u2081 d\u2082                      => return (\u2190 getBinaryAlias formatterAliasesRef n) (\u2190 interpretParserDescr d\u2081) (\u2190 interpretParserDescr d\u2082)\n  | ParserDescr.node k _ d                          => return node.formatter k (\u2190 interpretParserDescr d)\n  | ParserDescr.nodeWithAntiquot n k d              => return withAntiquot.formatter (mkAntiquot.formatter' n k (anonymous := true)) <|\n                                                                node.formatter k (\u2190 interpretParserDescr d)\n  | ParserDescr.sepBy p sep psep trail              => return sepBy.formatter (\u2190 interpretParserDescr p) sep (\u2190 interpretParserDescr psep) trail\n  | ParserDescr.sepBy1 p sep psep trail             => return sepBy1.formatter (\u2190 interpretParserDescr p) sep (\u2190 interpretParserDescr psep) trail\n  | ParserDescr.trailingNode k prec lhsPrec d       => return trailingNode.formatter k prec lhsPrec (\u2190 interpretParserDescr d)\n  | ParserDescr.symbol tk                           => return symbol.formatter tk\n  | ParserDescr.nonReservedSymbol tk _              => return nonReservedSymbol.formatter tk\n  | ParserDescr.parser constName                    => combinatorFormatterAttribute.runDeclFor constName\n  | ParserDescr.cat catName _                       => return categoryParser.formatter catName", "start": [106, 1], "end": [120, 95], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Offset.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/LBool.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "lake-packages/lean4/src/lean/Lean/Meta/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.withInstantiatedMVars", "code": "private abbrev withInstantiatedMVars (e : Expr) (k : Expr \u2192 OptionT MetaM \u03b1) : OptionT MetaM \u03b1 := do\n  let eNew \u2190 instantiateMVars e\n  if eNew.getAppFn.isMVar then\n    failure\n  else\n    k eNew", "start": [12, 1], "end": [17, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isNatProjInst", "code": "def isNatProjInst (declName : Name) (numArgs : Nat) : Bool :=\n      (numArgs == 4 && (declName == ``Add.add || declName == ``Sub.sub || declName == ``Mul.mul))\n   || (numArgs == 6 && (declName == ``HAdd.hAdd || declName == ``HSub.hSub || declName == ``HMul.hMul))\n   || (numArgs == 3 && declName == ``OfNat.ofNat)", "start": [19, 1], "end": [22, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.evalNat", "code": "partial def evalNat (e : Expr) : OptionT MetaM Nat := do\n  match e with\n  | .lit (.natVal n)     => return n\n  | .mdata _ e           => evalNat e\n  | .const ``Nat.zero .. => return 0\n  | .app ..              => visit e\n  | .mvar ..             => visit e\n  | _                    => failure\nwhere\n  visit e := do\n    let f := e.getAppFn\n    match f with\n    | .mvar .. => withInstantiatedMVars e evalNat\n    | .const c _ =>\n      let nargs := e.getAppNumArgs\n      if c == ``Nat.succ && nargs == 1 then\n        let v \u2190 evalNat (e.getArg! 0)\n        return v+1\n      else if c == ``Nat.add && nargs == 2 then\n        let v\u2081 \u2190 evalNat (e.getArg! 0)\n        let v\u2082 \u2190 evalNat (e.getArg! 1)\n        return v\u2081 + v\u2082\n      else if c == ``Nat.sub && nargs == 2 then\n        let v\u2081 \u2190 evalNat (e.getArg! 0)\n        let v\u2082 \u2190 evalNat (e.getArg! 1)\n        return v\u2081 - v\u2082\n      else if c == ``Nat.mul && nargs == 2 then\n        let v\u2081 \u2190 evalNat (e.getArg! 0)\n        let v\u2082 \u2190 evalNat (e.getArg! 1)\n        return v\u2081 * v\u2082\n      else if isNatProjInst c nargs then\n        evalNat (\u2190 unfoldProjInst? e)\n      else\n        failure\n    | _ => failure", "start": [24, 1], "end": [61, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getOffset", "code": "private partial def getOffset (e : Expr) : MetaM (Expr \u00d7 Nat) :=\n  return (\u2190 isOffset? e).getD (e, 0)", "start": [65, 1], "end": [71, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isOffset?", "code": "private partial def isOffset? (e : Expr) : OptionT MetaM (Expr \u00d7 Nat) := do\n  match e with\n  | .app _ a => do\n    let f := e.getAppFn\n    match f with\n    | .mvar .. => withInstantiatedMVars e isOffset?\n    | .const c _ =>\n      let nargs := e.getAppNumArgs\n      if c == ``Nat.succ && nargs == 1 then\n        let (s, k) \u2190 getOffset a\n        pure (s, k+1)\n      else if c == ``Nat.add && nargs == 2 then\n        let v \u2190 evalNat (e.getArg! 1)\n        let (s, k) \u2190 getOffset (e.getArg! 0)\n        pure (s, k+v)\n      else if (c == ``Add.add && nargs == 4) || (c == ``HAdd.hAdd && nargs == 6) then\n        isOffset? (\u2190 unfoldProjInst? e)\n      else\n        failure\n    | _ => failure\n  | _ => failure", "start": [73, 1], "end": [96, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isNatZero", "code": "private def isNatZero (e : Expr) : MetaM Bool := do\n  match (\u2190 evalNat e) with\n  | some v => return v == 0\n  | _      => return false", "start": [100, 1], "end": [103, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkOffset", "code": "private def mkOffset (e : Expr) (offset : Nat) : MetaM Expr := do\n  if offset == 0 then\n    return e\n  else if (\u2190 isNatZero e) then\n    return mkNatLit offset\n  else\n    mkAdd e (mkNatLit offset)", "start": [105, 1], "end": [111, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqOffset", "code": "def isDefEqOffset (s t : Expr) : MetaM LBool := do\n  let ifNatExpr (x : MetaM LBool) : MetaM LBool := do\n    let type \u2190 inferType s\n    if (\u2190 withNewMCtxDepth <| Meta.isExprDefEqAux type (mkConst ``Nat)) then\n      x\n    else\n      return LBool.undef\n  let isDefEq (s t) : MetaM LBool :=\n    ifNatExpr <| toLBoolM <| Meta.isExprDefEqAux s t\n  if !(\u2190 getConfig).offsetCnstrs then\n    return LBool.undef\n  else\n    match (\u2190 isOffset? s) with\n    | some (s, k\u2081) =>\n      match (\u2190 isOffset? t) with\n      | some (t, k\u2082) => if k\u2081 == k\u2082 then\n          isDefEq s t\n        else if k\u2081 < k\u2082 then\n          isDefEq s (\u2190 mkOffset t (k\u2082 - k\u2081))\n        else\n          isDefEq (\u2190 mkOffset s (k\u2081 - k\u2082)) t\n      | none =>\n        match (\u2190 evalNat t) with\n        | some v\u2082 => if v\u2082 \u2265 k\u2081 then\n            isDefEq s (mkNatLit <| v\u2082 - k\u2081)\n          else\n            ifNatExpr <| return LBool.false\n        | none =>\n          return LBool.undef\n    | none =>\n      match (\u2190 evalNat s) with\n      | some v\u2081 =>\n        match (\u2190 isOffset? t) with\n        | some (t, k\u2082) => if v\u2081 \u2265 k\u2082 then\n            isDefEq (mkNatLit <| v\u2081 - k\u2082) t\n          else\n            ifNatExpr <| return LBool.false\n        | none =>\n          match (\u2190 evalNat t) with\n          | some v\u2082 => ifNatExpr <| return (v\u2081 == v\u2082).toLBool | none    => return LBool.undef\n      | none => return LBool.undef", "start": [113, 1], "end": [158, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.clear", "code": "def _root_.Lean.MVarId.clear (mvarId : MVarId) (fvarId : FVarId) : MetaM MVarId :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `clear\n    let lctx \u2190 getLCtx\n    unless lctx.contains fvarId do\n      throwTacticEx `clear mvarId m!\"unknown variable '{mkFVar fvarId}'\"\n    let tag \u2190 mvarId.getTag\n    lctx.forM fun localDecl => do\n      unless localDecl.fvarId == fvarId do\n        if (\u2190 localDeclDependsOn localDecl fvarId) then\n          throwTacticEx `clear mvarId m!\"variable '{localDecl.toExpr}' depends on '{mkFVar fvarId}'\"\n    let mvarDecl \u2190 mvarId.getDecl\n    if (\u2190 exprDependsOn mvarDecl.type fvarId) then\n      throwTacticEx `clear mvarId m!\"target depends on '{mkFVar fvarId}'\"\n    let lctx := lctx.erase fvarId\n    let localInsts \u2190 getLocalInstances\n    let localInsts := match localInsts.findIdx? fun localInst => localInst.fvar.fvarId! == fvarId with\n      | none => localInsts\n      | some idx => localInsts.eraseIdx idx\n    let newMVar \u2190 mkFreshExprMVarAt lctx localInsts mvarDecl.type MetavarKind.syntheticOpaque tag\n    mvarId.assign newMVar\n    pure newMVar.mvarId!", "start": [10, 1], "end": [34, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.clear", "code": "@[deprecated MVarId.clear]\ndef clear (mvarId : MVarId) (fvarId : FVarId) : MetaM MVarId :=\n  mvarId.clear fvarId", "start": [37, 1], "end": [39, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.tryClear", "code": "def _root_.Lean.MVarId.tryClear (mvarId : MVarId) (fvarId : FVarId) : MetaM MVarId :=\n  mvarId.clear fvarId <|> pure mvarId", "start": [41, 1], "end": [46, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.tryClear", "code": "@[deprecated MVarId.tryClear]\ndef tryClear (mvarId : MVarId) (fvarId : FVarId) : MetaM MVarId :=\n  mvarId.tryClear fvarId", "start": [48, 1], "end": [50, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.tryClearMany", "code": "def _root_.Lean.MVarId.tryClearMany (mvarId : MVarId) (fvarIds : Array FVarId) : MetaM MVarId := do\n  fvarIds.foldrM (init := mvarId) fun fvarId mvarId => mvarId.tryClear fvarId", "start": [52, 1], "end": [56, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.tryClearMany", "code": "@[deprecated MVarId.tryClearMany]\ndef tryClearMany (mvarId : MVarId) (fvarIds : Array FVarId) : MetaM MVarId := do\n  mvarId.tryClearMany fvarIds", "start": [58, 1], "end": [60, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/HeadIndex.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.HeadIndex", "code": "inductive HeadIndex where\n  | fvar (fvarId : FVarId)\n  | mvar (mvarId : MVarId)\n  | const (constName : Name)\n  | proj (structName : Name) (idx : Nat)\n  | lit (litVal : Literal)\n  | sort\n  | lam\n  | forallE\n  deriving Inhabited, BEq, Repr", "start": [10, 1], "end": [32, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.HeadIndex.HeadIndex.hash", "code": "protected def HeadIndex.hash : HeadIndex \u2192 UInt64\n  | fvar fvarId         => mixHash 11 <| hash fvarId\n  | mvar mvarId         => mixHash 13 <| hash mvarId\n  | const constName     => mixHash 17 <| hash constName\n  | proj structName idx => mixHash 19 <| mixHash (hash structName) (hash idx)\n  | lit litVal          => mixHash 23 <| hash litVal\n  | sort                => 29\n  | lam                 => 31\n  | forallE             => 37", "start": [36, 1], "end": [45, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.headNumArgs", "code": "def headNumArgs (e : Expr) : Nat :=\n  go e 0\nwhere\n  go : Expr \u2192 Nat \u2192 Nat\n  | app f _, n        => go f (n + 1)\n  | letE _ _ _ b _, n => go b n\n  | mdata _ e, n      => go e n\n  | _, n              => n", "start": [53, 1], "end": [61, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.toHeadIndexQuick?", "code": "private def toHeadIndexQuick? : Expr \u2192 Option HeadIndex\n  | mvar mvarId             => HeadIndex.mvar mvarId\n  | fvar fvarId             => HeadIndex.fvar fvarId\n  | const constName _       => HeadIndex.const constName\n  | proj structName idx _   => HeadIndex.proj structName idx\n  | sort _                  => HeadIndex.sort\n  | lam ..                  => HeadIndex.lam\n  | forallE ..              => HeadIndex.forallE\n  | lit v                   => HeadIndex.lit v\n  | app f _                 => toHeadIndexQuick? f\n  | letE _ _ _ b _          => toHeadIndexQuick? b\n  | mdata _ e               => toHeadIndexQuick? e\n  | _                       => none", "start": [63, 1], "end": [83, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.toHeadIndexSlow", "code": "private partial def toHeadIndexSlow : Expr \u2192 HeadIndex\n  | mvar mvarId             => HeadIndex.mvar mvarId\n  | fvar fvarId             => HeadIndex.fvar fvarId\n  | const constName _       => HeadIndex.const constName\n  | proj structName idx _   => HeadIndex.proj structName idx\n  | sort _                  => HeadIndex.sort\n  | lam ..                  => HeadIndex.lam\n  | forallE ..              => HeadIndex.forallE\n  | lit v                   => HeadIndex.lit v\n  | app f _                 => toHeadIndexSlow f\n  | letE _ _ v b _          => toHeadIndexSlow (b.instantiate1 v)\n  | mdata _ e               => toHeadIndexSlow e\n  | _                       => panic! \"unexpected expression kind\"", "start": [85, 1], "end": [103, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.toHeadIndex", "code": "def toHeadIndex (e : Expr) : HeadIndex :=\n  match toHeadIndexQuick? e with\n  | some i => i\n  | none => toHeadIndexSlow e", "start": [105, 1], "end": [111, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Builtins.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/TopDownAnalyze.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/SubExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Parser.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Basic.lean"], "premises": [{"full_name": "Lean.PrettyPrinter.Delaborator.maybeAddBlockImplicit", "code": "def maybeAddBlockImplicit (ident : Syntax) : DelabM Syntax := do\n  if \u2190 getPPOption getPPAnalysisBlockImplicit then `(@$ident:ident) else pure ident", "start": [18, 1], "end": [19, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.unfoldMDatas", "code": "def unfoldMDatas : Expr \u2192 Expr\n  | Expr.mdata _ e => unfoldMDatas e\n  | e              => e", "start": [21, 1], "end": [23, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabFVar", "code": "@[builtin_delab fvar]\ndef delabFVar : Delab := do\nlet Expr.fvar fvarId \u2190 getExpr | unreachable!\ntry\n  let l \u2190 fvarId.getDecl\n  maybeAddBlockImplicit (mkIdent l.userName)\ncatch _ =>\n  maybeAddBlockImplicit <| mkIdent fvarId.name", "start": [25, 1], "end": [33, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabBVar", "code": "@[builtin_delab bvar]\ndef delabBVar : Delab := do\n  let Expr.bvar idx \u2190 getExpr | unreachable!\n  pure $ mkIdent $ Name.mkSimple $ \"#\" ++ toString idx", "start": [36, 1], "end": [39, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabMVar", "code": "@[builtin_delab mvar]\ndef delabMVar : Delab := do\n  let Expr.mvar n \u2190 getExpr | unreachable!\n  let mvarDecl \u2190 n.getDecl\n  let n :=\n    match mvarDecl.userName with\n    | Name.anonymous => n.name.replacePrefix `_uniq `m\n    | n => n\n  `(?$(mkIdent n))", "start": [41, 1], "end": [49, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabSort", "code": "@[builtin_delab sort]\ndef delabSort : Delab := do\n  let Expr.sort l \u2190 getExpr | unreachable!\n  match l with\n  | Level.zero => `(Prop)\n  | Level.succ .zero => `(Type)\n  | _ => match l.dec with\n    | some l' => `(Type $(Level.quote l' max_prec))\n    | none    => `(Sort $(Level.quote l max_prec))", "start": [51, 1], "end": [59, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabConst", "code": "def delabConst : Delab := do\n  let Expr.const c\u2080 ls \u2190 getExpr | unreachable!\n  let c\u2080 := if (\u2190 getPPOption getPPPrivateNames) then c\u2080 else (privateToUserName? c\u2080).getD c\u2080\n\n  let mut c \u2190 unresolveNameGlobal c\u2080 (fullNames := \u2190 getPPOption getPPFullNames)\n  let stx \u2190 if ls.isEmpty || !(\u2190 getPPOption getPPUniverses) then\n    if (\u2190 getLCtx).usesUserName c then\n      if c == c\u2080 && !(\u2190 read).inPattern then\n        c := `_root_ ++ c\n      else\n        c := c\u2080\n    pure <| mkIdent c\n  else\n    `($(mkIdent c).{$[$(ls.toArray.map quote)],*})\n\n  let mut stx \u2190 maybeAddBlockImplicit stx\n  if (\u2190 getPPOption getPPTagAppFns) then\n    stx \u2190 annotateCurPos stx\n    addTermInfo (\u2190 getPos) stx (\u2190 getExpr)\n  return stx", "start": [63, 1], "end": [84, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.withMDataOptions", "code": "def withMDataOptions [Inhabited \u03b1] (x : DelabM \u03b1) : DelabM \u03b1 := do\n  match \u2190 getExpr with\n  | Expr.mdata m .. =>\n    let mut posOpts := (\u2190 read).optionsPerPos\n    let pos \u2190 getPos\n    for (k, v) in m do\n      if (`pp).isPrefixOf k then\n        let opts := posOpts.find? pos |>.getD {}\n        posOpts := posOpts.insert pos (opts.insert k v)\n    withReader ({ \u00b7 with optionsPerPos := posOpts }) $ withMDataExpr x\n  | _ => x", "start": [86, 1], "end": [96, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.withMDatasOptions", "code": "partial def withMDatasOptions [Inhabited \u03b1] (x : DelabM \u03b1) : DelabM \u03b1 := do\n  if (\u2190 getExpr).isMData then withMDataOptions (withMDatasOptions x) else x", "start": [98, 1], "end": [99, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabAppFn", "code": "def delabAppFn : Delab := do\n  if (\u2190 getExpr).consumeMData.isConst then\n    withMDatasOptions delabConst\n  else\n    delab", "start": [101, 1], "end": [105, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.ParamKind", "code": "structure ParamKind where\n  name        : Name\n  bInfo       : BinderInfo\n  defVal      : Option Expr := none\n  isAutoParam : Bool := false", "start": [107, 1], "end": [111, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.ParamKind.isRegularExplicit", "code": "def ParamKind.isRegularExplicit (param : ParamKind) : Bool :=\n  param.bInfo.isExplicit && !param.isAutoParam && param.defVal.isNone", "start": [113, 1], "end": [114, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.getParamKinds", "code": "partial def getParamKinds : DelabM (Array ParamKind) := do\n  let e \u2190 getExpr\n  try\n    withTransparency TransparencyMode.all do\n      forallTelescopeArgs e.getAppFn e.getAppArgs fun params _ => do\n        params.mapM fun param => do\n          let l \u2190 param.fvarId!.getDecl\n          pure { name := l.userName, bInfo := l.binderInfo, defVal := l.type.getOptParamDefault?, isAutoParam := l.type.isAutoParam }\n  catch _ => pure #[] where\n  forallTelescopeArgs f args k := do\n    forallBoundedTelescope (\u2190 inferType f) args.size fun xs b =>\n      if xs.isEmpty || xs.size == args.size then\n        forallTelescopeReducing b fun ys b => k (xs ++ ys) b\n      else\n        forallTelescopeArgs (mkAppN f $ args.shrink xs.size) (args.extract xs.size args.size) fun ys b =>\n          k (xs ++ ys) b", "start": [116, 1], "end": [134, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabAppExplicit", "code": "@[builtin_delab app]\ndef delabAppExplicit : Delab := do\n  let paramKinds \u2190 getParamKinds\n  let tagAppFn \u2190 getPPOption getPPTagAppFns\n  let (fnStx, _, argStxs) \u2190 withAppFnArgs\n    (do\n      let stx \u2190 withOptionAtCurrPos `pp.tagAppFns tagAppFn delabAppFn\n      let needsExplicit := stx.raw.getKind != ``Lean.Parser.Term.explicit\n      let stx \u2190 if needsExplicit then `(@$stx) else pure stx\n      pure (stx, paramKinds.toList, #[]))\n    (fun \u27e8fnStx, paramKinds, argStxs\u27e9 => do\n      let isInstImplicit := match paramKinds with\n                            | [] => false\n                            | param :: _ => param.bInfo == BinderInfo.instImplicit\n      let argStx \u2190 if \u2190 getPPOption getPPAnalysisHole then `(_)\n                   else if isInstImplicit == true then\n                     let stx \u2190 if \u2190 getPPOption getPPInstances then delab else `(_)\n                     if \u2190 getPPOption getPPInstanceTypes then\n                       let typeStx \u2190 withType delab\n                       `(($stx : $typeStx))\n                     else pure stx\n                   else delab\n      pure (fnStx, paramKinds.tailD [], argStxs.push argStx))\n  return Syntax.mkApp fnStx argStxs", "start": [136, 1], "end": [159, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.shouldShowMotive", "code": "def shouldShowMotive (motive : Expr) (opts : Options) : MetaM Bool := do\n  pure (getPPMotivesAll opts)\n  <||> (pure (getPPMotivesPi opts) <&&> returnsPi motive)\n  <||> (pure (getPPMotivesNonConst opts) <&&> isNonConstFun motive)", "start": [161, 1], "end": [164, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.isRegularApp", "code": "def isRegularApp : DelabM Bool := do\n  let e \u2190 getExpr\n  if not (unfoldMDatas e.getAppFn).isConst then return false\n  if \u2190 withNaryFn (withMDatasOptions (getPPOption getPPUniverses <||> getPPOption getPPAnalysisBlockImplicit)) then return false\n  for i in [:e.getAppNumArgs] do\n    if \u2190 withNaryArg i (getPPOption getPPAnalysisNamedArg) then return false\n  return true", "start": [166, 1], "end": [172, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.unexpandRegularApp", "code": "def unexpandRegularApp (stx : Syntax) : Delab := do\n  let Expr.const c .. := (unfoldMDatas (\u2190 getExpr).getAppFn) | unreachable!\n  let fs := appUnexpanderAttribute.getValues (\u2190 getEnv) c\n  let ref \u2190 getRef\n  fs.firstM fun f =>\n    match f stx |>.run ref |>.run () with\n    | EStateM.Result.ok stx _ => pure stx\n    | _ => failure", "start": [174, 1], "end": [181, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.unexpandStructureInstance", "code": "def unexpandStructureInstance (stx : Syntax) : Delab := whenPPOption getPPStructureInstances do\n  let env \u2190 getEnv\n  let e \u2190 getExpr\n  let some s \u2190 pure $ e.isConstructorApp? env | failure\n  guard $ isStructure env s.induct;\n  \n  let fieldNames := getStructureFields env s.induct\n  let mut fields := #[]\n  guard $ fieldNames.size == stx[1].getNumArgs\n  let args := e.getAppArgs\n  let fieldVals := args.extract s.numParams args.size\n  for idx in [:fieldNames.size] do\n    let fieldName := fieldNames[idx]!\n    let fieldId := mkIdent fieldName\n    let fieldPos \u2190 nextExtraPos\n    let fieldId := annotatePos fieldPos fieldId\n    addFieldInfo fieldPos (s.induct ++ fieldName) fieldName fieldId fieldVals[idx]!\n    let field \u2190 `(structInstField|$fieldId:ident := $(stx[1][idx]))\n    fields := fields.push field\n  let tyStx \u2190 withType do\n    if (\u2190 getPPOption getPPStructureInstanceType) then delab >>= pure \u2218 some else pure none\n  `({ $fields,* $[: $tyStx]? })", "start": [183, 1], "end": [205, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabAppImplicit", "code": "@[builtin_delab app]\ndef delabAppImplicit : Delab := do\n  let paramKinds \u2190 getParamKinds\n  if \u2190 getPPOption getPPExplicit then\n    if paramKinds.any (fun param => !param.isRegularExplicit) then failure\n\n  let isImplicitApp \u2190 try\n      let ty \u2190 whnf (\u2190 inferType (\u2190 getExpr))\n      pure <| ty.isForall && (ty.binderInfo == BinderInfo.implicit || ty.binderInfo == BinderInfo.instImplicit)\n    catch _ => pure false\n  if isImplicitApp then failure\n\n  let tagAppFn \u2190 getPPOption getPPTagAppFns\n  let (fnStx, _, argStxs) \u2190 withAppFnArgs\n    (withOptionAtCurrPos `pp.tagAppFns tagAppFn <|\n      return (\u2190 delabAppFn, paramKinds.toList, #[]))\n    (fun (fnStx, paramKinds, argStxs) => do\n      let arg \u2190 getExpr\n      let opts \u2190 getOptions\n      let mkNamedArg (name : Name) (argStx : Syntax) : DelabM Syntax := do\n        `(Parser.Term.namedArgument| ($(mkIdent name) := $argStx))\n      let argStx? : Option Syntax \u2190\n        if \u2190 getPPOption getPPAnalysisSkip then pure none\n        else if \u2190 getPPOption getPPAnalysisHole then `(_)\n        else\n          match paramKinds with\n          | [] => delab\n          | param :: rest =>\n            if param.defVal.isSome && rest.isEmpty then\n              let v := param.defVal.get!\n              if !v.hasLooseBVars && v == arg then pure none else delab\n            else if !param.isRegularExplicit && param.defVal.isNone then\n              if \u2190 getPPOption getPPAnalysisNamedArg <||> (pure (param.name == `motive) <&&> shouldShowMotive arg opts) then some <$> mkNamedArg param.name (\u2190 delab) else pure none\n            else delab\n      let argStxs := match argStx? with\n        | none => argStxs\n        | some stx => argStxs.push stx\n      pure (fnStx, paramKinds.tailD [], argStxs))\n  let stx := Syntax.mkApp fnStx argStxs\n\n  if \u2190 isRegularApp then\n    (guard (\u2190 getPPOption getPPNotation) *> unexpandRegularApp stx)\n    <|> (guard (\u2190 getPPOption getPPStructureInstances) *> unexpandStructureInstance stx)\n    <|> pure stx\n  else pure stx", "start": [207, 1], "end": [254, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.AppMatchState", "code": "structure AppMatchState where\n  info        : MatcherInfo\n  matcherTy   : Expr\n  params      : Array Expr := #[]\n  motive      : Option (Term \u00d7 Expr) := none\n  motiveNamed : Bool := false\n  discrs      : Array Term := #[]\n  varNames    : Array (Array Name) := #[]\n  rhss        : Array Term := #[]\n  moreArgs    : Array Term := #[]", "start": [256, 1], "end": [267, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabPatterns", "code": "private partial def delabPatterns (st : AppMatchState) : DelabM (Array (Array Term)) :=\n  withReader (fun ctx => { ctx with inPattern := true, optionsPerPos := {} }) do\n    let ty \u2190 instantiateForall st.matcherTy st.params\n    forallTelescopeReducing ty fun params _ => do\n      let alts := Array.ofSubarray params[1 + st.discrs.size:]\n      alts.mapIdxM fun idx alt => do\n        let ty \u2190 inferType alt\n        withTheReader SubExpr ({ \u00b7 with expr := ty }) $\n          usingNames st.varNames[idx]! do\n            withAppFnArgs (pure #[]) (fun pats => do pure $ pats.push (\u2190 delab))\nwhere\n  usingNames {\u03b1} (varNames : Array Name) (x : DelabM \u03b1) : DelabM \u03b1 :=\n    usingNamesAux 0 varNames x\n  usingNamesAux {\u03b1} (i : Nat) (varNames : Array Name) (x : DelabM \u03b1) : DelabM \u03b1 :=\n    if i < varNames.size then\n      withBindingBody varNames[i]! <| usingNamesAux (i+1) varNames x\n    else\n      x", "start": [268, 1], "end": [293, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.skippingBinders", "code": "private partial def skippingBinders {\u03b1} (numParams : Nat) (x : Array Name \u2192 DelabM \u03b1) : DelabM \u03b1 :=\n  loop numParams #[]\nwhere\n  loop : Nat \u2192 Array Name \u2192 DelabM \u03b1\n    | 0,   varNames => x varNames\n    | n+1, varNames => do\n      let rec visitLambda : DelabM \u03b1 := do\n        let varName := (\u2190 getExpr).bindingName!.eraseMacroScopes\n        if varNames.contains varName then\n          let varName := (\u2190 getLCtx).getUnusedName varName\n          withBindingBody varName do\n            loop n (varNames.push varName)\n        else\n          withBindingBodyUnusedName fun id => do\n            loop n (varNames.push id.getId)\n      let e \u2190 getExpr\n      if e.isLambda then\n        visitLambda\n      else\n        let e \u2190 forallTelescopeReducing (\u2190 inferType e) fun xs _ => do\n          if xs.size == 1 && (\u2190 inferType xs[0]!).isConstOf ``Unit then\n            mkLambdaFVars xs (mkApp e (mkConst ``Unit.unit))\n          else\n            mkLambdaFVars xs (mkAppN e xs)\n        withTheReader SubExpr (fun ctx => { ctx with expr := e }) visitLambda", "start": [295, 1], "end": [326, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabAppMatch", "code": "@[builtin_delab app]\ndef delabAppMatch : Delab := whenPPOption getPPNotation <| whenPPOption getPPMatch do\n  let st \u2190 withAppFnArgs\n    (do\n      let (Expr.const c us) \u2190 getExpr | failure\n      let (some info) \u2190 getMatcherInfo? c | failure\n      let matcherTy \u2190 instantiateTypeLevelParams (\u2190 getConstInfo c) us\n      return { matcherTy, info : AppMatchState })\n    (fun st => do\n      if st.params.size < st.info.numParams then\n        return { st with params := st.params.push (\u2190 getExpr) }\n      else if st.motive.isNone then\n        let lamMotive \u2190 getExpr\n        let piMotive \u2190 lambdaTelescope lamMotive fun xs body => mkForallFVars xs body\n        let piStx \u2190 withTheReader SubExpr (fun cfg => { cfg with expr := piMotive }) delab\n        let named \u2190 getPPOption getPPAnalysisNamedArg\n        return { st with motive := (piStx, lamMotive), motiveNamed := named }\n      else if st.discrs.size < st.info.numDiscrs then\n        let idx := st.discrs.size\n        let discr \u2190 delab\n        if let some hName := st.info.discrInfos[idx]!.hName? then\n          return { st with discrs := st.discrs.push (\u2190 `(matchDiscr| $(mkIdent hName) : $discr)) }\n        else\n          return { st with discrs := st.discrs.push (\u2190 `(matchDiscr| $discr:term)) }\n      else if st.rhss.size < st.info.altNumParams.size then\n        \n        let (varNames, rhs) \u2190 skippingBinders st.info.altNumParams[st.rhss.size]! fun varNames => do\n          let rhs \u2190 delab\n          return (varNames, rhs)\n        return { st with rhss := st.rhss.push rhs, varNames := st.varNames.push varNames }\n      else\n        return { st with moreArgs := st.moreArgs.push (\u2190 delab) })\n\n  if st.discrs.size < st.info.numDiscrs || st.rhss.size < st.info.altNumParams.size then\n    failure\n\n  match st.discrs, st.rhss with\n  | #[discr], #[] =>\n    let stx \u2190 `(nomatch $discr)\n    return Syntax.mkApp stx st.moreArgs\n  | _,        #[] => failure\n  | _,        _   =>\n    let pats \u2190 delabPatterns st\n    let stx \u2190 do\n      let (piStx, lamMotive) := st.motive.get!\n      let opts \u2190 getOptions\n      if \u2190 pure st.motiveNamed <||> shouldShowMotive lamMotive opts then\n        `(match (motive := $piStx) $[$st.discrs:matchDiscr],* with $[| $pats,* => $st.rhss]*)\n      else\n        `(match $[$st.discrs:matchDiscr],* with $[| $pats,* => $st.rhss]*)\n    return Syntax.mkApp stx st.moreArgs", "start": [328, 1], "end": [395, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabLetFun", "code": "def delabLetFun : Delab := do\n  let stxV \u2190 withAppArg delab\n  withAppFn do\n    let Expr.lam n _ b _ \u2190 getExpr | unreachable!\n    let n \u2190 getUnusedName n b\n    let stxB \u2190 withBindingBody n delab\n    if \u2190 getPPOption getPPLetVarTypes <||> getPPOption getPPAnalysisLetVarType then\n      let stxT \u2190 withBindingDomain delab\n      `(let_fun $(mkIdent n) : $stxT := $stxV; $stxB)\n    else\n      `(let_fun $(mkIdent n) := $stxV; $stxB)", "start": [397, 1], "end": [410, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabMData", "code": "@[builtin_delab mdata]\ndef delabMData : Delab := do\n  if let some _ := inaccessible? (\u2190 getExpr) then\n    let s \u2190 withMDataExpr delab\n    if (\u2190 read).inPattern then\n      `(.($s)) else\n      return s\n  else if isLetFun (\u2190 getExpr) && getPPNotation (\u2190 getOptions) then\n    withMDataExpr <| delabLetFun\n  else if let some _ := isLHSGoal? (\u2190 getExpr) then\n    withMDataExpr <| withAppFn <| withAppArg <| delab\n  else\n    withMDataOptions delab", "start": [412, 1], "end": [425, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.hasIdent", "code": "partial def hasIdent (id : Name) : Syntax \u2192 Bool\n  | Syntax.ident _ _ id' _ => id == id'\n  | Syntax.node _ _ args   => args.any (hasIdent id)\n  | _                      => false", "start": [427, 1], "end": [435, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.shouldGroupWithNext", "code": "private def shouldGroupWithNext : DelabM Bool := do\n  let e \u2190 getExpr\n  let ppEType \u2190 getPPOption (getPPBinderTypes e)\n  let go (e' : Expr) := do\n    let ppE'Type \u2190 withBindingBody `_ $ getPPOption (getPPBinderTypes e)\n    pure $ e.binderInfo == e'.binderInfo &&\n      e.bindingDomain! == e'.bindingDomain! &&\n      e'.binderInfo != BinderInfo.instImplicit &&\n      ppEType == ppE'Type &&\n      (e'.binderInfo != BinderInfo.default || ppE'Type)\n  match e with\n  | Expr.lam _ _     e'@(Expr.lam _ _ _ _) _     => go e'\n  | Expr.forallE _ _ e'@(Expr.forallE _ _ _ _) _ => go e'\n  | _ => pure false\nwhere\n  getPPBinderTypes (e : Expr) :=\n    if e.isForall then getPPPiBinderTypes else getPPFunBinderTypes", "start": [437, 1], "end": [461, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabBinders", "code": "private partial def delabBinders (delabGroup : Array Syntax \u2192 Syntax \u2192 Delab) : optParam (Array Syntax) #[] \u2192 Delab\n  | curNames => do\n    if \u2190 shouldGroupWithNext then\n      withBindingBodyUnusedName fun stxN => delabBinders delabGroup (curNames.push stxN)\n    else\n      let (stx, stxN) \u2190 withBindingBodyUnusedName fun stxN => return (\u2190 delab, stxN)\n      delabGroup (curNames.push stxN) stx", "start": [463, 1], "end": [474, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabLam", "code": "@[builtin_delab lam]\ndef delabLam : Delab :=\n  delabBinders fun curNames stxBody => do\n    let e \u2190 getExpr\n    let stxT \u2190 withBindingDomain delab\n    let ppTypes \u2190 getPPOption getPPFunBinderTypes\n    let usedDownstream := curNames.any (fun n => hasIdent n.getId stxBody)\n\n    let blockImplicitLambda := true\n    \n\n    if !blockImplicitLambda then\n      pure stxBody\n    else\n      let defaultCase (_ : Unit) : Delab := do\n        if ppTypes then\n          let stxCurNames \u2190\n            if curNames.size > 1 then\n              `($(curNames.get! 0) $(curNames.eraseIdx 0)*)\n            else\n              pure $ curNames.get! 0;\n          `(funBinder| ($stxCurNames : $stxT))\n        else\n          pure curNames.back  let group \u2190 match e.binderInfo, ppTypes with\n        | BinderInfo.default,        _      => defaultCase ()\n        | BinderInfo.implicit,       true   => `(funBinder| {$curNames* : $stxT})\n        | BinderInfo.implicit,       false  => `(funBinder| {$curNames*})\n        | BinderInfo.strictImplicit, true   => `(funBinder| \u2983$curNames* : $stxT\u2984)\n        | BinderInfo.strictImplicit, false  => `(funBinder| \u2983$curNames*\u2984)\n        | BinderInfo.instImplicit,   _     =>\n          if usedDownstream then `(funBinder| [$curNames.back : $stxT])  else  `(funBinder| [$stxT])\n      let (binders, stxBody) :=\n        match stxBody with\n        | `(fun $binderGroups* => $stxBody) => (#[group] ++ binderGroups, stxBody)\n        | _                                 => (#[group], stxBody)\n      if \u2190 getPPOption getPPUnicodeFun then\n        `(fun $binders* \u21a6 $stxBody)\n      else\n        `(fun $binders* => $stxBody)", "start": [476, 1], "end": [530, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabForallBinders", "code": "private partial def delabForallBinders (delabGroup : Array Syntax \u2192 Bool \u2192 Syntax \u2192 Delab) (curNames : Array Syntax := #[]) (curDep := false) : Delab := do\n  let dep := !(\u2190 getExpr).isArrow\n  if !curNames.isEmpty && dep != curDep then\n    delabGroup curNames curDep (\u2190 delab)\n  else\n    let curDep := dep\n    if \u2190 shouldGroupWithNext then\n      withBindingBodyUnusedName fun stxN => delabForallBinders delabGroup (curNames.push stxN) curDep\n    else\n      let (stx, stxN) \u2190 withBindingBodyUnusedName fun stxN => return (\u2190 delab, stxN)\n      delabGroup (curNames.push stxN) curDep stx", "start": [532, 1], "end": [550, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabForall", "code": "@[builtin_delab forallE]\ndef delabForall : Delab := do\n  delabForallBinders fun curNames dependent stxBody => do\n    let e \u2190 getExpr\n    let prop \u2190 try isProp e catch _ => pure false\n    let stxT \u2190 withBindingDomain delab\n    let group \u2190 match e.binderInfo with\n    | BinderInfo.implicit       => `(bracketedBinderF|{$curNames* : $stxT})\n    | BinderInfo.strictImplicit => `(bracketedBinderF|\u2983$curNames* : $stxT\u2984)\n    | BinderInfo.instImplicit   => `(bracketedBinderF|[$curNames.back : $stxT])\n    | _                         =>\n      if dependent then\n        if prop && !(\u2190 getPPOption getPPPiBinderTypes) then\n          return \u2190 `(\u2200 $curNames:ident*, $stxBody)\n        else\n          `(bracketedBinderF|($curNames* : $stxT))\n      else\n        return \u2190 curNames.foldrM (fun _ stxBody => `($stxT \u2192 $stxBody)) stxBody\n    if prop then\n      match stxBody with\n      | `(\u2200 $groups*, $stxBody) => `(\u2200 $group $groups*, $stxBody)\n      | _                       => `(\u2200 $group, $stxBody)\n    else\n      `($group:bracketedBinder \u2192 $stxBody)", "start": [552, 1], "end": [577, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabLetE", "code": "@[builtin_delab letE]\ndef delabLetE : Delab := do\n  let Expr.letE n t v b _ \u2190 getExpr | unreachable!\n  let n \u2190 getUnusedName n b\n  let stxV \u2190 descend v 1 delab\n  let stxB \u2190 withLetDecl n t v fun fvar =>\n    let b := b.instantiate1 fvar\n    descend b 2 delab\n  if \u2190 getPPOption getPPLetVarTypes <||> getPPOption getPPAnalysisLetVarType then\n    let stxT \u2190 descend t 0 delab\n    `(let $(mkIdent n) : $stxT := $stxV; $stxB)\n  else `(let $(mkIdent n) := $stxV; $stxB)", "start": [579, 1], "end": [590, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabLit", "code": "@[builtin_delab lit]\ndef delabLit : Delab := do\n  let Expr.lit l \u2190 getExpr | unreachable!\n  match l with\n  | Literal.natVal n => pure $ quote n\n  | Literal.strVal s => pure $ quote s", "start": [592, 1], "end": [597, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabOfNat", "code": "@[builtin_delab app.OfNat.ofNat]\ndef delabOfNat : Delab := whenPPOption getPPCoercions do\n  let .app (.app _ (.lit (.natVal n))) _ \u2190 getExpr | failure\n  return quote n", "start": [600, 1], "end": [603, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabOfScientific", "code": "@[builtin_delab app.OfScientific.ofScientific]\ndef delabOfScientific : Delab := whenPPOption getPPCoercions do\n  let expr \u2190 getExpr\n  guard <| expr.getAppNumArgs == 5\n  let .lit (.natVal m) \u2190 pure (expr.getArg! 2) | failure\n  let .lit (.natVal e) \u2190 pure (expr.getArg! 4) | failure\n  let s \u2190 match expr.getArg! 3 with\n    | Expr.const ``Bool.true _  => pure true\n    | Expr.const ``Bool.false _ => pure false\n    | _ => failure\n  let str  := toString m\n  if s && e == str.length then\n    return Syntax.mkScientificLit (\"0.\" ++ str)\n  else if s && e < str.length then\n    let mStr := str.extract 0 \u27e8str.length - e\u27e9\n    let eStr := str.extract \u27e8str.length - e\u27e9 \u27e8str.length\u27e9\n    return Syntax.mkScientificLit (mStr ++ \".\" ++ eStr)\n  else\n    return Syntax.mkScientificLit (str ++ \"e\" ++ (if s then \"-\" else \"\") ++ toString e)", "start": [606, 1], "end": [624, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabProj", "code": "@[builtin_delab proj]\ndef delabProj : Delab := do\n  let Expr.proj _ idx _ \u2190 getExpr | unreachable!\n  let e \u2190 withProj delab\n  let idx := Syntax.mkLit fieldIdxKind (toString (idx + 1));\n  `($(e).$idx:fieldIdx)", "start": [626, 1], "end": [639, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabProjectionApp", "code": "@[builtin_delab app]\ndef delabProjectionApp : Delab := whenPPOption getPPStructureProjections $ do\n  let e@(Expr.app fn _) \u2190 getExpr | failure\n  let .const c@(.str _ f) _ \u2190 pure fn.getAppFn | failure\n  let env \u2190 getEnv\n  let some info \u2190 pure $ env.getProjectionFnInfo? c | failure\n  guard $ !info.fromClass\n  guard $ e.getAppNumArgs == info.numParams + 1\n  let expl \u2190 getPPOption getPPExplicit\n  guard $ !expl || info.numParams == 0\n  let appStx \u2190 withAppArg delab\n  `($(appStx).$(mkIdent f):ident)", "start": [641, 1], "end": [658, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabDIte", "code": "@[builtin_delab app.dite]\ndef delabDIte : Delab := whenPPOption getPPNotation do\n  guard $ (\u2190 getExpr).getAppNumArgs == 5\n  let c \u2190 withAppFn $ withAppFn $ withAppFn $ withAppArg delab\n  let (t, h) \u2190 withAppFn $ withAppArg $ delabBranch none\n  let (e, _) \u2190 withAppArg $ delabBranch h\n  `(if $(mkIdent h):ident : $c then $t else $e)\nwhere\n  delabBranch (h? : Option Name) : DelabM (Syntax \u00d7 Name) := do\n    let e \u2190 getExpr\n    guard e.isLambda\n    let h \u2190 match h? with\n      | some h => return (\u2190 withBindingBody h delab, h)\n      | none   => withBindingBodyUnusedName fun h => do\n        return (\u2190 delab, h.getId)", "start": [660, 1], "end": [675, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabCond", "code": "@[builtin_delab app.cond]\ndef delabCond : Delab := whenPPOption getPPNotation do\n  guard $ (\u2190 getExpr).getAppNumArgs == 4\n  let c \u2190 withAppFn $ withAppFn $ withAppArg delab\n  let t \u2190 withAppFn $ withAppArg delab\n  let e \u2190 withAppArg delab\n  `(bif $c then $t else $e)", "start": [677, 1], "end": [683, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabNamedPattern", "code": "@[builtin_delab app.namedPattern]\ndef delabNamedPattern : Delab := do\n  guard (\u2190 read).inPattern\n  guard $ (\u2190 getExpr).getAppNumArgs == 4\n  let x \u2190 withAppFn $ withAppFn $ withAppArg delab\n  let p \u2190 withAppFn $ withAppArg delab\n  let h \u2190 withAppArg delab\n  guard x.raw.isIdent\n  `($x:ident@$h:ident:$p:term)", "start": [685, 1], "end": [695, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabSigmaCore", "code": "def delabSigmaCore (sigma : Bool) : Delab := whenPPOption getPPNotation do\n  guard $ (\u2190 getExpr).getAppNumArgs == 2\n  guard $ (\u2190 getExpr).appArg!.isLambda\n  withAppArg do\n    let \u03b1 \u2190 withBindingDomain delab\n    let bodyExpr := (\u2190 getExpr).bindingBody!\n    withBindingBodyUnusedName fun n => do\n      let b \u2190 delab\n      if bodyExpr.hasLooseBVars then\n        if sigma then `(($n:ident : $\u03b1) \u00d7 $b) else `(($n:ident : $\u03b1) \u00d7' $b)\n      else\n        if sigma then `((_ : $\u03b1) \u00d7 $b) else `((_ : $\u03b1) \u00d7' $b)", "start": [698, 1], "end": [709, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabSigma", "code": "@[builtin_delab app.Sigma]\ndef delabSigma : Delab := delabSigmaCore (sigma := true)", "start": [711, 1], "end": [712, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabPSigma", "code": "@[builtin_delab app.PSigma]\ndef delabPSigma : Delab := delabSigmaCore (sigma := false)", "start": [714, 1], "end": [715, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabDoElems", "code": "partial def delabDoElems : DelabM (List Syntax) := do\n  let e \u2190 getExpr\n  if e.isAppOfArity ``Bind.bind 6 then\n    let \u03b1 := e.getAppArgs[2]!\n    let ma \u2190 withAppFn $ withAppArg delab\n    withAppArg do\n      match (\u2190 getExpr) with\n      | Expr.lam _ _ body _ =>\n        withBindingBodyUnusedName fun n => do\n          if body.hasLooseBVars then\n            prependAndRec `(doElem|let $n:term \u2190 $ma:term)\n          else if \u03b1.isConstOf ``Unit || \u03b1.isConstOf ``PUnit then\n            prependAndRec `(doElem|$ma:term)\n          else\n            prependAndRec `(doElem|let _ \u2190 $ma:term)\n      | _ => failure\n  else if e.isLet then\n    let Expr.letE n t v b _ \u2190 getExpr | unreachable!\n    let n \u2190 getUnusedName n b\n    let stxT \u2190 descend t 0 delab\n    let stxV \u2190 descend v 1 delab\n    withLetDecl n t v fun fvar =>\n      let b := b.instantiate1 fvar\n      descend b 2 $\n        prependAndRec `(doElem|let $(mkIdent n) : $stxT := $stxV)\n  else\n    let stx \u2190 delab\n    return [\u2190 `(doElem|$stx:term)]\n  where\n    prependAndRec x : DelabM _ := List.cons <$> x <*> delabDoElems", "start": [717, 1], "end": [747, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabDo", "code": "@[builtin_delab app.Bind.bind]\ndef delabDo : Delab := whenPPOption getPPNotation do\n  guard <| (\u2190 getExpr).isAppOfArity ``Bind.bind 6\n  let elems \u2190 delabDoElems\n  let items \u2190 elems.toArray.mapM (`(doSeqItem|$(\u00b7):doElem))\n  `(do $items:doSeqItem*)", "start": [749, 1], "end": [754, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.reifyName", "code": "def reifyName : Expr \u2192 DelabM Name\n  | .const ``Lean.Name.anonymous .. => return Name.anonymous\n  | .app (.app (.const ``Lean.Name.str ..) n) (.lit (.strVal s)) => return (\u2190 reifyName n).mkStr s\n  | .app (.app (.const ``Lean.Name.num ..) n) (.lit (.natVal i)) => return (\u2190 reifyName n).mkNum i\n  | _ => failure", "start": [756, 1], "end": [760, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabNameMkStr", "code": "@[builtin_delab app.Lean.Name.str]\ndef delabNameMkStr : Delab := whenPPOption getPPNotation do\n  let n \u2190 reifyName (\u2190 getExpr)\n  return mkNode ``Lean.Parser.Term.quotedName #[Syntax.mkNameLit s!\"`{n}\"]", "start": [762, 1], "end": [766, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabNameMkNum", "code": "@[builtin_delab app.Lean.Name.num]\ndef delabNameMkNum : Delab := delabNameMkStr", "start": [768, 1], "end": [769, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.declSigWithId", "code": "@[run_builtin_parser_attribute_hooks]\ndef declSigWithId := leading_parser termParser maxPrec >> declSig", "start": [772, 1], "end": [774, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.evalSyntaxConstantUnsafe", "code": "private unsafe def evalSyntaxConstantUnsafe (env : Environment) (opts : Options) (constName : Name) : ExceptT String Id Syntax :=\n  env.evalConstCheck Syntax opts ``Syntax constName", "start": [776, 1], "end": [777, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.evalSyntaxConstant", "code": "@[implemented_by evalSyntaxConstantUnsafe]\nprivate opaque evalSyntaxConstant (env : Environment) (opts : Options) (constName : Name) : ExceptT String Id Syntax := throw \"\"", "start": [779, 1], "end": [780, 129], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.Delaborator.delabConstWithSignature", "code": "partial def delabConstWithSignature : Delab := do\n  let e \u2190 getExpr\n  let idStx \u2190 descend e 0 <|\n    withOptions (pp.universes.set \u00b7 true |> (pp.fullNames.set \u00b7 true)) <|\n      delabConst\n  descend (\u2190 inferType e) 1 <|\n    delabParams idStx #[] #[]\nwhere\n  delabParams (idStx : Ident) (groups : TSyntaxArray ``bracketedBinder) (curIds : Array Ident) := do\n    if let .forallE n d _ i \u2190 getExpr then\n      let stxN \u2190 annotateCurPos (mkIdent n)\n      let curIds := curIds.push \u27e8stxN\u27e9\n      if \u2190 shouldGroupWithNext then\n        withBindingBody n <| delabParams idStx groups curIds\n      else\n        let delabTy := withOptions (pp.piBinderTypes.set \u00b7 true) delab\n        let group \u2190 withBindingDomain do\n          match i with\n          | .implicit       => `(bracketedBinderF|{$curIds* : $(\u2190 delabTy)})\n          | .strictImplicit => `(bracketedBinderF|\u2983$curIds* : $(\u2190 delabTy)\u2984)\n          | .instImplicit   => `(bracketedBinderF|[$curIds.back : $(\u2190 delabTy)])\n          | _ =>\n            if d.isOptParam then\n              `(bracketedBinderF|($curIds* : $(\u2190 withAppFn <| withAppArg delabTy) := $(\u2190 withAppArg delabTy)))\n            else if let some (.const tacticDecl _) := d.getAutoParamTactic? then\n              let tacticSyntax \u2190 ofExcept <| evalSyntaxConstant (\u2190 getEnv) (\u2190 getOptions) tacticDecl\n              `(bracketedBinderF|($curIds* : $(\u2190 withAppFn <| withAppArg delabTy) := by $tacticSyntax))\n            else\n              `(bracketedBinderF|($curIds* : $(\u2190 delabTy)))\n        withBindingBody n <| delabParams idStx (groups.push group) #[]\n    else\n      let type \u2190 delab\n      `(declSigWithId| $idStx:ident $groups* : $type)", "start": [782, 1], "end": [817, 54], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/ReduceEval.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Offset.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.ReduceEval", "code": "class ReduceEval (\u03b1 : Type) where\n  reduceEval : Expr \u2192 MetaM \u03b1", "start": [12, 1], "end": [13, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceEval", "code": "def reduceEval [ReduceEval \u03b1] (e : Expr) : MetaM \u03b1 :=\n  withAtLeastTransparency TransparencyMode.default $\n  ReduceEval.reduceEval e", "start": [15, 1], "end": [17, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwFailedToEval", "code": "private def throwFailedToEval (e : Expr) : MetaM \u03b1 :=\n  throwError \"reduceEval: failed to evaluate argument{indentExpr e}\"", "start": [19, 1], "end": [20, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.evalName", "code": "private partial def evalName (e : Expr) : MetaM Name := do\n  let e \u2190 whnf e\n  let Expr.const c _ \u2190 pure e.getAppFn | throwFailedToEval e\n  let nargs := e.getAppNumArgs\n  if      c == ``Lean.Name.anonymous && nargs == 0 then pure Name.anonymous\n  else if c == ``Lean.Name.str && nargs == 2 then do\n    let n \u2190 evalName $ e.getArg! 0\n    let s \u2190 reduceEval $ e.getArg! 1\n    pure $ Name.mkStr n s\n  else if c == ``Lean.Name.num && nargs == 2 then do\n    let n \u2190 evalName $ e.getArg! 0\n    let u \u2190 reduceEval $ e.getArg! 1\n    pure $ Name.mkNum n u\n  else\n    throwFailedToEval e", "start": [42, 1], "end": [56, 24], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/JsonRpc.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Init/Control.lean", "lake-packages/lean4/src/lean/Lean/Data/RBTree.lean"], "premises": [{"full_name": "Lean.JsonRpc.RequestID", "code": "inductive RequestID where\n  | str (s : String)\n  | num (n : JsonNumber)\n  | null\n  deriving Inhabited, BEq, Ord", "start": [19, 1], "end": [25, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonRpc.ErrorCode", "code": "inductive ErrorCode where\n  \n  | parseError\n  \n  | invalidRequest\n  \n  | methodNotFound\n  \n  | invalidParams\n  \n  | internalError\n  \n  | serverNotInitialized\n  | unknownErrorCode\n  \n  | contentModified\n  \n  | requestCancelled\n  | rpcNeedsReconnect\n  | workerExited\n  | workerCrashed\n  deriving Inhabited, BEq", "start": [35, 1], "end": [69, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonRpc.Message", "code": "inductive Message where\n  \n  | request (id : RequestID) (method : String) (params? : Option Structured)\n  \n  | notification (method : String) (params? : Option Structured)\n  \n  | response (id : RequestID) (result : Json)\n  \n  | responseError (id : RequestID) (code : ErrorCode) (message : String) (data? : Option Json)", "start": [100, 1], "end": [113, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonRpc.Batch", "code": "def Batch := Array Message", "start": [115, 1], "end": [115, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonRpc.Request", "code": "structure Request (\u03b1 : Type u) where\n  id     : RequestID\n  method : String\n  param  : \u03b1\n  deriving Inhabited, BEq", "start": [117, 1], "end": [128, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonRpc.Notification", "code": "structure Notification (\u03b1 : Type u) where\n  method : String\n  param  : \u03b1\n  deriving Inhabited, BEq", "start": [133, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonRpc.Response", "code": "structure Response (\u03b1 : Type u) where\n  id     : RequestID\n  result : \u03b1\n  deriving Inhabited, BEq", "start": [148, 1], "end": [162, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonRpc.ResponseError", "code": "structure ResponseError (\u03b1 : Type u) where\n  id      : RequestID\n  code    : ErrorCode\n  \n  message : String\n  \n  data?   : Option \u03b1 := none\n  deriving Inhabited, BEq", "start": [167, 1], "end": [181, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonRpc.RequestID.lt", "code": "private def RequestID.lt : RequestID \u2192 RequestID \u2192 Bool\n  | RequestID.str a, RequestID.str b            => a < b\n  | RequestID.num a, RequestID.num b            => a < b\n  | RequestID.null,  RequestID.num _            => true\n  | RequestID.null,  RequestID.str _            => true\n  | RequestID.num _, RequestID.str _            => true\n  | _, _  => false", "start": [189, 1], "end": [195, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.JsonRpc.RequestID.ltProp", "code": "private def RequestID.ltProp : LT RequestID :=\n  \u27e8fun a b => RequestID.lt a b = true\u27e9", "start": [197, 1], "end": [198, 39], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readMessage", "code": "def readMessage (h : FS.Stream) (nBytes : Nat) : IO Message := do\n    let j \u2190 h.readJson nBytes\n    match fromJson? j with\n    | Except.ok m => pure m\n    | Except.error inner => throw $ userError s!\"JSON '{j.compress}' did not have the format of a JSON-RPC message.\\n{inner}\"", "start": [276, 3], "end": [280, 126], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readRequestAs", "code": "def readRequestAs (h : FS.Stream) (nBytes : Nat) (expectedMethod : String) (\u03b1) [FromJson \u03b1] : IO (Request \u03b1) := do\n    let m \u2190 h.readMessage nBytes\n    match m with\n    | Message.request id method params? =>\n      if method = expectedMethod then\n        let j := toJson params?\n        match fromJson? j with\n        | Except.ok v => pure \u27e8id, expectedMethod, v\u27e9\n        | Except.error inner => throw $ userError s!\"Unexpected param '{j.compress}' for method '{expectedMethod}'\\n{inner}\"\n      else\n        throw $ userError s!\"Expected method '{expectedMethod}', got method '{method}'\"\n    | _ => throw $ userError s!\"Expected JSON-RPC request, got: '{(toJson m).compress}'\"", "start": [282, 3], "end": [293, 89], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readNotificationAs", "code": "def readNotificationAs (h : FS.Stream) (nBytes : Nat) (expectedMethod : String) (\u03b1) [FromJson \u03b1] : IO (Notification \u03b1) := do\n    let m \u2190 h.readMessage nBytes\n    match m with\n    | Message.notification method params? =>\n      if method = expectedMethod then\n        let j := toJson params?\n        match fromJson? j with\n        | Except.ok v => pure \u27e8expectedMethod, v\u27e9\n        | Except.error inner => throw $ userError s!\"Unexpected param '{j.compress}' for method '{expectedMethod}'\\n{inner}\"\n      else\n        throw $ userError s!\"Expected method '{expectedMethod}', got method '{method}'\"\n    | _ => throw $ userError s!\"Expected JSON-RPC notification, got: '{(toJson m).compress}'\"", "start": [295, 3], "end": [306, 94], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readResponseAs", "code": "partial def readResponseAs (h : FS.Stream) (nBytes : Nat) (expectedID : RequestID) (\u03b1) [FromJson \u03b1] : IO (Response \u03b1) := do\n    let m \u2190 h.readMessage nBytes\n    match m with\n    | Message.response id result =>\n      if id == expectedID then\n        match fromJson? result with\n        | Except.ok v => pure \u27e8expectedID, v\u27e9\n        | Except.error inner => throw $ userError s!\"Unexpected result '{result.compress}'\\n{inner}\"\n      else\n        throw $ userError s!\"Expected id {expectedID}, got id {id}\"\n    | Message.notification .. => readResponseAs h nBytes expectedID \u03b1\n    | _ => throw $ userError s!\"Expected JSON-RPC response, got: '{(toJson m).compress}'\"", "start": [308, 3], "end": [319, 90], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeMessage", "code": "def writeMessage (h : FS.Stream) (m : Message) : IO Unit :=\n    h.writeJson (toJson m)", "start": [325, 3], "end": [326, 27], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeRequest", "code": "def writeRequest (h : FS.Stream) (r : Request \u03b1) : IO Unit :=\n    h.writeMessage r", "start": [328, 3], "end": [329, 21], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeNotification", "code": "def writeNotification (h : FS.Stream) (n : Notification \u03b1) : IO Unit :=\n    h.writeMessage n", "start": [331, 3], "end": [332, 21], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeResponse", "code": "def writeResponse (h : FS.Stream) (r : Response \u03b1) : IO Unit :=\n    h.writeMessage r", "start": [334, 3], "end": [335, 21], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeResponseError", "code": "def writeResponseError (h : FS.Stream) (e : ResponseError Unit) : IO Unit :=\n    h.writeMessage (Message.responseError e.id e.code e.message none)", "start": [337, 3], "end": [338, 70], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeResponseErrorWithData", "code": "def writeResponseErrorWithData (h : FS.Stream) (e : ResponseError \u03b1) : IO Unit :=\n    h.writeMessage e", "start": [340, 3], "end": [341, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.introNImp", "code": "@[inline] private partial def introNImp {\u03c3} (mvarId : MVarId) (n : Nat) (mkName : LocalContext \u2192 Name \u2192 Bool \u2192 \u03c3 \u2192 MetaM (Name \u00d7 \u03c3)) (s : \u03c3)\n    : MetaM (Array FVarId \u00d7 MVarId) := mvarId.withContext do\n  mvarId.checkNotAssigned `introN\n  let mvarType \u2190 mvarId.getType\n  let lctx \u2190 getLCtx\n  let rec @[specialize] loop (i : Nat) (lctx : LocalContext) (fvars : Array Expr) (j : Nat) (s : \u03c3) (type : Expr) : MetaM (Array Expr \u00d7 MVarId) := do\n    match i, type with\n    | 0, type =>\n      let type := type.instantiateRevRange j fvars.size fvars\n      withReader (fun ctx => { ctx with lctx := lctx }) do\n        withNewLocalInstances fvars j do\n          let tag     \u2190 mvarId.getTag\n          let type := type.headBeta\n          let newMVar \u2190 mkFreshExprSyntheticOpaqueMVar type tag\n          let newVal  \u2190 mkLambdaFVars fvars newMVar\n          mvarId.assign newVal\n          return (fvars, newMVar.mvarId!)\n    | i+1, .letE n type val body _ =>\n      let type   := type.instantiateRevRange j fvars.size fvars\n      let type   := type.headBeta\n      let val    := val.instantiateRevRange j fvars.size fvars\n      let fvarId \u2190 mkFreshFVarId\n      let (n, s) \u2190 mkName lctx n true s\n      let lctx   := lctx.mkLetDecl fvarId n type val\n      let fvar   := mkFVar fvarId\n      let fvars  := fvars.push fvar\n      loop i lctx fvars j s body\n    | i+1, .forallE n type body c =>\n      let type   := type.instantiateRevRange j fvars.size fvars\n      let type   := type.headBeta\n      let fvarId \u2190 mkFreshFVarId\n      let (n, s) \u2190 mkName lctx n c.isExplicit s\n      let lctx   := lctx.mkLocalDecl fvarId n type c\n      let fvar   := mkFVar fvarId\n      let fvars  := fvars.push fvar\n      loop i lctx fvars j s body\n    | i+1, type =>\n      let type := type.instantiateRevRange j fvars.size fvars\n      withReader (fun ctx => { ctx with lctx := lctx }) do\n        withNewLocalInstances fvars j do\n          \n          let newType := (\u2190 instantiateMVars type).cleanupAnnotations\n          if newType.isForall || newType.isLet then\n            loop (i+1) lctx fvars fvars.size s newType\n          else\n            let newType \u2190 whnf newType\n            if newType.isForall then\n              loop (i+1) lctx fvars fvars.size s newType\n            else\n              throwTacticEx `introN mvarId \"insufficient number of binders\"\n  let (fvars, mvarId) \u2190 loop n lctx #[] 0 s mvarType\n  return (fvars.map Expr.fvarId!, mvarId)", "start": [10, 1], "end": [66, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshBinderNameForTacticCore", "code": "private def mkFreshBinderNameForTacticCore (lctx : LocalContext) (binderName : Name) (hygienic := true) : MetaM Name := do\n  if hygienic then\n    mkFreshUserName binderName\n  else\n    return lctx.getUnusedName binderName", "start": [74, 1], "end": [78, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshBinderNameForTactic", "code": "def mkFreshBinderNameForTactic (binderName : Name) : MetaM Name := do\n  mkFreshBinderNameForTacticCore (\u2190 getLCtx) binderName (tactic.hygienic.get (\u2190 getOptions))", "start": [80, 1], "end": [86, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAuxNameImp", "code": "private def mkAuxNameImp (preserveBinderNames : Bool) (hygienic : Bool) (useNamesForExplicitOnly : Bool)\n    (lctx : LocalContext) (binderName : Name) (isExplicit : Bool) : List Name \u2192 MetaM (Name \u00d7 List Name)\n  | []         => mkAuxNameWithoutGivenName []\n  | n :: rest  => do\n    if useNamesForExplicitOnly && !isExplicit then\n      mkAuxNameWithoutGivenName (n :: rest)\n    else if n != Name.mkSimple \"_\" then\n      return (n, rest)\n    else\n      mkAuxNameWithoutGivenName rest\nwhere\n  mkAuxNameWithoutGivenName (rest : List Name) : MetaM (Name \u00d7 List Name) := do\n    if preserveBinderNames then\n      return (binderName, rest)\n    else\n      let binderName \u2190 mkFreshBinderNameForTacticCore lctx binderName hygienic\n      return (binderName, rest)", "start": [88, 1], "end": [104, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.introNCore", "code": "def introNCore (mvarId : MVarId) (n : Nat) (givenNames : List Name) (useNamesForExplicitOnly : Bool) (preserveBinderNames : Bool)\n    : MetaM (Array FVarId \u00d7 MVarId) := do\n  let hygienic := tactic.hygienic.get (\u2190 getOptions)\n  if n == 0 then\n    return (#[], mvarId)\n  else\n    introNImp mvarId n (mkAuxNameImp preserveBinderNames hygienic useNamesForExplicitOnly) givenNames", "start": [106, 1], "end": [112, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.introN", "code": "abbrev _root_.Lean.MVarId.introN (mvarId : MVarId) (n : Nat) (givenNames : List Name := []) (useNamesForExplicitOnly := false) : MetaM (Array FVarId \u00d7 MVarId) :=\n  introNCore mvarId n givenNames (useNamesForExplicitOnly := useNamesForExplicitOnly) (preserveBinderNames := false)", "start": [114, 1], "end": [118, 117], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.introN", "code": "@[deprecated MVarId.introN]\nabbrev introN (mvarId : MVarId) (n : Nat) (givenNames : List Name := []) (useNamesForExplicitOnly := false) : MetaM (Array FVarId \u00d7 MVarId) :=\n  mvarId.introN n givenNames useNamesForExplicitOnly", "start": [120, 1], "end": [122, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.introNP", "code": "abbrev _root_.Lean.MVarId.introNP (mvarId : MVarId) (n : Nat) : MetaM (Array FVarId \u00d7 MVarId) :=\n  introNCore mvarId n [] (useNamesForExplicitOnly := false) (preserveBinderNames := true)", "start": [124, 1], "end": [129, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.introNP", "code": "@[deprecated MVarId.introNP]\nabbrev introNP (mvarId : MVarId) (n : Nat) : MetaM (Array FVarId \u00d7 MVarId) :=\n  mvarId.introNP n", "start": [131, 1], "end": [133, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.intro", "code": "def _root_.Lean.MVarId.intro (mvarId : MVarId) (name : Name) : MetaM (FVarId \u00d7 MVarId) := do\n  let (fvarIds, mvarId) \u2190 mvarId.introN 1 [name]\n  return (fvarIds[0]!, mvarId)", "start": [135, 1], "end": [140, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.intro", "code": "@[deprecated MVarId.intro]\ndef intro (mvarId : MVarId) (name : Name) : MetaM (FVarId \u00d7 MVarId) := do\n  mvarId.intro name", "start": [142, 1], "end": [144, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.intro1Core", "code": "def intro1Core (mvarId : MVarId) (preserveBinderNames : Bool) : MetaM (FVarId \u00d7 MVarId) := do\n  let (fvarIds, mvarId) \u2190 introNCore mvarId 1 [] (useNamesForExplicitOnly := false) preserveBinderNames\n  return (fvarIds[0]!, mvarId)", "start": [146, 1], "end": [148, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.intro1", "code": "abbrev _root_.Lean.MVarId.intro1 (mvarId : MVarId) : MetaM (FVarId \u00d7 MVarId) :=\n  intro1Core mvarId false", "start": [150, 1], "end": [155, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.intro1", "code": "@[deprecated MVarId.intro1]\nabbrev intro1 (mvarId : MVarId) : MetaM (FVarId \u00d7 MVarId) :=\n  mvarId.intro1", "start": [157, 1], "end": [159, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.intro1P", "code": "abbrev _root_.Lean.MVarId.intro1P (mvarId : MVarId) : MetaM (FVarId \u00d7 MVarId) :=\n  intro1Core mvarId true", "start": [161, 1], "end": [166, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.intro1P", "code": "@[deprecated MVarId.intro1P]\nabbrev intro1P (mvarId : MVarId) : MetaM (FVarId \u00d7 MVarId) :=\n  mvarId.intro1P", "start": [168, 1], "end": [170, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getIntrosSize", "code": "private def getIntrosSize : Expr \u2192 Nat\n  | .forallE _ _ b _ => getIntrosSize b + 1\n  | .letE _ _ _ b _  => getIntrosSize b + 1\n  | .mdata _ b       => getIntrosSize b\n  | _                => 0", "start": [172, 1], "end": [176, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.intros", "code": "def _root_.Lean.MVarId.intros (mvarId : MVarId) : MetaM (Array FVarId \u00d7 MVarId) := do\n  let type \u2190 mvarId.getType\n  let type \u2190 instantiateMVars type\n  let n := getIntrosSize type\n  if n == 0 then\n    return (#[], mvarId)\n  else\n    mvarId.introN n", "start": [178, 1], "end": [188, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.intros", "code": "@[deprecated MVarId.intros]\ndef intros (mvarId : MVarId) : MetaM (Array FVarId \u00d7 MVarId) := do\n  mvarId.intros", "start": [190, 1], "end": [192, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/FVarSubst.lean", "imports": ["lake-packages/lean4/src/lean/Lean/LocalContext.lean", "lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Util/ReplaceExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/AssocList.lean"], "premises": [{"full_name": "Lean.Meta.FVarSubst", "code": "structure FVarSubst where\n  map : AssocList FVarId Expr := {}\n  deriving Inhabited", "start": [12, 1], "end": [20, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.empty", "code": "def empty : FVarSubst := {}", "start": [24, 1], "end": [24, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.isEmpty", "code": "def isEmpty (s : FVarSubst) : Bool :=\n  s.map.isEmpty", "start": [26, 1], "end": [27, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.contains", "code": "def contains (s : FVarSubst) (fvarId : FVarId) : Bool :=\n  s.map.contains fvarId", "start": [29, 1], "end": [30, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.insert", "code": "def insert (s : FVarSubst) (fvarId : FVarId) (v : Expr) : FVarSubst :=\n  if s.contains fvarId then s\n  else\n    let map := s.map.mapVal fun e => e.replaceFVarId fvarId v;\n    { map := map.insert fvarId v }", "start": [32, 1], "end": [37, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.erase", "code": "def erase (s : FVarSubst) (fvarId : FVarId) : FVarSubst :=\n  { map := s.map.erase fvarId }", "start": [39, 1], "end": [40, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.find?", "code": "def find? (s : FVarSubst) (fvarId : FVarId) : Option Expr :=\n  s.map.find? fvarId", "start": [42, 1], "end": [43, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.get", "code": "def get (s : FVarSubst) (fvarId : FVarId) : Expr :=\n  match s.map.find? fvarId with\n  | none   => mkFVar fvarId | some v => v", "start": [45, 1], "end": [48, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.apply", "code": "def apply (s : FVarSubst) (e : Expr) : Expr :=\n  if s.map.isEmpty then e\n  else if !e.hasFVar then e\n  else e.replace fun e => match e with\n    | Expr.fvar fvarId => match s.map.find? fvarId with\n      | none   => e\n      | some v => v\n    | _ => none", "start": [50, 1], "end": [58, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.domain", "code": "def domain (s : FVarSubst) : List FVarId :=\n  s.map.foldl (init := []) fun r k _ => k :: r", "start": [60, 1], "end": [61, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.FVarSubst.any", "code": "def any (p : FVarId \u2192 Expr \u2192 Bool) (s : FVarSubst) : Bool :=\n  s.map.any p", "start": [63, 1], "end": [64, 14], "kind": "commanddeclaration"}, {"full_name": "LocalDecl.applyFVarSubst", "code": "def LocalDecl.applyFVarSubst (s : Meta.FVarSubst) : LocalDecl \u2192 LocalDecl\n  | LocalDecl.cdecl i id n t bi k   => LocalDecl.cdecl i id n (s.apply t) bi k\n  | LocalDecl.ldecl i id n t v nd k => LocalDecl.ldecl i id n (s.apply t) (s.apply v) nd k", "start": [69, 1], "end": [71, 91], "kind": "commanddeclaration"}, {"full_name": "Expr.applyFVarSubst", "code": "abbrev Expr.applyFVarSubst (s : Meta.FVarSubst) (e : Expr) : Expr :=\n  s.apply e", "start": [73, 1], "end": [74, 12], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Revert.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.revert", "code": "def _root_.Lean.MVarId.revert (mvarId : MVarId) (fvarIds : Array FVarId) (preserveOrder : Bool := false)\n    (clearAuxDeclsInsteadOfRevert := false) : MetaM (Array FVarId \u00d7 MVarId) := do\n  if fvarIds.isEmpty then\n    pure (#[], mvarId)\n  else mvarId.withContext do\n    mvarId.checkNotAssigned `revert\n    unless clearAuxDeclsInsteadOfRevert do\n      for fvarId in fvarIds do\n        if (\u2190 fvarId.getDecl) |>.isAuxDecl then\n          throwError \"failed to revert {mkFVar fvarId}, it is an auxiliary declaration created to represent recursive definitions\"\n    let fvars := fvarIds.map mkFVar\n    let toRevert \u2190 collectForwardDeps fvars preserveOrder\n    \n    let mut mvarId      := mvarId\n    let mut toRevertNew := #[]\n    for x in toRevert do\n      if (\u2190 x.fvarId!.getDecl).isAuxDecl then\n        mvarId \u2190 mvarId.clear x.fvarId!\n      else\n        toRevertNew := toRevertNew.push x\n    let tag \u2190 mvarId.getTag\n    mvarId.setKind .natural\n    let (e, toRevert) \u2190\n      try\n        liftMkBindingM <| MetavarContext.revert toRevertNew mvarId preserveOrder\n      finally\n        mvarId.setKind .syntheticOpaque\n    let mvar := e.getAppFn\n    mvar.mvarId!.setTag tag\n    return (toRevert.map Expr.fvarId!, mvar.mvarId!)", "start": [10, 1], "end": [46, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.revertAfter", "code": "def _root_.Lean.MVarId.revertAfter (mvarId : MVarId) (fvarId : FVarId) : MetaM (Array FVarId \u00d7 MVarId) :=\n  mvarId.withContext do\n    let localDecl \u2190 fvarId.getDecl\n    let fvarIds := (\u2190 getLCtx).foldl (init := #[]) (start := localDecl.index+1) fun fvarIds decl => fvarIds.push decl.fvarId\n    mvarId.revert fvarIds (preserveOrder := true) (clearAuxDeclsInsteadOfRevert := true)", "start": [48, 1], "end": [53, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.revert", "code": "@[deprecated MVarId.revert]\ndef revert (mvarId : MVarId) (fvarIds : Array FVarId) (preserveOrder : Bool := false) : MetaM (Array FVarId \u00d7 MVarId) := do\n  mvarId.revert fvarIds preserveOrder", "start": [55, 1], "end": [57, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/KExprMap.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/HeadIndex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.KExprMap", "code": "structure KExprMap (\u03b1 : Type) where\n  map : PHashMap HeadIndex (AssocList Expr \u03b1) := {}\n  deriving Inhabited", "start": [11, 1], "end": [19, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.KExprMap.find?", "code": "def KExprMap.find? (m : KExprMap \u03b1) (e : Expr) : MetaM (Option \u03b1) := do\n  match m.map.find? e.toHeadIndex with\n  | none => return none\n  | some ps =>\n    for \u27e8e', a\u27e9 in ps do\n      if (\u2190 isDefEq e e') then\n        return some a\n    return none", "start": [21, 1], "end": [29, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.updateList", "code": "private def updateList (ps : AssocList Expr \u03b1) (e : Expr) (v : \u03b1) : MetaM (AssocList Expr \u03b1) := do\n  match ps with\n  | AssocList.nil => return AssocList.cons e v ps\n  | AssocList.cons e' v' ps =>\n    if (\u2190 isDefEq e e') then\n      return AssocList.cons e v ps\n    else\n      return AssocList.cons e' v' (\u2190 updateList ps e v)", "start": [31, 1], "end": [38, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.KExprMap.insert", "code": "def KExprMap.insert (m : KExprMap \u03b1) (e : Expr) (v : \u03b1) : MetaM (KExprMap \u03b1) :=\n  let k := e.toHeadIndex\n  match m.map.find? k with\n  | none    => return { map := m.map.insert k (AssocList.cons e v AssocList.nil) }\n  | some ps => return { map := m.map.insert k (\u2190 updateList ps e v) }", "start": [40, 1], "end": [45, 70], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Options.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/TopDownAnalyze.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/SubExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Builtins.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator/Basic.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/ParserCompiler.lean", "imports": ["lake-packages/lean4/src/lean/Lean/ParserCompiler/Attribute.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/ReduceEval.lean", "lake-packages/lean4/src/lean/Lean/KeyedDeclsAttribute.lean", "lake-packages/lean4/src/lean/Lean/Parser/Extension.lean"], "premises": [{"full_name": "Lean.ParserCompiler.Context", "code": "structure Context (\u03b1 : Type) where\n  varName : Name\n  categoryAttr : KeyedDeclsAttribute \u03b1\n  combinatorAttr : CombinatorAttribute", "start": [18, 1], "end": [21, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.Context.tyName", "code": "def Context.tyName {\u03b1} (ctx : Context \u03b1) : Name := ctx.categoryAttr.defn.valueTypeName", "start": [23, 1], "end": [23, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.replaceParserTy", "code": "def replaceParserTy {\u03b1} (ctx : Context \u03b1) (e : Expr) : Expr :=\n  e.replace fun e =>\n    let e := if e.isOptParam then e.appFn!.appArg! else e\n    if e.isConstOf `Lean.Parser.Parser then mkConst ctx.tyName else none", "start": [25, 1], "end": [30, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.parserNodeKind?", "code": "partial def parserNodeKind? (e : Expr) : MetaM (Option Name) := do\n  let reduceEval? e : MetaM (Option Name) := do\n    try pure <| some (\u2190 reduceEval e) catch _ => pure none\n  let e \u2190 whnfCore e\n  if e matches Expr.lam .. then\n    lambdaLetTelescope e fun _ e => parserNodeKind? e\n  else if e.isAppOfArity ``leadingNode 3 || e.isAppOfArity ``trailingNode 4 || e.isAppOfArity ``node 2 then\n    reduceEval? (e.getArg! 0)\n  else if e.isAppOfArity ``withAntiquot 2 then\n    parserNodeKind? (e.getArg! 1)\n  else forallTelescope (\u2190 inferType e.getAppFn) fun params _ => do\n    let lctx \u2190 getLCtx\n    if let [(i, _)] := params.toList.enum.filter (lctx.getFVar! \u00b7.2 |>.type.isConstOf ``Parser) then\n      parserNodeKind? (e.getArg! i)\n    else\n      return none", "start": [33, 1], "end": [50, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.compileParserExpr", "code": "partial def compileParserExpr (e : Expr) : MetaM Expr := do\n  let e \u2190 whnfCore e\n  match e with\n  | .lam ..  => lambdaLetTelescope e fun xs b => compileParserExpr b >>= mkLambdaFVars xs\n  | .fvar .. => return e\n  | _ => do\n    let fn := e.getAppFn\n    let .const c .. := fn | throwError \"call of unknown parser at '{e}'\"\n    let mkCall (p : Name) := do\n      let ty \u2190 inferType (mkConst p)\n      forallTelescope ty fun params _ => do\n        let mut p := mkConst p\n        let args  := e.getAppArgs\n        for i in [:Nat.min params.size args.size] do\n          let param := params[i]!\n          let arg   := args[i]!\n          let paramTy \u2190 inferType param\n          let resultTy \u2190 forallTelescope paramTy fun _ b => pure b\n          let arg \u2190 if resultTy.isConstOf ctx.tyName then compileParserExpr arg else pure arg\n          p := mkApp p arg\n        return p\n    let env \u2190 getEnv\n    match ctx.combinatorAttr.getDeclFor? env c with\n    | some p => mkCall p\n    | none   =>\n      let c' := c ++ ctx.varName\n      let cinfo \u2190 getConstInfo c\n      let resultTy \u2190 forallTelescope cinfo.type fun _ b => pure b\n      if resultTy.isConstOf `Lean.Parser.TrailingParser || resultTy.isConstOf `Lean.Parser.Parser then do\n        let some value \u2190 pure cinfo.value?\n          | throwError \"don't know how to generate {ctx.varName} for non-definition '{e}'\"\n        unless (env.getModuleIdxFor? c).isNone || force do\n          throwError \"refusing to generate code for imported parser declaration '{c}'; use `@[run_parser_attribute_hooks]` on its definition instead.\"\n        let value \u2190 compileParserExpr <| replaceParserTy ctx value\n        let ty \u2190 forallTelescope cinfo.type fun params _ =>\n          params.foldrM (init := mkConst ctx.tyName) fun param ty => do\n            let paramTy \u2190 replaceParserTy ctx <$> inferType param\n            return mkForall `_ BinderInfo.default paramTy ty\n        let decl := Declaration.defnDecl {\n          name := c', levelParams := []\n          type := ty, value := value, hints := ReducibilityHints.opaque, safety := DefinitionSafety.safe\n        }\n        let env \u2190 getEnv\n        let env \u2190 match env.addAndCompile {} decl with\n          | Except.ok    env => pure env\n          | Except.error kex => do throwError (\u2190 (kex.toMessageData {}).toString)\n        setEnv <| ctx.combinatorAttr.setDeclFor env c c'\n        if cinfo.type.isConst then\n          if let some kind \u2190 parserNodeKind? cinfo.value! then\n            let attrName := if builtin then ctx.categoryAttr.defn.builtinName else ctx.categoryAttr.defn.name\n            let stx := mkNode `Lean.Parser.Attr.simple #[mkIdent attrName, mkNullNode #[mkIdent kind]]\n            Attribute.add c' attrName stx\n        mkCall c'\n      else\n        let some e' \u2190 unfoldDefinition? e\n          | throwError \"don't know how to generate {ctx.varName} for non-parser combinator '{e}'\"\n        compileParserExpr e'", "start": [56, 1], "end": [125, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.compileEmbeddedParsers", "code": "def compileEmbeddedParsers : ParserDescr \u2192 MetaM Unit\n  | ParserDescr.const _                => pure ()\n  | ParserDescr.unary _ d              => compileEmbeddedParsers d\n  | ParserDescr.binary _ d\u2081 d\u2082         => compileEmbeddedParsers d\u2081 *> compileEmbeddedParsers d\u2082\n  | ParserDescr.parser constName       => discard <| compileParserExpr ctx (mkConst constName) (builtin := builtin) (force := false)\n  | ParserDescr.node _ _ d             => compileEmbeddedParsers d\n  | ParserDescr.nodeWithAntiquot _ _ d => compileEmbeddedParsers d\n  | ParserDescr.sepBy p _ psep _       => compileEmbeddedParsers p *> compileEmbeddedParsers psep\n  | ParserDescr.sepBy1 p _ psep _      => compileEmbeddedParsers p *> compileEmbeddedParsers psep\n  | ParserDescr.trailingNode _ _ _ d   => compileEmbeddedParsers d\n  | ParserDescr.symbol _               => pure ()\n  | ParserDescr.nonReservedSymbol _ _  => pure ()\n  | ParserDescr.cat _ _                => pure ()", "start": [129, 1], "end": [141, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.ParserCompiler.registerParserCompiler", "code": "unsafe def registerParserCompiler {\u03b1} (ctx : Context \u03b1) : IO Unit := do\n  Parser.registerParserAttributeHook {\n    postAdd := fun catName constName builtin => do\n      let info \u2190 getConstInfo constName\n      if info.type.isConstOf `Lean.ParserDescr || info.type.isConstOf `Lean.TrailingParserDescr then\n        let d \u2190 evalConstCheck ParserDescr `Lean.ParserDescr constName <|>\n          evalConstCheck TrailingParserDescr `Lean.TrailingParserDescr constName\n        compileEmbeddedParsers ctx d (builtin := builtin) |>.run'\n      else\n        let force := catName.isAnonymous\n        discard (compileParserExpr ctx (mkConst constName) (builtin := builtin) (force := force)).run'\n  }", "start": [143, 1], "end": [156, 4], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/JsonRpc.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.CancelParams", "code": "structure CancelParams where\n  id : JsonRpc.RequestID\n  deriving Inhabited, BEq, ToJson, FromJson", "start": [21, 1], "end": [23, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentUri", "code": "abbrev DocumentUri := String", "start": [25, 1], "end": [25, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Position", "code": "structure Position where\n  line : Nat\n  character : Nat\n  deriving Inhabited, BEq, Ord, Hashable, ToJson, FromJson", "start": [27, 1], "end": [34, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Range", "code": "structure Range where\n  start : Position\n  \u00abend\u00bb : Position\n  deriving Inhabited, BEq, Hashable, ToJson, FromJson, Ord", "start": [42, 1], "end": [45, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Location", "code": "structure Location where\n  uri : DocumentUri\n  range : Range\n  deriving Inhabited, BEq, ToJson, FromJson", "start": [50, 1], "end": [54, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.LocationLink", "code": "structure LocationLink where\n  originSelectionRange? : Option Range\n  targetUri : DocumentUri\n  targetRange : Range\n  targetSelectionRange : Range\n  deriving ToJson, FromJson", "start": [56, 1], "end": [61, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Command", "code": "structure Command where\n  \n  title : String\n  \n  command : String\n  \n  arguments? : Option (Array Json) := none\n  deriving ToJson, FromJson", "start": [65, 1], "end": [79, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextEdit", "code": "structure TextEdit where\n  \n  range : Range\n  \n  newText : String\n  \n  annotationId? : Option String := none\n  deriving ToJson, FromJson", "start": [81, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextEditBatch", "code": "def TextEditBatch := Array TextEdit", "start": [100, 1], "end": [101, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentIdentifier", "code": "structure TextDocumentIdentifier where\n  uri : DocumentUri\n  deriving ToJson, FromJson", "start": [117, 1], "end": [119, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.VersionedTextDocumentIdentifier", "code": "structure VersionedTextDocumentIdentifier where\n  uri : DocumentUri\n  version? : Option Nat := none\n  deriving ToJson, FromJson", "start": [121, 1], "end": [124, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentEdit", "code": "structure TextDocumentEdit where\n  textDocument : VersionedTextDocumentIdentifier\n  edits : TextEditBatch\n  deriving ToJson, FromJson", "start": [126, 1], "end": [132, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ChangeAnnotation", "code": "structure ChangeAnnotation where\n  \n  label             : String\n  \n  needsConfirmation : Bool := false\n  \n  description?      : Option String := none\n  deriving ToJson, FromJson", "start": [134, 1], "end": [145, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CreateFile.Options", "code": "structure CreateFile.Options where\n  overwrite      : Bool := false\n  ignoreIfExists : Bool := false\n  deriving ToJson, FromJson", "start": [147, 1], "end": [151, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DeleteFile.Options", "code": "structure DeleteFile.Options where\n  recursive : Bool := false\n  ignoreIfNotExists := false\n  deriving ToJson, FromJson", "start": [153, 1], "end": [157, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CreateFile", "code": "structure CreateFile where\n  uri           : DocumentUri\n  options?      : Option CreateFile.Options := none\n  annotationId? : Option String := none\n  deriving ToJson, FromJson", "start": [159, 1], "end": [163, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RenameFile", "code": "structure RenameFile where\n  oldUri        : DocumentUri\n  newUri        : DocumentUri\n  options?      : Option CreateFile.Options := none\n  annotationId? : Option String := none\n  deriving ToJson, FromJson", "start": [165, 1], "end": [170, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DeleteFile", "code": "structure DeleteFile where\n  uri           : DocumentUri\n  options?      : Option DeleteFile.Options := none\n  annotationId? : Option String := none\n  deriving ToJson, FromJson", "start": [172, 1], "end": [176, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentChange", "code": "inductive DocumentChange where\n  | create : CreateFile       \u2192 DocumentChange\n  | rename : RenameFile       \u2192 DocumentChange\n  | delete : DeleteFile       \u2192 DocumentChange\n  | edit   : TextDocumentEdit \u2192 DocumentChange", "start": [178, 1], "end": [185, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkspaceEdit", "code": "structure WorkspaceEdit where\n  \n  changes : RBMap DocumentUri TextEditBatch compare := \u2205\n  \n  documentChanges : Array DocumentChange := \u2205\n  \n  changeAnnotations : RBMap String ChangeAnnotation compare := \u2205\n  deriving ToJson, FromJson", "start": [204, 1], "end": [231, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkspaceEdit.ofTextDocumentEdit", "code": "def ofTextDocumentEdit (e : TextDocumentEdit) : WorkspaceEdit :=\n  { documentChanges := #[DocumentChange.edit e]}", "start": [244, 1], "end": [245, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkspaceEdit.ofTextEdit", "code": "def ofTextEdit (uri : DocumentUri) (te : TextEdit) : WorkspaceEdit :=\n  \n  let doc := {uri, version? := some 0}\n  ofTextDocumentEdit { textDocument := doc, edits := #[te]}", "start": [247, 1], "end": [257, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ApplyWorkspaceEditParams", "code": "structure ApplyWorkspaceEditParams where\n  \n  label? : Option String := none\n  \n  edit : WorkspaceEdit\n  deriving ToJson, FromJson", "start": [261, 1], "end": [271, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentItem", "code": "structure TextDocumentItem where\n  \n  uri : DocumentUri\n  \n  languageId : String\n  \n  version : Nat\n  \n  text : String\n  deriving ToJson, FromJson", "start": [273, 1], "end": [286, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentPositionParams", "code": "structure TextDocumentPositionParams where\n  textDocument : TextDocumentIdentifier\n  position : Position\n  deriving ToJson, FromJson", "start": [288, 1], "end": [291, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentFilter", "code": "structure DocumentFilter where\n  language? : Option String := none\n  scheme?   : Option String := none\n  pattern?  : Option String := none\n  deriving ToJson, FromJson", "start": [296, 1], "end": [300, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentSelector", "code": "def DocumentSelector := Array DocumentFilter", "start": [302, 1], "end": [302, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.StaticRegistrationOptions", "code": "structure StaticRegistrationOptions where\n  id? : Option String := none\n  deriving ToJson, FromJson", "start": [310, 1], "end": [312, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentRegistrationOptions", "code": "structure TextDocumentRegistrationOptions where\n  documentSelector? : Option DocumentSelector := none\n  deriving ToJson, FromJson", "start": [314, 1], "end": [316, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.MarkupKind", "code": "inductive MarkupKind where\n  | plaintext | markdown", "start": [318, 1], "end": [319, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.MarkupContent", "code": "structure MarkupContent where\n  kind  : MarkupKind\n  value : String\n  deriving ToJson, FromJson", "start": [330, 1], "end": [333, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ProgressToken", "code": "abbrev ProgressToken := String", "start": [335, 1], "end": [339, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ProgressParams", "code": "structure ProgressParams (\u03b1 : Type) where\n  token : ProgressToken\n  value : \u03b1\n  deriving ToJson", "start": [341, 1], "end": [347, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkDoneProgressReport", "code": "structure WorkDoneProgressReport where\n  kind := \"report\"\n  \n  message? : Option String := none\n  \n  cancellable := false\n  \n  percentage? : Option Nat := none\n  deriving ToJson", "start": [349, 1], "end": [358, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkDoneProgressBegin", "code": "structure WorkDoneProgressBegin extends WorkDoneProgressReport where\n  kind := \"begin\"\n  title : String\n  deriving ToJson", "start": [360, 1], "end": [364, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkDoneProgressEnd", "code": "structure WorkDoneProgressEnd where\n  kind := \"end\"\n  message? : Option String := none\n  deriving ToJson", "start": [366, 1], "end": [370, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkDoneProgressParams", "code": "structure WorkDoneProgressParams where\n  workDoneToken? : Option ProgressToken := none\n  deriving ToJson, FromJson", "start": [372, 1], "end": [374, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.PartialResultParams", "code": "structure PartialResultParams where\n  partialResultToken? : Option ProgressToken := none\n  deriving ToJson, FromJson", "start": [376, 1], "end": [378, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkDoneProgressOptions", "code": "structure WorkDoneProgressOptions where\n  workDoneProgress := false\n  deriving ToJson, FromJson", "start": [380, 1], "end": [383, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/MatchUtil.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Util/Recognizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.testHelper", "code": "@[inline] def testHelper (e : Expr) (p : Expr \u2192 MetaM Bool) : MetaM Bool := do\n  if (\u2190 p e) then\n    return true\n  else\n    p (\u2190 whnf e)", "start": [11, 1], "end": [15, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchHelper?", "code": "@[inline] def matchHelper? (e : Expr) (p? : Expr \u2192 MetaM (Option \u03b1)) : MetaM (Option \u03b1) := do\n  match (\u2190 p? e) with\n  | none => p? (\u2190 whnf e)\n  | s    => return s", "start": [17, 1], "end": [20, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchEq?", "code": "def matchEq? (e : Expr) : MetaM (Option (Expr \u00d7 Expr \u00d7 Expr)) :=\n  matchHelper? e fun e => return Expr.eq? e", "start": [22, 1], "end": [24, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchHEq?", "code": "def matchHEq? (e : Expr) : MetaM (Option (Expr \u00d7 Expr \u00d7 Expr \u00d7 Expr)) :=\n  matchHelper? e fun e => return Expr.heq? e", "start": [26, 1], "end": [27, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchEqHEq?", "code": "def matchEqHEq? (e : Expr) : MetaM (Option (Expr \u00d7 Expr \u00d7 Expr)) := do\n  if let some r \u2190 matchEq? e then\n    return some r\n  else if let some (\u03b1, lhs, \u03b2, rhs) \u2190 matchHEq? e then\n    if (\u2190 isDefEq \u03b1 \u03b2) then\n      return some (\u03b1, lhs, rhs)\n    return none\n  else\n    return none", "start": [29, 1], "end": [40, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchFalse", "code": "def matchFalse (e : Expr) : MetaM Bool := do\n  testHelper e fun e => return e.isConstOf ``False", "start": [42, 1], "end": [43, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchNot?", "code": "def matchNot? (e : Expr) : MetaM (Option Expr) :=\n  matchHelper? e fun e => do\n    if let some e := e.not? then\n      return e\n    else if let some (a, b) := e.arrow? then\n      if (\u2190 matchFalse b) then return some a else return none\n    else\n      return none", "start": [45, 1], "end": [52, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchNe?", "code": "def matchNe? (e : Expr) : MetaM (Option (Expr \u00d7 Expr \u00d7 Expr)) :=\n  matchHelper? e fun e => do\n    if let some r := e.ne? then\n      return r\n    else if let some e \u2190 matchNot? e then\n      matchEq? e\n    else\n      return none", "start": [54, 1], "end": [61, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.matchConstructorApp?", "code": "def matchConstructorApp? (e : Expr) : MetaM (Option ConstructorVal) := do\n  let env \u2190 getEnv\n  matchHelper? e fun e =>\n    return e.isConstructorApp? env", "start": [63, 1], "end": [66, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Revert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/FVarSubst.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.assert", "code": "def _root_.Lean.MVarId.assert (mvarId : MVarId) (name : Name) (type : Expr) (val : Expr) : MetaM MVarId :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `assert\n    let tag    \u2190 mvarId.getTag\n    let target \u2190 mvarId.getType\n    let newType := Lean.mkForall name BinderInfo.default type target\n    let newMVar \u2190 mkFreshExprSyntheticOpaqueMVar newType tag\n    mvarId.assign (mkApp newMVar val)\n    return newMVar.mvarId!", "start": [12, 1], "end": [23, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.assert", "code": "@[deprecated MVarId.assert]\ndef assert (mvarId : MVarId) (name : Name) (type : Expr) (val : Expr) : MetaM MVarId :=\n  mvarId.assert name type val", "start": [25, 1], "end": [27, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.define", "code": "def _root_.Lean.MVarId.define (mvarId : MVarId) (name : Name) (type : Expr) (val : Expr) : MetaM MVarId := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `define\n    let tag    \u2190 mvarId.getTag\n    let target \u2190 mvarId.getType\n    let newType := Lean.mkLet name type val target\n    let newMVar \u2190 mkFreshExprSyntheticOpaqueMVar newType tag\n    mvarId.assign newMVar\n    return newMVar.mvarId!", "start": [29, 1], "end": [40, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.define", "code": "@[deprecated MVarId.define]\ndef define (mvarId : MVarId) (name : Name) (type : Expr) (val : Expr) : MetaM MVarId := do\n  mvarId.define name type val", "start": [42, 1], "end": [44, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.assertExt", "code": "def _root_.Lean.MVarId.assertExt (mvarId : MVarId) (name : Name) (type : Expr) (val : Expr) (hName : Name := `h) : MetaM MVarId := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `assert\n    let tag    \u2190 mvarId.getTag\n    let target \u2190 mvarId.getType\n    let u \u2190 getLevel type\n    let hType := mkApp3 (mkConst `Eq [u]) type (mkBVar 0) val\n    let newType := Lean.mkForall name BinderInfo.default type $ Lean.mkForall hName BinderInfo.default hType target\n    let newMVar \u2190 mkFreshExprSyntheticOpaqueMVar newType tag\n    let rflPrf \u2190 mkEqRefl val\n    mvarId.assign (mkApp2 newMVar val rflPrf)\n    return newMVar.mvarId!", "start": [46, 1], "end": [60, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.assertExt", "code": "@[deprecated MVarId.assertExt]\ndef assertExt (mvarId : MVarId) (name : Name) (type : Expr) (val : Expr) (hName : Name := `h) : MetaM MVarId := do\n  mvarId.assertExt name type val hName", "start": [62, 1], "end": [64, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AssertAfterResult", "code": "structure AssertAfterResult where\n  fvarId : FVarId\n  mvarId : MVarId\n  subst  : FVarSubst", "start": [66, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.assertAfter", "code": "def _root_.Lean.MVarId.assertAfter (mvarId : MVarId) (fvarId : FVarId) (userName : Name) (type : Expr) (val : Expr) : MetaM AssertAfterResult := do\n  mvarId.checkNotAssigned `assertAfter\n  let (fvarIds, mvarId) \u2190 mvarId.revertAfter fvarId\n  let mvarId \u2190 mvarId.assert userName type val\n  let (fvarIdNew, mvarId) \u2190 mvarId.intro1P\n  let (fvarIdsNew, mvarId) \u2190 mvarId.introNP fvarIds.size\n  let mut subst := {}\n  for f in fvarIds, fNew in fvarIdsNew do\n    subst := subst.insert f (mkFVar fNew)\n  return { fvarId := fvarIdNew, mvarId, subst }", "start": [71, 1], "end": [84, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.assertAfter", "code": "@[deprecated MVarId.assertAfter]\ndef assertAfter (mvarId : MVarId) (fvarId : FVarId) (userName : Name) (type : Expr) (val : Expr) : MetaM AssertAfterResult := do\n  mvarId.assertAfter fvarId userName type val", "start": [86, 1], "end": [88, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Hypothesis", "code": "structure Hypothesis where\n  userName : Name\n  type     : Expr\n  value    : Expr", "start": [90, 1], "end": [93, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.assertHypotheses", "code": "def _root_.Lean.MVarId.assertHypotheses (mvarId : MVarId) (hs : Array Hypothesis) : MetaM (Array FVarId \u00d7 MVarId) := do\n  if hs.isEmpty then\n    return (#[], mvarId)\n  else mvarId.withContext do\n    mvarId.checkNotAssigned `assertHypotheses\n    let tag    \u2190 mvarId.getTag\n    let target \u2190 mvarId.getType\n    let targetNew := hs.foldr (init := target) fun h targetNew =>\n      mkForall h.userName BinderInfo.default h.type targetNew\n    let mvarNew \u2190 mkFreshExprSyntheticOpaqueMVar targetNew tag\n    let val := hs.foldl (init := mvarNew) fun val h => mkApp val h.value\n    mvarId.assign val\n    mvarNew.mvarId!.introNP hs.size", "start": [95, 1], "end": [110, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.assertHypotheses", "code": "@[deprecated MVarId.assertHypotheses]\ndef assertHypotheses (mvarId : MVarId) (hs : Array Hypothesis) : MetaM (Array FVarId \u00d7 MVarId) := do\n  mvarId.assertHypotheses hs", "start": [112, 1], "end": [114, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Offset.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "lake-packages/lean4/src/lean/Lean/Meta/KExprMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.Linear.Nat.LinearExpr", "code": "abbrev LinearExpr  := Nat.Linear.Expr", "start": [16, 1], "end": [16, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.LinearCnstr", "code": "abbrev LinearCnstr := Nat.Linear.ExprCnstr", "start": [17, 1], "end": [17, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.PolyExpr", "code": "abbrev PolyExpr := Nat.Linear.Poly", "start": [18, 1], "end": [18, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.LinearExpr.toExpr", "code": "def LinearExpr.toExpr (e : LinearExpr) : Expr :=\n  open Nat.Linear.Expr in\n  match e with\n  | num v    => mkApp (mkConst ``num) (mkNatLit v)\n  | var i    => mkApp (mkConst ``var) (mkNatLit i)\n  | add a b  => mkApp2 (mkConst ``add) (toExpr a) (toExpr b)\n  | mulL k a => mkApp2 (mkConst ``mulL) (mkNatLit k) (toExpr a)\n  | mulR a k => mkApp2 (mkConst ``mulR) (toExpr a) (mkNatLit k)", "start": [20, 1], "end": [27, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.LinearCnstr.toExpr", "code": "protected def LinearCnstr.toExpr (c : LinearCnstr) : Expr :=\n   mkApp3 (mkConst ``Nat.Linear.ExprCnstr.mk) (toExpr c.eq) (LinearExpr.toExpr c.lhs) (LinearExpr.toExpr c.rhs)", "start": [33, 1], "end": [34, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.LinearExpr.toArith", "code": "def LinearExpr.toArith (ctx : Array Expr) (e : LinearExpr) : MetaM Expr := do\n  match e with\n  | num v    => return mkNatLit v\n  | var i    => return ctx[i]!\n  | add a b  => mkAdd (\u2190 toArith ctx a) (\u2190 toArith ctx b)\n  | mulL k a => mkMul (mkNatLit k) (\u2190 toArith ctx a)\n  | mulR a k => mkMul (\u2190 toArith ctx a) (mkNatLit k)", "start": [41, 1], "end": [47, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.LinearCnstr.toArith", "code": "def LinearCnstr.toArith (ctx : Array Expr) (c : LinearCnstr) : MetaM Expr := do\n  if c.eq then\n    mkEq (\u2190 LinearExpr.toArith ctx c.lhs) (\u2190 LinearExpr.toArith ctx c.rhs)\n  else\n    return mkApp4 (mkConst ``LE.le [levelZero]) (mkConst ``Nat) (mkConst ``instLENat) (\u2190 LinearExpr.toArith ctx c.lhs) (\u2190 LinearExpr.toArith ctx c.rhs)", "start": [49, 1], "end": [53, 152], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.ToLinear.State", "code": "structure State where\n  varMap : KExprMap Nat := {} vars   : Array Expr := #[]", "start": [57, 1], "end": [59, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.ToLinear.M", "code": "abbrev M := StateRefT State MetaM", "start": [61, 1], "end": [61, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.ToLinear.addAsVar", "code": "def addAsVar (e : Expr) : M LinearExpr := do\n  if let some x \u2190 (\u2190 get).varMap.find? e then\n    return var x\n  else\n    let x := (\u2190 get).vars.size\n    let s \u2190 get\n    set { varMap := (\u2190 s.varMap.insert e x), vars := s.vars.push e : State }\n    return var x", "start": [65, 1], "end": [72, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.ToLinear.toLinearExpr", "code": "partial def toLinearExpr (e : Expr) : M LinearExpr := do\n  match e with\n  | Expr.lit (Literal.natVal n) => return num n\n  | Expr.mdata _ e              => toLinearExpr e\n  | Expr.const ``Nat.zero ..    => return num 0\n  | Expr.app ..                 => visit e\n  | Expr.mvar ..                => visit e\n  | _                           => addAsVar e\nwhere\n  visit (e : Expr) : M LinearExpr := do\n    let f := e.getAppFn\n    match f with\n    | Expr.mvar .. =>\n      let eNew \u2190 instantiateMVars e\n      if eNew != e then\n        toLinearExpr eNew\n      else\n        addAsVar e\n    | Expr.const declName .. =>\n      let numArgs := e.getAppNumArgs\n      if declName == ``Nat.succ && numArgs == 1 then\n        return inc (\u2190 toLinearExpr e.appArg!)\n      else if declName == ``Nat.add && numArgs == 2 then\n        return add (\u2190 toLinearExpr (e.getArg! 0)) (\u2190 toLinearExpr (e.getArg! 1))\n      else if declName == ``Nat.mul && numArgs == 2 then\n        match (\u2190 evalNat (e.getArg! 0) |>.run) with\n        | some k => return mulL k (\u2190 toLinearExpr (e.getArg! 1))\n        | none => match (\u2190 evalNat (e.getArg! 1) |>.run) with\n          | some k => return mulR (\u2190 toLinearExpr (e.getArg! 0)) k\n          | none => addAsVar e\n      else if isNatProjInst declName numArgs then\n        if let some e \u2190 unfoldProjInst? e then\n          toLinearExpr e\n        else\n          addAsVar e\n      else\n        addAsVar e\n    | _ => addAsVar e", "start": [74, 1], "end": [111, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.ToLinear.toLinearCnstr?", "code": "partial def toLinearCnstr? (e : Expr) : M (Option LinearCnstr) := do\n  let f := e.getAppFn\n  match f with\n  | Expr.mvar .. =>\n    let eNew \u2190 instantiateMVars e\n    if eNew != e then\n      toLinearCnstr? eNew\n    else\n      return none\n  | Expr.const declName .. =>\n    let numArgs := e.getAppNumArgs\n    if declName == ``Eq && numArgs == 3 then\n      return some { eq := true, lhs := (\u2190 toLinearExpr (e.getArg! 1)), rhs := (\u2190 toLinearExpr (e.getArg! 2)) }\n    else if declName == ``Nat.le && numArgs == 2 then\n      return some { eq := false, lhs := (\u2190 toLinearExpr (e.getArg! 0)), rhs := (\u2190 toLinearExpr (e.getArg! 1)) }\n    else if declName == ``Nat.lt && numArgs == 2 then\n      return some { eq := false, lhs := (\u2190 toLinearExpr (e.getArg! 0)).inc, rhs := (\u2190 toLinearExpr (e.getArg! 1)) }\n    else if numArgs == 4 && (declName == ``GE.ge || declName == ``GT.gt) then\n      if let some e \u2190 unfoldDefinition? e then\n        toLinearCnstr? e\n      else\n        return none\n    else if numArgs == 4 && (declName == ``LE.le || declName == ``LT.lt) then\n      if (\u2190 isDefEq (e.getArg! 0) (mkConst ``Nat)) then\n        if let some e \u2190 unfoldProjInst? e then\n          toLinearCnstr? e\n        else\n          return none\n      else\n        return none\n    else\n      return none\n  | _ => return none", "start": [113, 1], "end": [145, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.ToLinear.run", "code": "def run (x : M \u03b1) : MetaM (\u03b1 \u00d7 Array Expr) := do\n  let (a, s) \u2190 x.run {}\n  return (a, s.vars)", "start": [147, 1], "end": [149, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.toContextExpr", "code": "def toContextExpr (ctx : Array Expr) : MetaM Expr := do\n  mkListLit (mkConst ``Nat) ctx.toList", "start": [155, 1], "end": [156, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.reflTrue", "code": "def reflTrue : Expr :=\n  mkApp2 (mkConst ``Eq.refl [levelOne]) (mkConst ``Bool) (mkConst ``Bool.true)", "start": [158, 1], "end": [159, 79], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Eqns.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.GetEqnsFn", "code": "def GetEqnsFn := Name \u2192 MetaM (Option (Array Name))", "start": [11, 1], "end": [11, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.registerGetEqnsFn", "code": "def registerGetEqnsFn (f : GetEqnsFn) : IO Unit := do\n  unless (\u2190 initializing) do\n    throw (IO.userError \"failed to register equation getter, this kind of extension can only be registered during initialization\")\n  getEqnsFnsRef.modify (f :: \u00b7)", "start": [15, 1], "end": [43, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.shouldGenerateEqnThms", "code": "private def shouldGenerateEqnThms (declName : Name) : MetaM Bool := do\n  if let some (.defnInfo info) := (\u2190 getEnv).find? declName then\n    return !(\u2190 isProp info.type)\n  else\n    return false", "start": [45, 1], "end": [50, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.EqnsExtState", "code": "structure EqnsExtState where\n  map : PHashMap Name (Array Name) := {}\n  deriving Inhabited", "start": [52, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSimpleEqThm", "code": "private def mkSimpleEqThm (declName : Name) : MetaM (Option Name) := do\n  if let some (.defnInfo info) := (\u2190 getEnv).find? declName then\n    lambdaTelescope info.value fun xs body => do\n      let lhs := mkAppN (mkConst info.name <| info.levelParams.map mkLevelParam) xs\n      let type  \u2190 mkForallFVars xs (\u2190 mkEq lhs body)\n      let value \u2190 mkLambdaFVars xs (\u2190 mkEqRefl lhs)\n      let name := mkPrivateName (\u2190 getEnv) declName ++ `_eq_1\n      addDecl <| Declaration.thmDecl {\n        name, type, value\n        levelParams := info.levelParams\n      }\n      return some name\n  else\n    return none", "start": [60, 1], "end": [76, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getEqnsFor?", "code": "def getEqnsFor? (declName : Name) (nonRec := false) : MetaM (Option (Array Name)) := withLCtx {} {} do\n  if let some eqs := eqnsExt.getState (\u2190 getEnv) |>.map.find? declName then\n    return some eqs\n  else if (\u2190 shouldGenerateEqnThms declName) then\n    for f in (\u2190 getEqnsFnsRef.get) do\n      if let some r \u2190 f declName then\n        modifyEnv fun env => eqnsExt.modifyState env fun s => { s with map := s.map.insert declName r }\n        return some r\n    if nonRec then\n      let some eqThm \u2190 mkSimpleEqThm declName | return none\n      let r := #[eqThm]\n      modifyEnv fun env => eqnsExt.modifyState env fun s => { s with map := s.map.insert declName r }\n      return some r\n  return none", "start": [78, 1], "end": [96, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.GetUnfoldEqnFn", "code": "def GetUnfoldEqnFn := Name \u2192 MetaM (Option Name)", "start": [98, 1], "end": [98, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.registerGetUnfoldEqnFn", "code": "def registerGetUnfoldEqnFn (f : GetUnfoldEqnFn) : IO Unit := do\n  unless (\u2190 initializing) do\n    throw (IO.userError \"failed to register equation getter, this kind of extension can only be registered during initialization\")\n  getUnfoldEqnFnsRef.modify (f :: \u00b7)", "start": [102, 1], "end": [130, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getUnfoldEqnFor?", "code": "def getUnfoldEqnFor? (declName : Name) (nonRec := false) : MetaM (Option Name) := withLCtx {} {} do\n  if (\u2190 shouldGenerateEqnThms declName) then\n    for f in (\u2190 getUnfoldEqnFnsRef.get) do\n      if let some r \u2190 f declName then\n        return some r\n    if nonRec then\n      let some #[eqThm] \u2190 getEqnsFor? declName (nonRec := true) | return none\n      return some eqThm\n   return none", "start": [132, 1], "end": [145, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/AuxLemma.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.AuxLemmas", "code": "structure AuxLemmas where\n  idx    : Nat := 1\n  lemmas : PHashMap Expr (Name \u00d7 List Name) := {}\n  deriving Inhabited", "start": [10, 1], "end": [13, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAuxLemma", "code": "def mkAuxLemma (levelParams : List Name) (type : Expr) (value : Expr) : MetaM Name := do\n  let env \u2190 getEnv\n  let s := auxLemmasExt.getState env\n  let mkNewAuxLemma := do\n    let auxName := Name.mkNum (env.mainModule ++ `_auxLemma) s.idx\n    addDecl <| Declaration.thmDecl {\n      name := auxName\n      levelParams, type, value\n    }\n    modifyEnv fun env => auxLemmasExt.modifyState env fun \u27e8idx, lemmas\u27e9 => \u27e8idx + 1, lemmas.insert type (auxName, levelParams)\u27e9\n    return auxName\n  match s.lemmas.find? type with\n  | some (name, levelParams') => if levelParams == levelParams' then return name else mkNewAuxLemma\n  | none => mkNewAuxLemma", "start": [17, 1], "end": [39, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/PrettyPrinter.lean", "imports": ["lake-packages/lean4/src/lean/Lean/ParserCompiler.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Formatter.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Parenthesizer.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Parser/Module.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter/Delaborator.lean"], "premises": [{"full_name": "Lean.PPContext.runCoreM", "code": "def PPContext.runCoreM {\u03b1 : Type} (ppCtx : PPContext) (x : CoreM \u03b1) : IO \u03b1 :=\n  Prod.fst <$> x.toIO { options := ppCtx.opts, currNamespace := ppCtx.currNamespace, openDecls := ppCtx.openDecls, fileName := \"<PrettyPrinter>\", fileMap := default }\n                      { env := ppCtx.env, ngen := { namePrefix := `_pp_uniq } }", "start": [14, 1], "end": [16, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.PPContext.runMetaM", "code": "def PPContext.runMetaM {\u03b1 : Type} (ppCtx : PPContext) (x : MetaM \u03b1) : IO \u03b1 :=\n  ppCtx.runCoreM <| x.run' { lctx := ppCtx.lctx } { mctx := ppCtx.mctx }", "start": [18, 1], "end": [19, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppCategory", "code": "def ppCategory (cat : Name) (stx : Syntax) : CoreM Format := do\n  let opts \u2190 getOptions\n  let stx := (sanitizeSyntax stx).run' { options := opts }\n  parenthesizeCategory cat stx >>= formatCategory cat", "start": [23, 1], "end": [26, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppTerm", "code": "def ppTerm (stx : Term) : CoreM Format := ppCategory `term stx", "start": [28, 1], "end": [28, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppUsing", "code": "def ppUsing (e : Expr) (delab : Expr \u2192 MetaM Term) : MetaM Format := do\n  let lctx := (\u2190 getLCtx).sanitizeNames.run' { options := (\u2190 getOptions) }\n  Meta.withLCtx lctx #[] do\n    ppTerm (\u2190 delab e)", "start": [30, 1], "end": [33, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppExpr", "code": "def ppExpr (e : Expr) : MetaM Format := do\n  ppUsing e delab", "start": [35, 1], "end": [36, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppExprWithInfos", "code": "def ppExprWithInfos (e : Expr) (optsPerPos : Delaborator.OptionsPerPos := {}) (delab := Delaborator.delab)\n    : MetaM FormatWithInfos := do\n  let lctx := (\u2190 getLCtx).sanitizeNames.run' { options := (\u2190 getOptions) }\n  Meta.withLCtx lctx #[] do\n    let (stx, infos) \u2190 delabCore e optsPerPos delab\n    let fmt \u2190 ppTerm stx\n    return \u27e8fmt, infos\u27e9", "start": [38, 1], "end": [46, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppConst", "code": "def ppConst (e : Expr) : MetaM Format := do\n  ppUsing e fun e => return (\u2190 delabCore e (delab := Delaborator.delabConst)).1", "start": [48, 1], "end": [49, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppExprLegacy", "code": "@[export lean_pp_expr]\ndef ppExprLegacy (env : Environment) (mctx : MetavarContext) (lctx : LocalContext) (opts : Options) (e : Expr) : IO Format :=\n  Prod.fst <$> ((ppExpr e).run' { lctx := lctx } { mctx := mctx }).toIO { options := opts, fileName := \"<PrettyPrinter>\", fileMap := default } { env := env }", "start": [51, 1], "end": [53, 158], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppTactic", "code": "def ppTactic (stx : TSyntax `tactic) : CoreM Format := ppCategory `tactic stx", "start": [55, 1], "end": [55, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppCommand", "code": "def ppCommand (stx : Syntax.Command) : CoreM Format := ppCategory `command stx", "start": [57, 1], "end": [57, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppModule", "code": "def ppModule (stx : TSyntax ``Parser.Module.module) : CoreM Format := do\n  parenthesize Lean.Parser.Module.module.parenthesizer stx >>= format Lean.Parser.Module.module.formatter", "start": [59, 1], "end": [60, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.ppSignature", "code": "def ppSignature (c : Name) : MetaM FormatWithInfos := do\n  let decl \u2190 getConstInfo c\n  let e := .const c (decl.levelParams.map mkLevelParam)\n  let (stx, infos) \u2190 delabCore e (delab := delabConstWithSignature)\n  return \u27e8\u2190 ppTerm \u27e8stx\u27e9, infos\u27e9", "start": [63, 1], "end": [68, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.noContext", "code": "private partial def noContext : MessageData \u2192 MessageData\n  | MessageData.withContext _   msg => noContext msg\n  | MessageData.withNamingContext ctx msg => MessageData.withNamingContext ctx (noContext msg)\n  | MessageData.nest n msg => MessageData.nest n (noContext msg)\n  | MessageData.group msg  => MessageData.group (noContext msg)\n  | MessageData.compose msg\u2081 msg\u2082 => MessageData.compose (noContext msg\u2081) (noContext msg\u2082)\n  | MessageData.tagged tag msg => MessageData.tagged tag (noContext msg)\n  | MessageData.trace cls header children collapsed =>\n    MessageData.trace cls (noContext header) (children.map noContext) collapsed\n  | msg => msg", "start": [70, 1], "end": [79, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.withoutContext", "code": "private def withoutContext {m} [MonadExcept Exception m] (x : m \u03b1) : m \u03b1 :=\n  tryCatch x fun\n    | Exception.error ref msg => throw <| Exception.error ref (noContext msg)\n    | ex                      => throw ex", "start": [82, 1], "end": [85, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.PrettyPrinter.registerParserCompilers", "code": "@[builtin_init]\nunsafe def registerParserCompilers : IO Unit := do\n  ParserCompiler.registerParserCompiler \u27e8`parenthesizer, parenthesizerAttribute, combinatorParenthesizerAttribute\u27e9\n  ParserCompiler.registerParserCompiler \u27e8`formatter, formatterAttribute, combinatorFormatterAttribute\u27e9", "start": [97, 1], "end": [100, 103], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Quotation/Util.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.Quotation.getAntiquotationIds", "code": "def getAntiquotationIds (stx : Syntax) : TermElabM (Array Ident) := do\n  let mut ids := #[]\n  for stx in stx.topDown (firstChoiceOnly := true) do\n    if (isAntiquot stx || isTokenAntiquot stx) && !isEscapedAntiquot stx then\n      let anti := getAntiquotTerm stx\n      if anti.isIdent then ids := ids.push \u27e8anti\u27e9\n      else if anti.isOfKind ``Parser.Term.hole then pure ()\n      else throwErrorAt stx \"complex antiquotation not allowed here\"\n  return ids", "start": [16, 1], "end": [24, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.getPatternVars", "code": "partial def getPatternVars (stx : Syntax) : TermElabM (Array Syntax) :=\n  if stx.isQuot then\n    getAntiquotationIds stx\n  else match stx with\n    | `(_)            => return #[]\n    | `($id:ident)    => return #[id]\n    | `($id:ident@$e) => return (\u2190 getPatternVars e).push id\n    | _               => throwErrorAt stx \"unsupported pattern in syntax match{indentD stx}\"", "start": [26, 1], "end": [34, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.getPatternsVars", "code": "def getPatternsVars (pats : Array Syntax) : TermElabM (Array Syntax) :=\n  pats.foldlM (fun vars pat => do return vars ++ (\u2190 getPatternVars pat)) #[]", "start": [36, 1], "end": [37, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.getAntiquotKindSpec?", "code": "def getAntiquotKindSpec? (antiquot : Syntax) : Option Syntax :=\n  let name := antiquot[3][1]\n  if name.isMissing then none else some name", "start": [39, 1], "end": [45, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Utf16.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Array.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Position.lean", "lake-packages/lean4/src/lean/Init/Data/String.lean"], "premises": [{"full_name": "Char.utf16Size", "code": "def utf16Size (c : Char) : UInt32 :=\n  if c.val \u2264 0xFFFF then 1 else 2", "start": [17, 1], "end": [18, 34], "kind": "commanddeclaration"}, {"full_name": "String.csize16", "code": "private def csize16 (c : Char) : Nat :=\n  c.utf16Size.toNat", "start": [24, 1], "end": [25, 20], "kind": "commanddeclaration"}, {"full_name": "String.utf16Length", "code": "def utf16Length (s : String) : Nat :=\n  s.foldr (fun c acc => csize16 c + acc) 0", "start": [27, 1], "end": [28, 43], "kind": "commanddeclaration"}, {"full_name": "String.codepointPosToUtf16PosFromAux", "code": "private def codepointPosToUtf16PosFromAux (s : String) : Nat \u2192 Pos \u2192 Nat \u2192 Nat\n  | 0,    _,       utf16pos => utf16pos\n  | cp+1, utf8pos, utf16pos => codepointPosToUtf16PosFromAux s cp (s.next utf8pos) (utf16pos + csize16 (s.get utf8pos))", "start": [30, 1], "end": [32, 120], "kind": "commanddeclaration"}, {"full_name": "String.codepointPosToUtf16PosFrom", "code": "def codepointPosToUtf16PosFrom (s : String) (n : Nat) (off : Pos) : Nat :=\n  codepointPosToUtf16PosFromAux s n off 0", "start": [34, 1], "end": [38, 42], "kind": "commanddeclaration"}, {"full_name": "String.codepointPosToUtf16Pos", "code": "def codepointPosToUtf16Pos (s : String) (pos : Nat) : Nat :=\n  codepointPosToUtf16PosFrom s pos 0", "start": [40, 1], "end": [41, 37], "kind": "commanddeclaration"}, {"full_name": "String.utf16PosToCodepointPosFromAux", "code": "private partial def utf16PosToCodepointPosFromAux (s : String) : Nat \u2192 Pos \u2192 Nat \u2192 Nat\n  | 0,        _,       cp => cp\n  | utf16pos, utf8pos, cp => utf16PosToCodepointPosFromAux s (utf16pos - csize16 (s.get utf8pos)) (s.next utf8pos) (cp + 1)", "start": [43, 1], "end": [45, 124], "kind": "commanddeclaration"}, {"full_name": "String.utf16PosToCodepointPosFrom", "code": "def utf16PosToCodepointPosFrom (s : String) (utf16pos : Nat) (off : Pos) : Nat :=\n  utf16PosToCodepointPosFromAux s utf16pos off 0", "start": [47, 1], "end": [50, 49], "kind": "commanddeclaration"}, {"full_name": "String.utf16PosToCodepointPos", "code": "def utf16PosToCodepointPos (s : String) (pos : Nat) : Nat :=\n  utf16PosToCodepointPosFrom s pos 0", "start": [52, 1], "end": [53, 37], "kind": "commanddeclaration"}, {"full_name": "String.codepointPosToUtf8PosFrom", "code": "def codepointPosToUtf8PosFrom (s : String) : String.Pos \u2192 Nat \u2192 String.Pos\n  | utf8pos, 0 => utf8pos\n  | utf8pos, p+1 => codepointPosToUtf8PosFrom s (s.next utf8pos) p", "start": [55, 1], "end": [58, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.FileMap.lspPosToUtf8Pos", "code": "def lspPosToUtf8Pos (text : FileMap) (pos : Lsp.Position) : String.Pos :=\n  let colPos :=\n    if h : pos.line < text.positions.size then\n      text.positions.get \u27e8pos.line, h\u27e9\n    else if text.positions.isEmpty then\n      0\n    else\n      text.positions.back\n  let chr := text.source.utf16PosToCodepointPosFrom pos.character colPos\n  text.source.codepointPosToUtf8PosFrom colPos chr", "start": [65, 1], "end": [76, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.FileMap.leanPosToLspPos", "code": "def leanPosToLspPos (text : FileMap) : Lean.Position \u2192 Lsp.Position\n  | \u27e8ln, col\u27e9 => \u27e8ln-1, text.source.codepointPosToUtf16PosFrom col (text.positions.get! $ ln - 1)\u27e9", "start": [78, 1], "end": [79, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.FileMap.utf8PosToLspPos", "code": "def utf8PosToLspPos (text : FileMap) (pos : String.Pos) : Lsp.Position :=\n  text.leanPosToLspPos (text.toPosition pos)", "start": [81, 1], "end": [82, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.RpcRef", "code": "structure RpcRef where\n  \n  p : USize\n  deriving BEq, Hashable, FromJson, ToJson", "start": [20, 1], "end": [25, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RpcObjectStore", "code": "structure RpcObjectStore : Type where\n  \n  aliveRefs : PersistentHashMap Lsp.RpcRef Dynamic := {}\n  \n  nextRef   : USize := 0", "start": [34, 1], "end": [44, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.rpcStoreRef", "code": "def rpcStoreRef (any : Dynamic) : StateM RpcObjectStore Lsp.RpcRef := do\n  let st \u2190 get\n  set { st with\n    aliveRefs := st.aliveRefs.insert \u27e8st.nextRef\u27e9 any\n    nextRef := st.nextRef + 1\n  }\n  return \u27e8st.nextRef\u27e9", "start": [46, 1], "end": [52, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.rpcGetRef", "code": "def rpcGetRef (r : Lsp.RpcRef) : ReaderT RpcObjectStore Id (Option Dynamic) :=\n  return (\u2190 read).aliveRefs.find? r", "start": [54, 1], "end": [55, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.rpcReleaseRef", "code": "def rpcReleaseRef (r : Lsp.RpcRef) : StateM RpcObjectStore Bool := do\n  let st \u2190 get\n  if st.aliveRefs.contains r then\n    set { st with aliveRefs := st.aliveRefs.erase r }\n    return true\n  else\n    return false", "start": [57, 1], "end": [63, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RpcEncodable", "code": "class RpcEncodable (\u03b1 : Type) where\n  rpcEncode : \u03b1 \u2192 StateM RpcObjectStore Json\n  rpcDecode : Json \u2192 ExceptT String (ReaderT RpcObjectStore Id) \u03b1", "start": [65, 1], "end": [80, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.WithRpcRef", "code": "structure WithRpcRef (\u03b1 : Type u) where\n  val : \u03b1\n  deriving Inhabited", "start": [106, 1], "end": [109, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/TextSync.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.TextDocumentSyncKind", "code": "inductive TextDocumentSyncKind where\n  | none\n  | full\n  | incremental", "start": [17, 1], "end": [20, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DidOpenTextDocumentParams", "code": "structure DidOpenTextDocumentParams where\n  textDocument : TextDocumentItem\n  deriving ToJson, FromJson", "start": [34, 1], "end": [36, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentChangeRegistrationOptions", "code": "structure TextDocumentChangeRegistrationOptions where\n  documentSelector? : Option DocumentSelector := none\n  syncKind : TextDocumentSyncKind\n  deriving FromJson", "start": [38, 1], "end": [41, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentContentChangeEvent", "code": "inductive TextDocumentContentChangeEvent where\n  | rangeChange (range : Range) (text : String)\n  | fullChange (text : String)", "start": [43, 1], "end": [46, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentContentChangeEvent.hasToJson", "code": "instance TextDocumentContentChangeEvent.hasToJson : ToJson TextDocumentContentChangeEvent :=\n  \u27e8fun o => mkObj $ match o with\n    | TextDocumentContentChangeEvent.rangeChange range text => [\u27e8\"range\", toJson range\u27e9, \u27e8\"text\", toJson text\u27e9]\n    | TextDocumentContentChangeEvent.fullChange text => [\u27e8\"text\", toJson text\u27e9]\u27e9", "start": [57, 1], "end": [60, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DidChangeTextDocumentParams", "code": "structure DidChangeTextDocumentParams where\n  textDocument : VersionedTextDocumentIdentifier\n  contentChanges : Array TextDocumentContentChangeEvent\n  deriving ToJson, FromJson", "start": [62, 1], "end": [65, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SaveOptions", "code": "structure SaveOptions where\n  includeText : Bool\n  deriving ToJson, FromJson", "start": [71, 1], "end": [73, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DidCloseTextDocumentParams", "code": "structure DidCloseTextDocumentParams where\n  textDocument : TextDocumentIdentifier\n  deriving ToJson, FromJson", "start": [75, 1], "end": [77, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentSyncOptions", "code": "structure TextDocumentSyncOptions where\n  openClose : Bool\n  change : TextDocumentSyncKind\n  willSave : Bool\n  willSaveWaitUntil : Bool\n  save? : Option SaveOptions := none\n  deriving ToJson, FromJson", "start": [81, 1], "end": [88, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Subst.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/FVarSubst.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/MatchUtil.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Revert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.Meta.substCore", "code": "def substCore (mvarId : MVarId) (hFVarId : FVarId) (symm := false) (fvarSubst : FVarSubst := {}) (clearH := true) (tryToSkip := false) : MetaM (FVarSubst \u00d7 MVarId) :=\n  mvarId.withContext do\n    let tag \u2190 mvarId.getTag\n    mvarId.checkNotAssigned `subst\n    let hFVarIdOriginal := hFVarId\n    let hLocalDecl \u2190 hFVarId.getDecl\n    match (\u2190 matchEq? hLocalDecl.type) with\n    | none => throwTacticEx `subst mvarId \"argument must be an equality proof\"\n    | some (_, lhs, rhs) => do\n      let a \u2190 instantiateMVars <| if symm then rhs else lhs\n      let b \u2190 instantiateMVars <| if symm then lhs else rhs\n      match a with\n      | Expr.fvar aFVarId => do\n        let aFVarIdOriginal := aFVarId\n        trace[Meta.Tactic.subst] \"substituting {a} (id: {aFVarId.name}) with {b}\"\n        if (\u2190 exprDependsOn b aFVarId) then\n          throwTacticEx `subst mvarId m!\"'{a}' occurs at{indentExpr b}\"\n        let (vars, mvarId) \u2190 mvarId.revert #[aFVarId, hFVarId] true\n        trace[Meta.Tactic.subst] \"after revert {MessageData.ofGoal mvarId}\"\n        let (twoVars, mvarId) \u2190 mvarId.introNP 2\n        trace[Meta.Tactic.subst] \"after intro2 {MessageData.ofGoal mvarId}\"\n        trace[Meta.Tactic.subst] \"reverted variables {vars.map (\u00b7.name)}\"\n        let aFVarId := twoVars[0]!\n        let a       := mkFVar aFVarId\n        let hFVarId := twoVars[1]!\n        let h       := mkFVar hFVarId\n        \n        let skip \u2190 if !tryToSkip || vars.size != 2 then\n          pure false\n        else\n          let mvarType \u2190 mvarId.getType\n          if (\u2190 exprDependsOn mvarType aFVarId) then pure false\n          else if (\u2190 exprDependsOn mvarType hFVarId) then pure false\n          else pure true\n        if skip then\n          if clearH then\n            let mvarId \u2190 mvarId.clear hFVarId\n            let mvarId \u2190 mvarId.clear aFVarId\n            pure ({}, mvarId)\n          else\n            pure ({}, mvarId)\n        else\n          mvarId.withContext do\n            let mvarDecl   \u2190 mvarId.getDecl\n            let type   := mvarDecl.type\n            let hLocalDecl \u2190 hFVarId.getDecl\n            match (\u2190 matchEq? hLocalDecl.type) with\n            | none => unreachable!\n            | some (_, lhs, rhs) => do\n              let b        \u2190 instantiateMVars <| if symm then lhs else rhs\n              let depElim  \u2190 exprDependsOn mvarDecl.type hFVarId\n              let cont (motive : Expr) (newType : Expr) : MetaM (FVarSubst \u00d7 MVarId) := do\n                let major \u2190 if symm then pure h else mkEqSymm h\n                let newMVar \u2190 mkFreshExprSyntheticOpaqueMVar newType tag\n                let minor := newMVar\n                let newVal  \u2190 if depElim then mkEqRec motive minor major else mkEqNDRec motive minor major\n                mvarId.assign newVal\n                let mvarId := newMVar.mvarId!\n                let mvarId \u2190 if clearH then\n                  let mvarId \u2190 mvarId.clear hFVarId\n                  mvarId.clear aFVarId\n                else\n                  pure mvarId\n                let (newFVars, mvarId) \u2190 mvarId.introNP (vars.size - 2)\n                trace[Meta.Tactic.subst] \"after intro rest {vars.size - 2} {MessageData.ofGoal mvarId}\"\n                let fvarSubst \u2190 newFVars.size.foldM (init := fvarSubst) fun i (fvarSubst : FVarSubst) =>\n                    let var     := vars[i+2]!\n                    let newFVar := newFVars[i]!\n                    pure $ fvarSubst.insert var (mkFVar newFVar)\n                let fvarSubst := fvarSubst.insert aFVarIdOriginal (if clearH then b else mkFVar aFVarId)\n                let fvarSubst := fvarSubst.insert hFVarIdOriginal (mkFVar hFVarId)\n                pure (fvarSubst, mvarId)\n              if depElim then do\n                let newType := type.replaceFVar a b\n                let reflB \u2190 mkEqRefl b\n                let newType := newType.replaceFVar h reflB\n                if symm then\n                  let motive \u2190 mkLambdaFVars #[a, h] type\n                  cont motive newType\n                else\n                  \n                  let hAuxType \u2190 mkEq b a\n                  let motive \u2190 withLocalDeclD `_h hAuxType fun hAux => do\n                    let hAuxSymm \u2190 mkEqSymm hAux\n                    \n                    let newType := type.replaceFVar h hAuxSymm\n                    mkLambdaFVars #[a, hAux] newType\n                  cont motive newType\n              else\n                let motive \u2190 mkLambdaFVars #[a] type\n                let newType := type.replaceFVar a b\n                cont motive newType\n      | _ =>\n        let eqMsg := if symm then \"(t = x)\" else \"(x = t)\"\n        throwTacticEx `subst mvarId\n          m!\"invalid equality proof, it is not of the form {eqMsg}{indentExpr hLocalDecl.type}\\nafter WHNF, variable expected, but obtained{indentExpr a}\"", "start": [17, 1], "end": [116, 155], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.heqToEq", "code": "def heqToEq (mvarId : MVarId) (fvarId : FVarId) (tryToClear : Bool := true) : MetaM (FVarId \u00d7 MVarId) :=\n  mvarId.withContext do\n   let decl \u2190 fvarId.getDecl\n   let type \u2190 whnf decl.type\n   match type.heq? with\n   | none              => pure (fvarId, mvarId)\n   | some (\u03b1, a, \u03b2, b) =>\n     if (\u2190 isDefEq \u03b1 \u03b2) then\n       let pr \u2190 mkEqOfHEq (mkFVar fvarId)\n       let eq \u2190 mkEq a b\n       let mut mvarId \u2190 mvarId.assert decl.userName eq pr\n       if tryToClear then\n         mvarId \u2190 mvarId.tryClear fvarId\n       let (fvarId, mvarId') \u2190 mvarId.intro1P\n       return (fvarId, mvarId')\n     else\n       return (fvarId, mvarId)", "start": [118, 1], "end": [138, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.subst", "code": "partial def subst (mvarId : MVarId) (h : FVarId) : MetaM MVarId :=\n  mvarId.withContext do\n    let type \u2190 h.getType\n    match (\u2190 matchEq? type) with\n    | some _ => substEq mvarId h\n    | none => match (\u2190 matchHEq? type) with\n      | some _ =>\n        let (h', mvarId') \u2190 heqToEq mvarId h\n        if mvarId == mvarId' then\n          findEq mvarId h\n        else\n          subst mvarId' h'\n      | none => findEq mvarId h\nwhere\n  \n  substEq (mvarId : MVarId) (h : FVarId) : MetaM MVarId := mvarId.withContext do\n    let localDecl \u2190 h.getDecl\n    let some (_, lhs, rhs) \u2190 matchEq? localDecl.type | unreachable!\n    let substReduced (newType : Expr) (symm : Bool) : MetaM MVarId := do\n      let mvarId \u2190 mvarId.assert localDecl.userName newType (mkFVar h)\n      let (hFVarId', mvarId) \u2190 mvarId.intro1P\n      let mvarId \u2190 mvarId.clear h\n      return (\u2190 substCore mvarId hFVarId' (symm := symm) (tryToSkip := true)).2\n    let rhs' \u2190 whnf rhs\n    if rhs'.isFVar then\n      if rhs != rhs' then\n        substReduced (\u2190 mkEq lhs rhs') true\n      else\n        return (\u2190 substCore mvarId h (symm := true) (tryToSkip := true)).2\n    else do\n      let lhs' \u2190 whnf lhs\n      if lhs'.isFVar then\n        if lhs != lhs' then\n          substReduced (\u2190 mkEq lhs' rhs) false\n        else\n          return (\u2190 substCore mvarId h (symm := false) (tryToSkip := true)).2\n      else do\n        throwTacticEx `subst mvarId m!\"invalid equality proof, it is not of the form (x = t) or (t = x){indentExpr localDecl.type}\"\n\n  \n  findEq (mvarId : MVarId) (h : FVarId) : MetaM MVarId := mvarId.withContext do\n    let localDecl \u2190 h.getDecl\n    if localDecl.isLet then\n      throwTacticEx `subst mvarId m!\"variable '{mkFVar h}' is a let-declaration\"\n    let lctx \u2190 getLCtx\n    let some (fvarId, symm) \u2190 lctx.findDeclM? fun localDecl => do\n       if localDecl.isImplementationDetail then\n         return none\n       else\n         match (\u2190 matchEq? localDecl.type) with\n         | some (_, lhs, rhs) =>\n           let lhs \u2190 instantiateMVars lhs\n           let rhs \u2190 instantiateMVars rhs\n           if rhs.isFVar && rhs.fvarId! == h then\n             if !(\u2190 exprDependsOn lhs h) then\n               return some (localDecl.fvarId, true)\n           if lhs.isFVar && lhs.fvarId! == h then\n             if !(\u2190 exprDependsOn rhs h) then\n               return some (localDecl.fvarId, false)\n           return none\n         | _ => return none\n      | throwTacticEx `subst mvarId m!\"did not find equation for eliminating '{mkFVar h}'\"\n    return (\u2190 substCore mvarId fvarId (symm := symm) (tryToSkip := true)).2", "start": [140, 1], "end": [202, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.subst?", "code": "def subst? (mvarId : MVarId) (hFVarId : FVarId) : MetaM (Option MVarId) :=\n  observing? (subst mvarId hFVarId)", "start": [204, 1], "end": [205, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.substCore?", "code": "def substCore? (mvarId : MVarId) (hFVarId : FVarId) (symm := false) (fvarSubst : FVarSubst := {}) (clearH := true) (tryToSkip := false) : MetaM (Option (FVarSubst \u00d7 MVarId)) :=\n  observing? (substCore mvarId hFVarId symm fvarSubst clearH tryToSkip)", "start": [207, 1], "end": [208, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.trySubst", "code": "def trySubst (mvarId : MVarId) (hFVarId : FVarId) : MetaM MVarId := do\n  match (\u2190 subst? mvarId hFVarId) with\n  | some mvarId => return mvarId\n  | none => return mvarId", "start": [210, 1], "end": [213, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.substSomeVar?", "code": "def substSomeVar? (mvarId : MVarId) : MetaM (Option MVarId) := mvarId.withContext do\n  for localDecl in (\u2190 getLCtx) do\n    if let some mvarId \u2190 subst? mvarId localDecl.fvarId then\n       return some mvarId\n  return none", "start": [215, 1], "end": [219, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.substVars", "code": "partial def substVars (mvarId : MVarId) : MetaM MVarId := do\n  if let some mvarId \u2190 substSomeVar? mvarId then\n    substVars mvarId\n  else\n    return mvarId", "start": [221, 1], "end": [225, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.Linear.isLinearTerm", "code": "def isLinearTerm (e : Expr) : Bool :=\n  let f := e.getAppFn\n  if !f.isConst then\n    false\n  else\n    let n := f.constName!\n    n == ``HAdd.hAdd || n == ``HMul.hMul || n == ``HSub.hSub || n == ``Nat.succ", "start": [10, 1], "end": [17, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.isLinearCnstr", "code": "partial def isLinearCnstr (e : Expr) : Bool :=\n  let f := e.getAppFn\n  if !f.isConst then\n    false\n  else\n    let n := f.constName!\n    if n == ``Eq || n == ``LT.lt || n == ``LE.le || n == ``GT.gt || n == ``GE.ge || n == ``Ne then\n      true\n    else if n == ``Not && e.getAppNumArgs == 1 then\n      isLinearCnstr e.appArg!\n    else\n      false", "start": [19, 1], "end": [31, 12], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Simp.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.Linear.Nat.simpCnstrPos?", "code": "def simpCnstrPos? (e : Expr) : MetaM (Option (Expr \u00d7 Expr)) := do\n  let (some c, ctx) \u2190 ToLinear.run (ToLinear.toLinearCnstr? e) | return none\n  let c\u2081 := c.toPoly\n  let c\u2082 := c\u2081.norm\n  if c\u2082.isUnsat then\n    let p := mkApp3 (mkConst ``Nat.Linear.ExprCnstr.eq_false_of_isUnsat) (\u2190 toContextExpr ctx) (toExpr c) reflTrue\n    return some (mkConst ``False, p)\n  else if c\u2082.isValid then\n    let p := mkApp3 (mkConst ``Nat.Linear.ExprCnstr.eq_true_of_isValid) (\u2190 toContextExpr ctx) (toExpr c) reflTrue\n    return some (mkConst ``True, p)\n  else\n    let c\u2082 : LinearCnstr := c\u2082.toExpr\n    let r \u2190 c\u2082.toArith ctx\n    if r != e then\n      let p := mkApp4 (mkConst ``Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq) (\u2190 toContextExpr ctx) (toExpr c) (toExpr c\u2082) reflTrue\n      return some (r, \u2190 mkExpectedTypeHint p (\u2190 mkEq e r))\n    else\n      return none", "start": [10, 1], "end": [27, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.simpCnstr?", "code": "def simpCnstr? (e : Expr) : MetaM (Option (Expr \u00d7 Expr)) := do\n  if let some arg := e.not? then\n    let mut eNew?   := none\n    let mut thmName := Name.anonymous\n    if arg.isAppOfArity ``LE.le 4 then\n      eNew?   := some (\u2190 mkLE (\u2190 mkAdd (arg.getArg! 3) (mkNatLit 1)) (arg.getArg! 2))\n      thmName := ``Nat.not_le_eq\n    else if arg.isAppOfArity ``GE.ge 4 then\n      eNew?   := some (\u2190 mkLE (\u2190 mkAdd (arg.getArg! 2) (mkNatLit 1)) (arg.getArg! 3))\n      thmName := ``Nat.not_ge_eq\n    else if arg.isAppOfArity ``LT.lt 4 then\n      eNew?   := some (\u2190 mkLE (arg.getArg! 3) (arg.getArg! 2))\n      thmName := ``Nat.not_lt_eq\n    else if arg.isAppOfArity ``GT.gt 4 then\n      eNew?   := some (\u2190 mkLE (arg.getArg! 2) (arg.getArg! 3))\n      thmName := ``Nat.not_gt_eq\n    if let some eNew := eNew? then\n      let h\u2081 := mkApp2 (mkConst thmName) (arg.getArg! 2) (arg.getArg! 3)\n      if let some (eNew', h\u2082) \u2190 simpCnstrPos? eNew then\n        let h  := mkApp6 (mkConst ``Eq.trans [levelOne]) (mkSort levelZero) e eNew eNew' h\u2081 h\u2082\n        return some (eNew', h)\n      else\n        return some (eNew, h\u2081)\n    else\n      return none\n  else\n    simpCnstrPos? e", "start": [29, 1], "end": [55, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.simpExpr?", "code": "def simpExpr? (e : Expr) : MetaM (Option (Expr \u00d7 Expr)) := do\n  let (e, ctx) \u2190 ToLinear.run (ToLinear.toLinearExpr e)\n  let p  := e.toPoly\n  let p' := p.norm\n  if p'.length < p.length then\n    let e' : LinearExpr := p'.toExpr\n    let p := mkApp4 (mkConst ``Nat.Linear.Expr.eq_of_toNormPoly_eq) (\u2190 toContextExpr ctx) (toExpr e) (toExpr e') reflTrue\n    let r \u2190 e'.toArith ctx\n    return some (r, p)\n  else\n    return none", "start": [57, 1], "end": [68, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpTheorems.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Recognizers.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/AuxLemma.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Lean/DocString.lean", "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eqns.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.Meta.Origin", "code": "inductive Origin where\n  \n  | decl (declName : Name) (inv := false)\n  \n  | fvar (fvarId : FVarId)\n  \n  | stx (id : Name) (ref : Syntax)\n  \n  | other (name : Name)\n  deriving Inhabited, Repr", "start": [15, 1], "end": [41, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Origin.key", "code": "def Origin.key : Origin \u2192 Name\n  | .decl declName _ => declName\n  | .fvar fvarId => fvarId.name\n  | .stx id _ => id\n  | .other name => name", "start": [43, 1], "end": [48, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheoremKey", "code": "abbrev SimpTheoremKey := DiscrTree.Key (simpleReduce := true)", "start": [64, 1], "end": [64, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorem", "code": "structure SimpTheorem where\n  keys        : Array SimpTheoremKey := #[]\n  \n  levelParams : Array Name := #[]\n  proof       : Expr\n  priority    : Nat  := eval_prio default\n  post        : Bool := true\n  \n  perm        : Bool := false\n  \n  origin      : Origin\n  \n  rfl         : Bool\n  deriving Inhabited", "start": [66, 1], "end": [95, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isRflProofCore", "code": "partial def isRflProofCore (type : Expr) (proof : Expr) : CoreM Bool := do\n    match type with\n    | .forallE _ _ type _ =>\n      if let .lam _ _ proof _ := proof then\n        isRflProofCore type proof\n      else\n        return false\n    | _ =>\n      if type.isAppOfArity ``Eq 3 then\n        if proof.isAppOfArity ``Eq.refl 2 || proof.isAppOfArity ``rfl 2 then\n          return true\n        else if proof.isAppOfArity ``Eq.symm 4 then\n          isRflProofCore type proof.appArg! else if proof.isApp && proof.getAppFn.isConst then\n          isRflTheorem proof.getAppFn.constName!\n        else\n          return false\n      else\n        return false", "start": [98, 3], "end": [118, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isRflTheorem", "code": "partial def isRflTheorem (declName : Name) : CoreM Bool := do\n    let .thmInfo info \u2190 getConstInfo declName | return false\n    isRflProofCore info.type info.value", "start": [120, 3], "end": [122, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isRflProof", "code": "def isRflProof (proof : Expr) : MetaM Bool := do\n  if let .const declName .. := proof then\n    isRflTheorem declName\n  else\n    isRflProofCore (\u2190 inferType proof) proof", "start": [125, 1], "end": [129, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ppOrigin", "code": "def ppOrigin [Monad m] [MonadEnv m] [MonadError m] : Origin \u2192 m MessageData\n  | .decl n inv => do let r \u2190 mkConstWithLevelParams n; if inv then return m!\"\u2190 {r}\" else return r\n  | .fvar n => return mkFVar n\n  | .stx _ ref => return ref\n  | .other n => return n", "start": [138, 1], "end": [142, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ppSimpTheorem", "code": "def ppSimpTheorem [Monad m] [MonadLiftT IO m] [MonadEnv m] [MonadError m] (s : SimpTheorem) : m MessageData := do\n  let perm := if s.perm then \":perm\" else \"\"\n  let name \u2190 ppOrigin s.origin\n  let prio := m!\":{s.priority}\"\n  return name ++ prio ++ perm", "start": [144, 1], "end": [148, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheoremTree", "code": "abbrev SimpTheoremTree := DiscrTree SimpTheorem (simpleReduce := true)", "start": [153, 1], "end": [153, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems", "code": "structure SimpTheorems where\n  pre          : SimpTheoremTree := DiscrTree.empty\n  post         : SimpTheoremTree := DiscrTree.empty\n  lemmaNames   : PHashSet Origin := {}\n  toUnfold     : PHashSet Name := {}\n  erased       : PHashSet Origin := {}\n  toUnfoldThms : PHashMap Name (Array Name) := {}\n  deriving Inhabited", "start": [155, 1], "end": [162, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addSimpTheoremEntry", "code": "def addSimpTheoremEntry (d : SimpTheorems) (e : SimpTheorem) : SimpTheorems :=\n  if e.post then\n    { d with post := d.post.insertCore e.keys e, lemmaNames := updateLemmaNames d.lemmaNames }\n  else\n    { d with pre := d.pre.insertCore e.keys e, lemmaNames := updateLemmaNames d.lemmaNames }\nwhere\n  updateLemmaNames (s : PHashSet Origin) : PHashSet Origin :=\n    s.insert e.origin", "start": [164, 1], "end": [171, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems.addDeclToUnfoldCore", "code": "def SimpTheorems.addDeclToUnfoldCore (d : SimpTheorems) (declName : Name) : SimpTheorems :=\n  { d with toUnfold := d.toUnfold.insert declName }", "start": [173, 1], "end": [174, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems.isDeclToUnfold", "code": "def SimpTheorems.isDeclToUnfold (d : SimpTheorems) (declName : Name) : Bool :=\n  d.toUnfold.contains declName", "start": [176, 1], "end": [178, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems.isLemma", "code": "def SimpTheorems.isLemma (d : SimpTheorems) (thmId : Origin) : Bool :=\n  d.lemmaNames.contains thmId", "start": [180, 1], "end": [181, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems.registerDeclToUnfoldThms", "code": "def SimpTheorems.registerDeclToUnfoldThms (d : SimpTheorems) (declName : Name) (eqThms : Array Name) : SimpTheorems :=\n  { d with toUnfoldThms := d.toUnfoldThms.insert declName eqThms }", "start": [183, 1], "end": [185, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems.eraseCore", "code": "partial def SimpTheorems.eraseCore (d : SimpTheorems) (thmId : Origin) : SimpTheorems :=\n  let d := { d with erased := d.erased.insert thmId, lemmaNames := d.lemmaNames.erase thmId }\n  if let .decl declName := thmId then\n    let d := { d with toUnfold := d.toUnfold.erase declName }\n    if let some thms := d.toUnfoldThms.find? declName then\n      thms.foldl (init := d) (eraseCore \u00b7 <| .decl \u00b7)\n    else\n      d\n  else\n    d", "start": [187, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems.erase", "code": "def SimpTheorems.erase [Monad m] [MonadError m] (d : SimpTheorems) (thmId : Origin) : m SimpTheorems := do\n  unless d.isLemma thmId ||\n    match thmId with\n    | .decl declName => d.isDeclToUnfold declName || d.toUnfoldThms.contains declName\n    | _ => false\n  do\n    throwError \"'{thmId.key}' does not have [simp] attribute\"\n  return d.eraseCore thmId", "start": [198, 1], "end": [205, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isPerm", "code": "private partial def isPerm : Expr \u2192 Expr \u2192 MetaM Bool\n  | Expr.app f\u2081 a\u2081, Expr.app f\u2082 a\u2082 => isPerm f\u2081 f\u2082 <&&> isPerm a\u2081 a\u2082\n  | Expr.mdata _ s, t => isPerm s t\n  | s, Expr.mdata _ t => isPerm s t\n  | s@(Expr.mvar ..), t@(Expr.mvar ..) => isDefEq s t\n  | Expr.forallE n\u2081 d\u2081 b\u2081 _, Expr.forallE _ d\u2082 b\u2082 _ => isPerm d\u2081 d\u2082 <&&> withLocalDeclD n\u2081 d\u2081 fun x => isPerm (b\u2081.instantiate1 x) (b\u2082.instantiate1 x)\n  | Expr.lam n\u2081 d\u2081 b\u2081 _, Expr.lam _ d\u2082 b\u2082 _ => isPerm d\u2081 d\u2082 <&&> withLocalDeclD n\u2081 d\u2081 fun x => isPerm (b\u2081.instantiate1 x) (b\u2082.instantiate1 x)\n  | Expr.letE n\u2081 t\u2081 v\u2081 b\u2081 _, Expr.letE _  t\u2082 v\u2082 b\u2082 _ =>\n    isPerm t\u2081 t\u2082 <&&> isPerm v\u2081 v\u2082 <&&> withLetDecl n\u2081 t\u2081 v\u2081 fun x => isPerm (b\u2081.instantiate1 x) (b\u2082.instantiate1 x)\n  | Expr.proj _ i\u2081 b\u2081, Expr.proj _ i\u2082 b\u2082 => pure (i\u2081 == i\u2082) <&&> isPerm b\u2081 b\u2082\n  | s, t => return s == t", "start": [207, 1], "end": [217, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkBadRewrite", "code": "private def checkBadRewrite (lhs rhs : Expr) : MetaM Unit := do\n  let lhs \u2190 DiscrTree.reduceDT lhs (root := true) (simpleReduce := true)\n  if lhs == rhs && lhs.isFVar then\n    throwError \"invalid `simp` theorem, equation is equivalent to{indentExpr (\u2190 mkEq lhs rhs)}\"", "start": [219, 1], "end": [222, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.shouldPreprocess", "code": "private partial def shouldPreprocess (type : Expr) : MetaM Bool :=\n  forallTelescopeReducing type fun _ result => do\n    if let some (_, lhs, rhs) := result.eq? then\n      checkBadRewrite lhs rhs\n      return false\n    else\n      return true", "start": [224, 1], "end": [230, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.preprocess", "code": "private partial def preprocess (e type : Expr) (inv : Bool) (isGlobal : Bool) : MetaM (List (Expr \u00d7 Expr)) :=\n  go e type\nwhere\n  go (e type : Expr) : MetaM (List (Expr \u00d7 Expr)) := do\n  let type \u2190 whnf type\n  if type.isForall then\n    forallTelescopeReducing type fun xs type => do\n      let e := mkAppN e xs\n      let ps \u2190 go e type\n      ps.mapM fun (e, type) =>\n        return (\u2190 mkLambdaFVars xs e, \u2190 mkForallFVars xs type)\n  else if let some (_, lhs, rhs) := type.eq? then\n    if isGlobal then\n      checkBadRewrite lhs rhs\n    if inv then\n      let type \u2190 mkEq rhs lhs\n      let e    \u2190 mkEqSymm e\n      return [(e, type)]\n    else\n      return [(e, type)]\n  else if let some (lhs, rhs) := type.iff? then\n    if isGlobal then\n      checkBadRewrite lhs rhs\n    if inv then\n      let type \u2190 mkEq rhs lhs\n      let e    \u2190 mkEqSymm (\u2190 mkPropExt e)\n      return [(e, type)]\n    else\n      let type \u2190 mkEq lhs rhs\n      let e    \u2190 mkPropExt e\n      return [(e, type)]\n  else if let some (_, lhs, rhs) := type.ne? then\n    if inv then\n      throwError \"invalid '\u2190' modifier in rewrite rule to 'False'\"\n    if rhs.isConstOf ``Bool.true then\n      return [(\u2190 mkAppM ``Bool.of_not_eq_true #[e], \u2190 mkEq lhs (mkConst ``Bool.false))]\n    else if rhs.isConstOf ``Bool.false then\n      return [(\u2190 mkAppM ``Bool.of_not_eq_false #[e], \u2190 mkEq lhs (mkConst ``Bool.true))]\n    let type \u2190 mkEq (\u2190 mkEq lhs rhs) (mkConst ``False)\n    let e    \u2190 mkEqFalse e\n    return [(e, type)]\n  else if let some p := type.not? then\n    if inv then\n      throwError \"invalid '\u2190' modifier in rewrite rule to 'False'\"\n    if let some (_, lhs, rhs) := p.eq? then\n      if rhs.isConstOf ``Bool.true then\n        return [(\u2190 mkAppM ``Bool.of_not_eq_true #[e], \u2190 mkEq lhs (mkConst ``Bool.false))]\n      else if rhs.isConstOf ``Bool.false then\n        return [(\u2190 mkAppM ``Bool.of_not_eq_false #[e], \u2190 mkEq lhs (mkConst ``Bool.true))]\n    let type \u2190 mkEq p (mkConst ``False)\n    let e    \u2190 mkEqFalse e\n    return [(e, type)]\n  else if let some (type\u2081, type\u2082) := type.and? then\n    let e\u2081 := mkProj ``And 0 e\n    let e\u2082 := mkProj ``And 1 e\n    return (\u2190 go e\u2081 type\u2081) ++ (\u2190 go e\u2082 type\u2082)\n  else\n    if inv then\n      throwError \"invalid '\u2190' modifier in rewrite rule to 'True'\"\n    let type \u2190 mkEq type (mkConst ``True)\n    let e    \u2190 mkEqTrue e\n    return [(e, type)]", "start": [232, 1], "end": [293, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkTypeIsProp", "code": "private def checkTypeIsProp (type : Expr) : MetaM Unit :=\n  unless (\u2190 isProp type) do\n    throwError \"invalid 'simp', proposition expected{indentExpr type}\"", "start": [295, 1], "end": [297, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSimpTheoremCore", "code": "private def mkSimpTheoremCore (origin : Origin) (e : Expr) (levelParams : Array Name) (proof : Expr) (post : Bool) (prio : Nat) : MetaM SimpTheorem := do\n  assert! origin != .fvar \u27e8.anonymous\u27e9\n  let type \u2190 instantiateMVars (\u2190 inferType e)\n  withNewMCtxDepth do\n    let (_, _, type) \u2190 withReducible <| forallMetaTelescopeReducing type\n    let type \u2190 whnfR type\n    let (keys, perm) \u2190\n      match type.eq? with\n      | some (_, lhs, rhs) => pure (\u2190 DiscrTree.mkPath lhs, \u2190 isPerm lhs rhs)\n      | none => throwError \"unexpected kind of 'simp' theorem{indentExpr type}\"\n    return { origin, keys, perm, post, levelParams, proof, priority := prio, rfl := (\u2190 isRflProof proof) }", "start": [299, 1], "end": [309, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSimpTheoremsFromConst", "code": "private def mkSimpTheoremsFromConst (declName : Name) (post : Bool) (inv : Bool) (prio : Nat) : MetaM (Array SimpTheorem) := do\n  let cinfo \u2190 getConstInfo declName\n  let val := mkConst declName (cinfo.levelParams.map mkLevelParam)\n  withReducible do\n    let type \u2190 inferType val\n    checkTypeIsProp type\n    if inv || (\u2190 shouldPreprocess type) then\n      let mut r := #[]\n      for (val, type) in (\u2190 preprocess val type inv (isGlobal := true)) do\n        let auxName \u2190 mkAuxLemma cinfo.levelParams type val\n        r := r.push <| (\u2190 mkSimpTheoremCore (.decl declName inv) (mkConst auxName (cinfo.levelParams.map mkLevelParam)) #[] (mkConst auxName) post prio)\n      return r\n    else\n      return #[\u2190 mkSimpTheoremCore (.decl declName) (mkConst declName (cinfo.levelParams.map mkLevelParam)) #[] (mkConst declName) post prio]", "start": [311, 1], "end": [324, 142], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpEntry", "code": "inductive SimpEntry where\n  | thm      : SimpTheorem \u2192 SimpEntry\n  | toUnfold : Name \u2192 SimpEntry\n  | toUnfoldThms : Name \u2192 Array Name \u2192 SimpEntry\n  deriving Inhabited", "start": [326, 1], "end": [330, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpExtension", "code": "abbrev SimpExtension := SimpleScopedEnvExtension SimpEntry SimpTheorems", "start": [332, 1], "end": [332, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpExtension.getTheorems", "code": "def SimpExtension.getTheorems (ext : SimpExtension) : CoreM SimpTheorems :=\n  return ext.getState (\u2190 getEnv)", "start": [334, 1], "end": [335, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addSimpTheorem", "code": "def addSimpTheorem (ext : SimpExtension) (declName : Name) (post : Bool) (inv : Bool) (attrKind : AttributeKind) (prio : Nat) : MetaM Unit := do\n  let simpThms \u2190 mkSimpTheoremsFromConst declName post inv prio\n  for simpThm in simpThms do\n    ext.add (SimpEntry.thm simpThm) attrKind", "start": [337, 1], "end": [340, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSimpAttr", "code": "def mkSimpAttr (attrName : Name) (attrDescr : String) (ext : SimpExtension)\n    (ref : Name := by exact decl_name%) : IO Unit :=\n  registerBuiltinAttribute {\n    ref   := ref\n    name  := attrName\n    descr := attrDescr\n    applicationTime := AttributeApplicationTime.afterCompilation\n    add   := fun declName stx attrKind =>\n      let go : MetaM Unit := do\n        let info \u2190 getConstInfo declName\n        let post := if stx[1].isNone then true else stx[1][0].getKind == ``Lean.Parser.Tactic.simpPost\n        let prio \u2190 getAttrParamOptPrio stx[2]\n        if (\u2190 isProp info.type) then\n          addSimpTheorem ext declName post (inv := false) attrKind prio\n        else if info.hasValue then\n          if let some eqns \u2190 getEqnsFor? declName then\n            for eqn in eqns do\n              addSimpTheorem ext eqn post (inv := false) attrKind prio\n            ext.add (SimpEntry.toUnfoldThms declName eqns) attrKind\n            if hasSmartUnfoldingDecl (\u2190 getEnv) declName then\n              ext.add (SimpEntry.toUnfold declName) attrKind\n          else\n            ext.add (SimpEntry.toUnfold declName) attrKind\n        else\n          throwError \"invalid 'simp', it is not a proposition nor a definition (to unfold)\"\n      discard <| go.run {} {}\n    erase := fun declName => do\n      let s := ext.getState (\u2190 getEnv)\n      let s \u2190 s.erase (.decl declName)\n      modifyEnv fun env => ext.modifyState env fun _ => s\n  }", "start": [342, 1], "end": [372, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSimpExt", "code": "def mkSimpExt (name : Name := by exact decl_name%) : IO SimpExtension :=\n  registerSimpleScopedEnvExtension {\n    name     := name\n    initial  := {}\n    addEntry := fun d e =>\n      match e with\n      | SimpEntry.thm e => addSimpTheoremEntry d e\n      | SimpEntry.toUnfold n => d.addDeclToUnfoldCore n\n      | SimpEntry.toUnfoldThms n thms => d.registerDeclToUnfoldThms n thms\n  }", "start": [374, 1], "end": [383, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpExtensionMap", "code": "abbrev SimpExtensionMap := HashMap Name SimpExtension", "start": [385, 1], "end": [385, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.registerSimpAttr", "code": "def registerSimpAttr (attrName : Name) (attrDescr : String)\n    (ref : Name := by exact decl_name%) : IO SimpExtension := do\n  let ext \u2190 mkSimpExt ref\n  mkSimpAttr attrName attrDescr ext ref simpExtensionMapRef.modify fun map => map.insert attrName ext\n  return ext", "start": [389, 1], "end": [394, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getSimpExtension?", "code": "def getSimpExtension? (attrName : Name) : IO (Option SimpExtension) :=\n  return (\u2190 simpExtensionMapRef.get).find? attrName", "start": [398, 1], "end": [399, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getSimpTheorems", "code": "def getSimpTheorems : CoreM SimpTheorems :=\n  simpExtension.getTheorems", "start": [401, 1], "end": [402, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems.addConst", "code": "def SimpTheorems.addConst (s : SimpTheorems) (declName : Name) (post := true) (inv := false) (prio : Nat := eval_prio default) : MetaM SimpTheorems := do\n  let s := { s with erased := s.erased.erase (.decl declName inv) }\n  let simpThms \u2190 mkSimpTheoremsFromConst declName post inv prio\n  return simpThms.foldl addSimpTheoremEntry s", "start": [404, 1], "end": [408, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorem.getValue", "code": "def SimpTheorem.getValue (simpThm : SimpTheorem) : MetaM Expr := do\n  if simpThm.proof.isConst && simpThm.levelParams.isEmpty then\n    let info \u2190 getConstInfo simpThm.proof.constName!\n    if info.levelParams.isEmpty then\n      return simpThm.proof\n    else\n      return simpThm.proof.updateConst! (\u2190 info.levelParams.mapM (fun _ => mkFreshLevelMVar))\n  else\n    let us \u2190 simpThm.levelParams.mapM fun _ => mkFreshLevelMVar\n    return simpThm.proof.instantiateLevelParamsArray simpThm.levelParams us", "start": [410, 1], "end": [419, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.preprocessProof", "code": "private def preprocessProof (val : Expr) (inv : Bool) : MetaM (Array Expr) := do\n  let type \u2190 inferType val\n  checkTypeIsProp type\n  let ps \u2190 preprocess val type inv (isGlobal := false)\n  return ps.toArray.map fun (val, _) => val", "start": [421, 1], "end": [425, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSimpTheorems", "code": "def mkSimpTheorems (id : Origin) (levelParams : Array Name) (proof : Expr) (post := true) (inv := false) (prio : Nat := eval_prio default) : MetaM (Array SimpTheorem) :=\n  withReducible do\n    (\u2190 preprocessProof proof inv).mapM fun val => mkSimpTheoremCore id val levelParams val post prio", "start": [427, 1], "end": [430, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems.add", "code": "def SimpTheorems.add (s : SimpTheorems) (id : Origin) (levelParams : Array Name) (proof : Expr) (inv := false) (post := true) (prio : Nat := eval_prio default) : MetaM SimpTheorems := do\n  if proof.isConst then\n    s.addConst proof.constName! post inv prio\n  else\n    let simpThms \u2190 mkSimpTheorems id levelParams proof post inv prio\n    return simpThms.foldl addSimpTheoremEntry s", "start": [432, 1], "end": [438, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheorems.addDeclToUnfold", "code": "def SimpTheorems.addDeclToUnfold (d : SimpTheorems) (declName : Name) : MetaM SimpTheorems := do\n  if let some eqns \u2190 getEqnsFor? declName then\n    let mut d := d\n    for eqn in eqns do\n      d \u2190 SimpTheorems.addConst d eqn\n    if hasSmartUnfoldingDecl (\u2190 getEnv) declName then\n      d := d.addDeclToUnfoldCore declName\n    return d\n  else\n    return d.addDeclToUnfoldCore declName", "start": [440, 1], "end": [449, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheoremsArray", "code": "abbrev SimpTheoremsArray := Array SimpTheorems", "start": [451, 1], "end": [451, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheoremsArray.addTheorem", "code": "def SimpTheoremsArray.addTheorem (thmsArray : SimpTheoremsArray) (id : Origin) (h : Expr) : MetaM SimpTheoremsArray :=\n  if thmsArray.isEmpty then\n    let thms : SimpTheorems := {}\n    return #[ (\u2190 thms.add id #[] h) ]\n  else\n    thmsArray.modifyM 0 fun thms => thms.add id #[] h", "start": [453, 1], "end": [458, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheoremsArray.eraseTheorem", "code": "def SimpTheoremsArray.eraseTheorem (thmsArray : SimpTheoremsArray) (thmId : Origin) : SimpTheoremsArray :=\n  thmsArray.map fun thms => thms.eraseCore thmId", "start": [460, 1], "end": [461, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheoremsArray.isErased", "code": "def SimpTheoremsArray.isErased (thmsArray : SimpTheoremsArray) (thmId : Origin) : Bool :=\n  thmsArray.any fun thms => thms.erased.contains thmId", "start": [463, 1], "end": [464, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpTheoremsArray.isDeclToUnfold", "code": "def SimpTheoremsArray.isDeclToUnfold (thmsArray : SimpTheoremsArray) (declName : Name) : Bool :=\n  thmsArray.any fun thms => thms.isDeclToUnfold declName", "start": [466, 1], "end": [467, 57], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpCongrTheorems.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Recognizers.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectMVars.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean"], "premises": [{"full_name": "Lean.Meta.SimpCongrTheorem", "code": "structure SimpCongrTheorem where\n  theoremName   : Name\n  funName       : Name\n  hypothesesPos : Array Nat\n  priority      : Nat\nderiving Inhabited, Repr", "start": [13, 1], "end": [24, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpCongrTheorems", "code": "structure SimpCongrTheorems where\n  lemmas : SMap Name (List SimpCongrTheorem) := {}\n  deriving Inhabited, Repr", "start": [26, 1], "end": [28, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpCongrTheorems.get", "code": "def SimpCongrTheorems.get (d : SimpCongrTheorems) (declName : Name) : List SimpCongrTheorem :=\n  match d.lemmas.find? declName with\n  | none    => []\n  | some cs => cs", "start": [30, 1], "end": [33, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addSimpCongrTheoremEntry", "code": "def addSimpCongrTheoremEntry (d : SimpCongrTheorems) (e : SimpCongrTheorem) : SimpCongrTheorems :=\n  { d with lemmas :=\n      match d.lemmas.find? e.funName with\n      | none    => d.lemmas.insert e.funName [e]\n      | some es => d.lemmas.insert e.funName <| insert es }\nwhere\n  insert : List SimpCongrTheorem \u2192 List SimpCongrTheorem\n    | []     => [e]\n    | e'::es => if e.priority \u2265 e'.priority then e::e'::es else e' :: insert es", "start": [35, 1], "end": [43, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSimpCongrTheorem", "code": "def mkSimpCongrTheorem (declName : Name) (prio : Nat) : MetaM SimpCongrTheorem := withReducible do\n  let c \u2190 mkConstWithLevelParams declName\n  let (xs, bis, type) \u2190 forallMetaTelescopeReducing (\u2190 inferType c)\n  match type.eqOrIff? with\n  | none => throwError \"invalid 'congr' theorem, equality expected{indentExpr type}\"\n  | some (lhs, rhs) =>\n    lhs.withApp fun lhsFn lhsArgs => rhs.withApp fun rhsFn rhsArgs => do\n      unless lhsFn.isConst && rhsFn.isConst && lhsFn.constName! == rhsFn.constName! && lhsArgs.size == rhsArgs.size do\n        throwError \"invalid 'congr' theorem, equality left/right-hand sides must be applications of the same function{indentExpr type}\"\n      let mut foundMVars : MVarIdSet := {}\n      for lhsArg in lhsArgs do\n        for mvarId in (lhsArg.collectMVars {}).result do\n          foundMVars := foundMVars.insert mvarId\n      let mut i := 0\n      let mut hypothesesPos := #[]\n      for x in xs, bi in bis do\n        if bi.isExplicit && !foundMVars.contains x.mvarId! then\n          let rhsFn? \u2190 forallTelescopeReducing (\u2190 inferType x) fun ys xType => do\n            match xType.eqOrIff? with\n            | none => pure none | some (xLhs, xRhs) =>\n              let mut j := 0\n              for y in ys do\n                let yType \u2190 inferType y\n                unless onlyMVarsAt yType foundMVars do\n                  throwError \"invalid 'congr' theorem, argument #{j+1} of parameter #{i+1} contains unresolved parameter{indentExpr yType}\"\n                j := j + 1\n              unless onlyMVarsAt xLhs foundMVars do\n                throwError \"invalid 'congr' theorem, parameter #{i+1} is not a valid hypothesis, the left-hand-side contains unresolved parameters{indentExpr xLhs}\"\n              let xRhsFn := xRhs.getAppFn\n              unless xRhsFn.isMVar do\n                throwError \"invalid 'congr' theorem, parameter #{i+1} is not a valid hypothesis, the right-hand-side head is not a metavariable{indentExpr xRhs}\"\n              unless !foundMVars.contains xRhsFn.mvarId! do\n                throwError \"invalid 'congr' theorem, parameter #{i+1} is not a valid hypothesis, the right-hand-side head was already resolved{indentExpr xRhs}\"\n              for arg in xRhs.getAppArgs do\n                unless arg.isFVar do\n                  throwError \"invalid 'congr' theorem, parameter #{i+1} is not a valid hypothesis, the right-hand-side argument is not local variable{indentExpr xRhs}\"\n              pure (some xRhsFn)\n          match rhsFn? with\n          | none       => pure ()\n          | some rhsFn =>\n            foundMVars    := foundMVars.insert x.mvarId! |>.insert rhsFn.mvarId!\n            hypothesesPos := hypothesesPos.push i\n        i := i + 1\n      return {\n        theoremName   := declName\n        funName       := lhsFn.constName!\n        hypothesesPos := hypothesesPos\n        priority      := prio\n      }\nwhere\n  \n  onlyMVarsAt (t : Expr) (mvarSet : MVarIdSet) : Bool :=\n    Option.isNone <| t.find? fun e => e.isMVar && !mvarSet.contains e.mvarId!", "start": [52, 1], "end": [105, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addSimpCongrTheorem", "code": "def addSimpCongrTheorem (declName : Name) (attrKind : AttributeKind) (prio : Nat) : MetaM Unit := do\n  let lemma \u2190 mkSimpCongrTheorem declName prio\n  congrExtension.add lemma attrKind", "start": [107, 1], "end": [109, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getSimpCongrTheorems", "code": "def getSimpCongrTheorems : MetaM SimpCongrTheorems :=\n  return congrExtension.getState (\u2190 getEnv)", "start": [120, 1], "end": [121, 44], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/CongrTheorems.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Class.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.CongrArgKind", "code": "inductive CongrArgKind where\n  \n  | fixed\n  \n  | fixedNoParam\n  \n  | eq\n  \n  | cast\n  \n  | heq\n  \n  | subsingletonInst\n  deriving Inhabited, Repr", "start": [11, 1], "end": [34, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CongrTheorem", "code": "structure CongrTheorem where\n  type     : Expr\n  proof    : Expr\n  argKinds : Array CongrArgKind", "start": [36, 1], "end": [39, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addPrimeToFVarUserNames", "code": "private def addPrimeToFVarUserNames (ys : Array Expr) (lctx : LocalContext) : LocalContext := Id.run do\n  let mut lctx := lctx\n  for y in ys do\n    let decl := lctx.getFVar! y\n    lctx := lctx.setUserName decl.fvarId (decl.userName.appendAfter \"'\")\n  return lctx", "start": [41, 1], "end": [46, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.setBinderInfosD", "code": "private def setBinderInfosD (ys : Array Expr) (lctx : LocalContext) : LocalContext := Id.run do\n  let mut lctx := lctx\n  for y in ys do\n    let decl := lctx.getFVar! y\n    lctx := lctx.setBinderInfo decl.fvarId BinderInfo.default\n  return lctx", "start": [48, 1], "end": [53, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkHCongrWithArity", "code": "partial def mkHCongrWithArity (f : Expr) (numArgs : Nat) : MetaM CongrTheorem := do\n  let fType \u2190 inferType f\n  forallBoundedTelescope fType numArgs fun xs _ =>\n  forallBoundedTelescope fType numArgs fun ys _ => do\n    if xs.size != numArgs then\n      throwError \"failed to generate hcongr theorem, insufficient number of arguments\"\n    else\n      let lctx := addPrimeToFVarUserNames ys (\u2190 getLCtx) |> setBinderInfosD ys |> setBinderInfosD xs\n      withLCtx lctx (\u2190 getLocalInstances) do\n      withNewEqs xs ys fun eqs argKinds => do\n        let mut hs := #[]\n        for x in xs, y in ys, eq in eqs do\n          hs := hs.push x |>.push y |>.push eq\n        let lhs := mkAppN f xs\n        let rhs := mkAppN f ys\n        let congrType \u2190 mkForallFVars hs (\u2190 mkHEq lhs rhs)\n        return {\n          type  := congrType\n          proof := (\u2190 mkProof congrType)\n          argKinds\n        }\nwhere\n  withNewEqs {\u03b1} (xs ys : Array Expr) (k : Array Expr \u2192 Array CongrArgKind \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n    let rec loop (i : Nat) (eqs : Array Expr) (kinds : Array CongrArgKind) := do\n      if  i < xs.size then\n        let x := xs[i]!\n        let y := ys[i]!\n        let xType := (\u2190 inferType x).consumeTypeAnnotations\n        let yType := (\u2190 inferType y).consumeTypeAnnotations\n        if xType == yType then\n          withLocalDeclD ((`e).appendIndexAfter (i+1)) (\u2190 mkEq x y) fun h =>\n            loop (i+1) (eqs.push h) (kinds.push CongrArgKind.eq)\n        else\n          withLocalDeclD ((`e).appendIndexAfter (i+1)) (\u2190 mkHEq x y) fun h =>\n            loop (i+1) (eqs.push h) (kinds.push CongrArgKind.heq)\n      else\n        k eqs kinds\n    loop 0 #[] #[]\n\n  mkProof (type : Expr) : MetaM Expr := do\n    if let some (_, lhs, _) := type.eq? then\n      mkEqRefl lhs\n    else if let some (_, lhs, _, _) := type.heq? then\n      mkHEqRefl lhs\n    else\n      forallBoundedTelescope type (some 1) fun a type =>\n      let a := a[0]!\n      forallBoundedTelescope type (some 1) fun b motive =>\n      let b := b[0]!\n      let type := type.bindingBody!.instantiate1 a\n      withLocalDeclD motive.bindingName! motive.bindingDomain! fun eqPr => do\n      let type := type.bindingBody!\n      let motive := motive.bindingBody!\n      let minor \u2190 mkProof type\n      let mut major := eqPr\n      if (\u2190 whnf (\u2190 inferType eqPr)).isHEq then\n        major \u2190 mkEqOfHEq major\n      let motive \u2190 mkLambdaFVars #[b] motive\n      mkLambdaFVars #[a, b, eqPr] (\u2190 mkEqNDRec motive minor major)", "start": [55, 1], "end": [113, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkHCongr", "code": "def mkHCongr (f : Expr) : MetaM CongrTheorem := do\n  mkHCongrWithArity f (\u2190 getFunInfo f).getArity", "start": [115, 1], "end": [116, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.fixKindsForDependencies", "code": "private def fixKindsForDependencies (info : FunInfo) (kinds : Array CongrArgKind) : Array CongrArgKind := Id.run do\n  let mut kinds := kinds\n  for i in [:info.paramInfo.size] do\n    for j in [i+1:info.paramInfo.size] do\n      if info.paramInfo[j]!.backDeps.contains i then\n        if kinds[j]! matches CongrArgKind.eq || kinds[j]! matches CongrArgKind.fixed then\n          kinds := kinds.set! i CongrArgKind.fixed\n          break\n  return kinds", "start": [118, 1], "end": [130, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkCast", "code": "private partial def mkCast (e : Expr) (type : Expr) (deps : Array Nat) (eqs : Array (Option Expr)) : MetaM Expr := do\n  let rec go (i : Nat) (type : Expr) : MetaM Expr := do\n     if i < deps.size then\n       match eqs[deps[i]!]! with\n       | none => go (i+1) type\n       | some major =>\n         let some (_, lhs, rhs) := (\u2190 inferType major).eq? | unreachable!\n         if (\u2190 dependsOn type major.fvarId!) then\n           let motive \u2190 mkLambdaFVars #[rhs, major] type\n           let typeNew := type.replaceFVar rhs lhs |>.replaceFVar major (\u2190 mkEqRefl lhs)\n           let minor \u2190 go (i+1) typeNew\n           mkEqRec motive minor major\n         else\n           let motive \u2190 mkLambdaFVars #[rhs] type\n           let typeNew := type.replaceFVar rhs lhs\n           let minor \u2190 go (i+1) typeNew\n           mkEqNDRec motive minor major\n     else\n       return e\n  go 0 type", "start": [132, 1], "end": [155, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.hasCastLike", "code": "private def hasCastLike (kinds : Array CongrArgKind) : Bool :=\n  kinds.any fun kind => kind matches CongrArgKind.cast || kind matches CongrArgKind.subsingletonInst", "start": [157, 1], "end": [158, 101], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNext", "code": "private def withNext (type : Expr) (k : Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  forallBoundedTelescope type (some 1) fun xs type => k xs[0]! type", "start": [160, 1], "end": [161, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.shouldUseSubsingletonInst", "code": "private def shouldUseSubsingletonInst (info : FunInfo) (kinds : Array CongrArgKind) (i : Nat) : Bool := Id.run do\n  if info.paramInfo[i]!.isDecInst then\n    for j in info.paramInfo[i]!.backDeps do\n      if kinds[j]! matches CongrArgKind.eq then\n        return true\n  return false", "start": [163, 1], "end": [171, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getClassSubobjectMask?", "code": "private def getClassSubobjectMask? (f : Expr) : MetaM (Option (Array Bool)) := do\n  let .const declName _ := f | return none\n  let .ctorInfo val \u2190 getConstInfo declName | return none\n  unless isClass (\u2190 getEnv) val.induct do return none\n  forallTelescopeReducing val.type fun xs _ => do\n    let env \u2190 getEnv\n    let mut mask := #[]\n    for i in [:xs.size] do\n      if i < val.numParams then\n        mask := mask.push false\n      else\n        let localDecl \u2190 xs[i]!.fvarId!.getDecl\n        mask := mask.push (isSubobjectField? env val.induct localDecl.userName).isSome\n    return some mask", "start": [173, 1], "end": [193, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getCongrSimpKinds", "code": "def getCongrSimpKinds (f : Expr) (info : FunInfo) : MetaM (Array CongrArgKind) := do\n  \n  let mut result := #[]\n  let mask? \u2190 getClassSubobjectMask? f\n  for i in [:info.paramInfo.size] do\n    if info.resultDeps.contains i then\n      result := result.push .fixed\n    else if info.paramInfo[i]!.isProp then\n      result := result.push .cast\n    else if info.paramInfo[i]!.isInstImplicit then\n      if let some mask := mask? then\n        if h : i < mask.size then\n          if mask[i] then\n            result := result.push .eq\n            continue\n      if shouldUseSubsingletonInst info result i then\n        result := result.push .subsingletonInst\n      else\n        result := result.push .fixed\n    else\n      result := result.push .eq\n  return fixKindsForDependencies info result", "start": [195, 1], "end": [231, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkCongrSimpCore?", "code": "partial def mkCongrSimpCore? (f : Expr) (info : FunInfo) (kinds : Array CongrArgKind) (subsingletonInstImplicitRhs : Bool := true) : MetaM (Option CongrTheorem) := do\n  if let some result \u2190 mk? f info kinds then\n    return some result\n  else if hasCastLike kinds then\n    let kinds := kinds.map fun kind =>\n      if kind matches CongrArgKind.cast || kind matches CongrArgKind.subsingletonInst then CongrArgKind.fixed else kind\n    mk? f info kinds\n  else\n    return none\nwhere\n  \n  mk? (f : Expr) (info : FunInfo) (kinds : Array CongrArgKind) : MetaM (Option CongrTheorem) := do\n    try\n      let fType \u2190 inferType f\n      forallBoundedTelescope fType kinds.size fun lhss _ => do\n        if lhss.size != kinds.size then return none\n        let rec go (i : Nat) (rhss : Array Expr) (eqs : Array (Option Expr)) (hyps : Array Expr) : MetaM CongrTheorem := do\n          if i == kinds.size then\n            let lhs := mkAppN f lhss\n            let rhs := mkAppN f rhss\n            let type \u2190 mkForallFVars hyps (\u2190 mkEq lhs rhs)\n            let proof \u2190 mkProof type kinds\n            return { type, proof, argKinds := kinds }\n          else\n            let hyps := hyps.push lhss[i]!\n            match kinds[i]! with\n            | .heq | .fixedNoParam => unreachable!\n            | .eq =>\n              let localDecl \u2190 lhss[i]!.fvarId!.getDecl\n              withLocalDecl localDecl.userName localDecl.binderInfo localDecl.type fun rhs => do\n              withLocalDeclD (localDecl.userName.appendBefore \"e_\") (\u2190 mkEq lhss[i]! rhs) fun eq => do\n                go (i+1) (rhss.push rhs) (eqs.push eq) (hyps.push rhs |>.push eq)\n            | .fixed => go (i+1) (rhss.push lhss[i]!) (eqs.push none) hyps\n            | .cast =>\n              let rhsType := (\u2190 inferType lhss[i]!).replaceFVars (lhss[:rhss.size]) rhss\n              let rhs \u2190 mkCast lhss[i]! rhsType info.paramInfo[i]!.backDeps eqs\n              go (i+1) (rhss.push rhs) (eqs.push none) hyps\n            | .subsingletonInst =>\n              withNewBinderInfos #[(lhss[i]!.fvarId!, .implicit)] do\n                let rhsType := (\u2190 inferType lhss[i]!).replaceFVars (lhss[:rhss.size]) rhss\n                let rhsBi   := if subsingletonInstImplicitRhs then .instImplicit else .implicit\n                withLocalDecl (\u2190 lhss[i]!.fvarId!.getDecl).userName rhsBi rhsType fun rhs =>\n                  go (i+1) (rhss.push rhs) (eqs.push none) (hyps.push rhs)\n        return some (\u2190 go 0 #[] #[] #[])\n    catch _ =>\n      return none\n\n  mkProof (type : Expr) (kinds : Array CongrArgKind) : MetaM Expr := do\n    let rec go (i : Nat) (type : Expr) : MetaM Expr := do\n      if i == kinds.size then\n        let some (_, lhs, _) := type.eq? | unreachable!\n        mkEqRefl lhs\n      else\n        withNext type fun lhs type => do\n        match kinds[i]! with\n        | .heq | .fixedNoParam => unreachable!\n        | .fixed => mkLambdaFVars #[lhs] (\u2190 go (i+1) type)\n        | .cast => mkLambdaFVars #[lhs] (\u2190 go (i+1) type)\n        | .eq =>\n          let typeSub := type.bindingBody!.bindingBody!.instantiate #[(\u2190 mkEqRefl lhs), lhs]\n          withNext type fun rhs type =>\n          withNext type fun heq type => do\n            let motive \u2190 mkLambdaFVars #[rhs, heq] type\n            let proofSub \u2190 go (i+1) typeSub\n            mkLambdaFVars #[lhs, rhs, heq] (\u2190 mkEqRec motive proofSub heq)\n        | .subsingletonInst =>\n          let typeSub := type.bindingBody!.instantiate #[lhs]\n          withNext type fun rhs type => do\n            let motive \u2190 mkLambdaFVars #[rhs] type\n            let proofSub \u2190 go (i+1) typeSub\n            let heq \u2190 mkAppM ``Subsingleton.elim #[lhs, rhs]\n            mkLambdaFVars #[lhs, rhs] (\u2190 mkEqNDRec motive proofSub heq)\n     go 0 type", "start": [233, 1], "end": [316, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkCongrSimp?", "code": "def mkCongrSimp? (f : Expr) (subsingletonInstImplicitRhs : Bool := true) : MetaM (Option CongrTheorem) := do\n  let f := (\u2190 instantiateMVars f).cleanupAnnotations\n  let info \u2190 getFunInfo f\n  mkCongrSimpCore? f info (\u2190 getCongrSimpKinds f info) (subsingletonInstImplicitRhs := subsingletonInstImplicitRhs)", "start": [318, 1], "end": [329, 116], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/InfoUtils.lean", "imports": ["lake-packages/lean4/src/lean/Lean/PrettyPrinter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.InfoWithCtx", "code": "structure InfoWithCtx where\n  ctx  : Elab.ContextInfo\n  info : Elab.Info\n  children : PersistentArray InfoTree", "start": [11, 1], "end": [36, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.visitM", "code": "partial def InfoTree.visitM [Monad m]\n    (preNode  : ContextInfo \u2192 Info \u2192 (children : PersistentArray InfoTree) \u2192 m Unit := fun _ _ _ => pure ())\n    (postNode : ContextInfo \u2192 Info \u2192 (children : PersistentArray InfoTree) \u2192 List (Option \u03b1) \u2192 m \u03b1)\n    : InfoTree \u2192 m (Option \u03b1) :=\n  go none\nwhere go\n  | _, context ctx t => go ctx t\n  | some ctx, node i cs => do\n    preNode ctx i cs\n    let as \u2190 cs.toList.mapM (go <| i.updateContext? ctx)\n    postNode ctx i cs as\n  | none, node .. => panic! \"unexpected context-free info tree node\"\n  | _, hole .. => pure none", "start": [38, 1], "end": [51, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.visitM'", "code": "def InfoTree.visitM' [Monad m]\n    (preNode  : ContextInfo \u2192 Info \u2192 (children : PersistentArray InfoTree) \u2192 m Unit := fun _ _ _ => pure ())\n    (postNode : ContextInfo \u2192 Info \u2192 (children : PersistentArray InfoTree) \u2192 m Unit := fun _ _ _ => pure ())\n    (t : InfoTree) : m Unit := t.visitM preNode (fun ci i cs _ => postNode ci i cs) |> discard", "start": [53, 1], "end": [57, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.collectNodesBottomUp", "code": "def InfoTree.collectNodesBottomUp (p : ContextInfo \u2192 Info \u2192 PersistentArray InfoTree \u2192 List \u03b1 \u2192 List \u03b1) (i : InfoTree) : List \u03b1 :=\n  i.visitM (m := Id) (postNode := fun ci i cs as => p ci i cs (as.filterMap id).join) |>.getD []", "start": [59, 1], "end": [62, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.deepestNodes", "code": "partial def InfoTree.deepestNodes (p : ContextInfo \u2192 Info \u2192 PersistentArray InfoTree \u2192 Option \u03b1) (infoTree : InfoTree) : List \u03b1 :=\n  infoTree.collectNodesBottomUp fun ctx i cs rs =>\n    if rs.isEmpty then\n      match p ctx i cs with\n      | some r => [r]\n      | none   => []\n    else\n      rs", "start": [64, 1], "end": [75, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.foldInfo", "code": "partial def InfoTree.foldInfo (f : ContextInfo \u2192 Info \u2192 \u03b1 \u2192 \u03b1) (init : \u03b1) : InfoTree \u2192 \u03b1 :=\n  go none init\nwhere go ctx? a\n  | context ctx t => go ctx a t\n  | node i ts =>\n    let a := match ctx? with\n      | none => a\n      | some ctx => f ctx i a\n    ts.foldl (init := a) (go <| i.updateContext? ctx?)\n  | _ => a", "start": [77, 1], "end": [86, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.isTerm", "code": "def Info.isTerm : Info \u2192 Bool\n  | ofTermInfo _ => true\n  | _ => false", "start": [88, 1], "end": [90, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.isCompletion", "code": "def Info.isCompletion : Info \u2192 Bool\n  | ofCompletionInfo .. => true\n  | _ => false", "start": [92, 1], "end": [94, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.getCompletionInfos", "code": "def InfoTree.getCompletionInfos (infoTree : InfoTree) : Array (ContextInfo \u00d7 CompletionInfo) :=\n  infoTree.foldInfo (init := #[]) fun ctx info result =>\n    match info with\n    | Info.ofCompletionInfo info => result.push (ctx, info)\n    | _ => result", "start": [96, 1], "end": [100, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.stx", "code": "def Info.stx : Info \u2192 Syntax\n  | ofTacticInfo i         => i.stx\n  | ofTermInfo i           => i.stx\n  | ofCommandInfo i        => i.stx\n  | ofMacroExpansionInfo i => i.stx\n  | ofOptionInfo i         => i.stx\n  | ofFieldInfo i          => i.stx\n  | ofCompletionInfo i     => i.stx\n  | ofCustomInfo i         => i.stx\n  | ofUserWidgetInfo i     => i.stx\n  | ofFVarAliasInfo _      => .missing\n  | ofFieldRedeclInfo i    => i.stx", "start": [102, 1], "end": [113, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.lctx", "code": "def Info.lctx : Info \u2192 LocalContext\n  | Info.ofTermInfo i  => i.lctx\n  | Info.ofFieldInfo i => i.lctx\n  | _                  => LocalContext.empty", "start": [115, 1], "end": [118, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.pos?", "code": "def Info.pos? (i : Info) : Option String.Pos :=\n  i.stx.getPos? (canonicalOnly := true)", "start": [120, 1], "end": [121, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.tailPos?", "code": "def Info.tailPos? (i : Info) : Option String.Pos :=\n  i.stx.getTailPos? (canonicalOnly := true)", "start": [123, 1], "end": [124, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.range?", "code": "def Info.range? (i : Info) : Option String.Range :=\n  i.stx.getRange? (canonicalOnly := true)", "start": [126, 1], "end": [127, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.contains", "code": "def Info.contains (i : Info) (pos : String.Pos) (includeStop := false) : Bool :=\n  i.range?.any (\u00b7.contains pos includeStop)", "start": [129, 1], "end": [130, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.size?", "code": "def Info.size? (i : Info) : Option String.Pos := do\n  let pos \u2190 i.pos?\n  let tailPos \u2190 i.tailPos?\n  return tailPos - pos", "start": [132, 1], "end": [135, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.isSmaller", "code": "def Info.isSmaller (i\u2081 i\u2082 : Info) : Bool :=\n  match i\u2081.size?, i\u2082.pos? with\n  | some sz\u2081, some sz\u2082 => sz\u2081 < sz\u2082\n  | some _, none => true\n  | _, _ => false", "start": [138, 1], "end": [142, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.occursBefore?", "code": "def Info.occursBefore? (i : Info) (hoverPos : String.Pos) : Option String.Pos := do\n  let tailPos \u2190 i.tailPos?\n  guard (tailPos \u2264 hoverPos)\n  return hoverPos - tailPos", "start": [144, 1], "end": [147, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.occursInside?", "code": "def Info.occursInside? (i : Info) (hoverPos : String.Pos) : Option String.Pos := do\n  let headPos \u2190 i.pos?\n  let tailPos \u2190 i.tailPos?\n  guard (headPos \u2264 hoverPos && hoverPos < tailPos)\n  return hoverPos - headPos", "start": [149, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.smallestInfo?", "code": "def InfoTree.smallestInfo? (p : Info \u2192 Bool) (t : InfoTree) : Option (ContextInfo \u00d7 Info) :=\n  let ts := t.deepestNodes fun ctx i _ => if p i then some (ctx, i) else none\n\n  let infos := ts.map fun (ci, i) =>\n    let diff := i.tailPos?.get! - i.pos?.get!\n    (diff, ci, i)\n\n  infos.toArray.getMax? (fun a b => a.1 > b.1) |>.map fun (_, ci, i) => (ci, i)", "start": [155, 1], "end": [162, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.hoverableInfoAt?", "code": "partial def InfoTree.hoverableInfoAt? (t : InfoTree) (hoverPos : String.Pos) (includeStop := false) (omitAppFns := false) (omitIdentApps := false) : Option InfoWithCtx := Id.run do\n  let results := t.visitM (m := Id) (postNode := fun ctx info children results => do\n    let mut results := results.bind (\u00b7.getD [])\n    if omitAppFns && info.stx.isOfKind ``Parser.Term.app && info.stx[0].isIdent then\n        results := results.filter (\u00b7.2.info.stx != info.stx[0])\n    if omitIdentApps && info.stx.isIdent then\n      if let .ofTermInfo ti := info then\n        if ti.expr.isApp then\n          results := results.filter (\u00b7.2.info.stx != info.stx)\n    unless results.isEmpty do\n      return results  if info.stx.isOfKind nullKind || info.toElabInfo?.any (\u00b7.elaborator == `Lean.Elab.Tactic.evalWithAnnotateState) then\n      return results\n    unless (info matches .ofFieldInfo _ | .ofOptionInfo _ || info.toElabInfo?.isSome) && info.contains hoverPos includeStop do\n      return results\n    let r := info.range?.get!\n    let priority := (\n      if r.stop == hoverPos then 0 else 1,\n      Int.negOfNat (r.stop - r.start).byteIdx,\n      if info matches .ofTermInfo { expr := .fvar .., .. } then 0 else 1)\n    [(priority, {ctx, info, children})]) |>.getD []\n  let maxPrio? :=\n    let _ := @lexOrd\n    let _ := @leOfOrd.{0}\n    let _ := @maxOfLe\n    results.map (\u00b7.1) |>.maximum?\n  let res? := results.find? (\u00b7.1 == maxPrio?) |>.map (\u00b7.2)\n  if let some i := res? then\n    if let .ofTermInfo ti := i.info then\n      if ti.expr.isSyntheticSorry then\n        return none\n  return res?", "start": [164, 1], "end": [208, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.type?", "code": "def Info.type? (i : Info) : MetaM (Option Expr) :=\n  match i with\n  | Info.ofTermInfo ti => Meta.inferType ti.expr\n  | Info.ofFieldInfo fi => Meta.inferType fi.val\n  | _ => return none", "start": [210, 1], "end": [214, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.docString?", "code": "def Info.docString? (i : Info) : MetaM (Option String) := do\n  let env \u2190 getEnv\n  match i with\n  | Info.ofTermInfo ti =>\n    if let some n := ti.expr.constName? then\n      return \u2190 findDocString? env n\n  | .ofFieldInfo fi => return \u2190 findDocString? env fi.projName\n  | .ofOptionInfo oi =>\n    if let some doc \u2190 findDocString? env oi.declName then\n      return doc\n    if let some decl := (\u2190 getOptionDecls).find? oi.optionName then\n      return decl.descr\n    return none\n  | _ => pure ()\n  if let some ei := i.toElabInfo? then\n    return \u2190 findDocString? env ei.stx.getKind <||> findDocString? env ei.elaborator\n  return none", "start": [216, 1], "end": [232, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Info.fmtHover?", "code": "def Info.fmtHover? (ci : ContextInfo) (i : Info) : IO (Option FormatWithInfos) := do\n  ci.runMetaM i.lctx do\n    let mut fmts := #[]\n    let mut infos := \u2205\n    let modFmt \u2190 try\n      let (termFmt, modFmt) \u2190 fmtTermAndModule?\n      if let some f := termFmt then\n        fmts := fmts.push f.fmt\n        infos := f.infos\n      pure modFmt\n    catch _ => pure none\n    if let some m \u2190 i.docString? then\n      fmts := fmts.push m\n    if let some f := modFmt then\n      fmts := fmts.push f\n    if fmts.isEmpty then\n      return none\n    else\n      return some \u27e8f!\"\\n***\\n\".joinSep fmts.toList, infos\u27e9\n\nwhere\n  fmtModule? (decl : Name) : MetaM (Option Format) := do\n    let some mod \u2190 findModuleOf? decl | return none\n    return some f!\"*import {mod}*\"\n\n  fmtTermAndModule? : MetaM (Option FormatWithInfos \u00d7 Option Format) := do\n    match i with\n    | Info.ofTermInfo ti =>\n      let e \u2190 instantiateMVars ti.expr\n      if e.isSort then\n        return (none, none)\n      let tp \u2190 instantiateMVars (\u2190 Meta.inferType e)\n      let tpFmt \u2190 Meta.ppExpr tp\n      if let .const c _ := e then\n        let eFmt \u2190 PrettyPrinter.ppSignature c\n        return (some { eFmt with fmt := f!\"```lean\\n{eFmt.fmt}\\n```\" }, \u2190 fmtModule? c)\n      let eFmt \u2190 Meta.ppExpr e\n      let showTerm := if let .fvar _ := e then\n        if let some ldecl := (\u2190 getLCtx).findFVar? e then\n          !ldecl.userName.hasMacroScopes\n        else false\n      else isAtomicFormat eFmt\n      let fmt := if showTerm then f!\"{eFmt} : {tpFmt}\" else tpFmt\n      return (some f!\"```lean\\n{fmt}\\n```\", none)\n    | Info.ofFieldInfo fi =>\n      let tp \u2190 Meta.inferType fi.val\n      let tpFmt \u2190 Meta.ppExpr tp\n      return (some f!\"```lean\\n{fi.fieldName} : {tpFmt}\\n```\", none)\n    | _ => return (none, none)\n\n  isAtomicFormat : Format \u2192 Bool\n    | Std.Format.text _    => true\n    | Std.Format.group f _ => isAtomicFormat f\n    | Std.Format.nest _ f  => isAtomicFormat f\n    | Std.Format.tag _ f   => isAtomicFormat f\n    | _                    => false", "start": [234, 1], "end": [292, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.GoalsAtResult", "code": "structure GoalsAtResult where\n  ctxInfo    : ContextInfo\n  tacticInfo : TacticInfo\n  useAfter   : Bool\n  \n  indented   : Bool\n  priority   : Nat", "start": [294, 1], "end": [301, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.goalsAt?", "code": "partial def InfoTree.goalsAt? (text : FileMap) (t : InfoTree) (hoverPos : String.Pos) : List GoalsAtResult :=\n  let gs := t.collectNodesBottomUp fun ctx i cs gs => Id.run do\n    if let Info.ofTacticInfo ti := i then\n      if let (some pos, some tailPos) := (i.pos?, i.tailPos?) then\n        let trailSize := i.stx.getTrailingSize\n        let atEOF := tailPos.byteIdx + trailSize == text.source.endPos.byteIdx\n        if pos \u2264 hoverPos \u2227 (hoverPos.byteIdx < tailPos.byteIdx + max 1 trailSize || atEOF) then\n          if gs.isEmpty || hoverPos \u2265 tailPos && gs.all (\u00b7.indented) then\n            return [{\n              ctxInfo := ctx\n              tacticInfo := ti\n              useAfter := hoverPos > pos && !cs.any (hasNestedTactic pos tailPos)\n              indented := (text.toPosition pos).column > (text.toPosition hoverPos).column && !isEmptyBy ti.stx\n              priority := if hoverPos.byteIdx == tailPos.byteIdx + trailSize then 0 else 1\n            }]\n    return gs\n  let maxPrio? := gs.map (\u00b7.priority) |>.maximum?\n  gs.filter (some \u00b7.priority == maxPrio?)\nwhere\n  hasNestedTactic (pos tailPos) : InfoTree \u2192 Bool\n    | InfoTree.node i@(Info.ofTacticInfo _) cs => Id.run do\n      if let `(by $_) := i.stx then\n        return false  if let (some pos', some tailPos') := (i.pos?, i.tailPos?) then\n        if tailPos' > hoverPos && (pos', tailPos') != (pos, tailPos) then\n          return true\n      cs.any (hasNestedTactic pos tailPos)\n    | InfoTree.node (Info.ofMacroExpansionInfo _) cs =>\n      cs.any (hasNestedTactic pos tailPos)\n    | _ => false\n  isEmptyBy (stx : Syntax) : Bool :=\n    stx.getNumArgs == 2 && stx[0].isToken \"by\" && stx[1].getNumArgs == 1 && stx[1][0].isMissing", "start": [303, 1], "end": [360, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.termGoalAt?", "code": "partial def InfoTree.termGoalAt? (t : InfoTree) (hoverPos : String.Pos) : Option InfoWithCtx :=\n  hoverableInfoAt? t hoverPos (includeStop := true) (omitAppFns := true)", "start": [363, 1], "end": [365, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.InfoTree.hasSorry", "code": "partial def InfoTree.hasSorry : InfoTree \u2192 IO Bool :=\n  go none\nwhere go ci?\n  | .context ci t => go ci t\n  | .node i cs =>\n    if let (some ci, .ofTermInfo ti) := (ci?, i) then do\n      let expr \u2190 ti.runMetaM ci (instantiateMVars ti.expr)\n      return expr.hasSorry\n      else\n      cs.anyM (go ci?)\n  | _ => return false", "start": [367, 1], "end": [379, 22], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/InfoTree.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Main.lean", "lake-packages/lean4/src/lean/Lean/Elab/InfoTree/Types.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Util/OccursCheck.lean", "imports": ["lake-packages/lean4/src/lean/Lean/MetavarContext.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.occursCheck", "code": "partial def occursCheck [Monad m] [MonadMCtx m] (mvarId : MVarId) (e : Expr) : m Bool := do\n  if !e.hasExprMVar then\n    return true\n  else\n    match (\u2190 visit e |>.run |>.run {}) with\n    | (.ok .., _)    => return true\n    | (.error .., _) => return false\nwhere\n  visitMVar (mvarId' : MVarId) : ExceptT Unit (StateT ExprSet m) Unit := do\n    if mvarId == mvarId' then\n      throw () else\n      match (\u2190 getExprMVarAssignment? mvarId') with\n      | some v => visit v\n      | none   =>\n        match (\u2190 getDelayedMVarAssignment? mvarId') with\n        | some d => visitMVar d.mvarIdPending\n        | none   => return ()\n\n  visit (e : Expr) : ExceptT Unit (StateT ExprSet m) Unit := do\n    if !e.hasExprMVar then\n      return ()\n    else if (\u2190 get).contains e then\n      return ()\n    else\n      modify fun s => s.insert e\n      match e with\n      | Expr.proj _ _ s      => visit s\n      | Expr.forallE _ d b _ => visit d; visit b\n      | Expr.lam _ d b _     => visit d; visit b\n      | Expr.letE _ t v b _  => visit t; visit v; visit b\n      | Expr.mdata _ b       => visit b\n      | Expr.app f a         => visit f; visit a\n      | Expr.mvar mvarId     => visitMVar mvarId\n      | _                    => return ()", "start": [10, 1], "end": [47, 42], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/ForEachExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Util/MonadCache.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ForEachExpr.visit", "code": "def visit (g : Expr \u2192 m Bool) (e : Expr) : MonadCacheT Expr Unit m Unit :=\n  checkCache e fun _ => do\n    if (\u2190 g e) then\n      match e with\n      | Expr.forallE _ d b _   => do visit g d; visit g b\n      | Expr.lam _ d b _       => do visit g d; visit g b\n      | Expr.letE _ t v b _    => do visit g t; visit g v; visit g b\n      | Expr.app f a           => do visit g f; visit g a\n      | Expr.mdata _ b         => visit g b\n      | Expr.proj _ _ b        => visit g b\n      | _                      => pure ()", "start": [18, 1], "end": [28, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.forEach'", "code": "@[inline] def Expr.forEach' (e : Expr) (f : Expr \u2192 m Bool) : m Unit :=\n  (ForEachExpr.visit f e).run", "start": [32, 1], "end": [34, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.forEach", "code": "@[inline] def Expr.forEach (e : Expr) (f : Expr \u2192 m Unit) : m Unit :=\n  e.forEach' fun e => do f e; pure true", "start": [36, 1], "end": [37, 40], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.admitGoal", "code": "def admitGoal (mvarId : MVarId) : MetaM Unit :=\n  mvarId.withContext do\n    let mvarType \u2190 inferType (mkMVar mvarId)\n    mvarId.assign (\u2190 mkSorry mvarType (synthetic := true))", "start": [11, 1], "end": [15, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.goalsToMessageData", "code": "def goalsToMessageData (goals : List MVarId) : MessageData :=\n  MessageData.joinSep (goals.map MessageData.ofGoal) m!\"\\n\\n\"", "start": [17, 1], "end": [18, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.reportUnsolvedGoals", "code": "def Term.reportUnsolvedGoals (goals : List MVarId) : MetaM Unit := do\n  logError <| MessageData.tagged `Tactic.unsolvedGoals <| m!\"unsolved goals\\n{goalsToMessageData goals}\"\n  goals.forM fun mvarId => admitGoal mvarId", "start": [20, 1], "end": [22, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Context", "code": "structure Context where\n  \n  elaborator : Name\n  \n  recover    : Bool := true", "start": [26, 1], "end": [34, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.SavedState", "code": "structure SavedState where\n  term   : Term.SavedState\n  tactic : State", "start": [36, 1], "end": [38, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.TacticM", "code": "abbrev TacticM := ReaderT Context $ StateRefT State TermElabM", "start": [40, 1], "end": [40, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Tactic", "code": "abbrev Tactic  := Syntax \u2192 TacticM Unit", "start": [41, 1], "end": [41, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getGoals", "code": "def getGoals : TacticM (List MVarId) :=\n  return (\u2190 get).goals", "start": [54, 1], "end": [55, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.setGoals", "code": "def setGoals (mvarIds : List MVarId) : TacticM Unit :=\n  modify fun _ => { goals := mvarIds }", "start": [57, 1], "end": [58, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.pruneSolvedGoals", "code": "def pruneSolvedGoals : TacticM Unit := do\n  let gs \u2190 getGoals\n  let gs \u2190 gs.filterM fun g => not <$> g.isAssigned\n  setGoals gs", "start": [60, 1], "end": [63, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getUnsolvedGoals", "code": "def getUnsolvedGoals : TacticM (List MVarId) := do\n  pruneSolvedGoals\n  getGoals", "start": [65, 1], "end": [67, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.TacticM.runCore", "code": "@[inline] private def TacticM.runCore (x : TacticM \u03b1) (ctx : Context) (s : State) : TermElabM (\u03b1 \u00d7 State) :=\n  x ctx |>.run s", "start": [69, 1], "end": [70, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.TacticM.runCore'", "code": "@[inline] private def TacticM.runCore' (x : TacticM \u03b1) (ctx : Context) (s : State) : TermElabM \u03b1 :=\n  Prod.fst <$> x.runCore ctx s", "start": [72, 1], "end": [73, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.run", "code": "def run (mvarId : MVarId) (x : TacticM Unit) : TermElabM (List MVarId) :=\n  mvarId.withContext do\n   let pendingMVarsSaved := (\u2190 get).pendingMVars\n   modify fun s => { s with pendingMVars := [] }\n   let aux : TacticM (List MVarId) :=\n     \n     try\n       x; getUnsolvedGoals\n     catch ex =>\n       if isAbortTacticException ex then\n         getUnsolvedGoals\n       else\n         throw ex\n   try\n     aux.runCore' { elaborator := .anonymous } { goals := [mvarId] }\n   finally\n     modify fun s => { s with pendingMVars := pendingMVarsSaved }", "start": [75, 1], "end": [93, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.saveState", "code": "protected def saveState : TacticM SavedState :=\n  return { term := (\u2190 Term.saveState), tactic := (\u2190 get) }", "start": [95, 1], "end": [96, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.SavedState.restore", "code": "def SavedState.restore (b : SavedState) (restoreInfo := false) : TacticM Unit := do\n  b.term.restore restoreInfo\n  set b.tactic", "start": [98, 1], "end": [100, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getCurrMacroScope", "code": "protected def getCurrMacroScope : TacticM MacroScope := do pure (\u2190 readThe Core.Context).currMacroScope", "start": [102, 1], "end": [102, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getMainModule", "code": "protected def getMainModule     : TacticM Name       := do pure (\u2190 getEnv).mainModule", "start": [103, 1], "end": [103, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.mkTacticAttribute", "code": "unsafe def mkTacticAttribute : IO (KeyedDeclsAttribute Tactic) :=\n  mkElabAttribute Tactic `builtin_tactic `tactic `Lean.Parser.Tactic `Lean.Elab.Tactic.Tactic \"tactic\" `Lean.Elab.Tactic.tacticElabAttribute", "start": [105, 1], "end": [106, 141], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.tacticElabAttribute", "code": "@[builtin_init mkTacticAttribute] opaque tacticElabAttribute : KeyedDeclsAttribute Tactic", "start": [108, 1], "end": [108, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.mkTacticInfo", "code": "def mkTacticInfo (mctxBefore : MetavarContext) (goalsBefore : List MVarId) (stx : Syntax) : TacticM Info :=\n  return Info.ofTacticInfo {\n    elaborator    := (\u2190 read).elaborator\n    mctxBefore    := mctxBefore\n    goalsBefore   := goalsBefore\n    stx           := stx\n    mctxAfter     := (\u2190 getMCtx)\n    goalsAfter    := (\u2190 getUnsolvedGoals)\n  }", "start": [110, 1], "end": [118, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.mkInitialTacticInfo", "code": "def mkInitialTacticInfo (stx : Syntax) : TacticM (TacticM Info) := do\n  let mctxBefore  \u2190 getMCtx\n  let goalsBefore \u2190 getUnsolvedGoals\n  return mkTacticInfo mctxBefore goalsBefore stx", "start": [120, 1], "end": [123, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.withTacticInfoContext", "code": "@[inline] def withTacticInfoContext (stx : Syntax) (x : TacticM \u03b1) : TacticM \u03b1 := do\n  withInfoContext x (\u2190 mkInitialTacticInfo stx)", "start": [125, 1], "end": [126, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.EvalTacticFailure", "code": "structure EvalTacticFailure where\n  exception : Exception\n  state : SavedState", "start": [135, 1], "end": [140, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalTactic", "code": "partial def evalTactic (stx : Syntax) : TacticM Unit := do\n  profileitM Exception \"tactic execution\" (decl := stx.getKind) (\u2190 getOptions) <|\n  withRef stx <| withIncRecDepth <| withFreshMacroScope <| match stx with\n    | .node _ k _    =>\n      if k == nullKind then\n        stx.getArgs.forM evalTactic\n      else withTraceNode `Elab.step (fun _ => return stx) do\n        let evalFns := tacticElabAttribute.getEntries (\u2190 getEnv) stx.getKind\n        let macros  := macroAttribute.getEntries (\u2190 getEnv) stx.getKind\n        if evalFns.isEmpty && macros.isEmpty then\n          throwErrorAt stx \"tactic '{stx.getKind}' has not been implemented\"\n        let s \u2190 Tactic.saveState\n        expandEval s macros evalFns #[]\n    | .missing => pure ()\n    | _ => throwError m!\"unexpected tactic{indentD stx}\"\nwhere\n    throwExs (failures : Array EvalTacticFailure) : TacticM Unit := do\n     if let some fail := failures[0]? then\n       fail.state.restore (restoreInfo := true)\n       throw fail.exception else\n       throwErrorAt stx \"unexpected syntax {indentD stx}\"\n\n    @[inline] handleEx (s : SavedState) (failures : Array EvalTacticFailure) (ex : Exception) (k : Array EvalTacticFailure \u2192 TacticM Unit) := do\n      match ex with\n      | .error .. =>\n        trace[Elab.tactic.backtrack] ex.toMessageData\n        let failures := failures.push \u27e8ex, \u2190 Tactic.saveState\u27e9\n        s.restore (restoreInfo := true); k failures\n      | .internal id _ =>\n        if id == unsupportedSyntaxExceptionId then\n          s.restore (restoreInfo := true); k failures\n        else if id == abortTacticExceptionId then\n          for msg in (\u2190 Core.getMessageLog).toList do\n            trace[Elab.tactic.backtrack] msg.data\n          let failures := failures.push \u27e8ex, \u2190 Tactic.saveState\u27e9\n          s.restore (restoreInfo := true); k failures\n        else\n          throw ex expandEval (s : SavedState) (macros : List _) (evalFns : List _) (failures : Array EvalTacticFailure) : TacticM Unit :=\n      match macros with\n      | [] => eval s evalFns failures\n      | m :: ms =>\n        try\n          withReader ({ \u00b7 with elaborator := m.declName }) do\n            withTacticInfoContext stx do\n              let stx' \u2190 adaptMacro m.value stx\n              evalTactic stx'\n        catch ex => handleEx s failures ex (expandEval s ms evalFns)\n\n    eval (s : SavedState) (evalFns : List _) (failures : Array EvalTacticFailure) : TacticM Unit := do\n      match evalFns with\n      | []              => throwExs failures\n      | evalFn::evalFns => do\n        try\n          withReader ({ \u00b7 with elaborator := evalFn.declName }) <| withTacticInfoContext stx <| evalFn.value stx\n        catch ex => handleEx s failures ex (eval s evalFns)", "start": [142, 1], "end": [202, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.throwNoGoalsToBeSolved", "code": "def throwNoGoalsToBeSolved : TacticM \u03b1 :=\n  throwError \"no goals to be solved\"", "start": [204, 1], "end": [205, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.done", "code": "def done : TacticM Unit := do\n  let gs \u2190 getUnsolvedGoals\n  unless gs.isEmpty do\n    Term.reportUnsolvedGoals gs\n    throwAbortTactic", "start": [207, 1], "end": [211, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.focus", "code": "def focus (x : TacticM \u03b1) : TacticM \u03b1 := do\n  let mvarId :: mvarIds \u2190 getUnsolvedGoals | throwNoGoalsToBeSolved\n  setGoals [mvarId]\n  let a \u2190 x\n  let mvarIds' \u2190 getUnsolvedGoals\n  setGoals (mvarIds' ++ mvarIds)\n  pure a", "start": [213, 1], "end": [219, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.focusAndDone", "code": "def focusAndDone (tactic : TacticM \u03b1) : TacticM \u03b1 :=\n  focus do\n    let a \u2190 tactic\n    done\n    pure a", "start": [221, 1], "end": [225, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.closeUsingOrAdmit", "code": "def closeUsingOrAdmit (tac : TacticM Unit) : TacticM Unit := do\n  \n  let mvarId :: mvarIds \u2190 getUnsolvedGoals | throwNoGoalsToBeSolved\n  try\n    focusAndDone tac\n  catch ex =>\n    if (\u2190 read).recover then\n      logException ex\n      admitGoal mvarId\n      setGoals mvarIds\n    else\n      throw ex", "start": [227, 1], "end": [240, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.tryCatch", "code": "@[inline] protected def tryCatch {\u03b1} (x : TacticM \u03b1) (h : Exception \u2192 TacticM \u03b1) : TacticM \u03b1 := do\n  let b \u2190 saveState\n  try x catch ex => b.restore; h ex", "start": [246, 1], "end": [248, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.withoutRecover", "code": "def withoutRecover (x : TacticM \u03b1) : TacticM \u03b1 :=\n  withReader (fun ctx => { ctx with recover := false }) x", "start": [254, 1], "end": [256, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.orElse", "code": "@[inline] protected def orElse (x : TacticM \u03b1) (y : Unit \u2192 TacticM \u03b1) : TacticM \u03b1 := do\n  try withoutRecover x catch _ => y ()", "start": [258, 1], "end": [259, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.saveTacticInfoForToken", "code": "def saveTacticInfoForToken (stx : Syntax) : TacticM Unit := do\n  unless stx.getPos?.isNone do\n    withTacticInfoContext stx (pure ())", "start": [268, 1], "end": [275, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.withMacroExpansion", "code": "@[inline]\ndef withMacroExpansion (beforeStx afterStx : Syntax) (x : TacticM \u03b1) : TacticM \u03b1 :=\n  withMacroExpansionInfo beforeStx afterStx do\n    withTheReader Term.Context (fun ctx => { ctx with macroStack := { before := beforeStx, after := afterStx } :: ctx.macroStack }) x", "start": [277, 1], "end": [281, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.adaptExpander", "code": "def adaptExpander (exp : Syntax \u2192 TacticM Syntax) : Tactic := fun stx => do\n  let stx' \u2190 exp stx\n  withMacroExpansion stx stx' $ evalTactic stx'", "start": [283, 1], "end": [286, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.appendGoals", "code": "def appendGoals (mvarIds : List MVarId) : TacticM Unit :=\n  modify fun s => { s with goals := s.goals ++ mvarIds }", "start": [288, 1], "end": [290, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.replaceMainGoal", "code": "def replaceMainGoal (mvarIds : List MVarId) : TacticM Unit := do\n  let (_ :: mvarIds') \u2190 getGoals | throwNoGoalsToBeSolved\n  modify fun _ => { goals := mvarIds ++ mvarIds' }", "start": [292, 1], "end": [296, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getMainGoal", "code": "def getMainGoal : TacticM MVarId := do\n  loop (\u2190 getGoals)\nwhere\n  loop : List MVarId \u2192 TacticM MVarId\n    | [] => throwNoGoalsToBeSolved\n    | mvarId :: mvarIds => do\n      if (\u2190 mvarId.isAssigned) then\n        loop mvarIds\n      else\n        setGoals (mvarId :: mvarIds)\n        return mvarId", "start": [298, 1], "end": [309, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getMainDecl", "code": "def getMainDecl : TacticM MetavarDecl := do\n  (\u2190 getMainGoal).getDecl", "start": [311, 1], "end": [313, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getMainTag", "code": "def getMainTag : TacticM Name :=\n  return (\u2190 getMainDecl).userName", "start": [315, 1], "end": [317, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getMainTarget", "code": "def getMainTarget : TacticM Expr := do\n  instantiateMVars (\u2190 getMainDecl).type", "start": [319, 1], "end": [321, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.withMainContext", "code": "def withMainContext (x : TacticM \u03b1) : TacticM \u03b1 := do\n  (\u2190 getMainGoal).withContext x", "start": [323, 1], "end": [325, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalTacticAt", "code": "def evalTacticAt (tac : Syntax) (mvarId : MVarId) : TacticM (List MVarId) := do\n  let gs \u2190 getGoals\n  try\n    setGoals [mvarId]\n    evalTactic tac\n    pruneSolvedGoals\n    getGoals\n  finally\n    setGoals gs", "start": [327, 1], "end": [336, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ensureHasNoMVars", "code": "def ensureHasNoMVars (e : Expr) : TacticM Unit := do\n  let e \u2190 instantiateMVars e\n  let pendingMVars \u2190 getMVars e\n  discard <| Term.logUnassignedUsingErrorInfos pendingMVars\n  if e.hasExprMVar then\n    throwError \"tactic failed, resulting expression contains metavariables{indentExpr e}\"", "start": [338, 1], "end": [343, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.closeMainGoal", "code": "def closeMainGoal (val : Expr) (checkUnassigned := true): TacticM Unit := do\n  if checkUnassigned then\n    ensureHasNoMVars val\n  (\u2190 getMainGoal).assign val\n  replaceMainGoal []", "start": [345, 1], "end": [350, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.liftMetaMAtMain", "code": "@[inline] def liftMetaMAtMain (x : MVarId \u2192 MetaM \u03b1) : TacticM \u03b1 := do\n  withMainContext do x (\u2190 getMainGoal)", "start": [352, 1], "end": [353, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.liftMetaTacticAux", "code": "@[inline] def liftMetaTacticAux (tac : MVarId \u2192 MetaM (\u03b1 \u00d7 List MVarId)) : TacticM \u03b1 := do\n  withMainContext do\n    let (a, mvarIds) \u2190 tac (\u2190 getMainGoal)\n    replaceMainGoal mvarIds\n    pure a", "start": [355, 1], "end": [359, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.liftMetaTactic", "code": "@[inline] def liftMetaTactic (tactic : MVarId \u2192 MetaM (List MVarId)) : TacticM Unit :=\n  liftMetaTacticAux fun mvarId => do\n    let gs \u2190 tactic mvarId\n    pure ((), gs)", "start": [361, 1], "end": [366, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.liftMetaTactic1", "code": "@[inline] def liftMetaTactic1 (tactic : MVarId \u2192 MetaM (Option MVarId)) : TacticM Unit :=\n  withMainContext do\n    if let some mvarId \u2190 tactic (\u2190 getMainGoal) then\n      replaceMainGoal [mvarId]\n    else\n      replaceMainGoal []", "start": [368, 1], "end": [373, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.tryTactic?", "code": "def tryTactic? (tactic : TacticM \u03b1) : TacticM (Option \u03b1) := do\n  try\n    pure (some (\u2190 tactic))\n  catch _ =>\n    pure none", "start": [375, 1], "end": [379, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.tryTactic", "code": "def tryTactic (tactic : TacticM \u03b1) : TacticM Bool := do\n  try\n    discard tactic\n    pure true\n  catch _ =>\n    pure false", "start": [381, 1], "end": [386, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.tagUntaggedGoals", "code": "def tagUntaggedGoals (parentTag : Name) (newSuffix : Name) (newGoals : List MVarId) : TacticM Unit := do\n  let mctx \u2190 getMCtx\n  let mut numAnonymous := 0\n  for g in newGoals do\n    if mctx.isAnonymousMVar g then\n      numAnonymous := numAnonymous + 1\n  modifyMCtx fun mctx => Id.run do\n    let mut mctx := mctx\n    let mut idx  := 1\n    for g in newGoals do\n      if mctx.isAnonymousMVar g then\n        if numAnonymous == 1 then\n          mctx := mctx.setMVarUserName g parentTag\n        else\n          mctx := mctx.setMVarUserName g (parentTag ++ newSuffix.appendIndexAfter idx)\n        idx := idx + 1\n    pure mctx", "start": [387, 1], "end": [407, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getNameOfIdent'", "code": "def getNameOfIdent' (id : Syntax) : Name :=\n  if id.isIdent then id.getId else `_", "start": [410, 1], "end": [411, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.withCaseRef", "code": "def withCaseRef [Monad m] [MonadRef m] (arrow body : Syntax) (x : m \u03b1) : m \u03b1 :=\n  withRef (mkNullNode #[arrow, body]) x", "start": [413, 1], "end": [418, 40], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/BindersUtil.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.expandOptType", "code": "def expandOptType (ref : Syntax) (optType : Syntax) : Syntax :=\n  if optType.isNone then\n    mkHole ref\n  else\n    optType[0][1]", "start": [9, 1], "end": [20, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getMatchAltsNumPatterns", "code": "def getMatchAltsNumPatterns (matchAlts : Syntax) : Nat :=\n  let alt0 := matchAlts[0][0]\n  let pats := alt0[1][0].getSepArgs\n  pats.size", "start": [24, 1], "end": [28, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandMatchAlt", "code": "def expandMatchAlt (stx : TSyntax ``matchAlt) : MacroM (Array (TSyntax ``matchAlt)) :=\n  match stx with\n  | `(matchAltExpr| | $[$patss,*]|* => $rhs) =>\n     if patss.size \u2264 1 then\n       return #[stx]\n     else\n       patss.mapM fun pats => `(matchAltExpr| | $pats,* => $rhs)\n  | _ => return #[stx]", "start": [30, 1], "end": [40, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.shouldExpandMatchAlt", "code": "def shouldExpandMatchAlt : TSyntax ``matchAlt \u2192 Bool\n  | `(matchAltExpr| | $[$patss,*]|* => $_) => patss.size > 1\n  | _ => false", "start": [42, 1], "end": [44, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandMatchAlts?", "code": "def expandMatchAlts? (stx : Syntax) : MacroM (Option Syntax) := do\n  match stx with\n  | `(match $[$gen]? $[$motive]? $discrs,* with $alts:matchAlt*) =>\n    if alts.any shouldExpandMatchAlt then\n      let alts \u2190 alts.foldlM (init := #[]) fun alts alt => return alts ++ (\u2190 expandMatchAlt alt)\n      `(match $[$gen]? $[$motive]? $discrs,* with $alts:matchAlt*)\n    else\n      return none\n  | _ => return none", "start": [46, 1], "end": [54, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.clearInMatchAlt", "code": "def clearInMatchAlt (stx : TSyntax ``matchAlt) (vars : Array Ident) : TSyntax ``matchAlt :=\n  stx.1.modifyArg 3 fun rhs => Unhygienic.run do\n    let mut rhs := rhs\n    for v in vars do\n      rhs \u2190 `(clear% $v; $rhs)\n    return rhs", "start": [57, 1], "end": [62, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.clearInMatch", "code": "def clearInMatch (stx : Syntax) (vars : Array Ident) : MacroM Syntax := do\n  if vars.isEmpty then return stx\n  match stx with\n  | `(match $[$gen]? $[$motive]? $discrs,* with $alts:matchAlt*) =>\n    let alts := alts.map (clearInMatchAlt \u00b7 vars)\n    `(match $[$gen]? $[$motive]? $discrs,* with $alts:matchAlt*)\n  | _ => return stx", "start": [64, 1], "end": [70, 20], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Quotation/Precheck.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Quotation/Util.lean", "lake-packages/lean4/src/lean/Lean/Parser/Command.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Lean/KeyedDeclsAttribute.lean"], "premises": [{"full_name": "Lean.Elab.Term.Quotation.Precheck.Context", "code": "structure Precheck.Context where\n  quotLCtx : NameSet", "start": [16, 1], "end": [17, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.PrecheckM", "code": "abbrev PrecheckM := ReaderT Precheck.Context TermElabM", "start": [19, 1], "end": [19, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.Precheck", "code": "abbrev Precheck  := Syntax \u2192 PrecheckM Unit", "start": [20, 1], "end": [20, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.withNewLocal", "code": "protected def withNewLocal (l : Name) (x : PrecheckM \u03b1) : PrecheckM \u03b1 :=\n  withReader (fun ctx => { ctx with quotLCtx := ctx.quotLCtx.insert l }) x", "start": [22, 1], "end": [23, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.withNewLocals", "code": "protected def withNewLocals (ls : Array Name) (x : PrecheckM \u03b1) : PrecheckM \u03b1 :=\n  withReader (fun ctx => { ctx with quotLCtx := ls.foldl NameSet.insert ctx.quotLCtx }) x", "start": [25, 1], "end": [26, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.mkPrecheckAttribute", "code": "unsafe def mkPrecheckAttribute : IO (KeyedDeclsAttribute Precheck) :=\n  KeyedDeclsAttribute.init {\n    builtinName := `builtin_quot_precheck,\n    name := `quot_precheck,\n    descr    := \"Register a double backtick syntax quotation pre-check.\n\n[quot_precheck k] registers a declaration of type `Lean.Elab.Term.Quotation.Precheck` for the `SyntaxNodeKind` `k`.\nIt should implement eager name analysis on the passed syntax by throwing an exception on unbound identifiers,\nand calling `precheck` recursively on nested terms, potentially with an extended local context (`withNewLocal`).\nMacros without registered precheck hook are unfolded, and identifier-less syntax is ultimately assumed to be well-formed.\",\n    valueTypeName := ``Precheck\n  } `Lean.Elab.Term.Quotation.precheckAttribute", "start": [39, 1], "end": [50, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.precheckAttribute", "code": "@[builtin_init mkPrecheckAttribute] opaque precheckAttribute : KeyedDeclsAttribute Precheck", "start": [51, 1], "end": [51, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.precheck", "code": "partial def precheck : Precheck := fun stx => do\n  if let p::_ := precheckAttribute.getValues (\u2190 getEnv) stx.getKind then\n    if \u2190 catchInternalId unsupportedSyntaxExceptionId (do withRef stx <| p stx; pure true) (fun _ => pure false) then\n      return\n  if stx.isAnyAntiquot then\n    return\n  if !hasQuotedIdent stx then\n    return  if let some stx' \u2190 liftMacroM <| expandMacro? stx then\n    precheck stx'\n    return\n  throwErrorAt stx \"no macro or `[quot_precheck]` instance for syntax kind '{stx.getKind}' found{indentD stx}\nThis means we cannot eagerly check your notation/quotation for unbound identifiers; you can use `set_option quotPrecheck false` to disable this check.\"\nwhere\n  hasQuotedIdent\n    | Syntax.ident .. => true\n    | stx =>\n      if stx.isAnyAntiquot then\n        false\n      else\n        stx.getArgs.any hasQuotedIdent", "start": [53, 1], "end": [73, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.runPrecheck", "code": "def runPrecheck (stx : Syntax) : TermElabM Unit := do\n  let opts \u2190 getOptions\n  if quotPrecheck.get opts && hygiene.get opts then\n    precheck stx |>.run { quotLCtx := {} }", "start": [75, 1], "end": [78, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.isSectionVariable", "code": "private def isSectionVariable (e : Expr) : TermElabM Bool := do\n  return (\u2190 read).sectionFVars.any fun _ v => e == v", "start": [80, 1], "end": [81, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.precheckIdent", "code": "@[builtin_quot_precheck ident] def precheckIdent : Precheck := fun stx =>\n  match stx with\n  | Syntax.ident _    _      val preresolved => do\n    if !preresolved.isEmpty then\n      return\n    \n    if let _::_ \u2190 resolveGlobalNameWithInfos stx val then\n      return\n    if (\u2190 read).quotLCtx.contains val then\n      return\n    let rs \u2190 try resolveName stx val [] [] catch _ => pure []\n    for (e, _) in rs do\n      match e with\n      | Expr.fvar _      .. =>\n        if quotPrecheck.allowSectionVars.get (\u2190 getOptions) && (\u2190 isSectionVariable e) then\n          return\n      | _ => pure ()\n    throwError \"unknown identifier '{val}' at quotation precheck; you can use `set_option quotPrecheck false` to disable this check.\"\n  | _ => throwUnsupportedSyntax", "start": [83, 1], "end": [107, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.precheckApp", "code": "@[builtin_quot_precheck Lean.Parser.Term.app] def precheckApp : Precheck\n  | `($f $args*) => do\n    precheck f\n    for arg in args.raw do\n      match arg with\n      | `(argument| ($_ := $e)) => precheck e\n      | `(argument| ..)         => pure ()\n      | `(argument| $e:term)    => precheck e\n  | _ => throwUnsupportedSyntax", "start": [109, 1], "end": [117, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.precheckTypeAscription", "code": "@[builtin_quot_precheck Lean.Parser.Term.typeAscription] def precheckTypeAscription : Precheck\n  | `(($e : $type)) => do\n    precheck e\n    precheck type\n  | `(($e :)) => precheck e\n  | _ => throwUnsupportedSyntax", "start": [119, 1], "end": [124, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.precheckExplicit", "code": "@[builtin_quot_precheck Lean.Parser.Term.explicit] def precheckExplicit : Precheck\n  | `(@ $id) => do\n    precheck id\n  | _ => throwUnsupportedSyntax", "start": [126, 1], "end": [129, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.precheckChoice", "code": "@[builtin_quot_precheck choice] def precheckChoice : Precheck := fun stx => do\n  let checks \u2190 stx.getArgs.mapM (_root_.observing \u2218 precheck)\n  let fails := checks.zip stx.getArgs |>.filterMap fun\n    | (.error e, stx) => some m!\"{stx}\\n{e.toMessageData}\"\n    | _               => none\n  unless fails.isEmpty do\n    throwErrorAt stx \"ambiguous notation with at least one interpretation that failed quotation precheck, possible interpretations {indentD (MessageData.joinSep fails.toList m!\"\\n\\n\")}\"", "start": [131, 1], "end": [137, 186], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Quotation.elabPrecheckedQuot", "code": "@[builtin_term_elab precheckedQuot] def elabPrecheckedQuot : TermElab := fun stx expectedType? => do\n  let singleQuot := stx[1]\n  runPrecheck singleQuot.getQuotContent\n  adaptExpander (fun _ => pure singleQuot) stx expectedType?", "start": [139, 1], "end": [142, 61], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Communication.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/JsonRpc.lean", "lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IO.FS.Stream.parseHeaderField", "code": "private def parseHeaderField (s : String) : Option (String \u00d7 String) := do\n    guard $ s \u2260 \"\" \u2227 s.takeRight 2 = \"\\r\\n\"\n    let xs := (s.dropRight 2).splitOn \": \"\n    match xs with\n    | []  => none\n    | [_] => none\n    | name :: value :: rest =>\n      let value := \": \".intercalate (value :: rest)\n      some \u27e8name, value\u27e9", "start": [18, 3], "end": [26, 25], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.isLean3Request", "code": "private def isLean3Request (s : String) : Bool :=\n    let e : Except String Unit := (do\n      let j \u2190 Json.parse s\n      let _ \u2190 j.getObjVal? \"command\"\n      let _ \u2190 j.getObjVal? \"seq_num\"\n      return ()\n    )\n    e.isOk", "start": [28, 3], "end": [38, 11], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readHeaderFields", "code": "private partial def readHeaderFields (h : FS.Stream) : IO (List (String \u00d7 String)) := do\n    let l \u2190 h.getLine\n    if l.isEmpty then\n      throw $ userError \"Stream was closed\"\n    if l = \"\\r\\n\" then\n      pure []\n    else\n      match parseHeaderField l with\n      | some hf =>\n        let tail \u2190 readHeaderFields h\n        pure (hf :: tail)\n      | none =>\n        if isLean3Request l then\n          throw $ userError s!\"A Lean 3 request was received. Please ensure that your editor has a Lean 4 compatible extension installed. For VSCode, this is\\n\\n    https://github.com/leanprover/vscode-lean4 \"\n        else\n          throw $ userError s!\"Invalid header field: {repr l}\"", "start": [40, 3], "end": [55, 63], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readLspHeader", "code": "private def readLspHeader (h : FS.Stream) : IO Nat := do\n    let fields \u2190 readHeaderFields h\n    match fields.lookup \"Content-Length\" with\n    | some length => match length.toNat? with\n      | some n => pure n\n      | none   => throw $ userError s!\"Content-Length header field value '{length}' is not a Nat\"\n    | none => throw $ userError s!\"No Content-Length field in header: {fields}\"", "start": [57, 3], "end": [64, 80], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readLspMessage", "code": "def readLspMessage (h : FS.Stream) : IO Message := do\n    try\n      let nBytes \u2190 readLspHeader h\n      h.readMessage nBytes\n    catch e =>\n      throw $ userError s!\"Cannot read LSP message: {e}\"", "start": [66, 3], "end": [71, 57], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readLspRequestAs", "code": "def readLspRequestAs (h : FS.Stream) (expectedMethod : String) (\u03b1) [FromJson \u03b1] : IO (Request \u03b1) := do\n    try\n      let nBytes \u2190 readLspHeader h\n      h.readRequestAs nBytes expectedMethod \u03b1\n    catch e =>\n      throw $ userError s!\"Cannot read LSP request: {e}\"", "start": [73, 3], "end": [78, 57], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readLspNotificationAs", "code": "def readLspNotificationAs (h : FS.Stream) (expectedMethod : String) (\u03b1) [FromJson \u03b1] : IO (Notification \u03b1) := do\n    try\n      let nBytes \u2190 readLspHeader h\n      h.readNotificationAs nBytes expectedMethod \u03b1\n    catch e =>\n      throw $ userError s!\"Cannot read LSP notification: {e}\"", "start": [80, 3], "end": [85, 62], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.readLspResponseAs", "code": "def readLspResponseAs (h : FS.Stream) (expectedID : RequestID) (\u03b1) [FromJson \u03b1] : IO (Response \u03b1) := do\n    try\n      let nBytes \u2190 readLspHeader h\n      h.readResponseAs nBytes expectedID \u03b1\n    catch e =>\n      throw $ userError s!\"Cannot read LSP response: {e}\"", "start": [87, 3], "end": [92, 58], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeLspMessage", "code": "def writeLspMessage (h : FS.Stream) (msg : Message) : IO Unit := do\n    let j := (toJson msg).compress\n    let header := s!\"Content-Length: {toString j.utf8ByteSize}\\r\\n\\r\\n\"\n    h.putStr (header ++ j)\n    h.flush", "start": [98, 3], "end": [104, 12], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeLspRequest", "code": "def writeLspRequest (h : FS.Stream) (r : Request \u03b1) : IO Unit :=\n    h.writeLspMessage r", "start": [106, 3], "end": [107, 24], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeLspNotification", "code": "def writeLspNotification (h : FS.Stream) (n : Notification \u03b1) : IO Unit :=\n    h.writeLspMessage n", "start": [109, 3], "end": [110, 24], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeLspResponse", "code": "def writeLspResponse (h : FS.Stream) (r : Response \u03b1) : IO Unit :=\n    h.writeLspMessage r", "start": [112, 3], "end": [113, 24], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeLspResponseError", "code": "def writeLspResponseError (h : FS.Stream) (e : ResponseError Unit) : IO Unit :=\n    h.writeLspMessage (Message.responseError e.id e.code e.message none)", "start": [115, 3], "end": [116, 73], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.writeLspResponseErrorWithData", "code": "def writeLspResponseErrorWithData (h : FS.Stream) (e : ResponseError \u03b1) : IO Unit :=\n    h.writeLspMessage e", "start": [118, 3], "end": [119, 24], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Diagnostics.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Message.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Utf16.lean"], "premises": [{"full_name": "Lean.Lsp.DiagnosticSeverity", "code": "inductive DiagnosticSeverity where\n  | error | warning | information | hint\n  deriving Inhabited, BEq", "start": [25, 1], "end": [27, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DiagnosticCode", "code": "inductive DiagnosticCode where\n  | int (i : Int)\n  | string (s : String)\n  deriving Inhabited, BEq", "start": [43, 1], "end": [47, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DiagnosticTag", "code": "inductive DiagnosticTag where\n  \n  | unnecessary\n  \n  | deprecated\n  deriving Inhabited, BEq", "start": [58, 1], "end": [64, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DiagnosticRelatedInformation", "code": "structure DiagnosticRelatedInformation where\n  location : Location\n  message : String\n  deriving Inhabited, BEq, ToJson, FromJson", "start": [76, 1], "end": [82, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DiagnosticWith", "code": "structure DiagnosticWith (\u03b1 : Type) where\n  \n  range : Range\n  \n  fullRange? : Option Range := some range\n  severity? : Option DiagnosticSeverity := none\n  \n  code? : Option DiagnosticCode := none\n  \n  source? : Option String := none\n  \n  message : \u03b1\n  \n  tags? : Option (Array DiagnosticTag) := none\n  \n  relatedInformation? : Option (Array DiagnosticRelatedInformation) := none\n  \n  data?: Option Json := none\n  deriving Inhabited, BEq, ToJson, FromJson", "start": [84, 1], "end": [110, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DiagnosticWith.fullRange", "code": "def DiagnosticWith.fullRange (d : DiagnosticWith \u03b1) : Range :=\n  d.fullRange?.getD d.range", "start": [112, 1], "end": [113, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Diagnostic", "code": "abbrev Diagnostic := DiagnosticWith String", "start": [115, 1], "end": [115, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.PublishDiagnosticsParams", "code": "structure PublishDiagnosticsParams where\n  uri : DocumentUri\n  version? : Option Int := none\n  diagnostics : Array Diagnostic\n  deriving Inhabited, BEq, ToJson, FromJson", "start": [117, 1], "end": [122, 44], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Extra.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/TextSync.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.DependencyBuildMode", "code": "inductive DependencyBuildMode where\n  \n  | always\n  \n  | once\n  \n  | never\n  deriving FromJson, ToJson, Inhabited", "start": [17, 1], "end": [27, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.LeanDidOpenTextDocumentParams", "code": "structure LeanDidOpenTextDocumentParams extends DidOpenTextDocumentParams where\n  dependencyBuildMode? : Option DependencyBuildMode := none deriving FromJson, ToJson", "start": [29, 1], "end": [31, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WaitForDiagnosticsParams", "code": "structure WaitForDiagnosticsParams where\n  uri     : DocumentUri\n  version : Nat\n  deriving FromJson, ToJson", "start": [33, 1], "end": [43, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WaitForDiagnostics", "code": "structure WaitForDiagnostics", "start": [45, 1], "end": [46, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.LeanFileProgressKind", "code": "inductive LeanFileProgressKind\n  | processing | fatalError\n  deriving Inhabited, BEq", "start": [54, 1], "end": [56, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.LeanFileProgressProcessingInfo", "code": "structure LeanFileProgressProcessingInfo where\n  range : Range\n  kind : LeanFileProgressKind := LeanFileProgressKind.processing\n  deriving FromJson, ToJson", "start": [68, 1], "end": [71, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.LeanFileProgressParams", "code": "structure LeanFileProgressParams where\n  textDocument : VersionedTextDocumentIdentifier\n  processing : Array LeanFileProgressProcessingInfo\n  deriving FromJson, ToJson", "start": [73, 1], "end": [79, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.PlainGoalParams", "code": "structure PlainGoalParams extends TextDocumentPositionParams\n  deriving FromJson, ToJson", "start": [81, 1], "end": [86, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.PlainGoal", "code": "structure PlainGoal where\n  \n  rendered : String\n  \n  goals : Array String\n  deriving FromJson, ToJson", "start": [88, 1], "end": [94, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.PlainTermGoalParams", "code": "structure PlainTermGoalParams extends TextDocumentPositionParams\n  deriving FromJson, ToJson", "start": [96, 1], "end": [100, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.PlainTermGoal", "code": "structure PlainTermGoal where\n  goal : String\n  range : Range\n  deriving FromJson, ToJson", "start": [102, 1], "end": [106, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RpcConnectParams", "code": "structure RpcConnectParams where\n  uri : DocumentUri\n  deriving FromJson, ToJson", "start": [108, 1], "end": [118, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RpcConnected", "code": "structure RpcConnected where\n  sessionId : UInt64\n  deriving FromJson, ToJson", "start": [120, 1], "end": [125, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RpcCallParams", "code": "structure RpcCallParams extends TextDocumentPositionParams where\n  sessionId : UInt64\n  \n  method : Name\n  params : Json\n  deriving FromJson, ToJson", "start": [127, 1], "end": [139, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RpcReleaseParams", "code": "structure RpcReleaseParams where\n  uri : DocumentUri\n  sessionId : UInt64\n  refs : Array RpcRef\n  deriving FromJson, ToJson", "start": [141, 1], "end": [149, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RpcKeepAliveParams", "code": "structure RpcKeepAliveParams where\n  uri : DocumentUri\n  sessionId : UInt64\n  deriving FromJson, ToJson", "start": [151, 1], "end": [159, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.LineRange", "code": "structure LineRange where\n  start : Nat\n  \u00abend\u00bb : Nat\n  deriving Inhabited, Repr, FromJson, ToJson", "start": [161, 1], "end": [167, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Injection.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/MatchUtil.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Subst.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.Meta.getCtorNumPropFields", "code": "def getCtorNumPropFields (ctorInfo : ConstructorVal) : MetaM Nat := do\n  forallTelescopeReducing ctorInfo.type fun xs _ => do\n    let mut numProps := 0\n    for i in [:ctorInfo.numFields] do\n      if (\u2190 isProp (\u2190 inferType xs[ctorInfo.numParams + i]!)) then\n        numProps := numProps + 1\n    return numProps", "start": [15, 1], "end": [21, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.InjectionResultCore", "code": "inductive InjectionResultCore where\n  | solved\n  | subgoal (mvarId : MVarId) (numNewEqs : Nat)", "start": [23, 1], "end": [25, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.injectionCore", "code": "def injectionCore (mvarId : MVarId) (fvarId : FVarId) : MetaM InjectionResultCore :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `injection\n    let decl \u2190 fvarId.getDecl\n    let type \u2190 whnf decl.type\n    let go (type prf : Expr) : MetaM InjectionResultCore := do\n      match type.eq? with\n      | none           => throwTacticEx `injection mvarId \"equality expected\"\n      | some (_, a, b) =>\n        let a \u2190 whnf a\n        let b \u2190 whnf b\n        let target \u2190 mvarId.getType\n        let env \u2190 getEnv\n        match a.isConstructorApp? env, b.isConstructorApp? env with\n        | some aCtor, some bCtor =>\n          let val \u2190 mkNoConfusion target prf\n          if aCtor.name != bCtor.name then\n            mvarId.assign val\n            return InjectionResultCore.solved\n          else\n            let valType \u2190 inferType val\n            let valType \u2190 whnf valType\n            match valType with\n            | Expr.forallE _ newTarget _ _ =>\n              let newTarget := newTarget.headBeta\n              let tag \u2190 mvarId.getTag\n              let newMVar \u2190 mkFreshExprSyntheticOpaqueMVar newTarget tag\n              mvarId.assign (mkApp val newMVar)\n              let mvarId \u2190 newMVar.mvarId!.tryClear fvarId\n              \n              let numPropFields \u2190 getCtorNumPropFields aCtor\n              return InjectionResultCore.subgoal mvarId (aCtor.numFields - numPropFields)\n            | _ => throwTacticEx `injection mvarId \"ill-formed noConfusion auxiliary construction\"\n        | _, _ => throwTacticEx `injection mvarId \"equality of constructor applications expected\"\n    let prf := mkFVar fvarId\n    if let some (\u03b1, a, \u03b2, b) := type.heq? then\n      if (\u2190 isDefEq \u03b1 \u03b2) then\n        go (\u2190 mkEq a b) (\u2190 mkEqOfHEq prf)\n      else\n        go type prf\n    else\n      go type prf", "start": [27, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.InjectionResult", "code": "inductive InjectionResult where\n  | solved\n  | subgoal (mvarId : MVarId) (newEqs : Array FVarId) (remainingNames : List Name)", "start": [71, 1], "end": [73, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.injectionIntro", "code": "def injectionIntro (mvarId : MVarId) (numEqs : Nat) (newNames : List Name) (tryToClear := true) : MetaM InjectionResult :=\n  let rec go : Nat \u2192 MVarId \u2192 Array FVarId \u2192 List Name \u2192 MetaM InjectionResult\n    | 0, mvarId, fvarIds, remainingNames =>\n      return InjectionResult.subgoal mvarId fvarIds remainingNames\n    | n+1, mvarId, fvarIds, name::remainingNames => do\n      let (fvarId, mvarId) \u2190 mvarId.intro name\n      let (fvarId, mvarId) \u2190 heqToEq mvarId fvarId tryToClear\n      go n mvarId (fvarIds.push fvarId) remainingNames\n    | n+1, mvarId, fvarIds, [] => do\n      let (fvarId, mvarId) \u2190 mvarId.intro1\n      let (fvarId, mvarId) \u2190 heqToEq mvarId fvarId tryToClear\n      go n mvarId (fvarIds.push fvarId) []\n  go numEqs mvarId #[] newNames", "start": [76, 1], "end": [88, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.injection", "code": "def injection (mvarId : MVarId) (fvarId : FVarId) (newNames : List Name := []) : MetaM InjectionResult := do\n  match (\u2190 injectionCore mvarId fvarId) with\n  | .solved                => pure .solved\n  | .subgoal mvarId numEqs => injectionIntro mvarId numEqs newNames", "start": [90, 1], "end": [93, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.InjectionsResult", "code": "inductive InjectionsResult where\n  | solved\n  | subgoal (mvarId : MVarId) (remainingNames : List Name)", "start": [95, 1], "end": [97, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.injections", "code": "partial def injections (mvarId : MVarId) (newNames : List Name := []) (maxDepth : Nat := 5) : MetaM InjectionsResult :=\n  mvarId.withContext do\n    let fvarIds := (\u2190 getLCtx).getFVarIds\n    go maxDepth fvarIds.toList mvarId newNames\nwhere\n  go : Nat \u2192 List FVarId \u2192 MVarId \u2192 List Name \u2192 MetaM InjectionsResult\n    | 0,   _,  _,      _        => throwTacticEx `injections mvarId \"recursion depth exceeded\"\n    | _,   [], mvarId, newNames => return .subgoal mvarId newNames\n    | d+1, fvarId :: fvarIds, mvarId, newNames => do\n      let cont := do\n        go (d+1) fvarIds mvarId newNames\n      if let some (_, lhs, rhs) \u2190 matchEqHEq? (\u2190 fvarId.getType) then\n        let lhs \u2190 whnf lhs\n        let rhs \u2190 whnf rhs\n        if lhs.isNatLit && rhs.isNatLit then cont\n        else\n          try\n            match (\u2190 injection mvarId fvarId newNames) with\n            | .solved  => return .solved\n            | .subgoal mvarId newEqs remainingNames =>\n              mvarId.withContext <| go d (newEqs.toList ++ fvarIds) mvarId remainingNames\n          catch _ => cont\n      else cont", "start": [99, 1], "end": [121, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/MatchEqsExt.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.Match.MatchEqns", "code": "structure MatchEqns where\n  eqnNames             : Array Name\n  splitterName         : Name\n  splitterAltNumParams : Array Nat\n  deriving Inhabited, Repr", "start": [10, 1], "end": [14, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatchEqns.size", "code": "def MatchEqns.size (e : MatchEqns) : Nat :=\n  e.eqnNames.size", "start": [16, 1], "end": [17, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatchEqnsExtState", "code": "structure MatchEqnsExtState where\n  map : PHashMap Name MatchEqns := {}\n  deriving Inhabited", "start": [19, 1], "end": [21, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.registerMatchEqns", "code": "def registerMatchEqns (matchDeclName : Name) (matchEqns : MatchEqns) : CoreM Unit :=\n  modifyEnv fun env => matchEqnsExt.modifyState env fun s => { s with map := s.map.insert matchDeclName matchEqns }", "start": [27, 1], "end": [28, 116], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.getEquationsFor", "code": "@[extern \"lean_get_match_equations_for\"]\nopaque getEquationsFor (matchDeclName : Name) : MetaM MatchEqns", "start": [33, 1], "end": [34, 64], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Simp.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Simp.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.Linear.parentIsTarget", "code": "private def parentIsTarget (parent? : Option Expr) : Bool :=\n  match parent? with\n  | none => false\n  | some parent => isLinearTerm parent || isLinearCnstr parent", "start": [11, 1], "end": [14, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.simp?", "code": "def simp? (e : Expr) (parent? : Option Expr) : MetaM (Option (Expr \u00d7 Expr)) := do\n  if isLinearCnstr e then\n    Nat.simpCnstr? e\n  else if isLinearTerm e && !parentIsTarget parent? then\n    trace[Meta.Tactic.simp] \"arith expr: {e}\"\n    Nat.simpExpr? e\n  else\n    return none", "start": [16, 1], "end": [24, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/ACLt.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Lean/Meta/FunInfo.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.ctorWeight", "code": "def Expr.ctorWeight : Expr \u2192 UInt8\n  | bvar ..    => 0\n  | fvar ..    => 1\n  | mvar ..    => 2\n  | sort ..    => 3\n  | const ..   => 4\n  | lit ..     => 5\n  | mdata ..   => 6\n  | proj ..    => 7\n  | app ..     => 8\n  | lam ..     => 9\n  | forallE .. => 10\n  | letE ..    => 11", "start": [12, 1], "end": [24, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ACLt.ReduceMode", "code": "inductive ReduceMode where\n  | reduce\n  | reduceSimpleOnly\n  | none", "start": [29, 1], "end": [32, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ACLt.main", "code": "unsafe def main (a b : Expr) (mode : ReduceMode := .none) : MetaM Bool :=\n  lt a b\nwhere\n  reduce (e : Expr) : MetaM Expr := do\n    if e.hasLooseBVars then\n      return e\n    else match mode with\n      | .reduce => DiscrTree.reduce e (simpleReduce := false)\n      | .reduceSimpleOnly => DiscrTree.reduce e (simpleReduce := true)\n      | .none => return e\n\n  lt (a b : Expr) : MetaM Bool := do\n    if ptrAddrUnsafe a == ptrAddrUnsafe b then\n      return false\n    else if a.isMData then\n      lt a.mdataExpr! b\n    else if b.isMData then\n      lt a b.mdataExpr!\n    else\n      lpo (\u2190 reduce a) (\u2190 reduce b)\n\n  ltPair (a\u2081 a\u2082 b\u2081 b\u2082 : Expr) : MetaM Bool := do\n    if (\u2190 lt a\u2081 b\u2081) then\n      return true\n    else if (\u2190 lt b\u2081 a\u2081) then\n      return false\n    else\n      lt a\u2082 b\u2082\n\n  ltApp (a b : Expr) : MetaM Bool := do\n    let aFn := a.getAppFn\n    let bFn := b.getAppFn\n    if (\u2190 lt aFn bFn) then\n      return true\n    else if (\u2190 lt bFn aFn) then\n      return false\n    else\n      let aArgs := a.getAppArgs\n      let bArgs := b.getAppArgs\n      if aArgs.size < bArgs.size then\n        return true\n      else if aArgs.size > bArgs.size then\n        return false\n      else\n        let infos := (\u2190 getFunInfoNArgs aFn aArgs.size).paramInfo\n        for i in [:infos.size] do\n          if !infos[i]!.isInstImplicit then\n            if (\u2190 lt aArgs[i]! bArgs[i]!) then\n              return true\n            else if (\u2190 lt bArgs[i]! aArgs[i]!) then\n              return false\n        for i in [infos.size:aArgs.size] do\n          if (\u2190 lt aArgs[i]! bArgs[i]!) then\n            return true\n          else if (\u2190 lt bArgs[i]! aArgs[i]!) then\n            return false\n        return false\n\n  lexSameCtor (a b : Expr) : MetaM Bool :=\n    match a with\n    | .bvar i ..    => return i < b.bvarIdx!\n    | .fvar id ..   => return Name.lt id.name b.fvarId!.name\n    | .mvar id ..   => return Name.lt id.name b.mvarId!.name\n    | .sort u ..    => return Level.normLt u b.sortLevel!\n    | .const n ..   => return Name.lt n b.constName! | .lit v ..     => return Literal.lt v b.litValue!\n    | .proj _ i e ..    => if i != b.projIdx! then return i < b.projIdx! else lt e b.projExpr!\n    | .app ..           => ltApp a b\n    | .lam _ d e ..     => ltPair d e b.bindingDomain! b.bindingBody!\n    | .forallE _ d e .. => ltPair d e b.bindingDomain! b.bindingBody!\n    | .letE _ _ v e ..  => ltPair v e b.letValue! b.letBody!\n    | .mdata ..         => unreachable!\n\n  allChildrenLt (a b : Expr) : MetaM Bool :=\n    match a with\n    | .proj _ _ e ..    => lt e b\n    | .app ..           =>\n      a.withApp fun f args => do\n        let infos := (\u2190 getFunInfoNArgs f args.size).paramInfo\n        for i in [:infos.size] do\n          if !infos[i]!.isInstImplicit then\n            if !(\u2190 lt args[i]! b) then\n              return false\n        for i in [infos.size:args.size] do\n          if !(\u2190 lt args[i]! b) then\n            return false\n        return true\n    | .lam _ d e ..     => lt d b <&&> lt e b\n    | .forallE _ d e .. => lt d b <&&> lt e b\n    | .letE _ _ v e ..  => lt v b <&&> lt e b\n    | _ => return true\n\n  someChildGe (a b : Expr) : MetaM Bool :=\n    return !(\u2190 allChildrenLt a b)\n\n  lpo (a b : Expr) : MetaM Bool := do\n    if (\u2190 someChildGe b a) then\n      return true\n    else if a.ctorWeight > b.ctorWeight then\n      return false\n    else\n      if !(\u2190 allChildrenLt a b) then\n        return false else if a.ctorWeight < b.ctorWeight then\n        return true else\n        lexSameCtor a b", "start": [36, 1], "end": [172, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Expr.acLt", "code": "@[implemented_by ACLt.main, inherit_doc ACLt.main]\nopaque Expr.acLt : Expr \u2192 Expr \u2192 (mode : ACLt.ReduceMode := .none) \u2192 MetaM Bool", "start": [178, 1], "end": [179, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Types.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/CongrTheorems.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpCongrTheorems.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpTheorems.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.Meta.Simp.Result", "code": "structure Result where\n  expr           : Expr\n  proof?         : Option Expr := none dischargeDepth : Nat := 0\n  deriving Inhabited", "start": [14, 1], "end": [18, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Cache", "code": "abbrev Cache := ExprMap Result", "start": [20, 1], "end": [20, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.CongrCache", "code": "abbrev CongrCache := ExprMap (Option CongrTheorem)", "start": [22, 1], "end": [22, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Context", "code": "structure Context where\n  config         : Config := {}\n  simpTheorems   : SimpTheoremsArray := {}\n  congrTheorems  : SimpCongrTheorems := {}\n  parent?        : Option Expr := none\n  dischargeDepth : Nat := 0\n  deriving Inhabited", "start": [24, 1], "end": [30, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Context.isDeclToUnfold", "code": "def Context.isDeclToUnfold (ctx : Context) (declName : Name) : Bool :=\n  ctx.simpTheorems.isDeclToUnfold declName", "start": [32, 1], "end": [33, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Context.mkDefault", "code": "def Context.mkDefault : MetaM Context :=\n  return { config := {}, simpTheorems := #[(\u2190 getSimpTheorems)], congrTheorems := (\u2190 getSimpCongrTheorems) }", "start": [35, 1], "end": [36, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.UsedSimps", "code": "abbrev UsedSimps := HashMap Origin Nat", "start": [38, 1], "end": [38, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.State", "code": "structure State where\n  cache        : Cache := {}\n  congrCache   : CongrCache := {}\n  usedTheorems : UsedSimps := {}\n  numSteps     : Nat := 0", "start": [40, 1], "end": [44, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.SimpM", "code": "abbrev SimpM := ReaderT Context $ StateRefT State MetaM", "start": [46, 1], "end": [46, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Step", "code": "inductive Step where\n  | visit : Result \u2192 Step\n  | done  : Result \u2192 Step\n  deriving Inhabited", "start": [52, 1], "end": [55, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Step.result", "code": "def Step.result : Step \u2192 Result\n  | Step.visit r => r\n  | Step.done r => r", "start": [57, 1], "end": [59, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Step.updateResult", "code": "def Step.updateResult : Step \u2192 Result \u2192 Step\n  | Step.visit _, r => Step.visit r\n  | Step.done _, r  => Step.done r", "start": [61, 1], "end": [63, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Methods", "code": "structure Methods where\n  pre        : Expr \u2192 SimpM Step          := fun e => return Step.visit { expr := e }\n  post       : Expr \u2192 SimpM Step          := fun e => return Step.done { expr := e }\n  discharge? : Expr \u2192 SimpM (Option Expr) := fun _ => return none\n  deriving Inhabited", "start": [65, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.M", "code": "abbrev M := ReaderT Methods SimpM", "start": [72, 1], "end": [72, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.pre", "code": "def pre (e : Expr) : M Step := do\n  (\u2190 read).pre e", "start": [74, 1], "end": [75, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.post", "code": "def post (e : Expr) : M Step := do\n  (\u2190 read).post e", "start": [77, 1], "end": [78, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.discharge?", "code": "def discharge? (e : Expr) : M (Option Expr) := do\n  (\u2190 read).discharge? e", "start": [80, 1], "end": [81, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.getConfig", "code": "def getConfig : M Config :=\n  return (\u2190 readThe Context).config", "start": [83, 1], "end": [84, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.withParent", "code": "@[inline] def withParent (parent : Expr) (f : M \u03b1) : M \u03b1 :=\n  withTheReader Context (fun ctx => { ctx with parent? := parent }) f", "start": [86, 1], "end": [87, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.getSimpTheorems", "code": "def getSimpTheorems : M SimpTheoremsArray :=\n  return (\u2190 readThe Context).simpTheorems", "start": [89, 1], "end": [90, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.getSimpCongrTheorems", "code": "def getSimpCongrTheorems : M SimpCongrTheorems :=\n  return (\u2190 readThe Context).congrTheorems", "start": [92, 1], "end": [93, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.withSimpTheorems", "code": "@[inline] def withSimpTheorems (s : SimpTheoremsArray) (x : M \u03b1) : M \u03b1 := do\n  let cacheSaved := (\u2190 get).cache\n  modify fun s => { s with cache := {} }\n  try\n    withTheReader Context (fun ctx => { ctx with simpTheorems := s }) x\n  finally\n    modify fun s => { s with cache := cacheSaved }", "start": [95, 1], "end": [101, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.recordSimpTheorem", "code": "def recordSimpTheorem (thmId : Origin) : SimpM Unit :=\n  modify fun s => if s.usedTheorems.contains thmId then s else\n    let n := s.usedTheorems.size\n    { s with usedTheorems := s.usedTheorems.insert thmId n }", "start": [103, 1], "end": [106, 61], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Widget/TaggedText.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json/FromToJson.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Widget.TaggedText", "code": "inductive TaggedText (\u03b1 : Type u) where\n  | text   : String \u2192 TaggedText \u03b1\n  \n  | append : Array (TaggedText \u03b1) \u2192 TaggedText \u03b1\n  | tag    : \u03b1 \u2192 TaggedText \u03b1 \u2192 TaggedText \u03b1\n  deriving Inhabited, BEq, Repr, FromJson, ToJson", "start": [13, 1], "end": [24, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.TaggedText.appendText", "code": "def appendText (s\u2080 : String) : TaggedText \u03b1 \u2192 TaggedText \u03b1\n  | text s    => text (s ++ s\u2080)\n  | append as => match as.back with\n    | text s => append <| as.set! (as.size - 1) <| text (s ++ s\u2080)\n    | _      => append <| as.push (text s\u2080)\n  | a         => append #[a, text s\u2080]", "start": [28, 1], "end": [33, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.TaggedText.appendTag", "code": "def appendTag (acc : TaggedText \u03b1) (t\u2080 : \u03b1) (a\u2080 : TaggedText \u03b1) : TaggedText \u03b1 :=\n  match acc with\n  | append as => append (as.push <| tag t\u2080 a\u2080)\n  | text \"\"   => tag t\u2080 a\u2080\n  | a         => append #[a, tag t\u2080 a\u2080]", "start": [35, 1], "end": [39, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.TaggedText.map", "code": "partial def map : TaggedText \u03b1 \u2192 TaggedText \u03b2\n  | text s => text s\n  | append as => append (as.map map)\n  | tag t a => tag (f t) (map a)", "start": [42, 1], "end": [45, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.TaggedText.mapM", "code": "partial def mapM : TaggedText \u03b1 \u2192 m (TaggedText \u03b2)\n  | text s => return text s\n  | append as => return append (\u2190 as.mapM mapM)\n  | tag t a => return tag (\u2190 f t) (\u2190 mapM a)", "start": [48, 1], "end": [51, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.TaggedText.rewrite", "code": "partial def rewrite : TaggedText \u03b1 \u2192 TaggedText \u03b2\n  | text s => text s\n  | append as => append (as.map rewrite)\n  | tag t a => f t a", "start": [54, 1], "end": [57, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.TaggedText.rewriteM", "code": "partial def rewriteM : TaggedText \u03b1 \u2192 m (TaggedText \u03b2)\n  | text s => return text s\n  | append as => return append (\u2190 as.mapM rewriteM)\n  | tag t a => f t a", "start": [60, 1], "end": [64, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.TaggedText.TaggedState", "code": "private structure TaggedState where\n  out      : TaggedText (Nat \u00d7 Nat)              := TaggedText.text \"\"\n  tagStack : List (Nat \u00d7 Nat \u00d7 TaggedText (Nat \u00d7 Nat)) := []\n  column   : Nat                                 := 0\n  deriving Inhabited", "start": [70, 1], "end": [74, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.TaggedText.prettyTagged", "code": "def prettyTagged (f : Format) (indent := 0) (w : Nat := Std.Format.defWidth) : TaggedText (Nat \u00d7 Nat) :=\n  (f.prettyM w indent : StateM TaggedState Unit) {} |>.snd.out", "start": [86, 1], "end": [90, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.TaggedText.stripTags", "code": "partial def stripTags (tt : TaggedText \u03b1) : String :=\n  go \"\" #[tt]\nwhere go (acc : String) : Array (TaggedText \u03b1) \u2192 String\n  | #[] => acc\n  | ts  => match ts.back with\n    | text s    => go (acc ++ s) ts.pop\n    | append as => go acc (ts.pop ++ as.reverse)\n    | tag _ a   => go acc (ts.set! (ts.size - 1) a)", "start": [92, 1], "end": [100, 52], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Widget/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/InfoTree.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Lean/Server/InfoUtils.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Message.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Lean/Util/ForEachExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Lean/Util/OccursCheck.lean"], "premises": [{"full_name": "Lean.Elab.Term.resumeElabTerm", "code": "private def resumeElabTerm (stx : Syntax) (expectedType? : Option Expr) (errToSorry := true) : TermElabM Expr :=\n  withReader (fun ctx => { ctx with errToSorry := ctx.errToSorry && errToSorry }) do\n    elabTerm stx expectedType? false", "start": [15, 1], "end": [19, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.resumePostponed", "code": "private def resumePostponed (savedContext : SavedContext) (stx : Syntax) (mvarId : MVarId) (postponeOnError : Bool) : TermElabM Bool :=\n  withRef stx <| mvarId.withContext do\n    let s \u2190 saveState\n    try\n      withSavedContext savedContext do\n        let mvarDecl     \u2190 getMVarDecl mvarId\n        let expectedType \u2190 instantiateMVars mvarDecl.type\n        withInfoHole mvarId do\n          let result \u2190 resumeElabTerm stx expectedType (!postponeOnError)\n          \n          let result \u2190 withRef stx <| ensureHasType expectedType result\n          \n          if (\u2190 occursCheck mvarId result) then\n            mvarId.assign result\n            return true\n          else\n            return false\n    catch\n     | ex@(.internal id _) =>\n       if id == postponeExceptionId then\n         s.restore (restoreInfo := true)\n         return false\n       else\n         throw ex\n     | ex@(.error ..) =>\n       if postponeOnError then\n         s.restore (restoreInfo := true)\n         return false\n       else\n         logException ex\n         return true", "start": [21, 1], "end": [56, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizePendingInstMVar", "code": "private def synthesizePendingInstMVar (instMVar : MVarId) : TermElabM Bool :=\n  instMVar.withContext do\n    try\n      synthesizeInstMVarCore instMVar\n    catch\n      | ex@(.error ..) => logException ex; return true\n      | _              => unreachable!", "start": [58, 1], "end": [67, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeUsingDefaultPrio", "code": "private partial def synthesizeUsingDefaultPrio (mvarId : MVarId) (prio : Nat) : TermElabM Bool :=\n  mvarId.withContext do\n    let mvarType \u2190 mvarId.getType\n    match (\u2190 isClass? mvarType) with\n    | none => return false\n    | some className =>\n      match (\u2190 getDefaultInstances className) with\n      | [] => return false\n      | defaultInstances =>\n        for (defaultInstance, instPrio) in defaultInstances do\n          if instPrio == prio then\n            if (\u2190 synthesizeUsingDefaultInstance mvarId defaultInstance) then\n              return true\n        return false\nwhere\n  synthesizeUsingDefault (mvarId : MVarId) : TermElabM Bool := do\n    for prio in (\u2190 getDefaultInstancesPriorities) do\n      if (\u2190 synthesizeUsingDefaultPrio mvarId prio) then\n        return true\n    return false\n\n  synthesizePendingInstMVar' (mvarId : MVarId) : TermElabM Bool :=\n    commitWhen <| mvarId.withContext do\n      try\n        synthesizeInstMVarCore mvarId\n      catch _ =>\n        return false\n\n  synthesizeUsingInstancesStep (mvarIds : List MVarId) : TermElabM (List MVarId) :=\n    mvarIds.filterM fun mvarId => do\n      if (\u2190 synthesizePendingInstMVar' mvarId) then\n        return false\n      else\n        return true\n\n  synthesizeUsingInstances (mvarIds : List MVarId) : TermElabM (List MVarId) := do\n    let mvarIds' \u2190 synthesizeUsingInstancesStep mvarIds\n    if mvarIds'.length < mvarIds.length then\n      synthesizeUsingInstances mvarIds'\n    else\n      return mvarIds'\n\n  synthesizeUsingDefaultInstance (mvarId : MVarId) (defaultInstance : Name) : TermElabM Bool :=\n    commitWhen do\n      let candidate \u2190 mkConstWithFreshMVarLevels defaultInstance\n      let (mvars, bis, _) \u2190 forallMetaTelescopeReducing (\u2190 inferType candidate)\n      let candidate := mkAppN candidate mvars\n      trace[Elab.defaultInstance] \"{toString (mkMVar mvarId)}, {mkMVar mvarId} : {\u2190 inferType (mkMVar mvarId)} =?= {candidate} : {\u2190 inferType candidate}\"\n      \n      if (\u2190 withAssignableSyntheticOpaque <| isDefEqGuarded (mkMVar mvarId) candidate) then\n        trace[Elab.defaultInstance] \"isDefEq worked {mkMVar mvarId} : {\u2190 inferType (mkMVar mvarId)} =?= {candidate} : {\u2190 inferType candidate}\"\n        let mut pending := []\n        for i in [:bis.size] do\n          if bis[i]! == BinderInfo.instImplicit then\n            pending := mvars[i]!.mvarId! :: pending\n        synthesizePending pending\n      else\n        return false\n\n  synthesizeSomeUsingDefault? (mvarIds : List MVarId) : TermElabM (Option (List MVarId)) := do\n    match mvarIds with\n    | [] => return none\n    | mvarId :: mvarIds =>\n      if (\u2190 synthesizeUsingDefault mvarId) then\n        return mvarIds\n      else if let some mvarIds' \u2190 synthesizeSomeUsingDefault? mvarIds then\n        return mvarId :: mvarIds'\n      else\n        return none\n\n  synthesizePending (mvarIds : List MVarId) : TermElabM Bool := do\n    let mvarIds \u2190 synthesizeUsingInstances mvarIds\n    if mvarIds.isEmpty then return true\n    let some mvarIds \u2190 synthesizeSomeUsingDefault? mvarIds | return false\n    synthesizePending mvarIds", "start": [69, 1], "end": [172, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeSomeUsingDefaultPrio", "code": "private def synthesizeSomeUsingDefaultPrio (prio : Nat) : TermElabM Bool := do\n  let rec visit (pendingMVars : List MVarId) (pendingMVarsNew : List MVarId) : TermElabM Bool := do\n    match pendingMVars with\n    | [] => return false\n    | mvarId :: pendingMVars =>\n      let some mvarDecl \u2190 getSyntheticMVarDecl? mvarId | visit pendingMVars (mvarId :: pendingMVarsNew)\n      match mvarDecl.kind with\n      | .typeClass =>\n        if (\u2190 withRef mvarDecl.stx <| synthesizeUsingDefaultPrio mvarId prio) then\n          modify fun s => { s with pendingMVars := pendingMVars.reverse ++ pendingMVarsNew }\n          return true\n        else\n          visit pendingMVars (mvarId :: pendingMVarsNew)\n      | _ => visit pendingMVars (mvarId :: pendingMVarsNew)\n  \n  visit (\u2190 get).pendingMVars.reverse []", "start": [174, 1], "end": [192, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeUsingDefault", "code": "private def synthesizeUsingDefault : TermElabM Bool := do\n  let prioSet \u2190 getDefaultInstancesPriorities\n  \n  for prio in prioSet do\n    if (\u2190 synthesizeSomeUsingDefaultPrio prio) then\n      return true\n  return false", "start": [194, 1], "end": [203, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.reportStuckSyntheticMVar", "code": "def reportStuckSyntheticMVar (mvarId : MVarId) (ignoreStuckTC := false) : TermElabM Unit := do\n  let some mvarSyntheticDecl \u2190 getSyntheticMVarDecl? mvarId | return ()\n  withRef mvarSyntheticDecl.stx do\n    match mvarSyntheticDecl.kind with\n    | .typeClass =>\n      unless ignoreStuckTC do\n         mvarId.withContext do\n          let mvarDecl \u2190 getMVarDecl mvarId\n          unless (\u2190 MonadLog.hasErrors) do\n            throwError \"typeclass instance problem is stuck, it is often due to metavariables{indentExpr mvarDecl.type}\"\n    | .coe header expectedType e f? =>\n      mvarId.withContext do\n        throwTypeMismatchError header expectedType (\u2190 inferType e) e f?\n          m!\"failed to create type class instance for{indentExpr (\u2190 getMVarDecl mvarId).type}\"\n    | _ => unreachable!", "start": [205, 1], "end": [223, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.reportStuckSyntheticMVars", "code": "private def reportStuckSyntheticMVars (ignoreStuckTC := false) : TermElabM Unit := do\n  let pendingMVars \u2190 modifyGet fun s => (s.pendingMVars, { s with pendingMVars := [] })\n  for mvarId in pendingMVars do\n    reportStuckSyntheticMVar mvarId ignoreStuckTC", "start": [225, 1], "end": [232, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getSomeSynthethicMVarsRef", "code": "private def getSomeSynthethicMVarsRef : TermElabM Syntax := do\n  for mvarId in (\u2190 get).pendingMVars do\n    if let some decl \u2190 getSyntheticMVarDecl? mvarId then\n      if decl.stx.getPos?.isSome then\n        return decl.stx\n  return .missing", "start": [234, 1], "end": [239, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.throwStuckAtUniverseCnstr", "code": "private def throwStuckAtUniverseCnstr : TermElabM Unit := do\n  let entries \u2190 getPostponed\n  let mut found : HashSet (Level \u00d7 Level) := {}\n  let mut uniqueEntries := #[]\n  for entry in entries do\n    let mut lhs := entry.lhs\n    let mut rhs := entry.rhs\n    if Level.normLt rhs lhs then\n      (lhs, rhs) := (rhs, lhs)\n    unless found.contains (lhs, rhs) do\n      found := found.insert (lhs, rhs)\n      uniqueEntries := uniqueEntries.push entry\n  for i in [1:uniqueEntries.size] do\n    logErrorAt uniqueEntries[i]!.ref (\u2190 mkLevelStuckErrorMessage uniqueEntries[i]!)\n  throwErrorAt uniqueEntries[0]!.ref (\u2190 mkLevelStuckErrorMessage uniqueEntries[0]!)", "start": [241, 1], "end": [259, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.processPostponedUniverseContraints", "code": "private def processPostponedUniverseContraints : TermElabM Unit := do\n  unless (\u2190 processPostponed (mayPostpone := false) (exceptionOnFailure := true)) do\n    throwStuckAtUniverseCnstr", "start": [261, 1], "end": [281, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.markAsResolved", "code": "private def markAsResolved (mvarId : MVarId) : TermElabM Unit :=\n  modify fun s => { s with syntheticMVars := s.syntheticMVars.erase mvarId }", "start": [283, 1], "end": [288, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.runTactic", "code": "partial def runTactic (mvarId : MVarId) (tacticCode : Syntax) : TermElabM Unit := withoutAutoBoundImplicit do\n    \n    let code := tacticCode[1]\n    instantiateMVarDeclMVars mvarId\n    \n    try\n      let remainingGoals \u2190 withInfoHole mvarId <| Tactic.run mvarId do\n        withTacticInfoContext tacticCode do\n          withTacticInfoContext tacticCode[0] do\n            evalTactic code\n        synthesizeSyntheticMVars (mayPostpone := false)\n      unless remainingGoals.isEmpty do\n        reportUnsolvedGoals remainingGoals\n    catch ex =>\n      if (\u2190 read).errToSorry then\n        for mvarId in (\u2190 getMVars (mkMVar mvarId)) do\n          mvarId.admit\n        logException ex\n      else\n        throw ex", "start": [292, 3], "end": [329, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeSyntheticMVar", "code": "private partial def synthesizeSyntheticMVar (mvarId : MVarId) (postponeOnError : Bool) (runTactics : Bool) : TermElabM Bool := do\n    let some mvarSyntheticDecl \u2190 getSyntheticMVarDecl? mvarId | return true withRef mvarSyntheticDecl.stx do\n    match mvarSyntheticDecl.kind with\n    | .typeClass => synthesizePendingInstMVar mvarId\n    | .coe _header? expectedType e _f? => mvarId.withContext do\n      if (\u2190 withDefault do isDefEq (\u2190 inferType e) expectedType) then\n        if (\u2190 occursCheck mvarId e) then\n          mvarId.assign e\n          return true\n      if let .some coerced \u2190 coerce? e expectedType then\n        if (\u2190 occursCheck mvarId coerced) then\n          mvarId.assign coerced\n          return true\n      return false\n    | .postponed savedContext => resumePostponed savedContext mvarSyntheticDecl.stx mvarId postponeOnError\n    | .tactic tacticCode savedContext =>\n      withSavedContext savedContext do\n        if runTactics then\n          runTactic mvarId tacticCode\n          return true\n        else\n          return false", "start": [331, 3], "end": [357, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeSyntheticMVarsStep", "code": "private partial def synthesizeSyntheticMVarsStep (postponeOnError : Bool) (runTactics : Bool) : TermElabM Bool := do\n    let ctx \u2190 read\n    traceAtCmdPos `Elab.resuming fun _ =>\n      m!\"resuming synthetic metavariables, mayPostpone: {ctx.mayPostpone}, postponeOnError: {postponeOnError}\"\n    let pendingMVars    := (\u2190 get).pendingMVars\n    let numSyntheticMVars := pendingMVars.length\n    modify fun s => { s with pendingMVars := [] }\n    let remainingPendingMVars \u2190 pendingMVars.filterRevM fun mvarId => do\n       traceM `Elab.postpone (mvarId.withContext do addMessageContext m!\"resuming {mkMVar mvarId}\")\n       let succeeded \u2190 synthesizeSyntheticMVar mvarId postponeOnError runTactics\n       if succeeded then markAsResolved mvarId\n       trace[Elab.postpone] if succeeded then format \"succeeded\" else format \"not ready yet\"\n       pure !succeeded\n    modify fun s => { s with pendingMVars := s.pendingMVars ++ remainingPendingMVars }\n    return numSyntheticMVars != remainingPendingMVars.length", "start": [358, 3], "end": [381, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeSyntheticMVars", "code": "partial def synthesizeSyntheticMVars (mayPostpone := true) (ignoreStuckTC := false) : TermElabM Unit := do\n    let rec loop (_ : Unit) : TermElabM Unit := do\n      withRef (\u2190 getSomeSynthethicMVarsRef) <| withIncRecDepth do\n        unless (\u2190 get).pendingMVars.isEmpty do\n          if \u2190 synthesizeSyntheticMVarsStep (postponeOnError := false) (runTactics := false) then\n            loop ()\n          else if !mayPostpone then\n            \n            if \u2190 withoutPostponing <| synthesizeSyntheticMVarsStep (postponeOnError := true) (runTactics := false) then\n              loop ()\n            else if \u2190 synthesizeUsingDefault then\n              loop ()\n            else if \u2190 withoutPostponing <| synthesizeSyntheticMVarsStep (postponeOnError := false) (runTactics := false) then\n              loop ()\n            else if \u2190 synthesizeSyntheticMVarsStep (postponeOnError := false) (runTactics := true) then\n              loop ()\n            else\n              reportStuckSyntheticMVars ignoreStuckTC\n    loop ()\n    unless mayPostpone do\n     processPostponedUniverseContraints", "start": [383, 3], "end": [431, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing", "code": "def synthesizeSyntheticMVarsNoPostponing (ignoreStuckTC := false) : TermElabM Unit :=\n  synthesizeSyntheticMVars (mayPostpone := false) (ignoreStuckTC := ignoreStuckTC)", "start": [434, 1], "end": [435, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeUsingDefaultLoop", "code": "private partial def synthesizeUsingDefaultLoop : TermElabM Unit := do\n  if (\u2190 synthesizeUsingDefault) then\n    synthesizeSyntheticMVars (mayPostpone := true)\n    synthesizeUsingDefaultLoop", "start": [437, 1], "end": [441, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault", "code": "def synthesizeSyntheticMVarsUsingDefault : TermElabM Unit := do\n  synthesizeSyntheticMVars (mayPostpone := true)\n  synthesizeUsingDefaultLoop", "start": [443, 1], "end": [445, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withSynthesizeImp", "code": "private partial def withSynthesizeImp {\u03b1} (k : TermElabM \u03b1) (mayPostpone : Bool) (synthesizeDefault : Bool) : TermElabM \u03b1 := do\n  let pendingMVarsSaved := (\u2190 get).pendingMVars\n  modify fun s => { s with pendingMVars := [] }\n  try\n    let a \u2190 k\n    synthesizeSyntheticMVars mayPostpone\n    if mayPostpone && synthesizeDefault then\n      synthesizeUsingDefaultLoop\n    return a\n  finally\n    modify fun s => { s with pendingMVars := s.pendingMVars ++ pendingMVarsSaved }", "start": [447, 1], "end": [457, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withSynthesize", "code": "@[inline] def withSynthesize [MonadFunctorT TermElabM m] [Monad m] (k : m \u03b1) (mayPostpone := false) : m \u03b1 :=\n  monadMap (m := TermElabM) (withSynthesizeImp \u00b7 mayPostpone (synthesizeDefault := true)) k", "start": [459, 1], "end": [464, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withSynthesizeLight", "code": "@[inline] def withSynthesizeLight [MonadFunctorT TermElabM m] [Monad m] (k : m \u03b1) : m \u03b1 :=\n  monadMap (m := TermElabM) (withSynthesizeImp \u00b7 (mayPostpone := true) (synthesizeDefault := false)) k", "start": [466, 1], "end": [468, 103], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabTermAndSynthesize", "code": "def elabTermAndSynthesize (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr :=\n  withRef stx do\n    instantiateMVars (\u2190 withSynthesize <| elabTerm stx expectedType?)", "start": [470, 1], "end": [473, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.runPendingTacticsAt", "code": "def runPendingTacticsAt (e : Expr) : TermElabM Unit := do\n  for mvarId in (\u2190 getMVars e) do\n    let mvarId \u2190 getDelayedMVarRoot mvarId\n    if let some { kind := .tactic tacticCode savedContext, .. } \u2190 getSyntheticMVarDecl? mvarId then\n      withSavedContext savedContext do\n        runTactic mvarId tacticCode\n        markAsResolved mvarId", "start": [475, 1], "end": [486, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Binders.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Lean/Elab/Quotation/Precheck.lean", "lake-packages/lean4/src/lean/Lean/Elab/BindersUtil.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.expandBinderType", "code": "private def expandBinderType (ref : Syntax) (stx : Syntax) : Syntax :=\n  if stx.getNumArgs == 0 then\n    mkHole ref\n  else\n    stx[1]", "start": [15, 1], "end": [24, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandBinderIdent", "code": "private def expandBinderIdent (stx : Syntax) : TermElabM Syntax :=\n  match stx with\n  | `(_) => mkFreshIdent stx (canonical := true)\n  | _    => pure stx", "start": [26, 1], "end": [30, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandOptIdent", "code": "private def expandOptIdent (stx : Syntax) : TermElabM Syntax := do\n  if stx.isNone then\n    let id \u2190 withFreshMacroScope <| MonadQuotation.addMacroScope `inst\n    return mkIdentFrom stx id\n  else\n    return stx[0]", "start": [32, 1], "end": [38, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.BinderView", "code": "structure BinderView where\n  \n  ref  : Syntax\n  id   : Syntax\n  type : Syntax\n  bi   : BinderInfo", "start": [40, 1], "end": [58, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.kindOfBinderName", "code": "def kindOfBinderName (binderName : Name) : LocalDeclKind :=\n  if binderName.isImplementationDetail then\n    .implDetail\n  else\n    .default", "start": [60, 1], "end": [69, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.quoteAutoTactic", "code": "partial def quoteAutoTactic : Syntax \u2192 TermElabM Syntax\n  | stx@(.ident ..) => throwErrorAt stx \"invalid auto tactic, identifier is not allowed\"\n  | stx@(.node _ k args) => do\n    if stx.isAntiquot then\n      throwErrorAt stx \"invalid auto tactic, antiquotation is not allowed\"\n    else\n      let mut quotedArgs \u2190 `(Array.empty)\n      for arg in args do\n        if k == nullKind && (arg.isAntiquotSuffixSplice || arg.isAntiquotSplice) then\n          throwErrorAt arg \"invalid auto tactic, antiquotation is not allowed\"\n        else\n          let quotedArg \u2190 quoteAutoTactic arg\n          quotedArgs \u2190 `(Array.push $quotedArgs $quotedArg)\n      `(Syntax.node SourceInfo.none $(quote k) $quotedArgs)\n  | .atom _ val => `(mkAtom $(quote val))\n  | .missing    => throwError \"invalid auto tactic, tactic is missing\"", "start": [71, 1], "end": [86, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.declareTacticSyntax", "code": "def declareTacticSyntax (tactic : Syntax) : TermElabM Name :=\n  withFreshMacroScope do\n    let name \u2190 MonadQuotation.addMacroScope `_auto\n    let type := Lean.mkConst `Lean.Syntax\n    let tactic \u2190 quoteAutoTactic tactic\n    let value \u2190 elabTerm tactic type\n    let value \u2190 instantiateMVars value\n    trace[Elab.autoParam] value\n    let decl := Declaration.defnDecl { name, levelParams := [], type, value, hints := .opaque,\n                                       safety := DefinitionSafety.safe }\n    addDecl decl\n    compileDecl decl\n    return name", "start": [88, 1], "end": [100, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandBinderModifier", "code": "private def expandBinderModifier (type : Syntax) (optBinderModifier : Syntax) : TermElabM Syntax := do\n  if optBinderModifier.isNone then\n    return type\n  else\n    let modifier := optBinderModifier[0]\n    let kind     := modifier.getKind\n    if kind == `Lean.Parser.Term.binderDefault then\n      let defaultVal := modifier[1]\n      `(optParam $type $defaultVal)\n    else if kind == `Lean.Parser.Term.binderTactic then\n      let tac := modifier[2]\n      let name \u2190 declareTacticSyntax tac\n      `(autoParam $type $(mkIdentFrom tac name))\n    else\n      throwUnsupportedSyntax", "start": [102, 1], "end": [123, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getBinderIds", "code": "private def getBinderIds (ids : Syntax) : TermElabM (Array Syntax) :=\n  ids.getArgs.mapM fun id =>\n    let k := id.getKind\n    if k == identKind || k == `Lean.Parser.Term.hole then\n      return id\n    else\n      throwErrorAt id \"identifier or `_` expected\"", "start": [125, 1], "end": [131, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.toBinderViews", "code": "private def toBinderViews (stx : Syntax) : TermElabM (Array BinderView) := do\n  let k := stx.getKind\n  if stx.isIdent || k == ``hole then\n    return #[{ ref := stx, id := (\u2190 expandBinderIdent stx), type := mkHole stx, bi := .default }]\n  else if k == ``Lean.Parser.Term.explicitBinder then\n    let ids \u2190 getBinderIds stx[1]\n    let type        := stx[2]\n    let optModifier := stx[3]\n    ids.mapM fun id => do pure { ref := id, id := (\u2190 expandBinderIdent id), type := (\u2190 expandBinderModifier (expandBinderType id type) optModifier), bi := .default }\n  else if k == ``Lean.Parser.Term.implicitBinder then\n    let ids \u2190 getBinderIds stx[1]\n    let type := stx[2]\n    ids.mapM fun id => do pure { ref := id, id := (\u2190 expandBinderIdent id), type := expandBinderType id type, bi := .implicit }\n  else if k == ``Lean.Parser.Term.strictImplicitBinder then\n    let ids \u2190 getBinderIds stx[1]\n    let type := stx[2]\n    ids.mapM fun id => do pure { ref := id, id := (\u2190 expandBinderIdent id), type := expandBinderType id type, bi := .strictImplicit }\n  else if k == ``Lean.Parser.Term.instBinder then\n    let id \u2190 expandOptIdent stx[1]\n    let type := stx[2]\n    return #[ { ref := id, id := id, type := type, bi := .instImplicit } ]\n  else\n    throwUnsupportedSyntax", "start": [133, 1], "end": [164, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.registerFailedToInferBinderTypeInfo", "code": "private def registerFailedToInferBinderTypeInfo (type : Expr) (ref : Syntax) : TermElabM Unit :=\n  registerCustomErrorIfMVar type ref \"failed to infer binder type\"", "start": [166, 1], "end": [167, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addLocalVarInfo", "code": "def addLocalVarInfo (stx : Syntax) (fvar : Expr) : TermElabM Unit :=\n  addTermInfo' (isBinder := true) stx fvar", "start": [169, 1], "end": [170, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ensureAtomicBinderName", "code": "private def ensureAtomicBinderName (binderView : BinderView) : TermElabM Unit :=\n  let n := binderView.id.getId.eraseMacroScopes\n  unless n.isAtomic do\n    throwErrorAt binderView.id \"invalid binder name '{n}', it must be atomic\"", "start": [172, 1], "end": [175, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.checkLocalInstanceParameters", "code": "private partial def checkLocalInstanceParameters (type : Expr) : TermElabM Unit := do\n  let .forallE n d b bi \u2190 whnf type | return ()\n  if bi != .instImplicit && !b.hasLooseBVar 0 then\n    throwError \"invalid parametric local instance, parameter with type{indentExpr d}\\ndoes not have forward dependencies, type class resolution cannot use this kind of local instance because it will not be able to infer a value for this parameter.\"\n  withLocalDecl n bi d fun x => checkLocalInstanceParameters (b.instantiate1 x)", "start": [182, 1], "end": [190, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabBinderViews", "code": "private partial def elabBinderViews (binderViews : Array BinderView) (fvars : Array (Syntax \u00d7 Expr)) (k : Array (Syntax \u00d7 Expr) \u2192 TermElabM \u03b1)\n    : TermElabM \u03b1 :=\n  let rec loop (i : Nat) (fvars : Array (Syntax \u00d7 Expr)) : TermElabM \u03b1 := do\n    if h : i < binderViews.size then\n      let binderView := binderViews[i]\n      ensureAtomicBinderName binderView\n      let type \u2190 elabType binderView.type\n      registerFailedToInferBinderTypeInfo type binderView.type\n      if binderView.bi.isInstImplicit && checkBinderAnnotations.get (\u2190 getOptions) then\n        unless (\u2190 isClass? type).isSome do\n          throwErrorAt binderView.type \"invalid binder annotation, type is not a class instance{indentExpr type}\\nuse the command `set_option checkBinderAnnotations false` to disable the check\"\n        withRef binderView.type <| checkLocalInstanceParameters type\n      let id := binderView.id.getId\n      let kind := kindOfBinderName id\n      withLocalDecl id binderView.bi type (kind := kind) fun fvar => do\n        addLocalVarInfo binderView.ref fvar\n        loop (i+1) (fvars.push (binderView.id, fvar))\n    else\n      k fvars\n  loop 0 fvars", "start": [192, 1], "end": [211, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabBindersAux", "code": "private partial def elabBindersAux (binders : Array Syntax) (k : Array (Syntax \u00d7 Expr) \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  let rec loop (i : Nat) (fvars : Array (Syntax \u00d7 Expr)) : TermElabM \u03b1 := do\n    if h : i < binders.size then\n      let binderViews \u2190 toBinderViews binders[i]\n      elabBinderViews binderViews fvars <| loop (i+1)\n    else\n      k fvars\n  loop 0 #[]", "start": [213, 1], "end": [220, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabBindersEx", "code": "def elabBindersEx (binders : Array Syntax) (k : Array (Syntax \u00d7 Expr) \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  universeConstraintsCheckpoint do\n    if binders.isEmpty then\n      k #[]\n    else\n      elabBindersAux binders k", "start": [222, 1], "end": [232, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabBinders", "code": "def elabBinders (binders : Array Syntax) (k : Array Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  elabBindersEx binders (fun fvars => k (fvars.map (\u00b7.2)))", "start": [234, 1], "end": [244, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabBinder", "code": "def elabBinder (binder : Syntax) (x : Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  elabBinders #[binder] fun fvars => x fvars[0]!", "start": [246, 1], "end": [248, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandSimpleBinderWithType", "code": "def expandSimpleBinderWithType (type : Term) (binder : Syntax) : MacroM Syntax :=\n  if binder.isOfKind ``hole || binder.isIdent then\n    `(bracketedBinderF| ($binder : $type))\n  else\n    Macro.throwErrorAt type \"unexpected type ascription\"", "start": [250, 1], "end": [255, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandForall", "code": "@[builtin_macro Lean.Parser.Term.forall] def expandForall : Macro\n  | `(forall $binders* : $ty, $term) => do\n    let binders \u2190 binders.mapM (expandSimpleBinderWithType ty)\n    `(forall $binders*, $term)\n  | _ => Macro.throwUnsupported", "start": [257, 1], "end": [261, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabForall", "code": "@[builtin_term_elab \u00abforall\u00bb] def elabForall : TermElab := fun stx _ =>\n  match stx with\n  | `(forall $binders*, $term) =>\n    elabBinders binders fun xs => do\n      let e \u2190 elabType term\n      mkForallFVars xs e\n  | _ => throwUnsupportedSyntax", "start": [263, 1], "end": [269, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.precheckArrow", "code": "@[builtin_quot_precheck Lean.Parser.Term.arrow] def precheckArrow : Precheck\n  | `($dom:term -> $rng) => do\n    precheck dom\n    precheck rng\n  | _ => throwUnsupportedSyntax", "start": [272, 1], "end": [276, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabArrow", "code": "@[builtin_term_elab arrow] def elabArrow : TermElab := fun stx _ =>\n  match stx with\n  | `($dom:term -> $rng) => do\n    let dom \u2190 elabType dom\n    let rng \u2190 elabType rng\n    return mkForall (\u2190 MonadQuotation.addMacroScope `a) BinderInfo.default dom rng\n  | _                    => throwUnsupportedSyntax", "start": [278, 1], "end": [285, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabDepArrow", "code": "@[builtin_term_elab depArrow] def elabDepArrow : TermElab := fun stx _ =>\n  let binder := stx[0]\n  let term   := stx[2]\n  elabBinders #[binder] fun xs => do\n    mkForallFVars xs (\u2190 elabType term)", "start": [287, 1], "end": [296, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getFunBinderIds?", "code": "private partial def getFunBinderIds? (stx : Syntax) : OptionT MacroM (Array Syntax) :=\n  let convertElem (stx : Term) : OptionT MacroM Syntax :=\n    match stx with\n    | `(_) =>\n      \n      return stx\n    | `($_:ident) => return stx\n    | _ => failure\n  match stx with\n  | `($f $args*) => do\n     let mut acc := #[].push (\u2190 convertElem f)\n     for arg in args do\n       acc := acc.push (\u2190 convertElem arg)\n     return acc\n  | _ =>\n    return #[].push (\u2190 convertElem stx)", "start": [298, 1], "end": [322, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandFunBinders", "code": "partial def expandFunBinders (binders : Array Syntax) (body : Syntax) : MacroM (Array Syntax \u00d7 Syntax \u00d7 Bool) :=\n  let rec loop (body : Syntax) (i : Nat) (newBinders : Array Syntax) := do\n    if h : i < binders.size then\n      let binder := binders[i]\n      let processAsPattern : Unit \u2192 MacroM (Array Syntax \u00d7 Syntax \u00d7 Bool) := fun _ => do\n        let pattern := binder\n        let major \u2190 mkFreshIdent binder\n        let (binders, newBody, _) \u2190 loop body (i+1) (newBinders.push $ mkExplicitBinder major (mkHole binder))\n        let newBody \u2190 `(match $major:ident with | $pattern => $newBody)\n        pure (binders, newBody, true)\n      match binder.getKind with\n      | ``Lean.Parser.Term.implicitBinder\n      | ``Lean.Parser.Term.strictImplicitBinder\n      | ``Lean.Parser.Term.instBinder\n      | ``Lean.Parser.Term.explicitBinder\n      | ``Lean.Parser.Term.hole | `ident => loop body (i+1) (newBinders.push binder)\n      | ``Lean.Parser.Term.paren =>\n        let term := binder[1]\n        match (\u2190 getFunBinderIds? term) with\n        | some idents =>\n          if (\u2190 idents.allM fun ident => return List.isEmpty (\u2190 Macro.resolveGlobalName ident.getId)) then\n            loop body (i+1) (newBinders ++ idents.map (mkExplicitBinder \u00b7 (mkHole binder)))\n          else\n            processAsPattern ()\n        | none => processAsPattern ()\n      | ``Lean.Parser.Term.typeAscription =>\n        let term := binder[1]\n        let type := binder[3].getOptional?.getD (mkHole binder)\n        match (\u2190 getFunBinderIds? term) with\n        | some idents => loop body (i+1) (newBinders ++ idents.map (fun ident => mkExplicitBinder ident type))\n        | none        => processAsPattern ()\n      | _ => processAsPattern ()\n    else\n      pure (newBinders, body, false)\n  loop body 0 #[]", "start": [324, 1], "end": [381, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.FunBinders.State", "code": "structure State where\n  fvars         : Array Expr := #[]\n  lctx          : LocalContext\n  localInsts    : LocalInstances\n  expectedType? : Option Expr := none", "start": [385, 1], "end": [389, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.FunBinders.propagateExpectedType", "code": "private def propagateExpectedType (fvar : Expr) (fvarType : Expr) (s : State) : TermElabM State := do\n  match s.expectedType? with\n  | none              => pure s\n  | some expectedType =>\n    let expectedType \u2190 whnfForall expectedType\n    match expectedType with\n    | .forallE _ d b _ =>\n      discard <| isDefEq fvarType d\n      let b := b.instantiate1 fvar\n      return { s with expectedType? := some b }\n    | _ =>\n      return { s with expectedType? := none }", "start": [391, 1], "end": [402, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.FunBinders.elabFunBinderViews", "code": "private partial def elabFunBinderViews (binderViews : Array BinderView) (i : Nat) (s : State) : TermElabM State := do\n  if h : i < binderViews.size then\n    let binderView := binderViews[i]\n    ensureAtomicBinderName binderView\n    withRef binderView.type <| withLCtx s.lctx s.localInsts do\n      let type \u2190 elabType binderView.type\n      registerFailedToInferBinderTypeInfo type binderView.type\n      let fvarId \u2190 mkFreshFVarId\n      let fvar  := mkFVar fvarId\n      let s     := { s with fvars := s.fvars.push fvar }\n      let id    := binderView.id.getId\n      let kind  := kindOfBinderName id\n      \n      let lctx  := s.lctx.mkLocalDecl fvarId id type binderView.bi kind\n      addTermInfo' (lctx? := some lctx) (isBinder := true) binderView.ref fvar\n      let s \u2190 withRef binderView.id <| propagateExpectedType fvar type s\n      let s := { s with lctx }\n      match \u2190 isClass? type, kind with\n      | some className, .default =>\n        let localInsts := s.localInsts.push { className, fvar := mkFVar fvarId }\n        elabFunBinderViews binderViews (i+1) { s with localInsts }\n      | _, _ => elabFunBinderViews binderViews (i+1) s\n  else\n    pure s", "start": [404, 1], "end": [431, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.FunBinders.elabFunBindersAux", "code": "partial def elabFunBindersAux (binders : Array Syntax) (i : Nat) (s : State) : TermElabM State := do\n  if h : i < binders.size then\n    let binderViews \u2190 toBinderViews binders[i]\n    let s \u2190 elabFunBinderViews binderViews 0 s\n    elabFunBindersAux binders (i+1) s\n  else\n    pure s", "start": [433, 1], "end": [439, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabFunBinders", "code": "def elabFunBinders (binders : Array Syntax) (expectedType? : Option Expr) (x : Array Expr \u2192 Option Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  if binders.isEmpty then\n    x #[] expectedType?\n  else do\n    let lctx \u2190 getLCtx\n    let localInsts \u2190 getLocalInstances\n    let s \u2190 FunBinders.elabFunBindersAux binders 0 { lctx, localInsts, expectedType? }\n    withLCtx s.lctx s.localInsts do\n      x s.fvars s.expectedType?", "start": [443, 1], "end": [451, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandWhereDecls", "code": "def expandWhereDecls (whereDecls : Syntax) (body : Syntax) : MacroM Syntax :=\n  match whereDecls with\n  | `(whereDecls|where $[$decls:letRecDecl];*) => `(let rec $decls:letRecDecl,*; $body)\n  | _ => Macro.throwUnsupported", "start": [453, 1], "end": [456, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandWhereDeclsOpt", "code": "def expandWhereDeclsOpt (whereDeclsOpt : Syntax) (body : Syntax) : MacroM Syntax :=\n  if whereDeclsOpt.isNone then\n    return body\n  else\n    expandWhereDecls whereDeclsOpt[0] body", "start": [458, 1], "end": [462, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandMatchAltsIntoMatchAux", "code": "private def expandMatchAltsIntoMatchAux (matchAlts : Syntax) (isTactic : Bool) (useExplicit : Bool) : Nat \u2192 Array Syntax \u2192 Array Ident \u2192 MacroM Syntax\n  | 0,   discrs, xs => do\n    if isTactic then\n      `(tactic|match $[$discrs:term],* with $matchAlts:matchAlts)\n    else\n      let stx \u2190 `(match $[$discrs:term],* with $matchAlts:matchAlts)\n      clearInMatch stx xs\n  | n+1, discrs, xs => withFreshMacroScope do\n    let x \u2190 `(x) let d \u2190 `(@$x:ident)\n    let body \u2190 expandMatchAltsIntoMatchAux matchAlts isTactic useExplicit n (discrs.push d) (xs.push x)\n    if isTactic then\n      `(tactic| intro $x:term; $body:tactic)\n    else if useExplicit then\n      `(@fun $x => $body)\n    else\n      `(fun $x => $body)", "start": [464, 1], "end": [483, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandMatchAltsIntoMatch", "code": "def expandMatchAltsIntoMatch (ref : Syntax) (matchAlts : Syntax) (useExplicit := true) : MacroM Syntax :=\n  withRef ref <| expandMatchAltsIntoMatchAux matchAlts (isTactic := false) (useExplicit := useExplicit) (getMatchAltsNumPatterns matchAlts) #[] #[]", "start": [485, 1], "end": [538, 148], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandMatchAltsIntoMatchTactic", "code": "def expandMatchAltsIntoMatchTactic (ref : Syntax) (matchAlts : Syntax) : MacroM Syntax :=\n  withRef ref <| expandMatchAltsIntoMatchAux matchAlts (isTactic := true) (useExplicit := false) (getMatchAltsNumPatterns matchAlts) #[] #[]", "start": [540, 1], "end": [541, 141], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandMatchAltsWhereDecls", "code": "def expandMatchAltsWhereDecls (matchAltsWhereDecls : Syntax) : MacroM Syntax :=\n  let matchAlts     := matchAltsWhereDecls[0]\n  let whereDeclsOpt := matchAltsWhereDecls[1]\n  let rec loop (i : Nat) (discrs : Array Syntax) : MacroM Syntax :=\n    match i with\n    | 0   => do\n      let matchStx \u2190 `(match $[@$discrs:term],* with $matchAlts:matchAlts)\n      let matchStx \u2190 clearInMatch matchStx discrs\n      if whereDeclsOpt.isNone then\n        return matchStx\n      else\n        expandWhereDeclsOpt whereDeclsOpt matchStx\n    | n+1 => withFreshMacroScope do\n      let body \u2190 loop n (discrs.push (\u2190 `(x)))\n      `(@fun x => $body)\n  loop (getMatchAltsNumPatterns matchAlts) #[]", "start": [543, 1], "end": [586, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandFun", "code": "@[builtin_macro Parser.Term.fun] partial def expandFun : Macro\n  | `(fun $binders* : $ty => $body) => do\n    let binders \u2190 binders.mapM (expandSimpleBinderWithType ty)\n    `(fun $binders* => $body)\n  | `(fun $binders* => $body) => do  let (binders, body, expandedPattern) \u2190 expandFunBinders binders body\n    if expandedPattern then\n      `(fun $binders* => $body)\n    else\n      Macro.throwUnsupported\n  | stx@`(fun $m:matchAlts) => expandMatchAltsIntoMatch stx m (useExplicit := false)\n  | _ => Macro.throwUnsupported", "start": [588, 1], "end": [599, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandExplicitFun", "code": "@[builtin_macro Parser.Term.explicit] partial def expandExplicitFun : Macro := fun stx =>\n  match stx with\n  | `(@fun $m:matchAlts) => expandMatchAltsIntoMatch stx[1] m (useExplicit := true)\n  | _ => Macro.throwUnsupported", "start": [601, 1], "end": [604, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.precheckFun", "code": "@[builtin_quot_precheck Lean.Parser.Term.fun] def precheckFun : Precheck\n  | `(fun $binders* $[: $ty?]? => $body) => do\n    let (binders, body, _) \u2190 liftMacroM <| expandFunBinders binders body\n    let mut ids := #[]\n    for b in binders do\n      for v in \u2190 toBinderViews b do\n        Quotation.withNewLocals ids <| precheck v.type\n        ids := ids.push v.id.getId\n    Quotation.withNewLocals ids <| precheck body\n  | _ => throwUnsupportedSyntax", "start": [607, 1], "end": [616, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabFun", "code": "@[builtin_term_elab \u00abfun\u00bb] partial def elabFun : TermElab := fun stx expectedType? =>\n  match stx with\n  | `(fun $binders* => $body) => do\n    let (binders, body, _) \u2190 liftMacroM <| expandFunBinders binders body\n    elabFunBinders binders expectedType? fun xs expectedType? => do\n      \n      let e \u2190 elabTermEnsuringType body expectedType?\n      mkLambdaFVars xs e\n  | _ => throwUnsupportedSyntax", "start": [618, 1], "end": [631, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLetDeclAux", "code": "def elabLetDeclAux (id : Syntax) (binders : Array Syntax) (typeStx : Syntax) (valStx : Syntax) (body : Syntax)\n    (expectedType? : Option Expr) (useLetExpr : Bool) (elabBodyFirst : Bool) (usedLetOnly : Bool) : TermElabM Expr := do\n  let (type, val, binders) \u2190 elabBindersEx binders fun xs => do\n    let (binders, fvars) := xs.unzip\n    let type \u2190 elabType typeStx\n    registerCustomErrorIfMVar type typeStx \"failed to infer 'let' declaration type\"\n    if elabBodyFirst then\n      let type \u2190 mkForallFVars fvars type\n      let val  \u2190 mkFreshExprMVar type\n      pure (type, val, binders)\n    else\n      let val  \u2190 elabTermEnsuringType valStx type\n      let type \u2190 mkForallFVars fvars type\n      \n      let val  \u2190 mkLambdaFVars fvars val (usedLetOnly := false)\n      pure (type, val, binders)\n  let kind := kindOfBinderName id.getId\n  trace[Elab.let.decl] \"{id.getId} : {type} := {val}\"\n  let result \u2190 if useLetExpr then\n    withLetDecl id.getId (kind := kind) type val fun x => do\n      addLocalVarInfo id x\n      let body \u2190 elabTermEnsuringType body expectedType?\n      let body \u2190 instantiateMVars body\n      mkLetFVars #[x] body (usedLetOnly := usedLetOnly)\n  else\n    let f \u2190 withLocalDecl id.getId (kind := kind) .default type fun x => do\n      addLocalVarInfo id x\n      let body \u2190 elabTermEnsuringType body expectedType?\n      let body \u2190 instantiateMVars body\n      mkLambdaFVars #[x] body (usedLetOnly := false)\n    pure <| mkLetFunAnnotation (mkApp f val)\n  if elabBodyFirst then\n    forallBoundedTelescope type binders.size fun xs type => do\n      for b in binders, x in xs do\n        addLocalVarInfo b x\n      let valResult \u2190 elabTermEnsuringType valStx type\n      let valResult \u2190 mkLambdaFVars xs valResult (usedLetOnly := false)\n      unless (\u2190 isDefEq val valResult) do\n        throwError \"unexpected error when elaborating 'let'\"\n  pure result", "start": [633, 1], "end": [686, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.LetIdDeclView", "code": "structure LetIdDeclView where\n  id      : Syntax\n  binders : Array Syntax\n  type    : Syntax\n  value   : Syntax", "start": [688, 1], "end": [692, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkLetIdDeclView", "code": "def mkLetIdDeclView (letIdDecl : Syntax) : LetIdDeclView :=\n  let id      := letIdDecl[0]\n  let binders := letIdDecl[1].getArgs\n  let optType := letIdDecl[2]\n  let type    := expandOptType id optType\n  let value   := letIdDecl[4]\n  { id, binders, type, value }", "start": [694, 1], "end": [701, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandLetEqnsDecl", "code": "def expandLetEqnsDecl (letDecl : Syntax) (useExplicit := true) : MacroM Syntax := do\n  let ref       := letDecl\n  let matchAlts := letDecl[3]\n  let val \u2190 expandMatchAltsIntoMatch ref matchAlts (useExplicit := useExplicit)\n  return mkNode `Lean.Parser.Term.letIdDecl #[letDecl[0], letDecl[1], letDecl[2], mkAtomFrom ref \" := \", val]", "start": [703, 1], "end": [707, 110], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLetDeclCore", "code": "def elabLetDeclCore (stx : Syntax) (expectedType? : Option Expr) (useLetExpr : Bool) (elabBodyFirst : Bool) (usedLetOnly : Bool) : TermElabM Expr := do\n  let letDecl := stx[1][0]\n  let body    := stx[3]\n  if letDecl.getKind == ``Lean.Parser.Term.letIdDecl then\n    let { id, binders, type, value } := mkLetIdDeclView letDecl\n    let id \u2190 if id.isIdent then pure id else mkFreshIdent id (canonical := true)\n    elabLetDeclAux id binders type value body expectedType? useLetExpr elabBodyFirst usedLetOnly\n  else if letDecl.getKind == ``Lean.Parser.Term.letPatDecl then\n    if elabBodyFirst then\n      throwError \"'let_delayed' with patterns is not allowed\"\n    let pat     := letDecl[0]\n    let optType := letDecl[2]\n    let val     := letDecl[4]\n    if pat.getKind == ``Parser.Term.hole then\n      let id   \u2190 mkFreshIdent pat (canonical := true)\n      let type := expandOptType id optType\n      elabLetDeclAux id #[] type val body expectedType? useLetExpr elabBodyFirst usedLetOnly\n    else\n      let stxNew \u2190 if optType.isNone then\n        `(match $val:term with | $pat => $body)\n      else\n        let type := optType[0][1]\n        `(match ($val:term : $type) with | $pat => $body)\n      withMacroExpansion stx stxNew <| elabTerm stxNew expectedType?\n  else if letDecl.getKind == ``Lean.Parser.Term.letEqnsDecl then\n    let letDeclIdNew \u2190 liftMacroM <| expandLetEqnsDecl letDecl\n    let declNew := stx[1].setArg 0 letDeclIdNew\n    let stxNew  := stx.setArg 1 declNew\n    withMacroExpansion stx stxNew <| elabTerm stxNew expectedType?\n  else\n    throwUnsupportedSyntax", "start": [709, 1], "end": [742, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLetDecl", "code": "@[builtin_term_elab \u00ablet\u00bb] def elabLetDecl : TermElab :=\n  fun stx expectedType? => elabLetDeclCore stx expectedType? (useLetExpr := true) (elabBodyFirst := false) (usedLetOnly := false)", "start": [744, 1], "end": [745, 130], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLetFunDecl", "code": "@[builtin_term_elab \u00ablet_fun\u00bb] def elabLetFunDecl : TermElab :=\n  fun stx expectedType? => elabLetDeclCore stx expectedType? (useLetExpr := false) (elabBodyFirst := false) (usedLetOnly := false)", "start": [747, 1], "end": [748, 131], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLetDelayedDecl", "code": "@[builtin_term_elab \u00ablet_delayed\u00bb] def elabLetDelayedDecl : TermElab :=\n  fun stx expectedType? => elabLetDeclCore stx expectedType? (useLetExpr := true) (elabBodyFirst := true) (usedLetOnly := false)", "start": [750, 1], "end": [751, 129], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLetTmpDecl", "code": "@[builtin_term_elab \u00ablet_tmp\u00bb] def elabLetTmpDecl : TermElab :=\n  fun stx expectedType? => elabLetDeclCore stx expectedType? (useLetExpr := true) (elabBodyFirst := false) (usedLetOnly := true)", "start": [753, 1], "end": [754, 129], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/Utils.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Extra.lean", "lake-packages/lean4/src/lean/Lean/Server/InfoUtils.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/TextSync.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Diagnostics.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Communication.lean"], "premises": [{"full_name": "IO.throwServerError", "code": "def throwServerError (err : String) : IO \u03b1 :=\n  throw (userError err)", "start": [15, 1], "end": [16, 24], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.chainRight", "code": "def chainRight (a : Stream) (b : Stream) (flushEagerly : Bool := false) : Stream :=\n  { a with\n    flush := a.flush *> b.flush\n    read := fun sz => do\n      let bs \u2190 a.read sz\n      b.write bs\n      if flushEagerly then b.flush\n      pure bs\n    getLine := do\n      let ln \u2190 a.getLine\n      b.putStr ln\n      if flushEagerly then b.flush\n      pure ln }", "start": [20, 1], "end": [38, 16], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.chainLeft", "code": "def chainLeft (a : Stream) (b : Stream) (flushEagerly : Bool := false) : Stream :=\n  { b with\n    flush := a.flush *> b.flush\n    write := fun bs => do\n      a.write bs\n      if flushEagerly then a.flush\n      b.write bs\n    putStr := fun s => do\n      a.putStr s\n      if flushEagerly then a.flush\n      b.putStr s }", "start": [40, 1], "end": [51, 19], "kind": "commanddeclaration"}, {"full_name": "IO.FS.Stream.withPrefix", "code": "def withPrefix (a : Stream) (pre : String) : Stream :=\n  { a with\n    write := fun bs => do\n      a.putStr pre\n      a.write bs\n    putStr := fun s =>\n      a.putStr (pre ++ s) }", "start": [53, 1], "end": [60, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.DocumentMeta", "code": "structure DocumentMeta where\n  uri                 : Lsp.DocumentUri\n  version             : Nat\n  text                : FileMap\n  dependencyBuildMode : Lsp.DependencyBuildMode\n  deriving Inhabited", "start": [67, 1], "end": [72, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.DocumentMeta.mkInputContext", "code": "def DocumentMeta.mkInputContext (doc : DocumentMeta) : Parser.InputContext where\n  input    := doc.text.source\n  fileName := (System.Uri.fileUriToPath? doc.uri).getD doc.uri |>.toString\n  fileMap  := doc.text", "start": [74, 1], "end": [77, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.replaceLspRange", "code": "def replaceLspRange (text : FileMap) (r : Lsp.Range) (newText : String) : FileMap :=\n  let start := text.lspPosToUtf8Pos r.start\n  let \u00abend\u00bb := text.lspPosToUtf8Pos r.\u00abend\u00bb\n  let pre := text.source.extract 0 start\n  let post := text.source.extract \u00abend\u00bb text.source.endPos\n  (pre ++ newText ++ post).toFileMap", "start": [79, 1], "end": [84, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.maybeTee", "code": "def maybeTee (fName : String) (isOut : Bool) (h : FS.Stream) : IO FS.Stream := do\n  match (\u2190 IO.getEnv \"LEAN_SERVER_LOG_DIR\") with\n  | none => pure h\n  | some logDir =>\n    IO.FS.createDirAll logDir\n    let hTee \u2190 FS.Handle.mk (System.mkFilePath [logDir, fName]) FS.Mode.write\n    let hTee := FS.Stream.ofHandle hTee\n    pure $ if isOut then\n      hTee.chainLeft h true\n    else\n      h.chainRight hTee true", "start": [88, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.applyDocumentChange", "code": "def applyDocumentChange (oldText : FileMap) : (change : Lsp.TextDocumentContentChangeEvent) \u2192 FileMap\n  | TextDocumentContentChangeEvent.rangeChange (range : Range) (newText : String) =>\n    replaceLspRange oldText range newText\n  | TextDocumentContentChangeEvent.fullChange (newText : String) =>\n    newText.toFileMap", "start": [104, 1], "end": [109, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.foldDocumentChanges", "code": "def foldDocumentChanges (changes : Array Lsp.TextDocumentContentChangeEvent) (oldText : FileMap) : FileMap :=\n  changes.foldl applyDocumentChange oldText", "start": [111, 1], "end": [113, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.publishDiagnostics", "code": "def publishDiagnostics (m : DocumentMeta) (diagnostics : Array Lsp.Diagnostic) (hOut : FS.Stream) : IO Unit :=\n  hOut.writeLspNotification {\n    method := \"textDocument/publishDiagnostics\"\n    param  := {\n      uri         := m.uri\n      version?    := m.version\n      diagnostics := diagnostics\n      : PublishDiagnosticsParams\n    }\n  }", "start": [115, 1], "end": [124, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.publishProgress", "code": "def publishProgress (m : DocumentMeta) (processing : Array LeanFileProgressProcessingInfo) (hOut : FS.Stream) : IO Unit :=\n  hOut.writeLspNotification {\n    method := \"$/lean/fileProgress\"\n    param := {\n      textDocument := { uri := m.uri, version? := m.version }\n      processing\n      : LeanFileProgressParams\n    }\n  }", "start": [126, 1], "end": [134, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.publishProgressAtPos", "code": "def publishProgressAtPos (m : DocumentMeta) (pos : String.Pos) (hOut : FS.Stream) (kind : LeanFileProgressKind := LeanFileProgressKind.processing) : IO Unit :=\n  publishProgress m #[{ range := \u27e8m.text.utf8PosToLspPos pos, m.text.utf8PosToLspPos m.text.source.endPos\u27e9, kind := kind }] hOut", "start": [136, 1], "end": [137, 129], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.publishProgressDone", "code": "def publishProgressDone (m : DocumentMeta) (hOut : FS.Stream) : IO Unit :=\n  publishProgress m #[] hOut", "start": [139, 1], "end": [140, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.applyWorkspaceEdit", "code": "def applyWorkspaceEdit (params : ApplyWorkspaceEditParams) (hOut : FS.Stream) : IO Unit :=\n  hOut.writeLspRequest \u27e8\"workspace/applyEdit\", \"workspace/applyEdit\", params\u27e9", "start": [143, 1], "end": [144, 78], "kind": "commanddeclaration"}, {"full_name": "String.Range.toLspRange", "code": "def String.Range.toLspRange (text : Lean.FileMap) (r : String.Range) : Lean.Lsp.Range :=\n  \u27e8text.utf8PosToLspPos r.start, text.utf8PosToLspPos r.stop\u27e9", "start": [148, 1], "end": [149, 62], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Internal.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.RefIdent", "code": "inductive RefIdent where\n  | const : Name \u2192 RefIdent\n  | fvar : FVarId \u2192 RefIdent\n  deriving BEq, Hashable, Inhabited", "start": [20, 1], "end": [23, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RefIdent.toString", "code": "def toString : RefIdent \u2192 String\n  | RefIdent.const n => s!\"c:{n}\"\n  | RefIdent.fvar id => s!\"f:{id.name}\"", "start": [27, 1], "end": [29, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RefIdent.fromString", "code": "def fromString (s : String) : Except String RefIdent := do\n  let sPrefix := s.take 2\n  let sName := s.drop 2\n  let name \u2190 match sName with\n    | \"[anonymous]\" => pure Name.anonymous\n    | _ =>\n      let n := sName.toName\n      if n.isAnonymous then throw s!\"expected a Name, got {sName}\"\n      else pure n\n  match sPrefix with\n    | \"c:\" => return RefIdent.const name\n    | \"f:\" => return RefIdent.fvar <| FVarId.mk name\n    | _ => throw \"string must start with 'c:' or 'f:'\"", "start": [31, 1], "end": [44, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RefInfo", "code": "structure RefInfo where\n  definition : Option Lsp.Range\n  usages : Array Lsp.Range", "start": [48, 1], "end": [50, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ModuleRefs", "code": "def ModuleRefs := HashMap RefIdent RefInfo", "start": [74, 1], "end": [75, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.LeanIleanInfoParams", "code": "structure LeanIleanInfoParams where\n  \n  version : Nat\n  references : ModuleRefs\n  deriving FromJson, ToJson", "start": [86, 1], "end": [93, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Replace.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Lean/Util/ForEachExpr.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/MatchUtil.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Revert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.MVarId.replaceTargetEq", "code": "def _root_.Lean.MVarId.replaceTargetEq (mvarId : MVarId) (targetNew : Expr) (eqProof : Expr) : MetaM MVarId :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `replaceTarget\n    let tag      \u2190 mvarId.getTag\n    let mvarNew  \u2190 mkFreshExprSyntheticOpaqueMVar targetNew tag\n    let target   \u2190 mvarId.getType\n    let u        \u2190 getLevel target\n    let eq       \u2190 mkEq target targetNew\n    let newProof \u2190 mkExpectedTypeHint eqProof eq\n    let val  := mkAppN (Lean.mkConst `Eq.mpr [u]) #[target, targetNew, newProof, mvarNew]\n    mvarId.assign val\n    return mvarNew.mvarId!", "start": [17, 1], "end": [31, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.replaceTargetEq", "code": "@[deprecated MVarId.replaceTargetEq]\ndef replaceTargetEq (mvarId : MVarId) (targetNew : Expr) (eqProof : Expr) : MetaM MVarId :=\n  mvarId.replaceTargetEq targetNew eqProof", "start": [33, 1], "end": [35, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.replaceTargetDefEq", "code": "def _root_.Lean.MVarId.replaceTargetDefEq (mvarId : MVarId) (targetNew : Expr) : MetaM MVarId :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `change\n    let target  \u2190 mvarId.getType\n    if target == targetNew then\n      return mvarId\n    else\n      let tag     \u2190 mvarId.getTag\n      let mvarNew \u2190 mkFreshExprSyntheticOpaqueMVar targetNew tag\n      let newVal  \u2190 mkExpectedTypeHint mvarNew target\n      mvarId.assign newVal\n      return mvarNew.mvarId!", "start": [37, 1], "end": [55, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.replaceTargetDefEq", "code": "@[deprecated MVarId.replaceTargetDefEq]\ndef replaceTargetDefEq (mvarId : MVarId) (targetNew : Expr) : MetaM MVarId :=\n  mvarId.replaceTargetDefEq targetNew", "start": [57, 1], "end": [59, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.replaceLocalDeclCore", "code": "private def replaceLocalDeclCore (mvarId : MVarId) (fvarId : FVarId) (typeNew : Expr) (eqProof : Expr) : MetaM AssertAfterResult :=\n  mvarId.withContext do\n    let localDecl \u2190 fvarId.getDecl\n    let typeNewPr \u2190 mkEqMP eqProof (mkFVar fvarId)\n    let (_, localDecl') \u2190 findMaxFVar typeNew |>.run localDecl\n    let result \u2190 mvarId.assertAfter localDecl'.fvarId localDecl.userName typeNew typeNewPr\n    (do let mvarIdNew \u2190 result.mvarId.clear fvarId\n        pure { result with mvarId := mvarIdNew })\n    <|> pure result\nwhere\n  findMaxFVar (e : Expr) : StateRefT LocalDecl MetaM Unit :=\n    e.forEach' fun e => do\n      if e.isFVar then\n        let localDecl' \u2190 e.fvarId!.getDecl\n        modify fun localDecl => if localDecl'.index > localDecl.index then localDecl' else localDecl\n        return false\n      else\n        return e.hasFVar", "start": [61, 1], "end": [80, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.replaceLocalDecl", "code": "abbrev _root_.Lean.MVarId.replaceLocalDecl (mvarId : MVarId) (fvarId : FVarId) (typeNew : Expr) (eqProof : Expr) : MetaM AssertAfterResult :=\n  replaceLocalDeclCore mvarId fvarId typeNew eqProof", "start": [82, 1], "end": [90, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.replaceLocalDecl", "code": "@[deprecated MVarId.replaceLocalDecl]\nabbrev replaceLocalDecl (mvarId : MVarId) (fvarId : FVarId) (typeNew : Expr) (eqProof : Expr) : MetaM AssertAfterResult :=\n  mvarId.replaceLocalDecl fvarId typeNew eqProof", "start": [92, 1], "end": [94, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.replaceLocalDeclDefEq", "code": "def _root_.Lean.MVarId.replaceLocalDeclDefEq (mvarId : MVarId) (fvarId : FVarId) (typeNew : Expr) : MetaM MVarId := do\n  mvarId.withContext do\n    if typeNew == (\u2190 fvarId.getType) then\n      return mvarId\n    else\n      let mvarDecl \u2190 mvarId.getDecl\n      let lctxNew := (\u2190 getLCtx).modifyLocalDecl fvarId (\u00b7.setType typeNew)\n      let mvarNew \u2190 mkFreshExprMVarAt lctxNew (\u2190 getLocalInstances) mvarDecl.type mvarDecl.kind mvarDecl.userName\n      mvarId.assign mvarNew\n      return mvarNew.mvarId!", "start": [96, 1], "end": [109, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.replaceLocalDeclDefEq", "code": "@[deprecated MVarId.replaceLocalDeclDefEq]\ndef replaceLocalDeclDefEq (mvarId : MVarId) (fvarId : FVarId) (typeNew : Expr) : MetaM MVarId := do\n  mvarId.replaceLocalDeclDefEq fvarId typeNew", "start": [111, 1], "end": [113, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.change", "code": "def _root_.Lean.MVarId.change (mvarId : MVarId) (targetNew : Expr) (checkDefEq := true) : MetaM MVarId := mvarId.withContext do\n  let target \u2190 mvarId.getType\n  if checkDefEq then\n    unless (\u2190 isDefEq target targetNew) do\n      throwTacticEx `change mvarId m!\"given type{indentExpr targetNew}\\nis not definitionally equal to{indentExpr target}\"\n  mvarId.replaceTargetDefEq targetNew", "start": [115, 1], "end": [125, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.change", "code": "@[deprecated MVarId.change]\ndef change (mvarId : MVarId) (targetNew : Expr) (checkDefEq := true) : MetaM MVarId := mvarId.withContext do\n  mvarId.change targetNew checkDefEq", "start": [127, 1], "end": [129, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.changeLocalDecl", "code": "def _root_.Lean.MVarId.changeLocalDecl (mvarId : MVarId) (fvarId : FVarId) (typeNew : Expr) (checkDefEq := true) : MetaM MVarId := do\n  mvarId.checkNotAssigned `changeLocalDecl\n  let (xs, mvarId) \u2190 mvarId.revert #[fvarId] true\n  mvarId.withContext do\n    let numReverted := xs.size\n    let target \u2190 mvarId.getType\n    let check (typeOld : Expr) : MetaM Unit := do\n      if checkDefEq then\n        unless (\u2190 isDefEq typeNew typeOld) do\n          throwTacticEx `changeHypothesis mvarId m!\"given type{indentExpr typeNew}\\nis not definitionally equal to{indentExpr typeOld}\"\n    let finalize (targetNew : Expr) : MetaM MVarId := do\n      let mvarId \u2190 mvarId.replaceTargetDefEq targetNew\n      let (_, mvarId) \u2190 mvarId.introNP numReverted\n      pure mvarId\n    match target with\n    | .forallE n d b c => do check d; finalize (mkForall n c typeNew b)\n    | .letE n t v b _  => do check t; finalize (mkLet n typeNew v b)\n    | _ => throwTacticEx `changeHypothesis mvarId \"unexpected auxiliary target\"", "start": [131, 1], "end": [153, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.changeLocalDecl", "code": "@[deprecated MVarId.changeLocalDecl]\ndef changeLocalDecl (mvarId : MVarId) (fvarId : FVarId) (typeNew : Expr) (checkDefEq := true) : MetaM MVarId := do\n  mvarId.changeLocalDecl fvarId typeNew checkDefEq", "start": [155, 1], "end": [157, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.modifyTarget", "code": "def _root_.Lean.MVarId.modifyTarget (mvarId : MVarId) (f : Expr \u2192 MetaM Expr) : MetaM MVarId := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `modifyTarget\n    mvarId.change (\u2190 f (\u2190 mvarId.getType)) (checkDefEq := false)", "start": [159, 1], "end": [165, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.modifyTarget", "code": "@[deprecated modifyTarget]\ndef modifyTarget (mvarId : MVarId) (f : Expr \u2192 MetaM Expr) : MetaM MVarId := do\n  mvarId.modifyTarget f", "start": [167, 1], "end": [169, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.modifyTargetEqLHS", "code": "def _root_.Lean.MVarId.modifyTargetEqLHS (mvarId : MVarId) (f : Expr \u2192 MetaM Expr) : MetaM MVarId := do\n   mvarId.modifyTarget fun target => do\n     if let some (_, lhs, rhs) \u2190 matchEq? target then\n       mkEq (\u2190 f lhs) rhs\n     else\n       throwTacticEx `modifyTargetEqLHS mvarId m!\"equality expected{indentExpr target}\"", "start": [171, 1], "end": [180, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.modifyTargetEqLHS", "code": "@[deprecated MVarId.modifyTargetEqLHS]\ndef modifyTargetEqLHS (mvarId : MVarId) (f : Expr \u2192 MetaM Expr) : MetaM MVarId := do\n  mvarId.modifyTargetEqLHS f", "start": [182, 1], "end": [184, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/UnifyEq.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Injection.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.heqToEq'", "code": "private def heqToEq' (mvarId : MVarId) (eqDecl : LocalDecl) : MetaM MVarId := do\n  \n  let prf    \u2190 mkEqOfHEq (mkFVar eqDecl.fvarId)\n  let aEqb   \u2190 whnf (\u2190 inferType prf)\n  let mvarId \u2190 mvarId.assert eqDecl.userName aEqb prf\n  mvarId.clear eqDecl.fvarId", "start": [10, 1], "end": [16, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.UnifyEqResult", "code": "structure UnifyEqResult where\n  mvarId    : MVarId\n  subst     : FVarSubst\n  numNewEqs : Nat := 0", "start": [18, 1], "end": [21, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unifyEq?", "code": "def unifyEq? (mvarId : MVarId) (eqFVarId : FVarId) (subst : FVarSubst := {})\n             (acyclic : MVarId \u2192 Expr \u2192 MetaM Bool := fun _ _ => return false)\n             (caseName? : Option Name := none)\n             : MetaM (Option UnifyEqResult) := do\n   mvarId.withContext do\n    let eqDecl \u2190 eqFVarId.getDecl\n    if eqDecl.type.isHEq then\n      let mvarId \u2190 heqToEq' mvarId eqDecl\n      return some { mvarId, subst, numNewEqs := 1 }\n    else match eqDecl.type.eq? with\n      | none => throwError \"equality expected{indentExpr eqDecl.type}\"\n      | some (_, a, b) =>\n        \n        \n        let rec substEq (symm : Bool) := do\n          \n          if let some (subst, mvarId) \u2190 observing? (substCore mvarId eqFVarId symm subst) then\n            return some { mvarId, subst }\n          else if (\u2190 isDefEq a b) then\n            \n            return some { mvarId := (\u2190  mvarId.clear eqFVarId), subst }\n          else if (\u2190 acyclic mvarId (mkFVar eqFVarId)) then\n            return none else\n            throwError \"dependent elimination failed, failed to solve equation{indentExpr eqDecl.type}\"\n        let rec injection (a b : Expr) := do\n          let env \u2190 getEnv\n          if a.isConstructorApp env && b.isConstructorApp env then\n            \n            match (\u2190 injectionCore mvarId eqFVarId) with\n            | InjectionResultCore.solved                   => return none | InjectionResultCore.subgoal mvarId numNewEqs => return some { mvarId, numNewEqs, subst }\n          else\n            let a' \u2190 whnf a\n            let b' \u2190 whnf b\n            if a' != a || b' != b then\n              \n              let prf := mkFVar eqFVarId\n              let aEqb'  \u2190 mkEq a' b'\n              let mvarId \u2190 mvarId.assert eqDecl.userName aEqb' prf\n              let mvarId \u2190  mvarId.clear eqFVarId\n              return some { mvarId, subst, numNewEqs := 1 }\n            else\n              match caseName? with\n              | none => throwError \"dependent elimination failed, failed to solve equation{indentExpr eqDecl.type}\"\n              | some caseName => throwError \"dependent elimination failed, failed to solve equation{indentExpr eqDecl.type}\\nat case {mkConst caseName}\"\n        let a \u2190 instantiateMVars a\n        let b \u2190 instantiateMVars b\n        match a, b with\n        | Expr.fvar aFVarId, Expr.fvar bFVarId =>\n          \n          let aDecl \u2190 aFVarId.getDecl\n          let bDecl \u2190 bFVarId.getDecl\n          substEq (aDecl.index < bDecl.index)\n        | Expr.fvar .., _   =>  substEq (symm := false)\n        | _, Expr.fvar ..   =>  substEq (symm := true)\n        | a, b              =>\n          if (\u2190 isDefEq a b) then\n            \n            return some { mvarId := (\u2190 mvarId.clear eqFVarId), subst }\n          else\n            injection a b", "start": [23, 1], "end": [102, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Rewrite.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Types.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/ACLt.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Simp.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatchEqsExt.lean", "lake-packages/lean4/src/lean/Lean/Meta/SynthInstance.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.Meta.Simp.mkEqTrans", "code": "def mkEqTrans (r\u2081 r\u2082 : Result) : MetaM Result := do\n  match r\u2081.proof? with\n  | none => return r\u2082\n  | some p\u2081 => match r\u2082.proof? with\n    | none    => return { r\u2082 with proof? := r\u2081.proof? }\n    | some p\u2082 => return { r\u2082 with proof? := (\u2190 Meta.mkEqTrans p\u2081 p\u2082) }", "start": [15, 1], "end": [20, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.synthesizeArgs", "code": "def synthesizeArgs (thmId : Origin) (xs : Array Expr) (bis : Array BinderInfo) (discharge? : Expr \u2192 SimpM (Option Expr)) : SimpM Bool := do\n  for x in xs, bi in bis do\n    let type \u2190 inferType x\n    if bi.isInstImplicit then\n      unless (\u2190 synthesizeInstance x type) do\n        return false\n    else if (\u2190 instantiateMVars x).isMVar then\n      if (\u2190 isClass? type).isSome then\n        if (\u2190 synthesizeInstance x type) then\n          continue\n      if (\u2190 isProp type) then\n        match (\u2190 discharge? type) with\n        | some proof =>\n          unless (\u2190 isDefEq x proof) do\n            trace[Meta.Tactic.simp.discharge] \"{\u2190 ppOrigin thmId}, failed to assign proof{indentExpr type}\"\n            return false\n        | none =>\n          trace[Meta.Tactic.simp.discharge] \"{\u2190 ppOrigin thmId}, failed to discharge hypotheses{indentExpr type}\"\n          return false\n  return true\nwhere\n  synthesizeInstance (x type : Expr) : SimpM Bool := do\n    match (\u2190 trySynthInstance type) with\n    | LOption.some val =>\n      if (\u2190 withReducibleAndInstances <| isDefEq x val) then\n        return true\n      else\n        trace[Meta.Tactic.simp.discharge] \"{\u2190 ppOrigin thmId}, failed to assign instance{indentExpr type}\\nsythesized value{indentExpr val}\\nis not definitionally equal to{indentExpr x}\"\n        return false\n    | _ =>\n      trace[Meta.Tactic.simp.discharge] \"{\u2190 ppOrigin thmId}, failed to synthesize instance{indentExpr type}\"\n      return false", "start": [22, 1], "end": [60, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.tryTheoremCore", "code": "private def tryTheoremCore (lhs : Expr) (xs : Array Expr) (bis : Array BinderInfo) (val : Expr) (type : Expr) (e : Expr) (thm : SimpTheorem) (numExtraArgs : Nat) (discharge? : Expr \u2192 SimpM (Option Expr)) : SimpM (Option Result) := do\n  let rec go (e : Expr) : SimpM (Option Result) := do\n    if (\u2190 isDefEq lhs e) then\n      unless (\u2190 synthesizeArgs thm.origin xs bis discharge?) do\n        return none\n      let proof? \u2190 if thm.rfl then\n        pure none\n      else\n        let proof \u2190 instantiateMVars (mkAppN val xs)\n        if (\u2190 hasAssignableMVar proof) then\n          trace[Meta.Tactic.simp.rewrite] \"{\u2190 ppSimpTheorem thm}, has unassigned metavariables after unification\"\n          return none\n        pure <| some proof\n      let rhs := (\u2190 instantiateMVars type).appArg!\n      if e == rhs then\n        return none\n      if thm.perm then\n        \n        if !(\u2190 Expr.acLt rhs e .reduceSimpleOnly) then\n          trace[Meta.Tactic.simp.rewrite] \"{\u2190 ppSimpTheorem thm}, perm rejected {e} ==> {rhs}\"\n          return none\n      trace[Meta.Tactic.simp.rewrite] \"{\u2190 ppSimpTheorem thm}, {e} ==> {rhs}\"\n      recordSimpTheorem thm.origin\n      return some { expr := rhs, proof? }\n    else\n      unless lhs.isMVar do\n        trace[Meta.Tactic.simp.unify] \"{\u2190 ppSimpTheorem thm}, failed to unify{indentExpr lhs}\\nwith{indentExpr e}\"\n      return none\n  \n  let mut extraArgs := #[]\n  let mut e := e\n  for _ in [:numExtraArgs] do\n    extraArgs := extraArgs.push e.appArg!\n    e := e.appFn!\n  extraArgs := extraArgs.reverse\n  match (\u2190 go e) with\n  | none => return none\n  | some { expr := eNew, proof? := none, .. } =>\n    if (\u2190 hasAssignableMVar eNew) then\n      trace[Meta.Tactic.simp.rewrite] \"{\u2190 ppSimpTheorem thm}, resulting expression has unassigned metavariables\"\n      return none\n    return some { expr := mkAppN eNew extraArgs }\n  | some { expr := eNew, proof? := some proof, .. } =>\n    let mut proof := proof\n    for extraArg in extraArgs do\n      proof \u2190 mkCongrFun proof extraArg\n    if (\u2190 hasAssignableMVar eNew) then\n      trace[Meta.Tactic.simp.rewrite] \"{\u2190 ppSimpTheorem thm}, resulting expression has unassigned metavariables\"\n      return none\n    return some { expr := mkAppN eNew extraArgs, proof? := some proof }", "start": [62, 1], "end": [118, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.tryTheoremWithExtraArgs?", "code": "def tryTheoremWithExtraArgs? (e : Expr) (thm : SimpTheorem) (numExtraArgs : Nat) (discharge? : Expr \u2192 SimpM (Option Expr)) : SimpM (Option Result) :=\n  withNewMCtxDepth do\n    let val  \u2190 thm.getValue\n    let type \u2190 inferType val\n    let (xs, bis, type) \u2190 forallMetaTelescopeReducing type\n    let type \u2190 whnf (\u2190 instantiateMVars type)\n    let lhs := type.appFn!.appArg!\n    tryTheoremCore lhs xs bis val type e thm numExtraArgs discharge?", "start": [120, 1], "end": [127, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.tryTheorem?", "code": "def tryTheorem? (e : Expr) (thm : SimpTheorem) (discharge? : Expr \u2192 SimpM (Option Expr)) : SimpM (Option Result) := do\n  withNewMCtxDepth do\n    let val  \u2190 thm.getValue\n    let type \u2190 inferType val\n    let (xs, bis, type) \u2190 forallMetaTelescopeReducing type\n    let type \u2190 whnf (\u2190 instantiateMVars type)\n    let lhs := type.appFn!.appArg!\n    match (\u2190 tryTheoremCore lhs xs bis val type e thm 0 discharge?) with\n    | some result => return some result\n    | none =>\n      let lhsNumArgs := lhs.getAppNumArgs\n      let eNumArgs   := e.getAppNumArgs\n      if eNumArgs > lhsNumArgs then\n        tryTheoremCore lhs xs bis val type e thm (eNumArgs - lhsNumArgs) discharge?\n      else\n        return none", "start": [129, 1], "end": [144, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.rewrite?", "code": "def rewrite? (e : Expr) (s : SimpTheoremTree) (erased : PHashSet Origin) (discharge? : Expr \u2192 SimpM (Option Expr)) (tag : String) (rflOnly : Bool) : SimpM (Option Result) := do\n  let candidates \u2190 s.getMatchWithExtra e\n  if candidates.isEmpty then\n    trace[Debug.Meta.Tactic.simp] \"no theorems found for {tag}-rewriting {e}\"\n    return none\n  else\n    let candidates := candidates.insertionSort fun e\u2081 e\u2082 => e\u2081.1.priority > e\u2082.1.priority\n    for (thm, numExtraArgs) in candidates do\n      unless inErasedSet thm || (rflOnly && !thm.rfl) do\n        if let some result \u2190 tryTheoremWithExtraArgs? e thm numExtraArgs discharge? then\n          trace[Debug.Meta.Tactic.simp] \"rewrite result {e} => {result.expr}\"\n          return some result\n    return none\nwhere\n  inErasedSet (thm : SimpTheorem) : Bool :=\n    erased.contains thm.origin", "start": [145, 1], "end": [163, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.andThen", "code": "@[inline] def andThen (s : Step) (f? : Expr \u2192 SimpM (Option Step)) : SimpM Step := do\n  match s with\n  | Step.done _  => return s\n  | Step.visit r =>\n    if let some s' \u2190 f? r.expr then\n      return s'.updateResult (\u2190 mkEqTrans r s'.result)\n    else\n      return s", "start": [165, 1], "end": [172, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.rewriteCtorEq?", "code": "def rewriteCtorEq? (e : Expr) : MetaM (Option Result) := withReducibleAndInstances do\n  match e.eq? with\n  | none => return none\n  | some (_, lhs, rhs) =>\n    let lhs \u2190 whnf lhs\n    let rhs \u2190 whnf rhs\n    let env \u2190 getEnv\n    match lhs.constructorApp? env, rhs.constructorApp? env with\n    | some (c\u2081, _), some (c\u2082, _) =>\n      if c\u2081.name != c\u2082.name then\n        withLocalDeclD `h e fun h =>\n          return some { expr := mkConst ``False, proof? := (\u2190 mkEqFalse' (\u2190 mkLambdaFVars #[h] (\u2190 mkNoConfusion (mkConst ``False) h))) }\n      else\n        return none\n    | _, _ => return none", "start": [174, 1], "end": [188, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.tryRewriteCtorEq?", "code": "@[inline] def tryRewriteCtorEq? (e : Expr) : SimpM (Option Step) := do\n  match (\u2190 rewriteCtorEq? e) with\n  | some r => return Step.done r\n  | none  => return none", "start": [190, 1], "end": [193, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.rewriteUsingDecide?", "code": "def rewriteUsingDecide? (e : Expr) : MetaM (Option Result) := withReducibleAndInstances do\n  if e.hasFVar || e.hasMVar || e.consumeMData.isConstOf ``True || e.consumeMData.isConstOf ``False then\n    return none\n  else\n    try\n      let d \u2190 mkDecide e\n      let r \u2190 withDefault <| whnf d\n      if r.isConstOf ``true then\n        return some { expr := mkConst ``True, proof? := mkAppN (mkConst ``eq_true_of_decide) #[e, d.appArg!, (\u2190 mkEqRefl (mkConst ``true))] }\n      else if r.isConstOf ``false then\n        return some { expr := mkConst ``False, proof? := mkAppN (mkConst ``eq_false_of_decide) #[e, d.appArg!, (\u2190 mkEqRefl (mkConst ``false))] }\n      else\n        return none\n    catch _ =>\n      return none", "start": [195, 1], "end": [209, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.tryRewriteUsingDecide?", "code": "@[inline] def tryRewriteUsingDecide? (e : Expr) : SimpM (Option Step) := do\n  if (\u2190 read).config.decide then\n    match (\u2190 rewriteUsingDecide? e) with\n    | some r => return Step.done r\n    | none => return none\n  else\n    return none", "start": [211, 1], "end": [217, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.simpArith?", "code": "def simpArith? (e : Expr) : SimpM (Option Step) := do\n  if !(\u2190 read).config.arith then return none\n  let some (e', h) \u2190 Linear.simp? e (\u2190 read).parent? | return none\n  return Step.visit { expr := e', proof? := h }", "start": [219, 1], "end": [222, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.simpMatchCore?", "code": "def simpMatchCore? (app : MatcherApp) (e : Expr) (discharge? : Expr \u2192 SimpM (Option Expr)) : SimpM (Option Step) := do\n  for matchEq in (\u2190 Match.getEquationsFor app.matcherName).eqnNames do\n    match (\u2190 withReducible <| Simp.tryTheorem? e { origin := .decl matchEq, proof := mkConst matchEq, rfl := (\u2190 isRflTheorem matchEq) } discharge?) with\n    | none   => pure ()\n    | some r => return some (Simp.Step.done r)\n  return none", "start": [224, 1], "end": [230, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.simpMatch?", "code": "def simpMatch? (discharge? : Expr \u2192 SimpM (Option Expr)) (e : Expr) : SimpM (Option Step) := do\n  if (\u2190 read).config.iota then\n    let some app \u2190 matchMatcherApp? e | return none\n    simpMatchCore? app e discharge?\n  else\n    return none", "start": [232, 1], "end": [237, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.rewritePre", "code": "def rewritePre (e : Expr) (discharge? : Expr \u2192 SimpM (Option Expr)) (rflOnly := false) : SimpM Step := do\n  for thms in (\u2190 read).simpTheorems do\n    if let some r \u2190 rewrite? e thms.pre thms.erased discharge? (tag := \"pre\") (rflOnly := rflOnly) then\n      return Step.visit r\n  return Step.visit { expr := e }", "start": [239, 1], "end": [243, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.rewritePost", "code": "def rewritePost (e : Expr) (discharge? : Expr \u2192 SimpM (Option Expr)) (rflOnly := false) : SimpM Step := do\n  for thms in (\u2190 read).simpTheorems do\n    if let some r \u2190 rewrite? e thms.post thms.erased discharge? (tag := \"post\") (rflOnly := rflOnly) then\n      return Step.visit r\n  return Step.visit { expr := e }", "start": [245, 1], "end": [249, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.preDefault", "code": "def preDefault (e : Expr) (discharge? : Expr \u2192 SimpM (Option Expr)) : SimpM Step := do\n  let s \u2190 rewritePre e discharge?\n  andThen s tryRewriteUsingDecide?", "start": [251, 1], "end": [253, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.postDefault", "code": "def postDefault (e : Expr) (discharge? : Expr \u2192 SimpM (Option Expr)) : SimpM Step := do\n  let s \u2190 rewritePost e discharge?\n  let s \u2190 andThen s (simpMatch? discharge?)\n  let s \u2190 andThen s simpArith?\n  let s \u2190 andThen s tryRewriteUsingDecide?\n  andThen s tryRewriteCtorEq?", "start": [255, 1], "end": [260, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Widget/InteractiveCode.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Widget/Basic.lean", "lake-packages/lean4/src/lean/Lean/Widget/TaggedText.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Lean/Server/InfoUtils.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/PrettyPrinter.lean"], "premises": [{"full_name": "Lean.Widget.DiffTag", "code": "inductive DiffTag where\n  | wasChanged\n  | willChange\n  | wasDeleted\n  | willDelete\n  | wasInserted\n  | willInsert\n  deriving ToJson, FromJson", "start": [19, 1], "end": [27, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.SubexprInfo", "code": "structure SubexprInfo where\n  \n  info : WithRpcRef Lean.Elab.InfoWithCtx\n  \n  subexprPos : Lean.SubExpr.Pos\n  \n  diffStatus? : Option DiffTag := none\n  deriving RpcEncodable", "start": [29, 1], "end": [41, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.CodeWithInfos", "code": "abbrev CodeWithInfos := TaggedText SubexprInfo", "start": [43, 1], "end": [44, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.CodeWithInfos.mergePosMap", "code": "def CodeWithInfos.mergePosMap [Monad m] (merger : SubexprInfo \u2192 \u03b1 \u2192 m SubexprInfo) (pm : Lean.SubExpr.PosMap \u03b1) (tt : CodeWithInfos) : m CodeWithInfos :=\n  if pm.isEmpty then return tt else\n  tt.mapM (fun (info : SubexprInfo) =>\n    match pm.find? info.subexprPos with\n    | some a => merger info a\n    | none => pure info\n  )", "start": [46, 1], "end": [52, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.CodeWithInfos.pretty", "code": "def CodeWithInfos.pretty (tt : CodeWithInfos) :=\n  tt.stripTags", "start": [54, 1], "end": [55, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.SubexprInfo.withDiffTag", "code": "def SubexprInfo.withDiffTag (tag : DiffTag) (c : SubexprInfo) : SubexprInfo :=\n  { c with diffStatus? := some tag }", "start": [57, 1], "end": [58, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.tagCodeInfos", "code": "partial def tagCodeInfos (ctx : Elab.ContextInfo) (infos : SubExpr.PosMap Elab.Info) (tt : TaggedText (Nat \u00d7 Nat))\n    : CodeWithInfos :=\n  go tt\nwhere\n  go (tt : TaggedText (Nat \u00d7 Nat)) :=\n    tt.rewrite fun (n, _) subTt =>\n      match infos.find? n with\n      | none   => go subTt\n      | some i =>\n        let t : SubexprInfo := {\n          info := WithRpcRef.mk { ctx, info := i, children := .empty }\n          subexprPos := n\n        }\n        TaggedText.tag t (go subTt)", "start": [60, 1], "end": [74, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.ppExprTagged", "code": "def ppExprTagged (e : Expr) (explicit : Bool := false) : MetaM CodeWithInfos := do\n  if pp.raw.get (\u2190 getOptions) then\n    return .text (toString e)\n  let delab := open PrettyPrinter.Delaborator in\n    if explicit then\n      withOptionAtCurrPos pp.tagAppFns.name true do\n      withOptionAtCurrPos pp.explicit.name true do\n        delabAppImplicit <|> delabAppExplicit\n    else\n      delab\n  let \u27e8fmt, infos\u27e9 \u2190 PrettyPrinter.ppExprWithInfos e (delab := delab)\n  let tt := TaggedText.prettyTagged fmt\n  let ctx := {\n    env           := (\u2190 getEnv)\n    mctx          := (\u2190 getMCtx)\n    options       := (\u2190 getOptions)\n    currNamespace := (\u2190 getCurrNamespace)\n    openDecls     := (\u2190 getOpenDecls)\n    fileMap       := default\n    ngen          := (\u2190 getNGen)\n  }\n  return tagCodeInfos ctx infos tt", "start": [76, 1], "end": [97, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Binders.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.Scope", "code": "structure Scope where\n  header        : String\n  opts          : Options := {}\n  currNamespace : Name := Name.anonymous\n  openDecls     : List OpenDecl := []\n  levelNames    : List Name := []\n  \n  varDecls      : Array (TSyntax ``Parser.Term.bracketedBinder) := #[]\n  \n  varUIds       : Array Name := #[]\n  \n  isNoncomputable : Bool := false\n  deriving Inhabited", "start": [11, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.State", "code": "structure State where\n  env            : Environment\n  messages       : MessageLog := {}\n  scopes         : List Scope := [{ header := \"\" }]\n  nextMacroScope : Nat := firstFrontendMacroScope + 1\n  maxRecDepth    : Nat\n  nextInstIdx    : Nat := 1 ngen           : NameGenerator := {}\n  infoState      : InfoState := {}\n  traceState     : TraceState := {}\n  deriving Nonempty", "start": [25, 1], "end": [35, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.Context", "code": "structure Context where\n  fileName       : String\n  fileMap        : FileMap\n  currRecDepth   : Nat := 0\n  cmdPos         : String.Pos := 0\n  macroStack     : MacroStack := []\n  currMacroScope : MacroScope := firstFrontendMacroScope\n  ref            : Syntax := Syntax.missing\n  tacticCache?   : Option (IO.Ref Tactic.Cache)", "start": [37, 1], "end": [45, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.CommandElabCoreM", "code": "abbrev CommandElabCoreM (\u03b5) := ReaderT Context $ StateRefT State $ EIO \u03b5", "start": [47, 1], "end": [47, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.CommandElabM", "code": "abbrev CommandElabM := CommandElabCoreM Exception", "start": [48, 1], "end": [48, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.CommandElab", "code": "abbrev CommandElab  := Syntax \u2192 CommandElabM Unit", "start": [49, 1], "end": [49, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.Linter", "code": "structure Linter where\n  run : Syntax \u2192 CommandElabM Unit\n  name : Name := by exact decl_name%", "start": [50, 1], "end": [52, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkState", "code": "def mkState (env : Environment) (messages : MessageLog := {}) (opts : Options := {}) : State := {\n  env         := env\n  messages    := messages\n  scopes      := [{ header := \"\", opts := opts }]\n  maxRecDepth := maxRecDepth.get opts\n}", "start": [63, 1], "end": [68, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addLinter", "code": "def addLinter (l : Linter) : IO Unit := do\n  let ls \u2190 lintersRef.get\n  lintersRef.set (ls.push l)", "start": [75, 1], "end": [77, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getRef", "code": "protected def getRef : CommandElabM Syntax :=\n  return (\u2190 read).ref", "start": [91, 1], "end": [92, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkMessageAux", "code": "def mkMessageAux (ctx : Context) (ref : Syntax) (msgData : MessageData) (severity : MessageSeverity) : Message :=\n  let pos := ref.getPos?.getD ctx.cmdPos\n  let endPos := ref.getTailPos?.getD pos\n  mkMessageCore ctx.fileName ctx.fileMap msgData severity pos endPos", "start": [113, 1], "end": [116, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkCoreContext", "code": "private def mkCoreContext (ctx : Context) (s : State) (heartbeats : Nat) : Core.Context :=\n  let scope        := s.scopes.head!\n  { fileName       := ctx.fileName\n    fileMap        := ctx.fileMap\n    options        := scope.opts\n    currRecDepth   := ctx.currRecDepth\n    maxRecDepth    := s.maxRecDepth\n    ref            := ctx.ref\n    currNamespace  := scope.currNamespace\n    openDecls      := scope.openDecls\n    initHeartbeats := heartbeats\n    currMacroScope := ctx.currMacroScope }", "start": [118, 1], "end": [129, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addTraceAsMessagesCore", "code": "private def addTraceAsMessagesCore (ctx : Context) (log : MessageLog) (traceState : TraceState) : MessageLog := Id.run do\n  if traceState.traces.isEmpty then return log\n  let mut traces : HashMap (String.Pos \u00d7 String.Pos) (Array MessageData) := \u2205\n  for traceElem in traceState.traces do\n    let ref := replaceRef traceElem.ref ctx.ref\n    let pos := ref.getPos?.getD 0\n    let endPos := ref.getTailPos?.getD pos\n    traces := traces.insert (pos, endPos) <| traces.findD (pos, endPos) #[] |>.push traceElem.msg\n  let mut log := log\n  let traces' := traces.toArray.qsort fun ((a, _), _) ((b, _), _) => a < b\n  for ((pos, endPos), traceMsg) in traces' do\n    log := log.add <| mkMessageCore ctx.fileName ctx.fileMap (.joinSep traceMsg.toList \"\\n\") .information pos endPos\n  return log", "start": [131, 1], "end": [143, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addTraceAsMessages", "code": "private def addTraceAsMessages : CommandElabM Unit := do\n  let ctx \u2190 read\n  modify fun s => { s with\n    messages          := addTraceAsMessagesCore ctx s.messages s.traceState\n    traceState.traces := {}\n  }", "start": [145, 1], "end": [150, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.liftCoreM", "code": "def liftCoreM (x : CoreM \u03b1) : CommandElabM \u03b1 := do\n  let s \u2190 get\n  let ctx \u2190 read\n  let heartbeats \u2190 IO.getNumHeartbeats\n  let E\u03b1 := Except Exception \u03b1\n  let x : CoreM E\u03b1 := try let a \u2190 x; pure <| Except.ok a catch ex => pure <| Except.error ex\n  let x : EIO Exception (E\u03b1 \u00d7 Core.State) := (ReaderT.run x (mkCoreContext ctx s heartbeats)).run { env := s.env, ngen := s.ngen, traceState := s.traceState, messages := {}, infoState.enabled := s.infoState.enabled }\n  let (ea, coreS) \u2190 liftM x\n  modify fun s => { s with\n    env := coreS.env\n    ngen := coreS.ngen\n    messages := s.messages ++ coreS.messages\n    traceState.traces := coreS.traceState.traces.map fun t => { t with ref := replaceRef t.ref ctx.ref }\n    infoState.trees := s.infoState.trees.append coreS.infoState.trees\n  }\n  match ea with\n  | Except.ok a    => pure a\n  | Except.error e => throw e", "start": [152, 1], "end": [169, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.ioErrorToMessage", "code": "private def ioErrorToMessage (ctx : Context) (ref : Syntax) (err : IO.Error) : Message :=\n  let ref := getBetterRef ref ctx.macroStack\n  mkMessageAux ctx ref (toString err) MessageSeverity.error", "start": [171, 1], "end": [173, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.liftEIO", "code": "@[inline] def liftEIO {\u03b1} (x : EIO Exception \u03b1) : CommandElabM \u03b1 := liftM x", "start": [175, 1], "end": [175, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.liftIO", "code": "@[inline] def liftIO {\u03b1} (x : IO \u03b1) : CommandElabM \u03b1 := do\n  let ctx \u2190 read\n  IO.toEIO (fun (ex : IO.Error) => Exception.error ctx.ref ex.toString) x", "start": [177, 1], "end": [179, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getScope", "code": "def getScope : CommandElabM Scope := do pure (\u2190 get).scopes.head!", "start": [184, 1], "end": [184, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.runLinters", "code": "def runLinters (stx : Syntax) : CommandElabM Unit := do\n  profileitM Exception \"linting\" (\u2190 getOptions) do\n    withTraceNode `Elab.lint (fun _ => return m!\"running linters\") do\n      let linters \u2190 lintersRef.get\n      unless linters.isEmpty do\n        for linter in linters do\n          withTraceNode `Elab.lint (fun _ => return m!\"running linter: {linter.name}\") do\n            let savedState \u2190 get\n            try\n              linter.run stx\n            catch ex =>\n              logException ex\n            finally\n              modify fun s => { savedState with messages := s.messages }", "start": [201, 1], "end": [214, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getCurrMacroScope", "code": "protected def getCurrMacroScope : CommandElabM Nat  := do pure (\u2190 read).currMacroScope", "start": [216, 1], "end": [216, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getMainModule", "code": "protected def getMainModule     : CommandElabM Name := do pure (\u2190 getEnv).mainModule", "start": [217, 1], "end": [217, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withFreshMacroScope", "code": "protected def withFreshMacroScope {\u03b1} (x : CommandElabM \u03b1) : CommandElabM \u03b1 := do\n  let fresh \u2190 modifyGet (fun st => (st.nextMacroScope, { st with nextMacroScope := st.nextMacroScope + 1 }))\n  withReader (fun ctx => { ctx with currMacroScope := fresh }) x", "start": [219, 1], "end": [221, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkCommandElabAttributeUnsafe", "code": "unsafe def mkCommandElabAttributeUnsafe (ref : Name) : IO (KeyedDeclsAttribute CommandElab) :=\n  mkElabAttribute CommandElab `builtin_command_elab `command_elab `Lean.Parser.Command `Lean.Elab.Command.CommandElab \"command\" ref", "start": [228, 1], "end": [229, 132], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkCommandElabAttribute", "code": "@[implemented_by mkCommandElabAttributeUnsafe]\nopaque mkCommandElabAttribute (ref : Name) : IO (KeyedDeclsAttribute CommandElab)", "start": [231, 1], "end": [232, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkInfoTree", "code": "private def mkInfoTree (elaborator : Name) (stx : Syntax) (trees : PersistentArray InfoTree) : CommandElabM InfoTree := do\n  let ctx \u2190 read\n  let s \u2190 get\n  let scope := s.scopes.head!\n  let tree := InfoTree.node (Info.ofCommandInfo { elaborator, stx }) trees\n  return InfoTree.context {\n    env := s.env, fileMap := ctx.fileMap, mctx := {}, currNamespace := scope.currNamespace,\n    openDecls := scope.openDecls, options := scope.opts, ngen := s.ngen\n  } tree", "start": [236, 1], "end": [244, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabCommandUsing", "code": "private def elabCommandUsing (s : State) (stx : Syntax) : List (KeyedDeclsAttribute.AttributeEntry CommandElab) \u2192 CommandElabM Unit\n  | []                => withInfoTreeContext (mkInfoTree := mkInfoTree `no_elab stx) <| throwError \"unexpected syntax{indentD stx}\"\n  | (elabFn::elabFns) =>\n    catchInternalId unsupportedSyntaxExceptionId\n      (withInfoTreeContext (mkInfoTree := mkInfoTree elabFn.declName stx) <| elabFn.value stx)\n      (fun _ => do set s; elabCommandUsing s stx elabFns)", "start": [246, 1], "end": [251, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withMacroExpansion", "code": "def withMacroExpansion {\u03b1} (beforeStx afterStx : Syntax) (x : CommandElabM \u03b1) : CommandElabM \u03b1 :=\n  withInfoContext (mkInfo := pure <| .ofMacroExpansionInfo { stx := beforeStx, output := afterStx, lctx := .empty }) do\n    withReader (fun ctx => { ctx with macroStack := { before := beforeStx, after := afterStx } :: ctx.macroStack }) x", "start": [253, 1], "end": [256, 118], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabCommand", "code": "partial def elabCommand (stx : Syntax) : CommandElabM Unit := do\n  withLogging <| withRef stx <| withIncRecDepth <| withFreshMacroScope do\n    match stx with\n    | Syntax.node _ k args =>\n      if k == nullKind then\n        args.forM elabCommand\n      else withTraceNode `Elab.command (fun _ => return stx) do\n        let s \u2190 get\n        match (\u2190 liftMacroM <| expandMacroImpl? s.env stx) with\n        | some (decl, stxNew?) =>\n          withInfoTreeContext (mkInfoTree := mkInfoTree decl stx) do\n            let stxNew \u2190 liftMacroM <| liftExcept stxNew?\n            withMacroExpansion stx stxNew do\n              elabCommand stxNew\n        | _ =>\n          match commandElabAttribute.getEntries s.env k with\n          | []      =>\n            withInfoTreeContext (mkInfoTree := mkInfoTree `no_elab stx) <|\n              throwError \"elaboration function for '{k}' has not been implemented\"\n          | elabFns => elabCommandUsing s stx elabFns\n    | _ =>\n      withInfoTreeContext (mkInfoTree := mkInfoTree `no_elab stx) <|\n        throwError \"unexpected command\"", "start": [275, 1], "end": [299, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabCommandTopLevel", "code": "def elabCommandTopLevel (stx : Syntax) : CommandElabM Unit := withRef stx do profileitM Exception \"elaboration\" (\u2190 getOptions) do\n  let initMsgs \u2190 modifyGet fun st => (st.messages, { st with messages := {} })\n  let initInfoTrees \u2190 getResetInfoTrees\n  elabCommand stx\n  withLogging do\n    runLinters stx\n\n  let mut msgs := (\u2190 get).messages\n  if !showPartialSyntaxErrors.get (\u2190 getOptions) && initMsgs.hasErrors && stx.hasMissing then\n    msgs := \u27e8msgs.msgs.filter fun msg =>\n      msg.data.hasTag (fun tag => tag == `Elab.synthPlaceholder || tag == `Tactic.unsolvedGoals || (`_traceMsg).isSuffixOf tag)\u27e9\n  for tree in (\u2190 getInfoTrees) do\n    trace[Elab.info] (\u2190 tree.format)\n  modify fun st => { st with\n    messages := initMsgs ++ msgs\n    infoState := { st.infoState with trees := initInfoTrees ++ st.infoState.trees }\n  }\n  addTraceAsMessages", "start": [303, 1], "end": [331, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.adaptExpander", "code": "def adaptExpander (exp : Syntax \u2192 CommandElabM Syntax) : CommandElab := fun stx => do\n  let stx' \u2190 exp stx\n  withMacroExpansion stx stx' <| elabCommand stx'", "start": [333, 1], "end": [336, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getVarDecls", "code": "private def getVarDecls (s : State) : Array Syntax :=\n  s.scopes.head!.varDecls", "start": [338, 1], "end": [339, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkMetaContext", "code": "private def mkMetaContext : Meta.Context := {\n  config := { foApprox := true, ctxApprox := true, quasiPatternApprox := true }\n}", "start": [344, 1], "end": [346, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getBracketedBinderIds", "code": "def getBracketedBinderIds : Syntax \u2192 Array Name\n  | `(bracketedBinderF|($ids* $[: $ty?]? $(_annot?)?)) => ids.map Syntax.getId\n  | `(bracketedBinderF|{$ids* $[: $ty?]?})             => ids.map Syntax.getId\n  | `(bracketedBinderF|[$id : $_])                     => #[id.getId]\n  | `(bracketedBinderF|[$_])                           => #[Name.anonymous]\n  | _                                                 => #[]", "start": [349, 1], "end": [355, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.mkTermContext", "code": "private def mkTermContext (ctx : Context) (s : State) : Term.Context := Id.run do\n  let scope      := s.scopes.head!\n  let mut sectionVars := {}\n  for id in scope.varDecls.concatMap getBracketedBinderIds, uid in scope.varUIds do\n    sectionVars := sectionVars.insert id uid\n  { macroStack             := ctx.macroStack\n    sectionVars            := sectionVars\n    isNoncomputableSection := scope.isNoncomputable\n    tacticCache?           := ctx.tacticCache? }", "start": [357, 1], "end": [365, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.liftTermElabM", "code": "def liftTermElabM (x : TermElabM \u03b1) : CommandElabM \u03b1 := do\n  let ctx \u2190 read\n  let s   \u2190 get\n  let heartbeats \u2190 IO.getNumHeartbeats\n  let scope := s.scopes.head!\n  let x : TermElabM _  := withSaveInfoContext x\n  let x : MetaM _      := (observing x).run (mkTermContext ctx s) { levelNames := scope.levelNames }\n  let x : CoreM _      := x.run mkMetaContext {}\n  let x : EIO _ _      := x.run (mkCoreContext ctx s heartbeats) { env := s.env, ngen := s.ngen, nextMacroScope := s.nextMacroScope, infoState.enabled := s.infoState.enabled, traceState := s.traceState }\n  let (((ea, _), _), coreS) \u2190 liftEIO x\n  modify fun s => { s with\n    env               := coreS.env\n    nextMacroScope    := coreS.nextMacroScope\n    ngen              := coreS.ngen\n    infoState.trees   := s.infoState.trees.append coreS.infoState.trees\n    traceState.traces := coreS.traceState.traces.map fun t => { t with ref := replaceRef t.ref ctx.ref }\n    messages          := s.messages ++ coreS.messages\n  }\n  match ea with\n  | Except.ok a     => pure a\n  | Except.error ex => throw ex", "start": [367, 1], "end": [414, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.runTermElabM", "code": "def runTermElabM (elabFn : Array Expr \u2192 TermElabM \u03b1) : CommandElabM \u03b1 := do\n  let scope \u2190 getScope\n  liftTermElabM <|\n    Term.withAutoBoundImplicit <|\n      Term.elabBinders scope.varDecls fun xs => do\n        Term.synthesizeSyntheticMVarsNoPostponing\n        let mut sectionFVars := {}\n        for uid in scope.varUIds, x in xs do\n          sectionFVars := sectionFVars.insert uid x\n        withReader ({ \u00b7 with sectionFVars := sectionFVars }) do\n          Core.resetMessageLog\n          let someType := mkSort levelZero\n          Term.addAutoBoundImplicits' xs someType fun xs _ =>\n            Term.withoutAutoBoundImplicit <| elabFn xs", "start": [416, 1], "end": [455, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.catchExceptions", "code": "@[inline] def catchExceptions (x : CommandElabM Unit) : CommandElabCoreM Empty Unit := fun ctx ref =>\n  EIO.catchExceptions (withLogging x ctx ref) (fun _ => pure ())", "start": [457, 1], "end": [458, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.liftAttrM", "code": "private def liftAttrM {\u03b1} (x : AttrM \u03b1) : CommandElabM \u03b1 := do\n  liftCoreM x", "start": [460, 1], "end": [461, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getScopes", "code": "def getScopes : CommandElabM (List Scope) := do\n  pure (\u2190 get).scopes", "start": [463, 1], "end": [464, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.modifyScope", "code": "def modifyScope (f : Scope \u2192 Scope) : CommandElabM Unit :=\n  modify fun s => { s with\n    scopes := match s.scopes with\n      | h::t => f h :: t\n      | []   => unreachable!\n  }", "start": [466, 1], "end": [471, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withScope", "code": "def withScope (f : Scope \u2192 Scope) (x : CommandElabM \u03b1) : CommandElabM \u03b1 := do\n  match (\u2190 get).scopes with\n  | [] => x\n  | h :: t =>\n    try\n      modify fun s => { s with scopes := f h :: t }\n      x\n    finally\n      modify fun s => { s with scopes := h :: t }", "start": [473, 1], "end": [481, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.getLevelNames", "code": "def getLevelNames : CommandElabM (List Name) :=\n  return (\u2190 getScope).levelNames", "start": [483, 1], "end": [484, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.addUnivLevel", "code": "def addUnivLevel (idStx : Syntax) : CommandElabM Unit := withRef idStx do\n  let id := idStx.getId\n  let levelNames \u2190 getLevelNames\n  if levelNames.elem id then\n    throwAlreadyDeclaredUniverseLevel id\n  else\n    modifyScope fun scope => { scope with levelNames := id :: scope.levelNames }", "start": [486, 1], "end": [492, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.expandDeclId", "code": "def expandDeclId (declId : Syntax) (modifiers : Modifiers) : CommandElabM ExpandDeclIdResult := do\n  let currNamespace \u2190 getCurrNamespace\n  let currLevelNames \u2190 getLevelNames\n  let r \u2190 Elab.expandDeclId currNamespace currLevelNames declId modifiers\n  for id in (\u2190 getScope).varDecls.concatMap getBracketedBinderIds do\n    if id == r.shortName then\n      throwError \"invalid declaration name '{r.shortName}', there is a section variable with the same name\"\n  return r", "start": [494, 1], "end": [501, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/References.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Internal.lean", "lake-packages/lean4/src/lean/Lean/Server/Utils.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Server.Reference", "code": "structure Reference where\n  ident : RefIdent\n  \n  aliases : Array RefIdent := #[]\n  range : Lsp.Range\n  stx : Syntax\n  ci : ContextInfo\n  info : Info\n  isBinder : Bool", "start": [15, 1], "end": [23, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RefInfo", "code": "structure RefInfo where\n  definition : Option Reference\n  usages : Array Reference", "start": [25, 1], "end": [27, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RefInfo.empty", "code": "def empty : RefInfo := \u27e8 none, #[] \u27e9", "start": [31, 1], "end": [31, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RefInfo.addRef", "code": "def addRef : RefInfo \u2192 Reference \u2192 RefInfo\n  | i@{ definition := none, .. }, ref@{ isBinder := true, .. } =>\n    { i with definition := ref }\n  | i@{ usages, .. }, ref@{ isBinder := false, .. } =>\n    { i with usages := usages.push ref }\n  | i, _ => i", "start": [33, 1], "end": [38, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.ModuleRefs", "code": "def ModuleRefs := HashMap RefIdent RefInfo", "start": [49, 1], "end": [49, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.ModuleRefs.addRef", "code": "def addRef (self : ModuleRefs) (ref : Reference) : ModuleRefs :=\n  let refInfo := self.findD ref.ident RefInfo.empty\n  self.insert ref.ident (refInfo.addRef ref)", "start": [53, 1], "end": [55, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RefInfo.empty", "code": "def empty : RefInfo := \u27e8 none, #[] \u27e9", "start": [67, 1], "end": [67, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RefInfo.merge", "code": "def merge (a : RefInfo) (b : RefInfo) : RefInfo :=\n  {\n    definition := b.definition.orElse fun _ => a.definition\n    usages := a.usages.append b.usages\n  }", "start": [69, 1], "end": [73, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RefInfo.contains", "code": "def contains (self : RefInfo) (pos : Lsp.Position) : Bool := Id.run do\n  if let some range := self.definition then\n    if contains range pos then\n      return true\n  for range in self.usages do\n    if contains range pos then\n      return true\n  false\nwhere\n  contains (range : Lsp.Range) (pos : Lsp.Position) : Bool :=\n    range.start <= pos && pos < range.end", "start": [75, 1], "end": [85, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ModuleRefs.findAt", "code": "def findAt (self : ModuleRefs) (pos : Lsp.Position) : Array RefIdent := Id.run do\n  let mut result := #[]\n  for (ident, info) in self.toList do\n    if info.contains pos then\n      result := result.push ident\n  result", "start": [92, 1], "end": [97, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Ilean", "code": "structure Ilean where\n  version : Nat := 1\n  module : Name\n  references : Lsp.ModuleRefs\n  deriving FromJson, ToJson", "start": [106, 1], "end": [111, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Ilean.load", "code": "def load (path : System.FilePath) : IO Ilean := do\n  let content \u2190 FS.readFile path\n  match Json.parse content >>= fromJson? with\n    | Except.ok ilean => pure ilean\n    | Except.error msg => throwServerError s!\"Failed to load ilean at {path}: {msg}\"", "start": [115, 1], "end": [119, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.identOf", "code": "def identOf : Info \u2192 Option (RefIdent \u00d7 Bool)\n  | Info.ofTermInfo ti => match ti.expr with\n    | Expr.const n .. => some (RefIdent.const n, ti.isBinder)\n    | Expr.fvar id .. => some (RefIdent.fvar id, ti.isBinder)\n    | _ => none\n  | Info.ofFieldInfo fi => some (RefIdent.const fi.projName, false)\n  | Info.ofOptionInfo oi => some (RefIdent.const oi.declName, false)\n  | _ => none", "start": [124, 1], "end": [131, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.findReferences", "code": "def findReferences (text : FileMap) (trees : Array InfoTree) : Array Reference := Id.run <| StateT.run' (s := #[]) do\n  for tree in trees do\n    tree.visitM' (postNode := fun ci info _ => do\n      if let some (ident, isBinder) := identOf info then\n        if let some range := info.range? then\n          if info.stx.getHeadInfo matches .original .. then  modify (\u00b7.push { ident, range := range.toLspRange text, stx := info.stx, ci, info, isBinder }))\n  get", "start": [133, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.combineFvars", "code": "partial def combineFvars (trees : Array InfoTree) (refs : Array Reference) : Array Reference := Id.run do\n  let mut posMap : HashMap Lsp.Range FVarId := HashMap.empty\n  for ref in refs do\n    if let { ident := RefIdent.fvar id, range, isBinder := true, .. } := ref then\n      posMap := posMap.insert range id\n\n  let idMap := buildIdMap posMap\n\n  let mut refs' := #[]\n  for ref in refs do\n    match ref with\n    | { ident := ident@(RefIdent.fvar id), .. } =>\n      if idMap.contains id then\n        refs' := refs'.push { ref with ident := applyIdMap idMap ident, aliases := #[ident] }\n      else if !idMap.contains id then\n        refs' := refs'.push ref\n    | _ =>\n      refs' := refs'.push ref\n  refs'\nwhere\n  findCanonicalBinder (idMap : HashMap FVarId FVarId) (id : FVarId) : FVarId :=\n    match idMap.find? id with\n    | some id' => findCanonicalBinder idMap id'  | none     => id\n\n  applyIdMap : HashMap FVarId FVarId \u2192 RefIdent \u2192 RefIdent\n    | m, RefIdent.fvar id => RefIdent.fvar <| findCanonicalBinder m id\n    | _, ident => ident\n\n  buildIdMap posMap := Id.run <| StateT.run' (s := HashMap.empty) do\n    for ref in refs do\n      if let { ident := RefIdent.fvar baseId, range, .. } := ref then\n        if let some id := posMap.find? range then\n          insertIdMap id baseId\n\n    trees.forM (\u00b7.visitM' (postNode := fun _ info _ => do\n      if let .ofFVarAliasInfo ai := info then\n        insertIdMap ai.id ai.baseId))\n\n    get\n\n  insertIdMap id baseId := do\n    let idMap \u2190 get\n    let id := findCanonicalBinder idMap id\n    let baseId := findCanonicalBinder idMap baseId\n    if baseId != id then\n      modify (\u00b7.insert id baseId)", "start": [142, 1], "end": [202, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.dedupReferences", "code": "def dedupReferences (refs : Array Reference) (allowSimultaneousBinderUse := false) : Array Reference := Id.run do\n  let mut refsByIdAndRange : HashMap (RefIdent \u00d7 Option Bool \u00d7 Lsp.Range) Reference := HashMap.empty\n  for ref in refs do\n    let isBinder := if allowSimultaneousBinderUse then some ref.isBinder else none\n    let key := (ref.ident, isBinder, ref.range)\n    refsByIdAndRange := match refsByIdAndRange[key] with\n      | some ref' => refsByIdAndRange.insert key { ref' with aliases := ref'.aliases ++ ref.aliases }\n      | none => refsByIdAndRange.insert key ref\n\n  let dedupedRefs := refsByIdAndRange.fold (init := #[]) fun refs _ ref => refs.push ref\n  return dedupedRefs.qsort (\u00b7.range < \u00b7.range)", "start": [204, 1], "end": [214, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.findModuleRefs", "code": "def findModuleRefs (text : FileMap) (trees : Array InfoTree) (localVars : Bool := true)\n    (allowSimultaneousBinderUse := false) : ModuleRefs := Id.run do\n  let mut refs :=\n    dedupReferences (allowSimultaneousBinderUse := allowSimultaneousBinderUse) <|\n    combineFvars trees <|\n    findReferences text trees\n  if !localVars then\n    refs := refs.filter fun\n      | { ident := RefIdent.fvar _, .. } => false\n      | _ => true\n  refs.foldl (init := HashMap.empty) fun m ref => m.addRef ref", "start": [216, 1], "end": [226, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References", "code": "structure References where\n  \n  ileans : HashMap Name (System.FilePath \u00d7 Lsp.ModuleRefs)\n  \n  workers : HashMap Name (Nat \u00d7 Lsp.ModuleRefs)", "start": [230, 1], "end": [234, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.empty", "code": "def empty : References := { ileans := HashMap.empty, workers := HashMap.empty }", "start": [238, 1], "end": [238, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.addIlean", "code": "def addIlean (self : References) (path : System.FilePath) (ilean : Ilean) : References :=\n  { self with ileans := self.ileans.insert ilean.module (path, ilean.references) }", "start": [240, 1], "end": [241, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.removeIlean", "code": "def removeIlean (self : References) (path : System.FilePath) : References :=\n  let namesToRemove := self.ileans.toList.filter (fun (_, p, _) => p == path)\n    |>.map (fun (n, _, _) => n)\n  namesToRemove.foldl (init := self) fun self name =>\n    { self with ileans := self.ileans.erase name }", "start": [243, 1], "end": [247, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.updateWorkerRefs", "code": "def updateWorkerRefs (self : References) (name : Name) (version : Nat) (refs : Lsp.ModuleRefs) : References := Id.run do\n  if let some (currVersion, _) := self.workers.find? name then\n    if version > currVersion then\n      return { self with workers := self.workers.insert name (version, refs) }\n    if version == currVersion then\n      let current := self.workers.findD name (version, HashMap.empty)\n      let merged := refs.fold (init := current.snd) fun m ident info =>\n        m.findD ident Lsp.RefInfo.empty |>.merge info |> m.insert ident\n      return { self with workers := self.workers.insert name (version, merged) }\n  return self", "start": [249, 1], "end": [258, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.finalizeWorkerRefs", "code": "def finalizeWorkerRefs (self : References) (name : Name) (version : Nat) (refs : Lsp.ModuleRefs) : References := Id.run do\n  if let some (currVersion, _) := self.workers.find? name then\n    if version < currVersion then\n      return self\n  return { self with workers := self.workers.insert name (version, refs) }", "start": [260, 1], "end": [264, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.removeWorkerRefs", "code": "def removeWorkerRefs (self : References) (name : Name) : References :=\n  { self with workers := self.workers.erase name }", "start": [266, 1], "end": [267, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.allRefs", "code": "def allRefs (self : References) : HashMap Name Lsp.ModuleRefs :=\n  let ileanRefs := self.ileans.toList.foldl (init := HashMap.empty) fun m (name, _, refs) => m.insert name refs\n  self.workers.toList.foldl (init := ileanRefs) fun m (name, _, refs) => m.insert name refs", "start": [269, 1], "end": [271, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.findAt", "code": "def findAt (self : References) (module : Name) (pos : Lsp.Position) : Array RefIdent := Id.run do\n  if let some refs := self.allRefs.find? module then\n    return refs.findAt pos\n  #[]", "start": [273, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.referringTo", "code": "def referringTo (self : References) (identModule : Name) (ident : RefIdent) (srcSearchPath : SearchPath)\n    (includeDefinition : Bool := true) : IO (Array Location) := do\n  let refsToCheck := match ident with\n    | RefIdent.const _ => self.allRefs.toList\n    | RefIdent.fvar _ => match self.allRefs.find? identModule with\n      | none => []\n      | some refs => [(identModule, refs)]\n  let mut result := #[]\n  for (module, refs) in refsToCheck do\n    if let some info := refs.find? ident then\n      if let some path \u2190 srcSearchPath.findModuleWithExt \"lean\" module then\n        let uri := System.Uri.pathToUri <| \u2190 IO.FS.realPath path\n        if includeDefinition then\n          if let some range := info.definition then\n            result := result.push \u27e8uri, range\u27e9\n        for range in info.usages do\n          result := result.push \u27e8uri, range\u27e9\n  return result", "start": [278, 1], "end": [297, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.definitionOf?", "code": "def definitionOf? (self : References) (ident : RefIdent) (srcSearchPath : SearchPath)\n    : IO (Option Location) := do\n  for (module, refs) in self.allRefs.toList do\n    if let some info := refs.find? ident then\n      if let some definition := info.definition then\n        if let some path \u2190 srcSearchPath.findModuleWithExt \"lean\" module then\n          let uri := System.Uri.pathToUri <| \u2190 IO.FS.realPath path\n          return some \u27e8uri, definition\u27e9\n  return none", "start": [299, 1], "end": [309, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.References.definitionsMatching", "code": "def definitionsMatching (self : References) (srcSearchPath : SearchPath) (filter : Name \u2192 Option \u03b1)\n    (maxAmount? : Option Nat := none) : IO $ Array (\u03b1 \u00d7 Location) := do\n  let mut result := #[]\n  for (module, refs) in self.allRefs.toList do\n    if let some path \u2190 srcSearchPath.findModuleWithExt \"lean\" module then\n      let uri := System.Uri.pathToUri <| \u2190 IO.FS.realPath path\n      for (ident, info) in refs.toList do\n        if let (RefIdent.const name, some definition) := (ident, info.definition) then\n          if let some a := filter name then\n            result := result.push (a, \u27e8uri, definition\u27e9)\n            if let some maxAmount := maxAmount? then\n              if result.size >= maxAmount then\n                return result\n  return result", "start": [311, 1], "end": [324, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Linter/Util.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Linter/Basic.lean", "lake-packages/lean4/src/lean/Lean/Server/InfoUtils.lean", "lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Linter.logLint", "code": "def logLint [Monad m] [MonadLog m] [AddMessageContext m] [MonadOptions m]\n    (linterOption : Lean.Option Bool) (stx : Syntax) (msg : MessageData) : m Unit :=\n  logWarningAt stx (.tagged linterOption.name m!\"{msg} [{linterOption.name}]\")", "start": [9, 1], "end": [11, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.collectMacroExpansions?", "code": "def collectMacroExpansions? {m} [Monad m] (range : String.Range) (tree : Elab.InfoTree) : m <| Option <| List Elab.MacroExpansionInfo := do\n  if let .some <| .some result \u2190 go then\n    return some result.reverse\n  else\n    return none\nwhere\n  go : m <| Option <| Option <| List Elab.MacroExpansionInfo := tree.visitM (postNode := fun _ i _ results => do\n    let results := results |>.filterMap id |>.filterMap id\n\n    if let results :: _ := results then\n      if let .ofMacroExpansionInfo i := i then\n        return some <| i :: results\n      else\n        return some results\n    else if i.contains range.start && i.contains (includeStop := true) range.stop then\n      if let .ofMacroExpansionInfo i := i then\n        return some [i]\n      else\n        return some []\n    else\n      return none)", "start": [13, 1], "end": [41, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/CodeActions.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Diagnostics.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.CodeActionKind", "code": "abbrev CodeActionKind := String", "start": [15, 1], "end": [32, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CodeActionTriggerKind", "code": "inductive CodeActionTriggerKind\n  \n  | invoked\n  \n  | automatic", "start": [34, 1], "end": [41, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CodeActionContext", "code": "structure CodeActionContext where\n  \n  diagnostics : Array Diagnostic := #[]\n  \n  only? : Option (Array CodeActionKind) := none\n  \n  triggerKind? : Option CodeActionTriggerKind := none\n  deriving FromJson, ToJson", "start": [56, 1], "end": [77, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CodeActionParams", "code": "structure CodeActionParams extends WorkDoneProgressParams, PartialResultParams where\n  textDocument : TextDocumentIdentifier\n  range        : Range\n  context      : CodeActionContext := {}\n  deriving FromJson, ToJson", "start": [79, 1], "end": [84, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CodeActionDisabled", "code": "structure CodeActionDisabled where\n  reason : String\n  deriving FromJson, ToJson", "start": [86, 1], "end": [89, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CodeActionOptions", "code": "structure CodeActionOptions extends WorkDoneProgressOptions where\n  \n  codeActionKinds? : Option (Array CodeActionKind) := none\n  \n  resolveProvider? : Option Bool := none\n  deriving ToJson, FromJson", "start": [91, 1], "end": [99, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CodeAction", "code": "structure CodeAction extends WorkDoneProgressParams, PartialResultParams where\n  \n  title        : String\n  \n  kind?        : Option CodeActionKind := none\n  \n  diagnostics? : Option (Array Diagnostic) := none\n  \n  isPreferred? : Option Bool := none\n  \n  disabled?    : Option CodeActionDisabled := none\n  \n  edit?        : Option WorkspaceEdit := none\n  \n  command?     : Option Command := none\n  \n  data?        : Option Json := none\n  deriving ToJson, FromJson", "start": [101, 1], "end": [129, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ResolveSupport", "code": "structure ResolveSupport where\n  properties : Array String\n  deriving FromJson, ToJson", "start": [131, 1], "end": [133, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CodeActionLiteralSupportValueSet", "code": "structure CodeActionLiteralSupportValueSet where\n  \n  valueSet : Array CodeActionKind\n  deriving FromJson, ToJson", "start": [135, 1], "end": [142, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CodeActionLiteralSupport", "code": "structure CodeActionLiteralSupport where\n  \n  codeActionKind : CodeActionLiteralSupportValueSet\n  deriving FromJson, ToJson", "start": [144, 1], "end": [147, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CodeActionClientCapabilities", "code": "structure CodeActionClientCapabilities where\n  \n  dynamicRegistration?      : Option Bool := false\n  \n  isPreferredSupport?       : Option Bool := false\n  \n  disabledSupport?          : Option Bool := false\n  \n  dataSupport?              : Option Bool := false\n  \n  honorsChangeAnnotations?  : Option Bool := false\n  \n  codeActionLiteralSupport? : Option CodeActionLiteralSupport := none\n  \n  resolveSupport?           : Option ResolveSupport           := none\n  deriving FromJson, ToJson", "start": [149, 1], "end": [169, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/LanguageFeatures.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.CompletionOptions", "code": "structure CompletionOptions where\n  triggerCharacters?   : Option (Array String) := none\n  allCommitCharacters? : Option (Array String) := none\n  resolveProvider      : Bool := false\n  deriving FromJson, ToJson", "start": [15, 1], "end": [19, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CompletionItemKind", "code": "inductive CompletionItemKind where\n  | text | method | function | constructor | field\n  | variable | class | interface | module | property\n  | unit | value | enum | keyword | snippet\n  | color | file | reference | folder | enumMember\n  | constant | struct | event | operator | typeParameter\n  deriving Inhabited, DecidableEq, Repr", "start": [21, 1], "end": [27, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.InsertReplaceEdit", "code": "structure InsertReplaceEdit where\n  newText : String\n  insert : Range\n  replace : Range\n  deriving FromJson, ToJson", "start": [37, 1], "end": [41, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CompletionItem", "code": "structure CompletionItem where\n  label : String\n  detail? : Option String := none\n  documentation? : Option MarkupContent := none\n  kind? : Option CompletionItemKind := none\n  textEdit? : Option InsertReplaceEdit := none\n  \n  deriving FromJson, ToJson, Inhabited", "start": [43, 1], "end": [62, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CompletionList", "code": "structure CompletionList where\n  isIncomplete : Bool\n  items : Array CompletionItem\n  deriving FromJson, ToJson", "start": [64, 1], "end": [67, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CompletionParams", "code": "structure CompletionParams extends TextDocumentPositionParams where\n  deriving FromJson, ToJson", "start": [69, 1], "end": [71, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Hover", "code": "structure Hover where\n  \n  contents : MarkupContent\n  range? : Option Range := none\n  deriving ToJson, FromJson", "start": [73, 1], "end": [78, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.HoverParams", "code": "structure HoverParams extends TextDocumentPositionParams\n  deriving FromJson, ToJson", "start": [80, 1], "end": [81, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DeclarationParams", "code": "structure DeclarationParams extends TextDocumentPositionParams\n  deriving FromJson, ToJson", "start": [83, 1], "end": [84, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DefinitionParams", "code": "structure DefinitionParams extends TextDocumentPositionParams\n  deriving FromJson, ToJson", "start": [86, 1], "end": [87, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TypeDefinitionParams", "code": "structure TypeDefinitionParams extends TextDocumentPositionParams\n  deriving FromJson, ToJson", "start": [89, 1], "end": [90, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ReferenceContext", "code": "structure ReferenceContext where\n  includeDeclaration : Bool\n  deriving FromJson, ToJson", "start": [92, 1], "end": [94, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ReferenceParams", "code": "structure ReferenceParams extends TextDocumentPositionParams where\n  context : ReferenceContext\n  deriving FromJson, ToJson", "start": [96, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkspaceSymbolParams", "code": "structure WorkspaceSymbolParams where\n  query : String\n  deriving FromJson, ToJson", "start": [100, 1], "end": [102, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentHighlightParams", "code": "structure DocumentHighlightParams extends TextDocumentPositionParams\n  deriving FromJson, ToJson", "start": [104, 1], "end": [105, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentHighlightKind", "code": "inductive DocumentHighlightKind where\n  | text\n  | read\n  | write", "start": [107, 1], "end": [110, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentHighlight", "code": "structure DocumentHighlight where\n  range : Range\n  kind? : Option DocumentHighlightKind := none\n  deriving ToJson", "start": [118, 1], "end": [121, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentHighlightResult", "code": "abbrev DocumentHighlightResult := Array DocumentHighlight", "start": [123, 1], "end": [123, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentSymbolParams", "code": "structure DocumentSymbolParams where\n  textDocument : TextDocumentIdentifier\n  deriving FromJson, ToJson", "start": [125, 1], "end": [127, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SymbolKind", "code": "inductive SymbolKind where\n  | file\n  | module\n  | namespace\n  | package\n  | class\n  | method\n  | property\n  | field\n  | constructor\n  | enum\n  | interface\n  | function\n  | variable\n  | constant\n  | string\n  | number\n  | boolean\n  | array\n  | object\n  | key\n  | null\n  | enumMember\n  | struct\n  | event\n  | operator\n  | typeParameter", "start": [129, 1], "end": [155, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentSymbolAux", "code": "structure DocumentSymbolAux (Self : Type) where\n  name : String\n  detail? : Option String := none\n  kind : SymbolKind\n  range : Range\n  selectionRange : Range\n  children? : Option (Array Self) := none\n  deriving ToJson", "start": [186, 1], "end": [194, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentSymbol", "code": "inductive DocumentSymbol where\n  | mk (sym : DocumentSymbolAux DocumentSymbol)", "start": [196, 1], "end": [197, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DocumentSymbolResult", "code": "structure DocumentSymbolResult where\n  syms : Array DocumentSymbol", "start": [207, 1], "end": [208, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SymbolTag", "code": "inductive SymbolTag where\n  | deprecated", "start": [213, 1], "end": [214, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SymbolInformation", "code": "structure SymbolInformation where\n  name : String\n  kind : SymbolKind\n  tags : Array SymbolTag := #[]\n  location : Location\n  containerName? : Option String := none\n  deriving ToJson", "start": [220, 1], "end": [226, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokenType", "code": "inductive SemanticTokenType where\n  | keyword\n  | variable\n  | property\n  | function\n  \n  | namespace\n  | type\n  | class\n  | enum\n  | interface\n  | struct\n  | typeParameter\n  | parameter\n  | enumMember\n  | event\n  | method\n  | macro\n  | modifier\n  | comment\n  | string\n  | number\n  | regexp\n  | operator\n  | decorator\n  | leanSorryLike\n  deriving ToJson, FromJson", "start": [228, 1], "end": [257, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokenType.names", "code": "def SemanticTokenType.names : Array String :=\n  #[\"keyword\", \"variable\", \"property\", \"function\", \"namespace\", \"type\", \"class\",\n    \"enum\", \"interface\", \"struct\", \"typeParameter\", \"parameter\", \"enumMember\",\n    \"event\", \"method\", \"macro\", \"modifier\", \"comment\", \"string\", \"number\",\n    \"regexp\", \"operator\", \"decorator\", \"leanSorryLike\"]", "start": [260, 1], "end": [264, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokenType.toNat", "code": "def SemanticTokenType.toNat (type : SemanticTokenType) : Nat :=\n  type.toCtorIdx", "start": [266, 1], "end": [267, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokenModifier", "code": "inductive SemanticTokenModifier where\n  | declaration\n  | definition\n  | readonly\n  | static\n  | deprecated\n  | abstract\n  | async\n  | modification\n  | documentation\n  | defaultLibrary\n  deriving ToJson, FromJson", "start": [275, 1], "end": [291, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokenModifier.names", "code": "def SemanticTokenModifier.names : Array String :=\n  #[\"declaration\", \"definition\", \"readonly\", \"static\", \"deprecated\", \"abstract\",\n    \"async\", \"modification\", \"documentation\", \"defaultLibrary\"]", "start": [294, 1], "end": [296, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokenModifier.toNat", "code": "def SemanticTokenModifier.toNat (modifier : SemanticTokenModifier) : Nat :=\n  modifier.toCtorIdx", "start": [298, 1], "end": [299, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokensLegend", "code": "structure SemanticTokensLegend where\n  tokenTypes : Array String\n  tokenModifiers : Array String\n  deriving FromJson, ToJson", "start": [306, 1], "end": [309, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokensOptions", "code": "structure SemanticTokensOptions where\n  legend : SemanticTokensLegend\n  range : Bool\n  full : Bool \n  deriving FromJson, ToJson", "start": [311, 1], "end": [317, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokensParams", "code": "structure SemanticTokensParams where\n  textDocument : TextDocumentIdentifier\n  deriving FromJson, ToJson", "start": [319, 1], "end": [321, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokensRangeParams", "code": "structure SemanticTokensRangeParams where\n  textDocument : TextDocumentIdentifier\n  range : Range\n  deriving FromJson, ToJson", "start": [323, 1], "end": [326, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.SemanticTokens", "code": "structure SemanticTokens where\n  resultId? : Option String := none\n  data : Array Nat\n  deriving FromJson, ToJson", "start": [328, 1], "end": [331, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.FoldingRangeParams", "code": "structure FoldingRangeParams where\n  textDocument : TextDocumentIdentifier\n  deriving FromJson, ToJson", "start": [333, 1], "end": [335, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.FoldingRangeKind", "code": "inductive FoldingRangeKind where\n  | comment\n  | imports\n  | region", "start": [337, 1], "end": [340, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.FoldingRange", "code": "structure FoldingRange where\n  startLine : Nat\n  endLine : Nat\n  kind? : Option FoldingRangeKind := none\n  deriving ToJson", "start": [348, 1], "end": [352, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/CollectMVars.lean", "lake-packages/lean4/src/lean/Lean/Util/FindMVar.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/SynthInstance.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean"], "premises": [{"full_name": "Lean.Meta.ApplyNewGoals", "code": "inductive ApplyNewGoals where\n  | nonDependentFirst | nonDependentOnly | all", "start": [12, 1], "end": [18, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ApplyConfig", "code": "structure ApplyConfig where\n  newGoals := ApplyNewGoals.nonDependentFirst\n  \n  synthAssignedInstances := true\n  \n  allowSynthFailures := false\n  \n  approx : Bool := true", "start": [20, 1], "end": [38, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getExpectedNumArgsAux", "code": "def getExpectedNumArgsAux (e : Expr) : MetaM (Nat \u00d7 Bool) :=\n  withDefault <| forallTelescopeReducing e fun xs body =>\n    pure (xs.size, body.getAppFn.isMVar)", "start": [40, 1], "end": [46, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getExpectedNumArgs", "code": "def getExpectedNumArgs (e : Expr) : MetaM Nat := do\n  let (numArgs, _) \u2190 getExpectedNumArgsAux e\n  pure numArgs", "start": [48, 1], "end": [50, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwApplyError", "code": "private def throwApplyError {\u03b1} (mvarId : MVarId) (eType : Expr) (targetType : Expr) : MetaM \u03b1 :=\n  throwTacticEx `apply mvarId m!\"failed to unify{indentExpr eType}\\nwith{indentExpr targetType}\"", "start": [52, 1], "end": [53, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.synthAppInstances", "code": "def synthAppInstances (tacticName : Name) (mvarId : MVarId) (newMVars : Array Expr) (binderInfos : Array BinderInfo)\n    (synthAssignedInstances : Bool) (allowSynthFailures : Bool) : MetaM Unit :=\n  newMVars.size.forM fun i => do\n    if binderInfos[i]!.isInstImplicit then\n      let mvar := newMVars[i]!\n      if synthAssignedInstances || !(\u2190 mvar.mvarId!.isAssigned) then\n        let mvarType \u2190 inferType mvar\n        try\n          let mvarVal  \u2190 synthInstance mvarType\n          unless (\u2190 isDefEq mvar mvarVal) do\n            throwTacticEx tacticName mvarId \"failed to assign synthesized instance\"\n        catch e => unless allowSynthFailures do throw e", "start": [55, 1], "end": [66, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.appendParentTag", "code": "def appendParentTag (mvarId : MVarId) (newMVars : Array Expr) (binderInfos : Array BinderInfo) : MetaM Unit := do\n  let parentTag \u2190 mvarId.getTag\n  if newMVars.size == 1 then\n    newMVars[0]!.mvarId!.setTag parentTag\n  else\n    unless parentTag.isAnonymous do\n      newMVars.size.forM fun i => do\n        let mvarIdNew := newMVars[i]!.mvarId!\n        unless (\u2190 mvarIdNew.isAssigned) do\n          unless binderInfos[i]!.isInstImplicit do\n            let currTag \u2190 mvarIdNew.getTag\n            mvarIdNew.setTag (appendTag parentTag currTag)", "start": [68, 1], "end": [80, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.postprocessAppMVars", "code": "def postprocessAppMVars (tacticName : Name) (mvarId : MVarId) (newMVars : Array Expr) (binderInfos : Array BinderInfo)\n    (synthAssignedInstances := true) (allowSynthFailures := false) : MetaM Unit := do\n  synthAppInstances tacticName mvarId newMVars binderInfos synthAssignedInstances allowSynthFailures\n  appendParentTag mvarId newMVars binderInfos", "start": [82, 1], "end": [91, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.dependsOnOthers", "code": "private def dependsOnOthers (mvar : Expr) (otherMVars : Array Expr) : MetaM Bool :=\n  otherMVars.anyM fun otherMVar => do\n    if mvar == otherMVar then\n      return false\n    else\n      let otherMVarType \u2190 inferType otherMVar\n      return (otherMVarType.findMVar? fun mvarId => mvarId == mvar.mvarId!).isSome", "start": [93, 1], "end": [99, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.partitionDependentMVars", "code": "private def partitionDependentMVars (mvars : Array Expr) : MetaM (Array MVarId \u00d7 Array MVarId) :=\n  mvars.foldlM (init := (#[], #[])) fun (nonDeps, deps) mvar => do\n    let currMVarId := mvar.mvarId!\n    if (\u2190 dependsOnOthers mvar mvars) then\n      return (nonDeps, deps.push currMVarId)\n    else\n      return (nonDeps.push currMVarId, deps)", "start": [101, 1], "end": [109, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reorderGoals", "code": "private def reorderGoals (mvars : Array Expr) : ApplyNewGoals \u2192 MetaM (List MVarId)\n  | ApplyNewGoals.nonDependentFirst => do\n      let (nonDeps, deps) \u2190 partitionDependentMVars mvars\n      return nonDeps.toList ++ deps.toList\n  | ApplyNewGoals.nonDependentOnly => do\n      let (nonDeps, _) \u2190 partitionDependentMVars mvars\n      return nonDeps.toList\n  | ApplyNewGoals.all => return mvars.toList.map Lean.Expr.mvarId!", "start": [111, 1], "end": [118, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqApply", "code": "private def isDefEqApply (cfg : ApplyConfig) (a b : Expr) : MetaM Bool := do\n  if cfg.approx then\n    approxDefEq <| isDefEqGuarded a b\n  else\n    isDefEqGuarded a b", "start": [120, 1], "end": [125, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.apply", "code": "def _root_.Lean.MVarId.apply (mvarId : MVarId) (e : Expr) (cfg : ApplyConfig := {}) : MetaM (List MVarId) :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `apply\n    let targetType \u2190 mvarId.getType\n    let eType      \u2190 inferType e\n    let (numArgs, hasMVarHead) \u2190 getExpectedNumArgsAux eType\n    \n    let rangeNumArgs \u2190 if hasMVarHead then\n      pure [numArgs : numArgs+1]\n    else\n      let targetTypeNumArgs \u2190 getExpectedNumArgs targetType\n      pure [numArgs - targetTypeNumArgs : numArgs+1]\n    \n    let rec go (i : Nat) : MetaM (Array Expr \u00d7 Array BinderInfo) := do\n      if i < rangeNumArgs.stop then\n        let s \u2190 saveState\n        let (newMVars, binderInfos, eType) \u2190 forallMetaTelescopeReducing eType i\n        if (\u2190 isDefEqApply cfg eType targetType) then\n          return (newMVars, binderInfos)\n        else\n          s.restore\n          go (i+1)\n      else\n        let (_, _, eType) \u2190 forallMetaTelescopeReducing eType (some rangeNumArgs.start)\n        throwApplyError mvarId eType targetType\n    let (newMVars, binderInfos) \u2190 go rangeNumArgs.start\n    postprocessAppMVars `apply mvarId newMVars binderInfos cfg.synthAssignedInstances cfg.allowSynthFailures\n    let e \u2190 instantiateMVars e\n    mvarId.assign (mkAppN e newMVars)\n    let newMVars \u2190 newMVars.filterM fun mvar => not <$> mvar.mvarId!.isAssigned\n    let otherMVarIds \u2190 getMVarsNoDelayed e\n    let newMVarIds \u2190 reorderGoals newMVars cfg.newGoals\n    let otherMVarIds := otherMVarIds.filter fun mvarId => !newMVarIds.contains mvarId\n    let result := newMVarIds ++ otherMVarIds.toList\n    result.forM (\u00b7.headBetaType)\n    return result\ntermination_by go i => rangeNumArgs.stop - i", "start": [127, 1], "end": [185, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.apply", "code": "@[deprecated MVarId.apply]\ndef apply (mvarId : MVarId) (e : Expr) (cfg : ApplyConfig := {}) : MetaM (List MVarId) :=\n  mvarId.apply e cfg", "start": [187, 1], "end": [189, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.splitAndCore", "code": "partial def splitAndCore (mvarId : MVarId) : MetaM (List MVarId) :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `splitAnd\n    let type \u2190 mvarId.getType'\n    if !type.isAppOfArity ``And 2 then\n      return [mvarId]\n    else\n      let tag \u2190 mvarId.getTag\n      let rec go (type : Expr) : StateRefT (Array MVarId) MetaM Expr := do\n        let type \u2190 whnf type\n        if type.isAppOfArity ``And 2 then\n          let p\u2081 := type.appFn!.appArg!\n          let p\u2082 := type.appArg!\n          return mkApp4 (mkConst ``And.intro) p\u2081 p\u2082 (\u2190 go p\u2081) (\u2190 go p\u2082)\n        else\n          let idx := (\u2190 get).size + 1\n          let mvar \u2190 mkFreshExprSyntheticOpaqueMVar type (tag ++ (`h).appendIndexAfter idx)\n          modify fun s => s.push mvar.mvarId!\n          return mvar\n      let (val, s) \u2190 go type |>.run #[]\n      mvarId.assign val\n      return s.toList", "start": [191, 1], "end": [212, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.splitAnd", "code": "abbrev _root_.Lean.MVarId.splitAnd (mvarId : MVarId) : MetaM (List MVarId) :=\n  splitAndCore mvarId", "start": [214, 1], "end": [218, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.splitAnd", "code": "@[deprecated MVarId.splitAnd]\ndef splitAnd (mvarId : MVarId) : MetaM (List MVarId) :=\n  mvarId.splitAnd", "start": [220, 1], "end": [222, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.exfalso", "code": "def _root_.Lean.MVarId.exfalso (mvarId : MVarId) : MetaM MVarId :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `exfalso\n    let target \u2190 instantiateMVars (\u2190 mvarId.getType)\n    let u \u2190 getLevel target\n    let mvarIdNew \u2190 mkFreshExprSyntheticOpaqueMVar (mkConst ``False) (tag := (\u2190 mvarId.getTag))\n    mvarId.assign (mkApp2 (mkConst ``False.elim [u]) target mvarIdNew)\n    return mvarIdNew.mvarId!", "start": [224, 1], "end": [231, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/UnifyEq.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Replace.lean"], "premises": [{"full_name": "Lean.Meta.Simp.throwCongrHypothesisFailed", "code": "def throwCongrHypothesisFailed : MetaM \u03b1 :=\n  throw <| Exception.internal congrHypothesisExceptionId", "start": [17, 1], "end": [18, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Config.updateArith", "code": "def Config.updateArith (c : Config) : CoreM Config := do\n  if c.arith then\n    if (\u2190 getEnv).contains ``Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq then\n      return c\n    else\n      return { c with arith := false }\n  else\n    return c", "start": [20, 1], "end": [30, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Result.getProof", "code": "def Result.getProof (r : Result) : MetaM Expr := do\n  match r.proof? with\n  | some p => return p\n  | none   => mkEqRefl r.expr", "start": [32, 1], "end": [35, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Result.getProof'", "code": "def Result.getProof' (source : Expr) (r : Result) : MetaM Expr := do\n  match r.proof? with\n  | some p => return p\n  | none   =>\n    if (\u2190 isDefEq source r.expr) then\n      mkEqRefl r.expr\n    else\n      \n      mkExpectedTypeHint (\u2190 mkEqRefl r.expr) (\u2190 mkEq source r.expr)", "start": [37, 1], "end": [50, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.mkCongrFun", "code": "def mkCongrFun (r : Result) (a : Expr) : MetaM Result :=\n  match r.proof? with\n  | none   => return { expr := mkApp r.expr a, proof? := none }\n  | some h => return { expr := mkApp r.expr a, proof? := (\u2190 Meta.mkCongrFun h a) }", "start": [52, 1], "end": [55, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.mkCongr", "code": "def mkCongr (r\u2081 r\u2082 : Result) : MetaM Result :=\n  let e := mkApp r\u2081.expr r\u2082.expr\n  match r\u2081.proof?, r\u2082.proof? with\n  | none,     none   => return { expr := e, proof? := none }\n  | some h,  none    => return { expr := e, proof? := (\u2190 Meta.mkCongrFun h r\u2082.expr) }\n  | none,    some h  => return { expr := e, proof? := (\u2190 Meta.mkCongrArg r\u2081.expr h) }\n  | some h\u2081, some h\u2082 => return { expr := e, proof? := (\u2190 Meta.mkCongr h\u2081 h\u2082) }", "start": [57, 1], "end": [63, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.mkImpCongr", "code": "private def mkImpCongr (src : Expr) (r\u2081 r\u2082 : Result) : MetaM Result := do\n  let e := src.updateForallE! r\u2081.expr r\u2082.expr\n  match r\u2081.proof?, r\u2082.proof? with\n  | none,     none   => return { expr := e, proof? := none }\n  | _,        _      => return { expr := e, proof? := (\u2190 Meta.mkImpCongr (\u2190 r\u2081.getProof) (\u2190 r\u2082.getProof)) }", "start": [65, 1], "end": [69, 108], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.isOfNatNatLit", "code": "def isOfNatNatLit (e : Expr) : Bool :=\n  e.isAppOfArity ``OfNat.ofNat 3 && e.appFn!.appArg!.isNatLit", "start": [71, 1], "end": [73, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.reduceProj", "code": "private def reduceProj (e : Expr) : MetaM Expr := do\n  match (\u2190 reduceProj? e) with\n  | some e => return e\n  | _      => return e", "start": [75, 1], "end": [78, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.reduceProjFn?", "code": "private def reduceProjFn? (e : Expr) : SimpM (Option Expr) := do\n  matchConst e.getAppFn (fun _ => pure none) fun cinfo _ => do\n    match (\u2190 getProjectionFnInfo? cinfo.name) with\n    | none => return none\n    | some projInfo =>\n      \n      let reduceProjCont? (e? : Option Expr) : SimpM (Option Expr) := do\n        match e? with\n        | none   => pure none\n        | some e =>\n          match (\u2190 reduceProj? e.getAppFn) with\n          | some f => return some (mkAppN f e.getAppArgs)\n          | none   => return none\n      if projInfo.fromClass then\n        if (\u2190 read).isDeclToUnfold cinfo.name then\n          \n          let e? \u2190 withReducibleAndInstances <| unfoldDefinition? e\n          if e?.isSome then\n            recordSimpTheorem (.decl cinfo.name)\n          return e?\n        else\n          \n          unless e.getAppNumArgs > projInfo.numParams do\n            return none\n          let major := e.getArg! projInfo.numParams\n          unless major.isConstructorApp (\u2190 getEnv) do\n            return none\n          reduceProjCont? (\u2190 withDefault <| unfoldDefinition? e)\n      else\n        reduceProjCont? (\u2190 unfoldDefinition? e)", "start": [80, 1], "end": [119, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.reduceFVar", "code": "private def reduceFVar (cfg : Config) (e : Expr) : MetaM Expr := do\n  if cfg.zeta then\n    match (\u2190 getFVarLocalDecl e).value? with\n    | some v => return v\n    | none   => return e\n  else\n    return e", "start": [121, 1], "end": [127, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.isMatchDef", "code": "private partial def isMatchDef (declName : Name) : CoreM Bool := do\n  let .defnInfo info \u2190 getConstInfo declName | return false\n  return go (\u2190 getEnv) info.value\nwhere\n  go (env : Environment) (e : Expr) : Bool :=\n    if e.isLambda then\n      go env e.bindingBody!\n    else\n      let f := e.getAppFn\n      f.isConst && isMatcherCore env f.constName!", "start": [129, 1], "end": [146, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.unfold?", "code": "private def unfold? (e : Expr) : SimpM (Option Expr) := do\n  let f := e.getAppFn\n  if !f.isConst then\n    return none\n  let fName := f.constName!\n  if (\u2190 isProjectionFn fName) then\n    return none let ctx \u2190 read\n  if ctx.config.autoUnfold then\n    if ctx.simpTheorems.isErased (.decl fName) then\n      return none\n    else if hasSmartUnfoldingDecl (\u2190 getEnv) fName then\n      withDefault <| unfoldDefinition? e\n    else if (\u2190 isMatchDef fName) then\n      let some value \u2190 withDefault <| unfoldDefinition? e | return none\n      let .reduced value \u2190 reduceMatcher? value | return none\n      return some value\n    else\n      return none\n  else if ctx.isDeclToUnfold fName then\n    withDefault <| unfoldDefinition? e\n  else\n    return none", "start": [148, 1], "end": [170, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.reduce", "code": "private partial def reduce (e : Expr) : SimpM Expr := withIncRecDepth do\n  let cfg := (\u2190 read).config\n  if e.getAppFn.isMVar then\n    let e' \u2190 instantiateMVars e\n    if e' != e then\n      return (\u2190 reduce e')\n  if cfg.beta then\n    let e' := e.headBeta\n    if e' != e then\n      return (\u2190 reduce e')\n  if cfg.proj then\n    match (\u2190 reduceProjFn? e) with\n    | some e => return (\u2190 reduce e)\n    | none   => pure ()\n  if cfg.iota then\n    match (\u2190 reduceRecMatcher? e) with\n    | some e => return (\u2190 reduce e)\n    | none   => pure ()\n  match (\u2190 unfold? e) with\n  | some e' =>\n    trace[Meta.Tactic.simp.rewrite] \"unfold {mkConst e.getAppFn.constName!}, {e} ==> {e'}\"\n    recordSimpTheorem (.decl e.getAppFn.constName!)\n    reduce e'\n  | none => return e", "start": [172, 1], "end": [196, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.dsimp", "code": "private partial def dsimp (e : Expr) : M Expr := do\n  let cfg \u2190 getConfig\n  unless cfg.dsimp do\n    return e\n  let pre (e : Expr) : M TransformStep := do\n    if let Step.visit r \u2190 rewritePre e (fun _ => pure none) (rflOnly := true) then\n      if r.expr != e then\n        return .visit r.expr\n    return .continue\n  let post (e : Expr) : M TransformStep := do\n    if let Step.visit r \u2190 rewritePost e (fun _ => pure none) (rflOnly := true) then\n      if r.expr != e then\n        return .visit r.expr\n    let mut eNew \u2190 reduce e\n    if cfg.zeta && eNew.isFVar then\n      eNew \u2190 reduceFVar cfg eNew\n    if eNew != e then return .visit eNew else return .done e\n  transform (usedLetOnly := cfg.zeta) e (pre := pre) (post := post)", "start": [198, 1], "end": [215, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.lambdaTelescopeDSimp", "code": "partial def lambdaTelescopeDSimp (e : Expr) (k : Array Expr \u2192 Expr \u2192 M \u03b1) : M \u03b1 := do\n  go #[] e\nwhere\n  go (xs : Array Expr) (e : Expr) : M \u03b1 := do\n    match e with\n    | .lam n d b c => withLocalDecl n c (\u2190 dsimp d) fun x => go (xs.push x) (b.instantiate1 x)\n    | e => k xs e", "start": [220, 1], "end": [226, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.SimpLetCase", "code": "inductive SimpLetCase where\n  | dep | nondepDepVar | nondep", "start": [228, 1], "end": [231, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.getSimpLetCase", "code": "def getSimpLetCase (n : Name) (t : Expr) (b : Expr) : MetaM SimpLetCase := do\n  withLocalDeclD n t fun x => do\n    let bx := b.instantiate1 x\n    \n    if (\u2190 isTypeCorrect bx) then\n      let bxType \u2190 whnf (\u2190 inferType bx)\n      if (\u2190 dependsOn bxType x.fvarId!) then\n        return SimpLetCase.nondepDepVar\n      else\n        return SimpLetCase.nondep\n    else\n      return SimpLetCase.dep", "start": [233, 1], "end": [245, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.removeUnnecessaryCasts", "code": "partial def removeUnnecessaryCasts (e : Expr) : MetaM Expr := do\n  let mut args := e.getAppArgs\n  let mut modified := false\n  for i in [:args.size] do\n    let arg := args[i]!\n    if isDummyEqRec arg then\n      args := args.set! i (elimDummyEqRec arg)\n      modified := true\n  if modified then\n    return mkAppN e.getAppFn args\n  else\n    return e\nwhere\n  isDummyEqRec (e : Expr) : Bool :=\n    (e.isAppOfArity ``Eq.rec 6 || e.isAppOfArity ``Eq.ndrec 6) && e.appArg!.isAppOf ``Eq.refl\n\n  elimDummyEqRec (e : Expr) : Expr :=\n    if isDummyEqRec e then\n      elimDummyEqRec e.appFn!.appFn!.appArg!\n    else\n      e", "start": [247, 1], "end": [268, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.simp", "code": "partial def simp (e : Expr) : M Result := withIncRecDepth do\n  checkMaxHeartbeats \"simp\"\n  let cfg \u2190 getConfig\n  if (\u2190 isProof e) then\n    return { expr := e }\n  if cfg.memoize then\n    if let some result := (\u2190 get).cache.find? e then\n      \n      if result.dischargeDepth \u2264 (\u2190 readThe Simp.Context).dischargeDepth then\n        return result\n  trace[Meta.Tactic.simp.heads] \"{repr e.toHeadIndex}\"\n  simpLoop { expr := e }\n\nwhere\n  simpLoop (r : Result) : M Result := do\n    let cfg \u2190 getConfig\n    if (\u2190 get).numSteps > cfg.maxSteps then\n      throwError \"simp failed, maximum number of steps exceeded\"\n    else\n      let init := r.expr\n      modify fun s => { s with numSteps := s.numSteps + 1 }\n      match (\u2190 pre r.expr) with\n      | Step.done r'  => cacheResult cfg (\u2190 mkEqTrans r r')\n      | Step.visit r' =>\n        let r \u2190 mkEqTrans r r'\n        let r \u2190 mkEqTrans r (\u2190 simpStep r.expr)\n        match (\u2190 post r.expr) with\n        | Step.done r'  => cacheResult cfg (\u2190 mkEqTrans r r')\n        | Step.visit r' =>\n          let r \u2190 mkEqTrans r r'\n          if cfg.singlePass || init == r.expr then\n            cacheResult cfg r\n          else\n            simpLoop r\n\n  simpStep (e : Expr) : M Result := do\n    match e with\n    | Expr.mdata m e   => let r \u2190 simp e; return { r with expr := mkMData m r.expr }\n    | Expr.proj ..     => simpProj e\n    | Expr.app ..      => simpApp e\n    | Expr.lam ..      => simpLambda e\n    | Expr.forallE ..  => simpForall e\n    | Expr.letE ..     => simpLet e\n    | Expr.const ..    => simpConst e\n    | Expr.bvar ..     => unreachable!\n    | Expr.sort ..     => return { expr := e }\n    | Expr.lit ..      => simpLit e\n    | Expr.mvar ..     => return { expr := (\u2190 instantiateMVars e) }\n    | Expr.fvar ..     => return { expr := (\u2190 reduceFVar (\u2190 getConfig) e) }\n\n  simpLit (e : Expr) : M Result := do\n    match e.natLit? with\n    | some n =>\n      \n      if (\u2190 readThe Simp.Context).isDeclToUnfold ``OfNat.ofNat then\n        return { expr := e }\n      else\n        return { expr := (\u2190 mkNumeral (mkConst ``Nat) n) }\n    | none   => return { expr := e }\n\n  simpProj (e : Expr) : M Result := do\n    match (\u2190 reduceProj? e) with\n    | some e => return { expr := e }\n    | none =>\n      let s := e.projExpr!\n      let motive? \u2190 withLocalDeclD `s (\u2190 inferType s) fun s => do\n        let p := e.updateProj! s\n        if (\u2190 dependsOn (\u2190 inferType p) s.fvarId!) then\n          return none\n        else\n          let motive \u2190 mkLambdaFVars #[s] (\u2190 mkEq e p)\n          if !(\u2190 isTypeCorrect motive) then\n            return none\n          else\n            return some motive\n      if let some motive := motive? then\n        let r \u2190 simp s\n        let eNew := e.updateProj! r.expr\n        match r.proof? with\n        | none => return { expr := eNew }\n        | some h =>\n          let hNew \u2190 mkEqNDRec motive (\u2190 mkEqRefl e) h\n          return { expr := eNew, proof? := some hNew }\n      else\n        return { expr := (\u2190 dsimp e) }\n\n  congrArgs (r : Result) (args : Array Expr) : M Result := do\n    if args.isEmpty then\n      return r\n    else\n      let infos := (\u2190 getFunInfoNArgs r.expr args.size).paramInfo\n      let mut r := r\n      let mut i := 0\n      for arg in args do\n        trace[Debug.Meta.Tactic.simp] \"app [{i}] {infos.size} {arg} hasFwdDeps: {infos[i]!.hasFwdDeps}\"\n        if i < infos.size && !infos[i]!.hasFwdDeps then\n          r \u2190 mkCongr r (\u2190 simp arg)\n        else if (\u2190 whnfD (\u2190 inferType r.expr)).isArrow then\n          r \u2190 mkCongr r (\u2190 simp arg)\n        else\n          r \u2190 mkCongrFun r (\u2190 dsimp arg)\n        i := i + 1\n      return r\n\n  visitFn (e : Expr) : M Result := do\n    let f := e.getAppFn\n    let fNew \u2190 simp f\n    if fNew.expr == f then\n      return { expr := e }\n    else\n      let args := e.getAppArgs\n      let eNew := mkAppN fNew.expr args\n      if fNew.proof?.isNone then return { expr := eNew }\n      let mut proof \u2190 fNew.getProof\n      for arg in args do\n        proof \u2190 Meta.mkCongrFun proof arg\n      return { expr := eNew, proof? := proof }\n\n  mkCongrSimp? (f : Expr) : M (Option CongrTheorem) := do\n    if f.isConst then if (\u2190 isMatcher f.constName!) then\n      return none\n    let info \u2190 getFunInfo f\n    let kinds \u2190 getCongrSimpKinds f info\n    if kinds.all fun k => match k with | CongrArgKind.fixed => true | CongrArgKind.eq => true | _ => false then\n      \n      return none\n    match (\u2190 get).congrCache.find? f with\n    | some thm? => return thm?\n    | none =>\n      let thm? \u2190 mkCongrSimpCore? f info kinds\n      modify fun s => { s with congrCache := s.congrCache.insert f thm? }\n      return thm?\n\n  \n  tryAutoCongrTheorem? (e : Expr) : M (Option Result) := do\n    let f := e.getAppFn\n    let some cgrThm \u2190 mkCongrSimp? f | return none\n    if cgrThm.argKinds.size != e.getAppNumArgs then return none\n    let mut simplified := false\n    let mut hasProof   := false\n    let mut hasCast    := false\n    let mut argsNew    := #[]\n    let mut argResults := #[]\n    let args := e.getAppArgs\n    for arg in args, kind in cgrThm.argKinds do\n      match kind with\n      | CongrArgKind.fixed => argsNew := argsNew.push (\u2190 dsimp arg)\n      | CongrArgKind.cast  => hasCast := true; argsNew := argsNew.push arg\n      | CongrArgKind.subsingletonInst => argsNew := argsNew.push arg\n      | CongrArgKind.eq =>\n        let argResult \u2190 simp arg\n        argResults := argResults.push argResult\n        argsNew    := argsNew.push argResult.expr\n        if argResult.proof?.isSome then hasProof := true\n        if arg != argResult.expr then simplified := true\n      | _ => unreachable!\n    if !simplified then return some { expr := e }\n    \n    if !hasProof && !hasCast then return some { expr := mkAppN f argsNew }\n    let mut proof := cgrThm.proof\n    let mut type  := cgrThm.type\n    let mut j := 0 let mut subst := #[]\n    for arg in args, kind in cgrThm.argKinds do\n      proof := mkApp proof arg\n      subst := subst.push arg\n      type := type.bindingBody!\n      match kind with\n      | CongrArgKind.fixed => pure ()\n      | CongrArgKind.cast  => pure ()\n      | CongrArgKind.subsingletonInst =>\n        let clsNew := type.bindingDomain!.instantiateRev subst\n        let instNew \u2190 if (\u2190 isDefEq (\u2190 inferType arg) clsNew) then\n          pure arg\n        else\n          match (\u2190 trySynthInstance clsNew) with\n          | LOption.some val => pure val\n          | _ =>\n            trace[Meta.Tactic.simp.congr] \"failed to synthesize instance{indentExpr clsNew}\"\n            return none\n        proof := mkApp proof instNew\n        subst := subst.push instNew\n        type := type.bindingBody!\n      | CongrArgKind.eq =>\n        let argResult := argResults[j]!\n        let argProof \u2190 argResult.getProof' arg\n        j := j + 1\n        proof := mkApp2 proof argResult.expr argProof\n        subst := subst.push argResult.expr |>.push argProof\n        type := type.bindingBody!.bindingBody!\n      | _ => unreachable!\n    let some (_, _, rhs) := type.instantiateRev subst |>.eq? | unreachable!\n    let rhs \u2190 if hasCast then removeUnnecessaryCasts rhs else pure rhs\n    if hasProof then\n      return some { expr := rhs, proof? := proof }\n    else\n      \n      return some { expr := rhs }\n\n  congrDefault (e : Expr) : M Result := do\n    if let some result \u2190 tryAutoCongrTheorem? e then\n      mkEqTrans result (\u2190 visitFn result.expr)\n    else\n      withParent e <| e.withApp fun f args => do\n        congrArgs (\u2190 simp f) args\n\n  \n  processCongrHypothesis (h : Expr) : M Bool := do\n    forallTelescopeReducing (\u2190 inferType h) fun xs hType => withNewLemmas xs do\n      let lhs \u2190 instantiateMVars hType.appFn!.appArg!\n      let r \u2190 simp lhs\n      let rhs := hType.appArg!\n      rhs.withApp fun m zs => do\n        let val \u2190 mkLambdaFVars zs r.expr\n        unless (\u2190 isDefEq m val) do\n          throwCongrHypothesisFailed\n        let mut proof \u2190 r.getProof\n        if hType.isAppOf ``Iff then\n          try proof \u2190 mkIffOfEq proof\n          catch _ => throwCongrHypothesisFailed\n        unless (\u2190 isDefEq h (\u2190 mkLambdaFVars xs proof)) do\n          throwCongrHypothesisFailed\n        \n        return r.proof?.isSome || (xs.size > 0 && lhs != r.expr)\n\n  \n  trySimpCongrTheorem? (c : SimpCongrTheorem) (e : Expr) : M (Option Result) := withNewMCtxDepth do\n    trace[Debug.Meta.Tactic.simp.congr] \"{c.theoremName}, {e}\"\n    let thm \u2190 mkConstWithFreshMVarLevels c.theoremName\n    let (xs, bis, type) \u2190 forallMetaTelescopeReducing (\u2190 inferType thm)\n    if c.hypothesesPos.any (\u00b7 \u2265 xs.size) then\n      return none\n    let isIff := type.isAppOf ``Iff\n    let lhs := type.appFn!.appArg!\n    let rhs := type.appArg!\n    let numArgs := lhs.getAppNumArgs\n    let mut e := e\n    let mut extraArgs := #[]\n    if e.getAppNumArgs > numArgs then\n      let args := e.getAppArgs\n      e := mkAppN e.getAppFn args[:numArgs]\n      extraArgs := args[numArgs:].toArray\n    if (\u2190 isDefEq lhs e) then\n      let mut modified := false\n      for i in c.hypothesesPos do\n        let x := xs[i]!\n        try\n          if (\u2190 processCongrHypothesis x) then\n            modified := true\n        catch ex =>\n          trace[Meta.Tactic.simp.congr] \"processCongrHypothesis {c.theoremName} failed {\u2190 inferType x}\"\n          if ex.isMaxRecDepth then\n            throw ex\n          else\n            return none\n      unless modified do\n        trace[Meta.Tactic.simp.congr] \"{c.theoremName} not modified\"\n        return none\n      unless (\u2190 synthesizeArgs (.decl c.theoremName) xs bis (\u2190 read).discharge?) do\n        trace[Meta.Tactic.simp.congr] \"{c.theoremName} synthesizeArgs failed\"\n        return none\n      let eNew \u2190 instantiateMVars rhs\n      let mut proof \u2190 instantiateMVars (mkAppN thm xs)\n      if isIff then\n        try proof \u2190 mkAppM ``propext #[proof]\n        catch _ => return none\n      if (\u2190 hasAssignableMVar proof <||> hasAssignableMVar eNew) then\n        trace[Meta.Tactic.simp.congr] \"{c.theoremName} has unassigned metavariables\"\n        return none\n      congrArgs { expr := eNew, proof? := proof } extraArgs\n    else\n      return none\n\n  congr (e : Expr) : M Result := do\n    let f := e.getAppFn\n    if f.isConst then\n      let congrThms \u2190 getSimpCongrTheorems\n      let cs := congrThms.get f.constName!\n      for c in cs do\n        match (\u2190 trySimpCongrTheorem? c e) with\n        | none   => pure ()\n        | some r => return r\n      congrDefault e\n    else\n      congrDefault e\n\n  simpApp (e : Expr) : M Result := do\n    let e \u2190 reduce e\n    if !e.isApp then\n      simp e\n    else if isOfNatNatLit e then\n      return { expr := e }\n    else\n      congr e\n\n  simpConst (e : Expr) : M Result :=\n    return { expr := (\u2190 reduce e) }\n\n  withNewLemmas {\u03b1} (xs : Array Expr) (f : M \u03b1) : M \u03b1 := do\n    if (\u2190 getConfig).contextual then\n      let mut s \u2190 getSimpTheorems\n      let mut updated := false\n      for x in xs do\n        if (\u2190 isProof x) then\n          s \u2190 s.addTheorem (.fvar x.fvarId!) x\n          updated := true\n      if updated then\n        withSimpTheorems s f\n      else\n        f\n    else\n      f\n\n  simpLambda (e : Expr) : M Result :=\n    withParent e <| lambdaTelescopeDSimp e fun xs e => withNewLemmas xs do\n      let r \u2190 simp e\n      let eNew \u2190 mkLambdaFVars xs r.expr\n      match r.proof? with\n      | none   => return { expr := eNew }\n      | some h =>\n        let p \u2190 xs.foldrM (init := h) fun x h => do\n          mkFunExt (\u2190 mkLambdaFVars #[x] h)\n        return { expr := eNew, proof? := p }\n\n  simpArrow (e : Expr) : M Result := do\n    trace[Debug.Meta.Tactic.simp] \"arrow {e}\"\n    let p := e.bindingDomain!\n    let q := e.bindingBody!\n    let rp \u2190 simp p\n    trace[Debug.Meta.Tactic.simp] \"arrow [{(\u2190 getConfig).contextual}] {p} [{\u2190 isProp p}] -> {q} [{\u2190 isProp q}]\"\n    if (\u2190 pure (\u2190 getConfig).contextual <&&> isProp p <&&> isProp q) then\n      trace[Debug.Meta.Tactic.simp] \"ctx arrow {rp.expr} -> {q}\"\n      withLocalDeclD e.bindingName! rp.expr fun h => do\n        let s \u2190 getSimpTheorems\n        let s \u2190 s.addTheorem (.fvar h.fvarId!) h\n        withSimpTheorems s do\n          let rq \u2190 simp q\n          match rq.proof? with\n          | none    => mkImpCongr e rp rq\n          | some hq =>\n            let hq \u2190 mkLambdaFVars #[h] hq\n            \n            if rq.expr.containsFVar h.fvarId! then\n              return { expr := (\u2190 mkForallFVars #[h] rq.expr), proof? := (\u2190 withDefault <| mkImpDepCongrCtx (\u2190 rp.getProof) hq) }\n            else\n              return { expr := e.updateForallE! rp.expr rq.expr, proof? := (\u2190 withDefault <| mkImpCongrCtx (\u2190 rp.getProof) hq) }\n    else\n      mkImpCongr e rp (\u2190 simp q)\n\n  simpForall (e : Expr) : M Result := withParent e do\n    trace[Debug.Meta.Tactic.simp] \"forall {e}\"\n    if e.isArrow then\n      simpArrow e\n    else if (\u2190 isProp e) then\n      withLocalDecl e.bindingName! e.bindingInfo! e.bindingDomain! fun x => withNewLemmas #[x] do\n        let b := e.bindingBody!.instantiate1 x\n        let rb \u2190 simp b\n        let eNew \u2190 mkForallFVars #[x] rb.expr\n        match rb.proof? with\n        | none   => return { expr := eNew }\n        | some h => return { expr := eNew, proof? := (\u2190 mkForallCongr (\u2190 mkLambdaFVars #[x] h)) }\n    else\n      return { expr := (\u2190 dsimp e) }\n\n  simpLet (e : Expr) : M Result := do\n    let Expr.letE n t v b _ := e | unreachable!\n    if (\u2190 getConfig).zeta then\n      return { expr := b.instantiate1 v }\n    else\n      match (\u2190 getSimpLetCase n t b) with\n      | SimpLetCase.dep => return { expr := (\u2190 dsimp e) }\n      | SimpLetCase.nondep =>\n        let rv \u2190 simp v\n        withLocalDeclD n t fun x => do\n          let bx := b.instantiate1 x\n          let rbx \u2190 simp bx\n          let hb? \u2190 match rbx.proof? with\n            | none => pure none\n            | some h => pure (some (\u2190 mkLambdaFVars #[x] h))\n          let e' := mkLet n t rv.expr (\u2190 rbx.expr.abstractM #[x])\n          match rv.proof?, hb? with\n          | none,   none   => return { expr := e' }\n          | some h, none   => return { expr := e', proof? := some (\u2190 mkLetValCongr (\u2190 mkLambdaFVars #[x] rbx.expr) h) }\n          | _,      some h => return { expr := e', proof? := some (\u2190 mkLetCongr (\u2190 rv.getProof) h) }\n      | SimpLetCase.nondepDepVar =>\n        let v' \u2190 dsimp v\n        withLocalDeclD n t fun x => do\n          let bx := b.instantiate1 x\n          let rbx \u2190 simp bx\n          let e' := mkLet n t v' (\u2190 rbx.expr.abstractM #[x])\n          match rbx.proof? with\n          | none => return { expr := e' }\n          | some h =>\n            let h \u2190 mkLambdaFVars #[x] h\n            return { expr := e', proof? := some (\u2190 mkLetBodyCongr v' h) }\n\n  cacheResult (cfg : Config) (r : Result) : M Result := do\n    if cfg.memoize then\n      let dischargeDepth := (\u2190 readThe Simp.Context).dischargeDepth\n      modify fun s => { s with cache := s.cache.insert e { r with dischargeDepth } }\n    return r", "start": [270, 1], "end": [727, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.withSimpConfig", "code": "@[inline] def withSimpConfig (ctx : Context) (x : MetaM \u03b1) : MetaM \u03b1 :=\n  withConfig (fun c => { c with etaStruct := ctx.config.etaStruct }) <| withReducible x", "start": [729, 1], "end": [730, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.main", "code": "def main (e : Expr) (ctx : Context) (usedSimps : UsedSimps := {}) (methods : Methods := {}) : MetaM (Result \u00d7 UsedSimps) := do\n  let ctx := { ctx with config := (\u2190 ctx.config.updateArith) }\n  withSimpConfig ctx do\n    try\n      let (r, s) \u2190 simp e methods ctx |>.run { usedTheorems := usedSimps }\n      trace[Meta.Tactic.simp.numSteps] \"{s.numSteps}\"\n      return (r, s.usedTheorems)\n    catch ex =>\n      if ex.isMaxHeartbeat then throwNestedTacticEx `simp ex else throw ex", "start": [732, 1], "end": [740, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.dsimpMain", "code": "def dsimpMain (e : Expr) (ctx : Context) (usedSimps : UsedSimps := {}) (methods : Methods := {}) : MetaM (Expr \u00d7 UsedSimps) := do\n  withSimpConfig ctx do\n    try\n      let (r, s) \u2190 dsimp e methods ctx |>.run { usedTheorems := usedSimps }\n      pure (r, s.usedTheorems)\n    catch ex =>\n      if ex.isMaxHeartbeat then throwNestedTacticEx `dsimp ex else throw ex", "start": [742, 1], "end": [748, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.isEqnThmHypothesis", "code": "partial def isEqnThmHypothesis (e : Expr) : Bool :=\n  e.isForall && go e\nwhere\n  go (e : Expr) : Bool :=\n    match e with\n    | .forallE _ d b _ => (d.isEq || d.isHEq || b.hasLooseBVar 0) && go b\n    | _ => e.consumeMData.isConstOf ``False", "start": [750, 1], "end": [775, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.Discharge", "code": "abbrev Discharge := Expr \u2192 SimpM (Option Expr)", "start": [777, 1], "end": [777, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.dischargeUsingAssumption?", "code": "def dischargeUsingAssumption? (e : Expr) : SimpM (Option Expr) := do\n  (\u2190 getLCtx).findDeclRevM? fun localDecl => do\n    if localDecl.isImplementationDetail then\n      return none\n    else if (\u2190 isDefEq e localDecl.type) then\n      return some localDecl.toExpr\n    else\n      return none", "start": [779, 1], "end": [786, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.dischargeEqnThmHypothesis?", "code": "partial def dischargeEqnThmHypothesis? (e : Expr) : MetaM (Option Expr) := do\n  assert! isEqnThmHypothesis e\n  let mvar \u2190 mkFreshExprSyntheticOpaqueMVar e\n  withReader (fun ctx => { ctx with canUnfold? := canUnfoldAtMatcher }) do\n    if let .none \u2190 go? mvar.mvarId! then\n      instantiateMVars mvar\n    else\n      return none\nwhere\n  go? (mvarId : MVarId) : MetaM (Option MVarId) :=\n    try\n      let (fvarId, mvarId) \u2190 mvarId.intro1\n      mvarId.withContext do\n        let localDecl \u2190 fvarId.getDecl\n        if localDecl.type.isEq || localDecl.type.isHEq then\n          if let some { mvarId, .. } \u2190 unifyEq? mvarId fvarId {} then\n            go? mvarId\n          else\n            return none\n        else\n          go? mvarId\n    catch _  =>\n      return some mvarId", "start": [788, 1], "end": [814, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.DefaultMethods.discharge?", "code": "partial def discharge? (e : Expr) : SimpM (Option Expr) := do\n    if isEqnThmHypothesis e then\n      if let some r \u2190 dischargeUsingAssumption? e then\n        return some r\n      if let some r \u2190 dischargeEqnThmHypothesis? e then\n        return some r\n    let ctx \u2190 read\n    trace[Meta.Tactic.simp.discharge] \">> discharge?: {e}\"\n    if ctx.dischargeDepth >= ctx.config.maxDischargeDepth then\n      trace[Meta.Tactic.simp.discharge] \"maximum discharge depth has been reached\"\n      return none\n    else\n      withReader (fun ctx => { ctx with dischargeDepth := ctx.dischargeDepth + 1 }) do\n        let r \u2190 simp e { pre := pre, post := post, discharge? := discharge? }\n        if r.expr.consumeMData.isConstOf ``True then\n          try\n            return some (\u2190 mkOfEqTrue (\u2190 r.getProof))\n          catch _ =>\n            return none\n        else\n          return none", "start": [818, 3], "end": [838, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.DefaultMethods.pre", "code": "partial def pre (e : Expr) : SimpM Step :=\n    preDefault e discharge?", "start": [840, 3], "end": [841, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.DefaultMethods.post", "code": "partial def post (e : Expr) : SimpM Step :=\n    postDefault e discharge?", "start": [843, 3], "end": [844, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Simp.DefaultMethods.methods", "code": "def methods : Methods :=\n  { pre := pre, post := post, discharge? := discharge? }", "start": [847, 1], "end": [848, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simp", "code": "def simp (e : Expr) (ctx : Simp.Context) (discharge? : Option Simp.Discharge := none)\n    (usedSimps : UsedSimps := {}) : MetaM (Simp.Result \u00d7 UsedSimps) := do profileitM Exception \"simp\" (\u2190 getOptions) do\n  match discharge? with\n  | none   => Simp.main e ctx usedSimps (methods := Simp.DefaultMethods.methods)\n  | some d => Simp.main e ctx usedSimps (methods := { pre := (Simp.preDefault \u00b7 d), post := (Simp.postDefault \u00b7 d), discharge? := d })", "start": [855, 1], "end": [859, 135], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.dsimp", "code": "def dsimp (e : Expr) (ctx : Simp.Context)\n    (usedSimps : UsedSimps := {}) : MetaM (Expr \u00d7 UsedSimps) := do profileitM Exception \"dsimp\" (\u2190 getOptions) do\n  Simp.dsimpMain e ctx usedSimps (methods := Simp.DefaultMethods.methods)", "start": [861, 1], "end": [863, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.applySimpResultToTarget", "code": "def applySimpResultToTarget (mvarId : MVarId) (target : Expr) (r : Simp.Result) : MetaM MVarId := do\n  match r.proof? with\n  | some proof => mvarId.replaceTargetEq r.expr proof\n  | none =>\n    if target != r.expr then\n      mvarId.replaceTargetDefEq r.expr\n    else\n      return mvarId", "start": [865, 1], "end": [876, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpTargetCore", "code": "def simpTargetCore (mvarId : MVarId) (ctx : Simp.Context) (discharge? : Option Simp.Discharge := none)\n    (mayCloseGoal := true) (usedSimps : UsedSimps := {}) : MetaM (Option MVarId \u00d7 UsedSimps) := do\n  let target \u2190 instantiateMVars (\u2190 mvarId.getType)\n  let (r, usedSimps) \u2190 simp target ctx discharge? usedSimps\n  if mayCloseGoal && r.expr.consumeMData.isConstOf ``True then\n    match r.proof? with\n    | some proof => mvarId.assign (\u2190 mkOfEqTrue proof)\n    | none => mvarId.assign (mkConst ``True.intro)\n    return (none, usedSimps)\n  else\n    return (\u2190 applySimpResultToTarget mvarId target r, usedSimps)", "start": [878, 1], "end": [889, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpTarget", "code": "def simpTarget (mvarId : MVarId) (ctx : Simp.Context) (discharge? : Option Simp.Discharge := none)\n    (mayCloseGoal := true) (usedSimps : UsedSimps := {}) : MetaM (Option MVarId \u00d7 UsedSimps) :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `simp\n    simpTargetCore mvarId ctx discharge? mayCloseGoal usedSimps", "start": [891, 1], "end": [898, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.applySimpResultToProp", "code": "def applySimpResultToProp (mvarId : MVarId) (proof : Expr) (prop : Expr) (r : Simp.Result) (mayCloseGoal := true) : MetaM (Option (Expr \u00d7 Expr)) := do\n  if mayCloseGoal && r.expr.consumeMData.isConstOf ``False then\n    match r.proof? with\n    | some eqProof => mvarId.assign (\u2190 mkFalseElim (\u2190 mvarId.getType) (\u2190 mkEqMP eqProof proof))\n    | none => mvarId.assign (\u2190 mkFalseElim (\u2190 mvarId.getType) proof)\n    return none\n  else\n    match r.proof? with\n    | some eqProof => return some ((\u2190 mkEqMP eqProof proof), r.expr)\n    | none =>\n      if r.expr != prop then\n        return some ((\u2190 mkExpectedTypeHint proof r.expr), r.expr)\n      else\n        return some (proof, r.expr)", "start": [900, 1], "end": [918, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.applySimpResultToFVarId", "code": "def applySimpResultToFVarId (mvarId : MVarId) (fvarId : FVarId) (r : Simp.Result) (mayCloseGoal : Bool) : MetaM (Option (Expr \u00d7 Expr)) := do\n  let localDecl \u2190 fvarId.getDecl\n  applySimpResultToProp mvarId (mkFVar fvarId) localDecl.type r mayCloseGoal", "start": [920, 1], "end": [922, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpStep", "code": "def simpStep (mvarId : MVarId) (proof : Expr) (prop : Expr) (ctx : Simp.Context) (discharge? : Option Simp.Discharge := none)\n    (mayCloseGoal := true) (usedSimps : UsedSimps := {}) : MetaM (Option (Expr \u00d7 Expr) \u00d7 UsedSimps) := do\n  let (r, usedSimps) \u2190 simp prop ctx discharge? usedSimps\n  return (\u2190 applySimpResultToProp mvarId proof prop r (mayCloseGoal := mayCloseGoal), usedSimps)", "start": [924, 1], "end": [932, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.applySimpResultToLocalDeclCore", "code": "def applySimpResultToLocalDeclCore (mvarId : MVarId) (fvarId : FVarId) (r : Option (Expr \u00d7 Expr)) : MetaM (Option (FVarId \u00d7 MVarId)) := do\n  match r with\n  | none => return none\n  | some (value, type') =>\n    let localDecl \u2190 fvarId.getDecl\n    if localDecl.type != type' then\n      let mvarId \u2190 mvarId.assert localDecl.userName type' value\n      let mvarId \u2190 mvarId.tryClear localDecl.fvarId\n      let (fvarId, mvarId) \u2190 mvarId.intro1P\n      return some (fvarId, mvarId)\n    else\n      return some (fvarId, mvarId)", "start": [934, 1], "end": [945, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.applySimpResultToLocalDecl", "code": "def applySimpResultToLocalDecl (mvarId : MVarId) (fvarId : FVarId) (r : Simp.Result) (mayCloseGoal : Bool) : MetaM (Option (FVarId \u00d7 MVarId)) := do\n  if r.proof?.isNone then\n    let mvarId \u2190 mvarId.replaceLocalDeclDefEq fvarId r.expr\n    if mayCloseGoal && r.expr.consumeMData.isConstOf ``False then\n      mvarId.assign (\u2190 mkFalseElim (\u2190 mvarId.getType) (mkFVar fvarId))\n      return none\n    else\n      return some (fvarId, mvarId)\n  else\n    applySimpResultToLocalDeclCore mvarId fvarId (\u2190 applySimpResultToFVarId mvarId fvarId r mayCloseGoal)", "start": [947, 1], "end": [960, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpLocalDecl", "code": "def simpLocalDecl (mvarId : MVarId) (fvarId : FVarId) (ctx : Simp.Context) (discharge? : Option Simp.Discharge := none)\n    (mayCloseGoal := true) (usedSimps : UsedSimps := {}) : MetaM (Option (FVarId \u00d7 MVarId) \u00d7 UsedSimps) := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `simp\n    let type \u2190 instantiateMVars (\u2190 fvarId.getType)\n    let (r, usedSimps) \u2190 simpStep mvarId (mkFVar fvarId) type ctx discharge? mayCloseGoal usedSimps\n    return (\u2190 applySimpResultToLocalDeclCore mvarId fvarId r, usedSimps)", "start": [962, 1], "end": [968, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpGoal", "code": "def simpGoal (mvarId : MVarId) (ctx : Simp.Context) (discharge? : Option Simp.Discharge := none)\n    (simplifyTarget : Bool := true) (fvarIdsToSimp : Array FVarId := #[])\n    (usedSimps : UsedSimps := {}) : MetaM (Option (Array FVarId \u00d7 MVarId) \u00d7 UsedSimps) := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `simp\n    let mut mvarIdNew := mvarId\n    let mut toAssert := #[]\n    let mut replaced := #[]\n    let mut usedSimps := usedSimps\n    for fvarId in fvarIdsToSimp do\n      let localDecl \u2190 fvarId.getDecl\n      let type \u2190 instantiateMVars localDecl.type\n      let ctx := { ctx with simpTheorems := ctx.simpTheorems.eraseTheorem (.fvar localDecl.fvarId) }\n      let (r, usedSimps') \u2190 simp type ctx discharge? usedSimps\n      usedSimps := usedSimps'\n      match r.proof? with\n      | some _ => match (\u2190 applySimpResultToProp mvarIdNew (mkFVar fvarId) type r) with\n        | none => return (none, usedSimps)\n        | some (value, type) => toAssert := toAssert.push { userName := localDecl.userName, type := type, value := value }\n      | none =>\n        if r.expr.consumeMData.isConstOf ``False then\n          mvarIdNew.assign (\u2190 mkFalseElim (\u2190 mvarIdNew.getType) (mkFVar fvarId))\n          return (none, usedSimps)\n        mvarIdNew \u2190 mvarIdNew.replaceLocalDeclDefEq fvarId r.expr\n        replaced := replaced.push fvarId\n    if simplifyTarget then\n      match (\u2190 simpTarget mvarIdNew ctx discharge? (usedSimps := usedSimps)) with\n      | (none, usedSimps') => return (none, usedSimps')\n      | (some mvarIdNew', usedSimps') => mvarIdNew := mvarIdNew'; usedSimps := usedSimps'\n    let (fvarIdsNew, mvarIdNew') \u2190 mvarIdNew.assertHypotheses toAssert\n    mvarIdNew := mvarIdNew'\n    let toClear := fvarIdsToSimp.filter fun fvarId => !replaced.contains fvarId\n    mvarIdNew \u2190 mvarIdNew.tryClearMany toClear\n    if ctx.config.failIfUnchanged && mvarId == mvarIdNew then\n      throwError \"simp made no progress\"\n    return (some (fvarIdsNew, mvarIdNew), usedSimps)", "start": [970, 1], "end": [1007, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpTargetStar", "code": "def simpTargetStar (mvarId : MVarId) (ctx : Simp.Context) (discharge? : Option Simp.Discharge := none)\n    (usedSimps : UsedSimps := {}) : MetaM (TacticResultCNM \u00d7 UsedSimps) := mvarId.withContext do\n  let mut ctx := ctx\n  for h in (\u2190 getPropHyps) do\n    let localDecl \u2190 h.getDecl\n    let proof  := localDecl.toExpr\n    let simpTheorems \u2190 ctx.simpTheorems.addTheorem (.fvar h) proof\n    ctx := { ctx with simpTheorems }\n  match (\u2190 simpTarget mvarId ctx discharge? (usedSimps := usedSimps)) with\n  | (none, usedSimps) => return (TacticResultCNM.closed, usedSimps)\n  | (some mvarId', usedSimps') =>\n    if (\u2190 mvarId.getType) == (\u2190 mvarId'.getType) then\n      return (TacticResultCNM.noChange, usedSimps)\n    else\n      return (TacticResultCNM.modified mvarId', usedSimps')", "start": [1009, 1], "end": [1023, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.dsimpGoal", "code": "def dsimpGoal (mvarId : MVarId) (ctx : Simp.Context) (simplifyTarget : Bool := true) (fvarIdsToSimp : Array FVarId := #[])\n    (usedSimps : UsedSimps := {}) : MetaM (Option MVarId \u00d7 UsedSimps) := do\n   mvarId.withContext do\n    mvarId.checkNotAssigned `simp\n    let mut mvarIdNew := mvarId\n    let mut usedSimps : UsedSimps := usedSimps\n    for fvarId in fvarIdsToSimp do\n      let type \u2190 instantiateMVars (\u2190 fvarId.getType)\n      let (typeNew, usedSimps') \u2190 dsimp type ctx\n      usedSimps := usedSimps'\n      if typeNew.consumeMData.isConstOf ``False then\n        mvarIdNew.assign (\u2190 mkFalseElim (\u2190 mvarIdNew.getType) (mkFVar fvarId))\n        return (none, usedSimps)\n      if typeNew != type then\n        mvarIdNew \u2190 mvarIdNew.replaceLocalDeclDefEq fvarId typeNew\n    if simplifyTarget then\n      let target \u2190 mvarIdNew.getType\n      let (targetNew, usedSimps') \u2190 dsimp target ctx usedSimps\n      usedSimps := usedSimps'\n      if targetNew.consumeMData.isConstOf ``True then\n        mvarIdNew.assign (mkConst ``True.intro)\n        return (none, usedSimps)\n      if let some (_, lhs, rhs) := targetNew.eq? then\n        if (\u2190 withReducible <| isDefEq lhs rhs) then\n          mvarIdNew.assign (\u2190 mkEqRefl lhs)\n          return (none, usedSimps)\n      if target != targetNew then\n        mvarIdNew \u2190 mvarIdNew.replaceTargetDefEq targetNew\n      pure () if ctx.config.failIfUnchanged && mvarId == mvarIdNew then\n      throwError \"dsimp made no progress\"\n    return (some mvarIdNew, usedSimps)", "start": [1025, 1], "end": [1056, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/RecursorInfo.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/AuxRecursor.lean", "lake-packages/lean4/src/lean/Lean/Util/FindExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.RecursorUnivLevelPos", "code": "inductive RecursorUnivLevelPos where\n  | motive                | majorType (idx : Nat)", "start": [12, 1], "end": [14, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.RecursorInfo", "code": "structure RecursorInfo where\n  recursorName  : Name\n  typeName      : Name\n  univLevelPos  : List RecursorUnivLevelPos\n  depElim       : Bool\n  recursive     : Bool\n  numArgs       : Nat majorPos      : Nat\n  paramsPos     : List (Option Nat) indicesPos    : List Nat produceMotive : List Bool", "start": [20, 1], "end": [30, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.RecursorInfo.numParams", "code": "def numParams (info : RecursorInfo) : Nat := info.paramsPos.length", "start": [34, 1], "end": [34, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.RecursorInfo.numIndices", "code": "def numIndices (info : RecursorInfo) : Nat := info.indicesPos.length", "start": [35, 1], "end": [35, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.RecursorInfo.motivePos", "code": "def motivePos (info : RecursorInfo) : Nat := info.numParams", "start": [36, 1], "end": [36, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.RecursorInfo.firstIndexPos", "code": "def firstIndexPos (info : RecursorInfo) : Nat := info.majorPos - info.numIndices", "start": [37, 1], "end": [37, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.RecursorInfo.isMinor", "code": "def isMinor (info : RecursorInfo) (pos : Nat) : Bool :=\n  if pos \u2264 info.motivePos then false\n  else if info.firstIndexPos \u2264 pos && pos \u2264 info.majorPos then false\n  else true", "start": [39, 1], "end": [42, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.RecursorInfo.numMinors", "code": "def numMinors (info : RecursorInfo) : Nat :=\n  let r := info.numArgs\n  let r := r - info.motivePos - 1\n  r - (info.majorPos + 1 - info.firstIndexPos)", "start": [44, 1], "end": [47, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkRecursorInfoForKernelRec", "code": "private def mkRecursorInfoForKernelRec (declName : Name) (val : RecursorVal) : MetaM RecursorInfo := do\n  let ival \u2190 getConstInfoInduct val.getInduct\n  let numLParams    := ival.levelParams.length\n  let univLevelPos  := (List.range numLParams).map RecursorUnivLevelPos.majorType\n  let univLevelPos  := if val.levelParams.length == numLParams then univLevelPos else RecursorUnivLevelPos.motive :: univLevelPos\n  let produceMotive := List.replicate val.numMinors true\n  let paramsPos     := (List.range val.numParams).map some\n  let indicesPos    := (List.range val.numIndices).map fun pos => val.numParams + pos\n  let numArgs       := val.numIndices + val.numParams + val.numMinors + val.numMotives + 1\n  pure {\n    recursorName  := declName,\n    typeName      := val.getInduct,\n    univLevelPos  := univLevelPos,\n    majorPos      := val.getMajorIdx,\n    depElim       := true,\n    recursive     := ival.isRec,\n    produceMotive := produceMotive,\n    paramsPos     := paramsPos,\n    indicesPos    := indicesPos,\n    numArgs       := numArgs\n  }", "start": [69, 1], "end": [89, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMajorPosIfAuxRecursor?", "code": "private def getMajorPosIfAuxRecursor? (declName : Name) (majorPos? : Option Nat) : MetaM (Option Nat) :=\n  if majorPos?.isSome then pure majorPos?\n  else do\n    let env \u2190 getEnv\n    if !isAuxRecursor env declName then pure none\n    else match declName with\n    | .str p s =>\n      if s != recOnSuffix && s != casesOnSuffix && s != brecOnSuffix then\n        pure none\n      else do\n        let val \u2190 getConstInfoRec (mkRecName p)\n        pure $ some (val.numParams + val.numIndices + (if s == casesOnSuffix then 1 else val.numMotives))\n    | _ => pure none", "start": [92, 1], "end": [104, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkMotive", "code": "private def checkMotive (declName : Name) (motive : Expr) (motiveArgs : Array Expr) : MetaM Unit :=\n  unless motive.isFVar && motiveArgs.all Expr.isFVar do\n    throwError \"invalid user defined recursor '{declName}', result type must be of the form (C t), where C is a bound variable, and t is a (possibly empty) sequence of bound variables\"", "start": [106, 1], "end": [108, 185], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getNumParams", "code": "private partial def getNumParams (xs : Array Expr) (motive : Expr) (i : Nat) : Nat :=\n  if h : i < xs.size then\n    let x := xs.get \u27e8i, h\u27e9\n    if motive == x then i\n    else getNumParams xs motive (i+1)\n  else\n    i", "start": [110, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMajorPosDepElim", "code": "private def getMajorPosDepElim (declName : Name) (majorPos? : Option Nat) (xs : Array Expr) (motiveArgs : Array Expr)\n    : MetaM (Expr \u00d7 Nat \u00d7 Bool) := do\n  match majorPos? with\n  | some majorPos =>\n    if h : majorPos < xs.size then\n      let major   := xs.get \u27e8majorPos, h\u27e9\n      let depElim := motiveArgs.contains major\n      pure (major, majorPos, depElim)\n    else throwError \"invalid major premise position for user defined recursor, recursor has only {xs.size} arguments\"\n  | none => do\n    if motiveArgs.isEmpty then\n      throwError \"invalid user defined recursor, '{declName}' does not support dependent elimination, and position of the major premise was not specified (solution: set attribute '[recursor <pos>]', where <pos> is the position of the major premise)\"\n    let major := motiveArgs.back\n    match xs.getIdx? major with\n    | some majorPos => pure (major, majorPos, true)\n    | none          => throwError \"ill-formed recursor '{declName}'\"", "start": [120, 1], "end": [135, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getParamsPos", "code": "private def getParamsPos (declName : Name) (xs : Array Expr) (numParams : Nat) (Iargs : Array Expr) : MetaM (List (Option Nat)) := do\n  let mut paramsPos := #[]\n  for i in [:numParams] do\n    let x := xs[i]!\n    match (\u2190 Iargs.findIdxM? fun Iarg => isDefEq Iarg x) with\n    | some j => paramsPos := paramsPos.push (some j)\n    | none   => do\n      let localDecl \u2190 x.fvarId!.getDecl\n      if localDecl.binderInfo.isInstImplicit then\n        paramsPos := paramsPos.push none\n      else\n        throwError\"invalid user defined recursor '{declName}', type of the major premise does not contain the recursor parameter\"\n  pure paramsPos.toList", "start": [137, 1], "end": [149, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getIndicesPos", "code": "private def getIndicesPos (declName : Name) (xs : Array Expr) (majorPos numIndices : Nat) (Iargs : Array Expr) : MetaM (List Nat) := do\n  let mut indicesPos := #[]\n  for i in [:numIndices] do\n    let i := majorPos - numIndices + i\n    let x := xs[i]!\n    match (\u2190 Iargs.findIdxM? fun Iarg => isDefEq Iarg x) with\n    | some j => indicesPos := indicesPos.push j\n    | none   => throwError \"invalid user defined recursor '{declName}', type of the major premise does not contain the recursor index\"\n  pure indicesPos.toList", "start": [151, 1], "end": [159, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMotiveLevel", "code": "private def getMotiveLevel (declName : Name) (motiveResultType : Expr) : MetaM Level :=\n  match motiveResultType with\n  | Expr.sort u@(Level.zero)    => pure u\n  | Expr.sort u@(Level.param _) => pure u\n  | _                           =>\n    throwError \"invalid user defined recursor '{declName}', motive result sort must be Prop or (Sort u) where u is a universe level parameter\"", "start": [161, 1], "end": [166, 143], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getUnivLevelPos", "code": "private def getUnivLevelPos (declName : Name) (lparams : List Name) (motiveLvl : Level) (Ilevels : List Level) : MetaM (List RecursorUnivLevelPos) := do\n  let Ilevels := Ilevels.toArray\n  let mut univLevelPos := #[]\n  for p in lparams do\n    if motiveLvl == mkLevelParam p then\n      univLevelPos := univLevelPos.push RecursorUnivLevelPos.motive\n    else\n      match Ilevels.findIdx? fun u => u == mkLevelParam p with\n      | some i => univLevelPos := univLevelPos.push (RecursorUnivLevelPos.majorType i)\n      | none   =>\n        throwError \"invalid user defined recursor '{declName}', major premise type does not contain universe level parameter '{p}'\"\n  pure univLevelPos.toList", "start": [168, 1], "end": [179, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getProduceMotiveAndRecursive", "code": "private def getProduceMotiveAndRecursive (xs : Array Expr) (numParams numIndices majorPos : Nat) (motive : Expr) : MetaM (List Bool \u00d7 Bool) := do\n  let mut produceMotive := #[]\n  let mut recursor      := false\n  for i in [:xs.size] do\n    if i < numParams + 1 then\n      continue if majorPos - numIndices \u2264 i && i \u2264 majorPos then\n      continue let x := xs[i]!\n    let xType \u2190 inferType x\n    (produceMotive, recursor) \u2190 forallTelescopeReducing xType fun minorArgs minorResultType => minorResultType.withApp fun res _ => do\n      let produceMotive := produceMotive.push (res == motive)\n      let recursor \u2190 if recursor then pure recursor else minorArgs.anyM fun minorArg => do\n        let minorArgType \u2190 inferType minorArg\n        pure (minorArgType.find? fun e => e == motive).isSome\n      pure (produceMotive, recursor)\n  pure (produceMotive.toList, recursor)", "start": [181, 1], "end": [198, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkMotiveResultType", "code": "private def checkMotiveResultType (declName : Name) (motiveArgs : Array Expr) (motiveResultType : Expr) (motiveTypeParams : Array Expr) : MetaM Unit := do\n  if !motiveResultType.isSort || motiveArgs.size != motiveTypeParams.size then\n    throwError \"invalid user defined recursor '{declName}', motive must have a type of the form (C : Pi (i : B A), I A i -> Type), where A is (possibly empty) sequence of variables (aka parameters), (i : B A) is a (possibly empty) telescope (aka indices), and I is a constant\"", "start": [200, 1], "end": [202, 277], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkRecursorInfoAux", "code": "private def mkRecursorInfoAux (cinfo : ConstantInfo) (majorPos? : Option Nat) : MetaM RecursorInfo := do\n  let declName := cinfo.name\n  let majorPos? \u2190 getMajorPosIfAuxRecursor? declName majorPos?\n  forallTelescopeReducing cinfo.type fun xs type => type.withApp fun motive motiveArgs => do\n    checkMotive declName motive motiveArgs\n    let numParams := getNumParams xs motive 0\n    let (major, majorPos, depElim) \u2190 getMajorPosDepElim declName majorPos? xs motiveArgs\n    let numIndices := if depElim then motiveArgs.size - 1 else motiveArgs.size\n    if majorPos < numIndices then\n      throwError \"invalid user defined recursor '{declName}', indices must occur before major premise\"\n    let majorType \u2190 inferType major\n    majorType.withApp fun I Iargs =>\n    match I with\n    | Expr.const Iname Ilevels => do\n      let paramsPos \u2190 getParamsPos declName xs numParams Iargs\n      let indicesPos \u2190 getIndicesPos declName xs majorPos numIndices Iargs\n      let motiveType \u2190 inferType motive\n      forallTelescopeReducing motiveType fun motiveTypeParams motiveResultType => do\n        checkMotiveResultType declName motiveArgs motiveResultType motiveTypeParams\n        let motiveLvl \u2190 getMotiveLevel declName motiveResultType\n        let univLevelPos \u2190 getUnivLevelPos declName cinfo.levelParams motiveLvl Ilevels\n        let (produceMotive, recursive) \u2190 getProduceMotiveAndRecursive xs numParams numIndices majorPos motive\n        pure {\n          recursorName  := declName,\n          typeName      := Iname,\n          univLevelPos  := univLevelPos,\n          majorPos      := majorPos,\n          depElim       := depElim,\n          recursive     := recursive,\n          produceMotive := produceMotive,\n          paramsPos     := paramsPos,\n          indicesPos    := indicesPos,\n          numArgs       := xs.size\n        }\n    | _ => throwError \"invalid user defined recursor '{declName}', type of the major premise must be of the form (I ...), where I is a constant\"", "start": [204, 1], "end": [238, 145], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Attribute.Recursor.getMajorPos", "code": "def Attribute.Recursor.getMajorPos (stx : Syntax) : AttrM Nat := do\n  if stx.getKind == `Lean.Parser.Attr.recursor then\n    let pos := stx[1].isNatLit?.getD 0\n    if pos == 0 then\n      throwErrorAt stx \"major premise position must be greater than zero\"\n    return pos - 1\n  else\n    throwErrorAt stx \"unexpected attribute argument, numeral expected\"", "start": [243, 1], "end": [250, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkRecursorInfoCore", "code": "private def mkRecursorInfoCore (declName : Name) (majorPos? : Option Nat := none) : MetaM RecursorInfo := do\n  let cinfo \u2190 getConstInfo declName\n  match cinfo with\n  | ConstantInfo.recInfo val => mkRecursorInfoForKernelRec declName val\n  | _                        => mkRecursorInfoAux cinfo majorPos?", "start": [252, 1], "end": [256, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getMajorPos?", "code": "def getMajorPos? (env : Environment) (declName : Name) : Option Nat :=\n  recursorAttribute.getParam? env declName", "start": [267, 1], "end": [268, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkRecursorInfo", "code": "def mkRecursorInfo (declName : Name) (majorPos? : Option Nat := none) : MetaM RecursorInfo := do\n  let cinfo \u2190 getConstInfo declName\n  match cinfo with\n  | ConstantInfo.recInfo val => mkRecursorInfoForKernelRec declName val\n  | _                        => match majorPos? with\n    | none => do mkRecursorInfoAux cinfo (getMajorPos? (\u2190 getEnv) declName)\n    | _    => mkRecursorInfoAux cinfo majorPos?", "start": [270, 1], "end": [276, 48], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/Value.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.UIntTypeNames", "code": "private def UIntTypeNames : Array Name :=\n  #[``UInt8, ``UInt16, ``UInt32, ``UInt64, ``USize]", "start": [11, 1], "end": [12, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isUIntTypeName", "code": "private def isUIntTypeName (n : Name) : Bool :=\n  UIntTypeNames.contains n", "start": [14, 1], "end": [15, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isFinPatLit", "code": "def isFinPatLit (e : Expr) : Bool :=\n  e.isAppOfArity `Fin.ofNat 2 && e.appArg!.isNatLit", "start": [17, 1], "end": [18, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isUIntPatLit?", "code": "def isUIntPatLit? (v : Expr) : Option (Name \u00d7 Expr) :=\n  match v with\n  | Expr.app (Expr.const (Name.str typeName \"mk\" ..) ..) val .. =>\n    if isUIntTypeName typeName && isFinPatLit val then\n      some (typeName, val.appArg!)\n    else\n      none\n  | _ => none", "start": [20, 1], "end": [28, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isUIntPatLit", "code": "def isUIntPatLit (v : Expr) : Bool :=\n  isUIntPatLit? v |>.isSome", "start": [30, 1], "end": [31, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.foldPatValue", "code": "def foldPatValue (v : Expr) : Expr :=\n  match isUIntPatLit? v with\n  | some (typeName, numLit) => mkApp (mkConst (Name.mkStr typeName \"ofNat\")) numLit\n  | _ => v", "start": [33, 1], "end": [40, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isMatchValue", "code": "def isMatchValue (e : Expr) : Bool :=\n  e.isNatLit || e.isCharLit || e.isStringLit || isFinPatLit e || isUIntPatLit e", "start": [43, 1], "end": [45, 80], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Widget/InteractiveGoal.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Extra.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveCode.lean", "lake-packages/lean4/src/lean/Lean/Meta/PPGoal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Widget.InteractiveHypothesisBundle", "code": "structure InteractiveHypothesisBundle where\n  \n  names : Array String\n  \n  fvarIds : Array FVarId\n  type : CodeWithInfos\n  \n  val? : Option CodeWithInfos := none\n  \n  isInstance? : Option Bool := none\n  \n  isType? : Option Bool := none\n  \n  isInserted? : Option Bool := none\n  \n  isRemoved? : Option Bool := none\n  deriving Inhabited, RpcEncodable", "start": [16, 1], "end": [39, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveGoalCore", "code": "structure InteractiveGoalCore where\n  hyps : Array InteractiveHypothesisBundle\n  \n  type : CodeWithInfos\n  \n  ctx : WithRpcRef Elab.ContextInfo", "start": [41, 1], "end": [47, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveGoal", "code": "structure InteractiveGoal extends InteractiveGoalCore where\n  \n  userName? : Option String\n  \n  goalPrefix : String\n  \n  mvarId : MVarId\n  \n  isInserted? : Option Bool := none\n  \n  isRemoved? : Option Bool := none\n  deriving RpcEncodable", "start": [49, 1], "end": [62, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveTermGoal", "code": "structure InteractiveTermGoal extends InteractiveGoalCore where\n  \n  range : Lsp.Range\n  \n  term : WithRpcRef Elab.TermInfo\n  deriving RpcEncodable", "start": [64, 1], "end": [70, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveGoalCore.pretty", "code": "def InteractiveGoalCore.pretty (g : InteractiveGoalCore) (userName? : Option String)\n    (goalPrefix : String) : Format := Id.run do\n  let indent := 2 let mut ret := match userName? with\n    | some userName => f!\"case {userName}\"\n    | none          => Format.nil\n  for hyp in g.hyps do\n    ret := addLine ret\n    let names := hyp.names\n        |>.toList\n        |>.filter (\u00b7 != toString Name.anonymous)\n        |> \" \".intercalate\n    match names with\n    | \"\" =>\n      ret := ret ++ Format.group f!\":{Format.nest indent (Format.line ++ hyp.type.stripTags)}\"\n    | _ =>\n      match hyp.val? with\n      | some val =>\n        ret := ret ++ Format.group f!\"{names} : {hyp.type.stripTags} :={Format.nest indent (Format.line ++ val.stripTags)}\"\n      | none =>\n        ret := ret ++ Format.group f!\"{names} :{Format.nest indent (Format.line ++ hyp.type.stripTags)}\"\n  ret := addLine ret\n  ret ++ f!\"{goalPrefix}{Format.nest indent g.type.stripTags}\"\nwhere\n  addLine (fmt : Format) : Format :=\n    if fmt.isNil then fmt else fmt ++ Format.line", "start": [72, 1], "end": [97, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveGoal.pretty", "code": "def InteractiveGoal.pretty (g : InteractiveGoal) : Format :=\n  g.toInteractiveGoalCore.pretty g.userName? g.goalPrefix", "start": [99, 1], "end": [100, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveTermGoal.pretty", "code": "def InteractiveTermGoal.pretty (g : InteractiveTermGoal) : Format :=\n  g.toInteractiveGoalCore.pretty none \"\u22a2 \"", "start": [102, 1], "end": [103, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveGoals", "code": "structure InteractiveGoals where\n  goals : Array InteractiveGoal\n  deriving RpcEncodable", "start": [105, 1], "end": [107, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveGoals.append", "code": "def InteractiveGoals.append (l r : InteractiveGoals) : InteractiveGoals where\n  goals := l.goals ++ r.goals", "start": [109, 1], "end": [110, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.addInteractiveHypothesisBundle", "code": "def addInteractiveHypothesisBundle (hyps : Array InteractiveHypothesisBundle)\n    (ids : Array (String \u00d7 FVarId)) (type : Expr) (value? : Option Expr := none) :\n    MetaM (Array InteractiveHypothesisBundle) := do\n  if ids.size == 0 then\n    throwError \"Can only add a nonzero number of ids as an InteractiveHypothesisBundle.\"\n  let fvarIds := ids.map Prod.snd\n  let names := ids.map Prod.fst\n  return hyps.push {\n    names\n    fvarIds\n    type        := (\u2190 ppExprTagged type)\n    val?        := (\u2190 value?.mapM ppExprTagged)\n    isInstance? := if (\u2190 isClass? type).isSome then true else none\n    isType?     := if (\u2190 instantiateMVars type).isSort then true else none\n  }", "start": [116, 1], "end": [131, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.withGoalCtx", "code": "def withGoalCtx (goal : MVarId) (action : LocalContext \u2192 MetavarDecl \u2192 n \u03b1) : n \u03b1 := do\n  let mctx \u2190 getMCtx\n  let some mvarDecl := mctx.findDecl? goal\n    | throwError \"unknown goal {goal.name}\"\n  let lctx := mvarDecl.lctx |>.sanitizeNames.run' {options := (\u2190 getOptions)}\n  withLCtx lctx mvarDecl.localInstances (action lctx mvarDecl)", "start": [135, 1], "end": [140, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.goalToInteractive", "code": "def goalToInteractive (mvarId : MVarId) : MetaM InteractiveGoal := do\n  let ppAuxDecls := pp.auxDecls.get (\u2190 getOptions)\n  let ppImplDetailHyps := pp.implementationDetailHyps.get (\u2190 getOptions)\n  let showLetValues := pp.showLetValues.get (\u2190 getOptions)\n  withGoalCtx mvarId fun lctx mvarDecl => do\n    let pushPending (ids : Array (String \u00d7 FVarId)) (type? : Option Expr) (hyps : Array InteractiveHypothesisBundle)\n        : MetaM (Array InteractiveHypothesisBundle) :=\n      if ids.isEmpty then\n        pure hyps\n      else\n        match type? with\n        | none      => pure hyps\n        | some type => addInteractiveHypothesisBundle hyps ids type\n    let mut varNames : Array (String \u00d7 FVarId) := #[]\n    let mut prevType? : Option Expr := none\n    let mut hyps : Array InteractiveHypothesisBundle := #[]\n    for localDecl in lctx do\n      if !ppAuxDecls && localDecl.isAuxDecl || !ppImplDetailHyps && localDecl.isImplementationDetail then\n        continue\n      else\n        match localDecl with\n        | LocalDecl.cdecl _index fvarId varName type _ _ =>\n          let varName := toString varName\n          let type \u2190 instantiateMVars type\n          if prevType? == none || prevType? == some type then\n            varNames := varNames.push (varName, fvarId)\n          else\n            hyps \u2190 pushPending varNames prevType? hyps\n            varNames := #[(varName, fvarId)]\n          prevType? := some type\n        | LocalDecl.ldecl _index fvarId varName type val _ _ => do\n          let varName := toString varName\n          hyps \u2190 pushPending varNames prevType? hyps\n          let type \u2190 instantiateMVars type\n          let val? \u2190 if showLetValues then pure (some (\u2190 instantiateMVars val)) else pure none\n          hyps \u2190 addInteractiveHypothesisBundle hyps #[(varName, fvarId)] type val?\n          varNames := #[]\n          prevType? := none\n    hyps \u2190 pushPending varNames prevType? hyps\n    let goalTp \u2190 instantiateMVars mvarDecl.type\n    let goalFmt \u2190 ppExprTagged goalTp\n    let userName? := match mvarDecl.userName with\n      | Name.anonymous => none\n      | name           => some <| toString name.eraseMacroScopes\n    return {\n      hyps\n      type := goalFmt\n      ctx := \u27e8\u2190 Elab.ContextInfo.save\u27e9\n      userName?\n      goalPrefix := getGoalPrefix mvarDecl\n      mvarId\n    }", "start": [143, 1], "end": [198, 6], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Linter/UnusedVariables.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/ForEachExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Linter/Util.lean", "lake-packages/lean4/src/lean/Lean/Server/References.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Lean.Linter.getLinterUnusedVariables", "code": "def getLinterUnusedVariables (o : Options) : Bool := getLinterValue linter.unusedVariables o", "start": [22, 1], "end": [22, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.getLinterUnusedVariablesFunArgs", "code": "def getLinterUnusedVariablesFunArgs (o : Options) : Bool := o.get linter.unusedVariables.funArgs.name (getLinterUnusedVariables o)", "start": [23, 1], "end": [23, 131], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.getLinterUnusedVariablesPatternVars", "code": "def getLinterUnusedVariablesPatternVars (o : Options) : Bool := o.get linter.unusedVariables.patternVars.name (getLinterUnusedVariables o)", "start": [24, 1], "end": [24, 139], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.IgnoreFunction", "code": "abbrev IgnoreFunction := Syntax \u2192 Syntax.Stack \u2192 Options \u2192 Bool", "start": [26, 1], "end": [26, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.addBuiltinUnusedVariablesIgnoreFn", "code": "def addBuiltinUnusedVariablesIgnoreFn (ignoreFn : IgnoreFunction) : IO Unit := do\n  (\u2190 builtinUnusedVariablesIgnoreFnsRef.get) |> (\u00b7.push ignoreFn) |> builtinUnusedVariablesIgnoreFnsRef.set", "start": [30, 1], "end": [31, 108], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.getUnusedVariablesIgnoreFnsImpl", "code": "unsafe def getUnusedVariablesIgnoreFnsImpl : CommandElabM (Array IgnoreFunction) := do\n  let ents := unusedVariablesIgnoreFnsExt.getEntries (\u2190 getEnv)\n  let ents \u2190 ents.mapM (evalConstCheck IgnoreFunction ``IgnoreFunction)\n  return (\u2190 builtinUnusedVariablesIgnoreFnsRef.get) ++ ents", "start": [127, 1], "end": [130, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.getUnusedVariablesIgnoreFns", "code": "@[implemented_by getUnusedVariablesIgnoreFnsImpl]\nopaque getUnusedVariablesIgnoreFns : CommandElabM (Array IgnoreFunction)", "start": [132, 1], "end": [133, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.unusedVariables", "code": "def unusedVariables : Linter where\n  run cmdStx := do\n    unless getLinterUnusedVariables (\u2190 getOptions) do\n      return\n\n    if (\u2190 get).messages.hasErrors then\n      return\n\n    let some cmdStxRange := cmdStx.getRange?\n      | pure ()\n\n    let infoTrees := (\u2190 get).infoState.trees.toArray\n    let fileMap := (\u2190 read).fileMap\n\n    if (\u2190 infoTrees.anyM (\u00b7.hasSorry)) then\n      return\n\n    let refs := findModuleRefs fileMap infoTrees (allowSimultaneousBinderUse := true)\n\n    let mut vars : HashMap FVarId RefInfo := .empty\n    let mut constDecls : HashSet String.Range := .empty\n\n    for (ident, info) in refs.toList do\n      match ident with\n      | .fvar id =>\n        vars := vars.insert id info\n      | .const _ =>\n        if let some definition := info.definition then\n          if let some range := definition.stx.getRange? then\n            constDecls := constDecls.insert range\n\n    let tacticMVarAssignments : HashMap MVarId Expr :=\n      infoTrees.foldr (init := .empty) fun tree assignments =>\n        tree.foldInfo (init := assignments) (fun _ i assignments => match i with\n          | .ofTacticInfo ti =>\n            ti.mctxAfter.eAssignment.foldl (init := assignments) fun assignments mvar expr =>\n              if assignments.contains mvar then\n                assignments\n              else\n                assignments.insert mvar expr\n          | _ =>\n            assignments)\n\n    let tacticFVarUses : HashSet FVarId \u2190\n      tacticMVarAssignments.foldM (init := .empty) fun uses _ expr => do\n        let (_, s) \u2190 StateT.run (s := uses) <| expr.forEach fun e => do if e.isFVar then modify (\u00b7.insert e.fvarId!)\n        return s\n\n    let ignoreFns := (\u2190 getUnusedVariablesIgnoreFns)\n      |>.insertAt! 0 (isTopLevelDecl constDecls)\n\n    let mut unused := #[]\n    for (id, \u27e8decl?, uses\u27e9) in vars.toList do\n      let some decl := decl?\n        | continue\n      let declStx := skipDeclIdIfPresent decl.stx\n      let some range := declStx.getRange?\n        | continue\n      let some localDecl := decl.info.lctx.find? id\n        | continue\n      if !cmdStxRange.contains range.start || localDecl.userName.hasMacroScopes then\n        continue\n\n      if !uses.isEmpty || tacticFVarUses.contains id || decl.aliases.any (match \u00b7 with | .fvar id => tacticFVarUses.contains id | _ => false) then\n          continue\n\n      let opts := decl.ci.options\n      if !getLinterUnusedVariables opts then\n        continue\n\n      if let some ((id', _) :: stack) := cmdStx.findStack? (\u00b7.getRange?.any (\u00b7.includes range)) then\n        if id'.isIdent && ignoreFns.any (\u00b7 declStx stack opts) then\n          continue\n      else\n        continue\n\n      if \u2190 infoTrees.anyM fun tree => do\n        if let some macroExpansions \u2190 collectMacroExpansions? range tree then\n          return macroExpansions.any fun expansion =>\n            if let some (_ :: stack) := expansion.output.findStack? (\u00b7.getRange?.any (\u00b7.includes range)) (fun stx => stx.isIdent && stx.getRange?.any (\u00b7 == range)) then\n              ignoreFns.any (\u00b7 declStx stack opts)\n            else\n              false\n        else\n          return false\n      then\n        continue\n\n      unused := unused.push (declStx, localDecl)\n\n    for (declStx, localDecl) in unused.qsort (\u00b7.1.getPos?.get! < \u00b7.1.getPos?.get!) do\n      logLint linter.unusedVariables declStx m!\"unused variable `{localDecl.userName}`\"\n\n    return ()\nwhere\n  skipDeclIdIfPresent (stx : Syntax) : Syntax :=\n    if stx.isOfKind ``Lean.Parser.Command.declId then\n      stx[0]\n    else\n      stx\n  isTopLevelDecl (constDecls : HashSet String.Range) : IgnoreFunction := fun stx stack _ => Id.run <| do\n    let some declRange := stx.getRange?\n      | false\n    constDecls.contains declRange &&\n    !stack.matches [``Lean.Parser.Term.letIdDecl]", "start": [136, 1], "end": [252, 50], "kind": "commanddeclaration"}, {"full_name": "MessageData.isUnusedVariableWarning", "code": "def MessageData.isUnusedVariableWarning (msg : MessageData) : Bool :=\n  msg.hasTag (\u00b7 == Linter.linter.unusedVariables.name)", "start": [258, 1], "end": [259, 55], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Capabilities.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/JsonRpc.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/LanguageFeatures.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/CodeActions.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/TextSync.lean"], "premises": [{"full_name": "Lean.Lsp.CompletionItemCapabilities", "code": "structure CompletionItemCapabilities where\n  insertReplaceSupport? : Option Bool := none\n  deriving ToJson, FromJson", "start": [21, 1], "end": [23, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.CompletionClientCapabilities", "code": "structure CompletionClientCapabilities where\n  completionItem? : Option CompletionItemCapabilities := none\n  deriving ToJson, FromJson", "start": [25, 1], "end": [27, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.TextDocumentClientCapabilities", "code": "structure TextDocumentClientCapabilities where\n  completion? : Option CompletionClientCapabilities := none\n  codeAction? : Option CodeActionClientCapabilities := none\n  deriving ToJson, FromJson", "start": [29, 1], "end": [32, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ShowDocumentClientCapabilities", "code": "structure ShowDocumentClientCapabilities where\n  support : Bool\n  deriving ToJson, FromJson", "start": [34, 1], "end": [36, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WindowClientCapabilities", "code": "structure WindowClientCapabilities where\n  showDocument? : Option ShowDocumentClientCapabilities := none\n  deriving ToJson, FromJson", "start": [38, 1], "end": [40, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ChangeAnnotationSupport", "code": "structure ChangeAnnotationSupport where\n  groupsOnLabel? : Option Bool := none\n  deriving ToJson, FromJson", "start": [42, 1], "end": [44, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkspaceEditClientCapabilities", "code": "structure WorkspaceEditClientCapabilities where\n  \n  documentChanges?         : Option Bool := none\n  \n  changeAnnotationSupport? : Option ChangeAnnotationSupport := none\n  \n  resourceOperations?      : Option (Array String) := none\n  deriving ToJson, FromJson", "start": [46, 1], "end": [53, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.WorkspaceClientCapabilities", "code": "structure WorkspaceClientCapabilities where\n  applyEdit: Bool\n  workspaceEdit? : Option WorkspaceEditClientCapabilities := none\n  deriving ToJson, FromJson", "start": [55, 1], "end": [58, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ClientCapabilities", "code": "structure ClientCapabilities where\n  textDocument? : Option TextDocumentClientCapabilities := none\n  window?       : Option WindowClientCapabilities       := none\n  workspace?    : Option WorkspaceClientCapabilities    := none\n  deriving ToJson, FromJson", "start": [60, 1], "end": [64, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ServerCapabilities", "code": "structure ServerCapabilities where\n  textDocumentSync?         : Option TextDocumentSyncOptions := none\n  completionProvider?       : Option CompletionOptions       := none\n  hoverProvider             : Bool                           := false\n  documentHighlightProvider : Bool                           := false\n  documentSymbolProvider    : Bool                           := false\n  definitionProvider        : Bool                           := false\n  declarationProvider       : Bool                           := false\n  typeDefinitionProvider    : Bool                           := false\n  referencesProvider        : Bool                           := false\n  workspaceSymbolProvider   : Bool                           := false\n  foldingRangeProvider      : Bool                           := false\n  semanticTokensProvider?   : Option SemanticTokensOptions   := none\n  codeActionProvider?       : Option CodeActionOptions       := none\n  deriving ToJson, FromJson", "start": [67, 1], "end": [81, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Workspace.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.WorkspaceFolder", "code": "structure WorkspaceFolder where\n  uri : DocumentUri\n  name : String\n  deriving ToJson, FromJson", "start": [15, 1], "end": [18, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.FileSystemWatcher", "code": "structure FileSystemWatcher where\n  globPattern : String\n  kind : Option Nat := none\n  deriving FromJson, ToJson", "start": [25, 1], "end": [28, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.FileSystemWatcher.create", "code": "def create := 1", "start": [33, 1], "end": [33, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.FileSystemWatcher.change", "code": "def change := 2", "start": [34, 1], "end": [34, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.FileSystemWatcher.delete", "code": "def delete := 4", "start": [35, 1], "end": [35, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DidChangeWatchedFilesRegistrationOptions", "code": "structure DidChangeWatchedFilesRegistrationOptions where\n  watchers : Array FileSystemWatcher\n  deriving FromJson, ToJson", "start": [39, 1], "end": [41, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.FileChangeType", "code": "inductive FileChangeType\n  | Created\n  | Changed\n  | Deleted", "start": [43, 1], "end": [46, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.FileEvent", "code": "structure FileEvent where\n  uri : DocumentUri\n  type : FileChangeType\n  deriving FromJson, ToJson", "start": [62, 1], "end": [65, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.DidChangeWatchedFilesParams", "code": "structure DidChangeWatchedFilesParams where\n  changes : Array FileEvent\n  deriving FromJson, ToJson", "start": [67, 1], "end": [69, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Rat.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Rat", "code": "structure Rat where\n  private mk ::\n    num : Int\n    den : Nat := 1\n  deriving Inhabited, BEq, DecidableEq", "start": [13, 1], "end": [17, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.normalize", "code": "@[inline] def Rat.normalize (a : Rat) : Rat :=\n  let n := Nat.gcd a.num.natAbs a.den\n  if n == 1 then a else { num := a.num / n, den := a.den / n }", "start": [25, 1], "end": [27, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRat", "code": "def mkRat (num : Int) (den : Nat) : Rat :=\n  if den == 0 then { num := 0 } else Rat.normalize { num, den }", "start": [29, 1], "end": [30, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.isInt", "code": "protected def isInt (a : Rat) : Bool :=\n  a.den == 1", "start": [34, 1], "end": [35, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.lt", "code": "protected def lt (a b : Rat) : Bool :=\n  if a.num < 0 && b.num >= 0 then\n    true\n  else if a.num == 0 then\n    b.num > 0\n  else if a.num > 0 && b.num <= 0 then\n    false\n  else\n    a.num * b.den < b.num * a.den", "start": [37, 1], "end": [46, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.mul", "code": "protected def mul (a b : Rat) : Rat :=\n  let g1 := Nat.gcd a.den b.num.natAbs\n  let g2 := Nat.gcd a.num.natAbs b.den\n  { num := (a.num / g2)*(b.num / g1)\n    den := (b.den / g2)*(a.den / g1) }", "start": [48, 1], "end": [52, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.inv", "code": "protected def inv (a : Rat) : Rat :=\n  if a.num < 0 then\n    { num := - a.den, den := a.num.natAbs }\n  else if a.num == 0 then\n    a\n  else\n    { num := a.den, den := a.num.natAbs }", "start": [54, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.div", "code": "protected def div (a b : Rat) : Rat :=\n  Rat.mul a b.inv", "start": [62, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.add", "code": "protected def add (a b : Rat) : Rat :=\n  let g := Nat.gcd a.den b.den\n  if g == 1 then\n    { num := a.num * b.den + b.num * a.den, den := a.den * b.den }\n  else\n    let den := (a.den / g) * b.den\n    let num := (b.den / g) * a.num + (a.den / g) * b.num\n    let g1  := Nat.gcd num.natAbs g\n    if g1 == 1 then\n      { num, den }\n    else\n      { num := num / g1, den := den / g1 }", "start": [65, 1], "end": [76, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.sub", "code": "protected def sub (a b : Rat) : Rat :=\n  let g := Nat.gcd a.den b.den\n  if g == 1 then\n    { num := a.num * b.den - b.num * a.den, den := a.den * b.den }\n  else\n    let den := (a.den / g) * b.den\n    let num := (b.den / g) * a.num - (a.den / g) * b.num\n    let g1  := Nat.gcd num.natAbs g\n    if g1 == 1 then\n      { num, den }\n    else\n      { num := num / g1, den := den / g1 }", "start": [78, 1], "end": [89, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.neg", "code": "protected def neg (a : Rat) : Rat :=\n  { a with num := - a.num }", "start": [91, 1], "end": [92, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.floor", "code": "protected def floor (a : Rat) : Int :=\n  if a.den == 1 then\n    a.num\n  else\n    let r := a.num / a.den\n    if a.num < 0 then r - 1 else r", "start": [94, 1], "end": [99, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Rat.ceil", "code": "protected def ceil (a : Rat) : Int :=\n  if a.den == 1 then\n    a.num\n  else\n    let r := a.num / a.den\n    if a.num > 0 then r + 1 else r", "start": [101, 1], "end": [106, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/SetOption.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/InfoTree.lean", "lake-packages/lean4/src/lean/Lean/Log.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.elabSetOption", "code": "def elabSetOption (id : Syntax) (val : Syntax) : m Options := do\n  let ref \u2190 getRef\n  addCompletionInfo <| CompletionInfo.option (ref.setArgs (ref.getArgs[0:2]))\n  let optionName := id.getId.eraseMacroScopes\n  let decl \u2190 IO.toEIO (fun (ex : IO.Error) => Exception.error ref ex.toString) (getOptionDecl optionName)\n  pushInfoLeaf <| .ofOptionInfo { stx := id, optionName, declName := decl.declName }\n  let rec setOption (val : DataValue) : m Options := do\n    unless decl.defValue.sameCtor val do throwError \"type mismatch at set_option\"\n    return (\u2190 getOptions).insert optionName val\n  match val.isStrLit? with\n  | some str => setOption (DataValue.ofString str)\n  | none     =>\n  match val.isNatLit? with\n  | some num => setOption (DataValue.ofNat num)\n  | none     =>\n  match val with\n  | Syntax.atom _ \"true\"  => setOption (DataValue.ofBool true)\n  | Syntax.atom _ \"false\" => setOption (DataValue.ofBool false)\n  | _ =>\n    throwError \"unexpected set_option value {val}\"", "start": [13, 1], "end": [34, 51], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Rename.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.rename", "code": "def _root_.Lean.MVarId.rename (mvarId : MVarId) (fvarId : FVarId) (userNameNew : Name) : MetaM MVarId := mvarId.withContext do\n  mvarId.checkNotAssigned `rename\n  let lctxNew := (\u2190 getLCtx).setUserName fvarId userNameNew\n  let mvarNew \u2190 mkFreshExprMVarAt lctxNew (\u2190 getLocalInstances) (\u2190 mvarId.getType) MetavarKind.syntheticOpaque (\u2190 mvarId.getTag)\n  mvarId.assign mvarNew\n  return mvarNew.mvarId!", "start": [10, 1], "end": [18, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.rename", "code": "@[deprecated MVarId.rename]\ndef rename (mvarId : MVarId) (fvarId : FVarId) (newUserName : Name) : MetaM MVarId :=\n  mvarId.rename fvarId newUserName", "start": [20, 1], "end": [22, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Constructor.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.constructor", "code": "def _root_.Lean.MVarId.constructor (mvarId : MVarId) (cfg : ApplyConfig := {}) : MetaM (List MVarId) := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `constructor\n    let target \u2190 mvarId.getType'\n    matchConstInduct target.getAppFn\n      (fun _ => throwTacticEx `constructor mvarId \"target is not an inductive datatype\")\n      fun ival us => do\n        for ctor in ival.ctors do\n          try\n            return \u2190 mvarId.apply (Lean.mkConst ctor us) cfg\n          catch _ =>\n            pure ()\n        throwTacticEx `constructor mvarId \"no applicable constructor found\"", "start": [12, 1], "end": [28, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.constructor", "code": "@[deprecated MVarId.constructor]\ndef constructor (mvarId : MVarId) (cfg : ApplyConfig := {}) : MetaM (List MVarId) := do\n  mvarId.constructor cfg", "start": [30, 1], "end": [32, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.existsIntro", "code": "def _root_.Lean.MVarId.existsIntro (mvarId : MVarId) (w : Expr) : MetaM MVarId := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `exists\n    let target \u2190 mvarId.getType'\n    matchConstStruct target.getAppFn\n      (fun _ => throwTacticEx `exists mvarId \"target is not an inductive datatype with one constructor\")\n      fun _ us cval => do\n        if cval.numFields < 2 then\n          throwTacticEx `exists mvarId \"constructor must have at least two fields\"\n        let ctor := mkAppN (Lean.mkConst cval.name us) target.getAppArgs[:cval.numParams]\n        let ctorType \u2190 inferType ctor\n        let (mvars, _, _) \u2190 forallMetaTelescopeReducing ctorType (some (cval.numFields-2))\n        let f := mkAppN ctor mvars\n        checkApp f w\n        let [mvarId] \u2190 mvarId.apply <| mkApp f w\n          | throwTacticEx `exists mvarId \"unexpected number of subgoals\"\n        pure mvarId", "start": [34, 1], "end": [50, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.existsIntro", "code": "@[deprecated MVarId.existsIntro]\ndef existsIntro (mvarId : MVarId) (w : Expr) : MetaM MVarId := do\n  mvarId.existsIntro w", "start": [52, 1], "end": [54, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Acyclic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/MatchUtil.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.isTarget", "code": "private def isTarget (lhs rhs : Expr) : MetaM Bool := do\n  if !lhs.isFVar || !lhs.occurs rhs then\n    return false\n  else\n    return (\u2190 whnf rhs).isConstructorApp (\u2190 getEnv)", "start": [12, 1], "end": [16, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.acyclic", "code": "def acyclic (mvarId : MVarId) (h : Expr) : MetaM Bool := mvarId.withContext do\n  let type \u2190 whnfD (\u2190 inferType h)\n  trace[Meta.Tactic.acyclic] \"type: {type}\"\n  let some (_, lhs, rhs) := type.eq? | return false\n  if (\u2190 isTarget lhs rhs) then\n    go h lhs rhs\n  else if (\u2190 isTarget rhs lhs) then\n    go (\u2190 mkEqSymm h) rhs lhs\n  else\n    return false\nwhere\n  go (h lhs rhs : Expr) : MetaM Bool := do\n    try\n      let sizeOf_lhs \u2190 mkAppM ``sizeOf #[lhs]\n      let sizeOf_rhs \u2190 mkAppM ``sizeOf #[rhs]\n      let sizeOfEq \u2190 mkLT sizeOf_lhs sizeOf_rhs\n      let hlt \u2190 mkFreshExprSyntheticOpaqueMVar sizeOfEq\n      match (\u2190 simpTarget hlt.mvarId! { config.arith := true, simpTheorems := #[ (\u2190 getSimpTheorems) ] }).1 with\n      | some _ => return false\n      | none   =>\n        let heq \u2190 mkCongrArg sizeOf_lhs.appFn! (\u2190 mkEqSymm h)\n        let hlt_self \u2190 mkAppM ``Nat.lt_of_lt_of_eq #[hlt, heq]\n        let hlt_irrelf \u2190 mkAppM ``Nat.lt_irrefl #[sizeOf_lhs]\n        mvarId.assign (\u2190 mkFalseElim (\u2190 mvarId.getType) (mkApp hlt_irrelf hlt_self))\n        trace[Meta.Tactic.acyclic] \"succeeded\"\n        return true\n    catch ex =>\n      trace[Meta.Tactic.acyclic] \"failed with\\n{ex.toMessageData}\"\n      return false", "start": [18, 1], "end": [51, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Induction.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/FVarSubst.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/RecursorInfo.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Revert.lean", "lake-packages/lean4/src/lean/Lean/Meta/SynthInstance.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean"], "premises": [{"full_name": "Lean.Meta.getTargetArity", "code": "private partial def getTargetArity : Expr \u2192 Nat\n  | Expr.mdata _ b       => getTargetArity b\n  | Expr.forallE _ _ b _ => getTargetArity b + 1\n  | e                    => if e.isHeadBetaTarget then getTargetArity e.headBeta else 0", "start": [16, 1], "end": [19, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addRecParams", "code": "private def addRecParams (mvarId : MVarId) (majorTypeArgs : Array Expr) : List (Option Nat) \u2192 Expr \u2192 MetaM Expr\n  | [], recursor => pure recursor\n  | some pos :: rest, recursor =>\n    if h : pos < majorTypeArgs.size then\n      addRecParams mvarId majorTypeArgs rest (mkApp recursor (majorTypeArgs.get \u27e8pos, h\u27e9))\n    else\n      throwTacticEx `induction mvarId \"ill-formed recursor\"\n  | none :: rest, recursor => do\n    let recursorType \u2190 inferType recursor\n    let recursorType \u2190 whnfForall recursorType\n    match recursorType with\n    | Expr.forallE _ d _ _ => do\n      let param \u2190 try synthInstance d catch _ => throwTacticEx `induction mvarId \"failed to generate type class instance parameter\"\n      addRecParams mvarId majorTypeArgs rest (mkApp recursor param)\n    | _ =>\n      throwTacticEx `induction mvarId \"ill-formed recursor\"", "start": [21, 1], "end": [36, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.InductionSubgoal", "code": "structure InductionSubgoal where\n  mvarId : MVarId\n  fields : Array Expr := #[]\n  subst  : FVarSubst := {}\n  deriving Inhabited", "start": [38, 1], "end": [42, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getTypeBody", "code": "private def getTypeBody (mvarId : MVarId) (type : Expr) (x : Expr) : MetaM Expr := do\n  let type \u2190 whnfForall type\n  match type with\n  | Expr.forallE _ _ b _ => pure $ b.instantiate1 x\n  | _                    => throwTacticEx `induction mvarId \"ill-formed recursor\"", "start": [44, 1], "end": [48, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AltVarNames", "code": "structure AltVarNames where\n  explicit : Bool := false   varNames : List Name := []\n  deriving Inhabited", "start": [50, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.finalize", "code": "private partial def finalize\n    (mvarId : MVarId) (givenNames : Array AltVarNames) (recursorInfo : RecursorInfo)\n    (reverted : Array FVarId) (major : Expr) (indices : Array Expr) (baseSubst : FVarSubst) (recursor : Expr)\n    : MetaM (Array InductionSubgoal) := do\n  let target \u2190 mvarId.getType\n  let initialArity := getTargetArity target\n  let recursorType \u2190 inferType recursor\n  let numMinors := recursorInfo.produceMotive.length\n  let rec loop (pos : Nat) (minorIdx : Nat) (recursor recursorType : Expr) (consumedMajor : Bool) (subgoals : Array InductionSubgoal) := do\n    let recursorType \u2190 whnfForall recursorType\n    if recursorType.isForall && pos < recursorInfo.numArgs then\n      if pos == recursorInfo.firstIndexPos then\n        let (recursor, recursorType) \u2190 indices.foldlM (init := (recursor, recursorType)) fun (recursor, recursorType) index => do\n          let recursor := mkApp recursor index\n          let recursorType \u2190 getTypeBody mvarId recursorType index\n          pure (recursor, recursorType)\n        let recursor := mkApp recursor major\n        let recursorType \u2190 getTypeBody mvarId recursorType major\n        loop (pos+1+indices.size) minorIdx recursor recursorType true subgoals\n      else\n        let tag \u2190 mvarId.getTag\n        if minorIdx \u2265 numMinors then throwTacticEx `induction mvarId \"ill-formed recursor\"\n        match recursorType with\n        | Expr.forallE n d _ c =>\n          let d := d.headBeta\n          if c.isInstImplicit && givenNames.isEmpty then\n            match (\u2190 synthInstance? d) with\n            | some inst =>\n              let recursor := mkApp recursor inst\n              let recursorType \u2190 getTypeBody mvarId recursorType inst\n              loop (pos+1) (minorIdx+1) recursor recursorType consumedMajor subgoals\n            | none => do\n              let mvar \u2190 mkFreshExprSyntheticOpaqueMVar d (tag ++ n)\n              let recursor := mkApp recursor mvar\n              let recursorType \u2190 getTypeBody mvarId recursorType mvar\n              loop (pos+1) (minorIdx+1) recursor recursorType consumedMajor (subgoals.push { mvarId := mvar.mvarId! })\n          else\n            let arity := getTargetArity d\n            if arity < initialArity then throwTacticEx `induction mvarId \"ill-formed recursor\"\n            let nparams := arity - initialArity let nextra  := reverted.size - indices.size - 1 let minorGivenNames := if h : minorIdx < givenNames.size then givenNames.get \u27e8minorIdx, h\u27e9 else {}\n            let mvar \u2190 mkFreshExprSyntheticOpaqueMVar d (tag ++ n)\n            let recursor := mkApp recursor mvar\n            let recursorType \u2190 getTypeBody mvarId recursorType mvar\n            let mvarId' \u2190 mvar.mvarId!.tryClear major.fvarId!\n            let (fields, mvarId') \u2190  mvarId'.introN nparams minorGivenNames.varNames (useNamesForExplicitOnly := !minorGivenNames.explicit)\n            let (extra,  mvarId') \u2190 mvarId'.introNP nextra\n            let subst := reverted.size.fold (init := baseSubst) fun i (subst : FVarSubst) =>\n              if i < indices.size + 1 then subst\n              else\n                let revertedFVarId := reverted[i]!\n                let newFVarId      := extra[i - indices.size - 1]!\n                subst.insert revertedFVarId (mkFVar newFVarId)\n            let fields := fields.map mkFVar\n            loop (pos+1) (minorIdx+1) recursor recursorType consumedMajor (subgoals.push { mvarId := mvarId', fields := fields, subst := subst })\n        | _ => unreachable!\n    else\n      unless consumedMajor do throwTacticEx `induction mvarId \"ill-formed recursor\"\n      mvarId.assign recursor\n      pure subgoals\n  loop (recursorInfo.paramsPos.length + 1) 0 recursor recursorType false #[]", "start": [55, 1], "end": [120, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwUnexpectedMajorType", "code": "private def throwUnexpectedMajorType {\u03b1} (mvarId : MVarId) (majorType : Expr) : MetaM \u03b1 :=\n  throwTacticEx `induction mvarId m!\"unexpected major premise type{indentExpr majorType}\"", "start": [122, 1], "end": [123, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.induction", "code": "def _root_.Lean.MVarId.induction (mvarId : MVarId) (majorFVarId : FVarId) (recursorName : Name) (givenNames : Array AltVarNames := #[]) : MetaM (Array InductionSubgoal) :=\n  mvarId.withContext do\n    trace[Meta.Tactic.induction] \"initial\\n{MessageData.ofGoal mvarId}\"\n    mvarId.checkNotAssigned `induction\n    let majorLocalDecl \u2190 majorFVarId.getDecl\n    let recursorInfo \u2190 mkRecursorInfo recursorName\n    let some majorType \u2190 whnfUntil majorLocalDecl.type recursorInfo.typeName | throwUnexpectedMajorType mvarId majorLocalDecl.type\n    majorType.withApp fun _ majorTypeArgs => do\n      recursorInfo.paramsPos.forM fun paramPos? => do\n        match paramPos? with\n        | none          => pure ()\n        | some paramPos => if paramPos \u2265 majorTypeArgs.size then throwTacticEx `induction mvarId m!\"major premise type is ill-formed{indentExpr majorType}\"\n      let indices \u2190 recursorInfo.indicesPos.toArray.mapM fun idxPos => do\n        if idxPos \u2265 majorTypeArgs.size then throwTacticEx `induction mvarId m!\"major premise type is ill-formed{indentExpr majorType}\"\n        let idx := majorTypeArgs.get! idxPos\n        unless idx.isFVar do throwTacticEx `induction mvarId m!\"major premise type index {idx} is not a variable{indentExpr majorType}\"\n        majorTypeArgs.size.forM fun i => do\n          let arg := majorTypeArgs[i]!\n          if i != idxPos && arg == idx then\n            throwTacticEx `induction mvarId m!\"'{idx}' is an index in major premise, but it occurs more than once{indentExpr majorType}\"\n          if i < idxPos then\n            if (\u2190 exprDependsOn arg idx.fvarId!) then\n              throwTacticEx `induction mvarId m!\"'{idx}' is an index in major premise, but it occurs in previous arguments{indentExpr majorType}\"\n          if i > idxPos && recursorInfo.indicesPos.contains i && arg.isFVar then\n            let idxDecl \u2190 idx.fvarId!.getDecl\n            if (\u2190 localDeclDependsOn idxDecl arg.fvarId!) then\n              throwTacticEx `induction mvarId m!\"'{idx}' is an index in major premise, but it depends on index occurring at position #{i+1}\"\n        pure idx\n      let target \u2190 mvarId.getType\n      if (\u2190 pure !recursorInfo.depElim <&&> exprDependsOn target majorFVarId) then\n        throwTacticEx `induction mvarId m!\"recursor '{recursorName}' does not support dependent elimination, but conclusion depends on major premise\"\n      let (reverted, mvarId) \u2190 mvarId.revert ((indices.map Expr.fvarId!).push majorFVarId) true\n      let (indices', mvarId) \u2190 mvarId.introNP indices.size\n      let (majorFVarId', mvarId) \u2190 mvarId.intro1P\n      let baseSubst := Id.run do\n        let mut subst : FVarSubst := {}\n        let mut i := 0\n        for index in indices do\n          subst := subst.insert index.fvarId! (mkFVar indices'[i]!)\n          i     := i + 1\n        pure subst\n      trace[Meta.Tactic.induction] \"after revert&intro\\n{MessageData.ofGoal mvarId}\"\n      let indices := indices'.map mkFVar\n      let majorFVarId := majorFVarId'\n      let major := mkFVar majorFVarId\n      mvarId.withContext do\n        let target \u2190 mvarId.getType\n        let targetLevel \u2190 getLevel target\n        let targetLevel \u2190 normalizeLevel targetLevel\n        let majorLocalDecl \u2190 majorFVarId.getDecl\n        let some majorType \u2190 whnfUntil majorLocalDecl.type recursorInfo.typeName | throwUnexpectedMajorType mvarId majorLocalDecl.type\n        majorType.withApp fun majorTypeFn majorTypeArgs => do\n          match majorTypeFn with\n          | Expr.const _ majorTypeFnLevels => do\n            let majorTypeFnLevels := majorTypeFnLevels.toArray\n            let (recursorLevels, foundTargetLevel) \u2190 recursorInfo.univLevelPos.foldlM (init := (#[], false))\n                fun (recursorLevels, foundTargetLevel) (univPos : RecursorUnivLevelPos) => do\n                  match univPos with\n                  | RecursorUnivLevelPos.motive => pure (recursorLevels.push targetLevel, true)\n                  | RecursorUnivLevelPos.majorType idx =>\n                    if idx \u2265 majorTypeFnLevels.size then throwTacticEx `induction mvarId \"ill-formed recursor\"\n                    pure (recursorLevels.push (majorTypeFnLevels.get! idx), foundTargetLevel)\n            if !foundTargetLevel && !targetLevel.isZero then\n              throwTacticEx `induction mvarId m!\"recursor '{recursorName}' can only eliminate into Prop\"\n            let recursor := mkConst recursorName recursorLevels.toList\n            let recursor \u2190 addRecParams mvarId majorTypeArgs recursorInfo.paramsPos recursor\n            let motive := target\n            let motive \u2190 if recursorInfo.depElim then\n              pure <| mkLambda `x BinderInfo.default (\u2190 inferType major) (\u2190 motive.abstractM #[major])\n            else\n              pure motive\n            let motive \u2190 mkLambdaFVars indices motive\n            let recursor := mkApp recursor motive\n            finalize mvarId givenNames recursorInfo reverted major indices baseSubst recursor\n          | _ =>\n           throwTacticEx `induction mvarId \"major premise is not of the form (C ...)\"", "start": [125, 1], "end": [207, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.induction", "code": "@[deprecated MVarId.induction]\ndef induction (mvarId : MVarId) (majorFVarId : FVarId) (recursorName : Name) (givenNames : Array AltVarNames := #[]) : MetaM (Array InductionSubgoal) :=\n  mvarId.induction majorFVarId recursorName givenNames", "start": [209, 1], "end": [211, 55], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/CollectFVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/LocalContext.lean", "lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.CollectFVars.State", "code": "structure State where\n  visitedExpr  : ExprSet  := {}\n  fvarSet      : FVarIdSet  := {}\n  fvarIds      : Array FVarId := #[]\n  deriving Inhabited", "start": [11, 1], "end": [15, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectFVars.State.add", "code": "def State.add (s : State) (fvarId : FVarId) : State :=\n  { s with fvarSet := s.fvarSet.insert fvarId, fvarIds := s.fvarIds.push fvarId }", "start": [17, 1], "end": [18, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectFVars.Visitor", "code": "abbrev Visitor := State \u2192 State", "start": [20, 1], "end": [20, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectFVars.visit", "code": "partial def visit (e : Expr) : Visitor := fun s =>\n    if !e.hasFVar || s.visitedExpr.contains e then s\n    else main e { s with visitedExpr := s.visitedExpr.insert e }", "start": [23, 3], "end": [25, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectFVars.main", "code": "partial def main : Expr \u2192 Visitor\n    | Expr.proj _ _ e      => visit e\n    | Expr.forallE _ d b _ => visit b \u2218 visit d\n    | Expr.lam _ d b _     => visit b \u2218 visit d\n    | Expr.letE _ t v b _  => visit b \u2218 visit v \u2218 visit t\n    | Expr.app f a         => visit a \u2218 visit f\n    | Expr.mdata _ b       => visit b\n    | Expr.fvar fvarId     => fun s => s.add fvarId\n    | _                    => id", "start": [27, 3], "end": [35, 33], "kind": "commanddeclaration"}, {"full_name": "collectFVars", "code": "def collectFVars (s : CollectFVars.State) (e : Expr) : CollectFVars.State :=\n  CollectFVars.main e s", "start": [40, 1], "end": [41, 24], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/CaseValues.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Subst.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/Value.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.CaseValueSubgoal", "code": "structure CaseValueSubgoal where\n  mvarId : MVarId\n  newH   : FVarId\n  subst  : FVarSubst := {}\n  deriving Inhabited", "start": [12, 1], "end": [16, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.caseValueAux", "code": "private def caseValueAux (mvarId : MVarId) (fvarId : FVarId) (value : Expr) (hName : Name := `h) (subst : FVarSubst := {})\n    : MetaM (CaseValueSubgoal \u00d7 CaseValueSubgoal) :=\n  mvarId.withContext do\n    let tag \u2190 mvarId.getTag\n    mvarId.checkNotAssigned `caseValue\n    let target \u2190 mvarId.getType\n    let xEqValue \u2190 mkEq (mkFVar fvarId) (foldPatValue value)\n    let xNeqValue := mkApp (mkConst `Not) xEqValue\n    let thenTarget := Lean.mkForall hName BinderInfo.default xEqValue  target\n    let elseTarget := Lean.mkForall hName BinderInfo.default xNeqValue target\n    let thenMVar \u2190 mkFreshExprSyntheticOpaqueMVar thenTarget tag\n    let elseMVar \u2190 mkFreshExprSyntheticOpaqueMVar elseTarget tag\n    let val \u2190 mkAppOptM `dite #[none, xEqValue, none, thenMVar, elseMVar]\n    mvarId.assign val\n    let (elseH, elseMVarId) \u2190 elseMVar.mvarId!.intro1P\n    let elseSubgoal := { mvarId := elseMVarId, newH := elseH, subst := subst : CaseValueSubgoal }\n    let (thenH, thenMVarId) \u2190 thenMVar.mvarId!.intro1P\n    let symm   := false\n    let clearH := false\n    let (thenSubst, thenMVarId) \u2190 substCore thenMVarId thenH symm subst clearH\n    thenMVarId.withContext do\n      trace[Meta] \"subst domain: {thenSubst.domain.map (\u00b7.name)}\"\n      let thenH := (thenSubst.get thenH).fvarId!\n      trace[Meta] \"searching for decl\"\n      let _ \u2190 thenH.getDecl\n      trace[Meta] \"found decl\"\n    let thenSubgoal := { mvarId := thenMVarId, newH := (thenSubst.get thenH).fvarId!, subst := thenSubst : CaseValueSubgoal }\n    pure (thenSubgoal, elseSubgoal)", "start": [18, 1], "end": [53, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.caseValue", "code": "def caseValue (mvarId : MVarId) (fvarId : FVarId) (value : Expr) : MetaM (CaseValueSubgoal \u00d7 CaseValueSubgoal) := do\n  let s \u2190 caseValueAux mvarId fvarId value\n  appendTagSuffix s.1.mvarId `thenBranch\n  appendTagSuffix s.2.mvarId `elseBranch\n  pure s", "start": [55, 1], "end": [59, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CaseValuesSubgoal", "code": "structure CaseValuesSubgoal where\n  mvarId : MVarId\n  newHs  : Array FVarId := #[]\n  subst  : FVarSubst := {}\n  deriving Inhabited", "start": [61, 1], "end": [65, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.caseValues", "code": "def caseValues (mvarId : MVarId) (fvarId : FVarId) (values : Array Expr) (hNamePrefix := `h) (substNewEqs := false) : MetaM (Array CaseValuesSubgoal) :=\n  let rec loop : Nat \u2192 MVarId \u2192 List Expr \u2192 Array FVarId \u2192 Array CaseValuesSubgoal \u2192 MetaM (Array CaseValuesSubgoal)\n    | _, mvarId, [],    _,  _        => throwTacticEx `caseValues mvarId \"list of values must not be empty\"\n    | i, mvarId, v::vs, hs, subgoals => do\n      let (thenSubgoal, elseSubgoal) \u2190 caseValueAux mvarId fvarId v (hNamePrefix.appendIndexAfter i) {}\n      appendTagSuffix thenSubgoal.mvarId ((`case).appendIndexAfter i)\n      let thenMVarId \u2190 hs.foldlM\n        (fun thenMVarId h => match thenSubgoal.subst.get h with\n          | Expr.fvar fvarId => thenMVarId.tryClear fvarId\n          | _                => pure thenMVarId)\n        thenSubgoal.mvarId\n      let subgoals \u2190 if substNewEqs then\n         let (subst, mvarId) \u2190 substCore thenMVarId thenSubgoal.newH false thenSubgoal.subst true\n         pure <| subgoals.push { mvarId := mvarId, newHs := #[], subst := subst }\n      else\n         pure <| subgoals.push { mvarId := thenMVarId, newHs := #[thenSubgoal.newH], subst := thenSubgoal.subst }\n      match vs with\n      | [] => do\n        appendTagSuffix elseSubgoal.mvarId ((`case).appendIndexAfter (i+1))\n        pure $ subgoals.push { mvarId := elseSubgoal.mvarId, newHs := hs.push elseSubgoal.newH, subst := {} }\n      | vs => loop (i+1) elseSubgoal.mvarId vs (hs.push elseSubgoal.newH) subgoals\n  loop 1 mvarId values.toList #[] #[]", "start": [67, 1], "end": [103, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Widget/InteractiveDiagnostic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Linter/UnusedVariables.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveGoal.lean", "lake-packages/lean4/src/lean/Lean/Server/Utils.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Widget.StrictOrLazy", "code": "inductive StrictOrLazy (\u03b1 \u03b2 : Type) : Type\n  | strict : \u03b1 \u2192 StrictOrLazy \u03b1 \u03b2\n  | lazy : \u03b2 \u2192 StrictOrLazy \u03b1 \u03b2\n  deriving Inhabited, RpcEncodable", "start": [14, 1], "end": [17, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.LazyTraceChildren", "code": "structure LazyTraceChildren where\n  indent : Nat\n  children : Array (WithRpcRef MessageData)\n  deriving TypeName", "start": [19, 1], "end": [22, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.MsgEmbed", "code": "inductive MsgEmbed where\n  \n  | expr : CodeWithInfos \u2192 MsgEmbed\n  \n  | goal : InteractiveGoal \u2192 MsgEmbed\n  \n  | trace (indent : Nat) (cls : Name) (msg : TaggedText MsgEmbed) (collapsed : Bool)\n      (children : StrictOrLazy (Array (TaggedText MsgEmbed)) (WithRpcRef LazyTraceChildren))\n  deriving Inhabited, RpcEncodable", "start": [24, 1], "end": [34, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveDiagnostic", "code": "abbrev InteractiveDiagnostic := Lsp.DiagnosticWith (TaggedText MsgEmbed)", "start": [36, 1], "end": [39, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.InteractiveDiagnostic.toDiagnostic", "code": "def toDiagnostic (diag : InteractiveDiagnostic) : Lsp.Diagnostic :=\n  { diag with message := prettyTt diag.message }\nwhere\n  prettyTt (tt : TaggedText MsgEmbed) : String :=\n    let tt : TaggedText MsgEmbed := tt.rewrite fun\n      | .expr tt,  _ => .text tt.stripTags\n      | .goal g,   _ => .text (toString g.pretty)\n      | .trace .., _ => .text \"(trace)\"\n    tt.stripTags", "start": [46, 1], "end": [54, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.mkPPContext", "code": "private def mkPPContext (nCtx : NamingContext) (ctx : MessageDataContext) : PPContext := {\n  env := ctx.env, mctx := ctx.mctx, lctx := ctx.lctx, opts := ctx.opts,\n  currNamespace := nCtx.currNamespace, openDecls := nCtx.openDecls\n}", "start": [58, 1], "end": [61, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.EmbedFmt", "code": "private inductive EmbedFmt\n  \n  | code (ctx : Elab.ContextInfo) (infos : RBMap Nat Elab.Info compare)\n  \n  | goal (ctx : Elab.ContextInfo) (lctx : LocalContext) (g : MVarId)\n  \n  | trace (cls : Name) (msg : Format) (collapsed : Bool)\n    (children : StrictOrLazy (Array Format) (Array MessageData))\n  \n  | ignoreTags\n  deriving Inhabited", "start": [80, 1], "end": [90, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.MsgFmtM", "code": "private abbrev MsgFmtM := StateT (Array EmbedFmt) IO", "start": [92, 1], "end": [92, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.msgToInteractiveAux", "code": "private partial def msgToInteractiveAux (msgData : MessageData) : IO (Format \u00d7 Array EmbedFmt) :=\n  go { currNamespace := Name.anonymous, openDecls := [] } none msgData #[]\nwhere\n  pushEmbed (e : EmbedFmt) : MsgFmtM Nat :=\n    modifyGet fun es => (es.size, es.push e)\n\n  withIgnoreTags (fmt : Format) : MsgFmtM Format := do\n    let t \u2190 pushEmbed EmbedFmt.ignoreTags\n    return Format.tag t fmt\n\n  mkContextInfo (nCtx : NamingContext) (ctx : MessageDataContext) : Elab.ContextInfo := {\n    env           := ctx.env\n    mctx          := ctx.mctx\n    fileMap       := default\n    options       := ctx.opts\n    currNamespace := nCtx.currNamespace\n    openDecls     := nCtx.openDecls\n    ngen          := { namePrefix := `_diag }\n  }\n\n  go (nCtx : NamingContext) : Option MessageDataContext \u2192 MessageData \u2192 MsgFmtM Format\n  | _,         ofFormat fmt             => withIgnoreTags fmt\n  | none,      ofPPFormat fmt           => (\u00b7.fmt) <$> fmt.pp none\n  | some ctx,  ofPPFormat fmt           => do\n    let \u27e8fmt, infos\u27e9 \u2190 fmt.pp (mkPPContext nCtx ctx)\n    let t \u2190 pushEmbed <| EmbedFmt.code (mkContextInfo nCtx ctx) infos\n    return Format.tag t fmt\n  | none,      ofGoal mvarId            => pure $ \"goal \" ++ format (mkMVar mvarId)\n  | some ctx,  ofGoal mvarId            =>\n    return .tag (\u2190 pushEmbed (.goal (mkContextInfo nCtx ctx) ctx.lctx mvarId)) \"\\n\"\n  | _,         withContext ctx d        => go nCtx ctx d\n  | ctx,       withNamingContext nCtx d => go nCtx ctx d\n  | ctx,       tagged _ d               => go nCtx ctx d\n  | ctx,       nest n d                 => Format.nest n <$> go nCtx ctx d\n  | ctx,       compose d\u2081 d\u2082            => do let d\u2081 \u2190 go nCtx ctx d\u2081; let d\u2082 \u2190 go nCtx ctx d\u2082; pure $ d\u2081 ++ d\u2082\n  | ctx,       group d                  => Format.group <$> go nCtx ctx d\n  | ctx,       .trace cls header children collapsed => do\n    let header := (\u2190 go nCtx ctx header).nest 4\n    let nodes \u2190\n      if collapsed && !children.isEmpty then\n        let children := children.map fun child =>\n          MessageData.withNamingContext nCtx <|\n            match ctx with\n            | some ctx => MessageData.withContext ctx child\n            | none     => child\n        pure (.lazy children)\n      else\n        pure (.strict (\u2190 children.mapM (go nCtx ctx)))\n    let e := .trace cls header collapsed nodes\n    return .tag (\u2190 pushEmbed e) \".\\n\"", "start": [95, 1], "end": [145, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.msgToInteractive", "code": "partial def msgToInteractive (msgData : MessageData) (hasWidgets : Bool) (indent : Nat := 0) : IO (TaggedText MsgEmbed) := do\n  if !hasWidgets then\n    return (TaggedText.prettyTagged (\u2190 msgData.format)).rewrite fun _ tt => .text tt.stripTags\n  let (fmt, embeds) \u2190 msgToInteractiveAux msgData\n  let rec fmtToTT (fmt : Format) (indent : Nat) : IO (TaggedText MsgEmbed) :=\n    (TaggedText.prettyTagged fmt indent).rewriteM fun (n, col) tt =>\n      match embeds[n]! with\n        | .code ctx infos =>\n          return .tag (.expr (tagCodeInfos ctx infos tt)) default\n        | .goal ctx lctx g =>\n          ctx.runMetaM lctx do\n            return .tag (.goal (\u2190 goalToInteractive g)) default\n        | .trace cls msg collapsed children => do\n          let col := col + tt.stripTags.length - 2\n          let children \u2190\n            match children with\n              | .lazy children => pure <| .lazy \u27e8{indent := col+2, children := children.map .mk}\u27e9\n              | .strict children => pure <| .strict (\u2190 children.mapM (fmtToTT \u00b7 (col+2)))\n          return .tag (.trace indent cls (\u2190 fmtToTT msg col) collapsed children) default\n        | .ignoreTags => return .text tt.stripTags\n  fmtToTT fmt indent", "start": [147, 1], "end": [167, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.msgToInteractiveDiagnostic", "code": "def msgToInteractiveDiagnostic (text : FileMap) (m : Message) (hasWidgets : Bool) : IO InteractiveDiagnostic := do\n  let low : Lsp.Position := text.leanPosToLspPos m.pos\n  let fullHigh := text.leanPosToLspPos <| m.endPos.getD m.pos\n  let high : Lsp.Position := match m.endPos with\n    | some endPos =>\n      \n      let endPos := if !m.keepFullRange && endPos.line > m.pos.line then { line := m.pos.line + 1, column := 0 } else endPos\n      text.leanPosToLspPos endPos\n    | none        => low\n  let range : Range := \u27e8low, high\u27e9\n  let fullRange : Range := \u27e8low, fullHigh\u27e9\n  let severity? := some <| match m.severity with\n    | .information => .information\n    | .warning     => .warning\n    | .error       => .error\n  let source? := some \"Lean 4\"\n  let tags? :=\n    if m.data.isDeprecationWarning then some #[.deprecated]\n    else if m.data.isUnusedVariableWarning then some #[.unnecessary]\n    else none\n  let message \u2190 try\n      msgToInteractive m.data hasWidgets\n    catch ex =>\n      pure <| TaggedText.text s!\"[error when printing message: {ex.toString}]\"\n  pure { range, fullRange? := some fullRange, severity?, source?, message, tags? }", "start": [169, 1], "end": [196, 83], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Import.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Lean/Parser/Module.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.headerToImports", "code": "def headerToImports (header : Syntax) : Array Import :=\n  let imports := if header[0].isNone then #[{ module := `Init : Import }] else #[]\n  imports ++ header[1].getArgs.map fun stx =>\n    let runtime := !stx[1].isNone\n    let id      := stx[2].getId\n    { module := id, runtimeOnly := runtime }", "start": [11, 1], "end": [17, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.processHeader", "code": "def processHeader (header : Syntax) (opts : Options) (messages : MessageLog) (inputCtx : Parser.InputContext) (trustLevel : UInt32 := 0)\n    : IO (Environment \u00d7 MessageLog) := do\n  try\n    let env \u2190 importModules (headerToImports header) opts trustLevel\n    pure (env, messages)\n  catch e =>\n    let env \u2190 mkEmptyEnvironment\n    let spos := header.getPos?.getD 0\n    let pos  := inputCtx.fileMap.toPosition spos\n    pure (env, messages.add { fileName := inputCtx.fileName, data := toString e, pos := pos })", "start": [19, 1], "end": [28, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.parseImports", "code": "def parseImports (input : String) (fileName : Option String := none) : IO (Array Import \u00d7 Position \u00d7 MessageLog) := do\n  let fileName := fileName.getD \"<input>\"\n  let inputCtx := Parser.mkInputContext input fileName\n  let (header, parserState, messages) \u2190 Parser.parseHeader inputCtx\n  pure (headerToImports header, inputCtx.fileMap.toPosition parserState.pos, messages)", "start": [30, 1], "end": [34, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.printImports", "code": "@[export lean_print_imports]\ndef printImports (input : String) (fileName : Option String) : IO Unit := do\n  let (deps, _, _) \u2190 parseImports input fileName\n  for dep in deps do\n    let fname \u2190 findOLean dep.module\n    IO.println fname", "start": [36, 1], "end": [41, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/InitShutdown.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Workspace.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Capabilities.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.ClientInfo", "code": "structure ClientInfo where\n  name : String\n  version? : Option String := none\n  deriving ToJson, FromJson", "start": [19, 1], "end": [22, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Trace", "code": "inductive Trace where\n  | off\n  | messages\n  | verbose", "start": [24, 1], "end": [31, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Trace.hasToJson", "code": "instance Trace.hasToJson : ToJson Trace :=\n\u27e8fun\n  | Trace.off => \"off\"\n  | Trace.messages => \"messages\"\n  | Trace.verbose => \"verbose\"\u27e9", "start": [40, 1], "end": [44, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.InitializationOptions", "code": "structure InitializationOptions where\n  \n  editDelay? : Option Nat\n  \n  hasWidgets? : Option Bool\n  deriving ToJson, FromJson", "start": [46, 1], "end": [55, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.InitializeParams", "code": "structure InitializeParams where\n  processId? : Option Int := none\n  clientInfo? : Option ClientInfo := none\n  \n  rootUri? : Option String := none\n  initializationOptions? : Option InitializationOptions := none\n  capabilities : ClientCapabilities\n  \n  trace : Trace := Trace.off\n  workspaceFolders? : Option (Array WorkspaceFolder) := none\n  deriving ToJson", "start": [57, 1], "end": [68, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.InitializeParams.editDelay", "code": "def InitializeParams.editDelay (params : InitializeParams) : Nat :=\n  params.initializationOptions? |>.bind (\u00b7.editDelay?) |>.getD 200", "start": [70, 1], "end": [71, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.InitializedParams", "code": "inductive InitializedParams where\n  | mk", "start": [98, 1], "end": [99, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.ServerInfo", "code": "structure ServerInfo where\n  name : String\n  version? : Option String := none\n  deriving ToJson, FromJson", "start": [107, 1], "end": [110, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.InitializeResult", "code": "structure InitializeResult where\n  capabilities : ServerCapabilities\n  serverInfo? : Option ServerInfo := none\n  deriving ToJson, FromJson", "start": [112, 1], "end": [115, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Client.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.Registration", "code": "structure Registration where\n  id : String\n  method : String\n  registerOptions : Option Json\n  deriving ToJson, FromJson", "start": [16, 1], "end": [20, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.RegistrationParams", "code": "structure RegistrationParams where\n  registrations : Array Registration\n  deriving ToJson, FromJson", "start": [22, 1], "end": [24, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp/Ipc.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Extra.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Diagnostics.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Communication.lean"], "premises": [{"full_name": "Lean.Lsp.Ipc.ipcStdioConfig", "code": "def ipcStdioConfig : Process.StdioConfig where\n  stdin  := Process.Stdio.piped\n  stdout := Process.Stdio.piped\n  stderr := Process.Stdio.inherit", "start": [21, 1], "end": [24, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.IpcM", "code": "abbrev IpcM := ReaderT (Process.Child ipcStdioConfig) IO", "start": [26, 1], "end": [26, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.stdin", "code": "def stdin : IpcM FS.Stream := do\n  return FS.Stream.ofHandle (\u2190read).stdin", "start": [30, 1], "end": [31, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.stdout", "code": "def stdout : IpcM FS.Stream := do\n  return FS.Stream.ofHandle (\u2190read).stdout", "start": [33, 1], "end": [34, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.writeRequest", "code": "def writeRequest (r : Request \u03b1) : IpcM Unit := do\n  (\u2190stdin).writeLspRequest r", "start": [36, 1], "end": [37, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.writeNotification", "code": "def writeNotification (n : Notification \u03b1) : IpcM Unit := do\n  (\u2190stdin).writeLspNotification n", "start": [39, 1], "end": [40, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.shutdown", "code": "def shutdown (requestNo : Nat) : IpcM Unit := do\n  let hIn \u2190 stdout\n  let hOut \u2190 stdin\n  hOut.writeLspRequest \u27e8requestNo, \"shutdown\", Json.null\u27e9\n  repeat\n    let shutMsg \u2190 hIn.readLspMessage\n    match shutMsg with\n    | Message.response id result =>\n      assert! result.isNull\n      if id != requestNo then\n        throw <| IO.userError s!\"Expected id {requestNo}, got id {id}\"\n\n      hOut.writeLspNotification \u27e8\"exit\", Json.null\u27e9\n      break\n    | _ =>  pure ()", "start": [42, 1], "end": [57, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.readMessage", "code": "def readMessage : IpcM JsonRpc.Message := do\n  (\u2190stdout).readLspMessage", "start": [59, 1], "end": [60, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.readRequestAs", "code": "def readRequestAs (expectedMethod : String) (\u03b1) [FromJson \u03b1] : IpcM (Request \u03b1) := do\n  (\u2190stdout).readLspRequestAs expectedMethod \u03b1", "start": [62, 1], "end": [63, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.readResponseAs", "code": "def readResponseAs (expectedID : RequestID) (\u03b1) [FromJson \u03b1] : IpcM (Response \u03b1) := do\n  (\u2190stdout).readLspResponseAs expectedID \u03b1", "start": [65, 1], "end": [66, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.waitForExit", "code": "def waitForExit : IpcM UInt32 := do\n  (\u2190read).wait", "start": [68, 1], "end": [69, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.collectDiagnostics", "code": "partial def collectDiagnostics (waitForDiagnosticsId : RequestID := 0) (target : DocumentUri) (version : Nat)\n: IpcM (List (Notification PublishDiagnosticsParams)) := do\n  writeRequest \u27e8waitForDiagnosticsId, \"textDocument/waitForDiagnostics\", WaitForDiagnosticsParams.mk target version\u27e9\n  let rec loop : IpcM (List (Notification PublishDiagnosticsParams)) := do\n    match (\u2190readMessage) with\n    | Message.response id _ =>\n      if id == waitForDiagnosticsId then return []\n      else loop\n    | Message.responseError id _    msg _ =>\n      if id == waitForDiagnosticsId then\n        throw $ userError s!\"Waiting for diagnostics failed: {msg}\"\n      else loop\n    | Message.notification \"textDocument/publishDiagnostics\" (some param) =>\n      match fromJson? (toJson param) with\n      | Except.ok diagnosticParam => return \u27e8\"textDocument/publishDiagnostics\", diagnosticParam\u27e9 :: (\u2190loop)\n      | Except.error inner => throw $ userError s!\"Cannot decode publishDiagnostics parameters\\n{inner}\"\n    | _ => loop\n  loop", "start": [71, 1], "end": [90, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Lsp.Ipc.runWith", "code": "def runWith (lean : System.FilePath) (args : Array String := #[]) (test : IpcM \u03b1) : IO \u03b1 := do\n  let proc \u2190 Process.spawn {\n    toStdioConfig := ipcStdioConfig\n    cmd := lean.toString\n    args := args }\n  ReaderT.run test proc", "start": [92, 1], "end": [97, 24], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Solver.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Rat.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.Linear.Var", "code": "structure Var where\n  id : Nat\n  deriving Inhabited, Ord, DecidableEq, Repr", "start": [10, 1], "end": [12, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Assignment", "code": "structure Assignment where\n  val : Array Rat := #[]\n  deriving Inhabited", "start": [20, 1], "end": [22, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Assignment.size", "code": "abbrev Assignment.size (a : Assignment) : Nat :=\n  a.val.size", "start": [24, 1], "end": [25, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Assignment.get?", "code": "abbrev Assignment.get? (a : Assignment) (x : Var) : Option Rat :=\n  if h : x.id < a.size then\n    some (a.val.get \u27e8x.id, h\u27e9)\n  else\n    none", "start": [27, 1], "end": [31, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Assignment.push", "code": "abbrev Assignment.push (a : Assignment) (v : Rat) : Assignment :=\n  { a with val := a.val.push v }", "start": [33, 1], "end": [34, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Assignment.shrink", "code": "abbrev Assignment.shrink (a : Assignment) (newSize : Nat) : Assignment :=\n  { a with val := a.val.shrink newSize }", "start": [36, 1], "end": [37, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Poly", "code": "structure Poly where\n  val : Array (Int \u00d7 Var)\n  deriving Inhabited, Repr, DecidableEq", "start": [39, 1], "end": [41, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Poly.size", "code": "abbrev Poly.size (e : Poly) : Nat :=\n  e.val.size", "start": [43, 1], "end": [44, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Poly.getMaxVarCoeff", "code": "abbrev Poly.getMaxVarCoeff (e : Poly) : Int :=\n  e.val.back.1", "start": [46, 1], "end": [47, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Poly.getMaxVar", "code": "abbrev Poly.getMaxVar (e : Poly) : Var :=\n  e.val.back.2", "start": [49, 1], "end": [50, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Poly.get", "code": "abbrev Poly.get (e : Poly) (i : Fin e.size) : Int \u00d7 Var :=\n  e.val.get i", "start": [52, 1], "end": [53, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Poly.scale", "code": "def Poly.scale (d : Int) (e : Poly) : Poly :=\n  { e with val := e.val.map fun (c, x) => (c*d, x) }", "start": [55, 1], "end": [56, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Poly.add", "code": "def Poly.add (e\u2081 e\u2082 : Poly) : Poly :=\n  let rec go (i\u2081 i\u2082 : Nat) (r : Array (Int \u00d7 Var)) : Poly :=\n    if h\u2081 : i\u2081 < e\u2081.size then\n      if h\u2082 : i\u2082 < e\u2082.size then\n        let (c\u2081, x\u2081) := e\u2081.get \u27e8i\u2081, h\u2081\u27e9\n        let (c\u2082, x\u2082) := e\u2082.get \u27e8i\u2082, h\u2082\u27e9\n        if x\u2081 = x\u2082 then\n           if c\u2081 + c\u2082 = 0 then\n             go (i\u2081+1) (i\u2082+1) r\n           else\n             go (i\u2081+1) (i\u2082+1) (r.push (c\u2081+c\u2082, x\u2081))\n        else if x\u2081 < x\u2082 then\n          go (i\u2081+1) i\u2082 (r.push (c\u2081, x\u2081))\n        else\n          go i\u2081 (i\u2082+1) (r.push (c\u2082, x\u2082))\n      else\n        go (i\u2081+1) i\u2082 (r.push (e\u2081.get \u27e8i\u2081, h\u2081\u27e9))\n    else\n      if h\u2082 : i\u2082 < e\u2082.size then\n        go i\u2081 (i\u2082+1) (r.push (e\u2082.get \u27e8i\u2082, h\u2082\u27e9))\n      else\n        { val := r }\n  go 0 0 #[]\ntermination_by go i j _ => (e\u2081.size - i, e\u2082.size - j)", "start": [58, 1], "end": [81, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Poly.combine", "code": "def Poly.combine (d\u2081 : Int) (e\u2081 : Poly) (d\u2082 : Int) (e\u2082 : Poly) : Poly :=\n  let rec go (i\u2081 i\u2082 : Nat) (r : Array (Int \u00d7 Var)) : Poly :=\n    if h\u2081 : i\u2081 < e\u2081.size then\n      let (c\u2081, x\u2081) := e\u2081.get \u27e8i\u2081, h\u2081\u27e9\n      if h\u2082 : i\u2082 < e\u2082.size then\n        let (c\u2082, x\u2082) := e\u2082.get \u27e8i\u2082, h\u2082\u27e9\n        if x\u2081 = x\u2082 then\n           let c := c\u2081*d\u2081 + c\u2082*d\u2082\n           if c = 0 then\n             go (i\u2081+1) (i\u2082+1) r\n           else\n             go (i\u2081+1) (i\u2082+1) (r.push (c, x\u2081))\n        else if x\u2081 < x\u2082 then\n          go (i\u2081+1) i\u2082 (r.push (d\u2081*c\u2081, x\u2081))\n        else\n          go i\u2081 (i\u2082+1) (r.push (d\u2082*c\u2082, x\u2082))\n      else\n        go (i\u2081+1) i\u2082 (r.push (d\u2081*c\u2081, x\u2081))\n    else\n      if h\u2082 : i\u2082 < e\u2082.size then\n        let (c\u2082, x\u2082) := e\u2082.get \u27e8i\u2082, h\u2082\u27e9\n        go i\u2081 (i\u2082+1) (r.push (d\u2082*c\u2082, x\u2082))\n      else\n        { val := r }\n  go 0 0 #[]\ntermination_by go i j _ => (e\u2081.size - i, e\u2082.size - j)", "start": [83, 1], "end": [108, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Poly.eval?", "code": "def Poly.eval? (e : Poly) (a : Assignment) : Option Rat := Id.run do\n  let mut r := 0\n  for (c, x) in e.val do\n    if let some v := a.get? x then\n      r := r + c*v\n    else\n      return none\n  return r", "start": [110, 1], "end": [117, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.AssumptionId", "code": "structure AssumptionId where\n  id : Nat := 0\n  deriving Inhabited, DecidableEq, Repr", "start": [119, 1], "end": [121, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Justification", "code": "inductive Justification where\n  | combine (c\u2081 : Int) (j\u2081 : Justification) (c\u2082 : Int) (j\u2082 : Justification)\n  | assumption (id : AssumptionId)\n  deriving Inhabited, DecidableEq, BEq, Repr", "start": [123, 1], "end": [126, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.CnstrKind", "code": "inductive CnstrKind where\n  | eq | div | lt | le\n  deriving Inhabited, DecidableEq, BEq, Repr", "start": [128, 1], "end": [130, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Cnstr", "code": "structure Cnstr where\n  kind : CnstrKind\n  lhs  : Poly\n  rhs  : Int\n  jst  : Justification\n  deriving Inhabited, DecidableEq, BEq, Repr", "start": [132, 1], "end": [137, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Cnstr.isStrict", "code": "abbrev Cnstr.isStrict (c : Cnstr) : Bool :=\n  c.kind matches CnstrKind.lt", "start": [139, 1], "end": [140, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Cnstr.getBound", "code": "def Cnstr.getBound (c : Cnstr) (a : Assignment) : Rat := Id.run do\n  let mut r : Rat := c.rhs\n  for (c, x) in c.lhs.val[:c.lhs.val.size-1] do\n    if let some v := a.get? x then\n      r := r - c*v\n    else\n      unreachable!\n  let k := c.lhs.val.back.1\n  return r / k", "start": [142, 1], "end": [151, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Cnstr.isUnsat", "code": "def Cnstr.isUnsat (c : Cnstr) (a : Assignment) : Bool :=\n  if let some v := c.lhs.eval? a then\n    match c.kind with\n    | CnstrKind.eq => !(v == c.rhs)\n    | CnstrKind.lt => !(v < c.rhs)\n    | CnstrKind.le => !(v <= c.rhs)\n    | CnstrKind.div => unreachable! else\n    false", "start": [153, 1], "end": [161, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.getBestBound?", "code": "def getBestBound? (cs : Array Cnstr) (a : Assignment) (isLower isInt : Bool) : Option (Rat \u00d7 Cnstr) :=\n  let adjust (v : Rat) :=\n    if isInt then if isLower then (v.ceil : Rat) else v.floor else v\n  if h : 0 < cs.size then\n    let c0 := cs.get \u27e80, h\u27e9\n    let b  := adjust <| c0.getBound a\n    some <| cs[1:].foldl (init := (b, c0)) fun r c =>\n      let b' := adjust <| c.getBound a\n      if isLower then\n        if b' > r.1 then (b', c) else r\n      else\n        if b' < r.1 then (b', c) else r\n  else\n    none", "start": [163, 1], "end": [176, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Result", "code": "inductive Result where\n  | unsat (j : Justification)\n  | unsupported\n  | timeout\n  | sat (a : Assignment)", "start": [178, 1], "end": [182, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Context", "code": "structure Context where\n  int : Array Bool", "start": [184, 1], "end": [185, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.State", "code": "structure State where\n  lowers      : Array (Array Cnstr)\n  uppers      : Array (Array Cnstr)\n  int         : Array Bool\n  assignment  : Assignment := {} deriving Inhabited", "start": [187, 1], "end": [192, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.State.getNumVars", "code": "abbrev State.getNumVars (s : State) : Nat := s.lowers.size", "start": [194, 1], "end": [194, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.State.currVar", "code": "abbrev State.currVar (s : State) : Nat := s.assignment.size", "start": [196, 1], "end": [196, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.State.getBestLowerBound?", "code": "abbrev State.getBestLowerBound? (s : State) : Option (Rat \u00d7 Cnstr) :=\n  getBestBound? s.lowers[s.currVar]! s.assignment true s.int[s.currVar]!", "start": [198, 1], "end": [199, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.State.getBestUpperBound?", "code": "abbrev State.getBestUpperBound? (s : State) : Option (Rat \u00d7 Cnstr) :=\n  getBestBound? s.uppers[s.currVar]! s.assignment false s.int[s.currVar]!", "start": [201, 1], "end": [202, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.State.assignCurr", "code": "abbrev State.assignCurr (s : State) (v : Rat) : State :=\n  { s with assignment := s.assignment.push v }", "start": [204, 1], "end": [205, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.pickAssignment?", "code": "def pickAssignment? (lower : Rat) (lowerIsStrict : Bool) (upper : Rat) (upperIsStrict : Bool) : Option Rat :=\n  if lower == upper then\n    if lowerIsStrict || upperIsStrict then none else some lower\n  else if lower < upper then\n    if lowerIsStrict then\n      let c := if lower.isInt then lower + 1 else lower.ceil\n      if c < upper then some c else some ((lower + upper) / 2)\n    else\n      some lower\n  else\n    none", "start": [207, 1], "end": [217, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.resolve", "code": "def resolve (s : State) (cl : Cnstr) (cu : Cnstr) : Sum Result State :=\n  let kl : Int := - cl.lhs.getMaxVarCoeff\n  let ku : Int := cu.lhs.getMaxVarCoeff\n  let lhs := Poly.combine ku cl.lhs kl cu.lhs\n  let rhs := ku * cl.rhs + kl * cu.rhs\n  let c   := {\n    lhs, rhs,\n    kind := if cl.isStrict || cu.isStrict then CnstrKind.lt else CnstrKind.le\n    jst  := Justification.combine kl cl.jst ku cu.jst\n    : Cnstr }\n  if !c.isUnsat s.assignment then\n    Sum.inl Result.unsupported\n  else if lhs.size == 0 then\n    Sum.inl <| Result.unsat c.jst\n  else\n    let maxVarIdx := c.lhs.getMaxVar.id\n    match s with | { lowers, uppers, int, assignment, } =>\n      let assignment := assignment.shrink maxVarIdx\n      if c.lhs.getMaxVarCoeff < 0 then\n        let lowers := lowers.modify maxVarIdx (\u00b7.push c)\n        Sum.inr { lowers, uppers, int, assignment }\n      else\n        let uppers := uppers.modify maxVarIdx (\u00b7.push c)\n        Sum.inr { lowers, uppers, int, assignment }", "start": [219, 1], "end": [246, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.solve", "code": "def solve (n : Nat) (s : State) : Result :=\n  match n with\n  | 0   => Result.timeout\n  | n+1 =>\n    let i := s.currVar\n    if i = s.getNumVars then\n      Result.sat s.assignment else\n      match s.getBestLowerBound?, s.getBestUpperBound? with\n      | none,         none         => solve n <| s.assignCurr 0\n      | some (l, cl), none         => solve n <| s.assignCurr (if cl.isStrict then l.ceil + 1 else l.ceil)\n      | none,         some (u, cu) => solve n <| s.assignCurr (if cu.isStrict then u.floor - 1 else u.floor)\n      | some (l, cl), some (u, cu) =>\n        match pickAssignment? l cl.isStrict u cu.isStrict with\n        | some v => solve n <| s.assignCurr v\n        | none => match resolve s cl cu with\n          | Sum.inl r => r\n          | Sum.inr s => solve n s", "start": [248, 1], "end": [265, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/KAbstract.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/HeadIndex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.kabstract", "code": "def kabstract (e : Expr) (p : Expr) (occs : Occurrences := .all) : MetaM Expr := do\n  let e \u2190 instantiateMVars e\n  if p.isFVar && occs == Occurrences.all then\n    return e.abstract #[p] else\n    let pHeadIdx := p.toHeadIndex\n    let pNumArgs := p.headNumArgs\n    let rec visit (e : Expr) (offset : Nat) : StateRefT Nat MetaM Expr := do\n      let visitChildren : Unit \u2192 StateRefT Nat MetaM Expr := fun _ => do\n        match e with\n        | .app f a         => return e.updateApp! (\u2190 visit f offset) (\u2190 visit a offset)\n        | .mdata _ b       => return e.updateMData! (\u2190 visit b offset)\n        | .proj _ _ b      => return e.updateProj! (\u2190 visit b offset)\n        | .letE _ t v b _  => return e.updateLet! (\u2190 visit t offset) (\u2190 visit v offset) (\u2190 visit b (offset+1))\n        | .lam _ d b _     => return e.updateLambdaE! (\u2190 visit d offset) (\u2190 visit b (offset+1))\n        | .forallE _ d b _ => return e.updateForallE! (\u2190 visit d offset) (\u2190 visit b (offset+1))\n        | e                => return e\n      if e.hasLooseBVars then\n        visitChildren ()\n      else if e.toHeadIndex != pHeadIdx || e.headNumArgs != pNumArgs then\n        visitChildren ()\n      else if (\u2190 isDefEq e p) then\n        let i \u2190 get\n        set (i+1)\n        if occs.contains i then\n          return mkBVar offset\n        else\n          visitChildren ()\n      else\n        visitChildren ()\n    visit e 0 |>.run' 1", "start": [11, 1], "end": [53, 24], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Eval.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.evalExprCore", "code": "unsafe def evalExprCore (\u03b1) (value : Expr) (checkType : Expr \u2192 MetaM Unit) (safety := DefinitionSafety.safe) : MetaM \u03b1 :=\n  withoutModifyingEnv do\n    let name \u2190 mkFreshUserName `_tmp\n    let value \u2190 instantiateMVars value\n    if value.hasMVar then\n      throwError \"failed to evaluate expression, it contains metavariables{indentExpr value}\"\n    let type \u2190 inferType value\n    checkType type\n    let decl := Declaration.defnDecl {\n       name, levelParams := [], type\n       value, hints := ReducibilityHints.opaque,\n       safety\n    }\n    addAndCompile decl\n    evalConst \u03b1 name", "start": [10, 1], "end": [24, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.evalExpr'", "code": "unsafe def evalExpr' (\u03b1) (typeName : Name) (value : Expr) (safety := DefinitionSafety.safe) : MetaM \u03b1 :=\n  evalExprCore (safety := safety) \u03b1 value fun type => do\n    let type \u2190 whnfD type\n    unless type.isConstOf typeName do\n      throwError \"unexpected type at evalExpr{indentExpr type}\"", "start": [26, 1], "end": [30, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.evalExpr", "code": "unsafe def evalExpr (\u03b1) (expectedType : Expr) (value : Expr) (safety := DefinitionSafety.safe) : MetaM \u03b1 :=\n  evalExprCore (safety := safety) \u03b1 value fun type => do\n    unless \u2190 isDefEq type expectedType do\n      throwError \"unexpected type at `evalExpr` {\u2190 mkHasTypeButIsExpectedMsg type expectedType}\"", "start": [32, 1], "end": [35, 97], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Linter/MissingDocs.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/SetOption.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Linter/Util.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpTheorems.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Lean.Linter.getLinterMissingDocs", "code": "def getLinterMissingDocs (o : Options) : Bool := getLinterValue linter.missingDocs o", "start": [21, 1], "end": [21, 85], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.SimpleHandler", "code": "abbrev SimpleHandler := Syntax \u2192 CommandElabM Unit", "start": [26, 1], "end": [26, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.Handler", "code": "abbrev Handler := Bool \u2192 SimpleHandler", "start": [27, 1], "end": [27, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.SimpleHandler.toHandler", "code": "def SimpleHandler.toHandler (h : SimpleHandler) : Handler :=\n  fun enabled stx => if enabled then h stx else pure ()", "start": [29, 1], "end": [30, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.mkHandlerUnsafe", "code": "unsafe def mkHandlerUnsafe (constName : Name) : ImportM Handler := do\n  let env  := (\u2190 read).env\n  let opts := (\u2190 read).opts\n  match env.find? constName with\n  | none      => throw \u2191s!\"unknown constant '{constName}'\"\n  | some info => match info.type with\n    | Expr.const ``SimpleHandler _ => do\n      let h \u2190 IO.ofExcept $ env.evalConst SimpleHandler opts constName\n      pure h.toHandler\n    | Expr.const ``Handler _ =>\n      IO.ofExcept $ env.evalConst Handler opts constName\n    | _ => throw \u2191s!\"unexpected missing docs handler at '{constName}', `MissingDocs.Handler` or `MissingDocs.SimpleHandler` expected\"", "start": [32, 1], "end": [43, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.mkHandler", "code": "@[implemented_by mkHandlerUnsafe]\nopaque mkHandler (constName : Name) : ImportM Handler", "start": [45, 1], "end": [46, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.addHandler", "code": "def addHandler (env : Environment) (declName key : Name) (h : Handler) : Environment :=\n  missingDocsExt.addEntry env (declName, key, h)", "start": [62, 1], "end": [63, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.getHandlers", "code": "def getHandlers (env : Environment) : NameMap Handler := (missingDocsExt.getState env).2", "start": [65, 1], "end": [65, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.missingDocs", "code": "partial def missingDocs : Linter where\n  run stx := do\n    if let some h := (getHandlers (\u2190 getEnv)).find? stx.getKind then\n      h (getLinterMissingDocs (\u2190 getOptions)) stx", "start": [67, 1], "end": [70, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.addBuiltinHandler", "code": "def addBuiltinHandler (key : Name) (h : Handler) : IO Unit :=\n  builtinHandlersRef.modify (\u00b7.insert key h)", "start": [74, 1], "end": [75, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.lint", "code": "def lint (stx : Syntax) (msg : String) : CommandElabM Unit :=\n  logLint linter.missingDocs stx m!\"missing doc string for {msg}\"", "start": [104, 1], "end": [105, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.lintNamed", "code": "def lintNamed (stx : Syntax) (msg : String) : CommandElabM Unit :=\n  lint stx s!\"{msg} {stx.getId}\"", "start": [107, 1], "end": [108, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.lintField", "code": "def lintField (parent stx : Syntax) (msg : String) : CommandElabM Unit :=\n  lint stx s!\"{msg} {parent.getId}.{stx.getId}\"", "start": [110, 1], "end": [111, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.lintStructField", "code": "def lintStructField (parent stx : Syntax) (msg : String) : CommandElabM Unit :=\n  lint stx s!\"{msg} {parent.getId}.{stx.getId}\"", "start": [113, 1], "end": [114, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.hasInheritDoc", "code": "def hasInheritDoc (attrs : Syntax) : Bool :=\n  attrs[0][1].getSepArgs.any fun attr =>\n    attr[1].isOfKind ``Parser.Attr.simple &&\n    attr[1][0].getId.eraseMacroScopes == `inherit_doc", "start": [116, 1], "end": [119, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.declModifiersPubNoDoc", "code": "def declModifiersPubNoDoc (mods : Syntax) : Bool :=\n  mods[2][0].getKind != ``\u00abprivate\u00bb && mods[0].isNone && !hasInheritDoc mods[1]", "start": [121, 1], "end": [122, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.lintDeclHead", "code": "def lintDeclHead (k : SyntaxNodeKind) (id : Syntax) : CommandElabM Unit := do\n  if k == ``\u00ababbrev\u00bb then lintNamed id \"public abbrev\"\n  else if k == ``\u00abdef\u00bb then lintNamed id \"public def\"\n  else if k == ``\u00abopaque\u00bb then lintNamed id \"public opaque\"\n  else if k == ``\u00abaxiom\u00bb then lintNamed id \"public axiom\"\n  else if k == ``\u00abinductive\u00bb then lintNamed id \"public inductive\"\n  else if k == ``classInductive then lintNamed id \"public inductive\"\n  else if k == ``\u00abstructure\u00bb then lintNamed id \"public structure\"", "start": [124, 1], "end": [131, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkDecl", "code": "@[builtin_missing_docs_handler declaration]\ndef checkDecl : SimpleHandler := fun stx => do\n  let head := stx[0]; let rest := stx[1]\n  if head[2][0].getKind == ``\u00abprivate\u00bb then return let k := rest.getKind\n  if declModifiersPubNoDoc head then lintDeclHead k rest[1][0]\n  if k == ``\u00abinductive\u00bb || k == ``classInductive then\n    for stx in rest[4].getArgs do\n      let head := stx[2]\n      if stx[0].isNone && declModifiersPubNoDoc head then\n        lintField rest[1][0] stx[3] \"public constructor\"\n    unless rest[5].isNone do\n      for stx in rest[5][0][1].getArgs do\n        let head := stx[0]\n        if declModifiersPubNoDoc head then lintField rest[1][0] stx[1] \"computed field\"\n  else if rest.getKind == ``\u00abstructure\u00bb then\n    unless rest[5][2].isNone do\n      let redecls : HashSet String.Pos :=\n        (\u2190 get).infoState.trees.foldl (init := {}) fun s tree =>\n          tree.foldInfo (init := s) fun _ info s =>\n            if let .ofFieldRedeclInfo info := info then\n              if let some range := info.stx.getRange? then\n                s.insert range.start\n              else s\n            else s\n      let parent := rest[1][0]\n      let lint1 stx := do\n        if let some range := stx.getRange? then\n          if redecls.contains range.start then return\n        lintField parent stx \"public field\"\n      for stx in rest[5][2][0].getArgs do\n        let head := stx[0]\n        if declModifiersPubNoDoc head then\n          if stx.getKind == ``structSimpleBinder then\n            lint1 stx[1]\n          else\n            for stx in stx[2].getArgs do\n              lint1 stx", "start": [133, 1], "end": [172, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkInit", "code": "@[builtin_missing_docs_handler \u00abinitialize\u00bb]\ndef checkInit : SimpleHandler := fun stx => do\n  if !stx[2].isNone && declModifiersPubNoDoc stx[0] then\n    lintNamed stx[2][0] \"initializer\"", "start": [174, 1], "end": [177, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkNotation", "code": "@[builtin_missing_docs_handler \u00abnotation\u00bb]\ndef checkNotation : SimpleHandler := fun stx => do\n  if stx[0].isNone && stx[2][0][0].getKind != ``\u00ablocal\u00bb && !hasInheritDoc stx[1] then\n    if stx[5].isNone then lint stx[3] \"notation\"\n    else lintNamed stx[5][0][3] \"notation\"", "start": [179, 1], "end": [183, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkMixfix", "code": "@[builtin_missing_docs_handler \u00abmixfix\u00bb]\ndef checkMixfix : SimpleHandler := fun stx => do\n  if stx[0].isNone && stx[2][0][0].getKind != ``\u00ablocal\u00bb && !hasInheritDoc stx[1] then\n    if stx[5].isNone then lint stx[3] stx[3][0].getAtomVal\n    else lintNamed stx[5][0][3] stx[3][0].getAtomVal", "start": [185, 1], "end": [189, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkSyntax", "code": "@[builtin_missing_docs_handler \u00absyntax\u00bb]\ndef checkSyntax : SimpleHandler := fun stx => do\n  if stx[0].isNone && stx[2][0][0].getKind != ``\u00ablocal\u00bb && !hasInheritDoc stx[1] then\n    if stx[5].isNone then lint stx[3] \"syntax\"\n    else lintNamed stx[5][0][3] \"syntax\"", "start": [191, 1], "end": [195, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.mkSimpleHandler", "code": "def mkSimpleHandler (name : String) : SimpleHandler := fun stx => do\n  if stx[0].isNone then\n    lintNamed stx[2] name", "start": [197, 1], "end": [199, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkSyntaxAbbrev", "code": "@[builtin_missing_docs_handler syntaxAbbrev]\ndef checkSyntaxAbbrev : SimpleHandler := mkSimpleHandler \"syntax\"", "start": [201, 1], "end": [202, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkSyntaxCat", "code": "@[builtin_missing_docs_handler syntaxCat]\ndef checkSyntaxCat : SimpleHandler := mkSimpleHandler \"syntax category\"", "start": [204, 1], "end": [205, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkMacro", "code": "@[builtin_missing_docs_handler \u00abmacro\u00bb]\ndef checkMacro : SimpleHandler := fun stx => do\n  if stx[0].isNone && stx[2][0][0].getKind != ``\u00ablocal\u00bb && !hasInheritDoc stx[1] then\n    if stx[5].isNone then lint stx[3] \"macro\"\n    else lintNamed stx[5][0][3] \"macro\"", "start": [207, 1], "end": [211, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkElab", "code": "@[builtin_missing_docs_handler \u00abelab\u00bb]\ndef checkElab : SimpleHandler := fun stx => do\n  if stx[0].isNone && stx[2][0][0].getKind != ``\u00ablocal\u00bb && !hasInheritDoc stx[1] then\n    if stx[5].isNone then lint stx[3] \"elab\"\n    else lintNamed stx[5][0][3] \"elab\"", "start": [213, 1], "end": [217, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkClassAbbrev", "code": "@[builtin_missing_docs_handler classAbbrev]\ndef checkClassAbbrev : SimpleHandler := fun stx => do\n  if declModifiersPubNoDoc stx[0] then\n    lintNamed stx[3] \"class abbrev\"", "start": [219, 1], "end": [222, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkSimpLike", "code": "@[builtin_missing_docs_handler Parser.Tactic.declareSimpLikeTactic]\ndef checkSimpLike : SimpleHandler := mkSimpleHandler \"simp-like tactic\"", "start": [224, 1], "end": [225, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkRegisterBuiltinOption", "code": "@[builtin_missing_docs_handler Option.registerBuiltinOption]\ndef checkRegisterBuiltinOption : SimpleHandler := mkSimpleHandler \"option\"", "start": [227, 1], "end": [228, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkRegisterOption", "code": "@[builtin_missing_docs_handler Option.registerOption]\ndef checkRegisterOption : SimpleHandler := mkSimpleHandler \"option\"", "start": [230, 1], "end": [231, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.checkRegisterSimpAttr", "code": "@[builtin_missing_docs_handler registerSimpAttr]\ndef checkRegisterSimpAttr : SimpleHandler := mkSimpleHandler \"simp attr\"", "start": [233, 1], "end": [234, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.handleIn", "code": "@[builtin_missing_docs_handler \u00abin\u00bb]\ndef handleIn : Handler := fun _ stx => do\n  if stx[0].getKind == ``\u00abset_option\u00bb then\n    let opts \u2190 Elab.elabSetOption stx[0][1] stx[0][2]\n    withScope (fun scope => { scope with opts }) do\n      missingDocs.run stx[2]\n  else\n    missingDocs.run stx[2]", "start": [236, 1], "end": [243, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Linter.MissingDocs.handleMutual", "code": "@[builtin_missing_docs_handler \u00abmutual\u00bb]\ndef handleMutual : Handler := fun _ stx => do\n  stx[1].getArgs.forM missingDocs.run", "start": [245, 1], "end": [247, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Constructor.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Rename.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.runTermElab", "code": "def runTermElab (k : TermElabM \u03b1) (mayPostpone := false) : TacticM \u03b1 := do\n  \n  if (\u2190 read).recover then\n    go\n  else\n    Term.withoutErrToSorry go\nwhere\n  go := k <* Term.synthesizeSyntheticMVars (mayPostpone := mayPostpone)", "start": [18, 1], "end": [31, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.elabTerm", "code": "def elabTerm (stx : Syntax) (expectedType? : Option Expr) (mayPostpone := false) : TacticM Expr :=\n  withRef stx do instantiateMVars <| \u2190 runTermElab (mayPostpone := mayPostpone) do\n    Term.elabTerm stx expectedType?", "start": [33, 1], "end": [37, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.elabTermEnsuringType", "code": "def elabTermEnsuringType (stx : Syntax) (expectedType? : Option Expr) (mayPostpone := false) : TacticM Expr := do\n  let e \u2190 elabTerm stx expectedType? mayPostpone\n  match expectedType? with\n  | none => return e\n  | some expectedType =>\n    let eType \u2190 inferType e\n    unless (\u2190 withAssignableSyntheticOpaque <| isDefEq eType expectedType) do\n      Term.throwTypeMismatchError none expectedType eType e\n    return e", "start": [39, 1], "end": [52, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.closeMainGoalUsing", "code": "def closeMainGoalUsing (x : Expr \u2192 TacticM Expr) (checkUnassigned := true) : TacticM Unit :=\n  withMainContext do\n    closeMainGoal (checkUnassigned := checkUnassigned) (\u2190 x (\u2190 getMainTarget))", "start": [54, 1], "end": [57, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.logUnassignedAndAbort", "code": "def logUnassignedAndAbort (mvarIds : Array MVarId) : TacticM Unit := do\n   if (\u2190 Term.logUnassignedUsingErrorInfos mvarIds) then\n     throwAbortTactic", "start": [59, 1], "end": [61, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.filterOldMVars", "code": "def filterOldMVars (mvarIds : Array MVarId) (mvarCounterSaved : Nat) : MetaM (Array MVarId) := do\n  let mctx \u2190 getMCtx\n  return mvarIds.filter fun mvarId => (mctx.getDecl mvarId |>.index) >= mvarCounterSaved", "start": [63, 1], "end": [65, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalExact", "code": "@[builtin_tactic \u00abexact\u00bb] def evalExact : Tactic := fun stx =>\n  match stx with\n  | `(tactic| exact $e) => closeMainGoalUsing (checkUnassigned := false) fun type => do\n    let mvarCounterSaved := (\u2190 getMCtx).mvarCounter\n    let r \u2190 elabTermEnsuringType e type\n    logUnassignedAndAbort (\u2190 filterOldMVars (\u2190 getMVars r) mvarCounterSaved)\n    return r\n  | _ => throwUnsupportedSyntax", "start": [67, 1], "end": [74, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.sortMVarIdArrayByIndex", "code": "def sortMVarIdArrayByIndex [MonadMCtx m] [Monad m] (mvarIds : Array MVarId) : m (Array MVarId) := do\n  let mctx \u2190 getMCtx\n  return mvarIds.qsort fun mvarId\u2081 mvarId\u2082 =>\n    let decl\u2081 := mctx.getDecl mvarId\u2081\n    let decl\u2082 := mctx.getDecl mvarId\u2082\n    if decl\u2081.index != decl\u2082.index then\n      decl\u2081.index < decl\u2082.index\n    else\n      Name.quickLt mvarId\u2081.name mvarId\u2082.name", "start": [76, 1], "end": [84, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.sortMVarIdsByIndex", "code": "def sortMVarIdsByIndex [MonadMCtx m] [Monad m] (mvarIds : List MVarId) : m (List MVarId) :=\n  return (\u2190 sortMVarIdArrayByIndex mvarIds.toArray).toList", "start": [86, 1], "end": [87, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.withCollectingNewGoalsFrom", "code": "def withCollectingNewGoalsFrom (k : TacticM Expr) (tagSuffix : Name) (allowNaturalHoles := false) : TacticM (Expr \u00d7 List MVarId) :=\n  \n  if allowNaturalHoles then\n    withTheReader Term.Context (fun ctx => { ctx with holesAsSyntheticOpaque := ctx.holesAsSyntheticOpaque || allowNaturalHoles }) do\n      \n      withAssignableSyntheticOpaque go\n  else\n    go\nwhere\n  go := do\n    let mvarCounterSaved := (\u2190 getMCtx).mvarCounter\n    let val \u2190 k\n    let newMVarIds \u2190 getMVarsNoDelayed val\n    \n    let newMVarIds \u2190 newMVarIds.filterM fun mvarId => return !(\u2190 Term.isLetRecAuxMVar mvarId)\n    \n    let newMVarIds \u2190 filterOldMVars newMVarIds mvarCounterSaved\n    \n    unless allowNaturalHoles do\n      let naturalMVarIds \u2190 newMVarIds.filterM fun mvarId => return (\u2190 mvarId.getKind).isNatural\n      logUnassignedAndAbort naturalMVarIds\n    \n    let newMVarIds \u2190 sortMVarIdsByIndex newMVarIds.toList\n    tagUntaggedGoals (\u2190 getMainTag) tagSuffix newMVarIds\n    return (val, newMVarIds)", "start": [89, 1], "end": [142, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.elabTermWithHoles", "code": "def elabTermWithHoles (stx : Syntax) (expectedType? : Option Expr) (tagSuffix : Name) (allowNaturalHoles := false) : TacticM (Expr \u00d7 List MVarId) := do\n  withCollectingNewGoalsFrom (elabTermEnsuringType stx expectedType?) tagSuffix allowNaturalHoles", "start": [144, 1], "end": [161, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.refineCore", "code": "def refineCore (stx : Syntax) (tagSuffix : Name) (allowNaturalHoles : Bool) : TacticM Unit := do\n  withMainContext do\n    let (val, mvarIds') \u2190 elabTermWithHoles stx (\u2190 getMainTarget) tagSuffix allowNaturalHoles\n    let mvarId \u2190 getMainGoal\n    let val \u2190 instantiateMVars val\n    if val == mkMVar mvarId then\n      \n      replaceMainGoal (mvarId :: mvarIds')\n    else\n      \n      if val.findMVar? (\u00b7 == mvarId) matches some _ then\n        throwError \"'refine' tactic failed, value{indentExpr val}\\ndepends on the main goal metavariable '{mkMVar mvarId}'\"\n      mvarId.assign val\n      replaceMainGoal mvarIds'", "start": [163, 1], "end": [183, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalRefine", "code": "@[builtin_tactic \u00abrefine\u00bb] def evalRefine : Tactic := fun stx =>\n  match stx with\n  | `(tactic| refine $e) => refineCore e `refine (allowNaturalHoles := false)\n  | _                    => throwUnsupportedSyntax", "start": [185, 1], "end": [188, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalRefine'", "code": "@[builtin_tactic \u00abrefine'\u00bb] def evalRefine' : Tactic := fun stx =>\n  match stx with\n  | `(tactic| refine' $e) => refineCore e `refine' (allowNaturalHoles := true)\n  | _                     => throwUnsupportedSyntax", "start": [190, 1], "end": [193, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalSpecialize", "code": "@[builtin_tactic \u00abspecialize\u00bb] def evalSpecialize : Tactic := fun stx => withMainContext do\n  match stx with\n  | `(tactic| specialize $e:term) =>\n    let (e, mvarIds') \u2190 elabTermWithHoles e none `specialize (allowNaturalHoles := true)\n    let h := e.getAppFn\n    if h.isFVar then\n      let localDecl \u2190 h.fvarId!.getDecl\n      let mvarId \u2190 (\u2190 getMainGoal).assert localDecl.userName (\u2190 inferType e).headBeta e\n      let (_, mvarId) \u2190 mvarId.intro1P\n      let mvarId \u2190 mvarId.tryClear h.fvarId!\n      replaceMainGoal (mvarIds' ++ [mvarId])\n    else\n      throwError \"'specialize' requires a term of the form `h x_1 .. x_n` where `h` appears in the local context\"\n  | _ => throwUnsupportedSyntax", "start": [195, 1], "end": [208, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.elabTermForApply", "code": "def elabTermForApply (stx : Syntax) (mayPostpone := true) : TacticM Expr := do\n  if stx.isIdent then\n    match (\u2190 Term.resolveId? stx (withInfo := true)) with\n    | some e => return e\n    | _      => pure ()\n  \n  withoutRecover <| elabTerm stx none mayPostpone", "start": [210, 1], "end": [266, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getFVarId", "code": "def getFVarId (id : Syntax) : TacticM FVarId := withRef id do\n  let e \u2190 withMainContext do\n    elabTermForApply id (mayPostpone := false)\n  match e with\n  | Expr.fvar fvarId => return fvarId\n  | _                => throwError \"unexpected term '{e}'; expected single reference to variable\"", "start": [268, 1], "end": [274, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getFVarIds", "code": "def getFVarIds (ids : Array Syntax) : TacticM (Array FVarId) := do\n  withMainContext do ids.mapM getFVarId", "start": [276, 1], "end": [277, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalApplyLikeTactic", "code": "def evalApplyLikeTactic (tac : MVarId \u2192 Expr \u2192 MetaM (List MVarId)) (e : Syntax) : TacticM Unit := do\n  withMainContext do\n    let mut val \u2190 instantiateMVars (\u2190 elabTermForApply e)\n    if val.isMVar then\n      \n      Term.synthesizeSyntheticMVarsNoPostponing\n      val \u2190 instantiateMVars val\n    let mvarIds' \u2190 tac (\u2190 getMainGoal) val\n    Term.synthesizeSyntheticMVarsNoPostponing\n    replaceMainGoal mvarIds'", "start": [279, 1], "end": [297, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalApply", "code": "@[builtin_tactic Lean.Parser.Tactic.apply] def evalApply : Tactic := fun stx =>\n  match stx with\n  | `(tactic| apply $e) => evalApplyLikeTactic (\u00b7.apply) e\n  | _ => throwUnsupportedSyntax", "start": [299, 1], "end": [302, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalConstructor", "code": "@[builtin_tactic Lean.Parser.Tactic.constructor] def evalConstructor : Tactic := fun _ =>\n  withMainContext do\n    let mvarIds' \u2190 (\u2190 getMainGoal).constructor\n    Term.synthesizeSyntheticMVarsNoPostponing\n    replaceMainGoal mvarIds'", "start": [304, 1], "end": [308, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalWithReducible", "code": "@[builtin_tactic Lean.Parser.Tactic.withReducible] def evalWithReducible : Tactic := fun stx =>\n  withReducible <| evalTactic stx[1]", "start": [310, 1], "end": [311, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalWithReducibleAndInstances", "code": "@[builtin_tactic Lean.Parser.Tactic.withReducibleAndInstances] def evalWithReducibleAndInstances : Tactic := fun stx =>\n  withReducibleAndInstances <| evalTactic stx[1]", "start": [313, 1], "end": [314, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalWithUnfoldingAll", "code": "@[builtin_tactic Lean.Parser.Tactic.withUnfoldingAll] def evalWithUnfoldingAll : Tactic := fun stx =>\n  withTransparency TransparencyMode.all <| evalTactic stx[1]", "start": [316, 1], "end": [317, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.elabAsFVar", "code": "def elabAsFVar (stx : Syntax) (userName? : Option Name := none) : TacticM FVarId :=\n  withMainContext do\n    let e \u2190 elabTerm stx none\n    match e with\n    | .fvar fvarId => pure fvarId\n    | _ =>\n      let type \u2190 inferType e\n      let intro (userName : Name) (preserveBinderNames : Bool) : TacticM FVarId := do\n        let mvarId \u2190 getMainGoal\n        let (fvarId, mvarId) \u2190 liftMetaM do\n          let mvarId \u2190 mvarId.assert userName type e\n          Meta.intro1Core mvarId preserveBinderNames\n        replaceMainGoal [mvarId]\n        return fvarId\n      match userName? with\n      | none          => intro `h false\n      | some userName => intro userName true", "start": [319, 1], "end": [338, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalRename", "code": "@[builtin_tactic Lean.Parser.Tactic.rename] def evalRename : Tactic := fun stx =>\n  match stx with\n  | `(tactic| rename $typeStx:term => $h:ident) => do\n    withMainContext do\n      \n      let fvarId \u2190 withoutModifyingState <| withNewMCtxDepth <| withoutRecover do\n        let type \u2190 elabTerm typeStx none (mayPostpone := true)\n        let fvarId? \u2190 (\u2190 getLCtx).findDeclRevM? fun localDecl => do\n          if (\u2190 isDefEq type localDecl.type) then return localDecl.fvarId else return none\n        match fvarId? with\n        | none => throwError \"failed to find a hypothesis with type{indentExpr type}\"\n        | some fvarId => return fvarId\n      replaceMainGoal [\u2190 (\u2190 getMainGoal).rename fvarId h.getId]\n  | _ => throwUnsupportedSyntax", "start": [340, 1], "end": [355, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.preprocessPropToDecide", "code": "private def preprocessPropToDecide (expectedType : Expr) : TermElabM Expr := do\n  let mut expectedType \u2190 instantiateMVars expectedType\n  if expectedType.hasFVar then\n    expectedType \u2190 zetaReduce expectedType\n  if expectedType.hasFVar || expectedType.hasMVar then\n    throwError \"expected type must not contain free or meta variables{indentExpr expectedType}\"\n  return expectedType", "start": [357, 1], "end": [367, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalDecide", "code": "@[builtin_tactic Lean.Parser.Tactic.decide] def evalDecide : Tactic := fun _ =>\n  closeMainGoalUsing fun expectedType => do\n    let expectedType \u2190 preprocessPropToDecide expectedType\n    let d \u2190 mkDecide expectedType\n    let d \u2190 instantiateMVars d\n    let r \u2190 withDefault <| whnf d\n    unless r.isConstOf ``true do\n      throwError \"failed to reduce to 'true'{indentExpr r}\"\n    let s := d.appArg! let rflPrf \u2190 mkEqRefl (toExpr true)\n    return mkApp3 (Lean.mkConst ``of_decide_eq_true) expectedType s rflPrf", "start": [369, 1], "end": [379, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.mkNativeAuxDecl", "code": "private def mkNativeAuxDecl (baseName : Name) (type value : Expr) : TermElabM Name := do\n  let auxName \u2190 Term.mkAuxName baseName\n  let decl := Declaration.defnDecl {\n    name := auxName, levelParams := [], type, value\n    hints := .abbrev\n    safety := .safe\n  }\n  addDecl decl\n  compileDecl decl\n  pure auxName", "start": [381, 1], "end": [390, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalNativeDecide", "code": "@[builtin_tactic Lean.Parser.Tactic.nativeDecide] def evalNativeDecide : Tactic := fun _ =>\n  closeMainGoalUsing fun expectedType => do\n    let expectedType \u2190 preprocessPropToDecide expectedType\n    let d \u2190 mkDecide expectedType\n    let auxDeclName \u2190 mkNativeAuxDecl `_nativeDecide (Lean.mkConst `Bool) d\n    let rflPrf \u2190 mkEqRefl (toExpr true)\n    let s := d.appArg! return mkApp3 (Lean.mkConst ``of_decide_eq_true) expectedType s <| mkApp3 (Lean.mkConst ``Lean.ofReduceBool) (Lean.mkConst auxDeclName) (toExpr true) rflPrf", "start": [392, 1], "end": [399, 161], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.findLocalDeclWithType?", "code": "def findLocalDeclWithType? (type : Expr) : MetaM (Option FVarId) := do\n  (\u2190 getLCtx).findDeclRevM? fun localDecl => do\n    if localDecl.isImplementationDetail then\n      return none\n    else if (\u2190 isDefEq type localDecl.type) then\n      return some localDecl.fvarId\n    else\n      return none", "start": [10, 1], "end": [18, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.assumptionCore", "code": "def _root_.Lean.MVarId.assumptionCore (mvarId : MVarId) : MetaM Bool :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `assumption\n    match (\u2190 findLocalDeclWithType? (\u2190 mvarId.getType)) with\n    | none => return false\n    | some fvarId => mvarId.assign (mkFVar fvarId); return true", "start": [20, 1], "end": [26, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.assumptionCore", "code": "@[deprecated MVarId.assumptionCore]\ndef assumptionCore (mvarId : MVarId) : MetaM Bool :=\n  mvarId.assumptionCore", "start": [28, 1], "end": [30, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.assumption", "code": "def _root_.Lean.MVarId.assumption (mvarId : MVarId) : MetaM Unit :=\n  unless (\u2190 mvarId.assumptionCore) do\n    throwTacticEx `assumption mvarId \"\"", "start": [32, 1], "end": [35, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.assumption", "code": "@[deprecated MVarId.assumption]\ndef assumption (mvarId : MVarId) : MetaM Unit :=\n  mvarId.assumption", "start": [37, 1], "end": [39, 20], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Induction.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Acyclic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Subst.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/UnifyEq.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Injection.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.Meta.throwInductiveTypeExpected", "code": "private def throwInductiveTypeExpected (type : Expr) : MetaM \u03b1 := do\n  throwError \"failed to compile pattern matching, inductive type expected{indentExpr type}\"", "start": [16, 1], "end": [17, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getInductiveUniverseAndParams", "code": "def getInductiveUniverseAndParams (type : Expr) : MetaM (List Level \u00d7 Array Expr) := do\n  let type \u2190 whnfD type\n  matchConstInduct type.getAppFn (fun _ => throwInductiveTypeExpected type) fun val us =>\n    let Iargs  := type.getAppArgs\n    let params := Iargs.extract 0 val.numParams\n    pure (us, params)", "start": [19, 1], "end": [24, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkEqAndProof", "code": "private def mkEqAndProof (lhs rhs : Expr) : MetaM (Expr \u00d7 Expr) := do\n  let lhsType \u2190 inferType lhs\n  let rhsType \u2190 inferType rhs\n  let u       \u2190 getLevel lhsType\n  if (\u2190 isDefEq lhsType rhsType) then\n    pure (mkApp3 (mkConst ``Eq [u]) lhsType lhs rhs, mkApp2 (mkConst ``Eq.refl [u]) lhsType lhs)\n  else\n    pure (mkApp4 (mkConst ``HEq [u]) lhsType lhs rhsType rhs, mkApp2 (mkConst ``HEq.refl [u]) lhsType lhs)", "start": [26, 1], "end": [33, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withNewEqs", "code": "private partial def withNewEqs (targets targetsNew : Array Expr) (k : Array Expr \u2192 Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  let rec loop (i : Nat) (newEqs : Array Expr) (newRefls : Array Expr) := do\n    if i < targets.size then\n      let (newEqType, newRefl) \u2190 mkEqAndProof targets[i]! targetsNew[i]!\n      withLocalDeclD `h newEqType fun newEq => do\n        loop (i+1) (newEqs.push newEq) (newRefls.push newRefl)\n    else\n      k newEqs newRefls\n  loop 0 #[] #[]", "start": [35, 1], "end": [43, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.generalizeTargetsEq", "code": "def generalizeTargetsEq (mvarId : MVarId) (motiveType : Expr) (targets : Array Expr) : MetaM MVarId :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `generalizeTargets\n    let (typeNew, eqRefls) \u2190\n      forallTelescopeReducing motiveType fun targetsNew _ => do\n        unless targetsNew.size == targets.size do\n          throwError \"invalid number of targets #{targets.size}, motive expects #{targetsNew.size}\"\n        withNewEqs targets targetsNew fun eqs eqRefls => do\n          let type    \u2190 mvarId.getType\n          let typeNew \u2190 mkForallFVars eqs type\n          let typeNew \u2190 mkForallFVars targetsNew typeNew\n          pure (typeNew, eqRefls)\n    let mvarNew \u2190 mkFreshExprSyntheticOpaqueMVar typeNew (\u2190 mvarId.getTag)\n    mvarId.assign (mkAppN (mkAppN mvarNew targets) eqRefls)\n    pure mvarNew.mvarId!", "start": [45, 1], "end": [59, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.GeneralizeIndicesSubgoal", "code": "structure GeneralizeIndicesSubgoal where\n  mvarId         : MVarId\n  indicesFVarIds : Array FVarId\n  fvarId         : FVarId\n  numEqs         : Nat", "start": [61, 1], "end": [65, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.generalizeIndices", "code": "def generalizeIndices (mvarId : MVarId) (fvarId : FVarId) : MetaM GeneralizeIndicesSubgoal :=\n  mvarId.withContext do\n    let lctx       \u2190 getLCtx\n    let localInsts \u2190 getLocalInstances\n    mvarId.checkNotAssigned `generalizeIndices\n    let fvarDecl \u2190 fvarId.getDecl\n    let type \u2190 whnf fvarDecl.type\n    type.withApp fun f args => matchConstInduct f (fun _ => throwTacticEx `generalizeIndices mvarId \"inductive type expected\") fun val _ => do\n      unless val.numIndices > 0 do throwTacticEx `generalizeIndices mvarId \"indexed inductive type expected\"\n      unless args.size == val.numIndices + val.numParams do throwTacticEx `generalizeIndices mvarId \"ill-formed inductive datatype\"\n      let indices := args.extract (args.size - val.numIndices) args.size\n      let IA := mkAppN f (args.extract 0 val.numParams) let IAType \u2190 inferType IA\n      forallTelescopeReducing IAType fun newIndices _ => do\n      let newType := mkAppN IA newIndices\n      withLocalDeclD fvarDecl.userName newType fun h' =>\n      withNewEqs indices newIndices fun newEqs newRefls => do\n      let (newEqType, newRefl) \u2190 mkEqAndProof fvarDecl.toExpr h'\n      let newRefls := newRefls.push newRefl\n      withLocalDeclD `h newEqType fun newEq => do\n      let newEqs := newEqs.push newEq\n      \n      let target  \u2190 mvarId.getType\n      let tag     \u2190 mvarId.getTag\n      let auxType \u2190 mkForallFVars newEqs target\n      let auxType \u2190 mkForallFVars #[h'] auxType\n      let auxType \u2190 mkForallFVars newIndices auxType\n      let newMVar \u2190 mkFreshExprMVarAt lctx localInsts auxType MetavarKind.syntheticOpaque tag\n      \n      mvarId.assign (mkAppN (mkApp (mkAppN newMVar indices) fvarDecl.toExpr) newRefls)\n      let (indicesFVarIds, newMVarId) \u2190 newMVar.mvarId!.introNP newIndices.size\n      let (fvarId, newMVarId) \u2190 newMVarId.intro1P\n      return {\n        mvarId         := newMVarId,\n        indicesFVarIds := indicesFVarIds,\n        fvarId         := fvarId,\n        numEqs         := newEqs.size\n      }", "start": [67, 1], "end": [122, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CasesSubgoal", "code": "structure CasesSubgoal extends InductionSubgoal where\n  ctorName : Name", "start": [124, 1], "end": [125, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cases.Context", "code": "structure Context where\n  inductiveVal     : InductiveVal\n  casesOnVal       : DefinitionVal\n  nminors          : Nat := inductiveVal.ctors.length\n  majorDecl        : LocalDecl\n  majorTypeFn      : Expr\n  majorTypeArgs    : Array Expr\n  majorTypeIndices : Array Expr := majorTypeArgs.extract (majorTypeArgs.size - inductiveVal.numIndices) majorTypeArgs.size", "start": [129, 1], "end": [136, 123], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cases.mkCasesContext?", "code": "private def mkCasesContext? (majorFVarId : FVarId) : MetaM (Option Context) := do\n  let env \u2190 getEnv\n  if !env.contains `Eq || !env.contains `HEq then\n    pure none\n  else\n    let majorDecl \u2190 majorFVarId.getDecl\n    let majorType \u2190 whnf majorDecl.type\n    majorType.withApp fun f args => matchConstInduct f (fun _ => pure none) fun ival _ =>\n      if args.size != ival.numIndices + ival.numParams then pure none\n      else match env.find? (Name.mkStr ival.name \"casesOn\") with\n        | ConstantInfo.defnInfo cval =>\n          return some {\n            inductiveVal  := ival,\n            casesOnVal    := cval,\n            majorDecl     := majorDecl,\n            majorTypeFn   := f,\n            majorTypeArgs := args\n          }\n        | _ => pure none", "start": [138, 1], "end": [156, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cases.hasIndepIndices", "code": "private def hasIndepIndices (ctx : Context) : MetaM Bool := do\n  if ctx.majorTypeIndices.isEmpty then\n    return true\n  else if ctx.majorTypeIndices.any fun idx => !idx.isFVar then\n    \n    return false\n  else if ctx.majorTypeIndices.size.any fun i => i.any fun j => ctx.majorTypeIndices[i]! == ctx.majorTypeIndices[j]! then\n    \n    return false\n  else\n    (\u2190 getLCtx).allM fun decl =>\n      pure (decl.fvarId == ctx.majorDecl.fvarId) <||> pure (ctx.majorTypeIndices.any (fun index => decl.fvarId == index.fvarId!)) <||> findLocalDeclDependsOn decl (fun fvarId => ctx.majorTypeIndices.all fun idx => idx.fvarId! != fvarId)", "start": [158, 1], "end": [177, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cases.elimAuxIndices", "code": "private def elimAuxIndices (s\u2081 : GeneralizeIndicesSubgoal) (s\u2082 : Array CasesSubgoal) : MetaM (Array CasesSubgoal) :=\n  let indicesFVarIds := s\u2081.indicesFVarIds\n  s\u2082.mapM fun s => do\n    indicesFVarIds.foldlM (init := s) fun s indexFVarId =>\n      match s.subst.get indexFVarId with\n      | Expr.fvar indexFVarId' =>\n        (do let mvarId \u2190 s.mvarId.clear indexFVarId'; pure { s with mvarId := mvarId, subst := s.subst.erase indexFVarId })\n        <|>\n        (pure s)\n      | _ => pure s", "start": [179, 1], "end": [188, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cases.toCasesSubgoals", "code": "private def toCasesSubgoals (s : Array InductionSubgoal) (ctorNames : Array Name) (majorFVarId : FVarId) (us : List Level) (params : Array Expr)\n    : Array CasesSubgoal :=\n  s.mapIdx fun i s =>\n    let ctorName := ctorNames[i]!\n    let ctorApp  := mkAppN (mkAppN (mkConst ctorName us) params) s.fields\n    let s        := { s with subst := s.subst.insert majorFVarId ctorApp }\n    { ctorName           := ctorName,\n      toInductionSubgoal := s }", "start": [190, 1], "end": [200, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cases.unifyEqs?", "code": "partial def unifyEqs? (numEqs : Nat) (mvarId : MVarId) (subst : FVarSubst) (caseName? : Option Name := none): MetaM (Option (MVarId \u00d7 FVarSubst)) := do\n  if numEqs == 0 then\n    return some (mvarId, subst)\n  else\n    let (eqFVarId, mvarId) \u2190 mvarId.intro1\n    if let some { mvarId, subst, numNewEqs } \u2190 unifyEq? mvarId eqFVarId subst MVarId.acyclic caseName? then\n      unifyEqs? (numEqs - 1 + numNewEqs) mvarId subst caseName?\n    else\n      return none", "start": [202, 1], "end": [210, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cases.unifyCasesEqs", "code": "private def unifyCasesEqs (numEqs : Nat) (subgoals : Array CasesSubgoal) : MetaM (Array CasesSubgoal) :=\n  subgoals.foldlM (init := #[]) fun subgoals s => do\n    match (\u2190 unifyEqs? numEqs s.mvarId s.subst s.ctorName) with\n    | none                 => pure subgoals\n    | some (mvarId, subst) =>\n      return subgoals.push { s with\n        mvarId := mvarId,\n        subst  := subst,\n        fields := s.fields.map (subst.apply \u00b7)\n      }", "start": [212, 1], "end": [221, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cases.inductionCasesOn", "code": "private def inductionCasesOn (mvarId : MVarId) (majorFVarId : FVarId) (givenNames : Array AltVarNames) (ctx : Context)\n    : MetaM (Array CasesSubgoal) := mvarId.withContext do\n  let majorType \u2190 inferType (mkFVar majorFVarId)\n  let (us, params) \u2190 getInductiveUniverseAndParams majorType\n  let casesOn := mkCasesOnName ctx.inductiveVal.name\n  let ctors   := ctx.inductiveVal.ctors.toArray\n  let s \u2190 mvarId.induction majorFVarId casesOn givenNames\n  return toCasesSubgoals s ctors majorFVarId us params", "start": [223, 1], "end": [230, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Cases.cases", "code": "def cases (mvarId : MVarId) (majorFVarId : FVarId) (givenNames : Array AltVarNames := #[]) : MetaM (Array CasesSubgoal) := do\n  try\n    mvarId.withContext do\n      mvarId.checkNotAssigned `cases\n      let context? \u2190 mkCasesContext? majorFVarId\n      match context? with\n      | none     => throwTacticEx `cases mvarId \"not applicable to the given hypothesis\"\n      | some ctx =>\n        \n        if ctx.inductiveVal.numIndices == 0 then\n          inductionCasesOn mvarId majorFVarId givenNames ctx\n        else\n          let s\u2081 \u2190 generalizeIndices mvarId majorFVarId\n          trace[Meta.Tactic.cases] \"after generalizeIndices\\n{MessageData.ofGoal s\u2081.mvarId}\"\n          let s\u2082 \u2190 inductionCasesOn s\u2081.mvarId s\u2081.fvarId givenNames ctx\n          let s\u2082 \u2190 elimAuxIndices s\u2081 s\u2082\n          unifyCasesEqs s\u2081.numEqs s\u2082\n  catch ex =>\n    throwNestedTacticEx `cases ex", "start": [232, 1], "end": [253, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.cases", "code": "def _root_.Lean.MVarId.cases (mvarId : MVarId) (majorFVarId : FVarId) (givenNames : Array AltVarNames := #[]) : MetaM (Array CasesSubgoal) :=\n  Cases.cases mvarId majorFVarId givenNames", "start": [257, 1], "end": [262, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.cases", "code": "@[deprecated MVarId.cases]\ndef cases (mvarId : MVarId) (majorFVarId : FVarId) (givenNames : Array AltVarNames := #[]) : MetaM (Array CasesSubgoal) :=\n  Cases.cases mvarId majorFVarId givenNames", "start": [264, 1], "end": [266, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.casesRec", "code": "def _root_.Lean.MVarId.casesRec (mvarId : MVarId) (p : LocalDecl \u2192 MetaM Bool) : MetaM (List MVarId) :=\n  saturate mvarId fun mvarId =>\n    mvarId.withContext do\n      for localDecl in (\u2190 getLCtx) do\n        if (\u2190 p localDecl) then\n          let r? \u2190 observing? do\n            let r \u2190 mvarId.cases localDecl.fvarId\n            return r.toList.map (\u00b7.mvarId)\n          if r?.isSome then\n            return r?\n      return none", "start": [268, 1], "end": [281, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.casesAnd", "code": "def _root_.Lean.MVarId.casesAnd (mvarId : MVarId) : MetaM MVarId := do\n  let mvarIds \u2190 mvarId.casesRec fun localDecl => return (\u2190 instantiateMVars localDecl.type).isAppOfArity ``And 2\n  exactlyOne mvarIds", "start": [283, 1], "end": [288, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.substEqs", "code": "def _root_.Lean.MVarId.substEqs (mvarId : MVarId) : MetaM (Option MVarId) := do\n  let mvarIds \u2190 mvarId.casesRec fun localDecl => do\n    let type \u2190 instantiateMVars localDecl.type\n    return type.isEq || type.isHEq\n  ensureAtMostOne mvarIds", "start": [290, 1], "end": [297, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ByCasesSubgoal", "code": "structure ByCasesSubgoal where\n  mvarId : MVarId\n  fvarId : FVarId", "start": [299, 1], "end": [302, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.toByCasesSubgoal", "code": "private def toByCasesSubgoal (s : CasesSubgoal) : MetaM ByCasesSubgoal :=  do\n    let #[Expr.fvar fvarId ..] \u2190 pure s.fields | throwError \"'byCases' tactic failed, unexpected new hypothesis\"\n    return { mvarId := s.mvarId, fvarId }", "start": [304, 1], "end": [306, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.byCases", "code": "def _root_.Lean.MVarId.byCases (mvarId : MVarId) (p : Expr) (hName : Name := `h) : MetaM (ByCasesSubgoal \u00d7 ByCasesSubgoal) := do\n  let mvarId \u2190 mvarId.assert `hByCases (mkOr p (mkNot p)) (mkEM p)\n  let (fvarId, mvarId) \u2190 mvarId.intro1\n  let #[s\u2081, s\u2082] \u2190 mvarId.cases fvarId #[{ varNames := [hName] }, { varNames := [hName] }] |\n    throwError \"'byCases' tactic failed, unexpected number of subgoals\"\n  return ((\u2190 toByCasesSubgoal s\u2081), (\u2190 toByCasesSubgoal s\u2082))", "start": [308, 1], "end": [316, 60], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/CollectFVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectFVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.collectFVars", "code": "def Expr.collectFVars (e : Expr) : StateRefT CollectFVars.State MetaM Unit := do\n  let e \u2190 instantiateMVars e\n  modify fun used => Lean.collectFVars used e", "start": [13, 1], "end": [15, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalDecl.collectFVars", "code": "def LocalDecl.collectFVars (localDecl : LocalDecl) : StateRefT CollectFVars.State MetaM Unit := do\n  match localDecl with\n  | .cdecl (type := type) .. => type.collectFVars\n  | .ldecl (type := type) (value := value) .. => type.collectFVars; value.collectFVars", "start": [17, 1], "end": [20, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.CollectFVars.State.addDependencies", "code": "partial def CollectFVars.State.addDependencies (s : CollectFVars.State) : MetaM CollectFVars.State := do\n  let (_, s) \u2190 go |>.run 0 |>.run s\n  return s\nwhere\n  getNext? : StateRefT Nat (StateRefT CollectFVars.State MetaM) (Option FVarId) := do\n    let s \u2190 getThe CollectFVars.State\n    let i \u2190 get\n    if h : i < s.fvarIds.size then\n      let r := s.fvarIds.get \u27e8i, h\u27e9\n      modify (\u00b7 + 1)\n      return some r\n    else\n      return none\n\n  go : StateRefT Nat (StateRefT CollectFVars.State MetaM) Unit := do\n    let some fvarId \u2190 getNext? | return ()\n    \n    let some localDecl := (\u2190 getLCtx).find? fvarId | return ()\n    localDecl.collectFVars\n    go", "start": [22, 1], "end": [44, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.removeUnused", "code": "def removeUnused (vars : Array Expr) (used : CollectFVars.State) : MetaM (LocalContext \u00d7 LocalInstances \u00d7 Array Expr) := do\n  let localInsts \u2190 getLocalInstances\n  let lctx \u2190 getLCtx\n  let (lctx, localInsts, newVars, _) \u2190 vars.foldrM\n    (fun var (lctx, localInsts, newVars, used) => do\n      if used.fvarSet.contains var.fvarId! then\n        let varType \u2190 inferType var\n        let (_, used) \u2190 varType.collectFVars.run used\n        pure (lctx, localInsts, newVars.push var, used)\n      else\n        pure (lctx.erase var.fvarId!, localInsts.erase var.fvarId!, newVars, used))\n    (lctx, localInsts, #[], used)\n  pure (lctx, localInsts, newVars.reverse)", "start": [48, 1], "end": [60, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/CaseArraySizes.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/CaseValues.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.CaseArraySizesSubgoal", "code": "structure CaseArraySizesSubgoal where\n  mvarId : MVarId\n  elems  : Array FVarId := #[]\n  diseqs : Array FVarId := #[]\n  subst  : FVarSubst := {}\n  deriving Inhabited", "start": [11, 1], "end": [16, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getArrayArgType", "code": "def getArrayArgType (a : Expr) : MetaM Expr := do\n  let aType \u2190 inferType a\n  let aType \u2190 whnfD aType\n  unless aType.isAppOfArity `Array 1 do\n    throwError \"array expected{indentExpr a}\"\n  pure aType.appArg!", "start": [18, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkArrayGetLit", "code": "private def mkArrayGetLit (a : Expr) (i : Nat) (n : Nat) (h : Expr) : MetaM Expr := do\n  let lt    \u2190 mkLt (mkRawNatLit i) (mkRawNatLit n)\n  let ltPrf \u2190 mkDecideProof lt\n  mkAppM `Array.getLit #[a, mkRawNatLit i, h, ltPrf]", "start": [25, 1], "end": [28, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.introArrayLit", "code": "private partial def introArrayLit (mvarId : MVarId) (a : Expr) (n : Nat) (xNamePrefix : Name) (aSizeEqN : Expr) : MetaM MVarId := do\n  let \u03b1 \u2190 getArrayArgType a\n  let rec loop (i : Nat) (xs : Array Expr) (args : Array Expr) := do\n    if i < n then\n      withLocalDeclD (xNamePrefix.appendIndexAfter (i+1)) \u03b1 fun xi => do\n        let xs := xs.push xi\n        let ai \u2190 mkArrayGetLit a i n aSizeEqN\n        let args := args.push ai\n        loop (i+1) xs args\n    else\n      let xsLit     \u2190 mkArrayLit \u03b1 xs.toList\n      let aEqXsLit  \u2190 mkEq a xsLit\n      let aEqLitPrf \u2190 mkAppM ``Array.toArrayLit_eq #[a, mkRawNatLit n, aSizeEqN]\n      withLocalDeclD `hEqALit aEqXsLit fun heq => do\n        let target    \u2190 mvarId.getType\n        let newTarget \u2190 mkForallFVars (xs.push heq) target\n        pure (newTarget, args.push aEqLitPrf)\n  let (newTarget, args) \u2190 loop 0 #[] #[]\n  let tag \u2190 mvarId.getTag\n  let newMVar   \u2190 mkFreshExprSyntheticOpaqueMVar newTarget tag\n  mvarId.assign (mkAppN newMVar args)\n  pure newMVar.mvarId!", "start": [30, 1], "end": [51, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.caseArraySizes", "code": "def caseArraySizes (mvarId : MVarId) (fvarId : FVarId) (sizes : Array Nat) (xNamePrefix := `x) (hNamePrefix := `h) : MetaM (Array CaseArraySizesSubgoal) :=\n  mvarId.withContext do\n    let a := mkFVar fvarId\n    let aSize \u2190 mkAppM `Array.size #[a]\n    let mvarId \u2190 mvarId.assertExt `aSize (mkConst `Nat) aSize\n    let (aSizeFVarId, mvarId) \u2190 mvarId.intro1\n    let (hEq, mvarId) \u2190 mvarId.intro1\n    let subgoals \u2190 caseValues mvarId aSizeFVarId (sizes.map mkRawNatLit) hNamePrefix\n    subgoals.mapIdxM fun i subgoal => do\n      let subst  := subgoal.subst\n      let mvarId := subgoal.mvarId\n      let hEqSz  := (subst.get hEq).fvarId!\n      if h : i.val < sizes.size then\n         let n := sizes.get \u27e8i, h\u27e9\n         let mvarId \u2190 mvarId.clear subgoal.newHs[0]!\n         let mvarId \u2190 mvarId.clear (subst.get aSizeFVarId).fvarId!\n         mvarId.withContext do\n           let hEqSzSymm \u2190 mkEqSymm (mkFVar hEqSz)\n           let mvarId \u2190 introArrayLit mvarId a n xNamePrefix hEqSzSymm\n           let (xs, mvarId)  \u2190 mvarId.introN n\n           let (hEqLit, mvarId) \u2190 mvarId.intro1\n           let mvarId \u2190 mvarId.clear hEqSz\n           let (subst, mvarId) \u2190 substCore mvarId hEqLit false subst\n           pure { mvarId := mvarId, elems := xs, subst := subst }\n      else\n         let (subst, mvarId) \u2190 substCore mvarId hEq false subst\n         let diseqs := subgoal.newHs.map fun fvarId => (subst.get fvarId).fvarId!\n         pure { mvarId := mvarId, diseqs := diseqs, subst := subst }", "start": [53, 1], "end": [87, 69], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Util/FoldConsts.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.FoldConstsImpl.cacheSize", "code": "abbrev cacheSize : USize := 8192 - 1", "start": [13, 1], "end": [13, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FoldConstsImpl.State", "code": "structure State where\n  visitedTerms  : Array Expr  visitedConsts : NameHashSet", "start": [15, 1], "end": [17, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FoldConstsImpl.FoldM", "code": "abbrev FoldM := StateM State", "start": [19, 1], "end": [19, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FoldConstsImpl.visited", "code": "unsafe def visited (e : Expr) (size : USize) : FoldM Bool := do\n  let s \u2190 get\n  let h := ptrAddrUnsafe e\n  let i := h % size\n  let k := s.visitedTerms.uget i lcProof\n  if ptrAddrUnsafe k == h then pure true\n  else do\n    modify fun s => { s with visitedTerms := s.visitedTerms.uset i e lcProof }\n    pure false", "start": [21, 1], "end": [29, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FoldConstsImpl.fold", "code": "unsafe def fold {\u03b1 : Type} (f : Name \u2192 \u03b1 \u2192 \u03b1) (size : USize) (e : Expr) (acc : \u03b1) : FoldM \u03b1 :=\n  let rec visit (e : Expr) (acc : \u03b1) : FoldM \u03b1 := do\n    if (\u2190 visited e size) then\n      pure acc\n    else\n      match e with\n      | Expr.forallE _ d b _   => visit b (\u2190 visit d acc)\n      | Expr.lam _ d b _       => visit b (\u2190 visit d acc)\n      | Expr.mdata _ b         => visit b acc\n      | Expr.letE _ t v b _    => visit b (\u2190 visit v (\u2190 visit t acc))\n      | Expr.app f a           => visit a (\u2190 visit f acc)\n      | Expr.proj _ _ b        => visit b acc\n      | Expr.const c _         =>\n        let s \u2190 get\n        if s.visitedConsts.contains c then\n          pure acc\n        else do\n          modify fun s => { s with visitedConsts := s.visitedConsts.insert c };\n          pure $ f c acc\n      | _                      => pure acc\n  visit e acc", "start": [31, 1], "end": [51, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FoldConstsImpl.initCache", "code": "unsafe def initCache : State :=\n  { visitedTerms  := mkArray cacheSize.toNat (cast lcProof ()),\n    visitedConsts := {} }", "start": [53, 1], "end": [55, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.FoldConstsImpl.foldUnsafe", "code": "@[inline] unsafe def foldUnsafe {\u03b1 : Type} (e : Expr) (init : \u03b1) (f : Name \u2192 \u03b1 \u2192 \u03b1) : \u03b1 :=\n  (fold f cacheSize e init).run' initCache", "start": [57, 1], "end": [58, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.foldConsts", "code": "@[implemented_by FoldConstsImpl.foldUnsafe]\nopaque foldConsts {\u03b1 : Type} (e : Expr) (init : \u03b1) (f : Name \u2192 \u03b1 \u2192 \u03b1) : \u03b1 := init", "start": [62, 1], "end": [64, 82], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getUsedConstants", "code": "def getUsedConstants (e : Expr) : Array Name :=\n  e.foldConsts #[] fun c cs => cs.push c", "start": [66, 1], "end": [67, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.getUsedConstantsAsSet", "code": "def getUsedConstantsAsSet (e : Expr) : NameSet :=\n  e.foldConsts {} fun c cs => cs.insert c", "start": [69, 1], "end": [71, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.ConstantInfo.getUsedConstantsAsSet", "code": "def getUsedConstantsAsSet (c : ConstantInfo) : NameSet :=\n  c.type.getUsedConstantsAsSet ++ match c.value? with\n  | some v => v.getUsedConstantsAsSet\n  | none => match c with\n    | .inductInfo val => .ofList val.ctors\n    | .opaqueInfo val => val.value.getUsedConstantsAsSet\n    | .ctorInfo val => ({} : NameSet).insert val.name\n    | .recInfo val => .ofList val.all\n    | _ => {}", "start": [77, 1], "end": [86, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.getMaxHeight", "code": "def getMaxHeight (env : Environment) (e : Expr) : UInt32 :=\n  e.foldConsts 0 fun constName max =>\n    match env.find? constName with\n    | ConstantInfo.defnInfo val =>\n      match val.hints with\n      | ReducibilityHints.regular h => if h > max then h else max\n      | _                           => max\n    | _ => max", "start": [90, 1], "end": [97, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/Snapshots.lean", "imports": ["lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Import.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveDiagnostic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Lean.Server.Snapshots.Snapshot", "code": "structure Snapshot where\n  \n  beginPos : String.Pos\n  stx : Syntax\n  mpState : Parser.ModuleParserState\n  cmdState : Command.State\n  \n  interactiveDiags : PersistentArray Widget.InteractiveDiagnostic\n  tacticCache : IO.Ref Tactic.Cache", "start": [26, 1], "end": [40, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.Snapshot.endPos", "code": "def endPos (s : Snapshot) : String.Pos :=\n  s.mpState.pos", "start": [44, 1], "end": [45, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.Snapshot.env", "code": "def env (s : Snapshot) : Environment :=\n  s.cmdState.env", "start": [47, 1], "end": [48, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.Snapshot.msgLog", "code": "def msgLog (s : Snapshot) : MessageLog :=\n  s.cmdState.messages", "start": [50, 1], "end": [51, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.Snapshot.diagnostics", "code": "def diagnostics (s : Snapshot) : PersistentArray Lsp.Diagnostic :=\n  s.interactiveDiags.map fun d => d.toDiagnostic", "start": [53, 1], "end": [54, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.Snapshot.infoTree", "code": "def infoTree (s : Snapshot) : InfoTree :=\n  assert! s.cmdState.infoState.trees.size == 1\n  s.cmdState.infoState.trees[0]!", "start": [56, 1], "end": [59, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.Snapshot.isAtEnd", "code": "def isAtEnd (s : Snapshot) : Bool :=\n  Parser.isTerminalCommand s.stx", "start": [61, 1], "end": [62, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.Snapshot.runCommandElabM", "code": "def runCommandElabM (snap : Snapshot) (meta : DocumentMeta) (c : CommandElabM \u03b1) : EIO Exception \u03b1 := do\n  let ctx : Command.Context := {\n    cmdPos := snap.beginPos,\n    fileName := meta.uri,\n    fileMap := meta.text,\n    tacticCache? := snap.tacticCache,\n  }\n  c.run ctx |>.run' snap.cmdState", "start": [65, 1], "end": [73, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.Snapshot.runCoreM", "code": "def runCoreM (snap : Snapshot) (meta : DocumentMeta) (c : CoreM \u03b1) : EIO Exception \u03b1 :=\n  snap.runCommandElabM meta <| Command.liftCoreM c", "start": [75, 1], "end": [77, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.Snapshot.runTermElabM", "code": "def runTermElabM (snap : Snapshot) (meta : DocumentMeta) (c : TermElabM \u03b1) : EIO Exception \u03b1 :=\n  snap.runCommandElabM meta <| Command.liftTermElabM c", "start": [79, 1], "end": [81, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.parseNextCmd", "code": "def parseNextCmd (inputCtx : Parser.InputContext) (snap : Snapshot) : IO Syntax := do\n  let cmdState := snap.cmdState\n  let scope := cmdState.scopes.head!\n  let pmctx := { env := cmdState.env, options := scope.opts, currNamespace := scope.currNamespace, openDecls := scope.openDecls }\n  let (cmdStx, _, _) :=\n    Parser.parseCommand inputCtx pmctx snap.mpState snap.msgLog\n  return cmdStx", "start": [85, 1], "end": [93, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Snapshots.compileNextCmd", "code": "def compileNextCmd (inputCtx : Parser.InputContext) (snap : Snapshot) (hasWidgets : Bool) : IO Snapshot := do\n  let cmdState := snap.cmdState\n  let scope := cmdState.scopes.head!\n  let pmctx := { env := cmdState.env, options := scope.opts, currNamespace := scope.currNamespace, openDecls := scope.openDecls }\n  let (cmdStx, cmdParserState, msgLog) :=\n    Parser.parseCommand inputCtx pmctx snap.mpState snap.msgLog\n  let cmdPos := cmdStx.getPos?.get!\n  let cmdStateRef \u2190 IO.mkRef { snap.cmdState with messages := msgLog }\n  \n  let tacticCacheNew \u2190 IO.mkRef (\u2190 snap.tacticCache.get)\n  let cmdCtx : Elab.Command.Context := {\n    cmdPos       := snap.endPos\n    fileName     := inputCtx.fileName\n    fileMap      := inputCtx.fileMap\n    tacticCache? := some tacticCacheNew\n  }\n  let (output, _) \u2190 IO.FS.withIsolatedStreams (isolateStderr := server.stderrAsMessages.get scope.opts) <| liftM (m := BaseIO) do\n    Elab.Command.catchExceptions\n      (getResetInfoTrees *> Elab.Command.elabCommandTopLevel cmdStx)\n      cmdCtx cmdStateRef\n  let postNew := (\u2190 tacticCacheNew.get).post\n  snap.tacticCache.modify fun _ => { pre := postNew, post := {} }\n  let mut postCmdState \u2190 cmdStateRef.get\n  if !output.isEmpty then\n    postCmdState := {\n      postCmdState with\n      messages := postCmdState.messages.add {\n        fileName := inputCtx.fileName\n        severity := MessageSeverity.information\n        pos      := inputCtx.fileMap.toPosition snap.endPos\n        data     := output\n      }\n    }\n  let postCmdSnap : Snapshot := {\n    beginPos := cmdPos\n    stx := cmdStx\n    mpState := cmdParserState\n    cmdState := postCmdState\n    interactiveDiags := \u2190 withNewInteractiveDiags postCmdState.messages\n    tacticCache := (\u2190 IO.mkRef {})\n  }\n  return postCmdSnap\n\nwhere\n  \n  withNewInteractiveDiags (msgLog : MessageLog) : IO (PersistentArray Widget.InteractiveDiagnostic) := do\n    let newMsgCount := msgLog.msgs.size - snap.msgLog.msgs.size\n    let mut ret := snap.interactiveDiags\n    for i in List.iota newMsgCount do\n      let newMsg := msgLog.msgs.get! (msgLog.msgs.size - i)\n      ret := ret.push (\u2190 Widget.msgToInteractiveDiagnostic inputCtx.fileMap newMsg hasWidgets)\n    return ret", "start": [101, 1], "end": [161, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/AsyncList.lean", "imports": ["lake-packages/lean4/src/lean/Init/System/IO.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IO.AsyncList", "code": "inductive AsyncList (\u03b5 : Type u) (\u03b1 : Type v) where\n  | cons (hd : \u03b1) (tl : AsyncList \u03b5 \u03b1)\n  | delayed (tl : Task $ Except \u03b5 $ AsyncList \u03b5 \u03b1)\n  | nil", "start": [13, 1], "end": [19, 8], "kind": "commanddeclaration"}, {"full_name": "IO.AsyncList.append", "code": "partial def append : AsyncList \u03b5 \u03b1 \u2192 AsyncList \u03b5 \u03b1 \u2192 AsyncList \u03b5 \u03b1\n  | cons hd tl, s => cons hd (append tl s)\n  | delayed ttl, s => delayed (ttl.map $ Except.map (append \u00b7 s))\n  | nil, s => s", "start": [26, 1], "end": [29, 16], "kind": "commanddeclaration"}, {"full_name": "IO.AsyncList.ofList", "code": "def ofList : List \u03b1 \u2192 AsyncList \u03b5 \u03b1 :=\n  List.foldr AsyncList.cons AsyncList.nil", "start": [33, 1], "end": [34, 42], "kind": "commanddeclaration"}, {"full_name": "IO.AsyncList.unfoldAsync", "code": "partial def unfoldAsync (f : StateT \u03c3 (EIO \u03b5) $ Option \u03b1) (init : \u03c3)\n    : BaseIO (AsyncList \u03b5 \u03b1) := do\n  let rec step (s : \u03c3) : EIO \u03b5 (AsyncList \u03b5 \u03b1) := do\n    let (aNext, sNext) \u2190 f s\n    match aNext with\n      | none => return nil\n      | some aNext => do\n        let tNext \u2190 EIO.asTask (step sNext)\n        return cons aNext $ delayed tNext\n\n  let tInit \u2190 EIO.asTask (step init)\n  return delayed tInit", "start": [38, 1], "end": [54, 23], "kind": "commanddeclaration"}, {"full_name": "IO.AsyncList.getAll", "code": "partial def getAll : AsyncList \u03b5 \u03b1 \u2192 List \u03b1 \u00d7 Option \u03b5\n  | cons hd tl =>\n    let \u27e8l, e?\u27e9 := tl.getAll\n    \u27e8hd :: l, e?\u27e9\n  | nil => \u27e8[], none\u27e9\n  | delayed tl =>\n    match tl.get with\n    | Except.ok tl => tl.getAll\n    | Except.error e => \u27e8[], some e\u27e9", "start": [56, 1], "end": [66, 37], "kind": "commanddeclaration"}, {"full_name": "IO.AsyncList.waitUntil", "code": "partial def waitUntil (p : \u03b1 \u2192 Bool) : AsyncList \u03b5 \u03b1 \u2192 Task (List \u03b1 \u00d7 Option \u03b5)\n  | cons hd tl =>\n    if !p hd then\n      (tl.waitUntil p).map fun \u27e8l, e?\u27e9 => \u27e8hd :: l, e?\u27e9\n    else\n      .pure \u27e8[hd], none\u27e9\n  | nil => .pure \u27e8[], none\u27e9\n  | delayed tl =>\n    tl.bind fun\n      | .ok tl   => tl.waitUntil p\n      | .error e => .pure \u27e8[], some e\u27e9", "start": [68, 1], "end": [80, 39], "kind": "commanddeclaration"}, {"full_name": "IO.AsyncList.waitAll", "code": "def waitAll : AsyncList \u03b5 \u03b1 \u2192 Task (List \u03b1 \u00d7 Option \u03b5) :=\n  waitUntil (fun _ => false)", "start": [82, 1], "end": [84, 29], "kind": "commanddeclaration"}, {"full_name": "IO.AsyncList.waitFind?", "code": "partial def waitFind? (p : \u03b1 \u2192 Bool) : AsyncList \u03b5 \u03b1 \u2192 Task (Except \u03b5 (Option \u03b1))\n  | nil => .pure <| .ok none\n  | cons hd tl =>\n    if p hd then .pure <| Except.ok <| some hd\n    else tl.waitFind? p\n  | delayed tl =>\n    tl.bind fun\n      | .ok tl   => tl.waitFind? p\n      | .error e => .pure <| .error e", "start": [86, 1], "end": [97, 38], "kind": "commanddeclaration"}, {"full_name": "IO.AsyncList.getFinishedPrefix", "code": "partial def getFinishedPrefix : AsyncList \u03b5 \u03b1 \u2192 BaseIO (List \u03b1 \u00d7 Option \u03b5)\n  | cons hd tl => do\n    let \u27e8tl, e?\u27e9 \u2190 tl.getFinishedPrefix\n    pure \u27e8hd :: tl, e?\u27e9\n  | nil => pure \u27e8[], none\u27e9\n  | delayed tl => do\n    if (\u2190 hasFinished tl) then\n      match tl.get with\n      | Except.ok tl => tl.getFinishedPrefix\n      | Except.error e => pure \u27e8[], some e\u27e9\n    else pure \u27e8[], none\u27e9", "start": [99, 1], "end": [110, 25], "kind": "commanddeclaration"}, {"full_name": "IO.AsyncList.waitHead?", "code": "def waitHead? (as : AsyncList \u03b5 \u03b1) : Task (Except \u03b5 (Option \u03b1)) :=\n  as.waitFind? fun _ => true", "start": [112, 1], "end": [113, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/Lsp.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Ipc.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Internal.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Extra.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/LanguageFeatures.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Client.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/InitShutdown.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Workspace.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Capabilities.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Basic.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/TextSync.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Diagnostics.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/CodeActions.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Communication.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Utf16.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Solver.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Solver.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.Linear.Nat.Collect.LinearArith", "code": "inductive LinearArith", "start": [13, 1], "end": [13, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.Collect.Cnstr", "code": "structure Cnstr where\n  cnstr : LinearArith\n  proof : Expr", "start": [15, 1], "end": [17, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.Collect.State", "code": "structure State where\n  cnstrs : Array Cnstr", "start": [19, 1], "end": [20, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Linear.Nat.Collect.M", "code": "abbrev M := StateRefT State ToLinear.M", "start": [22, 1], "end": [22, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Rewrite.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/KAbstract.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/MatchUtil.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.Meta.RewriteResult", "code": "structure RewriteResult where\n  eNew     : Expr\n  eqProof  : Expr\n  mvarIds  : List MVarId", "start": [14, 1], "end": [17, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.rewrite", "code": "def _root_.Lean.MVarId.rewrite (mvarId : MVarId) (e : Expr) (heq : Expr)\n    (symm : Bool := false) (config := { : Rewrite.Config }) : MetaM RewriteResult :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `rewrite\n    let heqType \u2190 instantiateMVars (\u2190 inferType heq)\n    let (newMVars, binderInfos, heqType) \u2190 forallMetaTelescopeReducing heqType\n    let heq := mkAppN heq newMVars\n    let cont (heq heqType : Expr) : MetaM RewriteResult := do\n      match (\u2190 matchEq? heqType) with\n      | none => throwTacticEx `rewrite mvarId m!\"equality or iff proof expected{indentExpr heqType}\"\n      | some (\u03b1, lhs, rhs) =>\n        let cont (heq heqType lhs rhs : Expr) : MetaM RewriteResult := do\n          if lhs.getAppFn.isMVar then\n            throwTacticEx `rewrite mvarId m!\"pattern is a metavariable{indentExpr lhs}\\nfrom equation{indentExpr heqType}\"\n          let e \u2190 instantiateMVars e\n          let eAbst \u2190 withConfig (fun oldConfig => { config, oldConfig with }) <| kabstract e lhs config.occs\n          unless eAbst.hasLooseBVars do\n            throwTacticEx `rewrite mvarId m!\"did not find instance of the pattern in the target expression{indentExpr lhs}\"\n          let eNew := eAbst.instantiate1 rhs\n          let eNew \u2190 instantiateMVars eNew\n          let eEqE \u2190 mkEq e e\n          let eEqEAbst := mkApp eEqE.appFn! eAbst\n          let motive := Lean.mkLambda `_a BinderInfo.default \u03b1 eEqEAbst\n          unless (\u2190 isTypeCorrect motive) do\n            throwTacticEx `rewrite mvarId \"motive is not type correct\"\n          let eqRefl \u2190 mkEqRefl e\n          let eqPrf \u2190 mkEqNDRec motive eqRefl heq\n          postprocessAppMVars `rewrite mvarId newMVars binderInfos\n          let newMVarIds \u2190 newMVars.map Expr.mvarId! |>.filterM fun mvarId => not <$> mvarId.isAssigned\n          let otherMVarIds \u2190 getMVarsNoDelayed eqPrf\n          let otherMVarIds := otherMVarIds.filter (!newMVarIds.contains \u00b7)\n          let newMVarIds := newMVarIds ++ otherMVarIds\n          pure { eNew := eNew, eqProof := eqPrf, mvarIds := newMVarIds.toList }\n        match symm with\n        | false => cont heq heqType lhs rhs\n        | true  => do\n          let heq \u2190 mkEqSymm heq\n          let heqType \u2190 mkEq rhs lhs\n          cont heq heqType rhs lhs\n    match heqType.iff? with\n    | some (lhs, rhs) =>\n      let heqType \u2190 mkEq lhs rhs\n      let heq := mkApp3 (mkConst `propext) lhs rhs heq\n      cont heq heqType\n    | none =>\n      cont heq heqType", "start": [19, 1], "end": [68, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.rewrite", "code": "@[deprecated MVarId.rewrite]\ndef rewrite (mvarId : MVarId) (e : Expr) (heq : Expr)\n    (symm : Bool := false) (config := { : Rewrite.Config }) : MetaM RewriteResult :=\n  mvarId.rewrite e heq symm config", "start": [70, 1], "end": [73, 35], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Config.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Linter/MissingDocs.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eval.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.evalUnsafe", "code": "unsafe def evalUnsafe (e : Expr) : TermElabM $type :=\n    Meta.evalExpr' (safety := .unsafe) $type ``$type e", "start": [14, 4], "end": [15, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.eval", "code": "@[implemented_by evalUnsafe] opaque eval (e : Expr) : TermElabM $type", "start": [16, 4], "end": [16, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.checkConfigElab", "code": "@[builtin_missing_docs_handler Elab.Tactic.configElab]\ndef checkConfigElab : SimpleHandler := mkSimpleHandler \"config elab\"", "start": [30, 1], "end": [31, 69], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Location", "code": "inductive Location where\n  \n  | wildcard\n  \n  | targets (hypotheses : Array Syntax) (type : Bool)", "start": [11, 1], "end": [17, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.expandLocation", "code": "def expandLocation (stx : Syntax) : Location :=\n  let arg := stx[1]\n  if arg.getKind == ``Parser.Tactic.locationWildcard then\n    Location.wildcard\n  else\n    Location.targets arg[0].getArgs (!arg[1].isNone)", "start": [27, 1], "end": [32, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.expandOptLocation", "code": "def expandOptLocation (stx : Syntax) : Location :=\n  if stx.isNone then\n    Location.targets #[] true\n  else\n    expandLocation stx[0]", "start": [34, 1], "end": [38, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.withLocation", "code": "def withLocation (loc : Location) (atLocal : FVarId \u2192 TacticM Unit) (atTarget : TacticM Unit) (failed : MVarId \u2192 TacticM Unit) : TacticM Unit := do\n  match loc with\n  | Location.targets hyps type =>\n    hyps.forM fun hyp => withMainContext do\n      let fvarId \u2190 getFVarId hyp\n      atLocal fvarId\n    if type then\n      withMainContext atTarget\n  | Location.wildcard =>\n    let worked \u2190 tryTactic <| withMainContext <| atTarget\n    withMainContext do\n      let mut worked := worked\n      for fvarId in (\u2190 getLCtx).getFVarIds.reverse do\n        if (\u2190 fvarId.getDecl).isImplementationDetail then\n          continue\n        worked := worked || (\u2190 tryTactic <| withMainContext <| atLocal fvarId)\n      unless worked do\n        failed (\u2190 getMainGoal)", "start": [42, 1], "end": [63, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Reduce.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/MonadCache.lean", "lake-packages/lean4/src/lean/Lean/Meta/FunInfo.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.reduce", "code": "partial def reduce (e : Expr) (explicitOnly skipTypes skipProofs := true) : MetaM Expr :=\n  let rec visit (e : Expr) : MonadCacheT Expr Expr MetaM Expr :=\n    checkCache e fun _ => Core.withIncRecDepth do\n      if (\u2190 (pure skipTypes <&&> isType e)) then\n        return e\n      else if (\u2190 (pure skipProofs <&&> isProof e)) then\n        return e\n      else\n        let e \u2190 whnf e\n        match e with\n        | Expr.app .. =>\n          let f     \u2190 visit e.getAppFn\n          let nargs := e.getAppNumArgs\n          let finfo \u2190 getFunInfoNArgs f nargs\n          let mut args  := e.getAppArgs\n          for i in [:args.size] do\n            if i < finfo.paramInfo.size then\n              let info := finfo.paramInfo[i]!\n              if !explicitOnly || info.isExplicit then\n                args \u2190 args.modifyM i visit\n            else\n              args \u2190 args.modifyM i visit\n          if f.isConstOf ``Nat.succ && args.size == 1 && args[0]!.isNatLit then\n            return mkRawNatLit (args[0]!.natLit?.get! + 1)\n          else\n            return mkAppN f args\n        | Expr.lam ..        => lambdaTelescope e fun xs b => do mkLambdaFVars xs (\u2190 visit b)\n        | Expr.forallE ..    => forallTelescope e fun xs b => do mkForallFVars xs (\u2190 visit b)\n        | Expr.proj n i s .. => return mkProj n i (\u2190 visit s)\n        | _                  => return e\n  visit e |>.run", "start": [12, 1], "end": [42, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.reduceAll", "code": "def reduceAll (e : Expr) : MetaM Expr :=\n  reduce e false false false", "start": [44, 1], "end": [45, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Syntax.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Util.lean", "lake-packages/lean4/src/lean/Lean/Parser/Syntax.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.expandOptPrecedence", "code": "def expandOptPrecedence (stx : Syntax) : MacroM (Option Nat) :=\n  if stx.isNone then\n    return none\n  else\n    return some (\u2190 evalPrec stx[0][1])", "start": [11, 1], "end": [18, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkParserSeq", "code": "private def mkParserSeq (ds : Array (Term \u00d7 Nat)) : TermElabM (Term \u00d7 Nat) := do\n  if ds.size == 0 then\n    throwUnsupportedSyntax\n  else if ds.size == 1 then\n    pure ds[0]!\n  else\n    let mut (r, stackSum) := ds[0]!\n    for (d, stackSz) in ds[1:ds.size] do\n      r \u2190 `(ParserDescr.binary `andthen $r $d)\n      stackSum := stackSum + stackSz\n    return (r, stackSum)", "start": [20, 1], "end": [30, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToParserDescrContext", "code": "structure ToParserDescrContext where\n  catName  : Name\n  first    : Bool\n  leftRec  : Bool \n  behavior : Parser.LeadingIdentBehavior", "start": [32, 1], "end": [37, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToParserDescrM", "code": "abbrev ToParserDescrM := ReaderT ToParserDescrContext (StateRefT (Option Nat) TermElabM)", "start": [39, 1], "end": [39, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToParserDescr", "code": "abbrev ToParserDescr := ToParserDescrM (Term \u00d7 Nat)", "start": [40, 1], "end": [40, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.markAsTrailingParser", "code": "private def markAsTrailingParser (lhsPrec : Nat) : ToParserDescrM Unit := set (some lhsPrec)", "start": [41, 1], "end": [41, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withNotFirst", "code": "@[inline] private def withNotFirst {\u03b1} (x : ToParserDescrM \u03b1) : ToParserDescrM \u03b1 :=\n  withReader (fun ctx => { ctx with first := false }) x", "start": [43, 1], "end": [44, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ensureUnaryOutput", "code": "def ensureUnaryOutput (x : Term \u00d7 Nat) : Term :=\n  let (stx, stackSz) := x\n  if stackSz != 1 then\n    Unhygienic.run ``(ParserDescr.unary $(quote `group) $stx)\n  else\n    stx", "start": [46, 1], "end": [51, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withNestedParser", "code": "@[inline] private def withNestedParser (x : ToParserDescr) : ToParserDescr := do\n  withReader (fun ctx => { ctx with leftRec := false, first := false }) x", "start": [53, 1], "end": [54, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addCategoryInfo", "code": "def addCategoryInfo (ref : Syntax) (catName : Name) : TermElabM Unit := do\n  let declName := ``Lean.Parser.Category ++ catName\n  if (\u2190 getEnv).contains declName then\n    addTermInfo' ref (Lean.mkConst declName)", "start": [56, 1], "end": [60, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addAliasInfo", "code": "def addAliasInfo (ref : Syntax) (info : Parser.ParserAliasInfo) : TermElabM Unit := do\n  if (\u2190 getInfoState).enabled then\n    if (\u2190 getEnv).contains info.declName then\n      addTermInfo' ref (Lean.mkConst info.declName)", "start": [62, 1], "end": [66, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.checkLeftRec", "code": "def checkLeftRec (stx : Syntax) : ToParserDescrM Bool := do\n  let ctx \u2190 read\n  unless ctx.first && stx.getKind == ``Lean.Parser.Syntax.cat do\n    return false\n  let cat := stx[0].getId.eraseMacroScopes\n  unless cat == ctx.catName do\n    return false\n  addCategoryInfo stx cat\n  let prec? \u2190 liftMacroM <| expandOptPrecedence stx[1]\n  unless ctx.leftRec do\n    throwErrorAt stx[3] \"invalid occurrence of '{cat}', parser algorithm does not allow this form of left recursion\"\n  markAsTrailingParser (prec?.getD 0)\n  return true", "start": [68, 1], "end": [80, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabParserName?", "code": "def elabParserName? (stx : Syntax.Ident) : TermElabM (Option Parser.ParserName) := do\n  match \u2190 Parser.resolveParserName stx with\n  | [n@(.category cat)] =>\n    addCategoryInfo stx cat\n    return n\n  | [n@(.parser parser _)] =>\n    addTermInfo' stx (Lean.mkConst parser)\n    return n\n  | _::_::_ => throwErrorAt stx \"ambiguous parser {stx}\"\n  | [] => return none", "start": [82, 1], "end": [91, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabParserName", "code": "def elabParserName (stx : Syntax.Ident) : TermElabM Parser.ParserName := do\n  match \u2190 elabParserName? stx with\n  | some n => return n\n  | none => throwErrorAt stx \"unknown parser {stx}\"", "start": [93, 1], "end": [96, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.toParserDescr", "code": "partial def toParserDescr (stx : Syntax) (catName : Name) : TermElabM (Term \u00d7 Option Nat) := do\n  let env \u2190 getEnv\n  let behavior := Parser.leadingIdentBehavior env catName\n  let ((newStx, _), lhsPrec?) \u2190 (process stx { catName := catName, first := true, leftRec := true, behavior := behavior }).run none\n  return (newStx, lhsPrec?)\nwhere\n  process (stx : Syntax) : ToParserDescr := withRef stx do\n    let kind := stx.getKind\n    if kind == nullKind then\n      processSeq stx\n    else if kind == choiceKind then\n      process stx[0]\n    else if kind == ``Lean.Parser.Syntax.paren then\n      process stx[1]\n    else if kind == ``Lean.Parser.Syntax.cat then\n      processNullaryOrCat stx\n    else if kind == ``Lean.Parser.Syntax.unary then\n      processAlias stx[0] #[stx[2]]\n    else if kind == ``Lean.Parser.Syntax.binary then\n      processAlias stx[0] #[stx[2], stx[4]]\n    else if kind == ``Lean.Parser.Syntax.sepBy then\n      processSepBy stx\n    else if kind == ``Lean.Parser.Syntax.sepBy1 then\n      processSepBy1 stx\n    else if kind == ``Lean.Parser.Syntax.atom then\n      processAtom stx\n    else if kind == ``Lean.Parser.Syntax.nonReserved then\n      processNonReserved stx\n    else\n      let stxNew? \u2190 liftM (liftMacroM (expandMacro? stx) : TermElabM _)\n      match stxNew? with\n      | some stxNew => process stxNew\n      | none => throwErrorAt stx \"unexpected syntax kind of category `syntax`: {kind}\"\n\n  \n  processSeq (stx : Syntax) := do\n    let args := stx.getArgs\n    if (\u2190 checkLeftRec stx[0]) then\n      if args.size == 1 then throwErrorAt stx \"invalid atomic left recursive syntax\"\n      let args := args.eraseIdx 0\n      let args \u2190 args.mapM fun arg => withNestedParser do process arg\n      mkParserSeq args\n    else\n      let args \u2190 args.mapIdxM fun i arg => withReader (fun ctx => { ctx with first := ctx.first && i.val == 0 }) do process arg\n      mkParserSeq args\n\n  ensureNoPrec (stx : Syntax) :=\n    unless stx[1].isNone do\n      throwErrorAt stx[1] \"unexpected precedence\"\n\n  processParserCategory (stx : Syntax) := do\n    let catName := stx[0].getId.eraseMacroScopes\n    if (\u2190 read).first && catName == (\u2190 read).catName then\n      throwErrorAt stx \"invalid atomic left recursive syntax\"\n    let prec? \u2190 liftMacroM <| expandOptPrecedence stx[1]\n    let prec := prec?.getD 0\n    return (\u2190 `(ParserDescr.cat $(quote catName) $(quote prec)), 1)\n\n  processAlias (id : Syntax) (args : Array Syntax) := do\n    let aliasName := id.getId.eraseMacroScopes\n    let info \u2190 Parser.getParserAliasInfo aliasName\n    addAliasInfo id info\n    let args' \u2190 args.mapM (withNestedParser \u2218 process)\n    let args' \u2190 if aliasName == `orelse then  args.zip args' |>.mapM fun (arg, arg') => do\n        let mut #[arg] := arg.getArgs | return arg'\n        let sym \u2190 match arg with\n          | `(stx| &$sym) => pure sym\n          | `(stx| $sym:str) => pure sym\n          | _ => return arg'\n        let sym := sym.getString\n        return (\u2190 `(ParserDescr.nodeWithAntiquot $(quote sym) $(quote (`token ++ sym)) $(arg'.1)), 1)\n    else\n      pure args'\n    let (args', stackSz) := if let some stackSz := info.stackSz? then\n      if !info.autoGroupArgs then\n        (args'.map (\u00b7.1), stackSz)\n      else\n        (args'.map ensureUnaryOutput, stackSz)\n    else\n      let (args', stackSzs) := args'.unzip\n      (args', stackSzs.foldl (\u00b7 + \u00b7) 0)\n    let stx \u2190 match args' with\n      | #[]       => Parser.ensureConstantParserAlias aliasName; ``(ParserDescr.const $(quote aliasName))\n      | #[p1]     => Parser.ensureUnaryParserAlias aliasName; ``(ParserDescr.unary $(quote aliasName) $p1)\n      | #[p1, p2] => Parser.ensureBinaryParserAlias aliasName; ``(ParserDescr.binary $(quote aliasName) $p1 $p2)\n      | _         => unreachable!\n    return (stx, stackSz)\n\n  processNullaryOrCat (stx : Syntax) := do\n    let ident := stx[0]\n    let id := ident.getId.eraseMacroScopes\n    let default := do\n      if (\u2190 Parser.isParserAlias id) then\n        ensureNoPrec stx\n        return (\u2190 processAlias ident #[])\n      throwError \"unknown parser declaration/category/alias '{id}'\"\n    match (\u2190 elabParserName? ident) with\n    | some (.parser c (isDescr := true)) =>\n      ensureNoPrec stx\n      let stackSz := 1\n      return (mkIdentFrom stx c, stackSz)\n    | some (.parser c (isDescr := false)) =>\n      if (\u2190 Parser.getParserAliasInfo id).declName == c then\n        return (\u2190 default)\n      ensureNoPrec stx\n      let stackSz := 1\n      return (\u2190 `(ParserDescr.parser $(quote c)), stackSz)\n    | some (.category _) =>\n      processParserCategory stx\n    | none => default\n\n  processSepBy (stx : Syntax) := do\n    let p \u2190 ensureUnaryOutput <$> withNestedParser do process stx[1]\n    let sep := stx[3]\n    let psep \u2190 if stx[4].isNone then `(ParserDescr.symbol $sep) else ensureUnaryOutput <$> withNestedParser do process stx[4][1]\n    let allowTrailingSep := !stx[5].isNone\n    return (\u2190 `((with_annotate_term $(stx[0]) @ParserDescr.sepBy) $p $sep $psep $(quote allowTrailingSep)), 1)\n\n  processSepBy1 (stx : Syntax) := do\n    let p \u2190 ensureUnaryOutput <$> withNestedParser do process stx[1]\n    let sep := stx[3]\n    let psep \u2190 if stx[4].isNone then `(ParserDescr.symbol $sep) else ensureUnaryOutput <$> withNestedParser do process stx[4][1]\n    let allowTrailingSep := !stx[5].isNone\n    return (\u2190 `((with_annotate_term $(stx[0]) @ParserDescr.sepBy1) $p $sep $psep $(quote allowTrailingSep)), 1)\n\n  isValidAtom (s : String) : Bool :=\n    !s.isEmpty &&\n    s.front != '\\'' &&\n    s.front != '\\\"' &&\n    !(s.front == '`' && (s.endPos == \u27e81\u27e9 || isIdFirst (s.get \u27e81\u27e9) || isIdBeginEscape (s.get \u27e81\u27e9))) &&\n    !s.front.isDigit\n\n  processAtom (stx : Syntax) := do\n    match stx[0].isStrLit? with\n    | some atom =>\n      unless isValidAtom atom do\n        throwErrorAt stx \"invalid atom\"\n      \n      if (\u2190 read).behavior != Parser.LeadingIdentBehavior.default && (\u2190 read).first then\n        return (\u2190 `(ParserDescr.nonReservedSymbol $(quote atom) false), 1)\n      else\n        return (\u2190 `(ParserDescr.symbol $(quote atom)), 1)\n    | none => throwUnsupportedSyntax\n\n  processNonReserved (stx : Syntax) := do\n    let some atom := stx[1].isStrLit? | throwUnsupportedSyntax\n    return (\u2190 `((with_annotate_term $(stx[0]) @ParserDescr.nonReservedSymbol) $(quote atom) false), 1)", "start": [99, 1], "end": [256, 103], "kind": "commanddeclaration"}, {"full_name": "Command.declareSyntaxCatQuotParser", "code": "private def declareSyntaxCatQuotParser (catName : Name) : CommandElabM Unit := do\n  if let .str _ suffix := catName then\n    let quotSymbol := \"`(\" ++ suffix ++ \"| \"\n    let name := catName ++ `quot\n    let cmd \u2190 `(\n      @[term_parser] def $(mkIdent name) : Lean.ParserDescr :=\n        Lean.ParserDescr.node `Lean.Parser.Term.quot $(quote Lean.Parser.maxPrec)\n          (Lean.ParserDescr.node $(quote name) $(quote Lean.Parser.maxPrec)\n            (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.symbol $(quote quotSymbol))\n              (Lean.ParserDescr.binary `andthen\n                (Lean.ParserDescr.cat $(quote catName) 0)\n                (Lean.ParserDescr.symbol \")\")))))\n    elabCommand cmd", "start": [266, 1], "end": [278, 20], "kind": "commanddeclaration"}, {"full_name": "Command.elabDeclareSyntaxCat", "code": "@[builtin_command_elab syntaxCat] def elabDeclareSyntaxCat : CommandElab := fun stx => do\n  let docString? := stx[0].getOptional?.map fun stx => \u27e8stx\u27e9\n  let catName    := stx[2].getId\n  let catBehavior :=\n    if stx[3].isNone then\n      Parser.LeadingIdentBehavior.default\n    else if stx[3][3].getKind == ``Parser.Command.catBehaviorBoth then\n      Parser.LeadingIdentBehavior.both\n    else\n      Parser.LeadingIdentBehavior.symbol\n  let attrName := catName.appendAfter \"_parser\"\n  let catDeclName := ``Lean.Parser.Category ++ catName\n  setEnv (\u2190 Parser.registerParserCategory (\u2190 getEnv) attrName catName catBehavior catDeclName)\n  let cmd \u2190 `($[$docString?]? def $(mkIdentFrom stx[2] (`_root_ ++ catDeclName) (canonical := true)) : Lean.Parser.Category := {})\n  declareSyntaxCatQuotParser catName\n  elabCommand cmd", "start": [280, 1], "end": [295, 18], "kind": "commanddeclaration"}, {"full_name": "Command.mkNameFromParserSyntax", "code": "partial def mkNameFromParserSyntax (catName : Name) (stx : Syntax) : MacroM Name := do\n  mkUnusedBaseName <| Name.mkSimple <| appendCatName <| visit stx \"\"\nwhere\n  visit (stx : Syntax) (acc : String) : String :=\n    match stx.isStrLit? with\n    | some val => acc ++ (val.trim.map fun c => if c.isWhitespace then '_' else c).capitalize\n    | none =>\n      match stx with\n      | Syntax.node _ k args =>\n        if k == ``Lean.Parser.Syntax.cat then\n          acc ++ \"_\"\n        else\n          args.foldl (init := acc) fun acc arg => visit arg acc\n      | Syntax.ident ..    => acc\n      | Syntax.atom ..     => acc\n      | Syntax.missing     => acc\n\n  appendCatName (str : String) :=\n    match catName with\n    | .str _ s => s ++ str\n    | _ => str", "start": [297, 1], "end": [327, 15], "kind": "commanddeclaration"}, {"full_name": "Command.isAtomLikeSyntax", "code": "private partial def isAtomLikeSyntax (stx : Syntax) : Bool :=\n  let kind := stx.getKind\n  if kind == nullKind then\n    isAtomLikeSyntax stx[0] && isAtomLikeSyntax stx[stx.getNumArgs - 1]\n  else if kind == choiceKind then\n    isAtomLikeSyntax stx[0] else if kind == ``Lean.Parser.Syntax.paren then\n    isAtomLikeSyntax stx[1]\n  else\n    kind == ``Lean.Parser.Syntax.atom", "start": [329, 1], "end": [346, 38], "kind": "commanddeclaration"}, {"full_name": "Command.resolveSyntaxKind", "code": "def resolveSyntaxKind (k : Name) : CommandElabM Name := do\n  checkSyntaxNodeKindAtNamespaces k (\u2190 getCurrNamespace)\n  <|>\n  throwError \"invalid syntax node kind '{k}'\"", "start": [348, 1], "end": [351, 46], "kind": "commanddeclaration"}, {"full_name": "Command.isLocalAttrKind", "code": "def isLocalAttrKind (attrKind : Syntax) : Bool :=\n  match attrKind with\n  | `(Parser.Term.attrKind| local) => true\n  | _ => false", "start": [353, 1], "end": [356, 15], "kind": "commanddeclaration"}, {"full_name": "Command.addMacroScopeIfLocal", "code": "def addMacroScopeIfLocal [MonadQuotation m] [Monad m] (name : Name) (attrKind : Syntax) : m Name := do\n  if isLocalAttrKind attrKind && !name.hasMacroScopes then\n    MonadQuotation.addMacroScope name\n  else\n    return name", "start": [358, 1], "end": [365, 16], "kind": "commanddeclaration"}, {"full_name": "Command.elabSyntax", "code": "@[builtin_command_elab \u00absyntax\u00bb] def elabSyntax : CommandElab := fun stx => do\n  let `($[$doc?:docComment]? $[ @[ $attrInstances:attrInstance,* ] ]? $attrKind:attrKind\n      syntax%$tk $[: $prec? ]? $[(name := $name?)]? $[(priority := $prio?)]? $[$ps:stx]* : $catStx) := stx\n    | throwUnsupportedSyntax\n  let cat := catStx.getId.eraseMacroScopes\n  unless (Parser.isParserCategory (\u2190 getEnv) cat) do\n    throwErrorAt catStx \"unknown category '{cat}'\"\n  liftTermElabM <| Term.addCategoryInfo catStx cat\n  let syntaxParser := mkNullNode ps\n  let precDefault  := if isAtomLikeSyntax syntaxParser then Parser.maxPrec else Parser.leadPrec\n  let prec \u2190 match prec? with\n    | some prec => liftMacroM <| evalPrec prec\n    | none      => pure precDefault\n  let name \u2190 match name? with\n    | some name => pure name.getId\n    | none => addMacroScopeIfLocal (\u2190 liftMacroM <| mkNameFromParserSyntax cat syntaxParser) attrKind\n  trace[Meta.debug] \"name: {name}\"\n  let prio \u2190 liftMacroM <| evalOptPrio prio?\n  let idRef := (name?.map (\u00b7.raw)).getD tk\n  let stxNodeKind := (\u2190 getCurrNamespace) ++ name\n  let catParserId := mkIdentFrom idRef (cat.appendAfter \"_parser\")\n  let (val, lhsPrec?) \u2190 runTermElabM fun _ => Term.toParserDescr syntaxParser cat\n  let declName := name?.getD (mkIdentFrom idRef name (canonical := true))\n  let attrInstance \u2190 `(attrInstance| $attrKind:attrKind $catParserId:ident $(quote prio):num)\n  let attrInstances := attrInstances.getD { elemsAndSeps := #[] }\n  let attrInstances := attrInstances.push attrInstance\n  let d \u2190 if let some lhsPrec := lhsPrec? then\n    `($[$doc?:docComment]? @[$attrInstances,*] def $declName:ident : Lean.TrailingParserDescr :=\n        ParserDescr.trailingNode $(quote stxNodeKind) $(quote prec) $(quote lhsPrec) $val)\n  else\n    `($[$doc?:docComment]? @[$attrInstances,*] def $declName:ident : Lean.ParserDescr :=\n        ParserDescr.node $(quote stxNodeKind) $(quote prec) $val)\n  trace `Elab fun _ => d\n  withMacroExpansion stx d <| elabCommand d", "start": [367, 1], "end": [401, 44], "kind": "commanddeclaration"}, {"full_name": "Command.$declName", "code": "$[$doc?:docComment]? @[$attrInstances,*] def $declName:ident : Lean.TrailingParserDescr :=\n        ParserDescr.trailingNode $(quote stxNodeKind) $(quote prec) $(quote lhsPrec) $val", "start": [395, 7], "end": [396, 90], "kind": "commanddeclaration"}, {"full_name": "Command.$declName", "code": "$[$doc?:docComment]? @[$attrInstances,*] def $declName:ident : Lean.ParserDescr :=\n        ParserDescr.node $(quote stxNodeKind) $(quote prec) $val", "start": [398, 7], "end": [399, 65], "kind": "commanddeclaration"}, {"full_name": "Command.elabSyntaxAbbrev", "code": "@[builtin_command_elab \u00absyntaxAbbrev\u00bb] def elabSyntaxAbbrev : CommandElab := fun stx => do\n  let `($[$doc?:docComment]? syntax $declName:ident := $[$ps:stx]*) \u2190 pure stx | throwUnsupportedSyntax\n  let (val, _) \u2190 runTermElabM fun _ => Term.toParserDescr (mkNullNode ps) Name.anonymous\n  let stxNodeKind := (\u2190 getCurrNamespace) ++ declName.getId\n  let stx' \u2190 `($[$doc?:docComment]? def $declName:ident : Lean.ParserDescr := ParserDescr.nodeWithAntiquot $(quote (toString declName.getId)) $(quote stxNodeKind) $val)\n  withMacroExpansion stx stx' <| elabCommand stx'", "start": [403, 1], "end": [409, 50], "kind": "commanddeclaration"}, {"full_name": "Command.$declName", "code": "$[$doc?:docComment]? def $declName:ident : Lean.ParserDescr := ParserDescr.nodeWithAntiquot $(quote (toString declName.getId)) $(quote stxNodeKind) $val", "start": [408, 16], "end": [408, 168], "kind": "commanddeclaration"}, {"full_name": "Command.checkRuleKind", "code": "def checkRuleKind (given expected : SyntaxNodeKind) : Bool :=\n  given == expected || given == expected ++ `antiquot", "start": [411, 1], "end": [412, 54], "kind": "commanddeclaration"}, {"full_name": "Command.inferMacroRulesAltKind", "code": "def inferMacroRulesAltKind : TSyntax ``matchAlt \u2192 CommandElabM SyntaxNodeKind\n  | `(matchAltExpr| | $pat:term => $_) => do\n    if !pat.raw.isQuot then\n      throwUnsupportedSyntax\n    let quoted := getQuotContent pat\n    pure quoted.getKind\n  | _ => throwUnsupportedSyntax", "start": [414, 1], "end": [420, 32], "kind": "commanddeclaration"}, {"full_name": "Command.expandNoKindMacroRulesAux", "code": "def expandNoKindMacroRulesAux (alts : Array (TSyntax ``matchAlt)) (cmdName : String) (mkCmd : Option Name \u2192 Array (TSyntax ``matchAlt) \u2192 CommandElabM Command) : CommandElabM Command := do\n  let mut k \u2190 inferMacroRulesAltKind alts[0]!\n  if k.isStr && k.getString! == \"antiquot\" then\n    k := k.getPrefix\n  if k == choiceKind then\n    throwErrorAt alts[0]!\n      \"invalid {cmdName} alternative, multiple interpretations for pattern (solution: specify node kind using `{cmdName} (kind := ...) ...`)\"\n  else\n    let altsK    \u2190 alts.filterM fun alt => return checkRuleKind (\u2190 inferMacroRulesAltKind alt) k\n    let altsNotK \u2190 alts.filterM fun alt => return !checkRuleKind (\u2190 inferMacroRulesAltKind alt) k\n    if altsNotK.isEmpty then\n      mkCmd k altsK\n    else\n      `($(\u2190 mkCmd k altsK):command $(\u2190 mkCmd none altsNotK))", "start": [422, 1], "end": [438, 61], "kind": "commanddeclaration"}, {"full_name": "Command.strLitToPattern", "code": "def strLitToPattern (stx: Syntax) : MacroM Syntax :=\n  match stx.isStrLit? with\n  | some str => return mkAtomFrom stx str\n  | none     => Macro.throwUnsupported", "start": [440, 1], "end": [443, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/MatchAltView.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.MatchAltView", "code": "structure MatchAltView where\n  ref      : Syntax\n  patterns : Array Syntax\n  rhs      : Syntax\n  deriving Inhabited", "start": [19, 1], "end": [23, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Arg.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.Arg", "code": "inductive Arg where\n  | stx  (val : Syntax)\n  | expr (val : Expr)\n  deriving Inhabited", "start": [10, 1], "end": [16, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.NamedArg", "code": "structure NamedArg where\n  ref  : Syntax := Syntax.missing\n  name : Name\n  val  : Arg\n  deriving Inhabited", "start": [18, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.addNamedArg", "code": "def addNamedArg (namedArgs : Array NamedArg) (namedArg : NamedArg) : MetaM (Array NamedArg) := do\n  if namedArgs.any (namedArg.name == \u00b7.name) then\n    throwError \"argument '{namedArg.name}' was already set\"\n  return namedArgs.push namedArg", "start": [25, 1], "end": [31, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandArgs", "code": "partial def expandArgs (args : Array Syntax) : MetaM (Array NamedArg \u00d7 Array Arg \u00d7 Bool) := do\n  let (args, ellipsis) :=\n    if args.isEmpty then\n      (args, false)\n    else if args.back.isOfKind ``Lean.Parser.Term.ellipsis then\n      (args.pop, true)\n    else\n      (args, false)\n  let (namedArgs, args) \u2190 args.foldlM (init := (#[], #[])) fun (namedArgs, args) stx => do\n    if stx.getKind == ``Lean.Parser.Term.namedArgument then\n      let name := stx[1].getId.eraseMacroScopes\n      let val  := stx[3]\n      let namedArgs \u2190 addNamedArg namedArgs { ref := stx, name := name, val := Arg.stx val }\n      return (namedArgs, args)\n    else if stx.getKind == ``Lean.Parser.Term.ellipsis then\n      throwErrorAt stx \"unexpected '..'\"\n    else\n      return (namedArgs, args.push $ Arg.stx stx)\n  return (namedArgs, args, ellipsis)", "start": [33, 1], "end": [52, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandApp", "code": "def expandApp (stx : Syntax) : MetaM (Syntax \u00d7 Array NamedArg \u00d7 Array Arg \u00d7 Bool) := do\n  let (namedArgs, args, ellipsis) \u2190 expandArgs stx[1].getArgs\n  return (stx[0], namedArgs, args, ellipsis)", "start": [54, 1], "end": [56, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Contradiction.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/MatchUtil.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean"], "premises": [{"full_name": "Lean.Meta.Contradiction.Config", "code": "structure Contradiction.Config where\n  useDecide  : Bool := true\n  \n  emptyType  : Bool := true\n  \n  searchFuel : Nat  := 16\n  \n  genDiseq : Bool := false", "start": [13, 1], "end": [24, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.nestedFalseElim", "code": "private def nestedFalseElim (mvarId : MVarId) : MetaM Bool := do\n  let target \u2190 mvarId.getType\n  if let some falseElim := target.find? fun e => e.isAppOfArity ``False.elim 2 && !e.appArg!.hasLooseBVars then\n    let falseProof := falseElim.appArg!\n    mvarId.assign (\u2190 mkFalseElim (\u2190 mvarId.getType) falseProof)\n    return true\n  else\n    return false", "start": [26, 1], "end": [37, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isElimEmptyInductiveCandidate", "code": "private def isElimEmptyInductiveCandidate (fvarId : FVarId) : MetaM Bool := do\n  let type \u2190 whnfD (\u2190 fvarId.getType)\n  matchConstInduct type.getAppFn (fun _ => pure false) fun info _ => do\n    return info.ctors.length == 0 || info.numIndices > 0", "start": [40, 1], "end": [43, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ElimEmptyInductive.M", "code": "abbrev M := StateRefT Nat MetaM", "start": [47, 1], "end": [47, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ElimEmptyInductive.elim", "code": "partial def elim (mvarId : MVarId) (fvarId : FVarId) : M Bool := do\n  if (\u2190 get) == 0 then\n    trace[Meta.Tactic.contradiction] \"elimEmptyInductive out-of-fuel\"\n    return false\n  modify (\u00b7 - 1)\n  commitWhen do\n    let subgoals \u2190 try mvarId.cases fvarId catch ex => trace[Meta.Tactic.contradiction] \"{ex.toMessageData}\"; return false\n    trace[Meta.Tactic.contradiction] \"elimEmptyInductive, number subgoals: {subgoals.size}\"\n    for subgoal in subgoals do\n      let found \u2190 subgoal.mvarId.withContext do\n        for field in subgoal.fields do\n          let field := subgoal.subst.apply field\n          if field.isFVar then\n            if (\u2190 isElimEmptyInductiveCandidate field.fvarId!) then\n              if (\u2190 elim subgoal.mvarId field.fvarId!) then\n                return true\n        return false\n      unless found do\n        return false\n    return true", "start": [53, 1], "end": [74, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.elimEmptyInductive", "code": "private def elimEmptyInductive (mvarId : MVarId) (fvarId : FVarId) (fuel : Nat) : MetaM Bool := do\n  mvarId.withContext do\n    if (\u2190 isElimEmptyInductiveCandidate fvarId) then\n      commitWhen do\n        ElimEmptyInductive.elim (\u2190 mvarId.exfalso) fvarId |>.run' fuel\n    else\n      return false", "start": [78, 1], "end": [84, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isGenDiseq", "code": "private abbrev isGenDiseq (e : Expr) : Bool :=\n  Simp.isEqnThmHypothesis e", "start": [86, 1], "end": [90, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkGenDiseqMask", "code": "private def mkGenDiseqMask (e : Expr) : Array Bool :=\n  go e #[]\nwhere\n  go (e : Expr) (acc : Array Bool) : Array Bool :=\n    match e with\n    | Expr.forallE _ d b _ => go b (acc.push (!b.hasLooseBVar 0 && (d.isEq || d.isHEq)))\n    | _ => acc", "start": [92, 1], "end": [104, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.processGenDiseq", "code": "private def processGenDiseq (mvarId : MVarId) (localDecl : LocalDecl) : MetaM Bool := do\n  assert! isGenDiseq localDecl.type\n  let val? \u2190 withNewMCtxDepth do\n    let (args, _, _) \u2190 forallMetaTelescope localDecl.type\n    let mask  := mkGenDiseqMask localDecl.type\n    for arg in args, useRefl in mask do\n      if useRefl then\n        \n        if let some (_, lhs, _) \u2190 matchEq? (\u2190 inferType arg) then\n          unless (\u2190 isDefEq arg (\u2190 mkEqRefl lhs)) do\n            return none\n        if let some (_, lhs, _,  _) \u2190 matchHEq? (\u2190 inferType arg) then\n          unless (\u2190 isDefEq arg (\u2190 mkHEqRefl lhs)) do\n            return none\n    let falseProof \u2190 instantiateMVars (mkAppN localDecl.toExpr args)\n    if (\u2190 hasAssignableMVar falseProof) then\n      return none\n    return some (\u2190 mkFalseElim (\u2190 mvarId.getType) falseProof)\n  if let some val := val? then\n    mvarId.assign val\n    return true\n  else\n    return false", "start": [106, 1], "end": [146, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.contradictionCore", "code": "def _root_.Lean.MVarId.contradictionCore (mvarId : MVarId) (config : Contradiction.Config) : MetaM Bool := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `contradiction\n    if (\u2190 nestedFalseElim mvarId) then\n      return true\n    for localDecl in (\u2190 getLCtx) do\n      unless localDecl.isImplementationDetail do\n        if let some p \u2190 matchNot? localDecl.type then\n          if let some pFVarId \u2190 findLocalDeclWithType? p then\n            mvarId.assign (\u2190 mkAbsurd (\u2190 mvarId.getType) (mkFVar pFVarId) localDecl.toExpr)\n            return true\n        if let some (_, lhs, rhs) \u2190 matchNe? localDecl.type then\n          if (\u2190 isDefEq lhs rhs) then\n            mvarId.assign (\u2190 mkAbsurd (\u2190  mvarId.getType) (\u2190 mkEqRefl lhs) localDecl.toExpr)\n            return true\n        let mut isEq := false\n        if let some (_, lhs, rhs) \u2190 matchEq? localDecl.type then\n          isEq := true\n          if let some lhsCtor \u2190 matchConstructorApp? lhs then\n          if let some rhsCtor \u2190 matchConstructorApp? rhs then\n          if lhsCtor.name != rhsCtor.name then\n            mvarId.assign (\u2190 mkNoConfusion (\u2190 mvarId.getType) localDecl.toExpr)\n            return true\n        let mut isHEq := false\n        if let some (\u03b1, lhs, \u03b2, rhs) \u2190 matchHEq? localDecl.type then\n          isHEq := true\n          if let some lhsCtor \u2190 matchConstructorApp? lhs then\n          if let some rhsCtor \u2190 matchConstructorApp? rhs then\n          if lhsCtor.name != rhsCtor.name then\n            if (\u2190 isDefEq \u03b1 \u03b2) then\n              mvarId.assign (\u2190 mkNoConfusion (\u2190 mvarId.getType) (\u2190 mkEqOfHEq localDecl.toExpr))\n              return true\n        if config.useDecide && !localDecl.type.hasFVar then\n          let type \u2190 instantiateMVars localDecl.type\n          if !type.hasMVar && !type.hasFVar then\n            try\n              let d \u2190 mkDecide localDecl.type\n              let r \u2190 withDefault <| whnf d\n              if r.isConstOf ``false then\n                let hn := mkAppN (mkConst ``of_decide_eq_false) <| d.getAppArgs.push (\u2190 mkEqRefl d)\n                mvarId.assign (\u2190 mkAbsurd (\u2190 mvarId.getType) localDecl.toExpr hn)\n                return true\n            catch _ =>\n              pure ()\n        if config.genDiseq && isGenDiseq localDecl.type then\n          if (\u2190 processGenDiseq mvarId localDecl) then\n            return true\n        if config.emptyType && !isEq && !isHEq then\n          if (\u2190 elimEmptyInductive mvarId localDecl.fvarId config.searchFuel) then\n            return true\n    return false", "start": [148, 1], "end": [211, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.contradiction", "code": "def _root_.Lean.MVarId.contradiction (mvarId : MVarId) (config : Contradiction.Config := {}) : MetaM Unit :=\n  unless (\u2190 mvarId.contradictionCore config) do\n    throwTacticEx `contradiction mvarId \"\"", "start": [213, 1], "end": [226, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.contradiction", "code": "@[deprecated MVarId.contradiction]\ndef contradiction (mvarId : MVarId) (config : Contradiction.Config := {}) : MetaM Unit :=\n  mvarId.contradiction config", "start": [228, 1], "end": [230, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Match/CaseArraySizes.lean", "lake-packages/lean4/src/lean/Lean/Meta/CollectFVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatcherInfo.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean"], "premises": [{"full_name": "Lean.Meta.Match.mkNamedPattern", "code": "def mkNamedPattern (x h p : Expr) : MetaM Expr :=\n  mkAppM ``namedPattern #[x, p, h]", "start": [13, 1], "end": [14, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isNamedPattern", "code": "def isNamedPattern (e : Expr) : Bool :=\n  let e := e.consumeMData\n  e.getAppNumArgs == 4 && e.getAppFn.consumeMData.isConstOf ``namedPattern", "start": [16, 1], "end": [18, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isNamedPattern?", "code": "def isNamedPattern? (e : Expr) : Option Expr :=\n  let e := e.consumeMData\n  if e.getAppNumArgs == 4 && e.getAppFn.consumeMData.isConstOf ``namedPattern then\n    some e\n  else\n    none", "start": [20, 1], "end": [25, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Pattern", "code": "inductive Pattern : Type where\n  | inaccessible (e : Expr) : Pattern\n  | var          (fvarId : FVarId) : Pattern\n  | ctor         (ctorName : Name) (us : List Level) (params : List Expr) (fields : List Pattern) : Pattern\n  | val          (e : Expr) : Pattern\n  | arrayLit     (type : Expr) (xs : List Pattern) : Pattern\n  | as           (varId : FVarId) (p : Pattern) (hId : FVarId) : Pattern\n  deriving Inhabited", "start": [27, 1], "end": [34, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Pattern.toMessageData", "code": "partial def toMessageData : Pattern \u2192 MessageData\n  | inaccessible e         => m!\".({e})\"\n  | var varId              => mkFVar varId\n  | ctor ctorName _ _ []   => ctorName\n  | ctor ctorName _ _ pats => m!\"({ctorName}{pats.foldl (fun (msg : MessageData) pat => msg ++ \" \" ++ toMessageData pat) Format.nil})\"\n  | val e                  => e\n  | arrayLit _ pats        => m!\"#[{MessageData.joinSep (pats.map toMessageData) \", \"}]\"\n  | as varId p _           => m!\"{mkFVar varId}@{toMessageData p}\"", "start": [38, 1], "end": [45, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Pattern.toExpr", "code": "partial def toExpr (p : Pattern) (annotate := false) : MetaM Expr :=\n  visit p\nwhere\n  visit (p : Pattern) := do\n    match p with\n    | inaccessible e                 =>\n      if annotate then\n        pure (mkInaccessible e)\n      else\n        pure e\n    | var fvarId                     => pure $ mkFVar fvarId\n    | val e                          => pure e\n    | as fvarId p hId                =>\n      if annotate then\n        mkNamedPattern (mkFVar fvarId) (mkFVar hId) (\u2190 visit p)\n      else\n        visit p\n    | arrayLit type xs               =>\n      let xs \u2190 xs.mapM visit\n      mkArrayLit type xs\n    | ctor ctorName us params fields =>\n      let fields \u2190 fields.mapM visit\n      pure $ mkAppN (mkConst ctorName us) (params ++ fields).toArray", "start": [47, 1], "end": [70, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Pattern.applyFVarSubst", "code": "partial def applyFVarSubst (s : FVarSubst) : Pattern \u2192 Pattern\n  | inaccessible e  => inaccessible $ s.apply e\n  | ctor n us ps fs => ctor n us (ps.map s.apply) $ fs.map (applyFVarSubst s)\n  | val e           => val $ s.apply e\n  | arrayLit t xs   => arrayLit (s.apply t) $ xs.map (applyFVarSubst s)\n  | var fvarId      => match s.find? fvarId with\n    | some e => inaccessible e\n    | none   => var fvarId\n  | as fvarId p hId => match s.find? fvarId with\n    | none   => as fvarId (applyFVarSubst s p) hId\n    | some _ => applyFVarSubst s p", "start": [72, 1], "end": [83, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Pattern.replaceFVarId", "code": "def replaceFVarId (fvarId : FVarId) (v : Expr) (p : Pattern) : Pattern :=\n  let s : FVarSubst := {}\n  p.applyFVarSubst (s.insert fvarId v)", "start": [85, 1], "end": [87, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Pattern.hasExprMVar", "code": "partial def hasExprMVar : Pattern \u2192 Bool\n  | inaccessible e => e.hasExprMVar\n  | ctor _ _ ps fs => ps.any (\u00b7.hasExprMVar) || fs.any hasExprMVar\n  | val e          => e.hasExprMVar\n  | as _ p _       => hasExprMVar p\n  | arrayLit t xs  => t.hasExprMVar || xs.any hasExprMVar\n  | _              => false", "start": [89, 1], "end": [95, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Pattern.collectFVars", "code": "partial def collectFVars (p : Pattern) : StateRefT CollectFVars.State MetaM Unit := do\n  match p with\n  | inaccessible e => e.collectFVars\n  | ctor _ _ ps fs =>\n    ps.forM fun p => p.collectFVars\n    fs.forM collectFVars\n  | val e => e.collectFVars\n  | arrayLit t xs => t.collectFVars; xs.forM collectFVars\n  | as fvarId\u2081 p fvarId\u2082 => modify (\u00b7.add fvarId\u2081 |>.add fvarId\u2082); p.collectFVars\n  | var fvarId => modify (\u00b7.add fvarId)", "start": [98, 1], "end": [107, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.instantiatePatternMVars", "code": "partial def instantiatePatternMVars : Pattern \u2192 MetaM Pattern\n  | Pattern.inaccessible e      => return Pattern.inaccessible (\u2190 instantiateMVars e)\n  | Pattern.val e               => return Pattern.val (\u2190 instantiateMVars e)\n  | Pattern.ctor n us ps fields => return Pattern.ctor n us (\u2190 ps.mapM instantiateMVars) (\u2190 fields.mapM instantiatePatternMVars)\n  | Pattern.as x p h            => return Pattern.as x (\u2190 instantiatePatternMVars p) h\n  | Pattern.arrayLit t xs       => return Pattern.arrayLit (\u2190 instantiateMVars t) (\u2190 xs.mapM instantiatePatternMVars)\n  | p                   => return p", "start": [111, 1], "end": [117, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.AltLHS", "code": "structure AltLHS where\n  ref        : Syntax\n  fvarDecls  : List LocalDecl patterns   : List Pattern", "start": [119, 1], "end": [122, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.AltLHS.collectFVars", "code": "def AltLHS.collectFVars (altLHS: AltLHS) : StateRefT CollectFVars.State MetaM Unit := do\n  altLHS.fvarDecls.forM fun fvarDecl => fvarDecl.collectFVars\n  altLHS.patterns.forM fun p => p.collectFVars", "start": [124, 1], "end": [126, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.instantiateAltLHSMVars", "code": "def instantiateAltLHSMVars (altLHS : AltLHS) : MetaM AltLHS :=\n  return { altLHS with\n    fvarDecls := (\u2190 altLHS.fvarDecls.mapM instantiateLocalDeclMVars),\n    patterns  := (\u2190 altLHS.patterns.mapM instantiatePatternMVars)\n  }", "start": [128, 1], "end": [132, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Alt", "code": "structure Alt where\n  \n  ref       : Syntax\n  \n  idx       : Nat\n  \n  rhs       : Expr\n  \n  fvarDecls : List LocalDecl\n  \n  patterns  : List Pattern\n  \n  cnstrs    : List (Expr \u00d7 Expr)\n  deriving Inhabited", "start": [134, 1], "end": [162, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Alt.toMessageData", "code": "partial def toMessageData (alt : Alt) : MetaM MessageData := do\n  withExistingLocalDecls alt.fvarDecls do\n    let msg := alt.fvarDecls.map fun d => m!\"{d.toExpr}:({d.type})\"\n    let mut msg := m!\"{msg} |- {alt.patterns.map Pattern.toMessageData} => {alt.rhs}\"\n    for (lhs, rhs) in alt.cnstrs do\n      msg := m!\"{msg}\\n  | {lhs} \u224b {rhs}\"\n    addMessageContext msg", "start": [166, 1], "end": [172, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Alt.applyFVarSubst", "code": "def applyFVarSubst (s : FVarSubst) (alt : Alt) : Alt :=\n  { alt with\n    patterns  := alt.patterns.map fun p => p.applyFVarSubst s,\n    fvarDecls := alt.fvarDecls.map fun d => d.applyFVarSubst s,\n    rhs       := alt.rhs.applyFVarSubst s\n    cnstrs    := alt.cnstrs.map fun (lhs, rhs) => (lhs.applyFVarSubst s, rhs.applyFVarSubst s) }", "start": [174, 1], "end": [179, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Alt.replaceFVarId", "code": "def replaceFVarId (fvarId : FVarId) (v : Expr) (alt : Alt) : Alt :=\n  { alt with\n    patterns  := alt.patterns.map fun p => p.replaceFVarId fvarId v,\n    rhs       := alt.rhs.replaceFVarId fvarId v\n    fvarDecls :=\n      let decls := alt.fvarDecls.filter fun d => d.fvarId != fvarId\n      decls.map (\u00b7.replaceFVarId fvarId v)\n    cnstrs    := alt.cnstrs.map fun (lhs, rhs) => (lhs.replaceFVarId fvarId v, rhs.replaceFVarId fvarId v) }", "start": [181, 1], "end": [188, 109], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Alt.isLocalDecl", "code": "def isLocalDecl (fvarId : FVarId) (alt : Alt) : Bool :=\n   alt.fvarDecls.any fun d => d.fvarId == fvarId", "start": [190, 1], "end": [192, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Alt.checkAndReplaceFVarId", "code": "def checkAndReplaceFVarId (fvarId : FVarId) (v : Expr) (alt : Alt) : MetaM Alt := do\n  match alt.fvarDecls.find? fun (fvarDecl : LocalDecl) => fvarDecl.fvarId == fvarId with\n  | none          => throwErrorAt alt.ref \"unknown free pattern variable\"\n  | some fvarDecl => do\n    let vType \u2190 inferType v\n    unless (\u2190 isDefEqGuarded fvarDecl.type vType) do\n      withExistingLocalDecls alt.fvarDecls do\n        let (expectedType, givenType) \u2190 addPPExplicitToExposeDiff vType fvarDecl.type\n        throwErrorAt alt.ref \"type mismatch during dependent match-elimination at pattern variable '{mkFVar fvarDecl.fvarId}' with type{indentExpr givenType}\\nexpected type{indentExpr expectedType}\"\n    return replaceFVarId fvarId v alt", "start": [194, 1], "end": [245, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Example", "code": "inductive Example where\n  | var        : FVarId \u2192 Example\n  | underscore : Example\n  | ctor       : Name \u2192 List Example \u2192 Example\n  | val        : Expr \u2192 Example\n  | arrayLit   : List Example \u2192 Example", "start": [249, 1], "end": [254, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Example.replaceFVarId", "code": "partial def replaceFVarId (fvarId : FVarId) (ex : Example) : Example \u2192 Example\n  | var x        => if x == fvarId then ex else var x\n  | ctor n exs   => ctor n $ exs.map (replaceFVarId fvarId ex)\n  | arrayLit exs => arrayLit $ exs.map (replaceFVarId fvarId ex)\n  | ex           => ex", "start": [258, 1], "end": [262, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Example.applyFVarSubst", "code": "partial def applyFVarSubst (s : FVarSubst) : Example \u2192 Example\n  | var fvarId =>\n    match s.get fvarId with\n    | Expr.fvar fvarId' => var fvarId'\n    | _                 => underscore\n  | ctor n exs   => ctor n $ exs.map (applyFVarSubst s)\n  | arrayLit exs => arrayLit $ exs.map (applyFVarSubst s)\n  | ex           => ex", "start": [264, 1], "end": [271, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Example.varsToUnderscore", "code": "partial def varsToUnderscore : Example \u2192 Example\n  | var _        => underscore\n  | ctor n exs   => ctor n $ exs.map varsToUnderscore\n  | arrayLit exs => arrayLit $ exs.map varsToUnderscore\n  | ex           => ex", "start": [273, 1], "end": [277, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Example.toMessageData", "code": "partial def toMessageData : Example \u2192 MessageData\n  | var fvarId        => mkFVar fvarId\n  | ctor ctorName []  => mkConst ctorName\n  | ctor ctorName exs => m!\"({mkConst ctorName}{exs.foldl (fun msg pat => m!\"{msg} {toMessageData pat}\") Format.nil})\"\n  | arrayLit exs      => \"#\" ++ MessageData.ofList (exs.map toMessageData)\n  | val e             => e\n  | underscore        => \"_\"", "start": [279, 1], "end": [285, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.examplesToMessageData", "code": "def examplesToMessageData (cex : List Example) : MessageData :=\n  MessageData.joinSep (cex.map (Example.toMessageData \u2218 Example.varsToUnderscore)) \", \"", "start": [289, 1], "end": [290, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Problem", "code": "structure Problem where\n  mvarId        : MVarId\n  vars          : List Expr\n  alts          : List Alt\n  examples      : List Example\n  deriving Inhabited", "start": [292, 1], "end": [297, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.withGoalOf", "code": "def withGoalOf {\u03b1} (p : Problem) (x : MetaM \u03b1) : MetaM \u03b1 :=\n  p.mvarId.withContext x", "start": [299, 1], "end": [300, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.Problem.toMessageData", "code": "def Problem.toMessageData (p : Problem) : MetaM MessageData :=\n  withGoalOf p do\n    let alts \u2190 p.alts.mapM Alt.toMessageData\n    let vars \u2190 p.vars.mapM fun x => do let xType \u2190 inferType x; pure m!\"{x}:({xType})\"\n    return m!\"remaining variables: {vars}\\nalternatives:{indentD (MessageData.joinSep alts Format.line)}\\nexamples:{examplesToMessageData p.examples}\\n\"", "start": [302, 1], "end": [306, 153], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.CounterExample", "code": "abbrev CounterExample := List Example", "start": [308, 1], "end": [308, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.counterExampleToMessageData", "code": "def counterExampleToMessageData (cex : CounterExample) : MessageData :=\n  examplesToMessageData cex", "start": [310, 1], "end": [311, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.counterExamplesToMessageData", "code": "def counterExamplesToMessageData (cexs : List CounterExample) : MessageData :=\n  MessageData.joinSep (cexs.map counterExampleToMessageData) Format.line", "start": [313, 1], "end": [314, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MatcherResult", "code": "structure MatcherResult where\n  matcher         : Expr counterExamples : List CounterExample\n  unusedAltIdxs   : List Nat\n  addMatcher      : MetaM Unit", "start": [316, 1], "end": [320, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.toPattern", "code": "partial def toPattern (e : Expr) : MetaM Pattern := do\n  match inaccessible? e with\n  | some t => return Pattern.inaccessible t\n  | none =>\n    match e.arrayLit? with\n    | some (\u03b1, lits) =>\n      return Pattern.arrayLit \u03b1 (\u2190 lits.mapM toPattern)\n    | none =>\n      if let some e := isNamedPattern? e then\n        let p \u2190 toPattern <| e.getArg! 2\n        match e.getArg! 1, e.getArg! 3 with\n        | Expr.fvar x, Expr.fvar h => return Pattern.as x p h\n        | _,           _   => throwError \"unexpected occurrence of auxiliary declaration 'namedPattern'\"\n      else if isMatchValue e then\n        return Pattern.val e\n      else if e.isFVar then\n        return Pattern.var e.fvarId!\n      else\n        let newE \u2190 whnf e\n        if newE != e then\n          toPattern newE\n        else matchConstCtor e.getAppFn (fun _ => throwError \"unexpected pattern{indentExpr e}\") fun v us => do\n          let args := e.getAppArgs\n          unless args.size == v.numParams + v.numFields do\n            throwError \"unexpected pattern{indentExpr e}\"\n          let params := args.extract 0 v.numParams\n          let fields := args.extract v.numParams args.size\n          let fields \u2190 fields.mapM toPattern\n          return Pattern.ctor v.name us params.toList fields.toList", "start": [322, 1], "end": [360, 68], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Closure.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/FoldConsts.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/MetavarContext.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean"], "premises": [{"full_name": "Lean.Meta.Closure.ToProcessElement", "code": "structure ToProcessElement where\n  fvarId : FVarId\n  newFVarId : FVarId\n  deriving Inhabited", "start": [99, 1], "end": [102, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.Context", "code": "structure Context where\n  zeta : Bool", "start": [104, 1], "end": [105, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.State", "code": "structure State where\n  visitedLevel          : LevelMap Level := {}\n  visitedExpr           : ExprStructMap Expr := {}\n  levelParams           : Array Name := #[]\n  nextLevelIdx          : Nat := 1\n  levelArgs             : Array Level := #[]\n  newLocalDecls         : Array LocalDecl := #[]\n  newLocalDeclsForMVars : Array LocalDecl := #[]\n  newLetDecls           : Array LocalDecl := #[]\n  nextExprIdx           : Nat := 1\n  exprMVarArgs          : Array Expr := #[]\n  exprFVarArgs          : Array Expr := #[]\n  toProcess             : Array ToProcessElement := #[]", "start": [107, 1], "end": [119, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.ClosureM", "code": "abbrev ClosureM := ReaderT Context $ StateRefT State MetaM", "start": [121, 1], "end": [121, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.visitLevel", "code": "@[inline] def visitLevel (f : Level \u2192 ClosureM Level) (u : Level) : ClosureM Level := do\n  if !u.hasMVar && !u.hasParam then\n    pure u\n  else\n    let s \u2190 get\n    match s.visitedLevel.find? u with\n    | some v => pure v\n    | none   => do\n      let v \u2190 f u\n      modify fun s => { s with visitedLevel := s.visitedLevel.insert u v }\n      pure v", "start": [123, 1], "end": [133, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.visitExpr", "code": "@[inline] def visitExpr (f : Expr \u2192 ClosureM Expr) (e : Expr) : ClosureM Expr := do\n  if !e.hasLevelParam && !e.hasFVar && !e.hasMVar then\n    pure e\n  else\n    let s \u2190 get\n    match s.visitedExpr.find? e with\n    | some r => pure r\n    | none   =>\n      let r \u2190 f e\n      modify fun s => { s with visitedExpr := s.visitedExpr.insert e r }\n      pure r", "start": [135, 1], "end": [145, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.mkNewLevelParam", "code": "def mkNewLevelParam (u : Level) : ClosureM Level := do\n  let s \u2190 get\n  let p := (`u).appendIndexAfter s.nextLevelIdx\n  modify fun s => { s with levelParams := s.levelParams.push p, nextLevelIdx := s.nextLevelIdx + 1, levelArgs := s.levelArgs.push u }\n  pure $ mkLevelParam p", "start": [147, 1], "end": [151, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.collectLevelAux", "code": "partial def collectLevelAux : Level \u2192 ClosureM Level\n  | u@(Level.succ v)   => return u.updateSucc! (\u2190 visitLevel collectLevelAux v)\n  | u@(Level.max v w)  => return u.updateMax! (\u2190 visitLevel collectLevelAux v) (\u2190 visitLevel collectLevelAux w)\n  | u@(Level.imax v w) => return u.updateIMax! (\u2190 visitLevel collectLevelAux v) (\u2190 visitLevel collectLevelAux w)\n  | u@(Level.mvar ..)    => mkNewLevelParam u\n  | u@(Level.param ..)   => mkNewLevelParam u\n  | u@(Level.zero)     => pure u", "start": [153, 1], "end": [159, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.collectLevel", "code": "def collectLevel (u : Level) : ClosureM Level := do\n  visitLevel collectLevelAux u", "start": [161, 1], "end": [163, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.preprocess", "code": "def preprocess (e : Expr) : ClosureM Expr := do\n  let e \u2190 instantiateMVars e\n  let ctx \u2190 read\n  if !ctx.zeta then\n    check e\n  pure e", "start": [165, 1], "end": [172, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.mkNextUserName", "code": "def mkNextUserName : ClosureM Name := do\n  let s \u2190 get\n  let n := (`_x).appendIndexAfter s.nextExprIdx\n  modify fun s => { s with nextExprIdx := s.nextExprIdx + 1 }\n  pure n", "start": [174, 1], "end": [182, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.pushToProcess", "code": "def pushToProcess (elem : ToProcessElement) : ClosureM Unit :=\n  modify fun s => { s with toProcess := s.toProcess.push elem }", "start": [184, 1], "end": [185, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.collectExprAux", "code": "partial def collectExprAux (e : Expr) : ClosureM Expr := do\n  let collect (e : Expr) := visitExpr collectExprAux e\n  match e with\n  | Expr.proj _ _ s      => return e.updateProj! (\u2190 collect s)\n  | Expr.forallE _ d b _ => return e.updateForallE! (\u2190 collect d) (\u2190 collect b)\n  | Expr.lam _ d b _     => return e.updateLambdaE! (\u2190 collect d) (\u2190 collect b)\n  | Expr.letE _ t v b _  => return e.updateLet! (\u2190 collect t) (\u2190 collect v) (\u2190 collect b)\n  | Expr.app f a         => return e.updateApp! (\u2190 collect f) (\u2190 collect a)\n  | Expr.mdata _ b       => return e.updateMData! (\u2190 collect b)\n  | Expr.sort u          => return e.updateSort! (\u2190 collectLevel u)\n  | Expr.const _ us      => return e.updateConst! (\u2190 us.mapM collectLevel)\n  | Expr.mvar mvarId     =>\n    let mvarDecl \u2190 mvarId.getDecl\n    let type \u2190 preprocess mvarDecl.type\n    let type \u2190 collect type\n    let newFVarId \u2190 mkFreshFVarId\n    let userName \u2190 mkNextUserName\n    modify fun s => { s with\n      newLocalDeclsForMVars := s.newLocalDeclsForMVars.push $ .cdecl default newFVarId userName type .default .default,\n      exprMVarArgs          := s.exprMVarArgs.push e\n    }\n    return mkFVar newFVarId\n  | Expr.fvar fvarId =>\n    match (\u2190 read).zeta, (\u2190 fvarId.getValue?) with\n    | true, some value => collect (\u2190 preprocess value)\n    | _,    _          =>\n      let newFVarId \u2190 mkFreshFVarId\n      pushToProcess \u27e8fvarId, newFVarId\u27e9\n      return mkFVar newFVarId\n  | e => pure e", "start": [187, 1], "end": [216, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.collectExpr", "code": "def collectExpr (e : Expr) : ClosureM Expr := do\n  let e \u2190 preprocess e\n  visitExpr collectExprAux e", "start": [218, 1], "end": [220, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.pickNextToProcessAux", "code": "partial def pickNextToProcessAux (lctx : LocalContext) (i : Nat) (toProcess : Array ToProcessElement) (elem : ToProcessElement)\n    : ToProcessElement \u00d7 Array ToProcessElement :=\n  if h : i < toProcess.size then\n    let elem' := toProcess.get \u27e8i, h\u27e9\n    if (lctx.get! elem.fvarId).index < (lctx.get! elem'.fvarId).index then\n      pickNextToProcessAux lctx (i+1) (toProcess.set \u27e8i, h\u27e9 elem) elem'\n    else\n      pickNextToProcessAux lctx (i+1) toProcess elem\n  else\n    (elem, toProcess)", "start": [222, 1], "end": [231, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.pickNextToProcess?", "code": "def pickNextToProcess? : ClosureM (Option ToProcessElement) := do\n  let lctx \u2190 getLCtx\n  let s \u2190 get\n  if s.toProcess.isEmpty then\n    pure none\n  else\n    modifyGet fun s =>\n      let elem      := s.toProcess.back\n      let toProcess := s.toProcess.pop\n      let (elem, toProcess) := pickNextToProcessAux lctx 0 toProcess elem\n      (some elem, { s with toProcess := toProcess })", "start": [233, 1], "end": [243, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.pushFVarArg", "code": "def pushFVarArg (e : Expr) : ClosureM Unit :=\n  modify fun s => { s with exprFVarArgs := s.exprFVarArgs.push e }", "start": [245, 1], "end": [246, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.pushLocalDecl", "code": "def pushLocalDecl (newFVarId : FVarId) (userName : Name) (type : Expr) (bi := BinderInfo.default) : ClosureM Unit := do\n  let type \u2190 collectExpr type\n  modify fun s => { s with newLocalDecls := s.newLocalDecls.push <| .cdecl default newFVarId userName type bi .default }", "start": [248, 1], "end": [250, 121], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.process", "code": "partial def process : ClosureM Unit := do\n  match (\u2190 pickNextToProcess?) with\n  | none => pure ()\n  | some \u27e8fvarId, newFVarId\u27e9 =>\n    match (\u2190 fvarId.getDecl) with\n    | .cdecl _ _ userName type bi _ =>\n      pushLocalDecl newFVarId userName type bi\n      pushFVarArg (mkFVar fvarId)\n      process\n    | .ldecl _ _ userName type val _ _ =>\n      let zetaFVarIds \u2190 getZetaFVarIds\n      if !zetaFVarIds.contains fvarId then\n        \n        pushLocalDecl newFVarId userName type\n        pushFVarArg (mkFVar fvarId)\n        process\n      else\n        \n        let type \u2190 collectExpr type\n        let val  \u2190 collectExpr val\n        modify fun s => { s with newLetDecls := s.newLetDecls.push <| .ldecl default newFVarId userName type val false .default }\n        \n        modify fun s => { s with newLocalDecls := s.newLocalDecls.map (\u00b7.replaceFVarId newFVarId val) }\n        process", "start": [252, 1], "end": [282, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.mkBinding", "code": "@[inline] def mkBinding (isLambda : Bool) (decls : Array LocalDecl) (b : Expr) : Expr :=\n  let xs := decls.map LocalDecl.toExpr\n  let b  := b.abstract xs\n  decls.size.foldRev (init := b) fun i b =>\n    let decl := decls[i]!\n    match decl with\n    | .cdecl _ _ n ty bi _ =>\n      let ty := ty.abstractRange i xs\n      if isLambda then\n        Lean.mkLambda n bi ty b\n      else\n        Lean.mkForall n bi ty b\n    | .ldecl _ _ n ty val nonDep _ =>\n      if b.hasLooseBVar 0 then\n        let ty  := ty.abstractRange i xs\n        let val := val.abstractRange i xs\n        mkLet n ty val b nonDep\n      else\n        b.lowerLooseBVars 1 1", "start": [284, 1], "end": [302, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.mkLambda", "code": "def mkLambda (decls : Array LocalDecl) (b : Expr) : Expr :=\n  mkBinding true decls b", "start": [304, 1], "end": [305, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.mkForall", "code": "def mkForall (decls : Array LocalDecl) (b : Expr) : Expr :=\n  mkBinding false decls b", "start": [307, 1], "end": [308, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.MkValueTypeClosureResult", "code": "structure MkValueTypeClosureResult where\n  levelParams : Array Name\n  type        : Expr\n  value       : Expr\n  levelArgs   : Array Level\n  exprArgs    : Array Expr", "start": [310, 1], "end": [315, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.mkValueTypeClosureAux", "code": "def mkValueTypeClosureAux (type : Expr) (value : Expr) : ClosureM (Expr \u00d7 Expr) := do\n  resetZetaFVarIds\n  withTrackingZeta do\n    let type  \u2190 collectExpr type\n    let value \u2190 collectExpr value\n    process\n    pure (type, value)", "start": [317, 1], "end": [323, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Closure.mkValueTypeClosure", "code": "def mkValueTypeClosure (type : Expr) (value : Expr) (zeta : Bool) : MetaM MkValueTypeClosureResult := do\n  let ((type, value), s) \u2190 ((mkValueTypeClosureAux type value).run { zeta := zeta }).run {}\n  let newLocalDecls := s.newLocalDecls.reverse ++ s.newLocalDeclsForMVars\n  let newLetDecls   := s.newLetDecls.reverse\n  let type  := mkForall newLocalDecls (mkForall newLetDecls type)\n  let value := mkLambda newLocalDecls (mkLambda newLetDecls value)\n  pure {\n    type        := type,\n    value       := value,\n    levelParams := s.levelParams,\n    levelArgs   := s.levelArgs,\n    exprArgs    := s.exprFVarArgs.reverse ++ s.exprMVarArgs\n  }", "start": [325, 1], "end": [337, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAuxDefinition", "code": "def mkAuxDefinition (name : Name) (type : Expr) (value : Expr) (zeta : Bool := false) (compile : Bool := true) : MetaM Expr := do\n  let result \u2190 Closure.mkValueTypeClosure type value zeta\n  let env \u2190 getEnv\n  let decl := Declaration.defnDecl {\n    name        := name\n    levelParams := result.levelParams.toList\n    type        := result.type\n    value       := result.value\n    hints       := ReducibilityHints.regular (getMaxHeight env result.value + 1)\n    safety      := if env.hasUnsafe result.type || env.hasUnsafe result.value then DefinitionSafety.unsafe else DefinitionSafety.safe\n  }\n  addDecl decl\n  if compile then\n    compileDecl decl\n  return mkAppN (mkConst name result.levelArgs.toList) result.exprArgs", "start": [341, 1], "end": [361, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAuxDefinitionFor", "code": "def mkAuxDefinitionFor (name : Name) (value : Expr) (zeta : Bool := false) : MetaM Expr := do\n  let type \u2190 inferType value\n  let type := type.headBeta\n  mkAuxDefinition name type value (zeta := zeta)", "start": [363, 1], "end": [367, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAuxTheorem", "code": "def mkAuxTheorem (name : Name) (type : Expr) (value : Expr) (zeta : Bool := false) : MetaM Expr := do\n  let result \u2190 Closure.mkValueTypeClosure type value zeta\n  let env \u2190 getEnv\n  let decl :=\n    if env.hasUnsafe result.type || env.hasUnsafe result.value then\n      Declaration.defnDecl {\n        name\n        levelParams := result.levelParams.toList\n        type        := result.type\n        value       := result.value\n        hints       := ReducibilityHints.opaque\n        safety      := DefinitionSafety.unsafe\n      }\n    else\n      Declaration.thmDecl {\n        name\n        levelParams := result.levelParams.toList\n        type        := result.type\n        value       := result.value\n      }\n  addDecl decl\n  return mkAppN (mkConst name result.levelArgs.toList) result.exprArgs", "start": [369, 1], "end": [394, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAuxTheoremFor", "code": "def mkAuxTheoremFor (name : Name) (value : Expr) (zeta : Bool := false) : MetaM Expr := do\n  let type \u2190 inferType value\n  let type := type.headBeta\n  mkAuxTheorem name type value zeta", "start": [396, 1], "end": [402, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/GeneralizeTelescope.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/KAbstract.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.GeneralizeTelescope.Entry", "code": "structure Entry where\n  expr     : Expr\n  type     : Expr\n  modified : Bool", "start": [12, 1], "end": [15, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.GeneralizeTelescope.updateTypes", "code": "partial def updateTypes (e eNew : Expr) (entries : Array Entry) (i : Nat) : MetaM (Array Entry) :=\n  if h : i < entries.size then\n    let entry := entries.get \u27e8i, h\u27e9\n    match entry with\n    | \u27e8_, type, _\u27e9 => do\n      let typeAbst \u2190 kabstract type e\n      if typeAbst.hasLooseBVars then do\n        let typeNew := typeAbst.instantiate1 eNew\n        let entries := entries.set \u27e8i, h\u27e9 { entry with type := typeNew, modified := true }\n        updateTypes e eNew entries (i+1)\n      else\n        updateTypes e eNew entries (i+1)\n  else\n    pure entries", "start": [17, 1], "end": [30, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.GeneralizeTelescope.generalizeTelescopeAux", "code": "partial def generalizeTelescopeAux {\u03b1} (k : Array Expr \u2192 MetaM \u03b1)\n    (entries : Array Entry) (i : Nat) (fvars : Array Expr) : MetaM \u03b1 := do\n  if h : i < entries.size then\n    let replace (baseUserName : Name) (e : Expr) (type : Expr) : MetaM \u03b1 := do\n      let userName \u2190 mkFreshUserName baseUserName\n      withLocalDeclD userName type fun x => do\n        let entries \u2190 updateTypes e x entries (i+1)\n        generalizeTelescopeAux k entries (i+1) (fvars.push x)\n    match entries.get \u27e8i, h\u27e9 with\n    | \u27e8e@(.fvar fvarId), type, false\u27e9 =>\n      let localDecl \u2190 fvarId.getDecl\n      match localDecl with\n      | .cdecl .. => generalizeTelescopeAux k entries (i+1) (fvars.push e)\n      | .ldecl .. => replace localDecl.userName e type\n    | \u27e8e, type, modified\u27e9 =>\n      if modified then\n        unless (\u2190 isTypeCorrect type) do\n          throwError \"failed to create telescope generalizing {entries.map Entry.expr}\"\n      replace `x e type\n  else\n    k fvars", "start": [32, 1], "end": [52, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.generalizeTelescope", "code": "def generalizeTelescope {\u03b1} (es : Array Expr) (k : Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  let es \u2190 es.mapM fun e => do\n    let type \u2190 inferType e\n    let type \u2190 instantiateMVars type\n    pure { expr := e, type := type, modified := false : Entry }\n  generalizeTelescopeAux k es 0 #[]", "start": [58, 1], "end": [92, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/FileWorker/Utils.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Server/AsyncList.lean", "lake-packages/lean4/src/lean/Lean/Server/Utils.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Lean/Server/Snapshots.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Server.FileWorker.logSnapContent", "code": "def logSnapContent (s : Snapshot) (text : FileMap) : IO Unit :=\n  IO.eprintln s!\"[{s.beginPos}, {s.endPos}]: ```\\n{text.source.extract s.beginPos (s.endPos - \u27e81\u27e9)}\\n```\"", "start": [17, 1], "end": [18, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.ElabTaskError", "code": "inductive ElabTaskError where\n  | aborted\n  | ioError (e : IO.Error)", "start": [20, 1], "end": [22, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.CancelToken", "code": "structure CancelToken where\n  ref : IO.Ref Bool", "start": [30, 1], "end": [31, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.CancelToken.new", "code": "def new : IO CancelToken :=\n  CancelToken.mk <$> IO.mkRef false", "start": [35, 1], "end": [36, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.CancelToken.check", "code": "def check [MonadExceptOf ElabTaskError m] [MonadLiftT (ST RealWorld) m] [Monad m] (tk : CancelToken) : m Unit := do\n  let c \u2190 tk.ref.get\n  if c then\n    throw ElabTaskError.aborted", "start": [38, 1], "end": [41, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.CancelToken.set", "code": "def set (tk : CancelToken) : IO Unit :=\n  tk.ref.set true", "start": [43, 1], "end": [44, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.EditableDocument", "code": "structure EditableDocument where\n  meta       : DocumentMeta\n  \n  cmdSnaps   : AsyncList ElabTaskError Snapshot\n  cancelTk   : CancelToken", "start": [48, 1], "end": [55, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.RpcSession", "code": "structure RpcSession where\n  objects         : RpcObjectStore\n  \n  expireTime      : Nat", "start": [61, 1], "end": [64, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.RpcSession.keepAliveTimeMs", "code": "def keepAliveTimeMs : Nat :=\n  30000", "start": [68, 1], "end": [69, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.RpcSession.new", "code": "def new : IO (UInt64 \u00d7 RpcSession) := do\n  \n  let newId \u2190 ByteArray.toUInt64LE! <$> IO.getRandomBytes 8\n  let newSesh := {\n    objects := {}\n    expireTime := (\u2190 IO.monoMsNow) + keepAliveTimeMs\n  }\n  return (newId, newSesh)", "start": [71, 1], "end": [79, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.RpcSession.keptAlive", "code": "def keptAlive (monoMsNow : Nat) (s : RpcSession) : RpcSession :=\n  { s with expireTime := monoMsNow + keepAliveTimeMs }", "start": [81, 1], "end": [82, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.RpcSession.hasExpired", "code": "def hasExpired (s : RpcSession) : IO Bool :=\n  return s.expireTime \u2264 (\u2190 IO.monoMsNow)", "start": [84, 1], "end": [85, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/FileSource.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Lsp.FileSource", "code": "class FileSource (\u03b1 : Type) where\n  fileSource : \u03b1 \u2192 DocumentUri", "start": [11, 1], "end": [12, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Data/FuzzyMatching.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.FuzzyMatching.iterateLookaround", "code": "@[specialize] private def iterateLookaround (f : (Option Char \u00d7 Char \u00d7 Option Char) \u2192 \u03b1) (string : String) : Array \u03b1 :=\n  if string.isEmpty then\n    #[]\n  else if string.length == 1 then\n    #[f (none, string.get 0, none)]\n  else Id.run do\n    let mut result := Array.mkEmpty string.length\n    result := result.push <| f (none, string.get 0, string.get \u27e81\u27e9)\n    for i in [2:string.length] do\n      result := result.push <| f (string.get \u27e8i - 2\u27e9, string.get \u27e8i - 1\u27e9, string.get \u27e8i\u27e9)\n    result.push <| f (string.get \u27e8string.length - 2\u27e9, string.get \u27e8string.length - 1\u27e9, none)", "start": [17, 1], "end": [28, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.containsInOrderLower", "code": "private def containsInOrderLower (a b : String) : Bool := Id.run do\n  if a.isEmpty then\n    return true\n  let mut aIt := a.mkIterator\n    for i in [:b.endPos.byteIdx] do\n    if aIt.curr.toLower == (b.get \u27e8i\u27e9).toLower then\n      aIt := aIt.next\n      if !aIt.hasNext then\n        return true\n  return false", "start": [30, 1], "end": [40, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.CharType", "code": "inductive CharType where\n  | lower | upper | separator", "start": [45, 1], "end": [47, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.charType", "code": "def charType (c : Char) : CharType :=\n  if c.isAlphanum then\n    if c.isUpper\n      then CharType.upper\n      else CharType.lower\n  else\n    CharType.separator", "start": [49, 1], "end": [55, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.CharRole", "code": "inductive CharRole where\n  | head | tail | separator\n  deriving Inhabited", "start": [58, 1], "end": [61, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.charRole", "code": "@[inline] def charRole (prev? : Option CharType) (curr : CharType) (next?: Option CharType) : CharRole :=\n  if curr matches CharType.separator then\n    CharRole.separator\n  else if prev?.isNone || prev? matches some CharType.separator then\n    CharRole.head\n  else if curr matches CharType.lower then\n    CharRole.tail\n  else if prev? matches some CharType.upper && !(next? matches some CharType.lower) then\n    CharRole.tail\n  else\n    CharRole.head", "start": [63, 1], "end": [73, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.stringInfo", "code": "private def stringInfo (s : String) : Array CharRole :=\n  iterateLookaround (string := s) fun (prev?, curr, next?) =>\n    charRole (prev?.map charType) (charType curr) (next?.map charType)", "start": [75, 1], "end": [78, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.selectBest", "code": "private def selectBest (missScore? matchScore? : Option Int) : Option Int :=\n  match (missScore?, matchScore?) with\n  | (missScore, none)  => missScore\n  | (none, matchScore) => matchScore\n  | (some missScore, some matchScore) =>\n    some <| max missScore matchScore", "start": [81, 1], "end": [86, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.fuzzyMatchCore", "code": "private def fuzzyMatchCore (pattern word : String) (patternRoles wordRoles : Array CharRole) : Option Int := Id.run do\n  \n  let mut result : Array (Option Int) := Array.mkArray (pattern.length * word.length * 2) none\n  let mut runLengths : Array Int := Array.mkArray (pattern.length * word.length) 0\n\n  let mut startPenalties : Array Int := Array.mkArray word.length 0\n\n  let mut lastSepIdx := 0\n  let mut penaltyNs : Int := 0\n  let mut penaltySkip : Int := 0\n  for wordIdx in [:word.length] do\n    if (wordIdx != 0) && (wordRoles.get! wordIdx) matches .separator then\n      penaltySkip := 0\n      penaltyNs := penaltyNs + 1\n      lastSepIdx := wordIdx\n    penaltySkip := penaltySkip + skipPenalty (wordRoles.get! wordIdx) (wordIdx == 0)\n    startPenalties := startPenalties.set! wordIdx $ penaltySkip + penaltyNs\n\n  for patternIdx in [:pattern.length] do\n    \n    for wordIdx in [patternIdx:word.length-(pattern.length - patternIdx - 1)] do\n      let missScore? := \n        if wordIdx >= 1 then \n          selectBest\n            (getMiss result patternIdx (wordIdx - 1))\n            (getMatch result patternIdx (wordIdx - 1))\n        else none\n\n      let mut matchScore? := none\n\n      if allowMatch (pattern.get \u27e8patternIdx\u27e9) (word.get \u27e8wordIdx\u27e9) (patternRoles.get! patternIdx) (wordRoles.get! wordIdx) then\n        if patternIdx >= 1 then \n          let runLength := runLengths.get! (getIdx (patternIdx - 1) (wordIdx - 1)) + 1\n          runLengths := runLengths.set! (getIdx patternIdx wordIdx) runLength\n\n          matchScore? := selectBest\n            (getMiss result (patternIdx - 1) (wordIdx - 1) |>.map (\u00b7 + matchResult\n              patternIdx wordIdx\n              (patternRoles.get! patternIdx) (wordRoles.get! wordIdx)\n              none\n            - startPenalties.get! wordIdx))\n            (getMatch result (patternIdx - 1) (wordIdx - 1) |>.map (\u00b7 + matchResult\n              patternIdx wordIdx\n              (patternRoles.get! patternIdx) (wordRoles.get! wordIdx)\n              (.some runLength)\n            )) |>.map fun score => if wordIdx >= lastSepIdx then score + 1 else score else\n          runLengths := runLengths.set! (getIdx patternIdx wordIdx) 1\n          matchScore? := .some $ matchResult\n              patternIdx wordIdx\n              (patternRoles.get! patternIdx) (wordRoles.get! wordIdx)\n              none\n              - startPenalties.get! wordIdx\n\n      result := set result patternIdx wordIdx missScore? matchScore?\n\n  return selectBest (getMiss result (pattern.length - 1) (word.length - 1)) (getMatch result (pattern.length - 1) (word.length - 1))\n\n  where\n    getDoubleIdx (patternIdx wordIdx : Nat) := patternIdx * word.length * 2 + wordIdx * 2\n\n    getIdx (patternIdx wordIdx : Nat) := patternIdx * word.length + wordIdx\n\n    getMiss (result : Array (Option Int)) (patternIdx wordIdx : Nat) : Option Int :=\n      result.get! $ getDoubleIdx patternIdx wordIdx\n\n    getMatch (result : Array (Option Int)) (patternIdx wordIdx : Nat) : Option Int :=\n      result.get! $ getDoubleIdx patternIdx wordIdx + 1\n\n    set (result : Array (Option Int)) (patternIdx wordIdx : Nat) (missValue matchValue : Option Int) : Array (Option Int) :=\n      let idx := getDoubleIdx patternIdx wordIdx\n      result |>.set! idx missValue |>.set! (idx + 1) matchValue\n\n    \n    skipPenalty (wordRole : CharRole) (wordStart : Bool) : Int := Id.run do\n      \n      if wordStart then\n        return 3\n      \n      if wordRole matches CharRole.head then\n        return 1\n\n      return 0\n\n    \n    allowMatch (patternChar wordChar : Char) (patternRole wordRole : CharRole) : Bool := Id.run do\n      \n      if patternChar.toLower != wordChar.toLower then\n        return false\n      \n      if patternRole matches CharRole.head && !(wordRole matches CharRole.head) then\n        return false\n\n      return true\n\n    \n    matchResult (patternIdx wordIdx : Nat) (patternRole wordRole : CharRole) (consecutive : Option Int) : Int := Id.run do\n      let mut score : Int := 1\n      \n      if (pattern.get \u27e8patternIdx\u27e9) == (word.get \u27e8wordIdx\u27e9) || (patternRole matches CharRole.head && wordRole matches CharRole.head) then\n        score := score + 1\n      \n      if wordIdx == word.length - 1 && patternIdx == pattern.length - 1 then\n        score := score + 2\n      \n      if (wordIdx == 0) then\n        score := score + 3\n      \n      if let some bonus := consecutive then\n        \n        score := score + bonus \n      return score", "start": [88, 1], "end": [214, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.fuzzyMatchScore?", "code": "def fuzzyMatchScore? (pattern word : String) : Option Float := Id.run do\n  \n  if pattern.isEmpty then\n    return some 1\n  if pattern.length > word.length then\n    return none\n  if !(containsInOrderLower pattern word) then\n    return none\n\n  let some score := fuzzyMatchCore pattern word (stringInfo pattern) (stringInfo word)\n    | none\n  let mut score := score\n\n  \n  if pattern.length == word.length then\n    score := score * 2\n\n  \n  let perfect := 4\n  \n  let perfectMatch := (perfect * pattern.length + ((pattern.length * (pattern.length + 1) / 2) - 1))\n  let normScore := Float.ofInt score / Float.ofInt perfectMatch\n\n  return some <| min 1 (max 0 normScore)", "start": [216, 1], "end": [243, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.fuzzyMatchScoreWithThreshold?", "code": "def fuzzyMatchScoreWithThreshold? (pattern word : String) (threshold := 0.1) : Option Float :=\n  fuzzyMatchScore? pattern word |>.filter (\u00b7 > threshold)", "start": [245, 1], "end": [246, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.FuzzyMatching.fuzzyMatch", "code": "def fuzzyMatch (pattern word : String) (threshold := 0.2) : Bool :=\n  fuzzyMatchScoreWithThreshold? pattern word threshold |>.isSome", "start": [248, 1], "end": [252, 65], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/LazyInitExtension.lean", "imports": ["lake-packages/lean4/src/lean/Lean/MonadEnv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LazyInitExtension", "code": "structure LazyInitExtension (m : Type \u2192 Type) (\u03b1 : Type) where\n  ext : EnvExtension (Option \u03b1)\n  fn  : m \u03b1", "start": [10, 1], "end": [12, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.registerLazyInitExtension", "code": "def registerLazyInitExtension (fn : m \u03b1) : IO (LazyInitExtension m \u03b1) := do\n  let ext \u2190 registerEnvExtension (pure none)\n  return { ext, fn }", "start": [20, 1], "end": [31, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.LazyInitExtension.get", "code": "def LazyInitExtension.get [MonadEnv m] [Monad m] (init : LazyInitExtension m \u03b1) : m \u03b1 := do\n  match init.ext.getState (\u2190 getEnv) with\n  | some a => return a\n  | none   =>\n    let a \u2190 init.fn\n    modifyEnv fun env => init.ext.setState env (some a)\n    return a", "start": [33, 1], "end": [39, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Simp.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat/Solver.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Rewrite.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Config.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Replace.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.rewriteTarget", "code": "def rewriteTarget (stx : Syntax) (symm : Bool) (config : Rewrite.Config := {}) : TacticM Unit := do\n  Term.withSynthesize <| withMainContext do\n    let e \u2190 elabTerm stx none true\n    let r \u2190 (\u2190 getMainGoal).rewrite (\u2190 getMainTarget) e symm (config := config)\n    let mvarId' \u2190 (\u2190 getMainGoal).replaceTargetEq r.eNew r.eqProof\n    replaceMainGoal (mvarId' :: r.mvarIds)", "start": [14, 1], "end": [19, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.rewriteLocalDecl", "code": "def rewriteLocalDecl (stx : Syntax) (symm : Bool) (fvarId : FVarId) (config : Rewrite.Config := {}) :\n    TacticM Unit := do\n  Term.withSynthesize <| withMainContext do\n    let e \u2190 elabTerm stx none true\n    let localDecl \u2190 fvarId.getDecl\n    let rwResult \u2190 (\u2190 getMainGoal).rewrite localDecl.type e symm (config := config)\n    let replaceResult \u2190 (\u2190 getMainGoal).replaceLocalDecl fvarId rwResult.eNew rwResult.eqProof\n    replaceMainGoal (replaceResult.mvarId :: rwResult.mvarIds)", "start": [21, 1], "end": [28, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.withRWRulesSeq", "code": "def withRWRulesSeq (token : Syntax) (rwRulesSeqStx : Syntax) (x : (symm : Bool) \u2192 (term : Syntax) \u2192 TacticM Unit) : TacticM Unit := do\n  let lbrak := rwRulesSeqStx[0]\n  let rules := rwRulesSeqStx[1].getArgs\n  withTacticInfoContext (mkNullNode #[token, lbrak]) (pure ())\n  let numRules := (rules.size + 1) / 2\n  for i in [:numRules] do\n    let rule := rules[i * 2]!\n    let sep  := rules.getD (i * 2 + 1) Syntax.missing\n    withTacticInfoContext (mkNullNode #[rule, sep]) do\n      withRef rule do\n        let symm := !rule[0].isNone\n        let term := rule[1]\n        let processId (id : Syntax) : TacticM Unit := do\n          let declName \u2190 try resolveGlobalConstNoOverload id catch _ => return (\u2190 x symm term)\n          let some eqThms \u2190 getEqnsFor? declName (nonRec := true) | x symm term\n          let rec go : List Name \u2192  TacticM Unit\n            | [] => throwError \"failed to rewrite using equation theorems for '{declName}'\"\n            | eqThm::eqThms => (x symm (mkIdentFrom id eqThm)) <|> go eqThms\n          go eqThms.toList\n          discard <| Term.addTermInfo id (\u2190 mkConstWithFreshMVarLevels declName) (lctx? := \u2190 getLCtx)\n        match term with\n        | `($id:ident)  => processId id\n        | `(@$id:ident) => processId id\n        | _ => x symm term", "start": [30, 1], "end": [57, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalRewriteSeq", "code": "@[builtin_tactic Lean.Parser.Tactic.rewriteSeq] def evalRewriteSeq : Tactic := fun stx => do\n  let cfg \u2190 elabRewriteConfig stx[1]\n  let loc   := expandOptLocation stx[3]\n  withRWRulesSeq stx[0] stx[2] fun symm term => do\n    withLocation loc\n      (rewriteLocalDecl term symm \u00b7 cfg)\n      (rewriteTarget term symm cfg)\n      (throwTacticEx `rewrite \u00b7 \"did not find instance of the pattern in the current goal\")", "start": [62, 1], "end": [69, 92], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Refl.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Reduce.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.useKernel", "code": "private def useKernel (lhs rhs : Expr) : MetaM Bool := do\n  if lhs.hasFVar || lhs.hasMVar || rhs.hasFVar || rhs.hasMVar then\n    return false\n  else\n    return (\u2190 getTransparency) matches TransparencyMode.default | TransparencyMode.all", "start": [12, 1], "end": [16, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.refl", "code": "def _root_.Lean.MVarId.refl (mvarId : MVarId) : MetaM Unit := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `refl\n    let targetType \u2190 mvarId.getType'\n    unless targetType.isAppOfArity ``Eq 3 do\n      throwTacticEx `rfl mvarId m!\"equality expected{indentExpr targetType}\"\n    let lhs \u2190 instantiateMVars targetType.appFn!.appArg!\n    let rhs \u2190 instantiateMVars targetType.appArg!\n    let success \u2190 if (\u2190 useKernel lhs rhs) then\n      ofExceptKernelException (Kernel.isDefEq (\u2190 getEnv) {} lhs rhs)\n    else\n      isDefEq lhs rhs\n    unless success do\n      throwTacticEx `rfl mvarId m!\"equality lhs{indentExpr lhs}\\nis not definitionally equal to rhs{indentExpr rhs}\"\n    let us := targetType.getAppFn.constLevels!\n    let \u03b1 := targetType.appFn!.appFn!.appArg!\n    mvarId.assign (mkApp2 (mkConst ``Eq.refl  us) \u03b1 lhs)", "start": [18, 1], "end": [37, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.refl", "code": "@[deprecated MVarId.refl]\ndef refl (mvarId : MVarId) : MetaM Unit := do\n  mvarId.refl", "start": [39, 1], "end": [41, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.applyRefl", "code": "@[deprecated MVarId.refl]\ndef _root_.Lean.MVarId.applyRefl (mvarId : MVarId) (msg : MessageData := \"refl failed\") : MetaM Unit :=\n  try mvarId.refl catch _ => throwError msg", "start": [43, 1], "end": [45, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.heqOfEq", "code": "def _root_.Lean.MVarId.heqOfEq (mvarId : MVarId) : MetaM MVarId :=\n  mvarId.withContext do\n    let some [mvarId] \u2190 observing? do mvarId.apply (mkConst ``heq_of_eq [\u2190 mkFreshLevelMVar]) | return mvarId\n    return mvarId", "start": [47, 1], "end": [53, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.eqOfHEq", "code": "def _root_.Lean.MVarId.eqOfHEq (mvarId : MVarId) : MetaM MVarId :=\n  mvarId.withContext do\n    let some [mvarId] \u2190 observing? do mvarId.apply (mkConst ``eq_of_heq [\u2190 mkFreshLevelMVar]) | return mvarId\n    return mvarId", "start": [55, 1], "end": [61, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.hrefl", "code": "def _root_.Lean.MVarId.hrefl (mvarId : MVarId) : MetaM Unit := do\n  mvarId.withContext do\n    let some [] \u2190 observing? do mvarId.apply (mkConst ``HEq.refl [\u2190 mkFreshLevelMVar])\n      | throwTacticEx `hrefl mvarId \"\"", "start": [63, 1], "end": [69, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/Specialize.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.SpecializeAttributeKind", "code": "inductive SpecializeAttributeKind where\n  | specialize | nospecialize\n  deriving Inhabited, BEq", "start": [11, 1], "end": [13, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.elabSpecArgs", "code": "private def elabSpecArgs (declName : Name) (args : Array Syntax) : MetaM (Array Nat) := do\n  if args.isEmpty then return #[]\n  let info \u2190 getConstInfo declName\n  Meta.forallTelescopeReducing info.type fun xs _ => do\n    let argNames \u2190 xs.mapM fun x => x.fvarId!.getUserName\n    let mut result := #[]\n    for arg in args do\n      if let some idx := arg.isNatLit? then\n        if idx == 0 then throwErrorAt arg \"invalid specialization argument index, index must be greater than 0\"\n        let idx := idx - 1\n        if idx >= argNames.size then\n          throwErrorAt arg \"invalid argument index, `{declName}` has #{argNames.size} arguments\"\n        if result.contains idx then throwErrorAt arg \"invalid specialization argument index, `{argNames[idx]!}` has already been specified as a specialization candidate\"\n        result := result.push idx\n      else\n        let argName := arg.getId\n        if let some idx := argNames.getIdx? argName then\n          if result.contains idx then throwErrorAt arg \"invalid specialization argument name `{argName}`, it has already been specified as a specialization candidate\"\n          result := result.push idx\n        else\n          throwErrorAt arg \"invalid specialization argument name `{argName}`, `{declName}` does have an argument with this name\"\n    return result.qsort (\u00b7<\u00b7)", "start": [18, 1], "end": [39, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.getSpecializationArgs?", "code": "def getSpecializationArgs? (env : Environment) (declName : Name) : Option (Array Nat) :=\n  specializeAttr.getParam? env declName", "start": [50, 1], "end": [51, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasSpecializeAttribute", "code": "def hasSpecializeAttribute (env : Environment) (declName : Name) : Bool :=\n  getSpecializationArgs? env declName |>.isSome", "start": [53, 1], "end": [54, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasNospecializeAttribute", "code": "def hasNospecializeAttribute (env : Environment) (declName : Name) : Bool :=\n  nospecializeAttr.hasTag env declName", "start": [56, 1], "end": [57, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasSpecializeAttributeOld", "code": "@[export lean_has_specialize_attribute]\npartial def hasSpecializeAttributeOld (env : Environment) (n : Name) : Bool :=\n  match specializeAttr.getParam? env n with\n  | some _ => true\n  | none   => if n.isInternal then hasSpecializeAttributeOld env n.getPrefix else false", "start": [61, 1], "end": [65, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.hasNospecializeAttributeOld", "code": "@[export lean_has_nospecialize_attribute]\npartial def hasNospecializeAttributeOld (env : Environment) (n : Name) : Bool :=\n  nospecializeAttr.hasTag env n ||\n  (n.isInternal && hasNospecializeAttributeOld env n.getPrefix)", "start": [67, 1], "end": [70, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.SpecArgKind", "code": "inductive SpecArgKind where\n  | fixed\n  | fixedNeutral | fixedHO      | fixedInst    | other\n  deriving Inhabited", "start": [72, 1], "end": [78, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.SpecInfo", "code": "structure SpecInfo where\n  mutualDecls : List Name\n  argKinds : List SpecArgKind\n  deriving Inhabited", "start": [80, 1], "end": [83, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.SpecState", "code": "structure SpecState where\n  specInfo : SMap Name SpecInfo := {}\n  cache    : SMap Expr Name := {}\n  deriving Inhabited", "start": [85, 1], "end": [88, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.SpecEntry", "code": "inductive SpecEntry where\n  | info (name : Name) (info : SpecInfo)\n  | cache (key : Expr) (fn : Name)\n  deriving Inhabited", "start": [90, 1], "end": [93, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.SpecState.addEntry", "code": "def addEntry (s : SpecState) (e : SpecEntry) : SpecState :=\n  match e with\n  | SpecEntry.info name info => { s with specInfo := s.specInfo.insert name info }\n  | SpecEntry.cache key fn   => { s with cache    := s.cache.insert key fn }", "start": [97, 1], "end": [100, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.SpecState.switch", "code": "def switch : SpecState \u2192 SpecState\n  | \u27e8m\u2081, m\u2082\u27e9 => \u27e8m\u2081.switch, m\u2082.switch\u27e9", "start": [102, 1], "end": [103, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.addSpecializationInfo", "code": "@[export lean_add_specialization_info]\ndef addSpecializationInfo (env : Environment) (fn : Name) (info : SpecInfo) : Environment :=\n  specExtension.addEntry env (SpecEntry.info fn info)", "start": [113, 1], "end": [115, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.getSpecializationInfo", "code": "@[export lean_get_specialization_info]\ndef getSpecializationInfo (env : Environment) (fn : Name) : Option SpecInfo :=\n  (specExtension.getState env).specInfo.find? fn", "start": [117, 1], "end": [119, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.cacheSpecialization", "code": "@[export lean_cache_specialization]\ndef cacheSpecialization (env : Environment) (e : Expr) (fn : Name) : Environment :=\n  specExtension.addEntry env (SpecEntry.cache e fn)", "start": [121, 1], "end": [123, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.getCachedSpecialization", "code": "@[export lean_get_cached_specialization]\ndef getCachedSpecialization (env : Environment) (e : Expr) : Option Name :=\n  (specExtension.getState env).cache.find? e", "start": [125, 1], "end": [127, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/InferType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.erasedExpr", "code": "def erasedExpr := mkConst ``lcErased", "start": [14, 1], "end": [14, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.isErased", "code": "def _root_.Lean.Expr.isErased (e : Expr) :=\n  e.isAppOf ``lcErased", "start": [16, 1], "end": [17, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isPropFormerTypeQuick", "code": "def isPropFormerTypeQuick : Expr \u2192 Bool\n  | .forallE _ _ b _ => isPropFormerTypeQuick b\n  | .sort .zero => true\n  | _ => false", "start": [19, 1], "end": [22, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isPropFormerType", "code": "partial def isPropFormerType (type : Expr) : MetaM Bool := do\n  match isPropFormerTypeQuick type with\n  | true => return true\n  | false => go type #[]\nwhere\n  go (type : Expr) (xs : Array Expr) : MetaM Bool := do\n    match type with\n    | .sort .zero => return true\n    | .forallE n d b c => Meta.withLocalDecl n c (d.instantiateRev xs) fun x => go b (xs.push x)\n    | _ =>\n      let type \u2190 Meta.whnfD (type.instantiateRev xs)\n      match type with\n      | .sort .zero => return true\n      | .forallE .. => go type #[]\n      | _ => return false", "start": [24, 1], "end": [41, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isPropFormer", "code": "def isPropFormer (e : Expr) : MetaM Bool := do\n  isPropFormerType (\u2190 Meta.inferType e)", "start": [43, 1], "end": [47, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.toLCNFType", "code": "partial def toLCNFType (type : Expr) : MetaM Expr := do\n  if (\u2190 isProp type) then\n    return erasedExpr\n  let type \u2190 whnfEta type\n  match type with\n  | .sort u     => return .sort u\n  | .const ..   => visitApp type #[]\n  | .lam n d b bi =>\n    withLocalDecl n bi d fun x => do\n      let d \u2190 toLCNFType d\n      let b \u2190 toLCNFType (b.instantiate1 x)\n      if b.isErased then\n        return b\n      else\n        return Expr.lam n d (b.abstract #[x]) bi\n  | .forallE .. => visitForall type #[]\n  | .app ..  => type.withApp visitApp\n  | .fvar .. => visitApp type #[]\n  | _        => return erasedExpr\nwhere\n  whnfEta (type : Expr) : MetaM Expr := do\n    let type \u2190 whnf type\n    let type' := type.eta\n    if type' != type then\n      whnfEta type'\n    else\n      return type\n\n  visitForall (e : Expr) (xs : Array Expr) : MetaM Expr := do\n    match e with\n    | .forallE n d b bi =>\n      let d := d.instantiateRev xs\n      withLocalDecl n bi d fun x => do\n        let d := (\u2190 toLCNFType d).abstract xs\n        return .forallE n d (\u2190 visitForall b (xs.push x)) bi\n    | _ =>\n      let e \u2190 toLCNFType (e.instantiateRev xs)\n      return e.abstract xs\n\n  visitApp (f : Expr) (args : Array Expr) := do\n    let fNew \u2190 match f with\n      | .const declName us =>\n        let .inductInfo _ \u2190 getConstInfo declName | return erasedExpr\n        pure <| .const declName us\n      | .fvar .. => pure f\n      | _ => return erasedExpr\n    let mut result := fNew\n    for arg in args do\n      if (\u2190 isProp arg) then\n        result := mkApp result erasedExpr\n      else if (\u2190 isPropFormer arg) then\n        result := mkApp result erasedExpr\n      else if (\u2190 isTypeFormer arg) then\n        result := mkApp result (\u2190 toLCNFType arg)\n      else\n        result := mkApp result erasedExpr\n    return result", "start": [112, 1], "end": [171, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.joinTypes", "code": "partial def joinTypes (a b : Expr) : Expr :=\n  joinTypes? a b |>.getD erasedExpr", "start": [175, 1], "end": [176, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.joinTypes?", "code": "partial def joinTypes? (a b : Expr) : Option Expr := do\n  if a.isErased || b.isErased then\n    return erasedExpr else if a == b then\n    return a\n  else\n    let a' := a.headBeta\n    let b' := b.headBeta\n    if a != a' || b != b' then\n      joinTypes? a' b'\n    else\n      match a, b with\n      | .mdata _ a, b => joinTypes? a b\n      | a, .mdata _ b => joinTypes? a b\n      | .app f a, .app g b =>\n        (do return .app (\u2190 joinTypes? f g) (\u2190 joinTypes? a b))\n         <|>\n        return erasedExpr\n      | .forallE n d\u2081 b\u2081 _, .forallE _ d\u2082 b\u2082 _ =>\n        (do return .forallE n (\u2190 joinTypes? d\u2081 d\u2082) (joinTypes b\u2081 b\u2082) .default)\n        <|>\n        return erasedExpr\n      | .lam n d\u2081 b\u2081 _, .lam _ d\u2082 b\u2082 _ =>\n        (do return .lam n (\u2190 joinTypes? d\u2081 d\u2082) (joinTypes b\u2081 b\u2082) .default)\n        <|>\n        return erasedExpr\n      | _, _ => return erasedExpr", "start": [178, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isTypeFormerType", "code": "partial def isTypeFormerType (type : Expr) : Bool :=\n  match type.headBeta with\n  | .sort .. => true\n  | .forallE _ _ b _ => isTypeFormerType b\n  | _ => false", "start": [208, 1], "end": [218, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.instantiateForall", "code": "def instantiateForall (type : Expr) (ps : Array Expr) : CoreM Expr :=\n  go 0 type\nwhere\n  go (i : Nat) (type : Expr) : CoreM Expr :=\n    if h : i < ps.size then\n      if let .forallE _ _ b _ := type.headBeta then\n        go (i+1) (b.instantiate1 ps[i])\n      else\n        throwError \"invalid instantiateForall, too many parameters\"\n    else\n      return type\ntermination_by go i _ => ps.size - i", "start": [220, 1], "end": [237, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isPredicateType", "code": "partial def isPredicateType (type : Expr) : Bool :=\n  match type.headBeta with\n  | .sort .zero => true\n  | .forallE _ _ b _ => isPredicateType b\n  | _ => false", "start": [239, 1], "end": [247, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.maybeTypeFormerType", "code": "partial def maybeTypeFormerType (type : Expr) : Bool :=\n  match type.headBeta with\n  | .sort .. => true\n  | .forallE _ _ b _ => maybeTypeFormerType b\n  | _ => type.isErased", "start": [249, 1], "end": [259, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isClass?", "code": "def isClass? (type : Expr) : CoreM (Option Name) := do\n  let .const declName _ := type.getAppFn | return none\n  if isClass (\u2190 getEnv) declName then\n    return declName\n  else\n    return none", "start": [261, 1], "end": [269, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isArrowClass?", "code": "partial def isArrowClass? (type : Expr) : CoreM (Option Name) := do\n  match type.headBeta with\n  | .forallE _ _ b _ => isArrowClass? b\n  | _ => isClass? type", "start": [271, 1], "end": [278, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getArrowArity", "code": "partial def getArrowArity (e : Expr) :=\n  match e.headBeta with\n  | .forallE _ _ b _ => getArrowArity b + 1\n  | _ => 0", "start": [280, 1], "end": [283, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isInductiveWithNoCtors", "code": "def isInductiveWithNoCtors (type : Expr) : CoreM Bool := do\n  let .const declName _ := type.getAppFn | return false\n  let some (.inductInfo info) := (\u2190 getEnv).find? declName | return false\n  return info.numCtors == 0", "start": [285, 1], "end": [289, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/AuxDef.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.elabAuxDef", "code": "@[builtin_command_elab \u00abaux_def\u00bb]\ndef elabAuxDef : CommandElab\n  | `($[$doc?:docComment]? $[$attrs?:attributes]? aux_def $suggestion* : $ty := $body) => do\n    let id := suggestion.map (\u00b7.getId.eraseMacroScopes) |>.foldl (\u00b7 ++ \u00b7) Name.anonymous\n    let id := `_aux ++ (\u2190 getMainModule) ++ `_ ++ id\n    let id := String.intercalate \"_\" <| id.components.map (\u00b7.toString (escape := false))\n    let ns \u2190 getCurrNamespace\n    let id \u2190 mkAuxName (ns.mkStr id) 1\n    let id := id.replacePrefix ns Name.anonymous elabCommand <|\n      \u2190 `($[$doc?:docComment]? $[$attrs?:attributes]?\n          def $(mkIdentFrom (mkNullNode suggestion) id (canonical := true)):ident : $ty := $body)\n  | _ => throwUnsupportedSyntax", "start": [19, 1], "end": [32, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.$", "code": "$[$doc?:docComment]? $[$attrs?:attributes]?\n          def $(mkIdentFrom (mkNullNode suggestion) id (canonical := true)):ident : $ty := $body", "start": [30, 11], "end": [31, 97], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/MacroArgUtil.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Syntax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.expandMacroArg", "code": "partial def expandMacroArg (stx : TSyntax ``macroArg) : CommandElabM (TSyntax `stx \u00d7 Term) := do\n  let (id?, id, stx) \u2190 match (\u2190 liftMacroM <| expandMacros stx) with\n    | `(macroArg| $id:ident:$stx) => pure (some id, (id : Term), stx)\n    | `(macroArg| $stx:stx)       => pure (none, (\u2190 `(x)), stx)\n    | _                           => throwUnsupportedSyntax\n  mkSyntaxAndPat id? id stx\nwhere\n  mkSyntaxAndPat (id? : Option Ident) (id : Term) (stx : TSyntax `stx) := do\n    let pat \u2190 match stx with\n    | `(stx| $s:str)\n    | `(stx| &$s:str)        => pure \u27e8mkNode `token_antiquot #[\u2190 liftMacroM <| strLitToPattern s, mkAtom \"%\", mkAtom \"$\", id]\u27e9\n    | `(stx| optional($stx)) => mkSplicePat `optional stx id \"?\"\n    | `(stx| many($stx))\n    | `(stx| many1($stx))    => mkSplicePat `many stx id \"*\"\n    | `(stx| sepBy($stx, $sep:str $[, $stxsep]? $[, allowTrailingSep]?))\n    | `(stx| sepBy1($stx, $sep:str $[, $stxsep]? $[, allowTrailingSep]?)) =>\n      mkSplicePat `sepBy stx id ((isStrLit? sep).get! ++ \"*\")\n    | `(stx| interpolatedStr(term)) => pure \u27e8Syntax.mkAntiquotNode interpolatedStrKind id\u27e9\n    | `(stx| withPosition($stx)) =>\n      let (stx, pat) \u2190 mkSyntaxAndPat id? id stx\n      let stx \u2190 `(stx| withPosition($stx))\n      return (stx, pat)\n    | _ => match id? with\n      | some id => mkAntiquotNode stx id\n      | none    => return (\u2190 `(stx| group($stx)), (\u2190 mkAntiquotNode stx id))\n    pure (stx, pat)\n  mkSplicePat (kind : SyntaxNodeKind) (stx : TSyntax `stx) (id : Term) (suffix : String) : CommandElabM Term :=\n    return \u27e8mkNullNode #[mkAntiquotSuffixSpliceNode kind (\u2190 mkAntiquotNode stx id) suffix]\u27e9\n  mkAntiquotNode : TSyntax `stx \u2192 Term \u2192 CommandElabM Term\n    | `(stx| $id:ident$[:$_]?), term => do\n      match (\u2190 liftTermElabM do Elab.Term.elabParserName? id) with\n        | some (.parser n _) =>\n          let kind := match n with\n            | ``Parser.ident => identKind\n            | ``Parser.Term.ident => identKind\n            | ``Parser.strLit => strLitKind\n            | _ => n return \u27e8Syntax.mkAntiquotNode kind term\u27e9\n        | some (.category cat) =>\n          return \u27e8Syntax.mkAntiquotNode cat term (isPseudoKind := true)\u27e9\n        | none =>\n          let id := id.getId.eraseMacroScopes\n          if (\u2190 Parser.isParserAlias id) then\n            let kind := (\u2190 Parser.getSyntaxKindOfParserAlias? id).getD Name.anonymous\n            return \u27e8Syntax.mkAntiquotNode kind term\u27e9\n          else\n            throwError \"unknown parser declaration/category/alias '{id}'\"\n    | stx, term => do\n      if stx.raw.isOfKind ``Parser.Syntax.paren then\n        let nonNullaryNodes \u2190 stx.raw[1].getArgs.filterM fun\n          | `(stx| $id:ident$[:$_]?) | `(stx| $id:ident($_)) => do\n            let info \u2190 Parser.getParserAliasInfo id.getId\n            return info.stackSz? != some 0\n          | _ => return true\n        if let #[stx] := nonNullaryNodes then\n          return (\u2190 mkAntiquotNode \u27e8stx\u27e9 term)\n      pure \u27e8Syntax.mkAntiquotNode Name.anonymous term (isPseudoKind := true)\u27e9", "start": [13, 1], "end": [77, 78], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/PatternVar.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Match/MatchPatternAttr.lean", "lake-packages/lean4/src/lean/Lean/Elab/Arg.lean", "lake-packages/lean4/src/lean/Lean/Elab/MatchAltView.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.PatternVar", "code": "abbrev PatternVar := Syntax", "start": [14, 1], "end": [14, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.State", "code": "structure State where\n  \n  found     : NameSet := {}\n  \n  vars      : Array PatternVar := #[]\n  deriving Inhabited", "start": [39, 1], "end": [45, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.M", "code": "abbrev M := StateRefT State TermElabM", "start": [47, 1], "end": [47, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.throwCtorExpected", "code": "private def throwCtorExpected {\u03b1} : M \u03b1 :=\n  throwError \"invalid pattern, constructor or constant marked with '[match_pattern]' expected\"", "start": [49, 1], "end": [50, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.throwInvalidPattern", "code": "private def throwInvalidPattern {\u03b1} : M \u03b1 :=\n  throwError \"invalid pattern\"", "start": [52, 1], "end": [53, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.Context", "code": "structure Context where\n  funId         : Ident\n  ctorVal?      : Option ConstructorVal explicit      : Bool\n  ellipsis      : Bool\n  paramDecls    : Array (Name \u00d7 BinderInfo) paramDeclIdx  : Nat := 0\n  namedArgs     : Array NamedArg\n  args          : List Arg\n  newArgs       : Array Term := #[]\n  deriving Inhabited", "start": [65, 1], "end": [75, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.isDone", "code": "private def isDone (ctx : Context) : Bool :=\n  ctx.paramDeclIdx \u2265 ctx.paramDecls.size", "start": [77, 1], "end": [78, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.finalize", "code": "private def finalize (ctx : Context) : M Syntax := do\n  if ctx.namedArgs.isEmpty && ctx.args.isEmpty then\n    let fStx \u2190 `(@$(ctx.funId):ident)\n    return Syntax.mkApp fStx ctx.newArgs\n  else\n    throwError \"too many arguments\"", "start": [80, 1], "end": [85, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.isNextArgAccessible", "code": "private def isNextArgAccessible (ctx : Context) : Bool :=\n  let i := ctx.paramDeclIdx\n  match ctx.ctorVal? with\n  | some ctorVal => i \u2265 ctorVal.numParams | none =>\n    if h : i < ctx.paramDecls.size then\n      let d := ctx.paramDecls.get \u27e8i, h\u27e9\n      d.2.isExplicit\n    else\n      false", "start": [87, 1], "end": [97, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.getNextParam", "code": "private def getNextParam (ctx : Context) : (Name \u00d7 BinderInfo) \u00d7 Context :=\n  let i := ctx.paramDeclIdx\n  let d := ctx.paramDecls[i]!\n  (d, { ctx with paramDeclIdx := ctx.paramDeclIdx + 1 })", "start": [99, 1], "end": [102, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.processVar", "code": "private def processVar (idStx : Syntax) : M Syntax := do\n  unless idStx.isIdent do\n    throwErrorAt idStx \"identifier expected\"\n  let id := idStx.getId\n  unless id.eraseMacroScopes.isAtomic do\n    throwError \"invalid pattern variable, must be atomic\"\n  if (\u2190 get).found.contains id then\n    throwError \"invalid pattern, variable '{id}' occurred more than once\"\n  modify fun s => { s with vars := s.vars.push idStx, found := s.found.insert id }\n  return idStx", "start": [104, 1], "end": [113, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.samePatternsVariables", "code": "private def samePatternsVariables (startingAt : Nat) (s\u2081 s\u2082 : State) : Bool :=\n  if h : s\u2081.vars.size = s\u2082.vars.size then\n    Array.isEqvAux s\u2081.vars s\u2082.vars h (.==.) startingAt\n  else\n    false", "start": [115, 1], "end": [119, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.collect", "code": "partial def collect (stx : Syntax) : M Syntax := withRef stx <| withFreshMacroScope do\n  let k := stx.getKind\n  if k == identKind then\n    processId stx\n  else if k == ``Lean.Parser.Term.app then\n    processCtorApp stx\n  else if k == ``Lean.Parser.Term.anonymousCtor then\n    let elems \u2190 stx[1].getArgs.mapSepElemsM collect\n    return stx.setArg 1 <| mkNullNode elems\n  else if k == ``Lean.Parser.Term.dotIdent then\n    return stx\n  else if k == ``Lean.Parser.Term.hole then\n    `(.( $stx ))\n  else if k == ``Lean.Parser.Term.syntheticHole then\n    `(.( $stx ))\n  else if k == ``Lean.Parser.Term.typeAscription then\n    let t := stx[1]\n    let t \u2190 collect t\n    return stx.setArg 1 t\n  else if k == ``Lean.Parser.Term.explicitUniv then\n    processCtor stx[0]\n  else if k == ``Lean.Parser.Term.namedPattern then\n    \n    let id := stx[0]\n    discard <| processVar id\n    let h \u2190 if stx[2].isNone then\n      `(h)\n    else\n      pure stx[2][0]\n    let pat := stx[3]\n    let pat \u2190 collect pat\n    discard <| processVar h\n    ``(_root_.namedPattern $id $pat $h)\n  else if k == ``Lean.Parser.Term.binop then\n    let lhs \u2190 collect stx[2]\n    let rhs \u2190 collect stx[3]\n    return stx.setArg 2 lhs |>.setArg 3 rhs\n  else if k == ``Lean.Parser.Term.unop then\n    let arg \u2190 collect stx[2]\n    return stx.setArg 2 arg\n  else if k == ``Lean.Parser.Term.inaccessible then\n    return stx\n  else if k == strLitKind then\n    return stx\n  else if k == numLitKind then\n    return stx\n  else if k == scientificLitKind then\n    return stx\n  else if k == charLitKind then\n    return stx\n  else if k == ``Lean.Parser.Term.quotedName || k == ``Lean.Parser.Term.doubleQuotedName then\n    return stx\n  else if k == choiceKind then\n    \n    let args :=\n      let args := stx.getArgs\n      if args.any (\u00b7.isOfKind ``Parser.Term.structInst) then\n        args.filter (\u00b7.isOfKind ``Parser.Term.structInst)\n      else\n        args\n    let stateSaved \u2190 get\n    let arg0 \u2190 collect args[0]!\n    let stateNew \u2190 get\n    let mut argsNew := #[arg0]\n    for arg in args[1:] do\n      set stateSaved\n      argsNew := argsNew.push (\u2190 collect arg)\n      unless samePatternsVariables stateSaved.vars.size stateNew (\u2190 get) do\n        throwError \"invalid pattern, overloaded notation is only allowed when all alternative have the same set of pattern variables\"\n    set stateNew\n    return mkNode choiceKind argsNew\n  else match stx with\n  | `({ $[$srcs?,* with]? $fields,* $[..%$ell?]? $[: $ty?]? }) =>\n    if let some srcs := srcs? then\n      throwErrorAt (mkNullNode srcs) \"invalid struct instance pattern, 'with' is not allowed in patterns\"\n    let fields \u2190 fields.getElems.mapM fun\n      | `(Parser.Term.structInstField| $lval:structInstLVal := $val) => do\n        let newVal \u2190 collect val\n        `(Parser.Term.structInstField| $lval:structInstLVal := $newVal)\n      | _ => throwInvalidPattern  `({ $[$srcs?,* with]? $fields,* $[..%$ell?]? $[: $ty?]? })\n  | _ => throwInvalidPattern\n\nwhere\n\n  processCtorApp (stx : Syntax) : M Syntax := do\n    let (f, namedArgs, args, ellipsis) \u2190 expandApp stx\n    if f.getKind == ``Parser.Term.dotIdent then\n      let namedArgsNew \u2190 namedArgs.mapM fun\n        | { ref, name, val := Arg.stx arg } => withRef ref do `(Lean.Parser.Term.namedArgument| ($(mkIdentFrom ref name) := $(\u2190 collect arg)))\n        | _ => unreachable!\n      let mut argsNew \u2190 args.mapM fun | Arg.stx arg => collect arg | _ => unreachable!\n      if ellipsis then\n        argsNew := argsNew.push (mkNode ``Parser.Term.ellipsis #[mkAtomFrom stx \"..\"])\n      return Syntax.mkApp f (namedArgsNew ++ argsNew)\n    else\n      processCtorAppCore f namedArgs args ellipsis\n\n  processCtor (stx : Syntax) : M Syntax := do\n    processCtorAppCore stx #[] #[] false\n\n  \n  processId (stx : Syntax) : M Syntax := do\n    match (\u2190 resolveId? stx \"pattern\") with\n    | none   => processVar stx\n    | some f => match f with\n      | Expr.const fName _ =>\n        match (\u2190 getEnv).find? fName with\n        | some (ConstantInfo.ctorInfo _) => processCtor stx\n        | some _ =>\n          if hasMatchPatternAttribute (\u2190 getEnv) fName then\n            processCtor stx\n          else\n            processVar stx\n        | none => throwCtorExpected\n      | _ => processVar stx\n\n  pushNewArg (accessible : Bool) (ctx : Context) (arg : Arg) : M Context := do\n    match arg with\n    | Arg.stx stx =>\n      let stx \u2190 if accessible then collect stx else pure stx\n      return { ctx with newArgs := ctx.newArgs.push stx }\n    | _ => unreachable!\n\n  processExplicitArg (accessible : Bool) (ctx : Context) : M Context := do\n    match ctx.args with\n    | [] =>\n      if ctx.ellipsis then\n        pushNewArg accessible ctx (Arg.stx (\u2190 `(_)))\n      else\n        throwError \"explicit parameter is missing, unused named arguments {ctx.namedArgs.map fun narg => narg.name}\"\n    | arg::args =>\n      pushNewArg accessible { ctx with args := args } arg\n\n  processImplicitArg (accessible : Bool) (ctx : Context) : M Context := do\n    if ctx.explicit then\n      processExplicitArg accessible ctx\n    else\n      pushNewArg accessible ctx (Arg.stx (\u2190 `(_)))\n\n  processCtorAppContext (ctx : Context) : M Syntax := do\n    if isDone ctx then\n      finalize ctx\n    else\n      let accessible := isNextArgAccessible ctx\n      let (d, ctx)   := getNextParam ctx\n      match ctx.namedArgs.findIdx? fun namedArg => namedArg.name == d.1 with\n      | some idx =>\n        let arg := ctx.namedArgs[idx]!\n        let ctx := { ctx with namedArgs := ctx.namedArgs.eraseIdx idx }\n        let ctx \u2190 pushNewArg accessible ctx arg.val\n        processCtorAppContext ctx\n      | none =>\n        let ctx \u2190 match d.2 with\n          | BinderInfo.implicit       => processImplicitArg accessible ctx\n          | BinderInfo.strictImplicit => processImplicitArg accessible ctx\n          | BinderInfo.instImplicit   => processImplicitArg accessible ctx\n          | _                         => processExplicitArg accessible ctx\n        processCtorAppContext ctx\n\n  processCtorAppCore (f : Syntax) (namedArgs : Array NamedArg) (args : Array Arg) (ellipsis : Bool) : M Syntax := do\n    let args := args.toList\n    let (fId, explicit) \u2190 match f with\n      | `($fId:ident)  => pure (fId, false)\n      | `(@$fId:ident) => pure (fId, true)\n      | _              => throwError \"identifier expected\"\n    let some (Expr.const fName _) \u2190 resolveId? fId \"pattern\" (withInfo := true) | throwCtorExpected\n    let fInfo \u2190 getConstInfo fName\n    let paramDecls \u2190 forallTelescopeReducing fInfo.type fun xs _ => xs.mapM fun x => do\n      let d \u2190 getFVarLocalDecl x\n      return (d.userName, d.binderInfo)\n    match fInfo with\n    | ConstantInfo.ctorInfo val =>\n      processCtorAppContext\n        { funId := fId, explicit := explicit, ctorVal? := val, paramDecls := paramDecls, namedArgs := namedArgs, args := args, ellipsis := ellipsis }\n    | _ =>\n      if hasMatchPatternAttribute (\u2190 getEnv) fName then\n        processCtorAppContext\n          { funId := fId, explicit := explicit, ctorVal? := none, paramDecls := paramDecls, namedArgs := namedArgs, args := args, ellipsis := ellipsis }\n      else\n        throwCtorExpected", "start": [122, 1], "end": [311, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.CollectPatternVars.main", "code": "def main (alt : MatchAltView) : M MatchAltView := do\n  let patterns \u2190 alt.patterns.mapM fun p => do\n    trace[Elab.match] \"collecting variables at pattern: {p}\"\n    collect p\n  return { alt with patterns := patterns }", "start": [313, 1], "end": [317, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.collectPatternVars", "code": "def collectPatternVars (alt : MatchAltView) : TermElabM (Array PatternVar \u00d7 MatchAltView) := do\n  let (alt, s) \u2190 (CollectPatternVars.main alt).run {}\n  return (s.vars, alt)", "start": [321, 1], "end": [327, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getPatternVars", "code": "def getPatternVars (patternStx : Syntax) : TermElabM (Array PatternVar) := do\n  let patternStx \u2190 liftMacroM <| expandMacros patternStx\n  let (_, s) \u2190 (CollectPatternVars.collect patternStx).run {}\n  return s.vars", "start": [329, 1], "end": [336, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getPatternsVars", "code": "def getPatternsVars (patterns : Array Syntax) : TermElabM (Array PatternVar) := do\n  let collect : CollectPatternVars.M Unit := do\n    for pattern in patterns do\n      discard <| CollectPatternVars.collect (\u2190 liftMacroM <| expandMacros pattern)\n  let (_, s) \u2190 collect.run {}\n  return s.vars", "start": [338, 1], "end": [347, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getPatternVarNames", "code": "def getPatternVarNames (pvars : Array PatternVar) : Array Name :=\n  pvars.map fun x => x.getId", "start": [349, 1], "end": [350, 29], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/ForEachExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Util/MonadCache.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.visitLambda", "code": "def visitLambda (f : Expr \u2192 m Unit) (e : Expr) : m Unit := visit #[] e\n  where visit (fvars : Array Expr) : Expr \u2192 m Unit\n    | Expr.lam n d b c => do\n      let d := d.instantiateRev fvars\n      f d\n      withLocalDecl n c d fun x =>\n        visit (fvars.push x) b\n    | e => do\n      f <| e.instantiateRev fvars", "start": [14, 1], "end": [23, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.visitForall", "code": "def visitForall (f : Expr \u2192 m Unit) (e : Expr) : m Unit := visit #[] e\n  where visit (fvars : Array Expr) : Expr \u2192 m Unit\n    | Expr.forallE n d b c => do\n      let d := d.instantiateRev fvars\n      f d\n      withLocalDecl n c d fun x =>\n        visit (fvars.push x) b\n    | e => do\n      f <| e.instantiateRev fvars", "start": [25, 1], "end": [34, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.visitLet", "code": "def visitLet (f : Expr \u2192 m Unit) (e : Expr) : m Unit := visit #[] e\n  where visit (fvars : Array Expr) : Expr \u2192 m Unit\n    | Expr.letE n d v b _ => do\n      let d := d.instantiateRev fvars\n      let v := v.instantiateRev fvars\n      f d\n      f v\n      withLetDecl n d v fun x =>\n        visit (fvars.push x) b\n    | e => do\n      f <| e.instantiateRev fvars", "start": [36, 1], "end": [47, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forEachExpr'", "code": "partial def forEachExpr'\n  (input : Expr)\n  (fn : Expr \u2192 m Bool)\n  : m Unit := do\n  let _ : STWorld IO.RealWorld m := \u27e8\u27e9\n  let _ : MonadLiftT (ST IO.RealWorld) m := { monadLift := fun x => liftM (m := MetaM) (liftM (m := ST IO.RealWorld) x) }\n  let rec visit (e : Expr) : MonadCacheT Expr Unit m Unit :=\n    checkCache e fun _ => do\n      if (\u2190 liftM (fn e)) then\n        match e with\n        | .forallE ..   => visitForall visit e\n        | .lam ..       => visitLambda visit e\n        | .letE ..      => visitLet visit e\n        | .app f a      => visit f; visit a\n        | .mdata _ b    => visit b\n        | .proj _ _ b   => visit b\n        | _             => return ()\n  visit input |>.run", "start": [49, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.forEachExpr", "code": "def forEachExpr (e : Expr) (f : Expr \u2192 m Unit) : m Unit :=\n  forEachExpr' e fun e => do\n    f e\n    return true", "start": [71, 1], "end": [75, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.shouldInferBinderName", "code": "private def shouldInferBinderName (x : Expr) : m Bool := do\n  match x with\n  | .mvar mvarId => return (\u2190 mvarId.getDecl).userName.isAnonymous\n  | _ => return false", "start": [77, 1], "end": [81, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.setMVarUserNamesAt", "code": "def setMVarUserNamesAt (e : Expr) (isTarget : Array Expr) : MetaM (Array MVarId) := do\n  let toReset \u2190 IO.mkRef #[]\n  forEachExpr (\u2190 instantiateMVars e) fun e => do\n    if e.isApp then\n      let args := e.getAppArgs\n      for i in [:args.size] do\n        let arg := args[i]!\n        if arg.isMVar && isTarget.contains arg then\n          let mvarId := arg.mvarId!\n          if (\u2190 mvarId.getDecl).userName.isAnonymous then\n            forallBoundedTelescope (\u2190 inferType e.getAppFn) (some (i+1)) fun xs _ => do\n              if i < xs.size then\n                let mvarId := arg.mvarId!\n                let userName \u2190 mkFreshUserName (\u2190 getFVarLocalDecl xs[i]!).userName\n                toReset.modify (\u00b7.push mvarId)\n                modifyMCtx fun mctx => mctx.setMVarUserNameTemporarily mvarId userName\n  toReset.get", "start": [83, 1], "end": [106, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.resetMVarUserNames", "code": "def resetMVarUserNames (toReset : Array MVarId) : MetaM Unit := do\n  for mvarId in toReset do\n    modifyMCtx fun mctx => mctx.setMVarUserNameTemporarily mvarId Name.anonymous", "start": [108, 1], "end": [114, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkForallFVars'", "code": "def mkForallFVars' (xs : Array Expr) (type : Expr) : MetaM Expr := do\n  if (\u2190 xs.anyM shouldInferBinderName) then\n    let setMVarsAt (e : Expr) : StateRefT (Array MVarId) MetaM Unit := do\n      let mvarIds \u2190 setMVarUserNamesAt e xs\n      modify (\u00b7 ++ mvarIds)\n    let go : StateRefT (Array MVarId) MetaM Expr := do\n      try\n        for x in xs do\n          setMVarsAt (\u2190 inferType x)\n        setMVarsAt type\n        mkForallFVars xs type\n      finally\n        resetMVarUserNames (\u2190 get)\n    go |>.run' #[]\n  else\n    mkForallFVars xs type", "start": [116, 1], "end": [138, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/Match.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/GeneralizeTelescope.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Lean/Meta/Closure.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Contradiction.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean"], "premises": [{"full_name": "Lean.Meta.Match.checkNumPatterns", "code": "private def checkNumPatterns (numDiscrs : Nat) (lhss : List AltLHS) : MetaM Unit := do\n  if lhss.any fun lhs => lhs.patterns.length != numDiscrs then\n    throwError \"incorrect number of patterns\"", "start": [15, 1], "end": [18, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.withEqs", "code": "private partial def withEqs (lhs rhs : Array Expr) (discrInfos : Array DiscrInfo) (k : Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  go 0 #[]\nwhere\n  go (i : Nat) (hs : Array Expr) : MetaM \u03b1 := do\n    if i < lhs.size then\n      if let some hName := discrInfos[i]!.hName? then\n        withLocalDeclD hName (\u2190 mkEqHEq lhs[i]! rhs[i]!) fun h =>\n          go (i+1) (hs.push h)\n      else\n        go (i+1) hs\n    else\n      k hs", "start": [20, 1], "end": [35, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.withAlts", "code": "private def withAlts {\u03b1} (motive : Expr) (discrs : Array Expr) (discrInfos : Array DiscrInfo) (lhss : List AltLHS) (k : List Alt \u2192 Array (Expr \u00d7 Nat) \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  loop lhss [] #[]\nwhere\n  mkMinorType (xs : Array Expr) (lhs : AltLHS) : MetaM Expr :=\n    withExistingLocalDecls lhs.fvarDecls do\n      let args \u2190 lhs.patterns.toArray.mapM (Pattern.toExpr \u00b7 (annotate := true))\n      let minorType := mkAppN motive args\n      withEqs discrs args discrInfos fun eqs => do\n        mkForallFVars (xs ++ eqs) minorType\n\n  loop (lhss : List AltLHS) (alts : List Alt) (minors : Array (Expr \u00d7 Nat)) : MetaM \u03b1 := do\n    match lhss with\n    | [] => k alts.reverse minors\n    | lhs::lhss =>\n      let xs := lhs.fvarDecls.toArray.map LocalDecl.toExpr\n      let minorType \u2190 mkMinorType xs lhs\n      let hasParams := !xs.isEmpty || discrInfos.any fun info => info.hName?.isSome\n      let (minorType, minorNumParams) := if hasParams then (minorType, xs.size) else (mkSimpleThunkType minorType, 1)\n      let idx       := alts.length\n      let minorName := (`h).appendIndexAfter (idx+1)\n      trace[Meta.Match.debug] \"minor premise {minorName} : {minorType}\"\n      withLocalDeclD minorName minorType fun minor => do\n        let rhs    := if hasParams then mkAppN minor xs else mkApp minor (mkConst `Unit.unit)\n        let minors := minors.push (minor, minorNumParams)\n        let fvarDecls \u2190 lhs.fvarDecls.mapM instantiateLocalDeclMVars\n        let alts   := { ref := lhs.ref, idx := idx, rhs := rhs, fvarDecls := fvarDecls, patterns := lhs.patterns, cnstrs := [] } :: alts\n        loop lhss alts minors", "start": [37, 1], "end": [64, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.State", "code": "structure State where\n  used            : HashSet Nat := {} counterExamples : List (List Example) := []", "start": [66, 1], "end": [68, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isDone", "code": "private def isDone (p : Problem) : Bool :=\n  p.vars.isEmpty", "start": [70, 1], "end": [72, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isNextVar", "code": "private def isNextVar (p : Problem) : Bool :=\n  match p.vars with\n  | .fvar _ :: _ => true\n  | _            => false", "start": [74, 1], "end": [78, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.hasAsPattern", "code": "private def hasAsPattern (p : Problem) : Bool :=\n  p.alts.any fun alt => match alt.patterns with\n    | .as .. :: _ => true\n    | _           => false", "start": [80, 1], "end": [83, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.hasCtorPattern", "code": "private def hasCtorPattern (p : Problem) : Bool :=\n  p.alts.any fun alt => match alt.patterns with\n    | .ctor .. :: _ => true\n    | _             => false", "start": [85, 1], "end": [88, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.hasValPattern", "code": "private def hasValPattern (p : Problem) : Bool :=\n  p.alts.any fun alt => match alt.patterns with\n    | .val _ :: _ => true\n    | _           => false", "start": [90, 1], "end": [93, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.hasNatValPattern", "code": "private def hasNatValPattern (p : Problem) : Bool :=\n  p.alts.any fun alt => match alt.patterns with\n    | .val v :: _ => v.isNatLit\n    | _           => false", "start": [95, 1], "end": [98, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.hasVarPattern", "code": "private def hasVarPattern (p : Problem) : Bool :=\n  p.alts.any fun alt => match alt.patterns with\n    | .var _ :: _ => true\n    | _           => false", "start": [100, 1], "end": [103, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.hasArrayLitPattern", "code": "private def hasArrayLitPattern (p : Problem) : Bool :=\n  p.alts.any fun alt => match alt.patterns with\n    | .arrayLit .. :: _ => true\n    | _                 => false", "start": [105, 1], "end": [108, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isVariableTransition", "code": "private def isVariableTransition (p : Problem) : Bool :=\n  p.alts.all fun alt => match alt.patterns with\n    | .inaccessible _ :: _ => true\n    | .var _ :: _          => true\n    | _                    => false", "start": [110, 1], "end": [114, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isConstructorTransition", "code": "private def isConstructorTransition (p : Problem) : Bool :=\n  (hasCtorPattern p || p.alts.isEmpty)\n  && p.alts.all fun alt => match alt.patterns with\n     | .ctor .. :: _        => true\n     | .var _ :: _          => true\n     | .inaccessible _ :: _ => true\n     | _                    => false", "start": [116, 1], "end": [122, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isValueTransition", "code": "private def isValueTransition (p : Problem) : Bool :=\n  hasVarPattern p && hasValPattern p\n  && p.alts.all fun alt => match alt.patterns with\n     | .val _ :: _ => true\n     | .var _ :: _ => true\n     | _           => false", "start": [124, 1], "end": [129, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isArrayLitTransition", "code": "private def isArrayLitTransition (p : Problem) : Bool :=\n  hasArrayLitPattern p && hasVarPattern p\n  && p.alts.all fun alt => match alt.patterns with\n     | .arrayLit .. :: _ => true\n     | .var _ :: _       => true\n     | _                 => false", "start": [131, 1], "end": [136, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isNatValueTransition", "code": "private def isNatValueTransition (p : Problem) : Bool :=\n  hasNatValPattern p\n  && (!isNextVar p ||\n      p.alts.any fun alt => match alt.patterns with\n      | .ctor .. :: _        => true\n      | .inaccessible _ :: _ => true\n      | _                    => false)", "start": [138, 1], "end": [144, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.processSkipInaccessible", "code": "private def processSkipInaccessible (p : Problem) : Problem := Id.run do\n  let x :: xs := p.vars | unreachable!\n  let alts := p.alts.map fun alt => Id.run do\n    let .inaccessible e :: ps := alt.patterns | unreachable!\n    { alt with patterns := ps, cnstrs := (x, e) :: alt.cnstrs }\n  { p with alts := alts, vars := xs }", "start": [146, 1], "end": [151, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.reorientCnstrs", "code": "private def reorientCnstrs (alt : Alt) : Alt :=\n  let cnstrs := alt.cnstrs.map fun (lhs, rhs) =>\n    if rhs.isFVar && alt.isLocalDecl rhs.fvarId! then\n      (rhs, lhs)\n    else if !lhs.isFVar && rhs.isFVar then\n      (rhs, lhs)\n    else\n      (lhs, rhs)\n  { alt with cnstrs }", "start": [153, 1], "end": [167, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.filterTrivialCnstrs", "code": "private def filterTrivialCnstrs (alt : Alt) : MetaM Alt := do\n   let cnstrs \u2190 withExistingLocalDecls alt.fvarDecls do\n     alt.cnstrs.filterM fun (lhs, rhs) => do\n       if (\u2190 isDefEqGuarded lhs rhs) then\n         return false\n       else if lhs.isFVar then\n         return false\n       else\n         return true\n   return { alt with cnstrs }", "start": [169, 1], "end": [182, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.solveSomeLocalFVarIdCnstr?", "code": "private def solveSomeLocalFVarIdCnstr? (alt : Alt) : MetaM (Option Alt) :=\n  withExistingLocalDecls alt.fvarDecls do\n    let (some (fvarId, val), cnstrs) \u2190 go alt.cnstrs | return none\n    trace[Meta.Match.match] \"found cnstr to solve {mkFVar fvarId} \u21a6 {val}\"\n    return some <| { alt with cnstrs }.replaceFVarId fvarId val\nwhere\n  go (cnstrs : List (Expr \u00d7 Expr)) := do\n    match cnstrs with\n    | [] => return (none, [])\n    | (lhs, rhs) :: cnstrs =>\n      if lhs.isFVar && alt.isLocalDecl lhs.fvarId! then\n        if !(\u2190 dependsOn rhs lhs.fvarId!) && (\u2190 isDefEqGuarded (\u2190 inferType lhs) (\u2190 inferType rhs)) then\n          return (some (lhs.fvarId!, rhs), cnstrs)\n      let (p, cnstrs) \u2190 go cnstrs\n      return (p, (lhs, rhs) :: cnstrs)", "start": [184, 1], "end": [204, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.solveCnstrs", "code": "private partial def solveCnstrs (mvarId : MVarId) (alt : Alt) : StateRefT State MetaM Bool := do\n  go (reorientCnstrs alt)\nwhere\n  go (alt : Alt) : StateRefT State MetaM Bool := do\n    match (\u2190 solveSomeLocalFVarIdCnstr? alt) with\n    | some alt => go alt\n    | none =>\n      let alt \u2190 filterTrivialCnstrs alt\n      if alt.cnstrs.isEmpty then\n        let eType \u2190 inferType alt.rhs\n        let targetType \u2190 mvarId.getType\n        unless (\u2190 isDefEqGuarded targetType eType) do\n          trace[Meta.Match.match] \"assignGoalOf failed {eType} =?= {targetType}\"\n          throwError \"dependent elimination failed, type mismatch when solving alternative with type{indentExpr eType}\\nbut expected{indentExpr targetType}\"\n        mvarId.assign alt.rhs\n        modify fun s => { s with used := s.used.insert alt.idx }\n        return true\n      else\n        trace[Meta.Match.match] \"alt has unsolved cnstrs:\\n{\u2190 alt.toMessageData}\"\n        return false", "start": [206, 1], "end": [229, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.processLeaf", "code": "private def processLeaf (p : Problem) : StateRefT State MetaM Unit :=\n  p.mvarId.withContext do\n    trace[Meta.Match.match] \"local context at processLeaf:\\n{(\u2190 mkFreshTypeMVar).mvarId!}\"\n    go p.alts\nwhere\n  go (alts : List Alt) : StateRefT State MetaM Unit := do\n    match alts with\n    | [] =>\n      \n      unless (\u2190 p.mvarId.contradictionCore {}) do\n        trace[Meta.Match.match] \"missing alternative\"\n        p.mvarId.admit\n        modify fun s => { s with counterExamples := p.examples :: s.counterExamples }\n    | alt :: alts =>\n      unless (\u2190 solveCnstrs p.mvarId alt) do\n        go alts", "start": [231, 1], "end": [249, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.processAsPattern", "code": "private def processAsPattern (p : Problem) : MetaM Problem := withGoalOf p do\n  let x :: _ := p.vars | unreachable!\n  let alts \u2190 p.alts.mapM fun alt => do\n    match alt.patterns with\n    | .as fvarId p h :: ps =>\n      \n      let r \u2190 mkEqRefl x\n      return { alt with patterns := p :: ps }.replaceFVarId fvarId x |>.replaceFVarId h r\n    | _ => return alt\n  return { p with alts := alts }", "start": [251, 1], "end": [283, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.processVariable", "code": "private def processVariable (p : Problem) : MetaM Problem := withGoalOf p do\n  let x :: xs := p.vars | unreachable!\n  let alts \u2190 p.alts.mapM fun alt => do\n    match alt.patterns with\n    | .inaccessible e :: ps => return { alt with patterns := ps, cnstrs := (x, e) :: alt.cnstrs }\n    | .var fvarId :: ps     =>\n      withExistingLocalDecls alt.fvarDecls do\n        if (\u2190 isDefEqGuarded (\u2190 fvarId.getType) (\u2190 inferType x)) then\n          return { alt with patterns := ps }.replaceFVarId fvarId x\n        else\n          return { alt with patterns := ps, cnstrs := (mkFVar fvarId, x) :: alt.cnstrs }\n    | _  => unreachable!\n  return { p with alts := alts, vars := xs }", "start": [285, 1], "end": [297, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.inLocalDecls", "code": "private def inLocalDecls (localDecls : List LocalDecl) (fvarId : FVarId) : Bool :=\n  localDecls.any fun d => d.fvarId == fvarId", "start": [328, 1], "end": [329, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.expandVarIntoCtor?", "code": "private def expandVarIntoCtor? (alt : Alt) (fvarId : FVarId) (ctorName : Name) : MetaM (Option Alt) :=\n  withExistingLocalDecls alt.fvarDecls do\n    trace[Meta.Match.unify] \"expandVarIntoCtor? fvarId: {mkFVar fvarId}, ctorName: {ctorName}, alt:\\n{\u2190 alt.toMessageData}\"\n    let expectedType \u2190 inferType (mkFVar fvarId)\n    let expectedType \u2190 whnfD expectedType\n    let (ctorLevels, ctorParams) \u2190 getInductiveUniverseAndParams expectedType\n    let ctor := mkAppN (mkConst ctorName ctorLevels) ctorParams\n    let ctorType \u2190 inferType ctor\n    forallTelescopeReducing ctorType fun ctorFields resultType => do\n      let ctor := mkAppN ctor ctorFields\n      let alt  := alt.replaceFVarId fvarId ctor\n      let ctorFieldDecls \u2190 ctorFields.mapM fun ctorField => ctorField.fvarId!.getDecl\n      let newAltDecls := ctorFieldDecls.toList ++ alt.fvarDecls\n      let mut cnstrs := alt.cnstrs\n      unless (\u2190 isDefEqGuarded resultType expectedType) do\n         cnstrs := (resultType, expectedType) :: cnstrs\n      trace[Meta.Match.unify] \"expandVarIntoCtor? {mkFVar fvarId} : {expectedType}, ctor: {ctor}\"\n      let ctorFieldPatterns := ctorFieldDecls.toList.map fun decl => Pattern.var decl.fvarId\n      return some { alt with fvarDecls := newAltDecls, patterns := ctorFieldPatterns ++ alt.patterns, cnstrs }", "start": [331, 1], "end": [349, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.getInductiveVal?", "code": "private def getInductiveVal? (x : Expr) : MetaM (Option InductiveVal) := do\n  let xType \u2190 inferType x\n  let xType \u2190 whnfD xType\n  match xType.getAppFn with\n  | Expr.const constName _ =>\n    let cinfo \u2190 getConstInfo constName\n    match cinfo with\n    | ConstantInfo.inductInfo val => return some val\n    | _ => return none\n  | _ => return none", "start": [351, 1], "end": [360, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.hasRecursiveType", "code": "private def hasRecursiveType (x : Expr) : MetaM Bool := do\n  match (\u2190 getInductiveVal? x) with\n  | some val => return val.isRec\n  | _        => return false", "start": [362, 1], "end": [365, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.processInaccessibleAsCtor", "code": "def processInaccessibleAsCtor (alt : Alt) (ctorName : Name) : MetaM (Option Alt) := do\n  let env \u2190 getEnv\n  match alt.patterns with\n  | p@(.inaccessible e) :: ps =>\n    trace[Meta.Match.match] \"inaccessible in ctor step {e}\"\n    withExistingLocalDecls alt.fvarDecls do\n      let e \u2190 whnfD e\n      match e.constructorApp? env with\n      | some (ctorVal, ctorArgs) =>\n        if ctorVal.name == ctorName then\n          let fields := ctorArgs.extract ctorVal.numParams ctorArgs.size\n          let fields := fields.toList.map .inaccessible\n          return some { alt with patterns := fields ++ ps }\n        else\n          return none\n      | _ => throwErrorAt alt.ref \"dependent match elimination failed, inaccessible pattern found{indentD p.toMessageData}\\nconstructor expected\"\n  | _ => unreachable!", "start": [367, 1], "end": [390, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.hasNonTrivialExample", "code": "private def hasNonTrivialExample (p : Problem) : Bool :=\n  p.examples.any fun | Example.underscore => false | _ => true", "start": [392, 1], "end": [393, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.throwCasesException", "code": "private def throwCasesException (p : Problem) (ex : Exception) : MetaM \u03b1 := do\n  match ex with\n  | .error ref msg =>\n    let exampleMsg :=\n      if hasNonTrivialExample p then m!\" after processing{indentD <| examplesToMessageData p.examples}\" else \"\"\n    throw <| Exception.error ref <| m!\"{msg}{exampleMsg}\\n\" ++\n              \"the dependent pattern matcher can solve the following kinds of equations\\n\" ++\n              \"- <var> = <term> and <term> = <var>\\n\" ++\n              \"- <term> = <term> where the terms are definitionally equal\\n\" ++\n              \"- <constructor> = <constructor>, examples: List.cons x xs = List.cons y ys, and List.cons x xs = List.nil\"\n  | _ => throw ex", "start": [395, 1], "end": [405, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.processConstructor", "code": "private def processConstructor (p : Problem) : MetaM (Array Problem) := do\n  trace[Meta.Match.match] \"constructor step\"\n  let x :: xs := p.vars | unreachable!\n  let subgoals? \u2190 commitWhenSome? do\n     let subgoals \u2190\n       try\n         p.mvarId.cases x.fvarId!\n       catch ex =>\n         if p.alts.isEmpty then\n           \n           return none\n         else\n           throwCasesException p ex\n     if subgoals.isEmpty then\n       \n       return some #[]\n     else if !p.alts.isEmpty then\n       return some subgoals\n     else do\n       let isRec \u2190 withGoalOf p <| hasRecursiveType x\n        \n       if isRec then\n         return none\n       else\n         return some subgoals\n  let some subgoals := subgoals? | return #[{ p with vars := xs }]\n  subgoals.mapM fun subgoal => subgoal.mvarId.withContext do\n    let subst    := subgoal.subst\n    let fields   := subgoal.fields.toList\n    let newVars  := fields ++ xs\n    let newVars  := newVars.map fun x => x.applyFVarSubst subst\n    let subex    := Example.ctor subgoal.ctorName <| fields.map fun field => match field with\n      | .fvar fvarId => Example.var fvarId\n      | _            => Example.underscore let examples := p.examples.map <| Example.replaceFVarId x.fvarId! subex\n    let examples := examples.map <| Example.applyFVarSubst subst\n    let newAlts  := p.alts.filter fun alt => match alt.patterns with\n      | .ctor n .. :: _       => n == subgoal.ctorName\n      | .var _ :: _           => true\n      | .inaccessible _ :: _  => true\n      | _                     => false\n    let newAlts  := newAlts.map fun alt => alt.applyFVarSubst subst\n    let newAlts \u2190 newAlts.filterMapM fun alt => do\n      match alt.patterns with\n      | .ctor _ _ _ fields :: ps  => return some { alt with patterns := fields ++ ps }\n      | .var fvarId :: ps         => expandVarIntoCtor? { alt with patterns := ps } fvarId subgoal.ctorName\n      | .inaccessible _ :: _      => processInaccessibleAsCtor alt subgoal.ctorName\n      | _                         => unreachable!\n    return { mvarId := subgoal.mvarId, vars := newVars, alts := newAlts, examples := examples }", "start": [407, 1], "end": [457, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.altsAreCtorLike", "code": "private def altsAreCtorLike (p : Problem) : MetaM Bool := withGoalOf p do\n  p.alts.allM fun alt => do match alt.patterns with\n    | .ctor .. :: _ => return true\n    | .inaccessible e :: _ => return (\u2190 whnfD e).isConstructorApp (\u2190 getEnv)\n    | _ => return false", "start": [459, 1], "end": [463, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.processNonVariable", "code": "private def processNonVariable (p : Problem) : MetaM Problem := withGoalOf p do\n  let x :: xs := p.vars | unreachable!\n  if let some (ctorVal, xArgs) := (\u2190 whnfD x).constructorApp? (\u2190 getEnv) then\n    if (\u2190 altsAreCtorLike p) then\n      let alts \u2190 p.alts.filterMapM fun alt => do\n        match alt.patterns with\n        | .ctor ctorName _ _ fields :: ps   =>\n          if ctorName != ctorVal.name then\n            return none\n          else\n            return some { alt with patterns := fields ++ ps }\n        | .inaccessible _ :: _ => processInaccessibleAsCtor alt ctorVal.name\n        | _ => unreachable!\n      let xFields := xArgs.extract ctorVal.numParams xArgs.size\n      return { p with alts := alts, vars := xFields.toList ++ xs }\n  let alts \u2190 p.alts.mapM fun alt => do\n    match alt.patterns with\n    | p :: ps => return { alt with patterns := ps, cnstrs := (x, \u2190 p.toExpr) :: alt.cnstrs }\n    | _      => unreachable!\n  return { p with alts := alts, vars := xs }", "start": [465, 1], "end": [484, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.collectValues", "code": "private def collectValues (p : Problem) : Array Expr :=\n  p.alts.foldl (init := #[]) fun values alt =>\n    match alt.patterns with\n    | .val v :: _ => if values.contains v then values else values.push v\n    | _           => values", "start": [486, 1], "end": [490, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isFirstPatternVar", "code": "private def isFirstPatternVar (alt : Alt) : Bool :=\n  match alt.patterns with\n  | .var _ :: _ => true\n  | _           => false", "start": [492, 1], "end": [495, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.processValue", "code": "private def processValue (p : Problem) : MetaM (Array Problem) := do\n  trace[Meta.Match.match] \"value step\"\n  let x :: xs := p.vars | unreachable!\n  let values := collectValues p\n  let subgoals \u2190 caseValues p.mvarId x.fvarId! values (substNewEqs := true)\n  subgoals.mapIdxM fun i subgoal => do\n    trace[Meta.Match.match] \"processValue subgoal\\n{MessageData.ofGoal subgoal.mvarId}\"\n    if h : i.val < values.size then\n      let value := values.get \u27e8i, h\u27e9\n      let subst := subgoal.subst\n      trace[Meta.Match.match] \"processValue subst: {subst.map.toList.map fun p => mkFVar p.1}, {subst.map.toList.map fun p => p.2}\"\n        let examples := p.examples.map <| Example.replaceFVarId x.fvarId! (Example.val value)\n      let examples := examples.map <| Example.applyFVarSubst subst\n      let newAlts  := p.alts.filter fun alt => match alt.patterns with\n        | .val v :: _ => v == value\n        | .var _ :: _ => true\n        | _           => false\n      let newAlts := newAlts.map fun alt => alt.applyFVarSubst subst\n      let newAlts := newAlts.map fun alt => match alt.patterns with\n        | .val _ :: ps      => { alt with patterns := ps }\n        | .var fvarId :: ps =>\n          let alt := { alt with patterns := ps }\n          alt.replaceFVarId fvarId value\n        | _  => unreachable!\n      let newVars := xs.map fun x => x.applyFVarSubst subst\n      return { mvarId := subgoal.mvarId, vars := newVars, alts := newAlts, examples := examples }\n    else\n      let newAlts := p.alts.filter isFirstPatternVar\n      return { p with mvarId := subgoal.mvarId, alts := newAlts, vars := x::xs }", "start": [497, 1], "end": [527, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.collectArraySizes", "code": "private def collectArraySizes (p : Problem) : Array Nat :=\n  p.alts.foldl (init := #[]) fun sizes alt =>\n    match alt.patterns with\n    | .arrayLit _ ps :: _ => let sz := ps.length; if sizes.contains sz then sizes else sizes.push sz\n    | _                   => sizes", "start": [529, 1], "end": [533, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.expandVarIntoArrayLit", "code": "private def expandVarIntoArrayLit (alt : Alt) (fvarId : FVarId) (arrayElemType : Expr) (arraySize : Nat) : MetaM Alt :=\n  withExistingLocalDecls alt.fvarDecls do\n    let fvarDecl \u2190 fvarId.getDecl\n    let varNamePrefix := fvarDecl.userName\n    let rec loop (n : Nat) (newVars : Array Expr) := do\n      match n with\n      | n+1 =>\n        withLocalDeclD (varNamePrefix.appendIndexAfter (n+1)) arrayElemType fun x =>\n          loop n (newVars.push x)\n      | 0 =>\n        let arrayLit \u2190 mkArrayLit arrayElemType newVars.toList\n        let alt := alt.replaceFVarId fvarId arrayLit\n        let newDecls \u2190 newVars.toList.mapM fun newVar => newVar.fvarId!.getDecl\n        let newPatterns := newVars.toList.map fun newVar => .var newVar.fvarId!\n        return { alt with fvarDecls := newDecls ++ alt.fvarDecls, patterns := newPatterns ++ alt.patterns }\n    loop arraySize #[]", "start": [535, 1], "end": [550, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.processArrayLit", "code": "private def processArrayLit (p : Problem) : MetaM (Array Problem) := do\n  trace[Meta.Match.match] \"array literal step\"\n  let x :: xs := p.vars | unreachable!\n  let sizes := collectArraySizes p\n  let subgoals \u2190 caseArraySizes p.mvarId x.fvarId! sizes\n  subgoals.mapIdxM fun i subgoal => do\n    if i.val < sizes.size then\n      let size     := sizes.get! i\n      let subst    := subgoal.subst\n      let elems    := subgoal.elems.toList\n      let newVars  := elems.map mkFVar ++ xs\n      let newVars  := newVars.map fun x => x.applyFVarSubst subst\n      let subex    := Example.arrayLit <| elems.map Example.var\n      let examples := p.examples.map <| Example.replaceFVarId x.fvarId! subex\n      let examples := examples.map <| Example.applyFVarSubst subst\n      let newAlts  := p.alts.filter fun alt => match alt.patterns with\n        | .arrayLit _ ps :: _ => ps.length == size\n        | .var _ :: _         => true\n        | _                          => false\n      let newAlts := newAlts.map fun alt => alt.applyFVarSubst subst\n      let newAlts \u2190 newAlts.mapM fun alt => do\n        match alt.patterns with\n        | .arrayLit _ pats :: ps => return { alt with patterns := pats ++ ps }\n        | .var fvarId :: ps      =>\n          let \u03b1 \u2190 getArrayArgType <| subst.apply x\n          expandVarIntoArrayLit { alt with patterns := ps } fvarId \u03b1 size\n        | _  => unreachable!\n      return { mvarId := subgoal.mvarId, vars := newVars, alts := newAlts, examples := examples }\n    else\n      let newAlts := p.alts.filter isFirstPatternVar\n      return { p with mvarId := subgoal.mvarId, alts := newAlts, vars := x::xs }", "start": [552, 1], "end": [583, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.expandNatValuePattern", "code": "private def expandNatValuePattern (p : Problem) : Problem :=\n  let alts := p.alts.map fun alt => match alt.patterns with\n    | .val (.lit (.natVal 0)) :: ps     => { alt with patterns := .ctor ``Nat.zero [] [] [] :: ps }\n    | .val (.lit (.natVal (n+1))) :: ps => { alt with patterns := .ctor ``Nat.succ [] [] [.val (mkRawNatLit n)] :: ps }\n    | _                                 => alt\n  { p with alts := alts }", "start": [585, 1], "end": [590, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.traceStep", "code": "private def traceStep (msg : String) : StateRefT State MetaM Unit := do\n  trace[Meta.Match.match] \"{msg} step\"", "start": [592, 1], "end": [593, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.traceState", "code": "private def traceState (p : Problem) : MetaM Unit :=\n  withGoalOf p (traceM `Meta.Match.match p.toMessageData)", "start": [595, 1], "end": [596, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.throwNonSupported", "code": "private def throwNonSupported (p : Problem) : MetaM Unit :=\n  withGoalOf p do\n    let msg \u2190 p.toMessageData\n    throwError \"failed to compile pattern matching, stuck at{indentD msg}\"", "start": [598, 1], "end": [601, 75], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.isCurrVarInductive", "code": "def isCurrVarInductive (p : Problem) : MetaM Bool := do\n  match p.vars with\n  | []   => return false\n  | x::_ => withGoalOf p do\n    let val? \u2190 getInductiveVal? x\n    return val?.isSome", "start": [603, 1], "end": [608, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.checkNextPatternTypes", "code": "private def checkNextPatternTypes (p : Problem) : MetaM Unit := do\n  match p.vars with\n  | []   => return ()\n  | x::_ => withGoalOf p do\n    for alt in p.alts do\n      withRef alt.ref do\n        match alt.patterns with\n        | []   => return ()\n        | p::_ =>\n          let e \u2190 p.toExpr\n          let xType \u2190 inferType x\n          let eType \u2190 inferType e\n          unless (\u2190 isDefEq xType eType) do\n            throwError \"pattern{indentExpr e}\\n{\u2190 mkHasTypeButIsExpectedMsg eType xType}\"", "start": [610, 1], "end": [623, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.process", "code": "private partial def process (p : Problem) : StateRefT State MetaM Unit := do\n  traceState p\n  let isInductive \u2190 isCurrVarInductive p\n  if isDone p then\n    traceStep (\"leaf\")\n    processLeaf p\n  else if hasAsPattern p then\n    traceStep (\"as-pattern\")\n    let p \u2190 processAsPattern p\n    process p\n  else if isNatValueTransition p then\n    traceStep (\"nat value to constructor\")\n    process (expandNatValuePattern p)\n  else if !isNextVar p then\n    traceStep (\"non variable\")\n    let p \u2190 processNonVariable p\n    process p\n  else if isInductive && isConstructorTransition p then\n    let ps \u2190 processConstructor p\n    ps.forM process\n  else if isVariableTransition p then\n    traceStep (\"variable\")\n    let p \u2190 processVariable p\n    process p\n  else if isValueTransition p then\n    let ps \u2190 processValue p\n    ps.forM process\n  else if isArrayLitTransition p then\n    let ps \u2190 processArrayLit p\n    ps.forM process\n  else if hasNatValPattern p then\n    traceStep (\"nat value to constructor\")\n    process (expandNatValuePattern p)\n  else\n    checkNextPatternTypes p\n    throwNonSupported p", "start": [625, 1], "end": [662, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.getUElimPos?", "code": "private def getUElimPos? (matcherLevels : List Level) (uElim : Level) : MetaM (Option Nat) :=\n  if uElim == levelZero then\n    return none\n  else match matcherLevels.toArray.indexOf? uElim with\n    | none => throwError \"dependent match elimination failed, universe level not found\"\n    | some pos => return some pos.val", "start": [664, 1], "end": [669, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.mkMatcherAuxDefinition", "code": "def mkMatcherAuxDefinition (name : Name) (type : Expr) (value : Expr) : MetaM (Expr \u00d7 Option (MatcherInfo \u2192 MetaM Unit)) := do\n  trace[Meta.Match.debug] \"{name} : {type} := {value}\"\n  let compile := bootstrap.genMatcherCode.get (\u2190 getOptions)\n  let result \u2190 Closure.mkValueTypeClosure type value (zeta := false)\n  let env \u2190 getEnv\n  let mkMatcherConst name :=\n    mkAppN (mkConst name result.levelArgs.toList) result.exprArgs\n  match (matcherExt.getState env).find? (result.value, compile) with\n  | some nameNew => return (mkMatcherConst nameNew, none)\n  | none =>\n    let decl := Declaration.defnDecl {\n      name\n      levelParams := result.levelParams.toList\n      type        := result.type\n      value       := result.value\n      hints       := ReducibilityHints.abbrev\n      safety      := if env.hasUnsafe result.type || env.hasUnsafe result.value then DefinitionSafety.unsafe else DefinitionSafety.safe\n    }\n    trace[Meta.Match.debug] \"{name} : {result.type} := {result.value}\"\n    let addMatcher : MatcherInfo \u2192 MetaM Unit := fun mi => do\n      addDecl decl\n      modifyEnv fun env => matcherExt.modifyState env fun s => s.insert (result.value, compile) name\n      addMatcherInfo name mi\n      setInlineAttribute name\n      if compile then\n        compileDecl decl\n    return (mkMatcherConst name, some addMatcher)", "start": [680, 1], "end": [708, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MkMatcherInput", "code": "structure MkMatcherInput where\n  matcherName : Name\n  matchType   : Expr\n  discrInfos  : Array DiscrInfo\n  lhss        : List AltLHS", "start": [710, 1], "end": [714, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MkMatcherInput.numDiscrs", "code": "def MkMatcherInput.numDiscrs (m : MkMatcherInput) :=\n  m.discrInfos.size", "start": [716, 1], "end": [717, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MkMatcherInput.collectFVars", "code": "def MkMatcherInput.collectFVars (m : MkMatcherInput) : StateRefT CollectFVars.State MetaM Unit := do\n  m.matchType.collectFVars\n  m.lhss.forM fun alt => alt.collectFVars", "start": [719, 1], "end": [721, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.MkMatcherInput.collectDependencies", "code": "def MkMatcherInput.collectDependencies (m : MkMatcherInput) : MetaM FVarIdSet := do\n  let (_, s) \u2190 m.collectFVars |>.run {}\n  let s \u2190 s.addDependencies\n  return s.fvarSet", "start": [723, 1], "end": [726, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.withCleanLCtxFor", "code": "def withCleanLCtxFor (m : MkMatcherInput) (k : MetaM \u03b1) : MetaM \u03b1 := do\n  let s \u2190 m.collectDependencies\n  let lctx \u2190 getLCtx\n  let lctx := lctx.foldr (init := lctx) fun localDecl lctx =>\n    if s.contains localDecl.fvarId then lctx else lctx.erase localDecl.fvarId\n  let localInstances := (\u2190 getLocalInstances).filter fun localInst => s.contains localInst.fvar.fvarId!\n  withLCtx lctx localInstances k", "start": [728, 1], "end": [742, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.mkMatcher", "code": "def mkMatcher (input : MkMatcherInput) : MetaM MatcherResult := withCleanLCtxFor input do\n  let \u27e8matcherName, matchType, discrInfos, lhss\u27e9 := input\n  let numDiscrs := discrInfos.size\n  let numEqs := getNumEqsFromDiscrInfos discrInfos\n  checkNumPatterns numDiscrs lhss\n  forallBoundedTelescope matchType numDiscrs fun discrs matchTypeBody => do\n  \n  let uElim \u2190 getLevel matchTypeBody\n  let uElimGen \u2190 if uElim == levelZero then pure levelZero else mkFreshLevelMVar\n  let mkMatcher (type val : Expr) (minors : Array (Expr \u00d7 Nat)) (s : State) : MetaM MatcherResult := do\n    trace[Meta.Match.debug] \"matcher value: {val}\\ntype: {type}\"\n    trace[Meta.Match.debug] \"minors num params: {minors.map (\u00b7.2)}\"\n    \n\n    let (matcher, addMatcher) \u2190 mkMatcherAuxDefinition matcherName type val\n    trace[Meta.Match.debug] \"matcher levels: {matcher.getAppFn.constLevels!}, uElim: {uElimGen}\"\n    let uElimPos? \u2190 getUElimPos? matcher.getAppFn.constLevels! uElimGen\n    discard <| isLevelDefEq uElimGen uElim\n    let addMatcher :=\n      match addMatcher with\n      | some addMatcher => addMatcher <|\n        { numParams := matcher.getAppNumArgs\n          altNumParams := minors.map fun minor => minor.2 + numEqs\n          discrInfos\n          numDiscrs\n          uElimPos?\n          }\n      | none => pure ()\n\n    trace[Meta.Match.debug] \"matcher: {matcher}\"\n    let unusedAltIdxs := lhss.length.fold (init := []) fun i r =>\n      if s.used.contains i then r else i::r\n    return {\n      matcher,\n      counterExamples := s.counterExamples,\n      unusedAltIdxs := unusedAltIdxs.reverse,\n      addMatcher\n    }\n\n  let motiveType \u2190 mkForallFVars discrs (mkSort uElimGen)\n  trace[Meta.Match.debug] \"motiveType: {motiveType}\"\n  withLocalDeclD `motive motiveType fun motive => do\n  if discrInfos.any fun info => info.hName?.isSome then\n    forallBoundedTelescope matchType numDiscrs fun discrs' _ => do\n    let (mvarType, isEqMask) \u2190 withEqs discrs discrs' discrInfos fun eqs => do\n      let mvarType \u2190 mkForallFVars eqs (mkAppN motive discrs')\n      let isEqMask \u2190 eqs.mapM fun eq => return (\u2190 inferType eq).isEq\n      return (mvarType, isEqMask)\n    trace[Meta.Match.debug] \"target: {mvarType}\"\n    withAlts motive discrs discrInfos lhss fun alts minors => do\n      let mvar \u2190 mkFreshExprMVar mvarType\n      trace[Meta.Match.debug] \"goal\\n{mvar.mvarId!}\"\n      let examples := discrs'.toList.map fun discr => Example.var discr.fvarId!\n      let (_, s) \u2190 (process { mvarId := mvar.mvarId!, vars := discrs'.toList, alts := alts, examples := examples }).run {}\n      let val \u2190 mkLambdaFVars discrs' mvar\n      trace[Meta.Match.debug] \"matcher\\nvalue: {val}\\ntype: {\u2190 inferType val}\"\n      let mut rfls := #[]\n      let mut isEqMaskIdx := 0\n      for discr in discrs, info in discrInfos do\n        if info.hName?.isSome then\n          if isEqMask[isEqMaskIdx]! then\n            rfls := rfls.push (\u2190 mkEqRefl discr)\n          else\n            rfls := rfls.push (\u2190 mkHEqRefl discr)\n          isEqMaskIdx := isEqMaskIdx + 1\n      let val := mkAppN (mkAppN val discrs) rfls\n      let args := #[motive] ++ discrs ++ minors.map Prod.fst\n      let val \u2190 mkLambdaFVars args val\n      let type \u2190 mkForallFVars args (mkAppN motive discrs)\n      mkMatcher type val minors s\n  else\n    let mvarType  := mkAppN motive discrs\n    trace[Meta.Match.debug] \"target: {mvarType}\"\n    withAlts motive discrs discrInfos lhss fun alts minors => do\n      let mvar \u2190 mkFreshExprMVar mvarType\n      let examples := discrs.toList.map fun discr => Example.var discr.fvarId!\n      let (_, s) \u2190 (process { mvarId := mvar.mvarId!, vars := discrs.toList, alts := alts, examples := examples }).run {}\n      let args := #[motive] ++ discrs ++ minors.map Prod.fst\n      let type \u2190 mkForallFVars args mvarType\n      let val  \u2190 mkLambdaFVars args mvar\n      mkMatcher type val minors s", "start": [744, 1], "end": [846, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.getMkMatcherInputInContext", "code": "def getMkMatcherInputInContext (matcherApp : MatcherApp) : MetaM MkMatcherInput := do\n  let matcherName := matcherApp.matcherName\n  let some matcherInfo \u2190 getMatcherInfo? matcherName | throwError \"not a matcher: {matcherName}\"\n  let matcherConst \u2190 getConstInfo matcherName\n  let matcherType \u2190 instantiateForall matcherConst.type <| matcherApp.params ++ #[matcherApp.motive]\n  let matchType \u2190 do\n    let u :=\n      if let some idx := matcherInfo.uElimPos?\n      then mkLevelParam matcherConst.levelParams.toArray[idx]!\n      else levelZero\n    forallBoundedTelescope matcherType (some matcherInfo.numDiscrs) fun discrs _ => do\n    mkForallFVars discrs (mkConst ``PUnit [u])\n\n  let matcherType \u2190 instantiateForall matcherType matcherApp.discrs\n  let lhss \u2190 forallBoundedTelescope matcherType (some matcherApp.alts.size) fun alts _ =>\n    alts.mapM fun alt => do\n    let ty \u2190 inferType alt\n    forallTelescope ty fun xs body => do\n    let xs \u2190 xs.filterM fun x => dependsOn body x.fvarId!\n    body.withApp fun _ args => do\n    let ctx \u2190 getLCtx\n    let localDecls := xs.map ctx.getFVar!\n    let patterns \u2190 args.mapM Match.toPattern\n    return {\n      ref := Syntax.missing\n      fvarDecls := localDecls.toList\n      patterns := patterns.toList : Match.AltLHS }\n\n  return { matcherName, matchType, discrInfos := matcherInfo.discrInfos, lhss := lhss.toList }", "start": [848, 1], "end": [876, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.withMkMatcherInput", "code": "def withMkMatcherInput (matcherName : Name) (k : MkMatcherInput \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  let some matcherInfo \u2190 getMatcherInfo? matcherName | throwError \"not a matcher: {matcherName}\"\n  let matcherConst \u2190 getConstInfo matcherName\n  forallBoundedTelescope matcherConst.type (some matcherInfo.arity) fun xs _ => do\n  let matcherApp \u2190 mkConstWithLevelParams matcherConst.name\n  let matcherApp := mkAppN matcherApp xs\n  let some matcherApp \u2190 matchMatcherApp? matcherApp | throwError \"not a matcher app: {matcherApp}\"\n  let mkMatcherInput \u2190 getMkMatcherInputInContext matcherApp\n  k mkMatcherInput", "start": [878, 1], "end": [887, 19], "kind": "commanddeclaration"}, {"full_name": "updateAlts", "code": "private partial def updateAlts (typeNew : Expr) (altNumParams : Array Nat) (alts : Array Expr) (i : Nat) : MetaM (Array Nat \u00d7 Array Expr) := do\n  if h : i < alts.size then\n    let alt       := alts.get \u27e8i, h\u27e9\n    let numParams := altNumParams[i]!\n    let typeNew \u2190 whnfD typeNew\n    match typeNew with\n    | Expr.forallE _ d b _ =>\n      let alt \u2190 forallBoundedTelescope d (some numParams) fun xs d => do\n        let alt \u2190 try instantiateLambda alt xs catch _ => throwError \"unexpected matcher application, insufficient number of parameters in alternative\"\n        forallBoundedTelescope d (some 1) fun x _ => do\n          let alt \u2190 mkLambdaFVars x alt mkLambdaFVars xs alt\n      updateAlts (b.instantiate1 alt) (altNumParams.set! i (numParams+1)) (alts.set \u27e8i, h\u27e9 alt) (i+1)\n    | _ => throwError \"unexpected type at MatcherApp.addArg\"\n  else\n    return (altNumParams, alts)", "start": [891, 1], "end": [907, 32], "kind": "commanddeclaration"}, {"full_name": "MatcherApp.addArg", "code": "def MatcherApp.addArg (matcherApp : MatcherApp) (e : Expr) : MetaM MatcherApp :=\n  lambdaTelescope matcherApp.motive fun motiveArgs motiveBody => do\n    unless motiveArgs.size == matcherApp.discrs.size do\n      throwError \"unexpected matcher application, motive must be lambda expression with #{matcherApp.discrs.size} arguments\"\n    let eType \u2190 inferType e\n    let eTypeAbst \u2190 matcherApp.discrs.size.foldRevM (init := eType) fun i eTypeAbst => do\n      let motiveArg := motiveArgs[i]!\n      let discr     := matcherApp.discrs[i]!\n      let eTypeAbst \u2190 kabstract eTypeAbst discr\n      return eTypeAbst.instantiate1 motiveArg\n    let motiveBody \u2190 mkArrow eTypeAbst motiveBody\n    let matcherLevels \u2190 match matcherApp.uElimPos? with\n      | none     => pure matcherApp.matcherLevels\n      | some pos =>\n        let uElim \u2190 getLevel motiveBody\n        pure <| matcherApp.matcherLevels.set! pos uElim\n    let motive \u2190 mkLambdaFVars motiveArgs motiveBody\n    let aux := mkAppN (mkConst matcherApp.matcherName matcherLevels.toList) matcherApp.params\n    let aux := mkApp aux motive\n    let aux := mkAppN aux matcherApp.discrs\n    unless (\u2190 isTypeCorrect aux) do\n      throwError \"failed to add argument to matcher application, type error when constructing the new motive\"\n    let auxType \u2190 inferType aux\n    let (altNumParams, alts) \u2190 updateAlts auxType matcherApp.altNumParams matcherApp.alts 0\n    return { matcherApp with\n      matcherLevels := matcherLevels,\n      motive        := motive,\n      alts          := alts,\n      altNumParams  := altNumParams,\n      remaining     := #[e] ++ matcherApp.remaining\n    }", "start": [909, 1], "end": [952, 6], "kind": "commanddeclaration"}, {"full_name": "MatcherApp.addArg?", "code": "def MatcherApp.addArg? (matcherApp : MatcherApp) (e : Expr) : MetaM (Option MatcherApp) :=\n  try\n    return some (\u2190 matcherApp.addArg e)\n  catch _ =>\n    return none", "start": [954, 1], "end": [959, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/GeneralizeVars.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Util/CollectFVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.mkGeneralizationForbiddenSet", "code": "partial def mkGeneralizationForbiddenSet (targets : Array Expr) (forbidden : FVarIdSet := {}) : MetaM FVarIdSet := do\n  let mut s := { fvarSet := forbidden }\n  let mut todo := #[]\n  for target in targets do\n    if target.isFVar then\n      todo := todo.push target.fvarId!\n    else\n      s := collectFVars s (\u2190 instantiateMVars (\u2190 inferType target))\n  loop todo.toList s.fvarSet\nwhere\n  visit (fvarId : FVarId) (todo : List FVarId) (s : FVarIdSet) : MetaM (List FVarId \u00d7 FVarIdSet) := do\n    let localDecl \u2190 fvarId.getDecl\n    let mut s' := collectFVars {} (\u2190 instantiateMVars localDecl.type)\n    if let some val := localDecl.value? then\n      s' := collectFVars s' (\u2190 instantiateMVars val)\n    let mut todo := todo\n    let mut s := s\n    for fvarId in s'.fvarSet do\n      unless s.contains fvarId do\n        todo := fvarId :: todo\n        s := s.insert fvarId\n    return (todo, s)\n\n  loop (todo : List FVarId) (s : FVarIdSet) : MetaM FVarIdSet := do\n    match todo with\n    | [] => return s\n    | fvarId::todo =>\n      if s.contains fvarId then\n        loop todo s\n      else\n        let (todo, s) \u2190 visit fvarId todo <| s.insert fvarId\n        loop todo s", "start": [11, 1], "end": [45, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getFVarSetToGeneralize", "code": "def getFVarSetToGeneralize (targets : Array Expr) (forbidden : FVarIdSet) (ignoreLetDecls := false) : MetaM FVarIdSet := do\n  let mut s : FVarIdSet := targets.foldl (init := {}) fun s target => if target.isFVar then s.insert target.fvarId! else s\n  let mut r : FVarIdSet := {}\n  for localDecl in (\u2190 getLCtx) do\n    unless forbidden.contains localDecl.fvarId do\n      unless localDecl.isAuxDecl || localDecl.binderInfo.isInstImplicit || (ignoreLetDecls && localDecl.isLet) do\n      if (\u2190 findLocalDeclDependsOn localDecl (s.contains \u00b7)) then\n        r := r.insert localDecl.fvarId\n        s := s.insert localDecl.fvarId\n  return r", "start": [47, 1], "end": [66, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getFVarsToGeneralize", "code": "def getFVarsToGeneralize (targets : Array Expr) (forbidden : FVarIdSet := {}) (ignoreLetDecls := false) : MetaM (Array FVarId) := do\n  let forbidden \u2190 mkGeneralizationForbiddenSet targets forbidden\n  let s \u2190 getFVarSetToGeneralize targets forbidden ignoreLetDecls\n  sortFVarIds s.toArray", "start": [68, 1], "end": [71, 24], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/Requests.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Server/FileSource.lean", "lake-packages/lean4/src/lean/Lean/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Lean/Server/FileWorker/Utils.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Lean.Server.RequestError", "code": "structure RequestError where\n  code    : JsonRpc.ErrorCode\n  message : String\n  deriving Inhabited", "start": [20, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestError.fileChanged", "code": "def fileChanged : RequestError :=\n  { code := ErrorCode.contentModified\n    message := \"File changed.\" }", "start": [28, 1], "end": [30, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestError.methodNotFound", "code": "def methodNotFound (method : String) : RequestError :=\n  { code := ErrorCode.methodNotFound\n    message := s!\"No request handler found for '{method}'\" }", "start": [32, 1], "end": [34, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestError.invalidParams", "code": "def invalidParams (message : String) : RequestError :=\n  {code := ErrorCode.invalidParams, message}", "start": [36, 1], "end": [37, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestError.internalError", "code": "def internalError (message : String) : RequestError :=\n  { code := ErrorCode.internalError, message }", "start": [39, 1], "end": [40, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestError.ofException", "code": "def ofException (e : Lean.Exception) : IO RequestError :=\n  return internalError (\u2190 e.toMessageData.toString)", "start": [42, 1], "end": [43, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestError.ofIoError", "code": "def ofIoError (e : IO.Error) : RequestError :=\n  internalError (toString e)", "start": [45, 1], "end": [46, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestError.toLspResponseError", "code": "def toLspResponseError (id : RequestID) (e : RequestError) : ResponseError Unit :=\n  { id := id\n    code := e.code\n    message := e.message }", "start": [48, 1], "end": [51, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.parseRequestParams", "code": "def parseRequestParams (paramType : Type) [FromJson paramType] (params : Json)\n    : Except RequestError paramType :=\n  fromJson? params |>.mapError fun inner =>\n    { code := JsonRpc.ErrorCode.parseError\n      message := s!\"Cannot parse request params: {params.compress}\\n{inner}\" }", "start": [55, 1], "end": [59, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestContext", "code": "structure RequestContext where\n  rpcSessions   : RBMap UInt64 (IO.Ref FileWorker.RpcSession) compare\n  srcSearchPath : SearchPath\n  doc           : FileWorker.EditableDocument\n  hLog          : IO.FS.Stream\n  hOut          : IO.FS.Stream\n  initParams    : Lsp.InitializeParams", "start": [61, 1], "end": [67, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestTask", "code": "abbrev RequestTask \u03b1 := Task (Except RequestError \u03b1)", "start": [69, 1], "end": [69, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestT", "code": "abbrev RequestT m := ReaderT RequestContext <| ExceptT RequestError m", "start": [70, 1], "end": [70, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM", "code": "abbrev RequestM := ReaderT RequestContext <| EIO RequestError", "start": [71, 1], "end": [72, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestTask.pure", "code": "abbrev RequestTask.pure (a : \u03b1) : RequestTask \u03b1 := .pure (.ok a)", "start": [74, 1], "end": [74, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.readDoc", "code": "def readDoc [Monad m] [MonadReaderOf RequestContext m] : m EditableDocument := do\n  let rc \u2190 readThe RequestContext\n  return rc.doc", "start": [92, 1], "end": [94, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.asTask", "code": "def asTask (t : RequestM \u03b1) : RequestM (RequestTask \u03b1) := do\n  let rc \u2190 readThe RequestContext\n  let t \u2190 EIO.asTask <| t.run rc\n  return t.map liftExcept", "start": [96, 1], "end": [99, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.mapTask", "code": "def mapTask (t : Task \u03b1) (f : \u03b1 \u2192 RequestM \u03b2) : RequestM (RequestTask \u03b2) := do\n  let rc \u2190 readThe RequestContext\n  let t \u2190 EIO.mapTask (f \u00b7 rc) t\n  return t.map liftExcept", "start": [101, 1], "end": [104, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.bindTask", "code": "def bindTask (t : Task \u03b1) (f : \u03b1 \u2192 RequestM (RequestTask \u03b2)) : RequestM (RequestTask \u03b2) := do\n  let rc \u2190 readThe RequestContext\n  EIO.bindTask t (f \u00b7 rc)", "start": [106, 1], "end": [108, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.waitFindSnapAux", "code": "def waitFindSnapAux (notFoundX abortedX : RequestM \u03b1) (x : Snapshot \u2192 RequestM \u03b1)\n    : Except ElabTaskError (Option Snapshot) \u2192 RequestM \u03b1\n  \n  | Except.error FileWorker.ElabTaskError.aborted => abortedX\n  | Except.error (FileWorker.ElabTaskError.ioError e) =>\n    throw (RequestError.ofIoError e)\n  | Except.ok none => notFoundX\n  | Except.ok (some snap) => x snap", "start": [110, 1], "end": [119, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.withWaitFindSnap", "code": "def withWaitFindSnap (doc : EditableDocument) (p : Snapshot \u2192 Bool)\n    (notFoundX : RequestM \u03b2)\n    (x : Snapshot \u2192 RequestM \u03b2)\n    (abortedX : RequestM \u03b2 := throwThe RequestError .fileChanged)\n    : RequestM (RequestTask \u03b2) := do\n  let findTask := doc.cmdSnaps.waitFind? p\n  mapTask findTask <| waitFindSnapAux notFoundX abortedX x", "start": [121, 1], "end": [130, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.bindWaitFindSnap", "code": "def bindWaitFindSnap (doc : EditableDocument) (p : Snapshot \u2192 Bool)\n    (notFoundX : RequestM (RequestTask \u03b2))\n    (x : Snapshot \u2192 RequestM (RequestTask \u03b2))\n    (abortedX : RequestM (RequestTask \u03b2) := throwThe RequestError .fileChanged)\n    : RequestM (RequestTask \u03b2) := do\n  let findTask := doc.cmdSnaps.waitFind? p\n  bindTask findTask <| waitFindSnapAux notFoundX abortedX x", "start": [132, 1], "end": [139, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.withWaitFindSnapAtPos", "code": "def withWaitFindSnapAtPos\n    (lspPos : Lsp.Position)\n    (f : Snapshots.Snapshot \u2192 RequestM \u03b1)\n    : RequestM (RequestTask \u03b1) := do\n  let doc \u2190 readDoc\n  let pos := doc.meta.text.lspPosToUtf8Pos lspPos\n  withWaitFindSnap doc (fun s => s.endPos >= pos)\n    (notFoundX := throw \u27e8.invalidParams, s!\"no snapshot found at {lspPos}\"\u27e9)\n    (x := f)", "start": [141, 1], "end": [151, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.runCommandElabM", "code": "def runCommandElabM (snap : Snapshot) (c : RequestT CommandElabM \u03b1) : RequestM \u03b1 := do\n  let rc \u2190 readThe RequestContext\n  match \u2190 snap.runCommandElabM rc.doc.meta (c.run rc) with\n  | .ok v => return v\n  | .error e => throw e", "start": [154, 1], "end": [158, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.runCoreM", "code": "def runCoreM (snap : Snapshot) (c : RequestT CoreM \u03b1) : RequestM \u03b1 := do\n  let rc \u2190 readThe RequestContext\n  match \u2190 snap.runCoreM rc.doc.meta (c.run rc) with\n  | .ok v => return v\n  | .error e => throw e", "start": [160, 1], "end": [164, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestM.runTermElabM", "code": "def runTermElabM (snap : Snapshot) (c : RequestT TermElabM \u03b1) : RequestM \u03b1 := do\n  let rc \u2190 readThe RequestContext\n  match \u2190 snap.runTermElabM rc.doc.meta (c.run rc) with\n  | .ok v => return v\n  | .error e => throw e", "start": [167, 1], "end": [171, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.RequestHandler", "code": "structure RequestHandler where\n  fileSource : Json \u2192 Except RequestError Lsp.DocumentUri\n  handle : Json \u2192 RequestM (RequestTask Json)", "start": [185, 1], "end": [187, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.registerLspRequestHandler", "code": "def registerLspRequestHandler (method : String)\n    paramType [FromJson paramType] [FileSource paramType]\n    respType [ToJson respType]\n    (handler : paramType \u2192 RequestM (RequestTask respType)) : IO Unit := do\n  if !(\u2190 Lean.initializing) then\n    throw <| IO.userError s!\"Failed to register LSP request handler for '{method}': only possible during initialization\"\n  if (\u2190 requestHandlers.get).contains method then\n    throw <| IO.userError s!\"Failed to register LSP request handler for '{method}': already registered\"\n  let fileSource := fun j =>\n    parseRequestParams paramType j |>.map Lsp.fileSource\n  let handle := fun j => do\n    let params \u2190 liftExcept <| parseRequestParams paramType j\n    let t \u2190 handler params\n    pure <| t.map <| Except.map ToJson.toJson\n\n  requestHandlers.modify fun rhs => rhs.insert method { fileSource, handle }", "start": [192, 1], "end": [219, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.lookupLspRequestHandler", "code": "def lookupLspRequestHandler (method : String) : IO (Option RequestHandler) :=\n  return (\u2190 requestHandlers.get).find? method", "start": [221, 1], "end": [222, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.chainLspRequestHandler", "code": "def chainLspRequestHandler (method : String)\n    paramType [FromJson paramType]\n    respType [FromJson respType] [ToJson respType]\n    (handler : paramType \u2192 RequestTask respType \u2192 RequestM (RequestTask respType)) : IO Unit := do\n  if !(\u2190 Lean.initializing) then\n    throw <| IO.userError s!\"Failed to chain LSP request handler for '{method}': only possible during initialization\"\n  if let some oldHandler \u2190 lookupLspRequestHandler method then\n    let handle := fun j => do\n      let t \u2190 oldHandler.handle j\n      let t := t.map fun x => x.bind fun j => FromJson.fromJson? j |>.mapError fun e =>\n        .internalError s!\"Failed to parse original LSP response for `{method}` when chaining: {e}\"\n      let params \u2190 liftExcept <| parseRequestParams paramType j\n      let t \u2190 handler params t\n      pure <| t.map <| Except.map ToJson.toJson\n\n    requestHandlers.modify fun rhs => rhs.insert method {oldHandler with handle}\n  else\n    throw <| IO.userError s!\"Failed to chain LSP request handler for '{method}': no initial handler registered\"", "start": [224, 1], "end": [248, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.routeLspRequest", "code": "def routeLspRequest (method : String) (params : Json) : IO (Except RequestError DocumentUri) := do\n  match (\u2190 lookupLspRequestHandler method) with\n  | none => return Except.error <| RequestError.methodNotFound method\n  | some rh => return rh.fileSource params", "start": [250, 1], "end": [253, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.handleLspRequest", "code": "def handleLspRequest (method : String) (params : Json) : RequestM (RequestTask Json) := do\n  match (\u2190 lookupLspRequestHandler method) with\n  | none =>\n    throw <| .internalError\n      s!\"request '{method}' routed through watchdog but unknown in worker; are both using the same plugins?\"\n  | some rh => rh.handle params", "start": [255, 1], "end": [260, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Widget/Diff.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Extra.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveCode.lean", "lake-packages/lean4/src/lean/Lean/Elab/InfoTree.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveGoal.lean", "lake-packages/lean4/src/lean/Lean/Meta/PPGoal.lean"], "premises": [{"full_name": "Lean.Widget.ExprDiffTag", "code": "private inductive ExprDiffTag where\n  | change\n  | delete\n  | insert", "start": [22, 1], "end": [29, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.ExprDiffTag.toDiffTag", "code": "def ExprDiffTag.toDiffTag : (useAfter : Bool) \u2192 ExprDiffTag \u2192 Lean.Widget.DiffTag\n  | true,  .change => .wasChanged\n  | false, .change => .willChange\n  | true,  .delete => .wasDeleted\n  | false, .delete => .willDelete\n  | true,  .insert => .wasInserted\n  | false, .insert => .willInsert", "start": [31, 1], "end": [37, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.ExprDiffTag.toString", "code": "def ExprDiffTag.toString : ExprDiffTag \u2192 String\n  | .change => \"change\"\n  | .delete => \"delete\"\n  | .insert => \"insert\"", "start": [39, 1], "end": [42, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.ExprDiff", "code": "structure ExprDiff where\n  \n  changesBefore : PosMap ExprDiffTag := \u2205\n  \n  changesAfter : PosMap ExprDiffTag := \u2205", "start": [46, 1], "end": [55, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.ExprDiff.insertBeforeChange", "code": "def ExprDiff.insertBeforeChange (p : Pos) (d : ExprDiffTag := .change) (\u03b4 : ExprDiff) : ExprDiff :=\n  {\u03b4 with changesBefore := \u03b4.changesBefore.insert p d}", "start": [69, 1], "end": [71, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.ExprDiff.insertAfterChange", "code": "def ExprDiff.insertAfterChange (p : Pos) (d : ExprDiffTag := .change) (\u03b4 : ExprDiff) : ExprDiff :=\n  {\u03b4 with changesAfter := \u03b4.changesAfter.insert p d}", "start": [73, 1], "end": [75, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.ExprDiff.withChangePos", "code": "def ExprDiff.withChangePos (before after : Pos) (d : ExprDiffTag := .change) : ExprDiff :=\n  { changesAfter := RBMap.empty.insert after d\n    changesBefore := RBMap.empty.insert before d\n  }", "start": [77, 1], "end": [80, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.ExprDiff.withChange", "code": "def ExprDiff.withChange (before after : SubExpr) (d : ExprDiffTag := .change) : ExprDiff :=\n  ExprDiff.withChangePos before.pos after.pos d", "start": [82, 1], "end": [84, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.ExprDiff.isEmpty", "code": "def ExprDiff.isEmpty (d : ExprDiff) : Bool :=\n  d.changesAfter.isEmpty \u2227 d.changesBefore.isEmpty", "start": [86, 1], "end": [88, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.exprDiffCore", "code": "partial def exprDiffCore (before after : SubExpr) : MetaM ExprDiff := do\n  if before.expr == after.expr then\n    return \u2205\n  match before.expr, after.expr with\n  | .mdata _ e\u2080, _ => exprDiffCore {before with expr := e\u2080} after\n  | _, .mdata _ e\u2081 => exprDiffCore before {after with expr := e\u2081}\n  | .app .., .app .. =>\n    let (fn\u2080, args\u2080) := after.expr.withApp Prod.mk\n    let (fn\u2081, args\u2081) := before.expr.withApp Prod.mk\n    if fn\u2080 != fn\u2081 || args\u2080.size != args\u2081.size then\n      return ExprDiff.withChange before after\n    let args := Array.zip args\u2080 args\u2081\n    let args \u2190 args.mapIdxM (fun i (beforeArg, afterArg) =>\n      exprDiffCore\n        \u27e8beforeArg, before.pos.pushNaryArg args\u2080.size i\u27e9\n        \u27e8afterArg,  after.pos.pushNaryArg  args\u2080.size i\u27e9\n    )\n    return args.foldl (init := \u2205) (\u00b7 ++ \u00b7)\n  | .forallE .., _ => piDiff before after\n  | .lam n\u2080 d\u2080 b\u2080 i\u2080, .lam n\u2081 d\u2081 b\u2081 i\u2081=>\n    if n\u2080 != n\u2081 || i\u2080 != i\u2081 then\n      return ExprDiff.withChange before after\n    let \u03b4d \u2190 exprDiffCore \u27e8d\u2080, before.pos.pushBindingDomain\u27e9 \u27e8d\u2081, after.pos.pushBindingDomain\u27e9\n    if \u03b4d.isEmpty then\n      return \u2190 exprDiffCore \u27e8b\u2080, before.pos.pushBindingBody\u27e9 \u27e8b\u2081, after.pos.pushBindingBody\u27e9\n    else\n      return \u03b4d ++ ExprDiff.withChangePos before.pos.pushBindingBody after.pos.pushBindingBody\n  | .proj n\u2080 i\u2080 e\u2080, .proj n\u2081 i\u2081 e\u2081 =>\n    if n\u2080 != n\u2081 || i\u2080 != i\u2081 then\n      return ExprDiff.withChange before after\n    else\n      exprDiffCore \u27e8e\u2080, before.pos.pushProj\u27e9 \u27e8e\u2081, after.pos.pushProj\u27e9\n  | _, _ => return ExprDiff.withChange before after\n  where\n    piDiff (before after : SubExpr) : MetaM ExprDiff := do\n      let .forallE n\u2080 d\u2080 b\u2080 i\u2080 := before.expr\n        | return \u2205\n      if let .forallE n\u2081 d\u2081 b\u2081 i\u2081 := after.expr then\n        if n\u2080 == n\u2081 && i\u2080 == i\u2081 then\n          let \u03b4d \u2190 exprDiffCore\n            \u27e8d\u2080, before.pos.pushBindingDomain\u27e9\n            \u27e8d\u2081, after.pos.pushBindingDomain\u27e9\n          if \u03b4d.isEmpty then\n            let \u03b4t \u2190 Lean.Meta.withLocalDecl n\u2080 i\u2080 d\u2080 fun x =>\n              exprDiffCore\n                \u27e8b\u2080.instantiate1 x, before.pos.pushBindingBody\u27e9\n                \u27e8b\u2081.instantiate1 x, after.pos.pushBindingBody\u27e9\n            return \u03b4t\n          else\n            return \u03b4d ++ ExprDiff.withChangePos before.pos.pushBindingBody after.pos.pushBindingBody\n      if let some s := List.isSuffixOf? after.expr.getForallBinderNames before.expr.getForallBinderNames then\n        if s.length == 0 then\n          throwError \"should not happen\"\n        let body\u2080 := before.expr.getForallBodyMaxDepth s.length\n        let mut \u03b4 : ExprDiff \u2190 (do\n          let fvars \u2190 s.mapM Lean.Meta.getFVarFromUserName\n          return \u2190 exprDiffCore\n            \u27e8body\u2080.instantiateRev fvars.toArray, before.pos.pushNthBindingBody s.length\u27e9\n            after\n        ) <|> (pure \u2205)\n        for i in [0:s.length] do\n          \u03b4 := \u03b4.insertBeforeChange (before.pos.pushNthBindingDomain i) .delete\n        return \u03b4\n      return ExprDiff.withChange before after", "start": [90, 1], "end": [177, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.exprDiff", "code": "def exprDiff (e\u2080 e\u2081 : Expr) (useAfter := true) : MetaM ExprDiff := do\n  let s\u2080 := \u27e8e\u2080, Pos.root\u27e9\n  let s\u2081 := \u27e8e\u2081, Pos.root\u27e9\n  if useAfter then\n    exprDiffCore s\u2080 s\u2081\n  else\n    exprDiffCore s\u2081 s\u2080", "start": [179, 1], "end": [186, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.addDiffTags", "code": "def addDiffTags (useAfter : Bool) (diff : ExprDiff) (info\u2081 : CodeWithInfos) : MetaM CodeWithInfos := do\n  let cs := if useAfter then diff.changesAfter else diff.changesBefore\n  info\u2081.mergePosMap (fun info d => pure <| info.withDiffTag <| ExprDiffTag.toDiffTag useAfter d) cs", "start": [188, 1], "end": [194, 100], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.diffHypothesesBundle", "code": "def diffHypothesesBundle (useAfter : Bool) (ctx\u2080  : LocalContext) (h\u2081 : InteractiveHypothesisBundle) : MetaM InteractiveHypothesisBundle := do\n  \n  for (ppName, fvid) in Array.zip h\u2081.names h\u2081.fvarIds do\n    if !(ctx\u2080.contains fvid) then\n      if let some decl\u2080 := ctx\u2080.findFromUserName? ppName then\n        let t\u2080 := decl\u2080.type\n        return \u2190 withTypeDiff t\u2080 h\u2081\n      else\n        if useAfter then\n          return {h\u2081 with isInserted? := true }\n        else\n          return {h\u2081 with isRemoved? := true }\n  return h\u2081\nwhere\n  withTypeDiff (t\u2080 : Expr) (h\u2081 : InteractiveHypothesisBundle) : MetaM InteractiveHypothesisBundle := do\n    let some x\u2081 := h\u2081.fvarIds[0]?\n      | throwError \"internal error: empty fvar list!\"\n    let t\u2081 \u2190 inferType <| Expr.fvar x\u2081\n    let t\u03b4 \u2190 exprDiff t\u2080 t\u2081 useAfter\n    let c\u2081 \u2190 addDiffTags useAfter t\u03b4 h\u2081.type\n    return {h\u2081 with type := c\u2081}", "start": [198, 1], "end": [226, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.diffHypotheses", "code": "def diffHypotheses (useAfter : Bool) (lctx\u2080 : LocalContext) (hs\u2081 : Array InteractiveHypothesisBundle) : MetaM (Array InteractiveHypothesisBundle) := do\n  hs\u2081.mapM (diffHypothesesBundle useAfter lctx\u2080)", "start": [228, 1], "end": [230, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.diffInteractiveGoal", "code": "def diffInteractiveGoal (useAfter : Bool) (g\u2080 : MVarId) (i\u2081 : InteractiveGoal) : MetaM InteractiveGoal := do\n  let mctx \u2190 getMCtx\n  let some md\u2080 := mctx.findDecl? g\u2080\n    | throwError \"Failed to find decl for {g\u2080}.\"\n  let lctx\u2080 := md\u2080.lctx |>.sanitizeNames.run' {options := (\u2190 getOptions)}\n  let hs\u2081 \u2190 diffHypotheses useAfter lctx\u2080 i\u2081.hyps\n  let i\u2081 := {i\u2081 with hyps := hs\u2081}\n  let g\u2081 := i\u2081.mvarId\n  let t\u2080 \u2190 instantiateMVars <|\u2190 inferType (Expr.mvar g\u2080)\n  let some md\u2081 := (\u2190 getMCtx).findDecl? g\u2081\n    | throwError \"Unknown goal {g\u2081}\"\n  let t\u2081 \u2190 instantiateMVars md\u2081.type\n  let t\u03b4 \u2190 exprDiff t\u2080 t\u2081 useAfter\n  let c\u2081 \u2190 addDiffTags useAfter t\u03b4 i\u2081.type\n  let i\u2081 := {i\u2081 with type := c\u2081, isInserted? := false}\n  return i\u2081", "start": [232, 1], "end": [249, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.diffInteractiveGoals", "code": "def diffInteractiveGoals (useAfter : Bool) (info : Elab.TacticInfo) (igs\u2081 : InteractiveGoals) : MetaM InteractiveGoals := do\n    if ! showTacticDiff.get (\u2190 getOptions) then return igs\u2081 else\n    let goals\u2080 := if useAfter then info.goalsBefore else info.goalsAfter\n    let parentMap : MVarIdMap MVarIdSet \u2190 info.goalsBefore.foldlM (init := \u2205) (fun s g => do\n      let ms \u2190 Expr.mvar g |> Lean.Meta.getMVars\n      let ms : MVarIdSet := RBTree.fromArray ms _\n      return s.insert g ms\n    )\n    let isParent (before after : MVarId) : Bool :=\n       match parentMap.find? before with\n       | some xs => xs.contains after\n       | none => false\n    let goals \u2190 igs\u2081.goals.mapM (fun ig\u2081 => do\n      let g\u2081 := ig\u2081.mvarId\n      withGoalCtx (g\u2081 : MVarId) (fun _lctx\u2081 _md\u2081 => do\n        if goals\u2080.any (fun g\u2080 => g\u2080 == g\u2081) then\n          return {ig\u2081 with isInserted? := none}\n        let some g\u2080 := goals\u2080.find? (fun g\u2080 => if useAfter then isParent g\u2080 g\u2081 else isParent g\u2081 g\u2080)\n          | return if useAfter then {ig\u2081 with isInserted? := true } else {ig\u2081 with isRemoved? := true}\n        let ig\u2081 \u2190 diffInteractiveGoal useAfter g\u2080 ig\u2081\n        return ig\u2081\n      )\n    )\n    return {igs\u2081 with goals := goals}", "start": [251, 1], "end": [278, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/Completion.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/LanguageFeatures.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatcherInfo.lean", "lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Capabilities.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Utf16.lean", "lake-packages/lean4/src/lean/Lean/Server/InfoUtils.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Data/FuzzyMatching.lean", "lake-packages/lean4/src/lean/Lean/Parser/Extension.lean", "lake-packages/lean4/src/lean/Lean/Environment.lean"], "premises": [{"full_name": "Lean.Server.Completion.addToBlackList", "code": "@[export lean_completion_add_to_black_list]\ndef addToBlackList (env : Environment) (declName : Name) : Environment :=\n  completionBlackListExt.tag env declName", "start": [25, 1], "end": [27, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.isBlackListed", "code": "private def isBlackListed (declName : Name) : MetaM Bool := do\n  let env \u2190 getEnv\n  (pure (declName.isInternal && !isPrivateName declName))\n  <||> (pure <| isAuxRecursor env declName)\n  <||> (pure <| isNoConfusion env declName)\n  <||> isRec declName\n  <||> (pure <| completionBlackListExt.isTagged env declName)\n  <||> isMatcher declName", "start": [29, 1], "end": [36, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.consumeImplicitPrefix", "code": "private partial def consumeImplicitPrefix (e : Expr) (k : Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  match e with\n  | Expr.forallE n d b c =>\n    if c == .implicit then\n      withLocalDecl n c d fun arg =>\n        consumeImplicitPrefix (b.instantiate1 arg) k\n    else\n      k e\n  | _ => k e", "start": [38, 1], "end": [47, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.isTypeApplicable", "code": "private def isTypeApplicable (type : Expr) (expectedType? : Option Expr) : MetaM Bool :=\n  try\n    match expectedType? with\n    | none => return true\n    | some expectedType =>\n      let mut (numArgs, hasMVarHead) \u2190 getExpectedNumArgsAux type\n      unless hasMVarHead do\n        let targetTypeNumArgs \u2190 getExpectedNumArgs expectedType\n        numArgs := numArgs - targetTypeNumArgs\n      let (_, _, type) \u2190 forallMetaTelescopeReducing type (some numArgs)\n      withReducible <| withoutModifyingState <| isDefEq type expectedType\n  catch _ =>\n    return false", "start": [49, 1], "end": [64, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.sortCompletionItems", "code": "private def sortCompletionItems (items : Array (CompletionItem \u00d7 Float)) : Array CompletionItem :=\n  items.qsort (fun (i1, s1) (i2, s2) => if s1 == s2 then i1.label < i2.label else s1 > s2) |>.map (\u00b7.1)", "start": [66, 1], "end": [67, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.mkCompletionItem", "code": "private def mkCompletionItem (label : Name) (type : Expr) (docString? : Option String) (kind : CompletionItemKind) : MetaM CompletionItem := do\n  let doc? := docString?.map fun docString => { value := docString, kind := MarkupKind.markdown : MarkupContent }\n  let detail \u2190 consumeImplicitPrefix type fun type => return toString (\u2190 Meta.ppExpr type)\n  return { label := label.toString, detail? := detail, documentation? := doc?, kind? := kind }", "start": [69, 1], "end": [72, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.State", "code": "structure State where\n  itemsMain  : Array (CompletionItem \u00d7 Float) := #[]\n  itemsOther : Array (CompletionItem \u00d7 Float) := #[]", "start": [74, 1], "end": [76, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.M", "code": "abbrev M := OptionT $ StateRefT State MetaM", "start": [78, 1], "end": [78, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.addCompletionItem", "code": "private def addCompletionItem (label : Name) (type : Expr) (expectedType? : Option Expr) (declName? : Option Name) (kind : CompletionItemKind) (score : Float) : M Unit := do\n  let docString? \u2190 if let some declName := declName? then findDocString? (\u2190 getEnv) declName else pure none\n  let item \u2190 mkCompletionItem label type docString? kind\n  if (\u2190 isTypeApplicable  type expectedType?) then\n    modify fun s => { s with itemsMain := s.itemsMain.push (item, score) }\n  else\n    modify fun s => { s with itemsOther := s.itemsOther.push (item, score) }", "start": [80, 1], "end": [86, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.getCompletionKindForDecl", "code": "private def getCompletionKindForDecl (constInfo : ConstantInfo) : M CompletionItemKind := do\n  let env \u2190 getEnv\n  if constInfo.isCtor then\n    return CompletionItemKind.constructor\n  else if constInfo.isInductive then\n    if isClass env constInfo.name then\n      return CompletionItemKind.class\n    else if (\u2190 isEnumType constInfo.name) then\n      return CompletionItemKind.enum\n    else\n      return CompletionItemKind.struct\n  else if (\u2190 isProjectionFn constInfo.name) then\n    return CompletionItemKind.field\n  else if (\u2190 whnf constInfo.type).isForall then\n    return CompletionItemKind.function\n  else\n    return CompletionItemKind.constant", "start": [88, 1], "end": [104, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.addCompletionItemForDecl", "code": "private def addCompletionItemForDecl (label : Name) (declName : Name) (expectedType? : Option Expr) (score : Float) : M Unit := do\n  if let some c := (\u2190 getEnv).find? declName then\n    addCompletionItem label c.type expectedType? (some declName) (\u2190 getCompletionKindForDecl c) score", "start": [106, 1], "end": [108, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.addKeywordCompletionItem", "code": "private def addKeywordCompletionItem (keyword : String) : M Unit := do\n  let item := { label := keyword, detail? := \"keyword\", documentation? := none, kind? := CompletionItemKind.keyword }\n  modify fun s => { s with itemsMain := s.itemsMain.push (item, 1) }", "start": [110, 1], "end": [112, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.addNamespaceCompletionItem", "code": "private def addNamespaceCompletionItem (ns : Name) (score : Float) : M Unit := do\n  let item := { label := ns.toString, detail? := \"namespace\", documentation? := none, kind? := CompletionItemKind.module }\n  modify fun s => { s with itemsMain := s.itemsMain.push (item, score) }", "start": [114, 1], "end": [116, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.runM", "code": "private def runM (ctx : ContextInfo) (lctx : LocalContext) (x : M Unit) : IO (Option CompletionList) :=\n  ctx.runMetaM lctx do\n    match (\u2190 x.run |>.run {}) with\n    | (none, _) => return none\n    | (some _, s) =>\n      return some { items := sortCompletionItems s.itemsMain ++ sortCompletionItems s.itemsOther, isIncomplete := true }", "start": [118, 1], "end": [123, 121], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.matchAtomic", "code": "private def matchAtomic (id : Name) (declName : Name) : Option Float :=\n  match id, declName with\n  | .str .anonymous s\u2081, .str .anonymous s\u2082 => fuzzyMatchScoreWithThreshold? s\u2081 s\u2082\n  | _, _ => none", "start": [125, 1], "end": [128, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.normPrivateName?", "code": "private def normPrivateName? (declName : Name) : MetaM (Option Name) := do\n  match privateToUserName? declName with\n  | none => return declName\n  | some userName =>\n    if mkPrivateName (\u2190 getEnv) userName == declName then\n      return userName\n    else\n      return none", "start": [130, 1], "end": [137, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.matchDecl?", "code": "private def matchDecl? (ns : Name) (id : Name) (danglingDot : Bool) (declName : Name) : MetaM (Option (Name \u00d7 Float)) := do\n  let some declName \u2190 normPrivateName? declName\n    | return none\n  if !ns.isPrefixOf declName then\n    return none\n  let declName := declName.replacePrefix ns Name.anonymous\n  if danglingDot then\n    if id.isPrefixOf declName then\n      let declName := declName.replacePrefix id Name.anonymous\n      if declName.isAtomic && !declName.isAnonymous then\n        return some (declName, 1)\n  else if let (.str p\u2081 s\u2081, .str p\u2082 s\u2082) := (id, declName) then\n    if p\u2081 == p\u2082 then\n      return fuzzyMatchScoreWithThreshold? s\u2081 s\u2082 |>.map (s\u2082, \u00b7)\n    else if p\u2081.isAnonymous then\n      return fuzzyMatchScoreWithThreshold? s\u2081 s\u2082 |>.map (declName, \u00b7 / (p\u2082.getNumParts + 1).toFloat)\n  return none", "start": [139, 1], "end": [167, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.truncate", "code": "private partial def truncate (id : Name) (newLen : Nat) : Name :=\n  let rec go (id : Name) : Name \u00d7 Nat :=\n     match id with\n     | Name.anonymous => (id, 0)\n     | Name.num ..    => unreachable!\n     | .str p s =>\n       let (p', len) := go p\n       if len + 1 >= newLen then\n         (p', len)\n       else\n         let optDot := if p.isAnonymous then 0 else 1\n         let len'   := len + optDot + s.length\n         if len' \u2264 newLen then\n           (id, len')\n         else\n           (Name.mkStr p (s.extract 0 \u27e8newLen - optDot - len\u27e9), newLen)\n  (go id).1", "start": [169, 1], "end": [189, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.HoverInfo", "code": "inductive HoverInfo where\n  | after\n  | inside (delta : Nat)", "start": [191, 1], "end": [193, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.matchNamespace", "code": "def matchNamespace (ns : Name) (nsFragment : Name) (danglingDot : Bool) : Option Float :=\n  if danglingDot then\n    if nsFragment != ns && nsFragment.isPrefixOf ns then\n      some 1\n    else\n      none\n  else\n    match ns, nsFragment with\n    | .str p\u2081 s\u2081, .str p\u2082 s\u2082 =>\n      if p\u2081 == p\u2082 then fuzzyMatchScoreWithThreshold? s\u2082 s\u2081 else none\n    | _, _ => none", "start": [195, 1], "end": [205, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.completeNamespaces", "code": "def completeNamespaces (ctx : ContextInfo) (id : Name) (danglingDot : Bool) : M Unit := do\n  let env \u2190 getEnv\n  let add (ns : Name) (ns' : Name) (score : Float) : M Unit :=\n    if danglingDot then\n      addNamespaceCompletionItem (ns.replacePrefix (ns' ++ id) Name.anonymous) score\n    else\n      addNamespaceCompletionItem (ns.replacePrefix ns' Name.anonymous) score\n  env.getNamespaceSet |>.forM fun ns => do\n    unless ns.isInternal || env.contains ns do for openDecl in ctx.openDecls do\n        match openDecl with\n        | OpenDecl.simple ns' _      =>\n          if let some score := matchNamespace ns (ns' ++ id) danglingDot then\n            add ns ns' score\n            return ()\n        | _ => pure ()\n      let rec visitNamespaces (ns' : Name) : M Unit := do\n        if let some score := matchNamespace ns (ns' ++ id) danglingDot then\n          add ns ns' score\n        else\n          match ns' with\n          | Name.str p .. => visitNamespaces p\n          | _ => return ()\n      visitNamespaces ctx.currNamespace", "start": [207, 1], "end": [231, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.idCompletionCore", "code": "private def idCompletionCore (ctx : ContextInfo) (id : Name) (hoverInfo : HoverInfo) (danglingDot : Bool) (expectedType? : Option Expr) : M Unit := do\n  let mut id := id.eraseMacroScopes\n  let mut danglingDot := danglingDot\n  if let HoverInfo.inside delta := hoverInfo then\n    id := truncate id delta\n    danglingDot := false\n  if id.isAtomic then\n    for localDecl in (\u2190 getLCtx) do\n      if let some score := matchAtomic id localDecl.userName then\n        addCompletionItem localDecl.userName localDecl.type expectedType? none (kind := CompletionItemKind.variable) score\n  let env \u2190 getEnv\n  env.constants.forM fun declName c => do\n    unless (\u2190 isBlackListed declName) do\n      let matchUsingNamespace (ns : Name): M Bool := do\n        if let some (label, score) \u2190 matchDecl? ns id danglingDot declName then\n          addCompletionItem label c.type expectedType? declName (\u2190 getCompletionKindForDecl c) score\n          return true\n        else\n          return false\n      let rec visitNamespaces (ns : Name) : M Bool := do\n        match ns with\n        | Name.str p .. => matchUsingNamespace ns <||> visitNamespaces p\n        | _ => return false\n      if (\u2190 visitNamespaces ctx.currNamespace) then\n        return ()\n      for openDecl in ctx.openDecls do\n        match openDecl with\n        | OpenDecl.simple ns exs =>\n          unless exs.contains declName do\n            if (\u2190 matchUsingNamespace ns) then\n              return ()\n        | _ => pure ()\n      if (\u2190 matchUsingNamespace Name.anonymous) then\n        return ()\n  let matchAlias (ns : Name) (alias : Name) : Option Float :=\n    if ns.isPrefixOf alias then\n      matchAtomic id (alias.replacePrefix ns Name.anonymous)\n    else\n      none\n  let addAlias (alias : Name) (declNames : List Name) (score : Float) : M Unit := do\n    declNames.forM fun declName => do\n      unless (\u2190 isBlackListed declName) do\n        addCompletionItemForDecl alias.getString! declName expectedType? score\n  for openDecl in ctx.openDecls do\n    match openDecl with\n    | OpenDecl.explicit openedId resolvedId =>\n      unless (\u2190 isBlackListed resolvedId) do\n        if let some score := matchAtomic id openedId then\n          addCompletionItemForDecl openedId.getString! resolvedId expectedType? score\n    | OpenDecl.simple ns _      =>\n      getAliasState env |>.forM fun alias declNames => do\n        if let some score := matchAlias ns alias then\n          addAlias alias declNames score\n  getAliasState env |>.forM fun alias declNames => do\n    let rec searchAlias (ns : Name) : M Unit := do\n      if let some score := matchAlias ns alias then\n        addAlias alias declNames score\n      else\n        match ns with\n        | Name.str p ..  => searchAlias p\n        | _ => return ()\n    searchAlias ctx.currNamespace\n  if let .str .anonymous s := id then\n    let keywords := Parser.getTokenTable env\n    for keyword in keywords.findPrefix s do\n      addKeywordCompletionItem keyword\n  completeNamespaces ctx id danglingDot", "start": [233, 1], "end": [312, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.idCompletion", "code": "private def idCompletion (ctx : ContextInfo) (lctx : LocalContext) (id : Name) (hoverInfo : HoverInfo) (danglingDot : Bool) (expectedType? : Option Expr) : IO (Option CompletionList) :=\n  runM ctx lctx do\n    idCompletionCore ctx id hoverInfo danglingDot expectedType?", "start": [314, 1], "end": [316, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.unfoldeDefinitionGuarded?", "code": "private def unfoldeDefinitionGuarded? (e : Expr) : MetaM (Option Expr) :=\n  try unfoldDefinition? e catch _ => pure none", "start": [318, 1], "end": [319, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.isDefEqToAppOf", "code": "private partial def isDefEqToAppOf (e : Expr) (declName : Name) : MetaM Bool := do\n  if e.getAppFn.isConstOf declName then\n    return true\n  let some e \u2190 unfoldeDefinitionGuarded? e | return false\n  isDefEqToAppOf e declName", "start": [321, 1], "end": [326, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.isDotCompletionMethod", "code": "private def isDotCompletionMethod (typeName : Name) (info : ConstantInfo) : MetaM Bool :=\n  forallTelescopeReducing info.type fun xs _ => do\n    for x in xs do\n      let localDecl \u2190 x.fvarId!.getDecl\n      let type := localDecl.type.consumeMData\n      if (\u2190 isDefEqToAppOf type typeName) then\n        return true\n    return false", "start": [328, 1], "end": [335, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.getDotCompletionTypeNames", "code": "private partial def getDotCompletionTypeNames (type : Expr) : MetaM NameSet :=\n  return (\u2190 visit type |>.run {}).2\nwhere\n  visit (type : Expr) : StateRefT NameSet MetaM Unit := do\n    let .const typeName _ := type.getAppFn | return ()\n    modify fun s => s.insert typeName\n    if isStructure (\u2190 getEnv) typeName then\n      for parentName in getAllParentStructures (\u2190 getEnv) typeName do\n        modify fun s => s.insert parentName\n    let some type \u2190 unfoldeDefinitionGuarded? type | return ()\n    visit type", "start": [337, 1], "end": [351, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.dotCompletion", "code": "private def dotCompletion (ctx : ContextInfo) (info : TermInfo) (hoverInfo : HoverInfo) (expectedType? : Option Expr) : IO (Option CompletionList) :=\n  runM ctx info.lctx do\n    let nameSet \u2190 try\n      getDotCompletionTypeNames (\u2190 instantiateMVars (\u2190 inferType info.expr))\n    catch _ =>\n      pure {}\n    if nameSet.isEmpty then\n      if info.stx.isIdent then\n        idCompletionCore ctx info.stx.getId hoverInfo (danglingDot := false) expectedType?\n      else if info.stx.getKind == ``Lean.Parser.Term.completion && info.stx[0].isIdent then\n        idCompletionCore ctx info.stx[0].getId HoverInfo.after (danglingDot := true) expectedType?\n      else\n        failure\n    else\n      (\u2190 getEnv).constants.forM fun declName c => do\n        let some declName \u2190 normPrivateName? declName\n          | return\n        let typeName := declName.getPrefix\n        if nameSet.contains typeName then\n          unless (\u2190 isBlackListed c.name) do\n            if (\u2190 isDotCompletionMethod typeName c) then\n              addCompletionItem c.name.getString! c.type expectedType? c.name (kind := (\u2190 getCompletionKindForDecl c)) 1", "start": [353, 1], "end": [375, 121], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.dotIdCompletion", "code": "private def dotIdCompletion (ctx : ContextInfo) (lctx : LocalContext) (id : Name) (expectedType? : Option Expr) : IO (Option CompletionList) :=\n  runM ctx lctx do\n    let some expectedType := expectedType? | return ()\n    let resultTypeFn := (\u2190 instantiateMVars expectedType).cleanupAnnotations.getAppFn\n    let .const typeName .. := resultTypeFn.cleanupAnnotations | return ()\n    (\u2190 getEnv).constants.forM fun declName c => do\n      let some (label, score) \u2190 matchDecl? typeName id (danglingDot := false) declName | pure ()\n      addCompletionItem label c.type expectedType? declName (\u2190 getCompletionKindForDecl c) score", "start": [377, 1], "end": [384, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.fieldIdCompletion", "code": "private def fieldIdCompletion (ctx : ContextInfo) (lctx : LocalContext) (id : Name) (structName : Name) : IO (Option CompletionList) :=\n  runM ctx lctx do\n    let idStr := id.toString\n    let fieldNames := getStructureFieldsFlattened (\u2190 getEnv) structName (includeSubobjectFields := false)\n    for fieldName in fieldNames do\n      let .str _ fieldName := fieldName | continue\n      let some score := fuzzyMatchScoreWithThreshold? idStr fieldName | continue\n      let item := { label := fieldName, detail? := \"field\", documentation? := none, kind? := CompletionItemKind.field }\n      modify fun s => { s with itemsMain := s.itemsMain.push (item, score) }", "start": [386, 1], "end": [394, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.optionCompletion", "code": "private def optionCompletion (ctx : ContextInfo) (stx : Syntax) (caps : ClientCapabilities) : IO (Option CompletionList) :=\n  ctx.runMetaM {} do\n    let (partialName, trailingDot) :=\n      match stx[1].getSubstring? (withLeading := false) (withTrailing := false) with\n      | none => (\"\", false)  | some ss =>\n        if !ss.str.atEnd ss.stopPos && ss.str.get ss.stopPos == '.' then\n          (ss.toString ++ \".\", true)\n        else\n          (ss.toString, false)\n    let (decls : RBMap _ _ _) \u2190 getOptionDecls\n    let opts \u2190 getOptions\n    let mut items := #[]\n    for \u27e8name, decl\u27e9 in decls do\n      if let some score := fuzzyMatchScoreWithThreshold? partialName name.toString then\n        let textEdit :=\n          if !caps.textDocument?.any (\u00b7.completion?.any (\u00b7.completionItem?.any (\u00b7.insertReplaceSupport?.any (\u00b7)))) then\n            none else if let some \u27e8start, stop\u27e9 := stx[1].getRange? then\n            let stop := if trailingDot then stop + ' ' else stop\n            let range := \u27e8ctx.fileMap.utf8PosToLspPos start, ctx.fileMap.utf8PosToLspPos stop\u27e9\n            some { newText := name.toString, insert := range, replace := range : InsertReplaceEdit }\n          else\n            none\n        items := items.push\n          ({ label := name.toString\n             detail? := s!\"({opts.get name decl.defValue}), {decl.descr}\"\n             documentation? := none,\n             kind? := CompletionItemKind.property textEdit? := textEdit }, score)\n    return some { items := sortCompletionItems items, isIncomplete := true }", "start": [396, 1], "end": [429, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.tacticCompletion", "code": "private def tacticCompletion (ctx : ContextInfo) : IO (Option CompletionList) :=\n  ctx.runMetaM {} do\n    let table := Parser.getCategory (Parser.parserExtension.getState (\u2190 getEnv)).categories `tactic |>.get!.tables.leadingTable\n    let items : Array (CompletionItem \u00d7 Float) := table.fold (init := #[]) fun items tk _ =>\n      items.push ({ label := tk.toString, detail? := none, documentation? := none, kind? := CompletionItemKind.keyword }, 1)\n    return some { items := sortCompletionItems items, isIncomplete := true }", "start": [431, 1], "end": [438, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.Completion.find?", "code": "partial def find? (fileMap : FileMap) (hoverPos : String.Pos) (infoTree : InfoTree) (caps : ClientCapabilities) : IO (Option CompletionList) := do\n  let \u27e8hoverLine, _\u27e9 := fileMap.toPosition hoverPos\n  match infoTree.foldInfo (init := none) (choose fileMap hoverLine) with\n  | some (hoverInfo, ctx, Info.ofCompletionInfo info) =>\n    match info with\n    | .dot info (expectedType? := expectedType?) .. => dotCompletion ctx info hoverInfo expectedType?\n    | .id _   id danglingDot lctx expectedType? => idCompletion ctx lctx id hoverInfo danglingDot expectedType?\n    | .dotId _  id lctx expectedType? => dotIdCompletion ctx lctx id expectedType?\n    | .fieldId _ id lctx structName => fieldIdCompletion ctx lctx id structName\n    | .option stx => optionCompletion ctx stx caps\n    | .tactic .. => tacticCompletion ctx\n    | _ => return none\n  | _ =>\n    return none\nwhere\n  choose (fileMap : FileMap) (hoverLine : Nat) (ctx : ContextInfo) (info : Info) (best? : Option (HoverInfo \u00d7 ContextInfo \u00d7 Info)) : Option (HoverInfo \u00d7 ContextInfo \u00d7 Info) :=\n    if !info.isCompletion then best?\n    else if info.occursInside? hoverPos |>.isSome then\n      let headPos          := info.pos?.get!\n      let \u27e8headPosLine, _\u27e9 := fileMap.toPosition headPos\n      let \u27e8tailPosLine, _\u27e9 := fileMap.toPosition info.tailPos?.get!\n      if headPosLine != hoverLine || headPosLine != tailPosLine then\n        best?\n      else match best? with\n        | none                         => (HoverInfo.inside (hoverPos - headPos).byteIdx, ctx, info)\n        | some (HoverInfo.after, _, _) => (HoverInfo.inside (hoverPos - headPos).byteIdx, ctx, info)\n        | some (_, _, best) =>\n          if info.isSmaller best then\n            (HoverInfo.inside (hoverPos - headPos).byteIdx, ctx, info)\n          else\n            best?\n    else if let some (HoverInfo.inside _, _, _) := best? then\n      best?\n    else if let some d := info.occursBefore? hoverPos then\n      let pos := info.tailPos?.get!\n      let \u27e8line, _\u27e9 := fileMap.toPosition pos\n      if line != hoverLine then best?\n      else match best? with\n        | none => (HoverInfo.after, ctx, info)\n        | some (_, _, best) =>\n          let dBest := best.occursBefore? hoverPos |>.get!\n          if d < dBest || (d == dBest && info.isSmaller best) then\n            (HoverInfo.after, ctx, info)\n          else\n            best?\n    else\n      best?", "start": [440, 1], "end": [488, 12], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/GoTo.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Path.lean", "lake-packages/lean4/src/lean/Lean/Data/Json/FromToJson.lean", "lake-packages/lean4/src/lean/Lean/Server/Utils.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Server.GoToKind", "code": "inductive GoToKind\n  | declaration | definition | type\n  deriving BEq, ToJson, FromJson", "start": [15, 1], "end": [17, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.documentUriFromModule", "code": "def documentUriFromModule (srcSearchPath : SearchPath) (modName : Name) : IO (Option DocumentUri) := do\n  let some modFname \u2190 srcSearchPath.findModuleWithExt \"lean\" modName\n    | pure none\n  let modFname \u2190 IO.FS.realPath modFname\n  return some <| System.Uri.pathToUri modFname", "start": [19, 1], "end": [25, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.locationLinksFromDecl", "code": "def locationLinksFromDecl (srcSearchPath : SearchPath) (uri : DocumentUri) (n : Name)\n    (originRange? : Option Range) : MetaM (Array LocationLink) := do\n  let mod? \u2190 findModuleOf? n\n  let modUri? \u2190 match mod? with\n    | some modName => documentUriFromModule srcSearchPath modName\n    | none         => pure <| some uri\n\n  let ranges? \u2190 findDeclarationRanges? n\n  if let (some ranges, some modUri) := (ranges?, modUri?) then\n    let declRangeToLspRange (r : DeclarationRange) : Lsp.Range :=\n      { start := \u27e8r.pos.line - 1, r.charUtf16\u27e9\n        \u00abend\u00bb := \u27e8r.endPos.line - 1, r.endCharUtf16\u27e9 }\n    let ll : LocationLink := {\n      originSelectionRange? := originRange?\n      targetUri := modUri\n      targetRange := declRangeToLspRange ranges.range\n      targetSelectionRange := declRangeToLspRange ranges.selectionRange\n    }\n    return #[ll]\n  return #[]", "start": [28, 1], "end": [47, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/SplitIf.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Lean/LazyInitExtension.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.SplitIf.getSimpContext", "code": "def getSimpContext : MetaM Simp.Context :=\n  ext.get", "start": [26, 1], "end": [30, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SplitIf.discharge?", "code": "def discharge? (useDecide := false) : Simp.Discharge := fun prop => do\n  let prop \u2190 instantiateMVars prop\n  trace[Meta.Tactic.splitIf] \"discharge? {prop}, {prop.notNot?}\"\n  if useDecide then\n    let prop \u2190 instantiateMVars prop\n    if !prop.hasFVar && !prop.hasMVar then\n      let d \u2190 mkDecide prop\n      let r \u2190 withDefault <| whnf d\n      if r.isConstOf ``true then\n        return some <| mkApp3 (mkConst ``of_decide_eq_true) prop d.appArg! (\u2190 mkEqRefl (mkConst ``true))\n  (\u2190 getLCtx).findDeclRevM? fun localDecl => do\n     if localDecl.isAuxDecl then\n       return none\n     else if (\u2190 isDefEq prop localDecl.type) then\n       return some localDecl.toExpr\n     else match prop.notNot? with\n       | none => return none\n       | some arg =>\n         if (\u2190 isDefEq arg localDecl.type) then\n           return some (mkApp2 (mkConst ``not_not_intro) arg localDecl.toExpr)\n         else\n           return none", "start": [32, 1], "end": [57, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SplitIf.findIfToSplit?", "code": "partial def findIfToSplit? (e : Expr) : Option Expr :=\n  if let some iteApp := e.find? fun e => (e.isIte || e.isDIte) && !(e.getArg! 1 5).hasLooseBVars then\n    let cond := iteApp.getArg! 1 5\n    findIfToSplit? cond |>.getD cond\n  else\n    none", "start": [59, 1], "end": [66, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SplitIf.splitIfAt?", "code": "def splitIfAt? (mvarId : MVarId) (e : Expr) (hName? : Option Name) : MetaM (Option (ByCasesSubgoal \u00d7 ByCasesSubgoal)) := do\n  let e \u2190 instantiateMVars e\n  if let some cond := findIfToSplit? e then\n    let hName \u2190 match hName? with\n      | none       => mkFreshUserName `h\n      | some hName => pure hName\n    trace[Meta.Tactic.splitIf] \"splitting on {cond}\"\n    return some (\u2190  mvarId.byCases cond hName)\n  else\n    return none", "start": [68, 1], "end": [77, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpIfTarget", "code": "def simpIfTarget (mvarId : MVarId) (useDecide := false) : MetaM MVarId := do\n  let mut ctx \u2190 getSimpContext\n  if let (some mvarId', _) \u2190 simpTarget mvarId ctx (discharge? useDecide) (mayCloseGoal := false) then\n    return mvarId'\n  else\n    unreachable!", "start": [83, 1], "end": [88, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpIfLocalDecl", "code": "def simpIfLocalDecl (mvarId : MVarId) (fvarId : FVarId) : MetaM MVarId := do\n  let mut ctx \u2190 getSimpContext\n  if let (some (_, mvarId'), _) \u2190 simpLocalDecl mvarId fvarId ctx discharge? (mayCloseGoal := false) then\n    return mvarId'\n  else\n    unreachable!", "start": [90, 1], "end": [95, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.splitIfTarget?", "code": "def splitIfTarget? (mvarId : MVarId) (hName? : Option Name := none) : MetaM (Option (ByCasesSubgoal \u00d7 ByCasesSubgoal)) := commitWhenSome? do\n  if let some (s\u2081, s\u2082) \u2190 splitIfAt? mvarId (\u2190 mvarId.getType) hName? then\n    let mvarId\u2081 \u2190 simpIfTarget s\u2081.mvarId\n    let mvarId\u2082 \u2190 simpIfTarget s\u2082.mvarId\n    if s\u2081.mvarId == mvarId\u2081 && s\u2082.mvarId == mvarId\u2082 then\n      return none\n    else\n      return some ({ s\u2081 with mvarId := mvarId\u2081 }, { s\u2082 with mvarId := mvarId\u2082 })\n  else\n    return none", "start": [97, 1], "end": [106, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.splitIfLocalDecl?", "code": "def splitIfLocalDecl? (mvarId : MVarId) (fvarId : FVarId) (hName? : Option Name := none) : MetaM (Option (MVarId \u00d7 MVarId)) := commitWhenSome? do\n  mvarId.withContext do\n    if let some (s\u2081, s\u2082) \u2190 splitIfAt? mvarId (\u2190 inferType (mkFVar fvarId)) hName? then\n      let mvarId\u2081 \u2190 simpIfLocalDecl s\u2081.mvarId fvarId\n      let mvarId\u2082 \u2190 simpIfLocalDecl s\u2082.mvarId fvarId\n      if s\u2081.mvarId == mvarId\u2081 && s\u2082.mvarId == mvarId\u2082 then\n        return none\n      else\n        return some (mvarId\u2081, mvarId\u2082)\n    else\n      return none", "start": [108, 1], "end": [118, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Generalize.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/KAbstract.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/FVarSubst.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Revert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean"], "premises": [{"full_name": "Lean.Meta.GeneralizeArg", "code": "structure GeneralizeArg where\n  expr   : Expr\n  xName? : Option Name := none\n  hName? : Option Name := none\n  deriving Inhabited", "start": [14, 1], "end": [19, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.generalizeCore", "code": "private partial def generalizeCore (mvarId : MVarId) (args : Array GeneralizeArg) : MetaM (Array FVarId \u00d7 MVarId) :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `generalize\n    let tag \u2190 mvarId.getTag\n    let target \u2190 instantiateMVars (\u2190 mvarId.getType)\n    let rec go (i : Nat) : MetaM Expr := do\n      if _h : i < args.size then\n        let arg := args[i]\n        let e \u2190 instantiateMVars arg.expr\n        let eType \u2190 instantiateMVars (\u2190 inferType e)\n        let type \u2190 go (i+1)\n        let xName \u2190 if let some xName := arg.xName? then pure xName else mkFreshUserName `x\n        return Lean.mkForall xName BinderInfo.default eType (\u2190 kabstract type e)\n      else\n        return target\n    let targetNew \u2190 go 0\n    unless (\u2190 isTypeCorrect targetNew) do\n      throwTacticEx `generalize mvarId m!\"result is not type correct{indentExpr targetNew}\"\n    let es := args.map (\u00b7.expr)\n    if !args.any fun arg => arg.hName?.isSome then\n      let mvarNew \u2190 mkFreshExprSyntheticOpaqueMVar targetNew tag\n      mvarId.assign (mkAppN mvarNew es)\n      mvarNew.mvarId!.introNP args.size\n    else\n      let (rfls, targetNew) \u2190 forallBoundedTelescope targetNew args.size fun xs type => do\n        let rec go' (i : Nat) : MetaM (List Expr \u00d7 Expr) := do\n          if _h : i < xs.size then\n            let arg := args[i]!\n            if let some hName := arg.hName? then\n              let xType \u2190 inferType xs[i]\n              let e \u2190 instantiateMVars arg.expr\n              let eType \u2190 instantiateMVars (\u2190 inferType e)\n              let (hType, r) \u2190 if (\u2190 isDefEq xType eType) then\n                pure (\u2190 mkEq e xs[i], \u2190 mkEqRefl e)\n              else\n                pure (\u2190 mkHEq e xs[i], \u2190 mkHEqRefl e)\n              let (rs, type) \u2190 go' (i+1)\n              return (r :: rs, mkForall hName BinderInfo.default hType type)\n            else\n              go' (i+1)\n          else\n            return ([], type)\n        let (rfls, type) \u2190 go' 0\n        return (rfls, \u2190 mkForallFVars xs type)\n      let mvarNew \u2190 mkFreshExprSyntheticOpaqueMVar targetNew tag\n      mvarId.assign (mkAppN (mkAppN mvarNew es) rfls.toArray)\n      mvarNew.mvarId!.introNP (args.size + rfls.length)", "start": [21, 1], "end": [71, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.generalize", "code": "@[inherit_doc generalizeCore]\ndef _root_.Lean.MVarId.generalize (mvarId : MVarId) (args : Array GeneralizeArg) : MetaM (Array FVarId \u00d7 MVarId) :=\n  generalizeCore mvarId args", "start": [73, 1], "end": [75, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.generalize", "code": "@[inherit_doc generalizeCore, deprecated MVarId.generalize]\ndef generalize (mvarId : MVarId) (args : Array GeneralizeArg) : MetaM (Array FVarId \u00d7 MVarId) :=\n  generalizeCore mvarId args", "start": [77, 1], "end": [79, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.generalizeHyp", "code": "def _root_.Lean.MVarId.generalizeHyp (mvarId : MVarId) (args : Array GeneralizeArg) (hyps : Array FVarId := #[])\n    (fvarSubst : FVarSubst := {}) : MetaM (FVarSubst \u00d7 Array FVarId \u00d7 MVarId) := do\n  if hyps.isEmpty then\n    return (fvarSubst, \u2190 mvarId.generalize args)\n  let args \u2190 args.mapM fun arg => return { arg with expr := \u2190 instantiateMVars arg.expr }\n  let hyps \u2190 hyps.filterM fun h => do\n    let type \u2190 instantiateMVars (\u2190 h.getType)\n    args.anyM fun arg => return (\u2190 kabstract type arg.expr).hasLooseBVars\n  let (reverted, mvarId) \u2190 mvarId.revert hyps true\n  let (newVars, mvarId) \u2190 mvarId.generalize args\n  let (reintros, mvarId) \u2190 mvarId.introNP reverted.size\n  let fvarSubst := Id.run do\n    let mut subst : FVarSubst := fvarSubst\n    for h in reverted, reintro in reintros do\n      subst := subst.insert h (mkFVar reintro)\n    pure subst\n  return (fvarSubst, newVars, mvarId)", "start": [81, 1], "end": [103, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Main.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Delta.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Replace.lean", "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.delta?", "code": "def delta? (e : Expr) (p : Name \u2192 Bool := fun _ => true) : CoreM (Option Expr) :=\n  matchConst e.getAppFn (fun _ => return none) fun fInfo fLvls => do\n    if p fInfo.name && fInfo.hasValue && fInfo.levelParams.length == fLvls.length then\n      let f \u2190 instantiateValueLevelParams fInfo fLvls\n      return some (f.betaRev e.getAppRevArgs (useZeta := true))\n    else\n      return none", "start": [11, 1], "end": [17, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.deltaExpand", "code": "def deltaExpand (e : Expr) (p : Name \u2192 Bool) : CoreM Expr :=\n  Core.transform e fun e => do\n    match (\u2190 delta? e p) with\n    | some e' => return .visit e'\n    | none    => return .continue", "start": [19, 1], "end": [24, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.deltaTarget", "code": "def _root_.Lean.MVarId.deltaTarget (mvarId : MVarId) (p : Name \u2192 Bool) : MetaM MVarId :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `delta\n    mvarId.change (\u2190 deltaExpand (\u2190 mvarId.getType) p) (checkDefEq := false)", "start": [26, 1], "end": [32, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.deltaTarget", "code": "@[deprecated MVarId.deltaTarget]\ndef deltaTarget (mvarId : MVarId) (p : Name \u2192 Bool) : MetaM MVarId :=\n  mvarId.deltaTarget p", "start": [34, 1], "end": [36, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.deltaLocalDecl", "code": "def _root_.Lean.MVarId.deltaLocalDecl (mvarId : MVarId) (fvarId : FVarId) (p : Name \u2192 Bool) : MetaM MVarId :=\n  mvarId.withContext do\n    mvarId.checkNotAssigned `delta\n    mvarId.changeLocalDecl fvarId (\u2190 deltaExpand (\u2190 mvarId.getType) p) (checkDefEq := false)", "start": [38, 1], "end": [44, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.deltaLocalDecl", "code": "@[deprecated MVarId.deltaLocalDecl]\ndef deltaLocalDecl (mvarId : MVarId) (fvarId : FVarId) (p : Name \u2192 Bool) : MetaM MVarId :=\n  mvarId.deltaLocalDecl fvarId p", "start": [46, 1], "end": [48, 33], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpAll.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.SimpAll.Entry", "code": "structure Entry where\n  fvarId   : FVarId userName : Name\n  id       : Origin origType : Expr\n  type     : Expr\n  proof    : Expr\n  deriving Inhabited", "start": [16, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpAll.State", "code": "structure State where\n  modified  : Bool := false\n  mvarId    : MVarId\n  entries   : Array Entry := #[]\n  ctx       : Simp.Context\n  usedSimps : UsedSimps := {}", "start": [25, 1], "end": [30, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpAll.M", "code": "abbrev M := StateRefT State MetaM", "start": [32, 1], "end": [32, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpAll.initEntries", "code": "private def initEntries : M Unit := do\n  let hs \u2190  (\u2190 get).mvarId.withContext do getPropHyps\n  let hsNonDeps \u2190 (\u2190 get).mvarId.getNondepPropHyps\n  let mut simpThms := (\u2190 get).ctx.simpTheorems\n  for h in hs do\n    unless simpThms.isErased (.fvar h) do\n      let localDecl \u2190 h.getDecl\n      let proof  := localDecl.toExpr\n      simpThms \u2190 simpThms.addTheorem (.fvar h) proof\n      modify fun s => { s with ctx.simpTheorems := simpThms }\n      if hsNonDeps.contains h then\n        let type \u2190 instantiateMVars localDecl.type\n        let entry : Entry := { fvarId := h, userName := localDecl.userName, id := .fvar h, origType := type, type, proof }\n        modify fun s => { s with entries := s.entries.push entry }", "start": [34, 1], "end": [48, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpAll.getSimpTheorems", "code": "private abbrev getSimpTheorems : M SimpTheoremsArray :=\n  return (\u2190 get).ctx.simpTheorems", "start": [50, 1], "end": [51, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpAll.loop", "code": "private partial def loop : M Bool := do\n  modify fun s => { s with modified := false }\n  for i in [:(\u2190 get).entries.size] do\n    let entry := (\u2190 get).entries[i]!\n    let ctx := (\u2190 get).ctx\n    let simpThmsWithoutEntry := (\u2190 getSimpTheorems).eraseTheorem entry.id\n    let ctx := { ctx with simpTheorems := simpThmsWithoutEntry }\n    let (r, usedSimps) \u2190 simpStep (\u2190 get).mvarId entry.proof entry.type ctx (usedSimps := (\u2190 get).usedSimps)\n    modify fun s => { s with usedSimps }\n    match r with\n    | none => return true | some (proofNew, typeNew) =>\n      unless typeNew == entry.type do\n        \n        trace[Meta.Tactic.simp.all] \"entry.id: {\u2190 ppOrigin entry.id}, {entry.type} => {typeNew}\"\n        let mut simpThmsNew := (\u2190 getSimpTheorems).eraseTheorem (.fvar entry.fvarId)\n        let idNew \u2190 mkFreshId\n        simpThmsNew \u2190 simpThmsNew.addTheorem (.other idNew) (\u2190 mkExpectedTypeHint proofNew typeNew)\n        modify fun s => { s with\n          modified         := true\n          ctx.simpTheorems := simpThmsNew\n          entries[i]       := { entry with type := typeNew, proof := proofNew, id := .other idNew }\n        }\n  let mvarId := (\u2190 get).mvarId\n  let (r, usedSimps) \u2190 simpTarget mvarId (\u2190 get).ctx (usedSimps := (\u2190 get).usedSimps)\n  modify fun s => { s with usedSimps }\n  match r with\n  | none => return true\n  | some mvarIdNew =>\n    unless mvarId == mvarIdNew do\n      modify fun s => { s with\n        modified := true\n        mvarId   := mvarIdNew\n      }\n  if (\u2190 get).modified then\n    loop\n  else\n    return false", "start": [53, 1], "end": [115, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SimpAll.main", "code": "def main : M (Option MVarId) := do\n  initEntries\n  if (\u2190 loop) then\n    return none else\n    let mvarId := (\u2190 get).mvarId\n    let mut toAssert := #[]\n    let mut toClear := #[]\n    let mut modified := false\n    for e in (\u2190 get).entries do\n      if e.type.consumeMData.isConstOf ``True then\n        toClear := toClear.push e.fvarId\n      else if modified || e.type != e.origType then\n        toClear := toClear.push e.fvarId\n        toAssert := toAssert.push { userName := e.userName, type := e.type, value := e.proof }\n        modified := true\n    let (_, mvarId) \u2190 mvarId.assertHypotheses toAssert\n    mvarId.tryClearMany toClear", "start": [117, 1], "end": [139, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpAll", "code": "def simpAll (mvarId : MVarId) (ctx : Simp.Context) (usedSimps : UsedSimps := {}) : MetaM (Option MVarId \u00d7 UsedSimps) := do\n  mvarId.withContext do\n    let (r, s) \u2190 SimpAll.main.run { mvarId, ctx, usedSimps }\n    if let .some mvarIdNew := r then\n      if ctx.config.failIfUnchanged && mvarId == mvarIdNew then\n        throwError \"simp_all made no progress\"\n    return (r, s.usedSimps)", "start": [143, 1], "end": [149, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/AC/Main.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Refl.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": [{"full_name": "Lean.Meta.AC.ACExpr", "code": "abbrev ACExpr := Lean.Data.AC.Expr", "start": [15, 1], "end": [15, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AC.PreContext", "code": "structure PreContext where\n  id : Nat\n  op : Expr\n  assoc : Expr\n  comm : Option Expr\n  idem : Option Expr\n  deriving Inhabited", "start": [17, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AC.getInstance", "code": "def getInstance (cls : Name) (exprs : Array Expr) : MetaM (Option Expr) := do\n  try\n    let app \u2190 mkAppM cls exprs\n    trace[Meta.AC] \"trying: {indentExpr app}\"\n    let inst \u2190 synthInstance app\n    trace[Meta.AC] \"got instance\"\n    return some inst\n  catch\n  | _ => return none", "start": [35, 1], "end": [43, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AC.preContext", "code": "def preContext (expr : Expr) : MetaM (Option PreContext) := do\n  if let some assoc := \u2190getInstance ``IsAssociative #[expr] then\n    return some\n      { assoc,\n        op := expr\n        id := 0\n        comm := \u2190getInstance ``IsCommutative #[expr]\n        idem := \u2190getInstance ``IsIdempotent #[expr] }\n\n  return none", "start": [45, 1], "end": [54, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AC.PreExpr", "code": "inductive PreExpr\n| op (lhs rhs : PreExpr)\n| var (e : Expr)", "start": [56, 1], "end": [58, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AC.bin", "code": "@[match_pattern] def bin (op l r : Expr) :=\n  Expr.app (Expr.app op l) r", "start": [60, 1], "end": [61, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AC.toACExpr", "code": "def toACExpr (op l r : Expr) : MetaM (Array Expr \u00d7 ACExpr) := do\n  let (preExpr, vars) \u2190\n    toPreExpr (mkApp2 op l r)\n    |>.run HashSet.empty\n  let vars := vars.toArray.insertionSort Expr.lt\n  let varMap := vars.foldl (fun xs x => xs.insert x xs.size) HashMap.empty |>.find!\n\n  return (vars, toACExpr varMap preExpr)\n  where\n    toPreExpr : Expr \u2192 StateT ExprSet MetaM PreExpr\n    | e@(bin op\u2082 l r) => do\n      if \u2190isDefEq op op\u2082 then\n        return PreExpr.op (\u2190toPreExpr l) (\u2190toPreExpr r)\n      modify fun vars => vars.insert e\n      return PreExpr.var e\n    | e => do\n      modify fun vars => vars.insert e\n      return PreExpr.var e\n\n    toACExpr (varMap : Expr \u2192 Nat) : PreExpr \u2192 ACExpr\n    | PreExpr.op l r => Data.AC.Expr.op (toACExpr varMap l) (toACExpr varMap r)\n    | PreExpr.var x => Data.AC.Expr.var (varMap x)", "start": [63, 1], "end": [84, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AC.buildNormProof", "code": "def buildNormProof (preContext : PreContext) (l r : Expr) : MetaM (Lean.Expr \u00d7 Lean.Expr) := do\n  let (vars, acExpr) \u2190 toACExpr preContext.op l r\n\n  let \u03b1 \u2190 inferType vars[0]!\n  let u \u2190 getLevel \u03b1\n  let (isNeutrals, context) \u2190 mkContext \u03b1 u vars\n  let acExprNormed := Data.AC.evalList ACExpr preContext $ Data.AC.norm (preContext, isNeutrals) acExpr\n  let tgt := convertTarget vars acExprNormed\n  let lhs := convert acExpr\n  let rhs := convert acExprNormed\n  let proof := mkAppN (mkConst ``Context.eq_of_norm [u]) #[\u03b1, context, lhs, rhs, \u2190mkEqRefl (mkConst ``Bool.true)]\n  return (proof, tgt)\nwhere\n  mkContext (\u03b1 : Expr) (u : Level) (vars : Array Expr) : MetaM (Array Bool \u00d7 Expr) := do\n    let arbitrary := vars[0]!\n    let zero := mkLevelZeroEx ()\n    let noneE := mkApp (mkConst ``Option.none [zero])\n    let someE := mkApp2 (mkConst ``Option.some [zero])\n\n    let vars \u2190 vars.mapM fun x => do\n      let isNeutral :=\n        let isNeutralClass := mkApp3 (mkConst ``IsNeutral [u]) \u03b1 preContext.op x\n        match \u2190getInstance ``IsNeutral #[preContext.op, x] with\n        | none => (false, noneE isNeutralClass)\n        | some isNeutral => (true, someE isNeutralClass isNeutral)\n\n      return (isNeutral.1, mkApp4 (mkConst ``Variable.mk [u]) \u03b1 preContext.op x isNeutral.2)\n\n    let (isNeutrals, vars) := vars.unzip\n    let vars := vars.toList\n    let vars \u2190 mkListLit (mkApp2 (mkConst ``Variable [u]) \u03b1 preContext.op) vars\n\n    let comm :=\n      let commClass := mkApp2 (mkConst ``IsCommutative [u]) \u03b1 preContext.op\n      match preContext.comm with\n      | none => noneE commClass\n      | some comm => someE commClass comm\n\n    let idem :=\n      let idemClass := mkApp2 (mkConst ``IsIdempotent [u]) \u03b1 preContext.op\n      match preContext.idem with\n      | none => noneE idemClass\n      | some idem => someE idemClass idem\n\n    return (isNeutrals, mkApp7 (mkConst ``Lean.Data.AC.Context.mk [u]) \u03b1 preContext.op preContext.assoc comm idem vars arbitrary)\n\n  convert : ACExpr \u2192 Expr\n    | Data.AC.Expr.op l r => mkApp2 (mkConst ``Data.AC.Expr.op) (convert l) (convert r)\n    | Data.AC.Expr.var x => mkApp (mkConst ``Data.AC.Expr.var) $ mkNatLit x\n\n  convertTarget (vars : Array Expr) : ACExpr \u2192 Expr\n    | Data.AC.Expr.op l r => mkApp2 preContext.op (convertTarget vars l) (convertTarget vars r)\n    | Data.AC.Expr.var x => vars[x]!", "start": [86, 1], "end": [138, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AC.rewriteUnnormalized", "code": "def rewriteUnnormalized (mvarId : MVarId) : MetaM Unit := do\n  let simpCtx :=\n    {\n      simpTheorems  := {}\n      congrTheorems := (\u2190 getSimpCongrTheorems)\n      config        := Simp.neutralConfig\n    }\n  let tgt \u2190 instantiateMVars (\u2190 mvarId.getType)\n  let (res, _) \u2190 Simp.main tgt simpCtx (methods := { post })\n  let newGoal \u2190 applySimpResultToTarget mvarId tgt res\n  newGoal.refl\nwhere\n  post (e : Expr) : SimpM Simp.Step := do\n    let ctx \u2190 read\n    match e, ctx.parent? with\n    | bin op\u2081 l r, some (bin op\u2082 _ _) =>\n      if \u2190isDefEq op\u2081 op\u2082 then\n        return Simp.Step.done { expr := e }\n      match \u2190preContext op\u2081 with\n      | some pc =>\n        let (proof, newTgt) \u2190 buildNormProof pc l r\n        return Simp.Step.done { expr := newTgt, proof? := proof }\n      | none => return Simp.Step.done { expr := e }\n    | bin op l r, _ =>\n      match \u2190preContext op with\n      | some pc =>\n        let (proof, newTgt) \u2190 buildNormProof pc l r\n        return Simp.Step.done { expr := newTgt, proof? := proof }\n      | none => return Simp.Step.done { expr := e }\n    | e, _ => return Simp.Step.done { expr := e }", "start": [140, 1], "end": [169, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AC.acRflTactic", "code": "@[builtin_tactic acRfl] def acRflTactic : Lean.Elab.Tactic.Tactic := fun _ => do\n  let goal \u2190 getMainGoal\n  goal.withContext <| rewriteUnnormalized goal", "start": [171, 1], "end": [173, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/InlineAttrs.lean", "lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Instances.lean", "lake-packages/lean4/src/lean/Lean/Compiler/Specialize.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Param", "code": "structure Param where\n  fvarId     : FVarId\n  binderName : Name\n  type       : Expr\n  borrow     : Bool\n  deriving Inhabited, BEq", "start": [23, 1], "end": [28, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Param.toExpr", "code": "def Param.toExpr (p : Param) : Expr :=\n  .fvar p.fvarId", "start": [30, 1], "end": [31, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AltCore", "code": "inductive AltCore (Code : Type) where\n  | alt (ctorName : Name) (params : Array Param) (code : Code)\n  | default (code : Code)\n  deriving Inhabited", "start": [33, 1], "end": [36, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LitValue", "code": "inductive LitValue where\n  | natVal (val : Nat)\n  | strVal (val : String)\n  deriving Inhabited, BEq, Hashable", "start": [38, 1], "end": [42, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LitValue.toExpr", "code": "def LitValue.toExpr : LitValue \u2192 Expr\n  | .natVal v => .lit (.natVal v)\n  | .strVal v => .lit (.strVal v)", "start": [44, 1], "end": [46, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg", "code": "inductive Arg where\n  | erased\n  | fvar (fvarId : FVarId)\n  | type (expr : Expr)\n  deriving Inhabited, BEq, Hashable", "start": [48, 1], "end": [52, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Param.toArg", "code": "def Param.toArg (p : Param) : Arg :=\n  .fvar p.fvarId", "start": [54, 1], "end": [55, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.toExpr", "code": "def Arg.toExpr (arg : Arg) : Expr :=\n  match arg with\n  | .erased => erasedExpr\n  | .fvar fvarId => .fvar fvarId\n  | .type e => e", "start": [57, 1], "end": [61, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.updateTypeImp", "code": "private unsafe def Arg.updateTypeImp (arg : Arg) (type' : Expr) : Arg :=\n  match arg with\n  | .type ty => if ptrEq ty type' then arg else .type type'\n  | _ => unreachable!", "start": [63, 1], "end": [66, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.updateType!", "code": "@[implemented_by Arg.updateTypeImp] opaque Arg.updateType! (arg : Arg) (type : Expr) : Arg", "start": [68, 1], "end": [68, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.updateFVarImp", "code": "private unsafe def Arg.updateFVarImp (arg : Arg) (fvarId' : FVarId) : Arg :=\n  match arg with\n  | .fvar fvarId => if fvarId' == fvarId then arg else .fvar fvarId'\n  | _ => unreachable!", "start": [70, 1], "end": [73, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.updateFVar!", "code": "@[implemented_by Arg.updateFVarImp] opaque Arg.updateFVar! (arg : Arg) (fvarId' : FVarId) : Arg", "start": [75, 1], "end": [75, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue", "code": "inductive LetValue where\n  | value (value : LitValue)\n  | erased\n  | proj (typeName : Name) (idx : Nat) (struct : FVarId)\n  | const (declName : Name) (us : List Level) (args : Array Arg)\n  | fvar (fvarId : FVarId) (args : Array Arg)\n  deriving Inhabited, BEq, Hashable", "start": [77, 1], "end": [84, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.toLetValue", "code": "def Arg.toLetValue (arg : Arg) : LetValue :=\n  match arg with\n  | .fvar fvarId => .fvar fvarId #[]\n  | .erased | .type .. => .erased", "start": [86, 1], "end": [89, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.updateProjImp", "code": "private unsafe def LetValue.updateProjImp (e : LetValue) (fvarId' : FVarId) : LetValue :=\n  match e with\n  | .proj s i fvarId => if fvarId == fvarId' then e else .proj s i fvarId'\n  | _ => unreachable!", "start": [91, 1], "end": [94, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.updateProj!", "code": "@[implemented_by LetValue.updateProjImp] opaque LetValue.updateProj! (e : LetValue) (fvarId' : FVarId) : LetValue", "start": [96, 1], "end": [96, 114], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.updateConstImp", "code": "private unsafe def LetValue.updateConstImp (e : LetValue) (declName' : Name) (us' : List Level) (args' : Array Arg) : LetValue :=\n  match e with\n  | .const declName us args => if declName == declName' && ptrEq us us' && ptrEq args args' then e else .const declName' us' args'\n  | _ => unreachable!", "start": [98, 1], "end": [101, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.updateConst!", "code": "@[implemented_by LetValue.updateConstImp] opaque LetValue.updateConst! (e : LetValue) (declName' : Name) (us' : List Level) (args' : Array Arg) : LetValue", "start": [103, 1], "end": [103, 155], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.updateFVarImp", "code": "private unsafe def LetValue.updateFVarImp (e : LetValue) (fvarId' : FVarId) (args' : Array Arg) : LetValue :=\n  match e with\n  | .fvar fvarId args => if fvarId == fvarId' && ptrEq args args' then e else .fvar fvarId' args'\n  | _ => unreachable!", "start": [105, 1], "end": [108, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.updateFVar!", "code": "@[implemented_by LetValue.updateFVarImp] opaque LetValue.updateFVar! (e : LetValue) (fvarId' : FVarId) (args' : Array Arg) : LetValue", "start": [110, 1], "end": [110, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.updateArgsImp", "code": "private unsafe def LetValue.updateArgsImp (e : LetValue) (args' : Array Arg) : LetValue :=\n  match e with\n  | .const declName us args => if ptrEq args args' then e else .const declName us args'\n  | .fvar fvarId args => if ptrEq args args' then e else .fvar fvarId args'\n  | _ => unreachable!", "start": [112, 1], "end": [116, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.updateArgs!", "code": "@[implemented_by LetValue.updateArgsImp] opaque LetValue.updateArgs! (e : LetValue) (args' : Array Arg) : LetValue", "start": [118, 1], "end": [118, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetValue.toExpr", "code": "def LetValue.toExpr (e : LetValue) : Expr :=\n  match e with\n  | .value (.natVal val) => .lit (.natVal val)\n  | .value (.strVal val) => .lit (.strVal val)\n  | .erased => erasedExpr\n  | .proj n i s => .proj n i (.fvar s)\n  | .const n us as => mkAppN (.const n us) (as.map Arg.toExpr)\n  | .fvar fvarId as => mkAppN (.fvar fvarId) (as.map Arg.toExpr)", "start": [120, 1], "end": [127, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl", "code": "structure LetDecl where\n  fvarId : FVarId\n  binderName : Name\n  type : Expr\n  value : LetValue\n  deriving Inhabited, BEq", "start": [129, 1], "end": [134, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore", "code": "structure FunDeclCore (Code : Type) where\n  fvarId : FVarId\n  binderName : Name\n  params : Array Param\n  type : Expr\n  value : Code\n  deriving Inhabited", "start": [136, 1], "end": [142, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.getArity", "code": "def FunDeclCore.getArity (decl : FunDeclCore Code) : Nat :=\n  decl.params.size", "start": [144, 1], "end": [145, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CasesCore", "code": "structure CasesCore (Code : Type) where\n  typeName : Name\n  resultType : Expr\n  discr : FVarId\n  alts : Array (AltCore Code)\n  deriving Inhabited", "start": [147, 1], "end": [152, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code", "code": "inductive Code where\n  | let (decl : LetDecl) (k : Code)\n  | fun (decl : FunDeclCore Code) (k : Code)\n  | jp (decl : FunDeclCore Code) (k : Code)\n  | jmp (fvarId : FVarId) (args : Array Arg)\n  | cases (cases : CasesCore Code)\n  | return (fvarId : FVarId)\n  | unreach (type : Expr)\n  deriving Inhabited", "start": [154, 1], "end": [162, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Alt", "code": "abbrev Alt := AltCore Code", "start": [164, 1], "end": [164, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDecl", "code": "abbrev FunDecl := FunDeclCore Code", "start": [165, 1], "end": [165, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Cases", "code": "abbrev Cases := CasesCore Code", "start": [166, 1], "end": [166, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CasesCore.getCtorNames", "code": "def CasesCore.getCtorNames (c : Cases) : NameSet :=\n  c.alts.foldl (init := {}) fun ctorNames alt =>\n    match alt with\n    | .default _ => ctorNames\n    | .alt ctorName .. => ctorNames.insert ctorName", "start": [168, 1], "end": [175, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CodeDecl", "code": "inductive CodeDecl where\n  | let (decl : LetDecl)\n  | fun (decl : FunDecl)\n  | jp (decl : FunDecl)\n  deriving Inhabited", "start": [177, 1], "end": [181, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CodeDecl.fvarId", "code": "def CodeDecl.fvarId : CodeDecl \u2192 FVarId\n  | .let decl | .fun decl | .jp decl => decl.fvarId", "start": [183, 1], "end": [184, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.attachCodeDecls", "code": "def attachCodeDecls (decls : Array CodeDecl) (code : Code) : Code :=\n  go decls.size code\nwhere\n  go (i : Nat) (code : Code) : Code :=\n    if i > 0 then\n      match decls[i-1]! with\n      | .let decl => go (i-1) (.let decl code)\n      | .fun decl => go (i-1) (.fun decl code)\n      | .jp decl => go (i-1) (.jp decl code)\n    else\n      code", "start": [186, 1], "end": [196, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eqImp", "code": "private unsafe def eqImp (c\u2081 c\u2082 : Code) : Bool :=\n    if ptrEq c\u2081 c\u2082 then\n      true\n    else match c\u2081, c\u2082 with\n      | .let d\u2081 k\u2081, .let d\u2082 k\u2082 => d\u2081 == d\u2082 && eqImp k\u2081 k\u2082\n      | .fun d\u2081 k\u2081, .fun d\u2082 k\u2082\n      | .jp d\u2081 k\u2081, .jp d\u2082 k\u2082 => eqFunDecl d\u2081 d\u2082 && eqImp k\u2081 k\u2082\n      | .cases c\u2081, .cases c\u2082 => eqCases c\u2081 c\u2082\n      | .jmp j\u2081 as\u2081, .jmp j\u2082 as\u2082 => j\u2081 == j\u2082 && as\u2081 == as\u2082\n      | .return r\u2081, .return r\u2082 => r\u2081 == r\u2082\n      | .unreach t\u2081, .unreach t\u2082 => t\u2081 == t\u2082\n      | _, _ => false", "start": [199, 3], "end": [210, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eqFunDecl", "code": "private unsafe def eqFunDecl (d\u2081 d\u2082 : FunDecl) : Bool :=\n    if ptrEq d\u2081 d\u2082 then\n      true\n    else\n      d\u2081.fvarId == d\u2082.fvarId && d\u2081.binderName == d\u2082.binderName &&\n      d\u2081.params == d\u2082.params && d\u2081.type == d\u2082.type &&\n      eqImp d\u2081.value d\u2082.value", "start": [212, 3], "end": [218, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eqCases", "code": "private unsafe def eqCases (c\u2081 c\u2082 : Cases) : Bool :=\n    c\u2081.resultType == c\u2082.resultType && c\u2081.discr == c\u2082.discr &&\n    c\u2081.typeName == c\u2082.typeName && c\u2081.alts.isEqv c\u2082.alts eqAlt", "start": [220, 3], "end": [222, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eqAlt", "code": "private unsafe def eqAlt (a\u2081 a\u2082 : Alt) : Bool :=\n    match a\u2081, a\u2082 with\n    | .default k\u2081, .default k\u2082 => eqImp k\u2081 k\u2082\n    | .alt c\u2081 ps\u2081 k\u2081, .alt c\u2082 ps\u2082 k\u2082 => c\u2081 == c\u2082 && ps\u2081 == ps\u2082 && eqImp k\u2081 k\u2082\n    | _, _ => false", "start": [224, 3], "end": [228, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.beq", "code": "@[implemented_by eqImp] protected opaque Code.beq : Code \u2192 Code \u2192 Bool", "start": [231, 1], "end": [231, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDecl.beq", "code": "@[implemented_by eqFunDecl] protected opaque FunDecl.beq : FunDecl \u2192 FunDecl \u2192 Bool", "start": [236, 1], "end": [236, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AltCore.getCode", "code": "def AltCore.getCode : Alt \u2192 Code\n  | .default k => k\n  | .alt _ _ k => k", "start": [241, 1], "end": [243, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AltCore.getParams", "code": "def AltCore.getParams : Alt \u2192 Array Param\n  | .default _ => #[]\n  | .alt _ ps _ => ps", "start": [245, 1], "end": [247, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AltCore.forCodeM", "code": "def AltCore.forCodeM [Monad m] (alt : Alt) (f : Code \u2192 m Unit) : m Unit := do\n  match alt with\n  | .default k => f k\n  | .alt _ _ k => f k", "start": [249, 1], "end": [252, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateAltCodeImp", "code": "private unsafe def updateAltCodeImp (alt : Alt) (k' : Code) : Alt :=\n  match alt with\n  | .default k => if ptrEq k k' then alt else .default k'\n  | .alt ctorName ps k => if ptrEq k k' then alt else .alt ctorName ps k'", "start": [254, 1], "end": [257, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AltCore.updateCode", "code": "@[implemented_by updateAltCodeImp] opaque AltCore.updateCode (alt : Alt) (c : Code) : Alt", "start": [259, 1], "end": [259, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateAltImp", "code": "private unsafe def updateAltImp (alt : Alt) (ps' : Array Param) (k' : Code) : Alt :=\n  match alt with\n  | .alt ctorName ps k => if ptrEq k k' && ptrEq ps ps' then alt else .alt ctorName ps' k'\n  | _ => unreachable!", "start": [261, 1], "end": [264, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AltCore.updateAlt!", "code": "@[implemented_by updateAltImp] opaque AltCore.updateAlt! (alt : Alt) (ps' : Array Param) (k' : Code) : Alt", "start": [266, 1], "end": [266, 107], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateAltsImp", "code": "@[inline] private unsafe def updateAltsImp (c : Code) (alts : Array Alt) : Code :=\n  match c with\n  | .cases cs => if ptrEq cs.alts alts then c else .cases { cs with alts }\n  | _ => unreachable!", "start": [268, 1], "end": [271, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.updateAlts!", "code": "@[implemented_by updateAltsImp] opaque Code.updateAlts! (c : Code) (alts : Array Alt) : Code", "start": [273, 1], "end": [273, 93], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateCasesImp", "code": "@[inline] private unsafe def updateCasesImp (c : Code) (resultType : Expr) (discr : FVarId) (alts : Array Alt) : Code :=\n  match c with\n  | .cases cs => if ptrEq cs.alts alts && ptrEq cs.resultType resultType && cs.discr == discr then c else .cases { cs with discr, resultType, alts }\n  | _ => unreachable!", "start": [275, 1], "end": [278, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.updateCases!", "code": "@[implemented_by updateCasesImp] opaque Code.updateCases! (c : Code) (resultType : Expr) (discr : FVarId) (alts : Array Alt) : Code", "start": [280, 1], "end": [280, 132], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateLetImp", "code": "@[inline] private unsafe def updateLetImp (c : Code) (decl' : LetDecl) (k' : Code) : Code :=\n  match c with\n  | .let decl k => if ptrEq k k' && ptrEq decl decl' then c else .let decl' k'\n  | _ => unreachable!", "start": [282, 1], "end": [285, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.updateLet!", "code": "@[implemented_by updateLetImp] opaque Code.updateLet! (c : Code) (decl' : LetDecl) (k' : Code) : Code", "start": [287, 1], "end": [287, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateContImp", "code": "@[inline] private unsafe def updateContImp (c : Code) (k' : Code) : Code :=\n  match c with\n  | .let decl k => if ptrEq k k' then c else .let decl k'\n  | .fun decl k => if ptrEq k k' then c else .fun decl k'\n  | .jp decl k => if ptrEq k k' then c else .jp decl k'\n  | _ => unreachable!", "start": [289, 1], "end": [294, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.updateCont!", "code": "@[implemented_by updateContImp] opaque Code.updateCont! (c : Code) (k' : Code) : Code", "start": [296, 1], "end": [296, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateFunImp", "code": "@[inline] private unsafe def updateFunImp (c : Code) (decl' : FunDecl) (k' : Code) : Code :=\n  match c with\n  | .fun decl k => if ptrEq k k' && ptrEq decl decl' then c else .fun decl' k'\n  | .jp decl k => if ptrEq k k' && ptrEq decl decl' then c else .jp decl' k'\n  | _ => unreachable!", "start": [298, 1], "end": [302, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.updateFun!", "code": "@[implemented_by updateFunImp] opaque Code.updateFun! (c : Code) (decl' : FunDecl) (k' : Code) : Code", "start": [304, 1], "end": [304, 102], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateReturnImp", "code": "@[inline] private unsafe def updateReturnImp (c : Code) (fvarId' : FVarId) : Code :=\n  match c with\n  | .return fvarId => if fvarId == fvarId' then c else .return fvarId'\n  | _ => unreachable!", "start": [306, 1], "end": [309, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.updateReturn!", "code": "@[implemented_by updateReturnImp] opaque Code.updateReturn! (c : Code) (fvarId' : FVarId) : Code", "start": [311, 1], "end": [311, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateJmpImp", "code": "@[inline] private unsafe def updateJmpImp (c : Code) (fvarId' : FVarId) (args' : Array Arg) : Code :=\n  match c with\n  | .jmp fvarId args => if fvarId == fvarId' && ptrEq args args' then c else .jmp fvarId' args'\n  | _ => unreachable!", "start": [313, 1], "end": [316, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.updateJmp!", "code": "@[implemented_by updateJmpImp] opaque Code.updateJmp! (c : Code) (fvarId' : FVarId) (args' : Array Arg) : Code", "start": [318, 1], "end": [318, 111], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateUnreachImp", "code": "@[inline] private unsafe def updateUnreachImp (c : Code) (type' : Expr) : Code :=\n  match c with\n  | .unreach type => if ptrEq type type' then c else .unreach type'\n  | _ => unreachable!", "start": [320, 1], "end": [323, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.updateUnreach!", "code": "@[implemented_by updateUnreachImp] opaque Code.updateUnreach! (c : Code) (type' : Expr) : Code", "start": [325, 1], "end": [325, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateParamCoreImp", "code": "private unsafe def updateParamCoreImp (p : Param) (type : Expr) : Param :=\n  if ptrEq type p.type then\n    p\n  else\n    { p with type }", "start": [327, 1], "end": [331, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Param.updateCore", "code": "@[implemented_by updateParamCoreImp] opaque Param.updateCore (p : Param) (type : Expr) : Param", "start": [333, 1], "end": [338, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateLetDeclCoreImp", "code": "private unsafe def updateLetDeclCoreImp (decl : LetDecl) (type : Expr) (value : LetValue) : LetDecl :=\n  if ptrEq type decl.type && ptrEq value decl.value then\n    decl\n  else\n    { decl with type, value }", "start": [340, 1], "end": [344, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl.updateCore", "code": "@[implemented_by updateLetDeclCoreImp] opaque LetDecl.updateCore (decl : LetDecl) (type : Expr) (value : LetValue) : LetDecl", "start": [346, 1], "end": [351, 125], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateFunDeclCoreImp", "code": "private unsafe def updateFunDeclCoreImp (decl: FunDecl) (type : Expr) (params : Array Param) (value : Code) : FunDecl :=\n  if ptrEq type decl.type && ptrEq params decl.params && ptrEq value decl.value then\n    decl\n  else\n    { decl with type, params, value }", "start": [353, 1], "end": [357, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.updateCore", "code": "@[implemented_by updateFunDeclCoreImp] opaque FunDeclCore.updateCore (decl: FunDecl) (type : Expr) (params : Array Param) (value : Code) : FunDecl", "start": [359, 1], "end": [364, 147], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CasesCore.extractAlt!", "code": "def CasesCore.extractAlt! (cases : Cases) (ctorName : Name) : Alt \u00d7 Cases :=\n  let found (i : Nat) := (cases.alts[i]!, { cases with alts := cases.alts.eraseIdx i })\n  if let some i := cases.alts.findIdx? fun | .alt ctorName' .. => ctorName == ctorName' | _ => false then\n    found i\n  else if let some i := cases.alts.findIdx? fun | .default _ => true | _ => false then\n    found i\n  else\n    unreachable!", "start": [366, 1], "end": [373, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.AltCore.mapCodeM", "code": "def AltCore.mapCodeM [Monad m] (alt : Alt) (f : Code \u2192 m Code) : m Alt := do\n  return alt.updateCode (\u2190 f alt.getCode)", "start": [375, 1], "end": [376, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.isDecl", "code": "def Code.isDecl : Code \u2192 Bool\n  | .let .. | .fun .. | .jp .. => true\n  | _ => false", "start": [378, 1], "end": [380, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.isFun", "code": "def Code.isFun : Code \u2192 Bool\n  | .fun .. => true\n  | _ => false", "start": [382, 1], "end": [384, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.isReturnOf", "code": "def Code.isReturnOf : Code \u2192 FVarId \u2192 Bool\n  | .return fvarId, fvarId' => fvarId == fvarId'\n  | _, _ => false", "start": [386, 1], "end": [388, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.size", "code": "partial def Code.size (c : Code) : Nat :=\n  go c 0\nwhere\n  go (c : Code) (n : Nat) : Nat :=\n    match c with\n    | .let _ k => go k (n+1)\n    | .jp decl k | .fun decl k => go k <| go decl.value n\n    | .cases c => c.alts.foldl (init := n+1) fun n alt => go alt.getCode (n+1)\n    | .jmp .. => n+1\n    | .return .. | unreach .. => n", "start": [390, 1], "end": [399, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.sizeLe", "code": "partial def Code.sizeLe (c : Code) (n : Nat) : Bool :=\n  match go c |>.run 0 with\n  | .ok .. => true\n  | .error .. => false\nwhere\n  inc : EStateM Unit Nat Unit := do\n    modify (\u00b7+1)\n    unless (\u2190 get) <= n do throw ()\n\n  go (c : Code) : EStateM Unit Nat Unit := do\n    match c with\n    | .let _ k => inc; go k\n    | .jp decl k | .fun decl k => inc; go decl.value; go k\n    | .cases c => inc; c.alts.forM fun alt => go alt.getCode\n    | .jmp .. => inc\n    | .return .. | unreach .. => return ()", "start": [401, 1], "end": [417, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.forM", "code": "partial def Code.forM [Monad m] (c : Code) (f : Code \u2192 m Unit) : m Unit :=\n  go c\nwhere\n  go (c : Code) : m Unit := do\n    f c\n    match c with\n    | .let _ k => go k\n    | .fun decl k | .jp decl k => go decl.value; go k\n    | .cases c => c.alts.forM fun alt => go alt.getCode\n    | .unreach .. | .return .. | .jmp .. => return ()", "start": [419, 1], "end": [428, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl", "code": "structure Decl where\n  \n  name  : Name\n  \n  levelParams : List Name\n  \n  type  : Expr\n  \n  params : Array Param\n  \n  value : Code\n  \n  recursive : Bool := false\n  \n  safe : Bool := true\n  \n  inlineAttr? : Option InlineAttributeKind\n  deriving Inhabited, BEq", "start": [430, 1], "end": [496, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.size", "code": "def Decl.size (decl : Decl) : Nat :=\n  decl.value.size", "start": [498, 1], "end": [499, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.getArity", "code": "def Decl.getArity (decl : Decl) : Nat :=\n  decl.params.size", "start": [501, 1], "end": [502, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.inlineAttr", "code": "def Decl.inlineAttr (decl : Decl) : Bool :=\n  decl.inlineAttr? matches some .inline", "start": [504, 1], "end": [505, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.noinlineAttr", "code": "def Decl.noinlineAttr (decl : Decl) : Bool :=\n  decl.inlineAttr? matches some .noinline", "start": [507, 1], "end": [508, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.inlineIfReduceAttr", "code": "def Decl.inlineIfReduceAttr (decl : Decl) : Bool :=\n  decl.inlineAttr? matches some .inlineIfReduce", "start": [510, 1], "end": [511, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.alwaysInlineAttr", "code": "def Decl.alwaysInlineAttr (decl : Decl) : Bool :=\n  decl.inlineAttr? matches some .alwaysInline", "start": [513, 1], "end": [514, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.inlineable", "code": "def Decl.inlineable (decl : Decl) : Bool :=\n  match decl.inlineAttr? with\n  | some .noinline => false\n  | some _ => true\n  | none => false", "start": [516, 1], "end": [521, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.isCasesOnParam?", "code": "def Decl.isCasesOnParam? (decl : Decl) : Option Nat :=\n  go decl.value\nwhere\n  go (code : Code) : Option Nat :=\n    match code with\n    | .let _ k | .jp _ k | .fun _ k => go k\n    | .cases c => decl.params.findIdx? fun param => param.fvarId == c.discr\n    | _ => none", "start": [523, 1], "end": [543, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.instantiateTypeLevelParams", "code": "def Decl.instantiateTypeLevelParams (decl : Decl) (us : List Level) : Expr :=\n  decl.type.instantiateLevelParamsNoCache decl.levelParams us", "start": [545, 1], "end": [546, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.instantiateParamsLevelParams", "code": "def Decl.instantiateParamsLevelParams (decl : Decl) (us : List Level) : Array Param :=\n  decl.params.mapMono fun param => param.updateCore (param.type.instantiateLevelParamsNoCache decl.levelParams us)", "start": [548, 1], "end": [549, 115], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.instantiateValueLevelParams", "code": "partial def Decl.instantiateValueLevelParams (decl : Decl) (us : List Level) : Code :=\n  instCode decl.value\nwhere\n  instLevel (u : Level) :=\n    u.instantiateParams decl.levelParams us\n\n  instExpr (e : Expr) :=\n    e.instantiateLevelParamsNoCache decl.levelParams us\n\n  instParams (ps : Array Param) :=\n    ps.mapMono fun p => p.updateCore (instExpr p.type)\n\n  instAlt (alt : Alt) :=\n    match alt with\n    | .default k => alt.updateCode (instCode k)\n    | .alt _ ps k => alt.updateAlt! (instParams ps) (instCode k)\n\n  instArg (arg : Arg) : Arg :=\n    match arg with\n    | .type e => arg.updateType! (instExpr e)\n    | .fvar .. | .erased => arg\n\n  instLetValue (e : LetValue) : LetValue :=\n    match e with\n    | .const declName vs args => e.updateConst! declName (vs.mapMono instLevel) (args.mapMono instArg)\n    | .fvar fvarId args => e.updateFVar! fvarId (args.mapMono instArg)\n    | .proj .. | .value .. | .erased => e\n\n  instLetDecl (decl : LetDecl) :=\n    decl.updateCore (instExpr decl.type) (instLetValue decl.value)\n\n  instFunDecl (decl : FunDecl) :=\n    decl.updateCore (instExpr decl.type) (instParams decl.params) (instCode decl.value)\n\n  instCode (code : Code) :=\n    match code with\n    | .let decl k => code.updateLet! (instLetDecl decl) (instCode k)\n    | .jp decl k | .fun decl k => code.updateFun! (instFunDecl decl) (instCode k)\n    | .cases c => code.updateCases! (instExpr c.resultType) c.discr (c.alts.mapMono instAlt)\n    | .jmp fvarId args => code.updateJmp! fvarId (args.mapMono instArg)\n    | .return .. => code\n    | .unreach type => code.updateUnreach! (instExpr type)", "start": [551, 1], "end": [592, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.hasLocalInst", "code": "def hasLocalInst (type : Expr) : Bool :=\n  match type with\n  | .forallE _ _ b bi => bi.isInstImplicit || hasLocalInst b\n  | _ => false", "start": [594, 1], "end": [600, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.isTemplateLike", "code": "def Decl.isTemplateLike (decl : Decl) : CoreM Bool := do\n  if hasLocalInst decl.type then\n    return true else if (\u2190 Meta.isInstance decl.name) then\n    return true else if decl.inlineable || hasSpecializeAttribute (\u2190 getEnv) decl.name then\n    return true else\n    return false", "start": [602, 1], "end": [613, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectType", "code": "private partial def collectType (e : Expr) : FVarIdSet \u2192 FVarIdSet :=\n  match e with\n  | .forallE _ d b _ => collectType b \u2218 collectType d\n  | .lam _ d b _     => collectType b \u2218 collectType d\n  | .app f a         => collectType f \u2218 collectType a\n  | .fvar fvarId     => fun s => s.insert fvarId\n  | .proj .. | .letE .. | .mdata .. => unreachable!\n  | _                => id", "start": [615, 1], "end": [622, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectArg", "code": "private def collectArg (arg : Arg) (s : FVarIdSet) : FVarIdSet :=\n  match arg with\n  | .erased => s\n  | .fvar fvarId => s.insert fvarId\n  | .type e => collectType e s", "start": [624, 1], "end": [628, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectArgs", "code": "private def collectArgs (args : Array Arg) (s : FVarIdSet) : FVarIdSet :=\n  args.foldl (init := s) fun s arg => collectArg arg s", "start": [630, 1], "end": [631, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectLetValue", "code": "private def collectLetValue (e : LetValue) (s : FVarIdSet) : FVarIdSet :=\n  match e with\n  | .fvar fvarId args => collectArgs args <| s.insert fvarId\n  | .const _ _ args => collectArgs args s\n  | .proj _ _ fvarId => s.insert fvarId\n  | .value .. | .erased => s", "start": [633, 1], "end": [638, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectParams", "code": "private partial def collectParams (ps : Array Param) (s : FVarIdSet) : FVarIdSet :=\n  ps.foldl (init := s) fun s p => collectType p.type s", "start": [640, 1], "end": [641, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.collectUsed", "code": "partial def FunDeclCore.collectUsed (decl : FunDecl) (s : FVarIdSet := {}) : FVarIdSet :=\n  decl.value.collectUsed <| collectParams decl.params <| collectType decl.type s", "start": [644, 1], "end": [645, 81], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Code.collectUsed", "code": "partial def Code.collectUsed (code : Code) (s : FVarIdSet := {}) : FVarIdSet :=\n  match code with\n  | .let decl k => k.collectUsed <| collectLetValue decl.value <| collectType decl.type s\n  | .jp decl k | .fun decl k => k.collectUsed <| decl.collectUsed s\n  | .cases c =>\n    let s := s.insert c.discr\n    let s := collectType c.resultType s\n    c.alts.foldl (init := s) fun s alt =>\n      match alt with\n      | .default k => k.collectUsed s\n      | .alt _ ps k => k.collectUsed <| collectParams ps s\n  | .return fvarId => s.insert fvarId\n  | .unreach type => collectType type s\n  | .jmp fvarId args => collectArgs args <| s.insert fvarId", "start": [647, 1], "end": [660, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.collectUsedAtExpr", "code": "abbrev collectUsedAtExpr (s : FVarIdSet) (e : Expr) : FVarIdSet :=\n  collectType e s", "start": [663, 1], "end": [664, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.markRecDecls", "code": "partial def markRecDecls (decls : Array Decl) : Array Decl :=\n  let (_, isRec) := go |>.run {}\n  decls.map fun decl =>\n    if isRec.contains decl.name then\n      { decl with recursive := true }\n    else\n      decl\nwhere\n  visit (code : Code) : StateM NameSet Unit := do\n    match code with\n    | .jp decl k | .fun decl k => visit decl.value; visit k\n    | .cases c => c.alts.forM fun alt => visit alt.getCode\n    | .unreach .. | .jmp .. | .return .. => return ()\n    | .let decl k =>\n      if let .const declName _ _ := decl.value then\n        if decls.any (\u00b7.name == declName) then\n          modify fun s => s.insert declName\n      visit k\n\n  go : StateM NameSet Unit :=\n    decls.forM fun decl => visit decl.value", "start": [666, 1], "end": [694, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.instantiateRangeArgs", "code": "def instantiateRangeArgs (e : Expr) (beginIdx endIdx : Nat) (args : Array Arg) : Expr :=\n  if !e.hasLooseBVars then\n    e\n  else\n    e.instantiateRange beginIdx endIdx (args.map (\u00b7.toExpr))", "start": [696, 1], "end": [700, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.instantiateRevRangeArgs", "code": "def instantiateRevRangeArgs (e : Expr) (beginIdx endIdx : Nat) (args : Array Arg) : Expr :=\n  if !e.hasLooseBVars then\n    e\n  else\n    e.instantiateRevRange beginIdx endIdx (args.map (\u00b7.toExpr))", "start": [702, 1], "end": [706, 64], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/OpenPrivate.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/FoldConsts.lean", "lake-packages/lean4/src/lean/Lean/Parser/Module.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.collectPrivateIn", "code": "def Meta.collectPrivateIn [Monad m] [MonadEnv m] [MonadError m]\n  (n : Name) (set := NameSet.empty) : m NameSet := do\n  let c \u2190 getConstInfo n\n  let traverse value := Expr.foldConsts value set fun c a =>\n    if isPrivateName c then a.insert c else a\n  if let some value := c.value? then return traverse value\n  if let some c := (\u2190 getEnv).find? (n ++ `_cstage1) then\n    if let some value := c.value? then return traverse value\n  return traverse c.type", "start": [14, 1], "end": [23, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.moduleIdxForModule?", "code": "def Environment.moduleIdxForModule? (env : Environment) (mod : Name) : Option ModuleIdx :=\n  (env.allImportedModuleNames.indexOf? mod).map fun idx => idx.val", "start": [25, 1], "end": [27, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Environment.declsInModuleIdx", "code": "def Environment.declsInModuleIdx (env : Environment) (idx : ModuleIdx) : List Name :=\n  env.const2ModIdx.fold (fun acc n i => if i = idx then n :: acc else acc) []", "start": [31, 1], "end": [33, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.addModuleInfo", "code": "def Elab.addModuleInfo [Monad m] [MonadInfoTree m] (stx : Ident) : m Unit := do\n  pushInfoLeaf <| .ofCommandInfo {\n    elaborator := `import\n    stx := Unhygienic.run `(Parser.Module.import| import $stx) |>.raw.copyHeadTailInfoFrom stx\n  }", "start": [35, 1], "end": [43, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabOpenPrivateLike", "code": "def elabOpenPrivateLike (ids : Array Ident) (tgts mods : Option (Array Ident))\n  (f : (priv full user : Name) \u2192 CommandElabM Name) : CommandElabM Unit := do\n  let mut names := NameSet.empty\n  for tgt in tgts.getD #[] do\n    let n \u2190 resolveGlobalConstNoOverloadWithInfo tgt\n    names \u2190 Meta.collectPrivateIn n names\n  for mod in mods.getD #[] do\n    let some modIdx := (\u2190 getEnv).moduleIdxForModule? mod.getId\n      | throwError \"unknown module {mod}\"\n    addModuleInfo mod\n    for declName in (\u2190 getEnv).declsInModuleIdx modIdx do\n      if isPrivateName declName then\n        names := names.insert declName\n  let appendNames (msg : String) : String := Id.run do\n    let mut msg := msg\n    for c in names do\n      if let some name := privateToUserName? c then\n        msg := msg ++ s!\"{name}\\n\"\n    msg\n  if ids.isEmpty && !names.isEmpty then\n    logInfo (appendNames \"found private declarations:\\n\")\n  let mut decls := #[]\n  for id in ids do\n    let n := id.getId\n    let mut found := []\n    for c in names do\n      if n.isSuffixOf c then\n        addConstInfo id c\n        found := c::found\n    match found with\n    | [] => throwError appendNames s!\"'{n}' not found in the provided declarations:\\n\"\n    | [c] =>\n      if let some name := privateToUserName? c then\n        let new \u2190 f c name n\n        decls := decls.push (OpenDecl.explicit n new)\n      else unreachable!\n    | _ => throwError s!\"provided name is ambiguous: found {found.map privateToUserName?}\"\n  modifyScope fun scope => Id.run do\n    let mut openDecls := scope.openDecls\n    for decl in decls do\n      openDecls := decl::openDecls\n    { scope with openDecls := openDecls }", "start": [47, 1], "end": [89, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabOpenPrivate", "code": "@[command_elab openPrivate] def elabOpenPrivate : CommandElab\n| `(open private $ids* $[in $tgts*]? $[from $mods*]?) =>\n  elabOpenPrivateLike ids tgts mods fun c _ _ => pure c\n| _ => throwUnsupportedSyntax", "start": [105, 1], "end": [109, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabExportPrivate", "code": "@[command_elab exportPrivate] def elabExportPrivate : CommandElab\n| `(export private $ids* $[in $tgts*]? $[from $mods*]?) =>\n  elabOpenPrivateLike ids tgts mods fun c name _ => liftCoreM do\n    let cinfo \u2190 getConstInfo c\n    if (\u2190 getEnv).contains name then\n      throwError s!\"'{name}' has already been declared\"\n    let decl := Declaration.defnDecl {\n      name := name,\n      levelParams := cinfo.levelParams,\n      type := cinfo.type,\n      value := mkConst c (cinfo.levelParams.map mkLevelParam),\n      hints := ReducibilityHints.abbrev,\n      safety := if cinfo.isUnsafe then DefinitionSafety.unsafe else DefinitionSafety.safe\n    }\n    addDecl decl\n    compileDecl decl\n    pure name\n| _ => throwUnsupportedSyntax", "start": [125, 1], "end": [143, 30], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/MacroArgUtil.lean", "lake-packages/lean4/src/lean/Lean/Elab/AuxDef.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.withExpectedType", "code": "def withExpectedType (expectedType? : Option Expr) (x : Expr \u2192 TermElabM Expr) : TermElabM Expr := do\n  Term.tryPostponeIfNoneOrMVar expectedType?\n  let some expectedType \u2190 pure expectedType?\n    | throwError \"expected type must be known\"\n  x expectedType", "start": [14, 1], "end": [18, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabElabRulesAux", "code": "def elabElabRulesAux (doc? : Option (TSyntax ``docComment))\n    (attrs? : Option (TSepArray ``attrInstance \",\")) (attrKind : TSyntax ``attrKind)\n    (k : SyntaxNodeKind) (cat? expty? : Option (Ident)) (alts : Array (TSyntax ``matchAlt)) :\n    CommandElabM Syntax := do\n  let alts \u2190 alts.mapM fun (alt : TSyntax ``matchAlt) => match alt with\n    | `(matchAltExpr| | $pats,* => $rhs) => do\n      let pat := pats.elemsAndSeps[0]!\n      if !pat.isQuot then\n        throwUnsupportedSyntax\n      let quoted := getQuotContent pat\n      let k' := quoted.getKind\n      if checkRuleKind k' k then\n        pure alt\n      else if k' == choiceKind then\n         match quoted.getArgs.find? fun quotAlt => checkRuleKind quotAlt.getKind k with\n         | none        => throwErrorAt alt \"invalid elab_rules alternative, expected syntax node kind '{k}'\"\n         | some quoted =>\n           let pat := pat.setArg 1 quoted\n           let pats := \u27e8pats.elemsAndSeps.set! 0 pat\u27e9\n           `(matchAltExpr| | $pats,* => $rhs)\n      else\n        throwErrorAt alt \"invalid elab_rules alternative, unexpected syntax node kind '{k'}'\"\n    | _ => throwUnsupportedSyntax\n  let catName \u2190 match cat?, expty? with\n    | some cat, _ => pure cat.getId\n    | _, some _   => pure `term\n    | _, _        => throwError \"invalid elab_rules command, specify category using `elab_rules : <cat> ...`\"\n  let mkAttrs (kind : Name) : CommandElabM (TSyntaxArray ``attrInstance) := do\n    let attr \u2190 `(attrInstance| $attrKind:attrKind $(mkIdent kind):ident $(\u2190 mkIdentFromRef k):ident)\n    pure <| match attrs? with\n      | some attrs => attrs.getElems.push attr\n      | none => #[attr]\n  if let some expId := expty? then\n    if catName == `term then\n      `($[$doc?:docComment]? @[$(\u2190 mkAttrs `term_elab),*]\n        aux_def elabRules $(mkIdent k) : Lean.Elab.Term.TermElab :=\n        fun stx expectedType? => Lean.Elab.Command.withExpectedType expectedType? fun $expId => match stx with\n          $alts:matchAlt* | _ => no_error_if_unused% throwUnsupportedSyntax)\n    else\n      throwErrorAt expId \"syntax category '{catName}' does not support expected type specification\"\n  else if catName == `term then\n    `($[$doc?:docComment]? @[$(\u2190 mkAttrs `term_elab),*]\n      aux_def elabRules $(mkIdent k) : Lean.Elab.Term.TermElab :=\n      fun stx _ => match stx with\n        $alts:matchAlt* | _ => no_error_if_unused% throwUnsupportedSyntax)\n  else if catName == `command then\n    `($[$doc?:docComment]? @[$(\u2190 mkAttrs `command_elab),*]\n      aux_def elabRules $(mkIdent k) : Lean.Elab.Command.CommandElab :=\n      fun $alts:matchAlt* | _ => no_error_if_unused% throwUnsupportedSyntax)\n  else if catName == `tactic || catName == `conv then\n    `($[$doc?:docComment]? @[$(\u2190 mkAttrs `tactic),*]\n      aux_def elabRules $(mkIdent k) : Lean.Elab.Tactic.Tactic :=\n      fun $alts:matchAlt* | _ => no_error_if_unused% throwUnsupportedSyntax)\n  else\n    throwError \"unsupported syntax category '{catName}'\"", "start": [20, 1], "end": [77, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabElabRules", "code": "@[builtin_command_elab \u00abelab_rules\u00bb] def elabElabRules : CommandElab :=\n  adaptExpander fun stx => match stx with\n  | `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind elab_rules $[: $cat?]? $[<= $expty?]? $alts:matchAlt*) =>\n    expandNoKindMacroRulesAux alts \"elab_rules\" fun kind? alts =>\n      `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind elab_rules $[(kind := $(mkIdent <$> kind?))]? $[: $cat?]? $[<= $expty?]? $alts:matchAlt*)\n  | `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind elab_rules (kind := $kind) $[: $cat?]? $[<= $expty?]? $alts:matchAlt*) =>\n    do elabElabRulesAux doc? attrs? attrKind (\u2190 resolveSyntaxKind kind.getId) cat? expty? alts\n  | _  => throwUnsupportedSyntax", "start": [79, 1], "end": [86, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabElab", "code": "@[builtin_command_elab Lean.Parser.Command.elab]\ndef elabElab : CommandElab\n  | `($[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind\n    elab%$tk$[:$prec?]? $[(name := $name?)]? $[(priority := $prio?)]? $args:macroArg* :\n      $cat $[<= $expectedType?]? => $rhs) => do\n    let prio    \u2190 liftMacroM <| evalOptPrio prio?\n    let (stxParts, patArgs) := (\u2190 args.mapM expandMacroArg).unzip\n    let name \u2190 match name? with\n      | some name => pure name.getId\n      | none => addMacroScopeIfLocal (\u2190 liftMacroM <| mkNameFromParserSyntax cat.getId (mkNullNode stxParts)) attrKind\n    let nameId := name?.getD (mkIdentFrom tk name (canonical := true))\n    let pat := \u27e8mkNode ((\u2190 getCurrNamespace) ++ name) patArgs\u27e9\n    elabCommand <|\u2190 `(\n      $[$doc?:docComment]? $[@[$attrs?,*]]? $attrKind:attrKind\n      syntax%$tk$[:$prec?]? (name := $nameId) (priority := $(quote prio):num) $[$stxParts]* : $cat\n      $[$doc?:docComment]? elab_rules : $cat $[<= $expectedType?]? | `($pat) => $rhs)\n  | _ => throwUnsupportedSyntax", "start": [88, 1], "end": [105, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Match.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/GeneralizeVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/Match.lean", "lake-packages/lean4/src/lean/Lean/Util/ForEachExprWhere.lean", "lake-packages/lean4/src/lean/Lean/Elab/Quotation/Precheck.lean", "lake-packages/lean4/src/lean/Lean/Meta/ForEachExpr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/BindersUtil.lean", "lake-packages/lean4/src/lean/Lean/Elab/PatternVar.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean"], "premises": [{"full_name": "Lean.Elab.Term.expandSimpleMatch", "code": "private def expandSimpleMatch (stx : Syntax) (discr : Term) (lhsVar : Ident) (rhs : Term) (expectedType? : Option Expr) : TermElabM Expr := do\n  let newStx \u2190 `(let $lhsVar := $discr; $rhs)\n  withMacroExpansion stx newStx <| elabTerm newStx expectedType?", "start": [19, 1], "end": [21, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkUserNameFor", "code": "private def mkUserNameFor (e : Expr) : TermElabM Name := do\n  match e with\n  \n  | .fvar fvarId => mkFreshUserName (\u2190 fvarId.getUserName)\n  | _            => mkFreshBinderName", "start": [23, 1], "end": [27, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isAtomicDiscr", "code": "def isAtomicDiscr (discr : Syntax) : TermElabM Bool := do\n  match discr with\n  | `($_:ident)  => pure true\n  | `(@$_:ident) => pure true\n  | `(?$_:ident) => pure true\n  | _ => if discr.isMissing then throwAbortTerm else pure false", "start": [30, 1], "end": [50, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabAtomicDiscr", "code": "private def elabAtomicDiscr (discr : Syntax) : TermElabM Expr := do\n  let term := discr[1]\n  elabTerm term none", "start": [53, 1], "end": [55, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.Discr", "code": "structure Discr where\n  expr : Expr\n  \n  h?  : Option Syntax := none\n  deriving Inhabited", "start": [57, 1], "end": [61, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ElabMatchTypeAndDiscrsResult", "code": "structure ElabMatchTypeAndDiscrsResult where\n  discrs    : Array Discr\n  matchType : Expr\n  \n  isDep     : Bool\n  alts      : Array MatchAltView", "start": [63, 1], "end": [69, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabMatchTypeAndDiscrs", "code": "private partial def elabMatchTypeAndDiscrs (discrStxs : Array Syntax) (matchOptMotive : Syntax) (matchAltViews : Array MatchAltView) (expectedType : Expr)\n      : TermElabM ElabMatchTypeAndDiscrsResult := do\n  if matchOptMotive.isNone then\n    elabDiscrs 0 #[]\n  else\n    let matchTypeStx := matchOptMotive[0][3]\n    let matchType \u2190 elabType matchTypeStx\n    let (discrs, isDep) \u2190 elabDiscrsWitMatchType matchType\n    return { discrs := discrs, matchType := matchType, isDep := isDep, alts := matchAltViews }\nwhere\n  \n  elabDiscrsWitMatchType (matchType : Expr) : TermElabM (Array Discr \u00d7 Bool) := do\n    let mut discrs := #[]\n    let mut i := 0\n    let mut matchType := matchType\n    let mut isDep := false\n    for discrStx in discrStxs do\n      i := i + 1\n      matchType \u2190 whnf matchType\n      match matchType with\n      | Expr.forallE _ d b _ =>\n        let discr \u2190 fullApproxDefEq <| elabTermEnsuringType discrStx[1] d\n        trace[Elab.match] \"discr #{i} {discr} : {d}\"\n        if b.hasLooseBVars then\n          isDep := true\n        matchType := b.instantiate1 discr\n        discrs := discrs.push { expr := discr }\n      | _ =>\n        throwError \"invalid motive provided to match-expression, function type with arity #{discrStxs.size} expected\"\n    return (discrs, isDep)\n\n  markIsDep (r : ElabMatchTypeAndDiscrsResult) :=\n    { r with isDep := true }\n\n  \n  elabDiscrs (i : Nat) (discrs : Array Discr) : TermElabM ElabMatchTypeAndDiscrsResult := do\n    if h : i < discrStxs.size then\n      let discrStx := discrStxs.get \u27e8i, h\u27e9\n      let discr     \u2190 elabAtomicDiscr discrStx\n      let discr     \u2190 instantiateMVars discr\n      let userName \u2190 mkUserNameFor discr\n      let h? := if discrStx[0].isNone then none else some discrStx[0][0]\n      let discrs := discrs.push { expr := discr, h? }\n      let mut result \u2190 elabDiscrs (i + 1) discrs\n      let matchTypeBody \u2190 kabstract result.matchType discr\n      if matchTypeBody.hasLooseBVars then\n        result := markIsDep result\n      \n      let discrType \u2190 transform (usedLetOnly := true) (\u2190 instantiateMVars (\u2190 inferType discr))\n      let matchType := Lean.mkForall userName BinderInfo.default discrType matchTypeBody\n      return { result with matchType }\n    else\n      return { discrs, alts := matchAltViews, isDep := false, matchType := expectedType }", "start": [71, 1], "end": [131, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandMacrosInPatterns", "code": "def expandMacrosInPatterns (matchAlts : Array MatchAltView) : MacroM (Array MatchAltView) := do\n  matchAlts.mapM fun matchAlt => do\n    let patterns \u2190 matchAlt.patterns.mapM expandMacros\n    pure { matchAlt with patterns := patterns }", "start": [133, 1], "end": [136, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getMatchGeneralizing?", "code": "private def getMatchGeneralizing? : Syntax \u2192 Option Bool\n  | `(match (generalizing := true)  $[$motive]? $_discrs,* with $_alts:matchAlt*) => some true\n  | `(match (generalizing := false) $[$motive]? $_discrs,* with $_alts:matchAlt*) => some false\n  | _ => none", "start": [138, 1], "end": [141, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getMatchAlts", "code": "private def getMatchAlts : Syntax \u2192 Array MatchAltView\n  | `(match $[$gen]? $[$motive]? $_discrs,* with $alts:matchAlt*) =>\n    alts.filterMap fun alt => match alt with\n      | `(matchAltExpr| | $patterns,* => $rhs) => some {\n          ref      := alt,\n          patterns := patterns,\n          rhs      := rhs\n        }\n      | _ => none\n  | _ => #[]", "start": [143, 1], "end": [153, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabInaccessible", "code": "@[builtin_term_elab inaccessible] def elabInaccessible : TermElab := fun stx expectedType? => do\n  let e \u2190 elabTerm stx[1] expectedType?\n  return mkInaccessible e", "start": [155, 1], "end": [157, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.precheckMatch", "code": "@[builtin_quot_precheck Lean.Parser.Term.match] def precheckMatch : Precheck\n  | `(match $[$discrs:term],* with $[| $[$patss],* => $rhss]*) => do\n    discrs.forM precheck\n    for (pats, rhs) in patss.zip rhss do\n      let vars \u2190 try\n        getPatternsVars pats\n      catch | _ => return  Quotation.withNewLocals (getPatternVarNames vars) <| precheck rhs\n  | _ => throwUnsupportedSyntax", "start": [160, 1], "end": [168, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.PatternVarDecl", "code": "structure PatternVarDecl where\n  fvarId : FVarId", "start": [170, 1], "end": [172, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withPatternVars", "code": "private partial def withPatternVars {\u03b1} (pVars : Array PatternVar) (k : Array PatternVarDecl \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n  let rec loop (i : Nat) (decls : Array PatternVarDecl) (userNames : Array Name) := do\n    if h : i < pVars.size then\n      let var := pVars.get \u27e8i, h\u27e9\n      let type \u2190 mkFreshTypeMVar\n      withLocalDecl var.getId BinderInfo.default type fun x =>\n        loop (i+1) (decls.push { fvarId := x.fvarId! }) (userNames.push Name.anonymous)\n    else\n      k decls\n  loop 0 #[] #[]", "start": [174, 1], "end": [183, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.PatternElabException", "code": "structure PatternElabException where\n  ex          : Exception\n  patternIdx  : Nat pathToIndex : List Nat", "start": [207, 1], "end": [212, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.findDiscrRefinementPath", "code": "private partial def findDiscrRefinementPath (pattern : Expr) (expected : Expr) : OptionT MetaM (List Nat) := do\n  goType (\u2190 instantiateMVars (\u2190 inferType pattern)) expected\nwhere\n  checkCompatibleApps (t d : Expr) : OptionT MetaM Unit := do\n    guard d.isApp\n    guard <| t.getAppNumArgs == d.getAppNumArgs\n    let tFn := t.getAppFn\n    let dFn := d.getAppFn\n    guard <| tFn.isConst && dFn.isConst\n    guard (\u2190 isDefEq tFn dFn)\n\n  goType (t d : Expr) : OptionT MetaM (List Nat) := do\n    let t \u2190 whnf t\n    let d \u2190 whnf d\n    checkCompatibleApps t d\n    matchConstInduct t.getAppFn (fun _ => failure) fun info _ => do\n      let tArgs := t.getAppArgs\n      let dArgs := d.getAppArgs\n      for i in [:info.numParams] do\n        let tArg := tArgs[i]!\n        let dArg := dArgs[i]!\n        unless (\u2190 isDefEq tArg dArg) do\n          return i :: (\u2190 goType tArg dArg)\n      for i in [info.numParams : tArgs.size] do\n        let tArg := tArgs[i]!\n        let dArg := dArgs[i]!\n        unless (\u2190 isDefEq tArg dArg) do\n          return i :: (\u2190 goIndex tArg dArg)\n      failure\n\n  goIndex (t d : Expr) : OptionT MetaM (List Nat) := do\n    let t \u2190 whnfD t\n    let d \u2190 whnfD d\n    if t.isFVar || d.isFVar then\n      return [] else\n      checkCompatibleApps t d\n      matchConstCtor t.getAppFn (fun _ => failure) fun info _ => do\n        let tArgs := t.getAppArgs\n        let dArgs := d.getAppArgs\n        for i in [:info.numParams] do\n          let tArg := tArgs[i]!\n          let dArg := dArgs[i]!\n          unless (\u2190 isDefEq tArg dArg) do\n            failure\n        for i in [info.numParams : tArgs.size] do\n          let tArg := tArgs[i]!\n          let dArg := dArgs[i]!\n          unless (\u2190 isDefEq tArg dArg) do\n            return i :: (\u2190 goIndex tArg dArg)\n        failure", "start": [214, 1], "end": [312, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.eraseIndices", "code": "private partial def eraseIndices (type : Expr) : MetaM Expr := do\n  let type' \u2190 whnfD type\n  matchConstInduct type'.getAppFn (fun _ => return type) fun info _ => do\n    let args := type'.getAppArgs\n    let params \u2190 args[:info.numParams].toArray.mapM eraseIndices\n    let result := mkAppN type'.getAppFn params\n    let resultType \u2190 inferType result\n    let (newIndices, _, _) \u2190  forallMetaTelescopeReducing resultType (some (args.size - info.numParams))\n    return mkAppN result newIndices", "start": [314, 1], "end": [322, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withPatternElabConfig", "code": "private def withPatternElabConfig (x : TermElabM \u03b1) : TermElabM \u03b1 :=\n  withoutErrToSorry <| withReader (fun ctx => { ctx with inPattern := true }) <| x", "start": [324, 1], "end": [325, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabPatterns", "code": "private def elabPatterns (patternStxs : Array Syntax) (matchType : Expr) : ExceptT PatternElabException TermElabM (Array Expr \u00d7 Expr) :=\n  withReader (fun ctx => { ctx with implicitLambda := false }) do\n    let mut patterns  := #[]\n    let mut matchType := matchType\n    for idx in [:patternStxs.size] do\n      let patternStx := patternStxs[idx]!\n      matchType \u2190 whnf matchType\n      match matchType with\n      | Expr.forallE _ d b _ =>\n        let pattern \u2190 do\n          let s \u2190 saveState\n          try\n            liftM <| withSynthesize <| withPatternElabConfig <| elabTermEnsuringType patternStx d\n          catch ex : Exception =>\n            restoreState s\n            match (\u2190 liftM <| commitIfNoErrors? <| withPatternElabConfig do elabTermAndSynthesize patternStx (\u2190 eraseIndices d)) with\n            | some pattern =>\n              match (\u2190 findDiscrRefinementPath pattern d |>.run) with\n              | some path =>\n                restoreState s\n                throwThe PatternElabException { ex := ex, patternIdx := idx, pathToIndex := path }\n              | none => restoreState s; throw ex\n            | none => throw ex\n        matchType := b.instantiate1 pattern\n        patterns  := patterns.push pattern\n      | _ => throwError \"unexpected match type\"\n    return (patterns, matchType)", "start": [327, 1], "end": [354, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.throwInvalidPattern", "code": "private def throwInvalidPattern (e : Expr) : MetaM \u03b1 :=\n  throwError \"invalid pattern {indentExpr e}\"", "start": [360, 1], "end": [361, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.State", "code": "structure State where\n  patternVars : Array Expr := #[]", "start": [363, 1], "end": [364, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.Context", "code": "structure Context where\n  \n  userName : Name := Name.anonymous\n  \n  explicitPatternVars : Array FVarId := #[]", "start": [366, 1], "end": [376, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.M", "code": "abbrev M := ReaderT Context $ StateRefT State TermElabM", "start": [378, 1], "end": [378, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.isExplicitPatternVar", "code": "def isExplicitPatternVar (e : Expr) : M Bool := do\n  if e.isFVar then\n    return (\u2190 read).explicitPatternVars.any (\u00b7 == e.fvarId!)\n  else\n    return false", "start": [380, 1], "end": [385, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.withMVar", "code": "private def withMVar (mvarId : MVarId) (x : M \u03b1) : M \u03b1 := do\n  let localDecl \u2190 getMVarDecl mvarId\n  if !localDecl.userName.isAnonymous && (\u2190 read).userName.isAnonymous then\n    withReader (fun ctx => { ctx with userName := localDecl.userName }) x\n  else\n    x", "start": [387, 1], "end": [400, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.mkPatternRefMap", "code": "private def mkPatternRefMap (e : Expr) : ExprMap Expr :=\n  runST go\nwhere\n  go (\u03c3) : ST \u03c3 (ExprMap Expr) := do\n   let map : ST.Ref \u03c3 (ExprMap Expr) \u2190 ST.mkRef {}\n   e.forEachWhere isPatternWithRef fun e => do\n     let some (_, b) := patternWithRef? e | unreachable!\n     map.modify (\u00b7.insert b e)\n   map.get", "start": [402, 1], "end": [415, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.applyRefMap", "code": "private def applyRefMap (e : Expr) (map : ExprMap Expr) : Expr :=\n  e.replace fun e =>\n    match patternWithRef? e with\n    | some _ => some e | none => match map.find? e with\n      | some eWithRef => some eWithRef | none => none", "start": [417, 1], "end": [428, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.whnfPreservingPatternRef", "code": "private def whnfPreservingPatternRef (e : Expr) : MetaM Expr := do\n  let eNew \u2190 whnf e\n  if eNew.isConstructorApp (\u2190 getEnv) then\n    return eNew\n  else\n    return applyRefMap eNew (mkPatternRefMap e)", "start": [430, 1], "end": [447, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.normalize", "code": "partial def normalize (e : Expr) : M Expr := do\n  match inaccessible? e with\n  | some e => processInaccessible e\n  | none =>\n  match patternWithRef? e with\n  | some (ref, e) => return mkPatternWithRef (\u2190 normalize e) ref\n  | none =>\n    match e.arrayLit? with\n    | some (\u03b1, lits) => mkArrayLit \u03b1 (\u2190 lits.mapM normalize)\n    | none =>\n      if let some e := Match.isNamedPattern? e then\n        let x := e.getArg! 1\n        let p := e.getArg! 2\n        let h := e.getArg! 3\n        unless x.consumeMData.isFVar && h.consumeMData.isFVar do\n          throwError \"unexpected occurrence of auxiliary declaration 'namedPattern'\"\n        addVar x\n        let p \u2190 normalize p\n        addVar h\n        return mkApp4 e.getAppFn (e.getArg! 0) x p h\n      else if isMatchValue e then\n        return e\n      else if e.isFVar then\n        if (\u2190 isExplicitPatternVar e) then\n          processVar e\n        else\n          return mkInaccessible e\n      else if e.getAppFn.isMVar then\n        let eNew \u2190 instantiateMVars e\n        if eNew != e then\n          withMVar e.getAppFn.mvarId! <| normalize eNew\n        else if e.isMVar then\n          withMVar e.mvarId! <| processVar e\n        else\n          throwInvalidPattern e\n      else\n        let eNew \u2190 whnfPreservingPatternRef e\n        if eNew != e then\n          normalize eNew\n        else\n          matchConstCtor e.getAppFn\n            (fun _ => return mkInaccessible (\u2190 eraseInaccessibleAnnotations (\u2190 instantiateMVars e)))\n            (fun v _ => do\n              let args := e.getAppArgs\n              unless args.size == v.numParams + v.numFields do\n                throwInvalidPattern e\n              let params := args.extract 0 v.numParams\n              let params \u2190 params.mapM fun p => instantiateMVars p\n              let fields := args.extract v.numParams args.size\n              let fields \u2190 fields.mapM normalize\n              return mkAppN e.getAppFn (params ++ fields))\nwhere\n  addVar (e : Expr) : M Unit := do\n    let e \u2190 erasePatternRefAnnotations e\n    unless (\u2190 get).patternVars.contains e do\n      modify fun s => { s with patternVars := s.patternVars.push e }\n\n  processVar (e : Expr) : M Expr := do\n    let e' \u2190 erasePatternRefAnnotations e\n    if (\u2190 get).patternVars.contains e' then\n      return mkInaccessible (\u2190 eraseInaccessibleAnnotations e)\n    else\n      if e'.isMVar then\n        e'.mvarId!.setTag (\u2190 read).userName\n      modify fun s => { s with patternVars := s.patternVars.push e' }\n      return e\n\n  processInaccessible (e : Expr) : M Expr := do\n    let e' \u2190 erasePatternRefAnnotations e\n    match e' with\n    | Expr.fvar _ =>\n      if (\u2190 isExplicitPatternVar e') then\n        processVar e\n      else\n        return mkInaccessible e\n    | _ =>\n      if e'.getAppFn.isMVar then\n        let eNew \u2190 instantiateMVars e'\n        if eNew != e' then\n          withMVar e'.getAppFn.mvarId! <| processInaccessible eNew\n        else if e'.isMVar then\n          withMVar e'.mvarId! <| processVar e'\n        else\n          throwInvalidPattern e\n      else\n        return mkInaccessible (\u2190 eraseInaccessibleAnnotations (\u2190 instantiateMVars e))", "start": [449, 1], "end": [540, 86], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.packMatchTypePatterns", "code": "private partial def packMatchTypePatterns (matchType : Expr) (ps : Array Expr) : MetaM Expr :=\n  ps.foldlM (init := matchType) fun result p => mkAppM ``PProd.mk #[result, p]", "start": [542, 1], "end": [546, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.unpackMatchTypePatterns", "code": "private partial def unpackMatchTypePatterns (p : Expr) : Expr \u00d7 Array Expr :=\n  if p.isAppOf ``PProd.mk then\n    let (matchType, ps) := unpackMatchTypePatterns (p.getArg! 2)\n    (matchType, ps.push (p.getArg! 3))\n  else\n    (p, #[])", "start": [548, 1], "end": [554, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.toPattern", "code": "private partial def toPattern (e : Expr) : MetaM Pattern := do\n  match inaccessible? e with\n  | some e => return Pattern.inaccessible e\n  | none =>\n    match e.arrayLit? with\n    | some (\u03b1, lits) => return Pattern.arrayLit \u03b1 (\u2190 lits.mapM toPattern)\n    | none =>\n      if let some e := Match.isNamedPattern? e then\n        let p \u2190 toPattern <| e.getArg! 2\n        match e.getArg! 1, e.getArg! 3 with\n        | Expr.fvar x, Expr.fvar h => return Pattern.as x p h\n        | _,           _           => throwError \"unexpected occurrence of auxiliary declaration 'namedPattern'\"\n      else if isMatchValue e then\n        return Pattern.val e\n      else if e.isFVar then\n        return Pattern.var e.fvarId!\n      else\n        matchConstCtor e.getAppFn (fun _ => unreachable!) fun v us => do\n          let args := e.getAppArgs\n          let params := args.extract 0 v.numParams\n          let params \u2190 params.mapM fun p => instantiateMVars p\n          let fields := args.extract v.numParams args.size\n          let fields \u2190 fields.mapM toPattern\n          return Pattern.ctor v.name us params.toList fields.toList", "start": [556, 1], "end": [584, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.TopSort.State", "code": "structure TopSort.State where\n  visitedFVars : FVarIdSet := {}\n  visitedMVars : MVarIdSet := {}\n  result       : Array Expr := #[]", "start": [586, 1], "end": [589, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.TopSortM", "code": "abbrev TopSortM := StateRefT TopSort.State TermElabM", "start": [591, 1], "end": [591, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.topSort", "code": "private partial def topSort (patternVars : Array Expr) : TermElabM (Array Expr) := do\n  let (_, s) \u2190 patternVars.mapM visit |>.run {}\n  return s.result\nwhere\n  visit (e : Expr) : TopSortM Unit := do\n    match e with\n    | Expr.proj _ _ e      => visit e\n    | Expr.forallE _ d b _ => visit d; visit b\n    | Expr.lam _ d b _     => visit d; visit b\n    | Expr.letE _ t v b _  => visit t; visit v; visit b\n    | Expr.app f a         => visit f; visit a\n    | Expr.mdata _ b       => visit b\n    | Expr.mvar mvarId     =>\n      let v \u2190 instantiateMVars e\n      if !v.isMVar then\n        visit v\n      else if patternVars.contains e then\n        unless (\u2190 get).visitedMVars.contains mvarId do\n          modify fun s => { s with visitedMVars := s.visitedMVars.insert mvarId }\n          let mvarDecl \u2190 getMVarDecl mvarId\n          visit mvarDecl.type\n          modify fun s => { s with result := s.result.push e }\n    | Expr.fvar fvarId    =>\n      if patternVars.contains e then\n        unless (\u2190 get).visitedFVars.contains fvarId do\n          modify fun s => { s with visitedFVars := s.visitedFVars.insert fvarId }\n          visit (\u2190 fvarId.getType)\n          modify fun s => { s with result := s.result.push e }\n    | _ => return ()", "start": [593, 1], "end": [626, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.savePatternInfo", "code": "partial def savePatternInfo (p : Expr) : TermElabM Expr :=\n  go p |>.run false\nwhere\n  \n  go (p : Expr) : ReaderT Bool TermElabM Expr := do\n    match p with\n    | .forallE n d b bi  => withLocalDecl n bi (\u2190 go d) fun x => do mkForallFVars #[x] (\u2190 go (b.instantiate1 x))\n    | .lam n d b bi      => withLocalDecl n bi (\u2190 go d) fun x => do mkLambdaFVars #[x] (\u2190 go (b.instantiate1 x))\n    | .letE n t v b ..  => withLetDecl n (\u2190 go t) (\u2190 go v) fun x => do mkLetFVars #[x] (\u2190 go (b.instantiate1 x))\n    | .app f a          => return mkApp (\u2190 go f) (\u2190 go a)\n    | .proj _ _ b       => return p.updateProj! (\u2190 go b)\n    | .mdata k b        =>\n      if inaccessible? p |>.isSome then\n        return mkMData k (\u2190 withReader (fun _ => false) (go b))\n      else if let some (stx, p) := patternWithRef? p then\n        Elab.withInfoContext' (go p) fun p => do\n          \n          mkTermInfo Name.anonymous stx p (isBinder := p.isFVar && !(\u2190 read))\n      else\n        return mkMData k (\u2190 go b)\n    | _ => return p", "start": [628, 1], "end": [651, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.ToDepElimPattern.main", "code": "partial def main (patternVarDecls : Array PatternVarDecl) (ps : Array Expr) (matchType : Expr) (k : Array LocalDecl \u2192 Array Pattern \u2192 Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  let explicitPatternVars := patternVarDecls.map fun decl => decl.fvarId\n  let (ps, s) \u2190 ps.mapM normalize |>.run { explicitPatternVars } |>.run {}\n  let patternVars \u2190 topSort s.patternVars\n  trace[Elab.match] \"patternVars after topSort: {patternVars}\"\n  for explicit in explicitPatternVars do\n    unless patternVars.any (\u00b7 == mkFVar explicit) do\n      withInPattern do\n        throwError \"invalid patterns, `{mkFVar explicit}` is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching{indentD (MessageData.joinSep (ps.toList.map (MessageData.ofExpr .)) m!\"\\n\\n\")}\"\n  let packed \u2190 pack patternVars ps matchType\n  trace[Elab.match] \"packed: {packed}\"\n  let lctx := explicitPatternVars.foldl (init := (\u2190 getLCtx)) fun lctx d => lctx.erase d\n  withTheReader Meta.Context (fun ctx => { ctx with lctx := lctx }) do\n    check packed\n    unpack packed fun patternVars patterns matchType => do\n      let localDecls \u2190 patternVars.mapM fun x => x.fvarId!.getDecl\n      trace[Elab.match] \"patternVars: {patternVars}, matchType: {matchType}\"\n      k localDecls (\u2190 patterns.mapM fun p => toPattern p) matchType\nwhere\n  pack (patternVars : Array Expr) (ps : Array Expr) (matchType : Expr) : MetaM Expr := do\n    \n    let setMVarsAt (e : Expr) : StateRefT (Array MVarId) MetaM Unit := do\n      let mvarIds \u2190 setMVarUserNamesAt (\u2190 erasePatternRefAnnotations e) patternVars\n      modify (\u00b7 ++ mvarIds)\n    let go : StateRefT (Array MVarId) MetaM Expr := do\n      try\n        for p in ps.reverse do\n          setMVarsAt p\n        mkLambdaFVars patternVars (\u2190 packMatchTypePatterns matchType ps) (binderInfoForMVars := BinderInfo.default)\n      finally\n        resetMVarUserNames (\u2190 get)\n    go |>.run' #[]\n\n  unpack (packed : Expr) (k : (patternVars : Array Expr) \u2192 (patterns : Array Expr) \u2192 (matchType : Expr) \u2192 TermElabM \u03b1) : TermElabM \u03b1 :=\n    let rec go (packed : Expr) (patternVars : Array Expr) : TermElabM \u03b1 := do\n      match packed with\n      | .lam n d b _ =>\n        withLocalDeclD n (\u2190 erasePatternRefAnnotations (\u2190 eraseInaccessibleAnnotations d)) fun patternVar =>\n          go (b.instantiate1 patternVar) (patternVars.push patternVar)\n      | _ =>\n        let (matchType, patterns) := unpackMatchTypePatterns packed\n        let matchType \u2190 erasePatternRefAnnotations (\u2190 eraseInaccessibleAnnotations matchType)\n        let patterns \u2190 patterns.mapM (savePatternInfo \u00b7)\n        k patternVars patterns matchType\n    go packed #[]", "start": [653, 1], "end": [716, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withDepElimPatterns", "code": "def withDepElimPatterns (patternVarDecls : Array PatternVarDecl) (ps : Array Expr) (matchType : Expr) (k : Array LocalDecl \u2192 Array Pattern \u2192 Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  ToDepElimPattern.main patternVarDecls ps matchType k", "start": [720, 1], "end": [721, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withElaboratedLHS", "code": "private def withElaboratedLHS {\u03b1} (ref : Syntax) (patternVarDecls : Array PatternVarDecl) (patternStxs : Array Syntax) (matchType : Expr)\n    (k : AltLHS \u2192 Expr \u2192 TermElabM \u03b1) : ExceptT PatternElabException TermElabM \u03b1 := do\n  let (patterns, matchType) \u2190 withSynthesize <| elabPatterns patternStxs matchType\n  id (\u03b1 := TermElabM \u03b1) do\n    trace[Elab.match] \"patterns: {patterns}\"\n    withDepElimPatterns patternVarDecls patterns matchType fun localDecls patterns matchType => do\n      k { ref := ref, fvarDecls := localDecls.toList, patterns := patterns.toList } matchType", "start": [723, 1], "end": [729, 94], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withToClear", "code": "private def withToClear (toClear : Array FVarId) (type : Expr) (k : TermElabM \u03b1) : TermElabM \u03b1 := do\n  if toClear.isEmpty then\n    k\n  else\n    let toClear \u2190 sortFVarIds toClear\n    trace[Elab.match] \">> toClear {toClear.map mkFVar}\"\n    let mut lctx \u2190 getLCtx\n    let mut localInsts \u2190 getLocalInstances\n    for fvarId in toClear.reverse do\n      if !(\u2190 dependsOn type fvarId) then\n        if !(\u2190 lctx.anyM fun localDecl => pure (localDecl.fvarId != fvarId) <&&> localDeclDependsOn localDecl fvarId) then\n          lctx := lctx.erase fvarId\n          localInsts := localInsts.filter fun localInst => localInst.fvar.fvarId! != fvarId\n    withLCtx lctx localInsts k", "start": [731, 1], "end": [748, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withEqs", "code": "private def withEqs (discrs : Array Discr) (patterns : List Pattern) (k : Array Expr \u2192 TermElabM \u03b1) : TermElabM \u03b1 := do\n  go 0 patterns #[]\nwhere\n  go (i : Nat) (ps : List Pattern) (eqs : Array Expr) : TermElabM \u03b1 := do\n    match ps with\n    | [] => k eqs\n    | p::ps =>\n      if h : i < discrs.size then\n        let discr := discrs.get \u27e8i, h\u27e9\n        if let some h := discr.h? then\n          withLocalDeclD h.getId (\u2190 mkEqHEq discr.expr (\u2190 p.toExpr)) fun eq => do\n            addTermInfo' h eq (isBinder := true)\n            go (i+1) ps (eqs.push eq)\n        else\n          go (i+1) ps eqs\n      else\n        k eqs", "start": [750, 1], "end": [770, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabMatchAltView", "code": "private def elabMatchAltView (discrs : Array Discr) (alt : MatchAltView) (matchType : Expr) (toClear : Array FVarId) : ExceptT PatternElabException TermElabM (AltLHS \u00d7 Expr) := withRef alt.ref do\n    let (patternVars, alt) \u2190 collectPatternVars alt\n    trace[Elab.match] \"patternVars: {patternVars}\"\n    withPatternVars patternVars fun patternVarDecls => do\n      withElaboratedLHS alt.ref patternVarDecls alt.patterns matchType fun altLHS matchType =>\n        withEqs discrs altLHS.patterns fun eqs =>\n          withLocalInstances altLHS.fvarDecls do\n            trace[Elab.match] \"elabMatchAltView: {matchType}\"\n            for (fvar, baseId) in altLHS.fvarDecls.toArray.reverse.zip toClear.reverse do\n              pushInfoLeaf <| .ofFVarAliasInfo { id := fvar.fvarId, baseId, userName := fvar.userName }\n            let matchType \u2190 instantiateMVars matchType\n            let matchType' \u2190 if matchType.getAppFn.isMVar then mkFreshTypeMVar else pure matchType\n            withToClear toClear matchType' do\n              let rhs \u2190 elabTermEnsuringType alt.rhs matchType'\n              unless (\u2190 fullApproxDefEq <| isDefEq matchType' matchType) do\n                throwError \"type mistmatch, alternative {\u2190 mkHasTypeButIsExpectedMsg matchType' matchType}\"\n              let xs := altLHS.fvarDecls.toArray.map LocalDecl.toExpr ++ eqs\n              let rhs \u2190 if xs.isEmpty then pure <| mkSimpleThunk rhs else mkLambdaFVars xs rhs\n              trace[Elab.match] \"rhs: {rhs}\"\n              return (altLHS, rhs)", "start": [772, 1], "end": [801, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getIndexToInclude?", "code": "private partial def getIndexToInclude? (discr : Expr) (pathToIndex : List Nat) : TermElabM (Option Expr) := do\n  go (\u2190 inferType discr) pathToIndex |>.run\nwhere\n  go (e : Expr) (path : List Nat) : OptionT MetaM Expr := do\n    match path with\n    | [] => return e\n    | i::path =>\n      let e \u2190 whnfD e\n      guard <| e.isApp && i < e.getAppNumArgs\n      go (e.getArg! i) path", "start": [803, 1], "end": [815, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.GeneralizeResult", "code": "structure GeneralizeResult where\n  discrs    : Array Discr\n  \n  toClear   : Array FVarId := #[]\n  matchType : Expr\n  altViews  : Array MatchAltView\n  refined   : Bool := false", "start": [817, 1], "end": [823, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.generalize", "code": "private def generalize (discrs : Array Discr) (matchType : Expr) (altViews : Array MatchAltView) (generalizing? : Option Bool) : TermElabM GeneralizeResult := do\n  let gen := if let some g := generalizing? then g else true\n  if !gen then\n    return { discrs, matchType, altViews }\n  else\n    let discrExprs := discrs.map (\u00b7.expr)\n    \n    let ysFVarIds \u2190 getFVarsToGeneralize discrExprs (ignoreLetDecls := true)\n    if ysFVarIds.isEmpty then\n      return { discrs, matchType, altViews }\n    else\n      let ys := ysFVarIds.map mkFVar\n      let matchType' \u2190 forallBoundedTelescope matchType discrs.size fun ds type => do\n        let type \u2190 mkForallFVars ys type\n        let (discrs', ds') := Array.unzip <| Array.zip discrExprs ds |>.filter fun (di, _) => di.isFVar\n        let type := type.replaceFVars discrs' ds'\n        mkForallFVars ds type\n      if (\u2190 isTypeCorrect matchType') then\n        let discrs := discrs ++  ys.map fun y => { expr := y : Discr }\n        let altViews \u2190 altViews.mapM fun altView => do\n          let patternVars \u2190 getPatternsVars altView.patterns\n          let ysUserNames \u2190 ys.foldrM (init := #[]) fun ys ysUserNames => do\n            let yDecl \u2190 ys.fvarId!.getDecl\n            let mut yUserName := yDecl.userName\n            if ysUserNames.contains yUserName then\n              yUserName \u2190 mkFreshUserName yUserName\n            else if patternVars.any fun x => x.getId == yUserName then\n              yUserName \u2190 mkFreshUserName yUserName\n            return ysUserNames.push yUserName\n          let ysIds \u2190 ysUserNames.reverse.mapM fun n => return mkIdentFrom (\u2190 getRef) n\n          return { altView with patterns := altView.patterns ++ ysIds }\n        return { discrs, toClear := ysFVarIds, matchType := matchType', altViews, refined := true }\n      else\n        return { discrs, matchType, altViews }", "start": [825, 1], "end": [873, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabMatchAltViews", "code": "private partial def elabMatchAltViews (generalizing? : Option Bool) (discrs : Array Discr) (matchType : Expr) (altViews : Array MatchAltView) : TermElabM (Array Discr \u00d7 Expr \u00d7 Array (AltLHS \u00d7 Expr) \u00d7 Bool) := do\n  loop discrs #[] matchType altViews none\nwhere\n  \n  loop (discrs : Array Discr) (toClear : Array FVarId) (matchType : Expr) (altViews : Array MatchAltView) (first? : Option (SavedState \u00d7 Exception))\n      : TermElabM (Array Discr \u00d7 Expr \u00d7 Array (AltLHS \u00d7 Expr) \u00d7 Bool) := do\n    let s \u2190 saveState\n    let { discrs := discrs', toClear := toClear', matchType := matchType', altViews := altViews', refined } \u2190 generalize discrs matchType altViews generalizing?\n    match (\u2190 altViews'.mapM (fun altView => elabMatchAltView discrs' altView matchType' (toClear ++ toClear')) |>.run) with\n    | Except.ok alts => return (discrs', matchType', alts, first?.isSome || refined)\n    | Except.error { patternIdx := patternIdx, pathToIndex := pathToIndex, ex := ex } =>\n      let discr := discrs[patternIdx]!\n      let some index \u2190 getIndexToInclude? discr.expr pathToIndex\n        | throwEx (\u2190 updateFirst first? ex)\n      trace[Elab.match] \"index to include: {index}\"\n      if (\u2190 discrs.anyM fun discr => isDefEq discr.expr index) then\n        throwEx (\u2190 updateFirst first? ex)\n      let first \u2190 updateFirst first? ex\n      s.restore (restoreInfo := true)\n      let indices \u2190 collectDeps #[index] (discrs.map (\u00b7.expr))\n      let matchType \u2190 try\n        updateMatchType indices matchType\n      catch _ => throwEx first\n      let ref \u2190 getRef\n      trace[Elab.match] \"new indices to add as discriminants: {indices}\"\n      let wildcards \u2190 indices.mapM fun index => do\n        if index.isFVar then\n          let localDecl \u2190 index.fvarId!.getDecl\n          if localDecl.userName.hasMacroScopes then\n            return mkHole ref\n          else\n            let id := mkIdentFrom ref localDecl.userName\n            `(?$id)\n        else\n          return mkHole ref\n      let altViews  := altViews.map fun altView => { altView with patterns := wildcards ++ altView.patterns }\n      let indDiscrs \u2190 indices.mapM fun i => do\n        match discr.h? with\n        | none => return { expr := i : Discr }\n        | some h =>\n          let h := mkIdentFrom h (\u2190 mkFreshUserName `h)\n          return { expr := i, h? := h : Discr }\n      let discrs    := indDiscrs ++ discrs\n      let indexFVarIds := indices.filterMap fun | .fvar fvarId .. => some fvarId | _  => none\n      loop discrs (toClear ++ indexFVarIds) matchType altViews first\n\n  throwEx {\u03b1} (p : SavedState \u00d7 Exception) : TermElabM \u03b1 := do\n    p.1.restore (restoreInfo := true); throw p.2\n\n  updateFirst (first? : Option (SavedState \u00d7 Exception)) (ex : Exception) : TermElabM (SavedState \u00d7 Exception) := do\n    match first? with\n    | none       => return (\u2190 saveState, ex)\n    | some first => return first\n\n  containsFVar (es : Array Expr) (fvarId : FVarId) : Bool :=\n    es.any fun e => e.isFVar && e.fvarId! == fvarId\n\n  \n  collectDeps (indices : Array Expr) (discrs : Array Expr) : TermElabM (Array Expr) := do\n    let mut s : CollectFVars.State := {}\n    for discr in discrs do\n      s := collectFVars s (\u2190 instantiateMVars (\u2190 inferType discr))\n    let (indicesFVar, indicesNonFVar) := indices.split Expr.isFVar\n    let indicesFVar := indicesFVar.map Expr.fvarId!\n    let mut toAdd := #[]\n    for fvarId in s.fvarSet.toList do\n      unless containsFVar discrs fvarId || containsFVar indices fvarId do\n        let localDecl \u2190 fvarId.getDecl\n        for indexFVarId in indicesFVar do\n          if (\u2190 localDeclDependsOn localDecl indexFVarId) then\n            toAdd := toAdd.push fvarId\n    let indicesFVar \u2190 sortFVarIds (indicesFVar ++ toAdd)\n    return indicesFVar.map mkFVar ++ indicesNonFVar\n\n  updateMatchType (indices : Array Expr) (matchType : Expr) : TermElabM Expr := do\n    let matchType \u2190 indices.foldrM (init := matchType) fun index matchType => do\n      let indexType \u2190 inferType index\n      let matchTypeBody \u2190 kabstract matchType index\n      let userName \u2190 mkUserNameFor index\n      return Lean.mkForall userName BinderInfo.default indexType matchTypeBody\n    check matchType\n    return matchType", "start": [876, 1], "end": [978, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkMatcher", "code": "def mkMatcher (input : Meta.Match.MkMatcherInput) : TermElabM MatcherResult :=\n  Meta.Match.mkMatcher input", "start": [981, 1], "end": [982, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.reportMatcherResultErrors", "code": "def reportMatcherResultErrors (altLHSS : List AltLHS) (result : MatcherResult) : TermElabM Unit := do\n  unless result.counterExamples.isEmpty do\n    withHeadRefOnly <| logError m!\"missing cases:\\n{Meta.Match.counterExamplesToMessageData result.counterExamples}\"\n    return ()\n  unless match.ignoreUnusedAlts.get (\u2190 getOptions) || result.unusedAltIdxs.isEmpty do\n    let mut i := 0\n    for alt in altLHSS do\n      if result.unusedAltIdxs.contains i then\n        withRef alt.ref do\n          logError \"redundant alternative\"\n      i := i + 1", "start": [989, 1], "end": [999, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isMatchUnit?", "code": "private def isMatchUnit? (altLHSS : List Match.AltLHS) (rhss : Array Expr) : MetaM (Option Expr) := do\n  assert! altLHSS.length == rhss.size\n  match altLHSS with\n  | [ { fvarDecls := [], patterns := [ Pattern.ctor `PUnit.unit .. ], .. } ] =>\n    \n    match rhss[0]! with\n    | Expr.lam _ _ b _ => return if b.hasLooseBVars then none else b\n    | _ => return none\n  | _ => return none", "start": [1001, 1], "end": [1013, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabMatchAux", "code": "private def elabMatchAux (generalizing? : Option Bool) (discrStxs : Array Syntax) (altViews : Array MatchAltView) (matchOptMotive : Syntax) (expectedType : Expr)\n    : TermElabM Expr := do\n  let mut generalizing? := generalizing?\n  if !matchOptMotive.isNone then\n    if generalizing? == some true then\n      throwError \"the '(generalizing := true)' parameter is not supported when the 'match' motive is explicitly provided\"\n    generalizing? := some false\n  let (discrs, matchType, altLHSS, isDep, rhss) \u2190 commitIfDidNotPostpone do\n    let \u27e8discrs, matchType, isDep, altViews\u27e9 \u2190 elabMatchTypeAndDiscrs discrStxs matchOptMotive altViews expectedType\n    let matchAlts \u2190 liftMacroM <| expandMacrosInPatterns altViews\n    trace[Elab.match] \"matchType: {matchType}\"\n    let (discrs, matchType, alts, refined) \u2190 elabMatchAltViews generalizing? discrs matchType matchAlts\n    let isDep := isDep || refined\n    \n    synthesizeSyntheticMVarsUsingDefault\n    let rhss := alts.map Prod.snd\n    let matchType \u2190 instantiateMVars matchType\n    let altLHSS \u2190 alts.toList.mapM fun alt => do\n      let altLHS \u2190 Match.instantiateAltLHSMVars alt.1\n      \n      withRef altLHS.ref do\n        for d in altLHS.fvarDecls do\n          if d.hasExprMVar then\n            tryPostpone\n            withExistingLocalDecls altLHS.fvarDecls do\n              runPendingTacticsAt d.type\n              if (\u2190 instantiateMVars d.type).hasExprMVar then\n                throwMVarError m!\"invalid match-expression, type of pattern variable '{d.toExpr}' contains metavariables{indentExpr d.type}\"\n        for p in altLHS.patterns do\n          if (\u2190 Match.instantiatePatternMVars p).hasExprMVar then\n            tryPostpone\n            withExistingLocalDecls altLHS.fvarDecls do\n              throwMVarError m!\"invalid match-expression, pattern contains metavariables{indentExpr (\u2190 p.toExpr)}\"\n        pure altLHS\n    return (discrs, matchType, altLHSS, isDep, rhss)\n  if let some r \u2190 if isDep then pure none else isMatchUnit? altLHSS rhss then\n    return r\n  else\n    let numDiscrs := discrs.size\n    let matcherName \u2190 mkAuxName `match\n    let matcherResult \u2190 mkMatcher { matcherName, matchType, discrInfos := discrs.map fun discr => { hName? := discr.h?.map (\u00b7.getId) }, lhss := altLHSS }\n    reportMatcherResultErrors altLHSS matcherResult\n    matcherResult.addMatcher\n    let motive \u2190 forallBoundedTelescope matchType numDiscrs fun xs matchType => mkLambdaFVars xs matchType\n    let r := mkApp matcherResult.matcher motive\n    let r := mkAppN r (discrs.map (\u00b7.expr))\n    let r := mkAppN r rhss\n    trace[Elab.match] \"result: {r}\"\n    return r", "start": [1015, 1], "end": [1096, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getDiscrs", "code": "private def getDiscrs (matchStx : Syntax) : Array Syntax :=\n  matchStx[3].getSepArgs", "start": [1100, 1], "end": [1101, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.getMatchOptMotive", "code": "private def getMatchOptMotive (matchStx : Syntax) : Syntax :=\n  matchStx[2]", "start": [1103, 1], "end": [1104, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandNonAtomicDiscrs?", "code": "private def expandNonAtomicDiscrs? (matchStx : Syntax) : TermElabM (Option Syntax) :=\n  let matchOptMotive := getMatchOptMotive matchStx\n  if matchOptMotive.isNone then do\n    let discrs := getDiscrs matchStx\n    let allLocal \u2190 discrs.allM fun discr => isAtomicDiscr discr[1]\n    if allLocal then\n      return none\n    else\n      let rec loop (discrs : List Syntax) (discrsNew : Array Syntax)  := do\n        match discrs with\n        | [] =>\n          let discrs := Syntax.mkSep discrsNew (mkAtomFrom matchStx \", \")\n          pure (matchStx.setArg 3 discrs)\n        | discr :: discrs =>\n          let term := discr[1]\n          if (\u2190 isAtomicDiscr term) then\n            loop discrs (discrsNew.push discr)\n          else\n            withFreshMacroScope do\n              let discrNew := discr.setArg 1 (\u2190 `(?x))\n              let r \u2190 loop discrs (discrsNew.push discrNew)\n              `(let_mvar% ?x := $term; $r)\n      return some (\u2190 loop discrs.toList #[])\n  else\n    return none", "start": [1107, 1], "end": [1134, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.waitExpectedType", "code": "private def waitExpectedType (expectedType? : Option Expr) : TermElabM Expr := do\n  tryPostponeIfNoneOrMVar expectedType?\n  match expectedType? with\n    | some expectedType => pure expectedType\n    | none              => mkFreshTypeMVar", "start": [1136, 1], "end": [1140, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.tryPostponeIfDiscrTypeIsMVar", "code": "private def tryPostponeIfDiscrTypeIsMVar (matchStx : Syntax) : TermElabM Unit := do\n  if getMatchOptMotive matchStx |>.isNone then\n    let discrs := getDiscrs matchStx\n    for discr in discrs do\n      let term := discr[1]\n      let d \u2190 elabTerm term none\n      let dType \u2190 inferType d\n      trace[Elab.match] \"discr {d} : {\u2190 instantiateMVars dType}\"\n      tryPostponeIfMVar dType", "start": [1142, 1], "end": [1151, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.waitExpectedTypeAndDiscrs", "code": "private def waitExpectedTypeAndDiscrs (matchStx : Syntax) (expectedType? : Option Expr) : TermElabM Expr := do\n  tryPostponeIfNoneOrMVar expectedType?\n  tryPostponeIfDiscrTypeIsMVar matchStx\n  match expectedType? with\n  | some expectedType => return expectedType\n  | none              => mkFreshTypeMVar", "start": [1153, 1], "end": [1187, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabMatchCore", "code": "private def elabMatchCore (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr := do\n  let expectedType   \u2190 waitExpectedTypeAndDiscrs stx expectedType?\n  let discrStxs      := (getDiscrs stx).map fun d => d\n  let gen?           := getMatchGeneralizing? stx\n  let altViews       := getMatchAlts stx\n  let matchOptMotive := getMatchOptMotive stx\n  elabMatchAux gen? discrStxs altViews matchOptMotive expectedType", "start": [1189, 1], "end": [1201, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isPatternVar", "code": "private def isPatternVar (stx : Syntax) : TermElabM Bool := do\n  match (\u2190 resolveId? stx \"pattern\") with\n  | none   => return isAtomicIdent stx\n  | some f => match f with\n    | Expr.const fName _ =>\n      match (\u2190 getEnv).find? fName with\n      | some (ConstantInfo.ctorInfo _) => return false\n      | some _                         => return !hasMatchPatternAttribute (\u2190 getEnv) fName\n      | _                              => return isAtomicIdent stx\n    | _ => return isAtomicIdent stx\nwhere\n  isAtomicIdent (stx : Syntax) : Bool :=\n    stx.isIdent && stx.getId.eraseMacroScopes.isAtomic", "start": [1203, 1], "end": [1215, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabMatch", "code": "@[builtin_term_elab \u00abmatch\u00bb] def elabMatch : TermElab := fun stx expectedType? => do\n  match stx with\n  | `(match $discr:term with | $y:ident => $rhs) =>\n     if (\u2190 isPatternVar y) then expandSimpleMatch stx discr y rhs expectedType? else elabMatchDefault stx expectedType?\n  | _ => elabMatchDefault stx expectedType?\nwhere\n  elabMatchDefault (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr := do\n    match (\u2190 liftMacroM <| expandMatchAlts? stx) with\n    | some stxNew => withMacroExpansion stx stxNew <| elabTerm stxNew expectedType?\n    | none =>\n    match (\u2190 expandNonAtomicDiscrs? stx) with\n    | some stxNew => withMacroExpansion stx stxNew <| elabTerm stxNew expectedType?\n    | none =>\n      let discrs         := getDiscrs stx\n      let matchOptMotive := getMatchOptMotive stx\n      if !matchOptMotive.isNone && discrs.any fun d => !d[0].isNone then\n        throwErrorAt matchOptMotive \"match motive should not be provided when discriminants with equality proofs are used\"\n      elabMatchCore stx expectedType?", "start": [1217, 1], "end": [1234, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabNoMatch", "code": "@[builtin_term_elab \u00abnomatch\u00bb] def elabNoMatch : TermElab := fun stx expectedType? => do\n  match stx with\n  | `(nomatch $discrExpr) =>\n    if (\u2190 isAtomicDiscr discrExpr) then\n      let expectedType \u2190 waitExpectedType expectedType?\n      let discr := mkNode ``Lean.Parser.Term.matchDiscr #[mkNullNode, discrExpr]\n      elabMatchAux none #[discr] #[] mkNullNode expectedType\n    else\n      let stxNew \u2190 `(let_mvar% ?x := $discrExpr; nomatch ?x)\n      withMacroExpansion stx stxNew <| elabTerm stxNew expectedType?\n  | _ => throwUnsupportedSyntax", "start": [1240, 1], "end": [1250, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Fin/Init/Lemmas.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fin.zero_eta", "code": "@[simp] theorem Fin.zero_eta : (\u27e80, Nat.zero_lt_succ _\u27e9 : Fin (n + 1)) = 0", "start": [7, 1], "end": [7, 82], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/TagAttribute.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.TagAttribute.getDecls", "code": "def Lean.TagAttribute.getDecls (attr : TagAttribute) (env : Environment) : Array Name :=\n  core <| attr.ext.toEnvExtension.getState env\nwhere\n  \n  core (st : PersistentEnvExtensionState Name NameSet) : Array Name := Id.run do\n    let mut decls := st.state.toArray\n    for ds in st.importedEntries do\n      decls := decls ++ ds\n    decls", "start": [8, 1], "end": [17, 10], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Open.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Util.lean", "lake-packages/lean4/src/lean/Lean/Log.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.OpenDecl.State", "code": "structure State where\n  openDecls     : List OpenDecl\n  currNamespace : Name", "start": [16, 1], "end": [22, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.OpenDecl.M", "code": "abbrev M := StateRefT State m", "start": [24, 1], "end": [24, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.OpenDecl.resolveId", "code": "def resolveId (ns : Name) (idStx : Syntax) : M (m := m) Name := do\n  let declName := ns ++ idStx.getId\n  if (\u2190 getEnv).contains declName then\n    return declName\n  else\n    withRef idStx <| resolveGlobalConstNoOverloadCore declName", "start": [30, 1], "end": [35, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.OpenDecl.addOpenDecl", "code": "private def addOpenDecl (decl : OpenDecl) : M (m:=m) Unit :=\n  modify fun s => { s with openDecls := decl :: s.openDecls }", "start": [37, 1], "end": [38, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.OpenDecl.resolveNameUsingNamespacesCore", "code": "private def resolveNameUsingNamespacesCore (nss : List Name) (idStx : Syntax) : M (m:=m) Name := do\n  let mut exs := #[]\n  let mut result := #[]\n  for ns in nss do\n    try\n      let declName \u2190 resolveId ns idStx\n      result := result.push declName\n    catch ex =>\n      exs := exs.push ex\n  if exs.size == nss.length then\n    withRef idStx do\n      if exs.size == 1 then\n        throw exs[0]!\n      else\n        throwErrorWithNestedErrors \"failed to open\" exs\n  if result.size == 1 then\n    return result[0]!\n  else\n    withRef idStx do throwError \"ambiguous identifier '{idStx.getId}', possible interpretations: {result.map mkConst}\"", "start": [40, 1], "end": [58, 119], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.OpenDecl.elabOpenDecl", "code": "def elabOpenDecl [MonadResolveName m] (stx : TSyntax ``Parser.Command.openDecl) : m (List OpenDecl) := do\n  StateRefT'.run' (s := { openDecls := (\u2190 getOpenDecls), currNamespace := (\u2190 getCurrNamespace) }) do\n    match stx with\n    | `(Parser.Command.openDecl| $nss*) =>\n      for ns in nss do\n        for ns in (\u2190 resolveNamespace ns) do\n          addOpenDecl (OpenDecl.simple ns [])\n          activateScoped ns\n    | `(Parser.Command.openDecl| scoped $nss*) =>\n      for ns in nss do\n        for ns in (\u2190 resolveNamespace ns) do\n          activateScoped ns\n    | `(Parser.Command.openDecl| $ns ($ids*)) =>\n      let nss \u2190 resolveNamespace ns\n      for idStx in ids do\n        let declName \u2190 resolveNameUsingNamespacesCore nss idStx\n        addOpenDecl (OpenDecl.explicit idStx.getId declName)\n    | `(Parser.Command.openDecl| $ns hiding $ids*) =>\n      let ns \u2190 resolveUniqueNamespace ns\n      activateScoped ns\n      for id in ids do\n        let _ \u2190 resolveId ns id\n      let ids := ids.map (\u00b7.getId) |>.toList\n      addOpenDecl (OpenDecl.simple ns ids)\n    | `(Parser.Command.openDecl| $ns renaming $[$froms -> $tos],*) =>\n      let ns \u2190 resolveUniqueNamespace ns\n      for (\u00abfrom\u00bb, to) in froms.zip tos do\n        let declName \u2190 resolveId ns \u00abfrom\u00bb\n        addOpenDecl (OpenDecl.explicit to.getId declName)\n    | _ => throwUnsupportedSyntax\n    return (\u2190 get).openDecls", "start": [60, 1], "end": [90, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.OpenDecl.resolveNameUsingNamespaces", "code": "def resolveNameUsingNamespaces [MonadResolveName m] (nss : List Name) (idStx : Ident) : m Name := do\n  StateRefT'.run' (s := { openDecls := (\u2190 getOpenDecls), currNamespace := (\u2190 getCurrNamespace) }) do\n    resolveNameUsingNamespacesCore nss idStx", "start": [92, 1], "end": [94, 45], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/Rpc/RequestHandling.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Server/Requests.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp/Extra.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Server.RpcProcedure", "code": "private structure RpcProcedure where\n  wrapper : (sessionId : UInt64) \u2192 Json \u2192 RequestM (RequestTask Json)\n  deriving Inhabited", "start": [14, 1], "end": [16, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.evalRpcProcedureUnsafe", "code": "private unsafe def evalRpcProcedureUnsafe (env : Environment) (opts : Options) (procName : Name) :\n    Except String RpcProcedure :=\n  env.evalConstCheck RpcProcedure opts ``RpcProcedure procName", "start": [26, 1], "end": [28, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.evalRpcProcedure", "code": "@[implemented_by evalRpcProcedureUnsafe]\nopaque evalRpcProcedure (env : Environment) (opts : Options) (procName : Name) :\n    Except String RpcProcedure", "start": [30, 1], "end": [32, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.handleRpcCall", "code": "def handleRpcCall (p : Lsp.RpcCallParams) : RequestM (RequestTask Json) := do\n  if let some proc := (\u2190 builtinRpcProcedures.get).find? p.method then\n    proc.wrapper p.sessionId p.params\n  else\n    let doc \u2190 readDoc\n    let text := doc.meta.text\n    let callPos := text.lspPosToUtf8Pos p.position\n    let throwNotFound := throwThe RequestError\n      { code := .methodNotFound\n        message := s!\"No RPC method '{p.method}' found\"}\n    bindWaitFindSnap doc (notFoundX := throwNotFound)\n      (fun s => s.endPos >= callPos ||\n        (userRpcProcedures.find? s.env p.method).isSome)\n      fun snap => do\n        if let some procName := userRpcProcedures.find? snap.env p.method then\n          let options := snap.cmdState.scopes.head!.opts\n          match evalRpcProcedure snap.env options procName with\n          | .ok x => x.wrapper p.sessionId p.params\n          | .error e => throwThe RequestError {\n            code := .internalError\n            message := s!\"Failed to evaluate RPC constant '{procName}': {e}\" }\n        else\n          throwNotFound", "start": [35, 1], "end": [60, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.wrapRpcProcedure", "code": "def wrapRpcProcedure (method : Name) paramType respType\n    [RpcEncodable paramType] [RpcEncodable respType]\n    (handler : paramType \u2192 RequestM (RequestTask respType)) : RpcProcedure :=\n  \u27e8fun seshId j => do\n    let rc \u2190 read\n\n    let some seshRef := rc.rpcSessions.find? seshId\n      | throwThe RequestError { code := JsonRpc.ErrorCode.rpcNeedsReconnect\n                                message := s!\"Outdated RPC session\" }\n    let t \u2190 RequestM.asTask do\n      match rpcDecode j (\u2190 seshRef.get).objects with\n      | Except.ok v => return v\n      | Except.error e => throwThe RequestError {\n          code := JsonRpc.ErrorCode.invalidParams\n          message := s!\"Cannot decode params in RPC call '{method}({j.compress})'\\n{e}\"\n        }\n\n    let t \u2190 RequestM.bindTask t fun\n      | Except.error e => throw e\n      | Except.ok ps => handler ps\n\n    RequestM.mapTask t fun\n      | Except.error e => throw e\n      | Except.ok ret =>\n        seshRef.modifyGet fun st =>\n          rpcEncode ret st.objects |>.map id ({st with objects := \u00b7})\u27e9", "start": [65, 1], "end": [90, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.registerBuiltinRpcProcedure", "code": "def registerBuiltinRpcProcedure (method : Name) paramType respType\n    [RpcEncodable paramType] [RpcEncodable respType]\n    (handler : paramType \u2192 RequestM (RequestTask respType)) : IO Unit := do\n  let errMsg := s!\"Failed to register builtin RPC call handler for '{method}'\"\n  unless (\u2190 initializing) do\n    throw <| IO.userError s!\"{errMsg}: only possible during initialization\"\n  if (\u2190builtinRpcProcedures.get).contains method then\n    throw <| IO.userError s!\"{errMsg}: already registered\"\n\n  let proc := wrapRpcProcedure method paramType respType handler\n  builtinRpcProcedures.modify fun ps => ps.insert method proc", "start": [92, 1], "end": [102, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.registerRpcProcedure", "code": "def registerRpcProcedure (method : Name) : CoreM Unit := do\n  let env \u2190 getEnv\n  let errMsg := m!\"Failed to register RPC call handler for '{method}'\"\n  if (\u2190builtinRpcProcedures.get).contains method then\n    throwError m!\"{errMsg}: already registered (builtin)\"\n  if userRpcProcedures.contains env method then\n    throwError m!\"{errMsg}: already registered\"\n  let wrappedName := method ++ `_rpc_wrapped\n  let procT := mkConst ``RpcProcedure\n  let proc \u2190 MetaM.run' <| TermElabM.run' <| withoutErrToSorry do\n    let stx \u2190 ``(wrapRpcProcedure $(quote method) _ _ $(mkIdent method))\n    let c \u2190 Lean.Elab.Term.elabTerm stx procT\n    instantiateMVars c\n  addAndCompile <| Declaration.defnDecl {\n        name        := wrappedName\n        type        := procT\n        value       := proc\n        safety      := DefinitionSafety.safe\n        levelParams := []\n        hints := ReducibilityHints.opaque\n      }\n  setEnv <| userRpcProcedures.insert (\u2190 getEnv) method wrappedName", "start": [105, 1], "end": [126, 67], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Eval.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Eval.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.evalTerm", "code": "unsafe def evalTerm (\u03b1) (type : Expr) (value : Syntax) (safety := DefinitionSafety.safe) : TermElabM \u03b1 := do\n  let v \u2190 elabTermEnsuringType value type\n  synthesizeSyntheticMVarsNoPostponing\n  let v \u2190 instantiateMVars v\n  if (\u2190 logUnassignedUsingErrorInfos (\u2190 getMVars v)) then throwAbortTerm\n  evalExpr \u03b1 type v safety", "start": [12, 1], "end": [17, 27], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/FileWorker/RequestHandling.lean", "imports": ["lake-packages/lean4/src/lean/Lean/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Data/Json.lean", "lake-packages/lean4/src/lean/Lean/Server/GoTo.lean", "lake-packages/lean4/src/lean/Lean/Server/FileWorker/Utils.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Data/Lsp.lean", "lake-packages/lean4/src/lean/Lean/Widget/InteractiveGoal.lean", "lake-packages/lean4/src/lean/Lean/Server/Completion.lean", "lake-packages/lean4/src/lean/Lean/Widget/Diff.lean", "lake-packages/lean4/src/lean/Lean/Server/References.lean", "lake-packages/lean4/src/lean/Lean/Server/Requests.lean"], "premises": [{"full_name": "Lean.Server.FileWorker.handleCompletion", "code": "def handleCompletion (p : CompletionParams)\n    : RequestM (RequestTask CompletionList) := do\n  let doc \u2190 readDoc\n  let text := doc.meta.text\n  let pos := text.lspPosToUtf8Pos p.position\n  let caps := (\u2190 read).initParams.capabilities\n  withWaitFindSnap doc (\u00b7.endPos + ' ' >= pos)\n    (notFoundX := pure { items := #[], isIncomplete := true })\n    (abortedX :=\n      pure { items := #[{label := \"-\"}], isIncomplete := true }) fun snap => do\n      if let some r \u2190 Completion.find? doc.meta.text pos snap.infoTree caps then\n        return r\n      return { items := #[ ], isIncomplete := true }", "start": [26, 1], "end": [43, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleHover", "code": "def handleHover (p : HoverParams)\n    : RequestM (RequestTask (Option Hover)) := do\n  let doc \u2190 readDoc\n  let text := doc.meta.text\n  let mkHover (s : String) (r : String.Range) : Hover := {\n    contents := {\n      kind := MarkupKind.markdown\n      value := s\n    }\n    range? := r.toLspRange text\n  }\n\n  let hoverPos := text.lspPosToUtf8Pos p.position\n  withWaitFindSnap doc (fun s => s.endPos > hoverPos)\n    (notFoundX := pure none) fun snap => do\n      let stack? := snap.stx.findStack? (\u00b7.getRange?.any (\u00b7.contains hoverPos))\n      let stxDoc? \u2190 match stack? with\n        | some stack => stack.findSomeM? fun (stx, _) => do\n          let .node _ kind _ := stx | pure none\n          return (\u2190 findDocString? snap.env kind).map (\u00b7, stx.getRange?.get!)\n        | none => pure none\n\n      if let some ictx := snap.infoTree.hoverableInfoAt? hoverPos then\n        if let some range := ictx.info.range? then\n          if stxDoc?.all fun (_, stxRange) => stxRange.includes range then\n            if let some hoverFmt \u2190 ictx.info.fmtHover? ictx.ctx then\n              return mkHover (toString hoverFmt.fmt) range\n\n      if let some (doc, range) := stxDoc? then\n        return mkHover doc range\n\n      return none", "start": [46, 1], "end": [80, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.locationLinksOfInfo", "code": "def locationLinksOfInfo (kind : GoToKind) (ictx : InfoWithCtx)\n    (infoTree? : Option InfoTree := none) : RequestM (Array LocationLink) := do\n  let rc \u2190 read\n  let doc \u2190 readDoc\n  let text := doc.meta.text\n\n  let locationLinksFromDecl (i : Elab.Info) (n : Name) :=\n    locationLinksFromDecl rc.srcSearchPath doc.meta.uri n <| (\u00b7.toLspRange text) <$> i.range?\n\n  let locationLinksFromBinder (i : Elab.Info) (id : FVarId) := do\n    if let some i' := infoTree? >>= InfoTree.findInfo? fun\n        | Info.ofTermInfo { isBinder := true, expr := Expr.fvar id' .., .. } => id' == id\n        | _ => false then\n      if let some r := i'.range? then\n        let r := r.toLspRange text\n        let ll : LocationLink := {\n          originSelectionRange? := (\u00b7.toLspRange text) <$> i.range?\n          targetUri := doc.meta.uri\n          targetRange := r\n          targetSelectionRange := r\n        }\n        return #[ll]\n    return #[]\n\n  let locationLinksFromImport (i : Elab.Info) := do\n    let name := i.stx[2].getId\n    if let some modUri \u2190 documentUriFromModule rc.srcSearchPath name then\n      let range := { start := \u27e80, 0\u27e9, \u00abend\u00bb := \u27e80, 0\u27e9 : Range }\n      let ll : LocationLink := {\n        originSelectionRange? := (\u00b7.toLspRange text) <$> i.stx[2].getRange? (canonicalOnly := true)\n        targetUri := modUri\n        targetRange := range\n        targetSelectionRange := range\n      }\n      return #[ll]\n    return #[]\n\n  let i := ictx.info\n  let ci := ictx.ctx\n  let children := ictx.children\n  match i with\n  | .ofTermInfo ti =>\n    let mut expr := ti.expr\n    if kind == type then\n      expr \u2190 ci.runMetaM i.lctx do\n        return Expr.getAppFn (\u2190 instantiateMVars (\u2190 Meta.inferType expr))\n    match expr with\n    | Expr.const n .. => return \u2190 ci.runMetaM i.lctx <| locationLinksFromDecl i n\n    | Expr.fvar id .. => return \u2190 ci.runMetaM i.lctx <| locationLinksFromBinder i id\n    | _ => pure ()\n\n    let isExprGenerator := children.all fun\n      | .node (Info.ofTermInfo info) _ => info.expr != expr\n      | .node (Info.ofMacroExpansionInfo _) _ => false\n      | _ => true\n\n    if kind != declaration && isExprGenerator then\n      expr \u2190 ci.runMetaM i.lctx do instantiateMVars expr\n      if let .const n _ := expr.getAppFn then\n        let mut results \u2190 ci.runMetaM i.lctx <| locationLinksFromDecl i n\n        if let some info := ci.env.getProjectionFnInfo? n then\n          let mut elaborators := default\n          if let some ei := i.toElabInfo? then do\n            if ei.elaborator != `Delab && ei.elaborator != `Lean.Elab.Term.elabApp && ei.elaborator != `Lean.Elab.Term.elabIdent then do\n              elaborators \u2190 ci.runMetaM i.lctx <| locationLinksFromDecl i ei.elaborator\n          let instIdx := info.numParams\n          let appArgs := expr.getAppArgs\n          let rec extractInstances : Expr \u2192 RequestM (Array Name)\n            | .const declName _ => do\n              if \u2190 ci.runMetaM i.lctx do Lean.Meta.isInstance declName then pure #[declName] else pure #[]\n            | .app fn arg => do pure $ (\u2190 extractInstances fn).append (\u2190 extractInstances arg)\n            | _ => pure #[]\n          if let some instArg := appArgs.get? instIdx then\n            for inst in (\u2190 extractInstances instArg) do\n              results := results.append (\u2190 ci.runMetaM i.lctx <| locationLinksFromDecl i inst)\n            results := results.append elaborators return results\n  | .ofFieldInfo fi =>\n    if kind == type then\n      let expr \u2190 ci.runMetaM i.lctx do\n        instantiateMVars (\u2190 Meta.inferType fi.val)\n      if let some n := expr.getAppFn.constName? then\n        return \u2190 ci.runMetaM i.lctx <| locationLinksFromDecl i n\n    else\n      return \u2190 ci.runMetaM i.lctx <| locationLinksFromDecl i fi.projName\n  | .ofOptionInfo oi =>\n    return \u2190 ci.runMetaM i.lctx <| locationLinksFromDecl i oi.declName\n  | .ofCommandInfo \u27e8`import, _\u27e9 =>\n    if kind == definition || kind == declaration then\n      return \u2190 ci.runMetaM i.lctx <| locationLinksFromImport i\n  | _ => pure ()\n  if let some ei := i.toElabInfo? then\n    if kind == declaration && ci.env.contains ei.stx.getKind then\n      return \u2190 ci.runMetaM i.lctx <| locationLinksFromDecl i ei.stx.getKind\n    if kind == definition && ci.env.contains ei.elaborator then\n      return \u2190 ci.runMetaM i.lctx <| locationLinksFromDecl i ei.elaborator\n  return #[]", "start": [83, 1], "end": [190, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleDefinition", "code": "def handleDefinition (kind : GoToKind) (p : TextDocumentPositionParams)\n    : RequestM (RequestTask (Array LocationLink)) := do\n  let doc \u2190 readDoc\n  let text := doc.meta.text\n  let hoverPos := text.lspPosToUtf8Pos p.position\n\n  withWaitFindSnap doc (fun s => s.endPos > hoverPos)\n    (notFoundX := pure #[]) fun snap => do\n      if let some infoWithCtx := snap.infoTree.hoverableInfoAt? (omitIdentApps := true) (includeStop := true ) hoverPos then\n        locationLinksOfInfo kind infoWithCtx snap.infoTree\n      else return #[]", "start": [193, 1], "end": [203, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.getInteractiveGoals", "code": "def getInteractiveGoals (p : Lsp.PlainGoalParams) : RequestM (RequestTask (Option Widget.InteractiveGoals)) := do\n  let doc \u2190 readDoc\n  let text := doc.meta.text\n  let hoverPos := text.lspPosToUtf8Pos p.position\n  withWaitFindSnap doc (fun s => s.endPos >= hoverPos)\n    (notFoundX := return none) fun snap => do\n      if let rs@(_ :: _) := snap.infoTree.goalsAt? doc.meta.text hoverPos then\n        let goals : List Widget.InteractiveGoals \u2190 rs.mapM fun { ctxInfo := ci, tacticInfo := ti, useAfter := useAfter, .. } => do\n          let ciAfter := { ci with mctx := ti.mctxAfter }\n          let ci := if useAfter then ciAfter else { ci with mctx := ti.mctxBefore }\n          let goals \u2190 ci.runMetaM {} (do\n            let goals := List.toArray <| if useAfter then ti.goalsAfter else ti.goalsBefore\n            let goals \u2190 goals.mapM Widget.goalToInteractive\n            return {goals}\n          )\n          let goals \u2190 ciAfter.runMetaM {} (do\n              try\n                Widget.diffInteractiveGoals useAfter ti goals\n              catch _ =>\n                return goals\n          )\n          return goals\n        return some <| goals.foldl (\u00b7 ++ \u00b7) \u2205\n      else\n        return none", "start": [206, 1], "end": [234, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handlePlainGoal", "code": "def handlePlainGoal (p : PlainGoalParams)\n    : RequestM (RequestTask (Option PlainGoal)) := do\n  let t \u2190 getInteractiveGoals p\n  return t.map <| Except.map <| Option.map <| fun {goals, ..} =>\n    if goals.isEmpty then\n      { goals := #[], rendered := \"no goals\" }\n    else\n      let goalStrs := goals.map (toString \u00b7.pretty)\n      let goalBlocks := goalStrs.map fun goal => s!\"```lean\n{goal}\n```\"\n      let md := String.intercalate \"\\n      { goals := goalStrs, rendered := md }", "start": [237, 1], "end": [249, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.getInteractiveTermGoal", "code": "def getInteractiveTermGoal (p : Lsp.PlainTermGoalParams)\n    : RequestM (RequestTask (Option Widget.InteractiveTermGoal)) := do\n  let doc \u2190 readDoc\n  let text := doc.meta.text\n  let hoverPos := text.lspPosToUtf8Pos p.position\n  withWaitFindSnap doc (fun s => s.endPos > hoverPos)\n    (notFoundX := pure none) fun snap => do\n      if let some {ctx := ci, info := i@(Elab.Info.ofTermInfo ti), ..} := snap.infoTree.termGoalAt? hoverPos then\n        let ty \u2190 ci.runMetaM i.lctx do\n          instantiateMVars <| ti.expectedType?.getD (\u2190 Meta.inferType ti.expr)\n        let lctx' := if ti.isBinder then i.lctx.pop else i.lctx\n        let goal \u2190 ci.runMetaM lctx' do\n          Widget.goalToInteractive (\u2190 Meta.mkFreshExprMVar ty).mvarId!\n        let range := if let some r := i.range? then r.toLspRange text else \u27e8p.position, p.position\u27e9\n        return some { goal with range, term := \u27e8ti\u27e9 }\n      else\n        return none", "start": [251, 1], "end": [268, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handlePlainTermGoal", "code": "def handlePlainTermGoal (p : PlainTermGoalParams)\n    : RequestM (RequestTask (Option PlainTermGoal)) := do\n  let t \u2190 getInteractiveTermGoal p\n  return t.map <| Except.map <| Option.map fun goal =>\n    { goal := toString goal.pretty\n      range := goal.range\n    }", "start": [270, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleDocumentHighlight", "code": "partial def handleDocumentHighlight (p : DocumentHighlightParams)\n    : RequestM (RequestTask (Array DocumentHighlight)) := do\n  let doc \u2190 readDoc\n  let text := doc.meta.text\n  let pos := text.lspPosToUtf8Pos p.position\n\n  let rec highlightReturn? (doRange? : Option Range) : Syntax \u2192 Option DocumentHighlight\n    | `(doElem|return%$i $e) => Id.run do\n      if let some range := i.getRange? then\n        if range.contains pos then\n          return some { range := doRange?.getD (range.toLspRange text), kind? := DocumentHighlightKind.text }\n      highlightReturn? doRange? e\n    | `(do%$i $elems) => highlightReturn? (i.getRange?.get!.toLspRange text) elems\n    | stx => stx.getArgs.findSome? (highlightReturn? doRange?)\n\n  let highlightRefs? (snaps : Array Snapshot) : Option (Array DocumentHighlight) := Id.run do\n    let trees := snaps.map (\u00b7.infoTree)\n    let refs : Lsp.ModuleRefs := findModuleRefs text trees\n    let mut ranges := #[]\n    for ident in \u2190 refs.findAt p.position do\n      if let some info \u2190 refs.find? ident then\n        if let some definition := info.definition then\n          ranges := ranges.push definition\n        ranges := ranges.append info.usages\n    if ranges.isEmpty then\n      return none\n    some <| ranges.map ({ range := \u00b7, kind? := DocumentHighlightKind.text })\n\n  withWaitFindSnap doc (fun s => s.endPos > pos)\n    (notFoundX := pure #[]) fun snap => do\n      let (snaps, _) \u2190 doc.cmdSnaps.getFinishedPrefix\n      if let some his := highlightRefs? snaps.toArray then\n        return his\n      if let some hi := highlightReturn? none snap.stx then\n        return #[hi]\n      return #[]", "start": [278, 1], "end": [313, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.NamespaceEntry", "code": "structure NamespaceEntry where\n  \n  name : List Name\n  stx : Syntax\n  selection : Syntax\n  prevSiblings : Array DocumentSymbol", "start": [315, 1], "end": [321, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.NamespaceEntry.finish", "code": "def NamespaceEntry.finish (text : FileMap) (syms : Array DocumentSymbol) (endStx : Option Syntax) :\n    NamespaceEntry \u2192 Array DocumentSymbol\n  | { name, stx, selection, prevSiblings, .. } =>\n    let range := match endStx with\n      | some endStx => (mkNullNode #[stx, endStx]).getRange?.get!\n      | none        =>  { stx.getRange?.get! with stop := text.source.endPos }\n    let name := name.foldr (fun x y => y ++ x) Name.anonymous\n    prevSiblings.push <| DocumentSymbol.mk {\n      name := if name == `\u00ab\u00bb then \"<section>\" else name.toString\n      kind := .namespace\n      range := range.toLspRange text\n      selectionRange := selection.getRange?.getD range |>.toLspRange text\n      children? := syms\n    }", "start": [323, 1], "end": [338, 6], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleDocumentSymbol", "code": "partial def handleDocumentSymbol (_ : DocumentSymbolParams)\n    : RequestM (RequestTask DocumentSymbolResult) := do\n  let doc \u2190 readDoc\n  let t := doc.cmdSnaps.waitAll\n  mapTask t fun (snaps, _) => do\n    let mut stxs := snaps.map (\u00b7.stx)\n    return { syms := toDocumentSymbols doc.meta.text stxs #[] [] }\nwhere\n  toDocumentSymbols (text : FileMap) (stxs : List Syntax)\n      (syms : Array DocumentSymbol) (stack : List NamespaceEntry) :\n      Array DocumentSymbol :=\n    match stxs with\n    | [] => stack.foldl (fun syms entry => entry.finish text syms none) syms\n    | stx::stxs => match stx with\n      | `(namespace $id)  =>\n        let entry := { name := id.getId.componentsRev, stx, selection := id, prevSiblings := syms }\n        toDocumentSymbols text stxs #[] (entry :: stack)\n      | `(section $(id)?) =>\n        let name := id.map (\u00b7.getId.componentsRev) |>.getD [`\u00ab\u00bb]\n        let entry := { name, stx, selection := id.map (\u00b7.raw) |>.getD stx, prevSiblings := syms }\n        toDocumentSymbols text stxs #[] (entry :: stack)\n      | `(end $(id)?) =>\n        let rec popStack n syms\n          | [] => toDocumentSymbols text stxs syms []\n          | entry :: stack =>\n            if entry.name.length == n then\n              let syms := entry.finish text syms stx\n              toDocumentSymbols text stxs syms stack\n            else if entry.name.length > n then\n              let syms := { entry with name := entry.name.take n, prevSiblings := #[] }.finish text syms stx\n              toDocumentSymbols text stxs syms ({ entry with name := entry.name.drop n } :: stack)\n            else\n              let syms := entry.finish text syms stx\n              popStack (n - entry.name.length) syms stack\n        popStack (id.map (\u00b7.getId.getNumParts) |>.getD 1) syms stack\n      | _ => Id.run do\n        unless stx.isOfKind ``Lean.Parser.Command.declaration do\n          return toDocumentSymbols text stxs syms stack\n        if let some stxRange := stx.getRange? then\n          let (name, selection) := match stx with\n            | `($_:declModifiers $_:attrKind instance $[$np:namedPrio]? $[$id$[.{$ls,*}]?]? $sig:declSig $_) =>\n              ((\u00b7.getId.toString) <$> id |>.getD s!\"instance {sig.raw.reprint.getD \"\"}\", id.map (\u00b7.raw) |>.getD sig)\n            | _ =>\n              match stx.getArg 1 |>.getArg 1 with\n              | `(declId|$id$[.{$ls,*}]?) => (id.raw.getId.toString, id)\n              | _ =>\n                let stx10 : Syntax := (stx.getArg 1).getArg 0 (stx10.isIdOrAtom?.getD \"<unknown>\", stx10)\n          if let some selRange := selection.getRange? then\n            let sym := DocumentSymbol.mk {\n              name := name\n              kind := SymbolKind.method\n              range := stxRange.toLspRange text\n              selectionRange := selRange.toLspRange text\n            }\n            return toDocumentSymbols text stxs (syms.push sym) stack\n        toDocumentSymbols text stxs syms stack", "start": [341, 1], "end": [398, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.noHighlightKinds", "code": "def noHighlightKinds : Array SyntaxNodeKind := #[\n  ``Lean.Parser.Term.sorry,\n  ``Lean.Parser.Term.type,\n  ``Lean.Parser.Term.prop,\n  `antiquotName,\n  ``Lean.Parser.Command.docComment,\n  ``Lean.Parser.Command.moduleDoc]", "start": [400, 1], "end": [408, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.SemanticTokensContext", "code": "structure SemanticTokensContext where\n  beginPos  : String.Pos\n  endPos    : String.Pos\n  text      : FileMap\n  snap      : Snapshot", "start": [410, 1], "end": [414, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.SemanticTokensState", "code": "structure SemanticTokensState where\n  data       : Array Nat\n  lastLspPos : Lsp.Position", "start": [416, 1], "end": [418, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.keywordSemanticTokenMap", "code": "def keywordSemanticTokenMap : RBMap String SemanticTokenType compare :=\n  RBMap.empty\n    |>.insert \"sorry\" .leanSorryLike\n    |>.insert \"admit\" .leanSorryLike\n    |>.insert \"stop\" .leanSorryLike\n    |>.insert \"#exit\" .leanSorryLike", "start": [421, 1], "end": [426, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleSemanticTokens", "code": "partial def handleSemanticTokens (beginPos endPos : String.Pos)\n    : RequestM (RequestTask SemanticTokens) := do\n  let doc \u2190 readDoc\n  let text := doc.meta.text\n  let t := doc.cmdSnaps.waitUntil (\u00b7.endPos >= endPos)\n  mapTask t fun (snaps, _) =>\n    StateT.run' (s := { data := #[], lastLspPos := \u27e80, 0\u27e9 : SemanticTokensState }) do\n      for s in snaps do\n        if s.endPos <= beginPos then\n          continue\n        ReaderT.run (r := SemanticTokensContext.mk beginPos endPos text s) <|\n          go s.stx\n      return { data := (\u2190 get).data }\nwhere\n  go (stx : Syntax) := do\n    match stx with\n    | `($e.$id:ident)    => go e; addToken id SemanticTokenType.property\n    | `($id:ident)       => highlightId id\n    | _ =>\n      if !noHighlightKinds.contains stx.getKind then\n        highlightKeyword stx\n        if stx.isOfKind choiceKind then\n          go stx[0]\n        else\n          stx.getArgs.forM go\n  highlightId (stx : Syntax) : ReaderT SemanticTokensContext (StateT SemanticTokensState RequestM) _ := do\n    if let some range := stx.getRange? then\n      let mut lastPos := range.start\n      for ti in (\u2190 read).snap.infoTree.deepestNodes (fun\n        | _, i@(Elab.Info.ofTermInfo ti), _ => match i.pos? with\n          | some ipos => if range.contains ipos then some ti else none\n          | _         => none\n        | _, _, _ => none) do\n        let pos := ti.stx.getPos?.get!\n        if pos < lastPos then\n          continue\n        if let Expr.fvar fvarId .. := ti.expr then\n          if let some localDecl := ti.lctx.find? fvarId then\n            if localDecl.isAuxDecl then\n              if ti.isBinder then\n                addToken ti.stx SemanticTokenType.function\n            else\n              addToken ti.stx SemanticTokenType.variable\n        else if ti.stx.getPos?.get! > lastPos then\n          addToken ti.stx SemanticTokenType.property\n          lastPos := ti.stx.getPos?.get!\n  highlightKeyword stx := do\n    if let Syntax.atom _ val := stx then\n      if (val.length > 0 && val.front.isAlpha) ||\n         (val.length > 1 && val.front == '#' && (val.get \u27e81\u27e9).isAlpha) then\n        addToken stx (keywordSemanticTokenMap.findD val .keyword)\n  addToken stx type := do\n    let \u27e8beginPos, endPos, text, _\u27e9 \u2190 read\n    if let (some pos, some tailPos) := (stx.getPos?, stx.getTailPos?) then\n      if beginPos <= pos && pos < endPos then\n        let lspPos := (\u2190 get).lastLspPos\n        let lspPos' := text.utf8PosToLspPos pos\n        let deltaLine := lspPos'.line - lspPos.line\n        let deltaStart := lspPos'.character - (if lspPos'.line == lspPos.line then lspPos.character else 0)\n        let length := (text.utf8PosToLspPos tailPos).character - lspPos'.character\n        let tokenType := type.toNat\n        let tokenModifiers := 0\n        modify fun st => {\n          data := st.data ++ #[deltaLine, deltaStart, length, tokenType, tokenModifiers]\n          lastLspPos := lspPos'\n        }", "start": [428, 1], "end": [500, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleSemanticTokensFull", "code": "def handleSemanticTokensFull (_ : SemanticTokensParams)\n    : RequestM (RequestTask SemanticTokens) := do\n  handleSemanticTokens 0 \u27e81 <<< 31\u27e9", "start": [502, 1], "end": [504, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleSemanticTokensRange", "code": "def handleSemanticTokensRange (p : SemanticTokensRangeParams)\n    : RequestM (RequestTask SemanticTokens) := do\n  let doc \u2190 readDoc\n  let text := doc.meta.text\n  let beginPos := text.lspPosToUtf8Pos p.range.start\n  let endPos := text.lspPosToUtf8Pos p.range.end\n  handleSemanticTokens beginPos endPos", "start": [506, 1], "end": [512, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleFoldingRange", "code": "partial def handleFoldingRange (_ : FoldingRangeParams)\n  : RequestM (RequestTask (Array FoldingRange)) := do\n  let doc \u2190 readDoc\n  let t := doc.cmdSnaps.waitAll\n  mapTask t fun (snaps, _) => do\n    let stxs := snaps.map (\u00b7.stx)\n    let (_, ranges) \u2190 StateT.run (addRanges doc.meta.text [] stxs) #[]\n    return ranges\n  where\n    isImport stx := stx.isOfKind ``Lean.Parser.Module.header || stx.isOfKind ``Lean.Parser.Command.open\n\n    addRanges (text : FileMap) sections\n    | [] => do\n      if let (_, start)::rest := sections then\n        addRange text FoldingRangeKind.region start text.source.endPos\n        addRanges text rest []\n    | stx::stxs => match stx with\n      | `(namespace $id)  =>\n        addRanges text ((id.getId.getNumParts, stx.getPos?)::sections) stxs\n      | `(section $(id)?) =>\n        addRanges text ((id.map (\u00b7.getId.getNumParts) |>.getD 1, stx.getPos?)::sections) stxs\n      | `(end $(id)?) => do\n        let rec popRanges n sections := do\n          if let (size, start)::rest := sections then\n            if size == n then\n              addRange text FoldingRangeKind.region start stx.getTailPos?\n              addRanges text rest stxs\n            else if size > n then\n              addRanges text ((size - n, start)::rest) stxs\n            else\n              addRange text FoldingRangeKind.region start stx.getTailPos?\n              popRanges (n - size) rest\n          else\n            addRanges text sections stxs\n        popRanges (id.map (\u00b7.getId.getNumParts) |>.getD 1) sections\n      | `(mutual $body* end) => do\n        addRangeFromSyntax text FoldingRangeKind.region stx\n        addRanges text [] body.raw.toList\n        addRanges text sections stxs\n      | _ => do\n        if isImport stx then\n          let (imports, stxs) := stxs.span isImport\n          let last := imports.getLastD stx\n          addRange text FoldingRangeKind.imports stx.getPos? last.getTailPos?\n          addRanges text sections stxs\n        else\n          addCommandRange text stx\n          addRanges text sections stxs\n\n    addCommandRange text stx :=\n      match stx.getKind with\n      | `Lean.Parser.Command.moduleDoc =>\n        addRangeFromSyntax text FoldingRangeKind.comment stx\n      | ``Lean.Parser.Command.declaration => do\n        if let `($dm:declModifiers $decl) := stx then\n          if let some comment := dm.raw[0].getOptional? then\n            addRangeFromSyntax text FoldingRangeKind.comment comment\n\n          addRangeFromSyntax text FoldingRangeKind.region decl\n        else\n          addRangeFromSyntax text FoldingRangeKind.region stx\n      | _ =>\n        addRangeFromSyntax text FoldingRangeKind.region stx\n\n    addRangeFromSyntax (text : FileMap) kind stx := addRange text kind stx.getPos? stx.getTailPos?\n\n    addRange (text : FileMap) kind start? stop? := do\n      if let (some startP, some endP) := (start?, stop?) then\n        let startP := text.utf8PosToLspPos startP\n        let endP := text.utf8PosToLspPos endP\n        if startP.line != endP.line then\n          modify fun st => st.push\n            { startLine := startP.line\n              endLine := endP.line\n              kind? := some kind }", "start": [514, 1], "end": [593, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.FileWorker.handleWaitForDiagnostics", "code": "partial def handleWaitForDiagnostics (p : WaitForDiagnosticsParams)\n    : RequestM (RequestTask WaitForDiagnostics) := do\n  let rec waitLoop : RequestM EditableDocument := do\n    let doc \u2190 readDoc\n    if p.version \u2264 doc.meta.version then\n      return doc\n    else\n      IO.sleep 50\n      waitLoop\n  let t \u2190 RequestM.asTask waitLoop\n  RequestM.bindTask t fun doc? => do\n    let doc \u2190 liftExcept doc?\n    let t\u2081 := doc.cmdSnaps.waitAll\n    return t\u2081.map fun _ => pure WaitForDiagnostics.mk", "start": [595, 1], "end": [608, 54], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Split.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Generalize.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/SplitIf.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean"], "premises": [{"full_name": "Lean.Meta.Split.getSimpMatchContext", "code": "def getSimpMatchContext : MetaM Simp.Context :=\n   return {\n      simpTheorems   := {}\n      congrTheorems := (\u2190 getSimpCongrTheorems)\n      config        := { Simp.neutralConfig with dsimp := false }\n   }", "start": [14, 1], "end": [19, 5], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.simpMatch", "code": "def simpMatch (e : Expr) : MetaM Simp.Result := do\n  (\u00b7.1) <$> Simp.main e (\u2190 getSimpMatchContext) (methods := { pre })\nwhere\n  pre (e : Expr) : SimpM Simp.Step := do\n    let some app \u2190 matchMatcherApp? e | return Simp.Step.visit { expr := e }\n    match (\u2190 reduceRecMatcher? e) with\n    | some e' => return Simp.Step.done { expr := e' }\n    | none    =>\n      match (\u2190 Simp.simpMatchCore? app e SplitIf.discharge?) with\n      | some r => return r\n      | none => return Simp.Step.visit { expr := e }", "start": [21, 1], "end": [32, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.simpMatchTarget", "code": "def simpMatchTarget (mvarId : MVarId) : MetaM MVarId := mvarId.withContext do\n  let target \u2190 instantiateMVars (\u2190 mvarId.getType)\n  let r \u2190 simpMatch target\n  applySimpResultToTarget mvarId target r", "start": [34, 1], "end": [37, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.simpMatchCore", "code": "private def simpMatchCore (matchDeclName : Name) (matchEqDeclName : Name) (e : Expr) : MetaM Simp.Result := do\n  (\u00b7.1) <$> Simp.main e (\u2190 getSimpMatchContext) (methods := { pre })\nwhere\n  pre (e : Expr) : SimpM Simp.Step := do\n    if e.isAppOf matchDeclName then\n      match (\u2190 reduceRecMatcher? e) with\n      | some e' => return Simp.Step.done { expr := e' }\n      | none    =>\n      let simpTheorem := {\n        origin := .decl matchEqDeclName\n        proof := mkConst matchEqDeclName\n        rfl := (\u2190 isRflTheorem matchEqDeclName)\n      }\n      match (\u2190 withReducible <| Simp.tryTheorem? e simpTheorem SplitIf.discharge?) with\n      | none => return Simp.Step.visit { expr := e }\n      | some r => return Simp.Step.done r\n    else\n      return Simp.Step.visit { expr := e }", "start": [39, 1], "end": [58, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.simpMatchTargetCore", "code": "private def simpMatchTargetCore (mvarId : MVarId) (matchDeclName : Name) (matchEqDeclName : Name) : MetaM MVarId := do\n  mvarId.withContext do\n    let target \u2190 instantiateMVars (\u2190 mvarId.getType)\n    let r \u2190 simpMatchCore matchDeclName matchEqDeclName target\n    match r.proof? with\n    | some proof => mvarId.replaceTargetEq r.expr proof\n    | none => mvarId.replaceTargetDefEq r.expr", "start": [60, 1], "end": [66, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.withEqs", "code": "private partial def withEqs (lhs rhs : Array Expr) (k : Array Expr \u2192 Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  go 0 #[] #[]\nwhere\n  go (i : Nat) (hs : Array Expr) (rfls : Array Expr) : MetaM \u03b1 := do\n    if i < lhs.size then\n      withLocalDeclD (\u2190 mkFreshUserName `heq) (\u2190 mkEqHEq lhs[i]! rhs[i]!) fun h => do\n        let rfl \u2190 if (\u2190 inferType h).isEq then mkEqRefl lhs[i]! else mkHEqRefl lhs[i]!\n        go (i+1) (hs.push h) (rfls.push rfl)\n    else\n      k hs rfls", "start": [68, 1], "end": [77, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.generalizeMatchDiscrs", "code": "private partial def generalizeMatchDiscrs (mvarId : MVarId) (matcherDeclName : Name) (motiveType : Expr) (discrs : Array Expr) : MetaM (Array FVarId \u00d7 Array FVarId \u00d7 MVarId) := mvarId.withContext do\n  if discrs.all (\u00b7.isFVar) then\n    return (discrs.map (\u00b7.fvarId!), #[], mvarId)\n  let some matcherInfo \u2190 getMatcherInfo? matcherDeclName | unreachable!\n  let numDiscrEqs := matcherInfo.getNumDiscrEqs let (targetNew, rfls) \u2190\n    forallTelescope motiveType fun discrVars _ =>\n    withEqs discrs discrVars fun eqs rfls => do\n      let foundRef \u2190 IO.mkRef false\n      let rec mkNewTarget (e : Expr) : MetaM Expr := do\n        let pre (e : Expr) : MetaM TransformStep := do\n          if !e.isAppOf matcherDeclName || e.getAppNumArgs != matcherInfo.arity then\n            return .continue\n          let some matcherApp \u2190 matchMatcherApp? e | return .continue\n          for matcherDiscr in matcherApp.discrs, discr in discrs do\n            unless matcherDiscr == discr do\n              trace[Meta.Tactic.split] \"discr mismatch {matcherDiscr} != {discr}\"\n              return .continue\n          let matcherApp := { matcherApp with discrs := discrVars }\n          foundRef.set true\n          let mut altsNew := #[]\n          for i in [:matcherApp.alts.size] do\n            let alt := matcherApp.alts[i]!\n            let altNumParams := matcherApp.altNumParams[i]!\n            let altNew \u2190 lambdaTelescope alt fun xs body => do\n              if xs.size < altNumParams || xs.size < numDiscrEqs then\n                throwError \"'applyMatchSplitter' failed, unexpected `match` alternative\"\n              let body \u2190 mkLambdaFVars xs[altNumParams:] (\u2190 mkNewTarget body)\n              let ys  := xs[:altNumParams - numDiscrEqs]\n              if numDiscrEqs == 0 then\n                mkLambdaFVars ys body\n              else\n                let altEqs := xs[altNumParams - numDiscrEqs : altNumParams]\n                withNewAltEqs matcherInfo eqs altEqs fun altEqsNew subst => do\n                  let body := body.replaceFVars altEqs subst\n                  mkLambdaFVars (ys++altEqsNew) body\n            altsNew := altsNew.push altNew\n          return .done { matcherApp with alts := altsNew }.toExpr\n        transform (\u2190 instantiateMVars e) pre\n      let targetNew \u2190 mkNewTarget (\u2190 mvarId.getType)\n      unless (\u2190 foundRef.get) do\n        throwError \"'applyMatchSplitter' failed, did not find discriminants\"\n      let targetNew \u2190 mkForallFVars (discrVars ++ eqs) targetNew\n      unless (\u2190 isTypeCorrect targetNew) do\n        throwError \"'applyMatchSplitter' failed, failed to generalize target\"\n      return (targetNew, rfls)\n    let mvarNew \u2190 mkFreshExprSyntheticOpaqueMVar targetNew (\u2190 mvarId.getTag)\n    trace[Meta.Tactic.split] \"targetNew:\\n{mvarNew.mvarId!}\"\n    mvarId.assign (mkAppN (mkAppN mvarNew discrs) rfls)\n    let (discrs', mvarId') \u2190 mvarNew.mvarId!.introNP discrs.size\n    let (discrEqs, mvarId') \u2190 mvarId'.introNP discrs.size\n    return (discrs', discrEqs, mvarId')\nwhere\n  \n  withNewAltEqs (matcherInfo : MatcherInfo) (eqs : Array Expr) (altEqs : Array Expr) (k : Array Expr \u2192 Array Expr \u2192 MetaM Expr) : MetaM Expr := do\n    let eqs' := (eqs.zip matcherInfo.discrInfos).filterMap fun (eq, info) => if info.hName?.isNone then none else some eq\n    let rec go (i : Nat) (altEqsNew : Array Expr) (subst : Array Expr) : MetaM Expr := do\n      if i < altEqs.size then\n        let altEqDecl \u2190 getFVarLocalDecl altEqs[i]!\n        let eq := eqs'[i]!\n        let eqType \u2190 inferType eq\n        let altEqType := altEqDecl.type\n        match eqType.eq?, altEqType.eq? with\n        | some (_, _, discrVar), some (_, _ , pattern) =>\n          withLocalDeclD altEqDecl.userName (\u2190 mkEq discrVar pattern) fun altEqNew => do\n            go (i+1) (altEqsNew.push altEqNew) (subst.push (\u2190 mkEqTrans eq altEqNew))\n        | _, _ =>\n        match eqType.heq?, altEqType.heq? with\n        | some (_, _, _, discrVar), some (_, _ , _, pattern) =>\n          withLocalDeclD altEqDecl.userName (\u2190 mkHEq discrVar pattern) fun altEqNew => do\n            go (i+1) (altEqsNew.push altEqNew) (subst.push (\u2190 mkHEqTrans eq altEqNew))\n        | _, _ =>\n          throwError \"'applyMatchSplitter' failed, unexpected discriminant equalities\"\n      else\n        k altEqsNew subst\n    go 0 #[] #[]", "start": [79, 1], "end": [191, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.substDiscrEqs", "code": "private def substDiscrEqs (mvarId : MVarId) (fvarSubst : FVarSubst) (discrEqs : Array FVarId) : MetaM MVarId := mvarId.withContext do\n  let mut mvarId := mvarId\n  let mut fvarSubst := fvarSubst\n  for fvarId in discrEqs do\n    if let .fvar fvarId := fvarSubst.apply (mkFVar fvarId) then\n      let (fvarId, mvarId') \u2190 heqToEq mvarId fvarId\n      match (\u2190 substCore? mvarId' fvarId (symm := false) fvarSubst) with\n      | some (fvarSubst', mvarId') => mvarId := mvarId'; fvarSubst := fvarSubst'\n      | none =>\n      match (\u2190 substCore? mvarId' fvarId (symm := true) fvarSubst) with\n      | some (fvarSubst', mvarId') => mvarId := mvarId'; fvarSubst := fvarSubst'\n      | none => mvarId := mvarId'\n  return mvarId", "start": [193, 1], "end": [205, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.applyMatchSplitter", "code": "def applyMatchSplitter (mvarId : MVarId) (matcherDeclName : Name) (us : Array Level) (params : Array Expr) (discrs : Array Expr) : MetaM (List MVarId) := do\n  let some info \u2190 getMatcherInfo? matcherDeclName | throwError \"'applyMatchSplitter' failed, '{matcherDeclName}' is not a 'match' auxiliary declaration.\"\n  let matchEqns \u2190 Match.getEquationsFor matcherDeclName\n  let splitterPre := mkAppN (mkConst matchEqns.splitterName us.toList) params\n  let motiveType := (\u2190 whnfForall (\u2190 inferType splitterPre)).bindingDomain!\n  trace[Meta.Tactic.split] \"applyMatchSplitter\\n{mvarId}\"\n  let (discrFVarIds, discrEqs, mvarId) \u2190 generalizeMatchDiscrs mvarId matcherDeclName motiveType discrs\n  trace[Meta.Tactic.split] \"after generalizeMatchDiscrs\\n{mvarId}\"\n  let mvarId \u2190 generalizeTargetsEq mvarId motiveType (discrFVarIds.map mkFVar)\n  mvarId.withContext do trace[Meta.Tactic.split] \"discrEqs after generalizeTargetsEq: {discrEqs.map mkFVar}\"\n  trace[Meta.Tactic.split] \"after generalize\\n{mvarId}\"\n  let numEqs := discrs.size\n  let (discrFVarIdsNew, mvarId) \u2190 mvarId.introN discrs.size\n  trace[Meta.Tactic.split] \"after introN\\n{mvarId}\"\n  let discrsNew := discrFVarIdsNew.map mkFVar\n  let mvarType \u2190 mvarId.getType\n  let elimUniv \u2190 mvarId.withContext <| getLevel mvarType\n  let us \u2190 if let some uElimPos := info.uElimPos? then\n    pure <| us.set! uElimPos elimUniv\n  else\n    unless elimUniv.isZero do\n      throwError \"match-splitter can only eliminate into `Prop`\"\n    pure us\n  let splitter := mkAppN (mkConst matchEqns.splitterName us.toList) params\n  mvarId.withContext do\n    let motive \u2190 mkLambdaFVars discrsNew mvarType\n    let splitter := mkAppN (mkApp splitter motive) discrsNew\n    check splitter\n    trace[Meta.Tactic.split] \"after check splitter\"\n    let mvarIds \u2190 mvarId.apply splitter\n    unless mvarIds.length == matchEqns.size do\n      throwError \"'applyMatchSplitter' failed, unexpected number of goals created after applying splitter for '{matcherDeclName}'.\"\n    let (_, mvarIds) \u2190 mvarIds.foldlM (init := (0, [])) fun (i, mvarIds) mvarId => do\n      let numParams := matchEqns.splitterAltNumParams[i]!\n      let (_, mvarId) \u2190 mvarId.introN numParams\n      trace[Meta.Tactic.split] \"before unifyEqs\\n{mvarId}\"\n      match (\u2190 Cases.unifyEqs? (numEqs + info.getNumDiscrEqs) mvarId {}) with\n      | none   => return (i+1, mvarIds) | some (mvarId, fvarSubst) =>\n        trace[Meta.Tactic.split] \"after unifyEqs\\n{mvarId}\"\n        let mvarId \u2190 substDiscrEqs mvarId fvarSubst discrEqs\n        return (i+1, mvarId::mvarIds)\n    return mvarIds.reverse", "start": [207, 1], "end": [251, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.splitMatch", "code": "def splitMatch (mvarId : MVarId) (e : Expr) : MetaM (List MVarId) := do\n  try\n    let some app \u2190 matchMatcherApp? e | throwError \"match application expected\"\n    let matchEqns \u2190 Match.getEquationsFor app.matcherName\n    let mvarIds \u2190 applyMatchSplitter mvarId app.matcherName app.matcherLevels app.params app.discrs\n    let (_, mvarIds) \u2190 mvarIds.foldlM (init := (0, [])) fun (i, mvarIds) mvarId => do\n      let mvarId \u2190 simpMatchTargetCore mvarId app.matcherName matchEqns.eqnNames[i]!\n      return (i+1, mvarId::mvarIds)\n    return mvarIds.reverse\n  catch ex =>\n    throwNestedTacticEx `splitMatch ex", "start": [253, 1], "end": [263, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Split.findSplit?", "code": "partial def findSplit? (env : Environment) (e : Expr) (splitIte := true) (exceptionSet : ExprSet := {}) : Option Expr :=\n  go e\nwhere\n  go (e : Expr) : Option Expr :=\n    if let some target := e.find? isCandidate then\n      if e.isIte || e.isDIte then\n        let cond := target.getArg! 1 5\n        go cond |>.getD target\n      else\n        some target\n    else\n      none\n\n  isCandidate (e : Expr) : Bool := Id.run do\n    if exceptionSet.contains e then\n      false\n    else if splitIte && (e.isIte || e.isDIte) then\n      !(e.getArg! 1 5).hasLooseBVars\n    else if let some info := isMatcherAppCore? env e then\n      let args := e.getAppArgs\n      for i in [info.getFirstDiscrPos : info.getFirstDiscrPos + info.numDiscrs] do\n        if args[i]!.hasLooseBVars then\n          return false\n      return true\n    else\n      false", "start": [265, 1], "end": [292, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.splitTarget?", "code": "partial def splitTarget? (mvarId : MVarId) (splitIte := true) : MetaM (Option (List MVarId)) := commitWhenSome? do\n  let target \u2190 instantiateMVars (\u2190 mvarId.getType)\n  let rec go (badCases : ExprSet) : MetaM (Option (List MVarId)) := do\n    if let some e := findSplit? (\u2190 getEnv) target splitIte badCases then\n      if e.isIte || e.isDIte then\n        return (\u2190 splitIfTarget? mvarId).map fun (s\u2081, s\u2082) => [s\u2081.mvarId, s\u2082.mvarId]\n      else\n        try\n          splitMatch mvarId e\n        catch _ =>\n          go (badCases.insert e)\n    else\n      trace[Meta.Tactic.split] \"did not find term to split\\n{MessageData.ofGoal mvarId}\"\n      return none\n  go {}", "start": [298, 1], "end": [312, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.splitLocalDecl?", "code": "def splitLocalDecl? (mvarId : MVarId) (fvarId : FVarId) : MetaM (Option (List MVarId)) := commitWhenSome? do\n  mvarId.withContext do\n    if let some e := findSplit? (\u2190 getEnv) (\u2190 instantiateMVars (\u2190 inferType (mkFVar fvarId))) then\n      if e.isIte || e.isDIte then\n        return (\u2190 splitIfLocalDecl? mvarId fvarId).map fun (mvarId\u2081, mvarId\u2082) => [mvarId\u2081, mvarId\u2082]\n      else\n        let (fvarIds, mvarId) \u2190 mvarId.revert #[fvarId]\n        let num := fvarIds.size\n        let mvarIds \u2190 splitMatch mvarId e\n        let mvarIds \u2190 mvarIds.mapM fun mvarId => return (\u2190 mvarId.introNP num).2\n        return some mvarIds\n    else\n      return none", "start": [314, 1], "end": [326, 18], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Nat.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Solver.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Main.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith/Simp.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Unfold.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Delta.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eqns.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.getSimpUnfoldContext", "code": "private def getSimpUnfoldContext : MetaM Simp.Context :=\n   return {\n      congrTheorems := (\u2190 getSimpCongrTheorems)\n      config        := Simp.neutralConfig\n   }", "start": [12, 1], "end": [16, 5], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfold", "code": "def unfold (e : Expr) (declName : Name) : MetaM Simp.Result := do\n  if let some unfoldThm \u2190 getUnfoldEqnFor? declName  then\n    (\u00b7.1) <$> Simp.main e (\u2190 getSimpUnfoldContext) (methods := { pre := pre unfoldThm })\n  else\n    return { expr  := (\u2190 deltaExpand e (\u00b7 == declName)) }\nwhere\n  pre (unfoldThm : Name) (e : Expr) : SimpM Simp.Step := do\n    match (\u2190 withReducible <| Simp.tryTheorem? e { origin := .decl unfoldThm, proof := mkConst unfoldThm, rfl := (\u2190 isRflTheorem unfoldThm) } (fun _ => return none)) with\n    | none   => pure ()\n    | some r => match (\u2190 reduceMatcher? r.expr) with\n      | .reduced e' => return Simp.Step.done { r with expr := e' }\n      | _ => return Simp.Step.done r\n    return Simp.Step.visit { expr := e }", "start": [18, 1], "end": [30, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldTarget", "code": "def unfoldTarget (mvarId : MVarId) (declName : Name) : MetaM MVarId := mvarId.withContext do\n  let target \u2190 instantiateMVars (\u2190 mvarId.getType)\n  let r \u2190 unfold target declName\n  if r.expr == target then throwError \"tactic 'unfold' failed to unfold '{declName}' at{indentExpr target}\"\n  applySimpResultToTarget mvarId target r", "start": [32, 1], "end": [36, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldLocalDecl", "code": "def unfoldLocalDecl (mvarId : MVarId) (fvarId : FVarId) (declName : Name) : MetaM MVarId := mvarId.withContext do\n  let type \u2190 fvarId.getType\n  let r \u2190 unfold (\u2190 instantiateMVars type) declName\n  if r.expr == type then throwError \"tactic 'unfold' failed to unfold '{declName}' at{indentExpr type}\"\n  let some (_, mvarId) \u2190 applySimpResultToLocalDecl mvarId fvarId r (mayCloseGoal := false) | unreachable!\n  return mvarId", "start": [38, 1], "end": [43, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Types.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpCongrTheorems.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpTheorems.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/SimpAll.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/AC.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/AC/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/ElimInfo.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.ElimAltInfo", "code": "structure ElimAltInfo where\n  name      : Name\n  declName? : Option Name\n  numFields : Nat\n  deriving Repr, Inhabited", "start": [12, 1], "end": [16, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ElimInfo", "code": "structure ElimInfo where\n  name       : Name\n  motivePos  : Nat\n  targetsPos : Array Nat := #[]\n  altsInfo   : Array ElimAltInfo := #[]\n  deriving Repr, Inhabited", "start": [18, 1], "end": [23, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getElimInfo", "code": "def getElimInfo (declName : Name) (baseDeclName? : Option Name := none) : MetaM ElimInfo := do\n  let declInfo \u2190 getConstInfo declName\n  forallTelescopeReducing declInfo.type fun xs type => do\n    let motive  := type.getAppFn\n    let targets := type.getAppArgs\n    unless motive.isFVar && targets.all (\u00b7.isFVar) && targets.size > 0 do\n      throwError \"unexpected eliminator resulting type{indentExpr type}\"\n    let motiveType \u2190 inferType motive\n    forallTelescopeReducing motiveType fun motiveArgs motiveResultType => do\n      unless motiveArgs.size == targets.size do\n        throwError \"unexpected number of arguments at motive type{indentExpr motiveType}\"\n      unless motiveResultType.isSort do\n        throwError \"motive result type must be a sort{indentExpr motiveType}\"\n    let some motivePos \u2190 pure (xs.indexOf? motive) |\n      throwError \"unexpected eliminator type{indentExpr declInfo.type}\"\n    let targetsPos \u2190 targets.mapM fun target => do\n      match xs.indexOf? target with\n      | none => throwError \"unexpected eliminator type{indentExpr declInfo.type}\"\n      | some targetPos => pure targetPos.val\n    let mut altsInfo := #[]\n    let env \u2190 getEnv\n    for i in [:xs.size] do\n      let x := xs[i]!\n      if x != motive && !targets.contains x then\n        let xDecl \u2190 x.fvarId!.getDecl\n        if xDecl.binderInfo.isExplicit then\n          let numFields \u2190 forallTelescopeReducing xDecl.type fun args _ => pure args.size\n          let name := xDecl.userName\n          let declName? := do\n            let base \u2190 baseDeclName?\n            let altDeclName := base ++ name\n            if env.contains altDeclName then some altDeclName else none\n          altsInfo := altsInfo.push { name, declName?, numFields }\n    pure { name := declName, motivePos, targetsPos, altsInfo }", "start": [25, 1], "end": [58, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addImplicitTargets", "code": "partial def addImplicitTargets (elimInfo : ElimInfo) (targets : Array Expr) : MetaM (Array Expr) :=\n  withNewMCtxDepth do\n    let f \u2190 mkConstWithFreshMVarLevels elimInfo.name\n    let targets \u2190 collect (\u2190 inferType f) 0 0 #[]\n    let targets \u2190 targets.mapM instantiateMVars\n    for target in targets do\n      if (\u2190 hasAssignableMVar target) then\n        throwError \"failed to infer implicit target, it contains unresolved metavariables{indentExpr target}\"\n    return targets\nwhere\n  collect (type : Expr) (argIdx targetIdx : Nat) (targets' : Array Expr) : MetaM (Array Expr) := do\n    match (\u2190 whnfD type) with\n    | Expr.forallE _ d b bi =>\n      if elimInfo.targetsPos.contains argIdx then\n        if bi.isExplicit then\n          unless targetIdx < targets.size do\n            throwError \"insufficient number of targets for '{elimInfo.name}'\"\n          let target := targets[targetIdx]!\n          let targetType \u2190 inferType target\n          unless (\u2190 isDefEq d targetType) do\n            throwError \"target{indentExpr target}\\n{\u2190 mkHasTypeButIsExpectedMsg targetType d}\"\n          collect (b.instantiate1 target) (argIdx+1) (targetIdx+1) (targets'.push target)\n        else\n          let implicitTarget \u2190 mkFreshExprMVar d\n          collect (b.instantiate1 implicitTarget) (argIdx+1) targetIdx (targets'.push implicitTarget)\n      else\n        collect (b.instantiate1 (\u2190 mkFreshExprMVar d)) (argIdx+1) targetIdx targets'\n    | _ =>\n      return targets'", "start": [60, 1], "end": [93, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CustomEliminator", "code": "structure CustomEliminator where\n  typeNames : Array Name\n  elimInfo  : ElimInfo\n  deriving Inhabited, Repr", "start": [95, 1], "end": [98, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CustomEliminators", "code": "structure CustomEliminators where\n  map : SMap (Array Name) ElimInfo := {}\n  deriving Inhabited, Repr", "start": [100, 1], "end": [102, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addCustomEliminatorEntry", "code": "def addCustomEliminatorEntry (es : CustomEliminators) (e : CustomEliminator) : CustomEliminators :=\n  match es with\n  | { map := map } => { map := map.insert e.typeNames e.elimInfo }", "start": [104, 1], "end": [106, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkCustomEliminator", "code": "def mkCustomEliminator (declName : Name) : MetaM CustomEliminator := do\n  let info \u2190 getConstInfo declName\n  let elimInfo \u2190 getElimInfo declName\n  forallTelescopeReducing info.type fun xs _ => do\n    let mut typeNames := #[]\n    for i in [:elimInfo.targetsPos.size] do\n      let targetPos := elimInfo.targetsPos[i]!\n      let x := xs[targetPos]!\n      \n      let isImplicitTarget : MetaM Bool := do\n        for j in [i+1:elimInfo.targetsPos.size] do\n          let y := xs[elimInfo.targetsPos[j]!]!\n          let yType \u2190 inferType y\n          if (\u2190 dependsOn yType x.fvarId!) then\n            return true\n        return false\n      \n      unless (\u2190 isImplicitTarget) do\n        let xType \u2190 inferType x\n        let .const typeName .. := xType.getAppFn | throwError \"unexpected eliminator target type{indentExpr xType}\"\n        typeNames := typeNames.push typeName\n    return { typeNames, elimInfo }", "start": [115, 1], "end": [137, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addCustomEliminator", "code": "def addCustomEliminator (declName : Name) (attrKind : AttributeKind) : MetaM Unit := do\n  let e \u2190 mkCustomEliminator declName\n  customEliminatorExt.add e attrKind", "start": [139, 1], "end": [141, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getCustomEliminators", "code": "def getCustomEliminators : CoreM CustomEliminators := do\n  return customEliminatorExt.getState (\u2190 getEnv)", "start": [151, 1], "end": [152, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getCustomEliminator?", "code": "def getCustomEliminator? (targets : Array Expr) : MetaM (Option ElimInfo) := do\n  let mut key := #[]\n  for target in targets do\n    let targetType := (\u2190 instantiateMVars (\u2190 inferType target)).headBeta\n    let .const declName .. := targetType.getAppFn | return none\n    key := key.push declName\n  return customEliminatorExt.getState (\u2190 getEnv) |>.map.find? key", "start": [154, 1], "end": [160, 66], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Congr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/CongrTheorems.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Refl.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean"], "premises": [{"full_name": "Lean.MVarId.congrPre", "code": "def MVarId.congrPre (mvarId : MVarId) : MetaM (Option MVarId) := do\n  let mvarId \u2190 mvarId.heqOfEq\n  try mvarId.refl; return none catch _ => pure ()\n  try mvarId.hrefl; return none catch _ => pure ()\n  if (\u2190 mvarId.assumptionCore) then return none\n  return some mvarId", "start": [16, 1], "end": [26, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.applyCongrThm?", "code": "private def applyCongrThm? (mvarId : MVarId) (congrThm : CongrTheorem) : MetaM (List MVarId) := do\n  let mvarId \u2190 mvarId.assert (\u2190 mkFreshUserName `h_congr_thm) congrThm.type congrThm.proof\n  let (fvarId, mvarId) \u2190 mvarId.intro1P\n  let mvarIds \u2190 mvarId.apply (mkFVar fvarId) { synthAssignedInstances := false }\n  mvarIds.mapM fun mvarId => mvarId.tryClear fvarId", "start": [28, 1], "end": [36, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congr?", "code": "def MVarId.congr? (mvarId : MVarId) : MetaM (Option (List MVarId)) :=\n  mvarId.withContext do commitWhenSomeNoEx? do\n    mvarId.checkNotAssigned `congr\n    let target \u2190 mvarId.getType'\n    let some (_, lhs, _) := target.eq? | return none\n    let lhs := lhs.cleanupAnnotations\n    unless lhs.isApp do return none\n    let some congrThm \u2190 mkCongrSimp? lhs.getAppFn (subsingletonInstImplicitRhs := false) | return none\n    applyCongrThm? mvarId congrThm", "start": [38, 1], "end": [49, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.hcongr?", "code": "def MVarId.hcongr? (mvarId : MVarId) : MetaM (Option (List MVarId)) := do\n  commitWhenSomeNoEx? do\n    mvarId.checkNotAssigned `congr\n    let mvarId \u2190 mvarId.eqOfHEq\n    mvarId.withContext do\n      let target \u2190 mvarId.getType'\n      let some (_, lhs, _, _) := target.heq? | return none\n      let lhs := lhs.cleanupAnnotations\n      unless lhs.isApp do return none\n      let congrThm \u2190 mkHCongr lhs.getAppFn\n      applyCongrThm? mvarId congrThm", "start": [51, 1], "end": [65, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congrImplies?", "code": "def MVarId.congrImplies? (mvarId : MVarId) : MetaM (Option (List MVarId)) :=\n  observing? do\n    let mvarId\u2081 :: mvarId\u2082 :: _ \u2190 mvarId.apply (\u2190 mkConstWithFreshMVarLevels ``implies_congr) | throwError \"unexpected number of goals\"\n    return [mvarId\u2081, mvarId\u2082]", "start": [67, 1], "end": [73, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congrCore", "code": "def MVarId.congrCore (mvarId : MVarId) : MetaM (List MVarId) := do\n  if let some mvarIds \u2190 mvarId.congr? then\n    pure mvarIds\n  else if let some mvarIds \u2190 mvarId.hcongr? then\n    pure mvarIds\n  else if let some mvarIds \u2190 mvarId.congrImplies? then\n    pure mvarIds\n  else\n    throwTacticEx `congr mvarId \"failed to apply congruence\"", "start": [75, 1], "end": [87, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.congrN", "code": "def MVarId.congrN (mvarId : MVarId) (depth : Nat := 1000000) (closePre := true) (closePost := true) : MetaM (List MVarId) := do\n  let (_, s) \u2190 go depth mvarId |>.run #[]\n  return s.toList\nwhere\n  post (mvarId : MVarId) : StateRefT (Array MVarId) MetaM Unit := do\n    if closePost && (\u2190 getTransparency) != .reducible then\n      if let some mvarId \u2190 mvarId.congrPre then\n        modify (\u00b7.push mvarId)\n    else\n      modify (\u00b7.push mvarId)\n\n  go (n : Nat) (mvarId : MVarId) : StateRefT (Array MVarId) MetaM Unit := do\n    if let some mvarId \u2190 if closePre then withReducible mvarId.congrPre else pure mvarId then\n      match n with\n      | 0 => post mvarId\n      | n+1 =>\n        let some mvarIds \u2190 observing? (m := MetaM) mvarId.congrCore\n          | post mvarId\n        mvarIds.forM (go n)", "start": [89, 1], "end": [117, 28], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cleanup.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/CollectFVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.cleanupCore", "code": "private partial def cleanupCore (mvarId : MVarId) : MetaM MVarId := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `cleanup\n    let used \u2190 collectUsed |>.run' (false, {})\n    let mut lctx \u2190 getLCtx\n    for localDecl in lctx do\n      unless used.contains localDecl.fvarId do\n        lctx := lctx.erase localDecl.fvarId\n    let localInsts := (\u2190 getLocalInstances).filter fun inst => used.contains inst.fvar.fvarId!\n    let mvarNew \u2190 mkFreshExprMVarAt lctx localInsts (\u2190 instantiateMVars (\u2190 mvarId.getType)) .syntheticOpaque (\u2190 mvarId.getTag)\n    mvarId.assign mvarNew\n    return mvarNew.mvarId!\nwhere\n  addUsedFVars (e : Expr) : StateRefT (Bool \u00d7 FVarIdSet) MetaM Unit := do\n    let (_, s) \u2190 (\u2190 instantiateMVars e).collectFVars |>.run {}\n    for fvarId in s.fvarSet do\n      addUsedFVar fvarId\n\n  addDeps (fvarId : FVarId) : StateRefT (Bool \u00d7 FVarIdSet) MetaM Unit := do\n    let localDecl \u2190 fvarId.getDecl\n    addUsedFVars localDecl.type\n    if let some val := localDecl.value? then\n      addUsedFVars val\n\n  addUsedFVar (fvarId : FVarId) : StateRefT (Bool \u00d7 FVarIdSet) MetaM Unit := do\n    unless (\u2190 get).2.contains fvarId do\n      modify fun (_, s) => (true, s.insert fvarId)\n      addDeps fvarId\n\n  \n  collectPropsStep : StateRefT (Bool \u00d7 FVarIdSet) MetaM Unit := do\n    let usedSet := (\u2190 get).2\n    for localDecl in (\u2190 getLCtx) do\n      if (\u2190 isProp localDecl.type) then\n        if (\u2190 dependsOnPred localDecl.type usedSet.contains) then\n          addUsedFVar localDecl.fvarId\n\n  collectProps : StateRefT (Bool \u00d7 FVarIdSet) MetaM Unit := do\n    modify fun s => (false, s.2)\n    collectPropsStep\n    if (\u2190 get).1 then\n      collectProps\n\n  collectUsed : StateRefT (Bool \u00d7 FVarIdSet) MetaM FVarIdSet := do\n    addUsedFVars (\u2190 instantiateMVars (\u2190 mvarId.getType))\n    collectProps\n    return (\u2190 get).2", "start": [11, 1], "end": [57, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.cleanup", "code": "abbrev _root_.Lean.MVarId.cleanup (mvarId : MVarId) : MetaM MVarId := do\n  cleanupCore mvarId", "start": [59, 1], "end": [67, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.cleanup", "code": "@[deprecated MVarId.cleanup]\nabbrev cleanup (mvarId : MVarId) : MetaM MVarId := do\n  mvarId.cleanup", "start": [69, 1], "end": [71, 17], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Constructions.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "lake-packages/lean4/src/lean/Lean/AuxRecursor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.mkCasesOnImp", "code": "@[extern \"lean_mk_cases_on\"] opaque mkCasesOnImp (env : Environment) (declName : @& Name) : Except KernelException Environment", "start": [11, 1], "end": [11, 127], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRecOnImp", "code": "@[extern \"lean_mk_rec_on\"] opaque mkRecOnImp (env : Environment) (declName : @& Name) : Except KernelException Environment", "start": [12, 1], "end": [12, 123], "kind": "commanddeclaration"}, {"full_name": "Lean.mkNoConfusionCoreImp", "code": "@[extern \"lean_mk_no_confusion\"] opaque mkNoConfusionCoreImp (env : Environment) (declName : @& Name) : Except KernelException Environment", "start": [13, 1], "end": [13, 139], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBelowImp", "code": "@[extern \"lean_mk_below\"] opaque mkBelowImp (env : Environment) (declName : @& Name) : Except KernelException Environment", "start": [14, 1], "end": [14, 122], "kind": "commanddeclaration"}, {"full_name": "Lean.mkIBelowImp", "code": "@[extern \"lean_mk_ibelow\"] opaque mkIBelowImp (env : Environment) (declName : @& Name) : Except KernelException Environment", "start": [15, 1], "end": [15, 124], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBRecOnImp", "code": "@[extern \"lean_mk_brec_on\"] opaque mkBRecOnImp (env : Environment) (declName : @& Name) : Except KernelException Environment", "start": [16, 1], "end": [16, 125], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBInductionOnImp", "code": "@[extern \"lean_mk_binduction_on\"] opaque mkBInductionOnImp (env : Environment) (declName : @& Name) : Except KernelException Environment", "start": [17, 1], "end": [17, 137], "kind": "commanddeclaration"}, {"full_name": "Lean.adaptFn", "code": "@[inline] private def adaptFn (f : Environment \u2192 Name \u2192 Except KernelException Environment) (declName : Name) : m Unit := do\n  let env \u2190 ofExceptKernelException (f (\u2190 getEnv) declName)\n  modifyEnv fun _ => env", "start": [21, 1], "end": [23, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.mkCasesOn", "code": "def mkCasesOn (declName : Name) : m Unit := adaptFn mkCasesOnImp declName", "start": [25, 1], "end": [25, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.mkRecOn", "code": "def mkRecOn (declName : Name) : m Unit := adaptFn mkRecOnImp declName", "start": [26, 1], "end": [26, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.mkNoConfusionCore", "code": "def mkNoConfusionCore (declName : Name) : m Unit := adaptFn mkNoConfusionCoreImp declName", "start": [27, 1], "end": [27, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBelow", "code": "def mkBelow (declName : Name) : m Unit := adaptFn mkBelowImp declName", "start": [28, 1], "end": [28, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.mkIBelow", "code": "def mkIBelow (declName : Name) : m Unit := adaptFn mkIBelowImp declName", "start": [29, 1], "end": [29, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBRecOn", "code": "def mkBRecOn (declName : Name) : m Unit := adaptFn mkBRecOnImp declName", "start": [30, 1], "end": [30, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.mkBInductionOn", "code": "def mkBInductionOn (declName : Name) : m Unit := adaptFn mkBInductionOnImp declName", "start": [31, 1], "end": [31, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.mkNoConfusionEnum", "code": "def mkNoConfusionEnum (enumName : Name) : MetaM Unit := do\n  if (\u2190 getEnv).contains ``noConfusionEnum then\n    mkToCtorIdx\n    mkNoConfusionType\n    mkNoConfusion\n  else\n    mkNoConfusionCore enumName\nwhere\n\n  mkToCtorIdx : MetaM Unit := do\n    let ConstantInfo.inductInfo info \u2190 getConstInfo enumName | unreachable!\n    let us := info.levelParams.map mkLevelParam\n    let numCtors := info.ctors.length\n    let declName := Name.mkStr enumName \"toCtorIdx\"\n    let enumType := mkConst enumName us\n    let natType  := mkConst ``Nat\n    let declType \u2190 mkArrow enumType natType\n    let mut minors := #[]\n    for i in [:numCtors] do\n      minors := minors.push <| mkNatLit i\n    withLocalDeclD `x enumType fun x => do\n      let motive \u2190 mkLambdaFVars #[x] natType\n      let declValue \u2190 mkLambdaFVars #[x] <| mkAppN (mkApp2 (mkConst (mkCasesOnName enumName) (levelOne::us)) motive x) minors\n      addAndCompile <| Declaration.defnDecl {\n        name        := declName\n        levelParams := info.levelParams\n        type        := declType\n        value       := declValue\n        safety      := DefinitionSafety.safe\n        hints       := ReducibilityHints.abbrev\n      }\n      setReducibleAttribute declName\n\n  mkNoConfusionType : MetaM Unit := do\n    let ConstantInfo.inductInfo info \u2190 getConstInfo enumName | unreachable!\n    let us := info.levelParams.map mkLevelParam\n    let v \u2190 mkFreshUserName `v\n    let enumType := mkConst enumName us\n    let sortV := mkSort (mkLevelParam v)\n    let toCtorIdx := mkConst (Name.mkStr enumName \"toCtorIdx\") us\n    withLocalDeclD `P sortV fun P =>\n    withLocalDeclD `x enumType fun x =>\n    withLocalDeclD `y enumType fun y => do\n      let declType  \u2190 mkForallFVars #[P, x, y] sortV\n      let declValue \u2190 mkLambdaFVars #[P, x, y] (\u2190 mkAppM ``noConfusionTypeEnum #[toCtorIdx, P, x, y])\n      let declName  := Name.mkStr enumName \"noConfusionType\"\n      addAndCompile <| Declaration.defnDecl {\n        name        := declName\n        levelParams := v :: info.levelParams\n        type        := declType\n        value       := declValue\n        safety      := DefinitionSafety.safe\n        hints       := ReducibilityHints.abbrev\n      }\n      setReducibleAttribute declName\n\n  mkNoConfusion : MetaM Unit := do\n    let ConstantInfo.inductInfo info \u2190 getConstInfo enumName | unreachable!\n    let us := info.levelParams.map mkLevelParam\n    let v \u2190 mkFreshUserName `v\n    let enumType := mkConst enumName us\n    let sortV := mkSort (mkLevelParam v)\n    let toCtorIdx := mkConst (Name.mkStr enumName \"toCtorIdx\") us\n    let noConfusionType := mkConst (Name.mkStr enumName \"noConfusionType\") (mkLevelParam v :: us)\n    withLocalDecl `P BinderInfo.implicit sortV fun P =>\n    withLocalDecl `x BinderInfo.implicit enumType fun x =>\n    withLocalDecl `y BinderInfo.implicit enumType fun y => do\n    withLocalDeclD `h (\u2190 mkEq x y) fun h => do\n      let declType  \u2190 mkForallFVars #[P, x, y, h] (mkApp3 noConfusionType P x y)\n      let declValue \u2190 mkLambdaFVars #[P, x, y, h] (\u2190 mkAppOptM ``noConfusionEnum #[none, none, none, toCtorIdx, P, x, y, h])\n      let declName  := Name.mkStr enumName \"noConfusion\"\n      addAndCompile <| Declaration.defnDecl {\n        name        := declName\n        levelParams := v :: info.levelParams\n        type        := declType\n        value       := declValue\n        safety      := DefinitionSafety.safe\n        hints       := ReducibilityHints.abbrev\n      }\n      setReducibleAttribute declName\n      modifyEnv fun env => markNoConfusion env declName", "start": [35, 1], "end": [116, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.mkNoConfusion", "code": "def mkNoConfusion (declName : Name) : MetaM Unit := do\n  if (\u2190 isEnumType declName) then\n    mkNoConfusionEnum declName\n  else\n    mkNoConfusionCore declName", "start": [118, 1], "end": [122, 31], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match/MatchEqs.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Match/Match.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/SplitIf.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Contradiction.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Refl.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatchEqsExt.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Delta.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Injection.lean"], "premises": [{"full_name": "Lean.Meta.casesOnStuckLHS", "code": "partial def casesOnStuckLHS (mvarId : MVarId) : MetaM (Array MVarId) := do\n  let target \u2190 mvarId.getType\n  if let some (_, lhs, _) \u2190 matchEq? target then\n    if let some fvarId \u2190 findFVar? lhs then\n      return (\u2190  mvarId.cases fvarId).map fun s => s.mvarId\n  throwError \"'casesOnStuckLHS' failed\"\nwhere\n  findFVar? (e : Expr) : MetaM (Option FVarId) := do\n    match e.getAppFn with\n    | Expr.proj _ _ e => findFVar? e\n    | f =>\n      if !f.isConst then\n        return none\n      else\n        let declName := f.constName!\n        let args := e.getAppArgs\n        match (\u2190 getProjectionFnInfo? declName) with\n        | some projInfo =>\n          if projInfo.numParams < args.size then\n            findFVar? args[projInfo.numParams]!\n          else\n            return none\n        | none =>\n          matchConstRec f (fun _ => return none) fun recVal _ => do\n            if recVal.getMajorIdx >= args.size then\n              return none\n            let major := args[recVal.getMajorIdx]!\n            if major.isFVar then\n              return some major.fvarId!\n            else\n              return none", "start": [17, 1], "end": [50, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.casesOnStuckLHS?", "code": "def casesOnStuckLHS? (mvarId : MVarId) : MetaM (Option (Array MVarId)) := do\n  try casesOnStuckLHS mvarId catch _ => return none", "start": [52, 1], "end": [53, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.unfoldNamedPattern", "code": "def unfoldNamedPattern (e : Expr) : MetaM Expr := do\n  let visit (e : Expr) : MetaM TransformStep := do\n    if let some e := isNamedPattern? e then\n      if let some eNew \u2190 unfoldDefinition? e then\n        return TransformStep.visit eNew\n    return .continue\n  Meta.transform e (pre := visit)", "start": [57, 1], "end": [63, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.forallAltTelescope", "code": "partial def forallAltTelescope (altType : Expr) (numNonEqParams : Nat)\n    (k : (ys : Array Expr) \u2192 (eqs : Array Expr) \u2192 (args : Array Expr) \u2192 (mask : Array Bool) \u2192 (type : Expr) \u2192 MetaM \u03b1)\n    : MetaM \u03b1 := do\n  go #[] #[] #[] #[] 0 altType\nwhere\n  go (ys : Array Expr) (eqs : Array Expr) (args : Array Expr) (mask : Array Bool) (i : Nat) (type : Expr) : MetaM \u03b1 := do\n    let type \u2190 whnfForall type\n    match type with\n    | Expr.forallE n d b .. =>\n      if i < numNonEqParams then\n        let d \u2190 unfoldNamedPattern d\n        withLocalDeclD n d fun y => do\n          let typeNew := b.instantiate1 y\n          if let some (_, lhs, rhs) \u2190 matchEq? d then\n            if lhs.isFVar && ys.contains lhs && args.contains lhs && isNamedPatternProof typeNew y then\n               let some i  := ys.getIdx? lhs | unreachable!\n               let ys      := ys.eraseIdx i\n               let some j  := args.getIdx? lhs | unreachable!\n               let mask    := mask.set! j false\n               let args    := args.map fun arg => if arg == lhs then rhs else arg\n               let args    := args.push (\u2190 mkEqRefl rhs)\n               let typeNew := typeNew.replaceFVar lhs rhs\n               return (\u2190 go ys eqs args (mask.push false) (i+1) typeNew)\n          go (ys.push y) eqs (args.push y) (mask.push true) (i+1) typeNew\n      else\n        let arg \u2190 if let some (_, _, rhs) \u2190 matchEq? d then\n          mkEqRefl rhs\n        else if let some (_, _, _, rhs) \u2190 matchHEq? d then\n          mkHEqRefl rhs\n        else\n          throwError \"unexpected match alternative type{indentExpr altType}\"\n        withLocalDeclD n d fun eq => do\n          let typeNew := b.instantiate1 eq\n          go ys (eqs.push eq) (args.push arg) (mask.push false) (i+1) typeNew\n    | _ =>\n      let type \u2190 unfoldNamedPattern type\n      \n      if ys.size == 1 then\n        if (\u2190 inferType ys[0]!).isConstOf ``Unit && !(\u2190 dependsOn type ys[0]!.fvarId!) then\n          return (\u2190 k #[] #[] #[mkConst ``Unit.unit] #[false] type)\n      k ys eqs args mask type\n\n  isNamedPatternProof (type : Expr) (h : Expr) : Bool :=\n    Option.isSome <| type.find? fun e =>\n      if let some e := isNamedPattern? e then\n        e.appArg! == h\n      else\n        false", "start": [65, 1], "end": [131, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.SimpH.State", "code": "structure State where\n  mvarId : MVarId            xs  : List FVarId          eqs : List FVarId          eqsNew : List FVarId := []", "start": [135, 1], "end": [149, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.SimpH.M", "code": "abbrev M := StateRefT State MetaM", "start": [151, 1], "end": [151, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.SimpH.applySubst", "code": "private def applySubst (s : FVarSubst) (fvarIds : List FVarId) : List FVarId :=\n  fvarIds.filterMap fun fvarId => match s.apply (mkFVar fvarId) with\n    | Expr.fvar fvarId .. => some fvarId\n    | _ => none", "start": [153, 1], "end": [160, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.SimpH.substRHS", "code": "private def substRHS (eq : FVarId) (rhs : FVarId) : M Unit := do\n  assert! (\u2190 get).xs.contains rhs\n  let (subst, mvarId) \u2190 substCore (\u2190 get).mvarId eq (symm := true)\n  modify fun s => { s with\n    mvarId,\n    xs  := applySubst subst (s.xs.erase rhs)\n    eqs := applySubst subst s.eqs\n    eqsNew := applySubst subst s.eqsNew\n  }", "start": [162, 1], "end": [174, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.SimpH.isDone", "code": "private def isDone : M Bool :=\n  return (\u2190 get).eqs.isEmpty", "start": [176, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.SimpH.contradiction", "code": "private def contradiction (mvarId : MVarId) : MetaM Bool :=\n   mvarId.contradictionCore { genDiseq := false, emptyType := false }", "start": [179, 1], "end": [181, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.SimpH.trySubstVarsAndContradiction", "code": "partial def trySubstVarsAndContradiction (mvarId : MVarId) : MetaM Bool :=\n  commitWhen do\n    let mvarId \u2190 substVars mvarId\n    match (\u2190 injections mvarId) with\n    | .solved => return true | .subgoal mvarId' _ =>\n      if mvarId' == mvarId then\n        contradiction mvarId\n      else\n        trySubstVarsAndContradiction mvarId'", "start": [183, 1], "end": [196, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.SimpH.processNextEq", "code": "private def processNextEq : M Bool := do\n  let s \u2190 get\n  s.mvarId.withContext do\n    if (\u2190 contradiction s.mvarId) then\n      return false\n    if let eq :: eqs := s.eqs then\n      modify fun s => { s with eqs }\n      let eqType \u2190 inferType (mkFVar eq)\n      if let some (_, lhs, rhs) \u2190 matchEq? eqType then\n        if (\u2190 isDefEq lhs rhs) then\n          return true\n        if rhs.isFVar && s.xs.contains rhs.fvarId! then\n          substRHS eq rhs.fvarId!\n          return true\n      if let some (\u03b1, lhs, \u03b2, rhs) \u2190 matchHEq? eqType then\n        if (\u2190 isDefEq \u03b1 \u03b2) then\n          let (eqNew, mvarId) \u2190 heqToEq s.mvarId eq (tryToClear := true)\n          modify fun s => { s with mvarId, eqs := eqNew :: s.eqs }\n          return true\n        else\n          match lhs.isConstructorApp? (\u2190 getEnv), rhs.isConstructorApp? (\u2190 getEnv) with\n          | some lhsCtor, some rhsCtor =>\n            if lhsCtor.name != rhsCtor.name then\n              return false else if (\u2190 trySubstVarsAndContradiction s.mvarId) then\n              return false\n          | _, _ =>\n            if (\u2190 trySubstVarsAndContradiction s.mvarId) then\n              return false\n      try\n        match (\u2190 injection s.mvarId eq) with\n        | InjectionResult.solved => return false\n        | InjectionResult.subgoal mvarId eqNews .. =>\n          modify fun s => { s with mvarId, eqs := eqNews.toList ++ s.eqs }\n      catch _ =>\n        modify fun s => { s with eqsNew := eq :: s.eqsNew }\n    return true", "start": [198, 1], "end": [239, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.SimpH.go", "code": "partial def go : M Bool := do\n  if (\u2190 isDone) then\n    return true\n  else if (\u2190 processNextEq) then\n    go\n  else\n    return false", "start": [241, 1], "end": [247, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.simpH?", "code": "private partial def simpH? (h : Expr) (numEqs : Nat) : MetaM (Option Expr) := withDefault do\n  let numVars \u2190 forallTelescope h fun ys _ => pure (ys.size - numEqs)\n  let mvarId := (\u2190 mkFreshExprSyntheticOpaqueMVar h).mvarId!\n  let (xs, mvarId) \u2190 mvarId.introN numVars\n  let (eqs, mvarId) \u2190 mvarId.introN numEqs\n  let (r, s) \u2190 SimpH.go |>.run { mvarId, xs := xs.toList, eqs := eqs.toList }\n  if r then\n    s.mvarId.withContext do\n      let eqs := s.eqsNew.reverse.toArray.map mkFVar\n      let mut r \u2190 mkForallFVars eqs (mkConst ``False)\n      \n      for x in s.xs.reverse do\n        if (\u2190 dependsOn r x) then\n          r \u2190 mkForallFVars #[mkFVar x] r\n      trace[Meta.Match.matchEqs] \"simplified hypothesis{indentExpr r}\"\n      check r\n      return some r\n  else\n    return none", "start": [251, 1], "end": [275, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.substSomeVar", "code": "private def substSomeVar (mvarId : MVarId) : MetaM (Array MVarId) := mvarId.withContext do\n  for localDecl in (\u2190 getLCtx) do\n    if let some (_, lhs, rhs) \u2190 matchEq? localDecl.type then\n      if lhs.isFVar then\n        if !(\u2190 dependsOn rhs lhs.fvarId!) then\n          match (\u2190 subst? mvarId lhs.fvarId!) with\n          | some mvarId => return #[mvarId]\n          | none => pure ()\n  throwError \"substSomeVar failed\"", "start": [277, 1], "end": [285, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.proveCondEqThm", "code": "partial def proveCondEqThm (matchDeclName : Name) (type : Expr) : MetaM Expr := withLCtx {} {} do\n  let type \u2190 instantiateMVars type\n  forallTelescope type fun ys target => do\n    let mvar0  \u2190 mkFreshExprSyntheticOpaqueMVar target\n    trace[Meta.Match.matchEqs] \"proveCondEqThm {mvar0.mvarId!}\"\n    let mvarId \u2190 mvar0.mvarId!.deltaTarget (\u00b7 == matchDeclName)\n    withDefault <| go mvarId 0\n    mkLambdaFVars ys (\u2190 instantiateMVars mvar0)\nwhere\n  go (mvarId : MVarId) (depth : Nat) : MetaM Unit := withIncRecDepth do\n    trace[Meta.Match.matchEqs] \"proveCondEqThm.go {mvarId}\"\n    let mvarId' \u2190 mvarId.modifyTargetEqLHS whnfCore\n    let mvarId := mvarId'\n    let subgoals \u2190\n      (do mvarId.refl; return #[])\n      <|>\n      (do mvarId.contradiction { genDiseq := true }; return #[])\n      <|>\n      (casesOnStuckLHS mvarId)\n      <|>\n      (do let mvarId' \u2190 simpIfTarget mvarId (useDecide := true)\n          if mvarId' == mvarId then throwError \"simpIf failed\"\n          return #[mvarId'])\n      <|>\n      (do if let some (s\u2081, s\u2082) \u2190 splitIfTarget? mvarId then\n            let mvarId\u2081 \u2190 trySubst s\u2081.mvarId s\u2081.fvarId\n            return #[mvarId\u2081, s\u2082.mvarId]\n          else\n            throwError \"spliIf failed\")\n      <|>\n      (substSomeVar mvarId)\n      <|>\n      (throwError \"failed to generate equality theorems for `match` expression `{matchDeclName}`\\n{MessageData.ofGoal mvarId}\")\n    subgoals.forM (go \u00b7 (depth+1))", "start": [287, 1], "end": [323, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.withSplitterAlts", "code": "private partial def withSplitterAlts (altTypes : Array Expr) (f : Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  let rec go (i : Nat) (xs : Array Expr) : MetaM \u03b1 := do\n    if h : i < altTypes.size then\n      let hName := (`h).appendIndexAfter (i+1)\n      withLocalDeclD hName (altTypes.get \u27e8i, h\u27e9) fun x =>\n        go (i+1) (xs.push x)\n    else\n      f xs\n  go 0 #[]", "start": [326, 1], "end": [335, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.InjectionAnyResult", "code": "inductive InjectionAnyResult where\n  | solved\n  | failed\n  | subgoal (mvarId : MVarId)", "start": [337, 1], "end": [340, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.injectionAnyCandidate?", "code": "private def injectionAnyCandidate? (type : Expr) : MetaM (Option (Expr \u00d7 Expr)) := do\n  if let some (_, lhs, rhs) \u2190 matchEq? type then\n    return some (lhs, rhs)\n  else if let some (\u03b1, lhs, \u03b2, rhs) \u2190 matchHEq? type then\n    if (\u2190 isDefEq \u03b1 \u03b2) then\n      return some (lhs, rhs)\n  return none", "start": [342, 1], "end": [348, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.injectionAny", "code": "private def injectionAny (mvarId : MVarId) : MetaM InjectionAnyResult :=\n  mvarId.withContext do\n    for localDecl in (\u2190 getLCtx) do\n      if let some (lhs, rhs) \u2190 injectionAnyCandidate? localDecl.type then\n        unless (\u2190 isDefEq lhs rhs) do\n          let lhs \u2190 whnf lhs\n          let rhs \u2190 whnf rhs\n          unless lhs.isNatLit && rhs.isNatLit do\n            try\n              match (\u2190 injection mvarId localDecl.fvarId) with\n              | InjectionResult.solved  => return InjectionAnyResult.solved\n              | InjectionResult.subgoal mvarId .. => return InjectionAnyResult.subgoal mvarId\n            catch ex =>\n              trace[Meta.Match.matchEqs] \"injectionAnyFailed at {localDecl.userName}, error\\n{ex.toMessageData}\"\n              pure ()\n    return InjectionAnyResult.failed", "start": [350, 1], "end": [365, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.ConvertM", "code": "private abbrev ConvertM := ReaderT (FVarIdMap (Expr \u00d7 Nat \u00d7 Array Bool)) $ StateRefT (Array MVarId) MetaM", "start": [368, 1], "end": [368, 106], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.mkSplitterProof", "code": "private partial def mkSplitterProof (matchDeclName : Name) (template : Expr) (alts altsNew : Array Expr)\n    (altsNewNumParams : Array Nat)\n    (altArgMasks : Array (Array Bool)) : MetaM Expr := do\n  trace[Meta.Match.matchEqs] \"proof template: {template}\"\n  let map := mkMap\n  let (proof, mvarIds) \u2190 convertTemplate template |>.run map |>.run #[]\n  trace[Meta.Match.matchEqs] \"splitter proof: {proof}\"\n  for mvarId in mvarIds do\n    proveSubgoal mvarId\n  instantiateMVars proof\nwhere\n  mkMap : FVarIdMap (Expr \u00d7 Nat \u00d7 Array Bool) := Id.run do\n    let mut m := {}\n    for alt in alts, altNew in altsNew, numParams in altsNewNumParams, argMask in altArgMasks do\n      m := m.insert alt.fvarId! (altNew, numParams, argMask)\n    return m\n\n  trimFalseTrail (argMask : Array Bool) : Array Bool :=\n    if argMask.isEmpty then\n      argMask\n    else if !argMask.back then\n      trimFalseTrail argMask.pop\n    else\n      argMask\n\n  \n  isCastEqRec (e : Expr) : ConvertM Bool := do\n    unless e.isAppOf ``Eq.ndrec do return false\n    unless e.getAppNumArgs > 6 do return false\n    for arg in e.getAppArgs[6:] do\n      if arg.isFVar && (\u2190 read).contains arg.fvarId! then\n        return true\n    return true\n\n  \n  convertCastEqRec (e : Expr) : ConvertM Expr := do\n    assert! (\u2190 isCastEqRec e)\n    e.withApp fun f args => do\n      let mut argsNew := args\n      let mut isAlt := #[]\n      for i in [6:args.size] do\n        let arg := argsNew[i]!\n        if arg.isFVar then\n          match (\u2190 read).find? arg.fvarId! with\n          | some (altNew, _, _) =>\n            argsNew := argsNew.set! i altNew\n            trace[Meta.Match.matchEqs] \"arg: {arg} : {\u2190 inferType arg}, altNew: {altNew} : {\u2190 inferType altNew}\"\n            isAlt := isAlt.push true\n          | none =>\n            argsNew := argsNew.set! i (\u2190 convertTemplate arg)\n            isAlt := isAlt.push false\n        else\n          argsNew := argsNew.set! i (\u2190 convertTemplate arg)\n          isAlt := isAlt.push false\n      assert! isAlt.size == args.size - 6\n      let rhs := args[4]!\n      let motive := args[2]!\n      let motiveNew \u2190 lambdaTelescope motive fun motiveArgs body => do\n        unless motiveArgs.size == 1 do\n          throwError \"unexpected `Eq.ndrec` motive while creating splitter/eliminator theorem for `{matchDeclName}`, expected lambda with 1 binder{indentExpr motive}\"\n        let x := motiveArgs[0]!\n        forallTelescopeReducing body fun motiveTypeArgs resultType => do\n          unless motiveTypeArgs.size >= isAlt.size do\n            throwError \"unexpected `Eq.ndrec` motive while creating splitter/eliminator theorem for `{matchDeclName}`, expected arrow with at least #{isAlt.size} binders{indentExpr body}\"\n          let rec go (i : Nat) (motiveTypeArgsNew : Array Expr) : ConvertM Expr := do\n            assert! motiveTypeArgsNew.size == i\n            if h : i < motiveTypeArgs.size then\n              let motiveTypeArg := motiveTypeArgs.get \u27e8i, h\u27e9\n              if i < isAlt.size && isAlt[i]! then\n                let altNew := argsNew[6+i]! let altTypeNew \u2190 inferType altNew\n                trace[Meta.Match.matchEqs] \"altNew: {altNew} : {altTypeNew}\"\n                let mut altTypeNewAbst := (\u2190 kabstract altTypeNew rhs).instantiate1 x\n                for j in [:i] do\n                  altTypeNewAbst := (\u2190 kabstract altTypeNewAbst argsNew[6+j]!).instantiate1 motiveTypeArgsNew[j]!\n                let localDecl \u2190 motiveTypeArg.fvarId!.getDecl\n                withLocalDecl localDecl.userName localDecl.binderInfo altTypeNewAbst fun motiveTypeArgNew =>\n                  go (i+1) (motiveTypeArgsNew.push motiveTypeArgNew)\n              else\n                go (i+1) (motiveTypeArgsNew.push motiveTypeArg)\n            else\n              mkLambdaFVars motiveArgs (\u2190 mkForallFVars motiveTypeArgsNew resultType)\n          go 0 #[]\n      trace[Meta.Match.matchEqs] \"new motive: {motiveNew}\"\n      unless (\u2190 isTypeCorrect motiveNew) do\n        throwError \"failed to construct new type correct motive for `Eq.ndrec` while creating splitter/eliminator theorem for `{matchDeclName}`{indentExpr motiveNew}\"\n      argsNew := argsNew.set! 2 motiveNew\n      let eqRecNewPrefix := mkAppN f argsNew[:3] let .forallE _ minorTypeNew .. \u2190 whnf (\u2190 inferType eqRecNewPrefix) | unreachable!\n      trace[Meta.Match.matchEqs] \"new minor type: {minorTypeNew}\"\n      let minor := args[3]!\n      let minorNew \u2190 forallBoundedTelescope minorTypeNew isAlt.size fun minorArgsNew _ => do\n        let mut minorBodyNew := minor\n        let mut m \u2190 read\n        for i in [:isAlt.size] do\n          if isAlt[i]! then\n            let alt := args[6+i]! let some (_, numParams, argMask) := m.find? alt.fvarId! | unreachable!\n            m := m.insert minorArgsNew[i]!.fvarId! (minorArgsNew[i]!, numParams, argMask)\n          unless minorBodyNew.isLambda do\n            throwError \"unexpected `Eq.ndrec` minor premise while creating splitter/eliminator theorem for `{matchDeclName}`, expected lambda with at least #{isAlt.size} binders{indentExpr minor}\"\n          minorBodyNew := minorBodyNew.bindingBody!\n        minorBodyNew := minorBodyNew.instantiateRev minorArgsNew\n        trace[Meta.Match.matchEqs] \"minor premise new body before convertTemplate:{indentExpr minorBodyNew}\"\n        minorBodyNew \u2190 withReader (fun _ => m) <| convertTemplate minorBodyNew\n        trace[Meta.Match.matchEqs] \"minor premise new body after convertTemplate:{indentExpr minorBodyNew}\"\n        mkLambdaFVars minorArgsNew minorBodyNew\n      unless (\u2190 isTypeCorrect minorNew) do\n        throwError \"failed to construct new type correct minor premise for `Eq.ndrec` while creating splitter/eliminator theorem for `{matchDeclName}`{indentExpr minorNew}\"\n      argsNew := argsNew.set! 3 minorNew\n      trace[Meta.Match.matchEqs] \"found cast target {e}\"\n      return mkAppN f argsNew\n\n  convertTemplate (e : Expr) : ConvertM Expr :=\n    transform e fun e => do\n      if (\u2190 isCastEqRec e) then\n        return .done (\u2190 convertCastEqRec e)\n      else\n        let Expr.fvar fvarId .. := e.getAppFn | return .continue\n        let some (altNew, numParams, argMask) := (\u2190 read).find? fvarId | return .continue\n        trace[Meta.Match.matchEqs] \">> argMask: {argMask}, e: {e}, {altNew}\"\n        let mut newArgs := #[]\n        let argMask := trimFalseTrail argMask\n        unless e.getAppNumArgs \u2265 argMask.size do\n          throwError \"unexpected occurrence of `match`-expression alternative (aka minor premise) while creating splitter/eliminator theorem for `{matchDeclName}`, minor premise is partially applied{indentExpr e}\\npossible solution if you are matching on inductive families: add its indices as additional discriminants\"\n        for arg in e.getAppArgs, includeArg in argMask do\n          if includeArg then\n            newArgs := newArgs.push arg\n        let eNew := mkAppN altNew newArgs\n        \n        let (mvars, _, _) \u2190 forallMetaBoundedTelescope (\u2190 inferType eNew) (numParams - newArgs.size) (kind := MetavarKind.syntheticOpaque)\n        modify fun s => s ++ (mvars.map (\u00b7.mvarId!))\n        let eNew := mkAppN eNew mvars\n        return TransformStep.done eNew\n\n  proveSubgoalLoop (mvarId : MVarId) : MetaM Unit := do\n    trace[Meta.Match.matchEqs] \"proveSubgoalLoop\\n{mvarId}\"\n    match (\u2190 injectionAny mvarId) with\n    | InjectionAnyResult.solved => return ()\n    | InjectionAnyResult.failed =>\n      let mvarId' \u2190 substVars mvarId\n      if mvarId' == mvarId then\n        if (\u2190 mvarId.contradictionCore {}) then\n          return ()\n        throwError \"failed to generate splitter for match auxiliary declaration '{matchDeclName}', unsolved subgoal:\\n{MessageData.ofGoal mvarId}\"\n      else\n        proveSubgoalLoop mvarId'\n    | InjectionAnyResult.subgoal mvarId => proveSubgoalLoop mvarId\n\n  proveSubgoal (mvarId : MVarId) : MetaM Unit := do\n    trace[Meta.Match.matchEqs] \"subgoal {mkMVar mvarId}, {repr (\u2190 mvarId.getDecl).kind}, {\u2190 mvarId.isAssigned}\\n{MessageData.ofGoal mvarId}\"\n    let (_, mvarId) \u2190 mvarId.intros\n    let mvarId \u2190 mvarId.tryClearMany (alts.map (\u00b7.fvarId!))\n    proveSubgoalLoop mvarId", "start": [370, 1], "end": [584, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.withNewAlts", "code": "private partial def withNewAlts (numDiscrEqs : Nat) (discrs : Array Expr) (patterns : Array Expr) (alts : Array Expr) (k : Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  if numDiscrEqs == 0 then\n    k alts\n  else\n    go 0 #[]\nwhere\n  go (i : Nat) (altsNew : Array Expr) : MetaM \u03b1 := do\n   if h : i < alts.size then\n     let alt := alts.get \u27e8i, h\u27e9\n     let altLocalDecl \u2190 getFVarLocalDecl alt\n     let typeNew := altLocalDecl.type.replaceFVars discrs patterns\n     withLocalDecl altLocalDecl.userName altLocalDecl.binderInfo typeNew fun altNew =>\n       go (i+1) (altsNew.push altNew)\n   else\n     k altsNew", "start": [586, 1], "end": [605, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.mkEquationsFor", "code": "private partial def mkEquationsFor (matchDeclName : Name) :  MetaM MatchEqns := withLCtx {} {} do\n  trace[Meta.Match.matchEqs] \"mkEquationsFor '{matchDeclName}'\"\n  withConfig (fun c => { c with etaStruct := .none }) do\n  let baseName := mkPrivateName (\u2190 getEnv) matchDeclName\n  let constInfo \u2190 getConstInfo matchDeclName\n  let us := constInfo.levelParams.map mkLevelParam\n  let some matchInfo \u2190 getMatcherInfo? matchDeclName | throwError \"'{matchDeclName}' is not a matcher function\"\n  let numDiscrEqs := getNumEqsFromDiscrInfos matchInfo.discrInfos\n  forallTelescopeReducing constInfo.type fun xs matchResultType => do\n    let mut eqnNames := #[]\n    let params := xs[:matchInfo.numParams]\n    let motive := xs[matchInfo.getMotivePos]!\n    let alts   := xs[xs.size - matchInfo.numAlts:]\n    let firstDiscrIdx := matchInfo.numParams + 1\n    let discrs := xs[firstDiscrIdx : firstDiscrIdx + matchInfo.numDiscrs]\n    let mut notAlts := #[]\n    let mut idx := 1\n    let mut splitterAltTypes := #[]\n    let mut splitterAltNumParams := #[]\n    let mut altArgMasks := #[] for i in [:alts.size] do\n      let altNumParams := matchInfo.altNumParams[i]!\n      let altNonEqNumParams := altNumParams - numDiscrEqs\n      let thmName := baseName ++ ((`eq).appendIndexAfter idx)\n      eqnNames := eqnNames.push thmName\n      let (notAlt, splitterAltType, splitterAltNumParam, argMask) \u2190 forallAltTelescope (\u2190 inferType alts[i]!) altNonEqNumParams fun ys eqs rhsArgs argMask altResultType => do\n        let patterns := altResultType.getAppArgs\n        let mut hs := #[]\n        for notAlt in notAlts do\n          let h \u2190 instantiateForall notAlt patterns\n          if let some h \u2190 simpH? h patterns.size then\n            hs := hs.push h\n        trace[Meta.Match.matchEqs] \"hs: {hs}\"\n        let splitterAltType \u2190 mkForallFVars ys (\u2190 hs.foldrM (init := (\u2190 mkForallFVars eqs altResultType)) (mkArrow \u00b7 \u00b7))\n        let splitterAltNumParam := hs.size + ys.size\n        let mut notAlt := mkConst ``False\n        for discr in discrs.toArray.reverse, pattern in patterns.reverse do\n          notAlt \u2190 mkArrow (\u2190 mkEqHEq discr pattern) notAlt\n        notAlt \u2190 mkForallFVars (discrs ++ ys) notAlt\n        \n        withNewAlts numDiscrEqs discrs patterns alts fun alts => do\n          let alt := alts[i]!\n          let lhs := mkAppN (mkConst constInfo.name us) (params ++ #[motive] ++ patterns ++ alts)\n          let rhs := mkAppN alt rhsArgs\n          let thmType \u2190 mkEq lhs rhs\n          let thmType \u2190 hs.foldrM (init := thmType) (mkArrow \u00b7 \u00b7)\n          let thmType \u2190 mkForallFVars (params ++ #[motive] ++ ys ++ alts) thmType\n          let thmType \u2190 unfoldNamedPattern thmType\n          let thmVal \u2190 proveCondEqThm matchDeclName thmType\n          addDecl <| Declaration.thmDecl {\n            name        := thmName\n            levelParams := constInfo.levelParams\n            type        := thmType\n            value       := thmVal\n          }\n          return (notAlt, splitterAltType, splitterAltNumParam, argMask)\n      notAlts := notAlts.push notAlt\n      splitterAltTypes := splitterAltTypes.push splitterAltType\n      splitterAltNumParams := splitterAltNumParams.push splitterAltNumParam\n      altArgMasks := altArgMasks.push argMask\n      trace[Meta.Match.matchEqs] \"splitterAltType: {splitterAltType}\"\n      idx := idx + 1\n    withSplitterAlts splitterAltTypes fun altsNew => do\n      let splitterParams := params.toArray ++ #[motive] ++ discrs.toArray ++ altsNew\n      let splitterType \u2190 mkForallFVars splitterParams matchResultType\n      trace[Meta.Match.matchEqs] \"splitterType: {splitterType}\"\n      let template := mkAppN (mkConst constInfo.name us) (params ++ #[motive] ++ discrs ++ alts)\n      let template \u2190 deltaExpand template (\u00b7 == constInfo.name)\n      let template := template.headBeta\n      let splitterVal \u2190 mkLambdaFVars splitterParams (\u2190 mkSplitterProof matchDeclName template alts altsNew splitterAltNumParams altArgMasks)\n      let splitterName := baseName ++ `splitter\n      addAndCompile <| Declaration.defnDecl {\n        name        := splitterName\n        levelParams := constInfo.levelParams\n        type        := splitterType\n        value       := splitterVal\n        hints       := .abbrev\n        safety      := .safe\n      }\n      setInlineAttribute splitterName\n      let result := { eqnNames, splitterName, splitterAltNumParams }\n      registerMatchEqns matchDeclName result\n      return result", "start": [607, 1], "end": [694, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.Match.getEquationsForImpl", "code": "@[export lean_get_match_equations_for]\ndef getEquationsForImpl (matchDeclName : Name) : MetaM MatchEqns := do\n  match matchEqnsExt.getState (\u2190 getEnv) |>.map.find? matchDeclName with\n  | some matchEqns => return matchEqns\n  | none => mkEquationsFor matchDeclName", "start": [697, 1], "end": [701, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/UnificationHint.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/Recognizers.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Lean/Meta/SynthInstance.lean", "lake-packages/lean4/src/lean/Lean/ScopedEnvExtension.lean"], "premises": [{"full_name": "Lean.Meta.UnificationHintKey", "code": "abbrev UnificationHintKey := DiscrTree.Key (simpleReduce := true)", "start": [13, 1], "end": [13, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.UnificationHintEntry", "code": "structure UnificationHintEntry where\n  keys        : Array UnificationHintKey\n  val         : Name\n  deriving Inhabited", "start": [15, 1], "end": [18, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.UnificationHintTree", "code": "abbrev UnificationHintTree := DiscrTree Name (simpleReduce := true)", "start": [20, 1], "end": [20, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.UnificationHints", "code": "structure UnificationHints where\n  discrTree : UnificationHintTree := DiscrTree.empty\n  deriving Inhabited", "start": [22, 1], "end": [24, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.UnificationHints.add", "code": "def UnificationHints.add (hints : UnificationHints) (e : UnificationHintEntry) : UnificationHints :=\n  { hints with discrTree := hints.discrTree.insertCore e.keys e.val }", "start": [29, 1], "end": [30, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.UnificationConstraint", "code": "structure UnificationConstraint where\n  lhs : Expr\n  rhs : Expr", "start": [38, 1], "end": [40, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.UnificationHint", "code": "structure UnificationHint where\n  pattern     : UnificationConstraint\n  constraints : List UnificationConstraint", "start": [42, 1], "end": [44, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.decodeUnificationHint", "code": "private partial def decodeUnificationHint (e : Expr) : ExceptT MessageData Id UnificationHint := do\n  decode e #[]\nwhere\n  decodeConstraint (e : Expr) : ExceptT MessageData Id UnificationConstraint :=\n    match e.eq? with\n    | some (_, lhs, rhs) => return UnificationConstraint.mk lhs rhs\n    | none => throw m!\"invalid unification hint constraint, unexpected term{indentExpr e}\"\n  decode (e : Expr) (cs : Array UnificationConstraint) : ExceptT MessageData Id UnificationHint := do\n    match e with\n    | Expr.forallE _ d b _ => do\n      let c \u2190 decodeConstraint d\n      if b.hasLooseBVars then\n        throw m!\"invalid unification hint constraint, unexpected dependency{indentExpr e}\"\n      decode b (cs.push c)\n    | _ => do\n      let p \u2190 decodeConstraint e\n      return { pattern := p, constraints := cs.toList }", "start": [46, 1], "end": [62, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.validateHint", "code": "private partial def validateHint (hint : UnificationHint) : MetaM Unit := do\n  hint.constraints.forM fun c => do\n    unless (\u2190 isDefEq c.lhs c.rhs) do\n      throwError \"invalid unification hint, failed to unify constraint left-hand-side{indentExpr c.lhs}\\nwith right-hand-side{indentExpr c.rhs}\"\n  unless (\u2190 isDefEq hint.pattern.lhs hint.pattern.rhs) do\n    throwError \"invalid unification hint, failed to unify pattern left-hand-side{indentExpr hint.pattern.lhs}\\nwith right-hand-side{indentExpr hint.pattern.rhs}\"", "start": [64, 1], "end": [69, 162], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.addUnificationHint", "code": "def addUnificationHint (declName : Name) (kind : AttributeKind) : MetaM Unit :=\n  withNewMCtxDepth do\n    let info \u2190 getConstInfo declName\n    match info.value? with\n    | none => throwError \"invalid unification hint, it must be a definition\"\n    | some val =>\n      let (_, _, body) \u2190 lambdaMetaTelescope val\n      match decodeUnificationHint body with\n      | Except.error msg => throwError msg\n      | Except.ok hint =>\n        let keys \u2190 DiscrTree.mkPath hint.pattern.lhs\n        validateHint hint\n        unificationHintExtension.add { keys := keys, val := declName } kind", "start": [71, 1], "end": [83, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.tryUnificationHints", "code": "def tryUnificationHints (t s : Expr) : MetaM Bool := do\n  trace[Meta.isDefEq.hint] \"{t} =?= {s}\"\n  unless (\u2190 read).config.unificationHints do\n    return false\n  if t.isMVar then\n    return false\n  let hints := unificationHintExtension.getState (\u2190 getEnv)\n  let candidates \u2190 hints.discrTree.getMatch t\n  for candidate in candidates do\n    if (\u2190 tryCandidate candidate) then\n      return true\n  return false\nwhere\n  isDefEqPattern p e :=\n    withReducible <| Meta.isExprDefEqAux p e\n\n  tryCandidate candidate : MetaM Bool :=\n    withTraceNode `Meta.isDefEq.hint\n      (return m!\"{exceptBoolEmoji \u00b7} hint {candidate} at {t} =?= {s}\") do\n    checkpointDefEq do\n      let cinfo \u2190 getConstInfo candidate\n      let us \u2190 cinfo.levelParams.mapM fun _ => mkFreshLevelMVar\n      let val \u2190 instantiateValueLevelParams cinfo us\n      let (xs, bis, body) \u2190 lambdaMetaTelescope val\n      let hint? \u2190 withConfig (fun cfg => { cfg with unificationHints := false }) do\n        match decodeUnificationHint body with\n        | Except.error _ => return none\n        | Except.ok hint =>\n          if (\u2190 isDefEqPattern hint.pattern.lhs t <&&> isDefEqPattern hint.pattern.rhs s) then\n            return some hint\n          else\n            return none\n      match hint? with\n      | none      => return false\n      | some hint =>\n        trace[Meta.isDefEq.hint] \"{candidate} succeeded, applying constraints\"\n        for c in hint.constraints do\n          unless (\u2190 Meta.isExprDefEqAux c.lhs c.rhs) do\n            return false\n        for x in xs, bi in bis do\n          if bi == BinderInfo.instImplicit then\n            match (\u2190 trySynthInstance (\u2190 inferType x)) with\n            | LOption.some val => unless (\u2190 isDefEq x val) do return false\n            | _                => return false\n        return true", "start": [94, 1], "end": [138, 20], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/BorrowedAnnotation.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.markBorrowed", "code": "def markBorrowed (e : Expr) : Expr :=\n  mkAnnotation `borrowed e", "start": [9, 1], "end": [10, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.isMarkedBorrowed", "code": "@[export lean_is_marked_borrowed]\ndef isMarkedBorrowed (e : Expr) : Bool :=\n  annotation? `borrowed e |>.isSome", "start": [12, 1], "end": [14, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/LCtx.lean", "imports": ["lake-packages/lean4/src/lean/Lean/LocalContext.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.LCtx", "code": "structure LCtx where\n  params   : HashMap FVarId Param := {}\n  letDecls : HashMap FVarId LetDecl := {}\n  funDecls : HashMap FVarId FunDecl := {}\n  deriving Inhabited", "start": [11, 1], "end": [18, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.addParam", "code": "def LCtx.addParam (lctx : LCtx) (param : Param) : LCtx :=\n  { lctx with params := lctx.params.insert param.fvarId param }", "start": [20, 1], "end": [21, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.addLetDecl", "code": "def LCtx.addLetDecl (lctx : LCtx) (letDecl : LetDecl) : LCtx :=\n  { lctx with letDecls := lctx.letDecls.insert letDecl.fvarId letDecl }", "start": [23, 1], "end": [24, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.addFunDecl", "code": "def LCtx.addFunDecl (lctx : LCtx) (funDecl : FunDecl) : LCtx :=\n  { lctx with funDecls := lctx.funDecls.insert funDecl.fvarId funDecl }", "start": [26, 1], "end": [27, 72], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.eraseParam", "code": "def LCtx.eraseParam (lctx : LCtx) (param : Param) : LCtx :=\n  { lctx with params := lctx.params.erase param.fvarId }", "start": [29, 1], "end": [30, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.eraseParams", "code": "def LCtx.eraseParams (lctx : LCtx) (ps : Array Param) : LCtx :=\n  { lctx with params := ps.foldl (init := lctx.params) fun params p => params.erase p.fvarId }", "start": [32, 1], "end": [33, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.eraseLetDecl", "code": "def LCtx.eraseLetDecl (lctx : LCtx) (decl : LetDecl) : LCtx :=\n  { lctx with letDecls := lctx.letDecls.erase decl.fvarId }", "start": [35, 1], "end": [36, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.eraseFunDecl", "code": "partial def LCtx.eraseFunDecl (lctx : LCtx) (decl : FunDecl) (recursive := true) : LCtx :=\n    let lctx := { lctx with funDecls := lctx.funDecls.erase decl.fvarId }\n    if recursive then\n      eraseCode decl.value <| eraseParams lctx decl.params\n    else\n      lctx", "start": [39, 3], "end": [44, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.eraseAlts", "code": "partial def LCtx.eraseAlts (alts : Array Alt) (lctx : LCtx) : LCtx :=\n    alts.foldl (init := lctx) fun lctx alt =>\n      match alt with\n      | .default k => eraseCode k lctx\n      | .alt _ ps k => eraseCode k <| eraseParams lctx ps", "start": [46, 3], "end": [50, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.eraseCode", "code": "partial def LCtx.eraseCode (code : Code) (lctx : LCtx) : LCtx :=\n    match code with\n    | .let decl k => eraseCode k <| lctx.eraseLetDecl decl\n    | .jp decl k | .fun decl k => eraseCode k <| eraseFunDecl lctx decl\n    | .cases c => eraseAlts c.alts lctx\n    | _ => lctx", "start": [52, 3], "end": [57, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LCtx.toLocalContext", "code": "def LCtx.toLocalContext (lctx : LCtx) : LocalContext := Id.run do\n  let mut result := {}\n  for (_, param) in lctx.params.toArray do\n    result := result.addDecl (.cdecl 0 param.fvarId param.binderName param.type .default .default)\n  for (_, decl) in lctx.letDecls.toArray do\n    result := result.addDecl (.ldecl 0 decl.fvarId decl.binderName decl.type decl.value.toExpr true .default)\n  for (_, decl) in lctx.funDecls.toArray do\n    result := result.addDecl (.cdecl 0 decl.fvarId decl.binderName decl.type .default .default)\n  return result", "start": [60, 1], "end": [71, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ConfigOptions.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.ConfigOptions", "code": "structure ConfigOptions where\n  \n  smallThreshold : Nat := 1\n  \n  maxRecInline : Nat := 1\n  \n  maxRecInlineIfReduce : Nat := 16\n  \n  checkTypes : Bool := false\n  deriving Inhabited", "start": [10, 1], "end": [33, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.toConfigOptions", "code": "def toConfigOptions (opts : Options) : ConfigOptions := {\n  smallThreshold := compiler.small.get opts\n  maxRecInline   := compiler.maxRecInline.get opts\n  maxRecInlineIfReduce := compiler.maxRecInlineIfReduce.get opts\n  checkTypes := compiler.checkTypes.get opts\n}", "start": [59, 1], "end": [64, 2], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/NoMatch.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Match.lean", "lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/std/Std/Tactic/OpenPrivate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.elabNoMatch'", "code": "@[term_elab noMatch] def elabNoMatch' : TermElab\n| `(match $discrs,* with.), expectedType? => do\n  let discrs := discrs.getElems\n  for h : i in [0:discrs.size] do\n    have h : i < discrs.size := h.2\n    let `(matchDiscr| $[$n :]? $discr:term) := discrs[i] | throwUnsupportedSyntax\n    if \u2190 isAtomicDiscr discr then\n      tryPostponeIfMVar (\u2190 Meta.inferType (\u2190 elabTerm discr none))\n    else\n      let discrs := discrs.set \u27e8i, h\u27e9 (\u2190 `(matchDiscr| $[$n :]? ?x))\n      return \u2190 elabTerm (\u2190 `(let_mvar% ?x := $discr; match $discrs,* with.)) expectedType?\n  let expectedType \u2190 waitExpectedType expectedType?\n  elabMatchAux none discrs #[] mkNullNode expectedType\n| _, _ => throwUnsupportedSyntax", "start": [29, 1], "end": [43, 33], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "imports": ["lake-packages/std/Std/Data/Fin/Init/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.get?_nil", "code": "@[simp] theorem get?_nil : @get? \u03b1 [] n = none", "start": [21, 1], "end": [21, 54], "kind": "commanddeclaration"}, {"full_name": "List.get?_cons_zero", "code": "@[simp] theorem get?_cons_zero : @get? \u03b1 (a::l) 0 = some a", "start": [22, 1], "end": [22, 66], "kind": "commanddeclaration"}, {"full_name": "List.get?_cons_succ", "code": "@[simp] theorem get?_cons_succ : @get? \u03b1 (a::l) (n+1) = get? l n", "start": [23, 1], "end": [23, 72], "kind": "commanddeclaration"}, {"full_name": "List.get_cons_zero", "code": "@[simp] theorem get_cons_zero : get (a::l) (0 : Fin (l.length + 1)) = a", "start": [24, 1], "end": [24, 79], "kind": "commanddeclaration"}, {"full_name": "List.head?_nil", "code": "@[simp] theorem head?_nil : @head? \u03b1 [] = none", "start": [25, 1], "end": [25, 54], "kind": "commanddeclaration"}, {"full_name": "List.head?_cons", "code": "@[simp] theorem head?_cons : @head? \u03b1 (a::l) = some a", "start": [26, 1], "end": [26, 61], "kind": "commanddeclaration"}, {"full_name": "List.headD_nil", "code": "@[simp 1100] theorem headD_nil : @headD \u03b1 [] d = d", "start": [27, 1], "end": [27, 58], "kind": "commanddeclaration"}, {"full_name": "List.headD_cons", "code": "@[simp 1100] theorem headD_cons : @headD \u03b1 (a::l) d = a", "start": [28, 1], "end": [28, 63], "kind": "commanddeclaration"}, {"full_name": "List.head_cons", "code": "@[simp] theorem head_cons : @head \u03b1 (a::l) h = a", "start": [29, 1], "end": [29, 56], "kind": "commanddeclaration"}, {"full_name": "List.tail?_nil", "code": "@[simp] theorem tail?_nil : @tail? \u03b1 [] = none", "start": [30, 1], "end": [30, 54], "kind": "commanddeclaration"}, {"full_name": "List.tail?_cons", "code": "@[simp] theorem tail?_cons : @tail? \u03b1 (a::l) = some l", "start": [31, 1], "end": [31, 61], "kind": "commanddeclaration"}, {"full_name": "List.tail!_cons", "code": "@[simp] theorem tail!_cons : @tail! \u03b1 (a::l) = l", "start": [32, 1], "end": [32, 56], "kind": "commanddeclaration"}, {"full_name": "List.tailD_nil", "code": "@[simp 1100] theorem tailD_nil : @tailD \u03b1 [] l' = l'", "start": [33, 1], "end": [33, 60], "kind": "commanddeclaration"}, {"full_name": "List.tailD_cons", "code": "@[simp 1100] theorem tailD_cons : @tailD \u03b1 (a::l) l' = l", "start": [34, 1], "end": [34, 64], "kind": "commanddeclaration"}, {"full_name": "List.any_nil", "code": "@[simp] theorem any_nil : [].any f = false", "start": [35, 1], "end": [35, 50], "kind": "commanddeclaration"}, {"full_name": "List.any_cons", "code": "@[simp] theorem any_cons : (a::l).any f = (f a || l.any f)", "start": [36, 1], "end": [36, 66], "kind": "commanddeclaration"}, {"full_name": "List.all_nil", "code": "@[simp] theorem all_nil : [].all f = true", "start": [37, 1], "end": [37, 49], "kind": "commanddeclaration"}, {"full_name": "List.all_cons", "code": "@[simp] theorem all_cons : (a::l).all f = (f a && l.all f)", "start": [38, 1], "end": [38, 66], "kind": "commanddeclaration"}, {"full_name": "List.or_nil", "code": "@[simp] theorem or_nil : [].or = false", "start": [39, 1], "end": [39, 46], "kind": "commanddeclaration"}, {"full_name": "List.or_cons", "code": "@[simp] theorem or_cons : (a::l).or = (a || l.or)", "start": [40, 1], "end": [40, 57], "kind": "commanddeclaration"}, {"full_name": "List.and_nil", "code": "@[simp] theorem and_nil : [].and = true", "start": [41, 1], "end": [41, 47], "kind": "commanddeclaration"}, {"full_name": "List.and_cons", "code": "@[simp] theorem and_cons : (a::l).and = (a && l.and)", "start": [42, 1], "end": [42, 60], "kind": "commanddeclaration"}, {"full_name": "List.eq_nil_of_length_eq_zero", "code": "theorem eq_nil_of_length_eq_zero (_ : length l = 0) : l = []", "start": [46, 1], "end": [46, 89], "kind": "commanddeclaration"}, {"full_name": "List.ne_nil_of_length_eq_succ", "code": "theorem ne_nil_of_length_eq_succ (_ : length l = succ n) : l \u2260 []", "start": [48, 1], "end": [48, 88], "kind": "commanddeclaration"}, {"full_name": "List.length_eq_zero", "code": "theorem length_eq_zero : length l = 0 \u2194 l = []", "start": [50, 1], "end": [51, 47], "kind": "commanddeclaration"}, {"full_name": "List.singleton_append", "code": "@[simp 1100] theorem singleton_append : [x] ++ l = x :: l", "start": [55, 1], "end": [55, 65], "kind": "commanddeclaration"}, {"full_name": "List.append_inj", "code": "theorem append_inj :\n    \u2200 {s\u2081 s\u2082 t\u2081 t\u2082 : List \u03b1}, s\u2081 ++ t\u2081 = s\u2082 ++ t\u2082 \u2192 length s\u2081 = length s\u2082 \u2192 s\u2081 = s\u2082 \u2227 t\u2081 = t\u2082", "start": [57, 1], "end": [61, 71], "kind": "commanddeclaration"}, {"full_name": "List.append_inj_right", "code": "theorem append_inj_right (h : s\u2081 ++ t\u2081 = s\u2082 ++ t\u2082) (hl : length s\u2081 = length s\u2082) : t\u2081 = t\u2082", "start": [63, 1], "end": [64, 26], "kind": "commanddeclaration"}, {"full_name": "List.append_inj_left", "code": "theorem append_inj_left (h : s\u2081 ++ t\u2081 = s\u2082 ++ t\u2082) (hl : length s\u2081 = length s\u2082) : s\u2081 = s\u2082", "start": [66, 1], "end": [67, 25], "kind": "commanddeclaration"}, {"full_name": "List.append_inj'", "code": "theorem append_inj' (h : s\u2081 ++ t\u2081 = s\u2082 ++ t\u2082) (hl : length t\u2081 = length t\u2082) : s\u2081 = s\u2082 \u2227 t\u2081 = t\u2082", "start": [69, 1], "end": [71, 82], "kind": "commanddeclaration"}, {"full_name": "List.append_inj_right'", "code": "theorem append_inj_right' (h : s\u2081 ++ t\u2081 = s\u2082 ++ t\u2082) (hl : length t\u2081 = length t\u2082) : t\u2081 = t\u2082", "start": [73, 1], "end": [74, 27], "kind": "commanddeclaration"}, {"full_name": "List.append_inj_left'", "code": "theorem append_inj_left' (h : s\u2081 ++ t\u2081 = s\u2082 ++ t\u2082) (hl : length t\u2081 = length t\u2082) : s\u2081 = s\u2082", "start": [76, 1], "end": [77, 26], "kind": "commanddeclaration"}, {"full_name": "List.append_right_inj", "code": "theorem append_right_inj {t\u2081 t\u2082 : List \u03b1} (s) : s ++ t\u2081 = s ++ t\u2082 \u2194 t\u2081 = t\u2082", "start": [79, 1], "end": [80, 48], "kind": "commanddeclaration"}, {"full_name": "List.append_left_inj", "code": "theorem append_left_inj {s\u2081 s\u2082 : List \u03b1} (t) : s\u2081 ++ t = s\u2082 ++ t \u2194 s\u2081 = s\u2082", "start": [82, 1], "end": [83, 55], "kind": "commanddeclaration"}, {"full_name": "List.map_nil", "code": "@[simp] theorem map_nil {f : \u03b1 \u2192 \u03b2} : map f [] = []", "start": [87, 1], "end": [87, 59], "kind": "commanddeclaration"}, {"full_name": "List.map_cons", "code": "@[simp] theorem map_cons (f : \u03b1 \u2192 \u03b2) a l : map f (a :: l) = f a :: map f l", "start": [89, 1], "end": [89, 82], "kind": "commanddeclaration"}, {"full_name": "List.map_append", "code": "@[simp] theorem map_append (f : \u03b1 \u2192 \u03b2) : \u2200 l\u2081 l\u2082, map f (l\u2081 ++ l\u2082) = map f l\u2081 ++ map f l\u2082", "start": [91, 1], "end": [92, 49], "kind": "commanddeclaration"}, {"full_name": "List.map_id", "code": "@[simp] theorem map_id (l : List \u03b1) : map id l = l", "start": [94, 1], "end": [94, 82], "kind": "commanddeclaration"}, {"full_name": "List.map_map", "code": "@[simp] theorem map_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) :\n  map g (map f l) = map (g \u2218 f) l", "start": [96, 1], "end": [97, 65], "kind": "commanddeclaration"}, {"full_name": "List.nil_bind", "code": "@[simp] theorem nil_bind (f : \u03b1 \u2192 List \u03b2) : List.bind [] f = []", "start": [101, 1], "end": [101, 93], "kind": "commanddeclaration"}, {"full_name": "List.cons_bind", "code": "@[simp] theorem cons_bind x xs (f : \u03b1 \u2192 List \u03b2) :\n  List.bind (x :: xs) f = f x ++ List.bind xs f", "start": [103, 1], "end": [104, 77], "kind": "commanddeclaration"}, {"full_name": "List.append_bind", "code": "@[simp] theorem append_bind xs ys (f : \u03b1 \u2192 List \u03b2) :\n  List.bind (xs ++ ys) f = List.bind xs f ++ List.bind ys f", "start": [106, 1], "end": [108, 58], "kind": "commanddeclaration"}, {"full_name": "List.bind_id", "code": "@[simp] theorem bind_id (l : List (List \u03b1)) : List.bind l id = l.join", "start": [110, 1], "end": [110, 93], "kind": "commanddeclaration"}, {"full_name": "List.join_nil", "code": "@[simp] theorem join_nil : List.join ([] : List (List \u03b1)) = []", "start": [114, 1], "end": [114, 70], "kind": "commanddeclaration"}, {"full_name": "List.join_cons", "code": "@[simp] theorem join_cons : (l :: ls).join = l ++ ls.join", "start": [116, 1], "end": [116, 65], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_cons", "code": "theorem forall_mem_cons {p : \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1} :\n    (\u2200 x, x \u2208 a :: l \u2192 p x) \u2194 p a \u2227 \u2200 x, x \u2208 l \u2192 p x", "start": [120, 1], "end": [123, 65], "kind": "commanddeclaration"}, {"full_name": "List.reverseAux_nil", "code": "@[simp] theorem reverseAux_nil : reverseAux [] r = r", "start": [127, 1], "end": [127, 60], "kind": "commanddeclaration"}, {"full_name": "List.reverseAux_cons", "code": "@[simp] theorem reverseAux_cons : reverseAux (a::l) r = reverseAux l (a::r)", "start": [128, 1], "end": [128, 83], "kind": "commanddeclaration"}, {"full_name": "List.reverseAux_eq", "code": "theorem reverseAux_eq (as bs : List \u03b1) : reverseAux as bs = reverse as ++ bs", "start": [130, 1], "end": [131, 26], "kind": "commanddeclaration"}, {"full_name": "List.reverse_map", "code": "theorem reverse_map (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) : (l.map f).reverse = l.reverse.map f", "start": [133, 1], "end": [134, 27], "kind": "commanddeclaration"}, {"full_name": "List.take_append_drop", "code": "@[simp] theorem take_append_drop : \u2200 (n : Nat) (l : List \u03b1), take n l ++ drop n l = l", "start": [138, 1], "end": [141, 63], "kind": "commanddeclaration"}, {"full_name": "List.length_drop", "code": "@[simp] theorem length_drop : \u2200 (i : Nat) (l : List \u03b1), length (drop i l) = length l - i", "start": [143, 1], "end": [148, 81], "kind": "commanddeclaration"}, {"full_name": "List.drop_length_le", "code": "theorem drop_length_le {l : List \u03b1} (h : l.length \u2264 i) : drop i l = []", "start": [150, 1], "end": [151, 62], "kind": "commanddeclaration"}, {"full_name": "List.take_length_le", "code": "theorem take_length_le {l : List \u03b1} (h : l.length \u2264 i) : take i l = l", "start": [153, 1], "end": [155, 56], "kind": "commanddeclaration"}, {"full_name": "List.take_zero", "code": "@[simp] theorem take_zero (l : List \u03b1) : l.take 0 = []", "start": [157, 1], "end": [157, 62], "kind": "commanddeclaration"}, {"full_name": "List.take_nil", "code": "@[simp] theorem take_nil : ([] : List \u03b1).take i = []", "start": [159, 1], "end": [159, 75], "kind": "commanddeclaration"}, {"full_name": "List.take_cons_succ", "code": "@[simp] theorem take_cons_succ : (a::as).take (i+1) = a :: as.take i", "start": [161, 1], "end": [161, 76], "kind": "commanddeclaration"}, {"full_name": "List.drop_zero", "code": "@[simp] theorem drop_zero (l : List \u03b1) : l.drop 0 = l", "start": [163, 1], "end": [163, 61], "kind": "commanddeclaration"}, {"full_name": "List.drop_succ_cons", "code": "@[simp] theorem drop_succ_cons : (a :: l).drop (n + 1) = l.drop n", "start": [165, 1], "end": [165, 73], "kind": "commanddeclaration"}, {"full_name": "List.drop_length", "code": "@[simp] theorem drop_length (l : List \u03b1) : drop l.length l = []", "start": [167, 1], "end": [167, 98], "kind": "commanddeclaration"}, {"full_name": "List.take_length", "code": "@[simp] theorem take_length (l : List \u03b1) : take l.length l = l", "start": [169, 1], "end": [169, 97], "kind": "commanddeclaration"}, {"full_name": "List.take_concat_get", "code": "theorem take_concat_get (l : List \u03b1) (i : Nat) (h : i < l.length) :\n    (l.take i).concat l[i] = l.take (i+1)", "start": [171, 1], "end": [174, 94], "kind": "commanddeclaration"}, {"full_name": "List.reverse_concat", "code": "theorem reverse_concat (l : List \u03b1) (a : \u03b1) : (l.concat a).reverse = a :: l.reverse", "start": [176, 1], "end": [177, 45], "kind": "commanddeclaration"}, {"full_name": "List.foldlM_reverse", "code": "@[simp] theorem foldlM_reverse [Monad m] (l : List \u03b1) (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (b) :\n    l.reverse.foldlM f b = l.foldrM (fun x y => f y x) b", "start": [181, 1], "end": [182, 64], "kind": "commanddeclaration"}, {"full_name": "List.foldlM_nil", "code": "@[simp] theorem foldlM_nil [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (b) : [].foldlM f b = pure b", "start": [184, 1], "end": [184, 91], "kind": "commanddeclaration"}, {"full_name": "List.foldlM_cons", "code": "@[simp] theorem foldlM_cons [Monad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (b) (a) (l : List \u03b1) :\n    (a :: l).foldlM f b = f b a >>= l.foldlM f", "start": [186, 1], "end": [188, 21], "kind": "commanddeclaration"}, {"full_name": "List.foldlM_append", "code": "@[simp] theorem foldlM_append [Monad m] [LawfulMonad m] (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (b) (l l' : List \u03b1) :\n    (l ++ l').foldlM f b = l.foldlM f b >>= l'.foldlM f", "start": [190, 1], "end": [192, 42], "kind": "commanddeclaration"}, {"full_name": "List.foldrM_nil", "code": "@[simp] theorem foldrM_nil [Monad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (b) : [].foldrM f b = pure b", "start": [194, 1], "end": [194, 91], "kind": "commanddeclaration"}, {"full_name": "List.foldrM_cons", "code": "@[simp] theorem foldrM_cons [Monad m] [LawfulMonad m] (a : \u03b1) (l) (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (b) :\n    (a :: l).foldrM f b = l.foldrM f b >>= f a", "start": [196, 1], "end": [199, 27], "kind": "commanddeclaration"}, {"full_name": "List.foldrM_reverse", "code": "@[simp] theorem foldrM_reverse [Monad m] (l : List \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (b) :\n    l.reverse.foldrM f b = l.foldlM (fun x y => f y x) b", "start": [201, 1], "end": [203, 44], "kind": "commanddeclaration"}, {"full_name": "List.foldl_eq_foldlM", "code": "theorem foldl_eq_foldlM (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b) (l : List \u03b1) :\n    l.foldl f b = l.foldlM (m := Id) f b", "start": [205, 1], "end": [207, 49], "kind": "commanddeclaration"}, {"full_name": "List.foldr_eq_foldrM", "code": "theorem foldr_eq_foldrM (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b) (l : List \u03b1) :\n    l.foldr f b = l.foldrM (m := Id) f b", "start": [209, 1], "end": [211, 34], "kind": "commanddeclaration"}, {"full_name": "List.foldl_reverse", "code": "@[simp] theorem foldl_reverse (l : List \u03b1) (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b) :\n    l.reverse.foldl f b = l.foldr (fun x y => f y x) b", "start": [215, 1], "end": [216, 101], "kind": "commanddeclaration"}, {"full_name": "List.foldr_reverse", "code": "@[simp] theorem foldr_reverse (l : List \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b) :\n    l.reverse.foldr f b = l.foldl (fun x y => f y x) b", "start": [218, 1], "end": [220, 43], "kind": "commanddeclaration"}, {"full_name": "List.foldrM_append", "code": "@[simp] theorem foldrM_append [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (b) (l l' : List \u03b1) :\n    (l ++ l').foldrM f b = l'.foldrM f b >>= l.foldrM f", "start": [222, 1], "end": [224, 27], "kind": "commanddeclaration"}, {"full_name": "List.foldl_append", "code": "@[simp] theorem foldl_append {\u03b2 : Type _} (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b) (l l' : List \u03b1) :\n    (l ++ l').foldl f b = l'.foldl f (l.foldl f b)", "start": [226, 1], "end": [227, 80], "kind": "commanddeclaration"}, {"full_name": "List.foldr_append", "code": "@[simp] theorem foldr_append (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b) (l l' : List \u03b1) :\n    (l ++ l').foldr f b = l.foldr f (l'.foldr f b)", "start": [229, 1], "end": [230, 80], "kind": "commanddeclaration"}, {"full_name": "List.foldl_nil", "code": "@[simp] theorem foldl_nil : [].foldl f b = b", "start": [232, 1], "end": [232, 52], "kind": "commanddeclaration"}, {"full_name": "List.foldl_cons", "code": "@[simp] theorem foldl_cons (l : List \u03b1) (b : \u03b2) : (a :: l).foldl f b = l.foldl f (f b a)", "start": [234, 1], "end": [234, 96], "kind": "commanddeclaration"}, {"full_name": "List.foldr_nil", "code": "@[simp] theorem foldr_nil : [].foldr f b = b", "start": [236, 1], "end": [236, 52], "kind": "commanddeclaration"}, {"full_name": "List.foldr_cons", "code": "@[simp] theorem foldr_cons (l : List \u03b1) : (a :: l).foldr f b = f a (l.foldr f b)", "start": [238, 1], "end": [238, 88], "kind": "commanddeclaration"}, {"full_name": "List.foldr_self_append", "code": "@[simp] theorem foldr_self_append (l : List \u03b1) : l.foldr cons l' = l ++ l'", "start": [240, 1], "end": [241, 27], "kind": "commanddeclaration"}, {"full_name": "List.foldr_self", "code": "theorem foldr_self (l : List \u03b1) : l.foldr cons [] = l", "start": [243, 1], "end": [243, 65], "kind": "commanddeclaration"}, {"full_name": "List.mapM'", "code": "def mapM' [Monad m] (f : \u03b1 \u2192 m \u03b2) : List \u03b1 \u2192 m (List \u03b2)\n  | [] => pure []\n  | a :: l => return (\u2190 f a) :: (\u2190 l.mapM' f)", "start": [247, 1], "end": [250, 46], "kind": "commanddeclaration"}, {"full_name": "List.mapM'_nil", "code": "@[simp] theorem mapM'_nil [Monad m] {f : \u03b1 \u2192 m \u03b2} : mapM' f [] = pure []", "start": [252, 1], "end": [252, 80], "kind": "commanddeclaration"}, {"full_name": "List.mapM'_cons", "code": "@[simp] theorem mapM'_cons [Monad m] {f : \u03b1 \u2192 m \u03b2} :\n    mapM' f (a :: l) = return ((\u2190 f a) :: (\u2190 l.mapM' f))", "start": [253, 1], "end": [255, 6], "kind": "commanddeclaration"}, {"full_name": "List.mapM'_eq_mapM", "code": "theorem mapM'_eq_mapM [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 m \u03b2) (l : List \u03b1) :\n    mapM' f l = mapM f l", "start": [257, 1], "end": [261, 52], "kind": "commanddeclaration"}, {"full_name": "List.mapM_nil", "code": "@[simp] theorem mapM_nil [Monad m] (f : \u03b1 \u2192 m \u03b2) : [].mapM f = pure []", "start": [263, 1], "end": [263, 78], "kind": "commanddeclaration"}, {"full_name": "List.mapM_cons", "code": "@[simp] theorem mapM_cons [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 m \u03b2) :\n    (a :: l).mapM f = (return (\u2190 f a) :: (\u2190 l.mapM f))", "start": [265, 1], "end": [266, 91], "kind": "commanddeclaration"}, {"full_name": "List.mapM_append", "code": "@[simp] theorem mapM_append [Monad m] [LawfulMonad m] (f : \u03b1 \u2192 m \u03b2) {l\u2081 l\u2082 : List \u03b1} :\n    (l\u2081 ++ l\u2082).mapM f = (return (\u2190 l\u2081.mapM f) ++ (\u2190 l\u2082.mapM f))", "start": [268, 1], "end": [269, 96], "kind": "commanddeclaration"}, {"full_name": "List.forM_nil'", "code": "@[simp] theorem forM_nil' [Monad m] : ([] : List \u03b1).forM f = (pure .unit : m PUnit)", "start": [276, 1], "end": [276, 91], "kind": "commanddeclaration"}, {"full_name": "List.forM_cons'", "code": "@[simp] theorem forM_cons' [Monad m] :\n    (a::as).forM f = (f a >>= fun _ => as.forM f : m PUnit)", "start": [278, 1], "end": [280, 23], "kind": "commanddeclaration"}, {"full_name": "List.eraseIdx_nil", "code": "@[simp] theorem eraseIdx_nil : ([] : List \u03b1).eraseIdx i = []", "start": [284, 1], "end": [284, 68], "kind": "commanddeclaration"}, {"full_name": "List.eraseIdx_cons_zero", "code": "@[simp] theorem eraseIdx_cons_zero : (a::as).eraseIdx 0 = as", "start": [285, 1], "end": [285, 68], "kind": "commanddeclaration"}, {"full_name": "List.eraseIdx_cons_succ", "code": "@[simp] theorem eraseIdx_cons_succ : (a::as).eraseIdx (i+1) = a :: as.eraseIdx i", "start": [286, 1], "end": [286, 88], "kind": "commanddeclaration"}, {"full_name": "List.find?_nil", "code": "@[simp] theorem find?_nil : ([] : List \u03b1).find? p = none", "start": [290, 1], "end": [290, 64], "kind": "commanddeclaration"}, {"full_name": "List.find?_cons", "code": "theorem find?_cons : (a::as).find? p = match p a with | true => some a | false => as.find? p", "start": [291, 1], "end": [292, 6], "kind": "commanddeclaration"}, {"full_name": "List.findSome?_nil", "code": "@[simp] theorem findSome?_nil : ([] : List \u03b1).findSome? f = none", "start": [296, 1], "end": [296, 72], "kind": "commanddeclaration"}, {"full_name": "List.findSome?_cons", "code": "theorem findSome?_cons {f : \u03b1 \u2192 Option \u03b2} :\n    (a::as).findSome? f = match f a with | some b => some b | none => as.findSome? f", "start": [297, 1], "end": [299, 6], "kind": "commanddeclaration"}, {"full_name": "List.replace_nil", "code": "@[simp] theorem replace_nil [BEq \u03b1] : ([] : List \u03b1).replace a b = []", "start": [303, 1], "end": [303, 76], "kind": "commanddeclaration"}, {"full_name": "List.replace_cons", "code": "theorem replace_cons [BEq \u03b1] {a : \u03b1} :\n    (a::as).replace b c = match a == b with | true => c::as | false => a :: replace as b c", "start": [304, 1], "end": [306, 6], "kind": "commanddeclaration"}, {"full_name": "List.replace_cons_self", "code": "@[simp] theorem replace_cons_self [BEq \u03b1] [LawfulBEq \u03b1] {a : \u03b1} : (a::as).replace a b = b::as", "start": [307, 1], "end": [308, 22], "kind": "commanddeclaration"}, {"full_name": "List.elem_nil", "code": "@[simp] theorem elem_nil [BEq \u03b1] : ([] : List \u03b1).elem a = false", "start": [312, 1], "end": [312, 71], "kind": "commanddeclaration"}, {"full_name": "List.elem_cons", "code": "theorem elem_cons [BEq \u03b1] {a : \u03b1} :\n    (a::as).elem b = match b == a with | true => true | false => as.elem b", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "List.elem_cons_self", "code": "@[simp] theorem elem_cons_self [BEq \u03b1] [LawfulBEq \u03b1] {a : \u03b1} : (a::as).elem a = true", "start": [316, 1], "end": [317, 19], "kind": "commanddeclaration"}, {"full_name": "List.lookup_nil", "code": "@[simp] theorem lookup_nil [BEq \u03b1] : ([] : List (\u03b1 \u00d7 \u03b2)).lookup a = none", "start": [321, 1], "end": [321, 80], "kind": "commanddeclaration"}, {"full_name": "List.lookup_cons", "code": "theorem lookup_cons [BEq \u03b1] {k : \u03b1} :\n    ((k,b)::es).lookup a = match a == k with | true => some b | false => es.lookup a", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "List.lookup_cons_self", "code": "@[simp] theorem lookup_cons_self [BEq \u03b1] [LawfulBEq \u03b1] {k : \u03b1} : ((k,b)::es).lookup k = some b", "start": [325, 1], "end": [326, 21], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_nil_left", "code": "@[simp] theorem zipWith_nil_left {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} : zipWith f [] l = []", "start": [330, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_nil_right", "code": "@[simp] theorem zipWith_nil_right {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} : zipWith f l [] = []", "start": [333, 1], "end": [334, 17], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_cons_cons", "code": "@[simp] theorem zipWith_cons_cons {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} :\n    zipWith f (a :: as) (b :: bs) = f a b :: zipWith f as bs", "start": [336, 1], "end": [338, 6], "kind": "commanddeclaration"}, {"full_name": "List.zip_nil_left", "code": "@[simp] theorem zip_nil_left : zip ([] : List \u03b1) (l : List \u03b2)  = []", "start": [342, 1], "end": [343, 6], "kind": "commanddeclaration"}, {"full_name": "List.zip_nil_right", "code": "@[simp] theorem zip_nil_right : zip (l : List \u03b1) ([] : List \u03b2)  = []", "start": [345, 1], "end": [346, 13], "kind": "commanddeclaration"}, {"full_name": "List.zip_cons_cons", "code": "@[simp] theorem zip_cons_cons : zip (a :: as) (b :: bs) = (a, b) :: zip as bs", "start": [348, 1], "end": [349, 6], "kind": "commanddeclaration"}, {"full_name": "List.unzip_nil", "code": "@[simp] theorem unzip_nil : ([] : List (\u03b1 \u00d7 \u03b2)).unzip = ([], [])", "start": [353, 1], "end": [353, 72], "kind": "commanddeclaration"}, {"full_name": "List.unzip_cons", "code": "@[simp] theorem unzip_cons {h : \u03b1 \u00d7 \u03b2} :\n    (h :: t).unzip = match unzip t with | (al, bl) => (h.1::al, h.2::bl)", "start": [354, 1], "end": [355, 80], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_nil", "code": "@[simp] theorem enumFrom_nil : ([] : List \u03b1).enumFrom i = []", "start": [359, 1], "end": [359, 68], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_cons", "code": "@[simp] theorem enumFrom_cons : (a::as).enumFrom i = (i, a) :: as.enumFrom (i+1)", "start": [360, 1], "end": [360, 88], "kind": "commanddeclaration"}, {"full_name": "List.iota_zero", "code": "@[simp] theorem iota_zero : iota 0 = []", "start": [364, 1], "end": [364, 47], "kind": "commanddeclaration"}, {"full_name": "List.iota_succ", "code": "@[simp] theorem iota_succ : iota (i+1) = (i+1) :: iota i", "start": [365, 1], "end": [365, 64], "kind": "commanddeclaration"}, {"full_name": "List.intersperse_nil", "code": "@[simp] theorem intersperse_nil (sep : \u03b1) : ([] : List \u03b1).intersperse sep = []", "start": [369, 1], "end": [369, 86], "kind": "commanddeclaration"}, {"full_name": "List.intersperse_single", "code": "@[simp] theorem intersperse_single (sep : \u03b1) : [x].intersperse sep = [x]", "start": [370, 1], "end": [370, 80], "kind": "commanddeclaration"}, {"full_name": "List.intersperse_cons\u2082", "code": "@[simp] theorem intersperse_cons\u2082 (sep : \u03b1) :\n    (x::y::zs).intersperse sep = x::sep::((y::zs).intersperse sep)", "start": [371, 1], "end": [372, 74], "kind": "commanddeclaration"}, {"full_name": "List.isPrefixOf_nil_left", "code": "@[simp] theorem isPrefixOf_nil_left [BEq \u03b1] : isPrefixOf ([] : List \u03b1) l = true", "start": [376, 1], "end": [377, 20], "kind": "commanddeclaration"}, {"full_name": "List.isPrefixOf_cons_nil", "code": "@[simp] theorem isPrefixOf_cons_nil [BEq \u03b1] : isPrefixOf (a::as) ([] : List \u03b1) = false", "start": [378, 1], "end": [378, 94], "kind": "commanddeclaration"}, {"full_name": "List.isPrefixOf_cons\u2082", "code": "theorem isPrefixOf_cons\u2082 [BEq \u03b1] {a : \u03b1} :\n    isPrefixOf (a::as) (b::bs) = (a == b && isPrefixOf as bs)", "start": [379, 1], "end": [380, 69], "kind": "commanddeclaration"}, {"full_name": "List.isPrefixOf_cons\u2082_self", "code": "@[simp] theorem isPrefixOf_cons\u2082_self [BEq \u03b1] [LawfulBEq \u03b1] {a : \u03b1} :\n    isPrefixOf (a::as) (a::bs) = isPrefixOf as bs", "start": [381, 1], "end": [382, 80], "kind": "commanddeclaration"}, {"full_name": "List.isEqv_nil_nil", "code": "@[simp] theorem isEqv_nil_nil : isEqv ([] : List \u03b1) [] eqv = true", "start": [386, 1], "end": [386, 73], "kind": "commanddeclaration"}, {"full_name": "List.isEqv_nil_cons", "code": "@[simp] theorem isEqv_nil_cons : isEqv ([] : List \u03b1) (a::as) eqv = false", "start": [387, 1], "end": [387, 80], "kind": "commanddeclaration"}, {"full_name": "List.isEqv_cons_nil", "code": "@[simp] theorem isEqv_cons_nil : isEqv (a::as : List \u03b1) [] eqv = false", "start": [388, 1], "end": [388, 78], "kind": "commanddeclaration"}, {"full_name": "List.isEqv_cons\u2082", "code": "theorem isEqv_cons\u2082 : isEqv (a::as) (b::bs) eqv = (eqv a b && isEqv as bs eqv)", "start": [389, 1], "end": [389, 86], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_nil", "code": "@[simp] theorem dropLast_nil : ([] : List \u03b1).dropLast = []", "start": [393, 1], "end": [393, 66], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_single", "code": "@[simp] theorem dropLast_single : [x].dropLast = []", "start": [394, 1], "end": [394, 59], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_cons\u2082", "code": "@[simp] theorem dropLast_cons\u2082 :\n    (x::y::zs).dropLast = x :: (y::zs).dropLast", "start": [395, 1], "end": [396, 55], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/ImplementedByAttr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/MonadEnv.lean", "lake-packages/lean4/src/lean/Lean/Elab/InfoTree.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Declaration.lean", "lake-packages/lean4/src/lean/Lean/Attributes.lean"], "premises": [{"full_name": "Lean.Compiler.getImplementedBy?", "code": "@[export lean_get_implemented_by]\ndef getImplementedBy? (env : Environment) (declName : Name) : Option Name :=\n  implementedByAttr.getParam? env declName", "start": [32, 1], "end": [34, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.setImplementedBy", "code": "def setImplementedBy (env : Environment) (declName : Name) (impName : Name) : Except String Environment :=\n  implementedByAttr.setParam env declName impName", "start": [36, 1], "end": [37, 50], "kind": "commanddeclaration"}, {"full_name": "setImplementedBy", "code": "def setImplementedBy {m} [Monad m] [MonadEnv m] [MonadError m] (declName : Name) (impName : Name) : m Unit := do\n  let env \u2190 getEnv\n  match Compiler.setImplementedBy env declName impName with\n  | Except.ok env   => setEnv env\n  | Except.error ex => throwError ex", "start": [41, 1], "end": [45, 37], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Command.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/SetOption.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.liftCommandElabM", "code": "def liftCommandElabM (k : CommandElabM \u03b1) : CoreM \u03b1 := do\n  let (a, commandState) \u2190\n    k.run {\n      fileName := \u2190 getFileName\n      fileMap := \u2190 getFileMap\n      ref := \u2190 getRef\n      tacticCache? := none\n    } |>.run {\n      env := \u2190 getEnv\n      maxRecDepth := \u2190 getMaxRecDepth\n      scopes := [{ header := \"\", opts := \u2190 getOptions }]\n    }\n  modify fun coreState => { coreState with\n    traceState.traces := coreState.traceState.traces ++ commandState.traceState.traces\n    env := commandState.env\n  }\n  if let some err := commandState.messages.msgs.toArray.find? (\u00b7.severity matches .error) then\n    throwError err.data\n  pure a", "start": [12, 1], "end": [34, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.withSetOptionIn", "code": "partial def withSetOptionIn (k : CommandElab) : CommandElab := fun stx => do\n  if stx.getKind == ``Lean.Parser.Command.in &&\n     stx[0].getKind == ``Lean.Parser.Command.set_option then\n      let opts \u2190 Elab.elabSetOption stx[0][1] stx[0][2]\n      Command.withScope (fun scope => { scope with opts }) do\n        withSetOptionIn k stx[1]\n  else\n    k stx", "start": [36, 1], "end": [47, 10], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/AttributeExtra.lean", "imports": ["lake-packages/std/Std/Lean/TagAttribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.TagAttributeExtra", "code": "structure TagAttributeExtra where\n  \n  ext : PersistentEnvExtension Name Name NameSet\n  \n  base : NameHashSet\n  deriving Inhabited", "start": [11, 1], "end": [28, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.registerTagAttributeExtra", "code": "def registerTagAttributeExtra (name : Name) (descr : String) (extra : List Name)\n    (validate : Name \u2192 AttrM Unit := fun _ => pure ()) (ref : Name := by exact decl_name%) :\n    IO TagAttributeExtra := do\n  let { ext, .. } \u2190 registerTagAttribute name descr validate ref\n  pure { ext, base := extra.foldl (\u00b7.insert \u00b7) {} }", "start": [30, 1], "end": [42, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.TagAttributeExtra.hasTag", "code": "def hasTag (attr : TagAttributeExtra) (env : Environment) (decl : Name) : Bool :=\n  match env.getModuleIdxFor? decl with\n  | some modIdx => (attr.ext.getModuleEntries env modIdx).binSearchContains decl Name.quickLt\n  | none        => (attr.ext.getState env).contains decl\n  || attr.base.contains decl", "start": [46, 1], "end": [51, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.TagAttributeExtra.getDecls", "code": "def getDecls (attr : TagAttributeExtra) (env : Environment) : Array Name := Id.run do\n  let decls := TagAttribute.getDecls.core <| attr.ext.toEnvExtension.getState env\n  attr.base.fold (\u00b7.push \u00b7) decls", "start": [53, 1], "end": [56, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.ParametricAttributeExtra", "code": "structure ParametricAttributeExtra (\u03b1 : Type) where\n  \n  attr : ParametricAttribute \u03b1\n  \n  base : HashMap Name \u03b1\n  deriving Inhabited", "start": [60, 1], "end": [77, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.registerParametricAttributeExtra", "code": "def registerParametricAttributeExtra [Inhabited \u03b1] (impl : ParametricAttributeImpl \u03b1)\n    (extra : List (Name \u00d7 \u03b1)) : IO (ParametricAttributeExtra \u03b1) := do\n  let attr \u2190 registerParametricAttribute impl\n  pure { attr, base := extra.foldl (fun s (a, b) => s.insert a b) {} }", "start": [79, 1], "end": [87, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.ParametricAttributeExtra.getParam?", "code": "def getParam? [Inhabited \u03b1] (attr : ParametricAttributeExtra \u03b1)\n    (env : Environment) (decl : Name) : Option \u03b1 :=\n  attr.attr.getParam? env decl <|> attr.base.find? decl", "start": [91, 1], "end": [97, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.ParametricAttributeExtra.setParam", "code": "def setParam (attr : ParametricAttributeExtra \u03b1)\n    (env : Environment) (decl : Name) (param : \u03b1) : Except String Environment :=\n  attr.attr.setParam env decl param", "start": [99, 1], "end": [102, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Unreachable.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/BuiltinTactic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Binders.lean", "lake-packages/lean4/src/lean/Lean/Elab/SetOption.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/Open.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Refl.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Contradiction.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.evalWithAnnotateState", "code": "@[builtin_tactic withAnnotateState] def evalWithAnnotateState : Tactic\n  | `(tactic| with_annotate_state $stx $t) =>\n    withTacticInfoContext stx (evalTactic t)\n  | _ => throwUnsupportedSyntax", "start": [19, 1], "end": [22, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalDone", "code": "@[builtin_tactic Lean.Parser.Tactic.\u00abdone\u00bb] def evalDone : Tactic := fun _ =>\n  done", "start": [24, 1], "end": [25, 7], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalSeq1", "code": "@[builtin_tactic seq1] def evalSeq1 : Tactic := fun stx => do\n  let args := stx[0].getArgs\n  for i in [:args.size] do\n    if i % 2 == 0 then\n      evalTactic args[i]!\n    else\n      saveTacticInfoForToken args[i]!", "start": [27, 1], "end": [33, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalParen", "code": "@[builtin_tactic paren] def evalParen : Tactic := fun stx =>\n  evalTactic stx[1]", "start": [35, 1], "end": [36, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.isCheckpointableTactic", "code": "def isCheckpointableTactic (arg : Syntax) : TacticM Bool := do\n  let kind := arg.getKind\n  return kind == ``Lean.Parser.Tactic.save", "start": [38, 1], "end": [41, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.addCheckpoints", "code": "def addCheckpoints (stx : Syntax) : TacticM Syntax := do\n  if !(\u2190 stx.getSepArgs.anyM isCheckpointableTactic) then return stx\n  if stx.getNumArgs <= 2 then return stx\n  let mut currentCheckpointBlock := #[]\n  let mut output := #[]\n  for i in [:(stx.getArgs.size + 1) / 2] do\n    let tac := stx[2*i]\n    let sep? := stx.getArgs[2*i+1]?\n    if (\u2190 isCheckpointableTactic tac) then\n      let checkpoint : Syntax :=\n        mkNode ``checkpoint #[\n          mkAtomFrom tac \"checkpoint\",\n          mkNode ``tacticSeq #[\n            mkNode ``tacticSeq1Indented #[\n              mkNullNode (currentCheckpointBlock.push (mkNullNode #[tac]))\n            ]\n          ]\n        ]\n      currentCheckpointBlock := #[]\n      output := output.push checkpoint\n      if let some sep := sep? then output := output.push sep\n    else\n      currentCheckpointBlock := currentCheckpointBlock.push tac\n      if let some sep := sep? then currentCheckpointBlock := currentCheckpointBlock.push sep\n  output := output ++ currentCheckpointBlock\n  return stx.setArgs output", "start": [43, 1], "end": [100, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalSepByIndentTactic", "code": "def evalSepByIndentTactic (stx : Syntax) : TacticM Unit := do\n  let stx \u2190 addCheckpoints stx\n  for arg in stx.getArgs, i in [:stx.getArgs.size] do\n    if i % 2 == 0 then\n      evalTactic arg\n    else\n      saveTacticInfoForToken arg", "start": [102, 1], "end": [109, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalTacticSeq1Indented", "code": "@[builtin_tactic tacticSeq1Indented] def evalTacticSeq1Indented : Tactic := fun stx =>\n  evalSepByIndentTactic stx[0]", "start": [111, 1], "end": [112, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalTacticSeqBracketed", "code": "@[builtin_tactic tacticSeqBracketed] def evalTacticSeqBracketed : Tactic := fun stx => do\n  let initInfo \u2190 mkInitialTacticInfo stx[0]\n  withRef stx[2] <| closeUsingOrAdmit do\n    withInfoContext (pure ()) initInfo\n    evalSepByIndentTactic stx[1]", "start": [114, 1], "end": [119, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalTacticCDot", "code": "@[builtin_tactic cdot] def evalTacticCDot : Tactic := fun stx => do\n  let initInfo \u2190 mkInitialTacticInfo stx[0]\n  withRef stx[0] <| closeUsingOrAdmit do\n    withInfoContext (pure ()) initInfo\n    evalSepByIndentTactic stx[1]", "start": [121, 1], "end": [130, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalFocus", "code": "@[builtin_tactic Parser.Tactic.focus] def evalFocus : Tactic := fun stx => do\n  let mkInfo \u2190 mkInitialTacticInfo stx[0]\n  focus do\n    withInfoContext (pure ()) mkInfo\n    evalTactic stx[1]", "start": [132, 1], "end": [137, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getOptRotation", "code": "private def getOptRotation (stx : Syntax) : Nat :=\n  if stx.isNone then 1 else stx[0].toNat", "start": [139, 1], "end": [140, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalRotateLeft", "code": "@[builtin_tactic Parser.Tactic.rotateLeft] def evalRotateLeft : Tactic := fun stx => do\n  let n := getOptRotation stx[1]\n  setGoals <| (\u2190 getGoals).rotateLeft n", "start": [142, 1], "end": [144, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalRotateRight", "code": "@[builtin_tactic Parser.Tactic.rotateRight] def evalRotateRight : Tactic := fun stx => do\n  let n := getOptRotation stx[1]\n  setGoals <| (\u2190 getGoals).rotateRight n", "start": [146, 1], "end": [148, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalOpen", "code": "@[builtin_tactic Parser.Tactic.open] def evalOpen : Tactic := fun stx => do\n  let `(tactic| open $decl in $tac) := stx | throwUnsupportedSyntax\n  try\n    pushScope\n    let openDecls \u2190 elabOpenDecl decl\n    withTheReader Core.Context (fun ctx => { ctx with openDecls := openDecls }) do\n      evalTactic tac\n  finally\n    popScope", "start": [150, 1], "end": [158, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.elabSetOption", "code": "@[builtin_tactic Parser.Tactic.set_option] def elabSetOption : Tactic := fun stx => do\n  let options \u2190 Elab.elabSetOption stx[1] stx[2]\n  withTheReader Core.Context (fun ctx => { ctx with maxRecDepth := maxRecDepth.get options, options := options }) do\n    evalTactic stx[4]", "start": [160, 1], "end": [163, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalAllGoals", "code": "@[builtin_tactic Parser.Tactic.allGoals] def evalAllGoals : Tactic := fun stx => do\n  let mvarIds \u2190 getGoals\n  let mut mvarIdsNew := #[]\n  for mvarId in mvarIds do\n    unless (\u2190 mvarId.isAssigned) do\n      setGoals [mvarId]\n      try\n        evalTactic stx[1]\n        mvarIdsNew := mvarIdsNew ++ (\u2190 getUnsolvedGoals)\n      catch ex =>\n        if (\u2190 read).recover then\n          logException ex\n          mvarIdsNew := mvarIdsNew.push mvarId\n        else\n          throw ex\n  setGoals mvarIdsNew.toList", "start": [165, 1], "end": [180, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalAnyGoals", "code": "@[builtin_tactic Parser.Tactic.anyGoals] def evalAnyGoals : Tactic := fun stx => do\n  let mvarIds \u2190 getGoals\n  let mut mvarIdsNew := #[]\n  let mut succeeded := false\n  for mvarId in mvarIds do\n    unless (\u2190 mvarId.isAssigned) do\n      setGoals [mvarId]\n      try\n        evalTactic stx[1]\n        mvarIdsNew := mvarIdsNew ++ (\u2190 getUnsolvedGoals)\n        succeeded := true\n      catch _ =>\n        mvarIdsNew := mvarIdsNew.push mvarId\n  unless succeeded do\n    throwError \"failed on all goals\"\n  setGoals mvarIdsNew.toList", "start": [182, 1], "end": [197, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalTacticSeq", "code": "@[builtin_tactic tacticSeq] def evalTacticSeq : Tactic := fun stx =>\n  evalTactic stx[0]", "start": [199, 1], "end": [200, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalChoiceAux", "code": "partial def evalChoiceAux (tactics : Array Syntax) (i : Nat) : TacticM Unit :=\n  if h : i < tactics.size then\n    let tactic := tactics.get \u27e8i, h\u27e9\n    catchInternalId unsupportedSyntaxExceptionId\n      (evalTactic tactic)\n      (fun _ => evalChoiceAux tactics (i+1))\n  else\n    throwUnsupportedSyntax", "start": [202, 1], "end": [209, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalChoice", "code": "@[builtin_tactic choice] def evalChoice : Tactic := fun stx =>\n  evalChoiceAux stx.getArgs 0", "start": [211, 1], "end": [212, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalSkip", "code": "@[builtin_tactic skip] def evalSkip : Tactic := fun _ => pure ()", "start": [214, 1], "end": [214, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalUnknown", "code": "@[builtin_tactic unknown] def evalUnknown : Tactic := fun stx => do\n  addCompletionInfo <| CompletionInfo.tactic stx (\u2190 getGoals)", "start": [216, 1], "end": [217, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalFailIfSuccess", "code": "@[builtin_tactic failIfSuccess] def evalFailIfSuccess : Tactic := fun stx =>\n  Term.withoutErrToSorry <| withoutRecover do\n    let tactic := stx[1]\n    if (\u2190 try evalTactic tactic; pure true catch _ => pure false) then\n      throwError \"tactic succeeded\"", "start": [219, 1], "end": [223, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalTraceState", "code": "@[builtin_tactic traceState] def evalTraceState : Tactic := fun _ => do\n  let gs \u2190 getUnsolvedGoals\n  addRawTrace (goalsToMessageData gs)", "start": [225, 1], "end": [227, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalTraceMessage", "code": "@[builtin_tactic traceMessage] def evalTraceMessage : Tactic := fun stx => do\n  match stx[1].isStrLit? with\n  | none     => throwIllFormedSyntax\n  | some msg => withRef stx[0] <| addRawTrace msg", "start": [229, 1], "end": [232, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalAssumption", "code": "@[builtin_tactic Lean.Parser.Tactic.assumption] def evalAssumption : Tactic := fun _ =>\n  liftMetaTactic fun mvarId => do mvarId.assumption; pure []", "start": [234, 1], "end": [235, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalContradiction", "code": "@[builtin_tactic Lean.Parser.Tactic.contradiction] def evalContradiction : Tactic := fun _ =>\n  liftMetaTactic fun mvarId => do mvarId.contradiction; pure []", "start": [237, 1], "end": [238, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalRefl", "code": "@[builtin_tactic Lean.Parser.Tactic.refl] def evalRefl : Tactic := fun _ =>\n  liftMetaTactic fun mvarId => do mvarId.refl; pure []", "start": [240, 1], "end": [241, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalIntro", "code": "@[builtin_tactic Lean.Parser.Tactic.intro] def evalIntro : Tactic := fun stx => do\n  match stx with\n  | `(tactic| intro)                   => introStep none `_\n  | `(tactic| intro $h:ident)          => introStep h h.getId\n  | `(tactic| intro _%$tk)             => introStep tk `_\n  \n  | `(tactic| intro ($h:ident : $type:term)) => introStep h h.getId type\n  \n  | `(tactic| intro $pat:term)         => evalTactic (\u2190 `(tactic| intro h; match @h with | $pat:term => ?_; try clear h))\n  | `(tactic| intro $h:term $hs:term*) => evalTactic (\u2190 `(tactic| intro $h:term; intro $hs:term*))\n  | _ => throwUnsupportedSyntax\nwhere\n  introStep (ref : Option Syntax) (n : Name) (typeStx? : Option Syntax := none) : TacticM Unit := do\n    let fvarId \u2190 liftMetaTacticAux fun mvarId => do\n      let (fvarId, mvarId) \u2190 mvarId.intro n\n      pure (fvarId, [mvarId])\n    if let some typeStx := typeStx? then\n      withMainContext do\n        let type \u2190 Term.withSynthesize (mayPostpone := true) <| Term.elabType typeStx\n        let fvar := mkFVar fvarId\n        let fvarType \u2190 inferType fvar\n        unless (\u2190 isDefEqGuarded type fvarType) do\n          throwError \"type mismatch at `intro {fvar}`{\u2190 mkHasTypeButIsExpectedMsg fvarType type}\"\n        liftMetaTactic fun mvarId => return [\u2190 mvarId.replaceLocalDeclDefEq fvarId type]\n    if let some stx := ref then\n      withMainContext do\n        Term.addLocalVarInfo stx (mkFVar fvarId)", "start": [243, 1], "end": [269, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalIntroMatch", "code": "@[builtin_tactic Lean.Parser.Tactic.introMatch] def evalIntroMatch : Tactic := fun stx => do\n  let matchAlts := stx[1]\n  let stxNew \u2190 liftMacroM <| Term.expandMatchAltsIntoMatchTactic stx matchAlts\n  withMacroExpansion stx stxNew <| evalTactic stxNew", "start": [271, 1], "end": [274, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalIntros", "code": "@[builtin_tactic \u00abintros\u00bb] def evalIntros : Tactic := fun stx =>\n  match stx with\n  | `(tactic| intros) => liftMetaTactic fun mvarId => do\n    let (_, mvarId) \u2190 mvarId.intros\n    return [mvarId]\n  | `(tactic| intros $ids*) => do\n    let fvars \u2190 liftMetaTacticAux fun mvarId => do\n      let (fvars, mvarId) \u2190 mvarId.introN ids.size (ids.map getNameOfIdent').toList\n      return (fvars, [mvarId])\n    withMainContext do\n      for stx in ids, fvar in fvars do\n        Term.addLocalVarInfo stx (mkFVar fvar)\n  | _ => throwUnsupportedSyntax", "start": [276, 1], "end": [288, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalRevert", "code": "@[builtin_tactic Lean.Parser.Tactic.revert] def evalRevert : Tactic := fun stx =>\n  match stx with\n  | `(tactic| revert $hs*) => do\n     let (_, mvarId) \u2190 (\u2190 getMainGoal).revert (\u2190 getFVarIds hs)\n     replaceMainGoal [mvarId]\n  | _                     => throwUnsupportedSyntax", "start": [290, 1], "end": [295, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalClear", "code": "@[builtin_tactic Lean.Parser.Tactic.clear] def evalClear : Tactic := fun stx =>\n  match stx with\n  | `(tactic| clear $hs*) => do\n    let fvarIds \u2190 getFVarIds hs\n    let fvarIds \u2190 withMainContext <| sortFVarIds fvarIds\n    for fvarId in fvarIds.reverse do\n      withMainContext do\n        let mvarId \u2190 (\u2190 getMainGoal).clear fvarId\n        replaceMainGoal [mvarId]\n  | _ => throwUnsupportedSyntax", "start": [297, 1], "end": [306, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.forEachVar", "code": "def forEachVar (hs : Array Syntax) (tac : MVarId \u2192 FVarId \u2192 MetaM MVarId) : TacticM Unit := do\n  for h in hs do\n    withMainContext do\n      let fvarId \u2190 getFVarId h\n      let mvarId \u2190 tac (\u2190 getMainGoal) fvarId\n      replaceMainGoal [mvarId]", "start": [308, 1], "end": [313, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalSubst", "code": "@[builtin_tactic Lean.Parser.Tactic.subst] def evalSubst : Tactic := fun stx =>\n  match stx with\n  | `(tactic| subst $hs*) => forEachVar hs Meta.subst\n  | _                     => throwUnsupportedSyntax", "start": [315, 1], "end": [318, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalSubstVars", "code": "@[builtin_tactic Lean.Parser.Tactic.substVars] def evalSubstVars : Tactic := fun _ =>\n  liftMetaTactic fun mvarId => return [\u2190 substVars mvarId]", "start": [320, 1], "end": [321, 59], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.findTag?", "code": "private def findTag? (mvarIds : List MVarId) (tag : Name) : TacticM (Option MVarId) := do\n  match (\u2190 mvarIds.findM? fun mvarId => return tag == (\u2190 mvarId.getDecl).userName) with\n  | some mvarId => return mvarId\n  | none =>\n  match (\u2190 mvarIds.findM? fun mvarId => return tag.isSuffixOf (\u2190 mvarId.getDecl).userName) with\n  | some mvarId => return mvarId\n  | none => mvarIds.findM? fun mvarId => return tag.isPrefixOf (\u2190 mvarId.getDecl).userName", "start": [323, 1], "end": [333, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.renameInaccessibles", "code": "def renameInaccessibles (mvarId : MVarId) (hs : TSyntaxArray ``binderIdent) : TacticM MVarId := do\n  if hs.isEmpty then\n    return mvarId\n  else\n    let mvarDecl \u2190 mvarId.getDecl\n    let mut lctx  := mvarDecl.lctx\n    let mut hs    := hs\n    let mut info  := #[]\n    let mut found : NameSet := {}\n    let n := lctx.numIndices\n    for i in [:n] do\n      let j := n - i - 1\n      match lctx.getAt? j with\n      | none => pure ()\n      | some localDecl =>\n        if localDecl.userName.hasMacroScopes || found.contains localDecl.userName then\n          if let `(binderIdent| $h:ident) := hs.back then\n            let newName := h.getId\n            lctx := lctx.setUserName localDecl.fvarId newName\n            info := info.push (localDecl.fvarId, h)\n          hs := hs.pop\n          if hs.isEmpty then\n            break\n        found := found.insert localDecl.userName\n    unless hs.isEmpty do\n      logError m!\"too many variable names provided\"\n    let mvarNew \u2190 mkFreshExprMVarAt lctx mvarDecl.localInstances mvarDecl.type MetavarKind.syntheticOpaque mvarDecl.userName\n    withSaveInfoContext <| mvarNew.mvarId!.withContext do\n      for (fvarId, stx) in info do\n        Term.addLocalVarInfo stx (mkFVar fvarId)\n    mvarId.assign mvarNew\n    return mvarNew.mvarId!", "start": [335, 1], "end": [366, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.getCaseGoals", "code": "private def getCaseGoals (tag : TSyntax ``binderIdent) : TacticM (MVarId \u00d7 List MVarId) := do\n  let gs \u2190 getUnsolvedGoals\n  let g \u2190 if let `(binderIdent| $tag:ident) := tag then\n    let tag := tag.getId\n    let some g \u2190 findTag? gs tag | notFound gs tag\n    pure g\n  else\n    getMainGoal\n  return (g, gs.erase g)\n\nwhere\n  notFound (available : List MVarId) (tag : Name) := do\n    let firstLine := m!\"Case tag {showTagName tag} not found.\"\n    match (\u2190 available.mapM getUserName).filter (\u00b7 \u2260 Name.anonymous) with\n    | [] =>\n      throwError \"{firstLine}\\n\\nThere are no cases to select.\"\n    | [availableName] =>\n      throwError \"{firstLine}\\n\\nThe only available case tag is {showTagName availableName}.\"\n    | availableNames =>\n      throwError \"Case tag {showTagName tag} not found.\\n\\nAvailable tags:{commaList <| availableNames.map showTagName}\"\n\n  getUserName (mv : MVarId) := do return (\u2190 mv.getDecl).userName\n\n  showTagName (tagName : Name) : MessageData := m!\"'{tagName}'\"\n\n  commaList (items : List MessageData) : MessageData :=\n    let sep := MessageData.ofFormat \",\" ++ Format.line\n    .group <| .nest 2 <|\n    .ofFormat .line ++ .joinSep items sep", "start": [368, 1], "end": [403, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalCase", "code": "@[builtin_tactic \u00abcase\u00bb] def evalCase : Tactic\n  | stx@`(tactic| case $[$tag $hs*]|* =>%$arr $tac:tacticSeq) =>\n    for tag in tag, hs in hs do\n      let (g, gs) \u2190 getCaseGoals tag\n      let g \u2190 renameInaccessibles g hs\n      setGoals [g]\n      g.setTag Name.anonymous\n      withCaseRef arr tac do\n        closeUsingOrAdmit (withTacticInfoContext stx (evalTactic tac))\n      setGoals gs\n  | _ => throwUnsupportedSyntax", "start": [406, 1], "end": [416, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalCase'", "code": "@[builtin_tactic \u00abcase'\u00bb] def evalCase' : Tactic\n  | `(tactic| case' $[$tag $hs*]|* =>%$arr $tac:tacticSeq) => do\n    let mut acc := #[]\n    for tag in tag, hs in hs do\n      let (g, gs) \u2190 getCaseGoals tag\n      let g \u2190 renameInaccessibles g hs\n      let mvarTag \u2190 g.getTag\n      setGoals [g]\n      withCaseRef arr tac (evalTactic tac)\n      let gs' \u2190 getUnsolvedGoals\n      if let [g'] := gs' then\n        g'.setTag mvarTag\n      acc := acc ++ gs'\n      setGoals gs\n    setGoals (acc.toList ++ (\u2190 getGoals))\n  | _ => throwUnsupportedSyntax", "start": [418, 1], "end": [433, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalRenameInaccessibles", "code": "@[builtin_tactic \u00abrenameI\u00bb] def evalRenameInaccessibles : Tactic\n  | `(tactic| rename_i $hs*) => do replaceMainGoal [\u2190 renameInaccessibles (\u2190 getMainGoal) hs]\n  | _ => throwUnsupportedSyntax", "start": [435, 1], "end": [437, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalFirst", "code": "@[builtin_tactic \u00abfirst\u00bb] partial def evalFirst : Tactic := fun stx => do\n  let tacs := stx[1].getArgs\n  if tacs.isEmpty then throwUnsupportedSyntax\n  loop tacs 0\nwhere\n  loop (tacs : Array Syntax) (i : Nat) :=\n    if i == tacs.size - 1 then\n      evalTactic tacs[i]![1]\n    else\n      evalTactic tacs[i]![1] <|> loop tacs (i+1)", "start": [439, 1], "end": [448, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalFail", "code": "@[builtin_tactic \u00abfail\u00bb] def evalFail : Tactic := fun stx => do\n  let goals \u2190 getGoals\n  let goalsMsg := MessageData.joinSep (goals.map MessageData.ofGoal) m!\"\\n\\n\"\n  match stx with\n  | `(tactic| fail)          => throwError \"tactic 'fail' failed\\n{goalsMsg}\"\n  | `(tactic| fail $msg:str) => throwError \"{msg.getString}\\n{goalsMsg}\"\n  | _ => throwUnsupportedSyntax", "start": [450, 1], "end": [456, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalDbgTrace", "code": "@[builtin_tactic Parser.Tactic.dbgTrace] def evalDbgTrace : Tactic := fun stx => do\n  match stx[1].isStrLit? with\n  | none     => throwIllFormedSyntax\n  | some msg => dbg_trace msg", "start": [458, 1], "end": [461, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalSleep", "code": "@[builtin_tactic sleep] def evalSleep : Tactic := fun stx => do\n  match stx[1].isNatLit? with\n  | none    => throwIllFormedSyntax\n  | some ms => IO.sleep ms.toUInt32", "start": [463, 1], "end": [466, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Position.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/Lsp/Utf16.lean", "lake-packages/lean4/src/lean/Lean/Syntax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.FileMap.utf8RangeToLspRange", "code": "def Lean.FileMap.utf8RangeToLspRange (text : FileMap) (range : String.Range) : Lsp.Range :=\n  { start := text.utf8PosToLspPos range.start, \u00abend\u00bb := text.utf8PosToLspPos range.stop }", "start": [9, 1], "end": [11, 90], "kind": "commanddeclaration"}, {"full_name": "Lean.FileMap.rangeOfStx?", "code": "def Lean.FileMap.rangeOfStx? (text : FileMap) (stx : Syntax) : Option Lsp.Range :=\n  text.utf8RangeToLspRange <$> stx.getRange?", "start": [13, 1], "end": [15, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.FileMap.ofPosition", "code": "def Lean.FileMap.ofPosition (text : FileMap) (pos : Position) : String.Pos :=\n  let colPos :=\n    if h : pos.line - 1 < text.positions.size then\n      text.positions.get \u27e8pos.line - 1, h\u27e9\n    else if text.positions.isEmpty then\n      0\n    else\n      text.positions.back\n  String.Iterator.nextn \u27e8text.source, colPos\u27e9 pos.column |>.pos", "start": [17, 1], "end": [26, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.findLineStart", "code": "def Lean.findLineStart (s : String) (pos : String.Pos) : String.Pos :=\n  match s.revFindAux (\u00b7 = '\\n') pos with\n  | none => 0\n  | some n => \u27e8n.byteIdx + 1\u27e9", "start": [28, 1], "end": [32, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.findIndentAndIsStart", "code": "def Lean.findIndentAndIsStart (s : String) (pos : String.Pos) : Nat \u00d7 Bool :=\n  let start := findLineStart s pos\n  let body := s.findAux (\u00b7 \u2260 ' ') pos start\n  ((body - start).1, body == pos)", "start": [34, 1], "end": [41, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.ofRange", "code": "def Lean.Syntax.ofRange (range : String.Range) (canonical := true) : Lean.Syntax :=\n  .atom (.synthetic range.start range.stop canonical) \"\"", "start": [43, 1], "end": [45, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.FileMap.lineStart", "code": "def Lean.FileMap.lineStart (map : FileMap) (line : Nat) : String.Pos :=\n  if h : line - 1 < map.positions.size then\n    map.positions.get \u27e8line - 1, h\u27e9\n  else map.positions.back?.getD 0", "start": [47, 1], "end": [51, 34], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Name.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Name.hasNum", "code": "def hasNum : Name \u2192 Bool\n  | .anonymous => false\n  | .str p _ => p.hasNum\n  | .num _ _ => true", "start": [9, 1], "end": [13, 21], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Widget/UserWidget.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Eval.lean", "lake-packages/lean4/src/lean/Lean/Server/Rpc/RequestHandling.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Widget.WidgetSource", "code": "structure WidgetSource where\n  \n  sourcetext : String\n  deriving Inhabited, ToJson, FromJson", "start": [14, 1], "end": [26, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.UserWidgetDefinition", "code": "structure UserWidgetDefinition where\n  \n  name : String\n  \n  javascript: String\n  deriving Inhabited, ToJson, FromJson", "start": [28, 1], "end": [43, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.UserWidget", "code": "structure UserWidget where\n  id : Name\n  \n  name : String\n  javascriptHash: UInt64\n  deriving Inhabited, ToJson, FromJson", "start": [45, 1], "end": [50, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.WidgetSourceRegistry", "code": "private abbrev WidgetSourceRegistry := SimplePersistentEnvExtension\n    (UInt64 \u00d7 Name)\n    (RBMap UInt64 Name compare)", "start": [52, 1], "end": [54, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.getUserWidgetDefinitionUnsafe", "code": "private unsafe def getUserWidgetDefinitionUnsafe\n  (decl : Name) : CoreM UserWidgetDefinition :=\n  evalConstCheck UserWidgetDefinition ``UserWidgetDefinition decl", "start": [65, 1], "end": [67, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.getUserWidgetDefinition", "code": "@[implemented_by getUserWidgetDefinitionUnsafe]\nprivate opaque getUserWidgetDefinition\n  (decl : Name) : CoreM UserWidgetDefinition", "start": [69, 1], "end": [71, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.attributeImpl", "code": "private def attributeImpl : AttributeImpl where\n  name := `widget\n  descr := \"Mark a string as static code that can be loaded by a widget handler.\"\n  applicationTime := AttributeApplicationTime.afterCompilation\n  add decl _stx _kind := do\n    let env \u2190 getEnv\n    let defn \u2190 getUserWidgetDefinition decl\n    let javascriptHash := hash defn.javascript\n    let env := userWidgetRegistry.insert env decl {id := decl, name := defn.name, javascriptHash}\n    let env := widgetSourceRegistry.addEntry env (javascriptHash, decl)\n    setEnv <| env", "start": [73, 1], "end": [83, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.GetWidgetSourceParams", "code": "structure GetWidgetSourceParams where\n  \n  hash: UInt64\n  pos : Lean.Lsp.Position\n  deriving ToJson, FromJson", "start": [87, 1], "end": [92, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.getWidgetSource", "code": "@[server_rpc_method]\ndef getWidgetSource (args : GetWidgetSourceParams) : RequestM (RequestTask WidgetSource) := do\n  let doc \u2190 readDoc\n  let pos := doc.meta.text.lspPosToUtf8Pos args.pos\n  let notFound := throwThe RequestError \u27e8.invalidParams, s!\"No registered user-widget with hash {args.hash}\"\u27e9\n  withWaitFindSnap doc (notFoundX := notFound)\n    (fun s => s.endPos >= pos || (widgetSourceRegistry.getState s.env).contains args.hash)\n    fun snap => do\n      if let some id := widgetSourceRegistry.getState snap.env |>.find? args.hash then\n        runCoreM snap do\n          return {sourcetext := (\u2190 getUserWidgetDefinition id).javascript}\n      else\n        notFound", "start": [95, 1], "end": [107, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.widgetInfosAt?", "code": "def widgetInfosAt? (text : FileMap) (t : InfoTree) (hoverPos : String.Pos) : List UserWidgetInfo :=\n  t.deepestNodes fun\n    | _ctx, i@(Info.ofUserWidgetInfo wi), _cs => do\n      if let (some pos, some tailPos) := (i.pos?, i.tailPos?) then\n        let trailSize := i.stx.getTrailingSize\n        let atEOF := tailPos.byteIdx + trailSize == text.source.endPos.byteIdx\n        guard <| pos \u2264 hoverPos \u2227 (hoverPos.byteIdx < tailPos.byteIdx + trailSize || atEOF)\n        return wi\n      else\n        failure\n    | _, _, _ => none", "start": [111, 1], "end": [125, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.UserWidgetInstance", "code": "structure UserWidgetInstance extends UserWidget where\n  \n  props : Json\n  \n  range? : Option Lsp.Range\n  deriving ToJson, FromJson", "start": [127, 1], "end": [133, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.GetWidgetsResponse", "code": "structure GetWidgetsResponse where\n  widgets : Array UserWidgetInstance\n  deriving ToJson, FromJson", "start": [135, 1], "end": [138, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.getWidgets", "code": "@[server_rpc_method]\ndef getWidgets (args : Lean.Lsp.Position) : RequestM (RequestTask (GetWidgetsResponse)) := do\n  let doc \u2190 readDoc\n  let filemap := doc.meta.text\n  let pos := filemap.lspPosToUtf8Pos args\n  withWaitFindSnap doc (\u00b7.endPos >= pos) (notFoundX := return \u27e8\u2205\u27e9) fun snap => do\n    let env := snap.env\n    let ws := widgetInfosAt? filemap snap.infoTree pos\n    let ws \u2190 ws.toArray.mapM (fun (w : UserWidgetInfo) => do\n      let some widget := userWidgetRegistry.find? env w.widgetId\n        | throw <| RequestError.mk .invalidParams s!\"No registered user-widget with id {w.widgetId}\"\n      return {\n        widget with\n        props := w.props\n        range? := String.Range.toLspRange filemap <$> Syntax.getRange? w.stx\n      })\n    return {widgets := ws}", "start": [141, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.saveWidgetInfo", "code": "def saveWidgetInfo [Monad m] [MonadEnv m] [MonadError m] [MonadInfoTree m] (widgetId : Name) (props : Json) (stx : Syntax):  m Unit := do\n  let info := Info.ofUserWidgetInfo {\n    widgetId := widgetId\n    props := props\n    stx := stx\n  }\n  pushInfoLeaf info", "start": [160, 1], "end": [168, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.evalJsonUnsafe", "code": "private unsafe def evalJsonUnsafe (stx : Syntax) : TermElabM Json :=\n  Lean.Elab.Term.evalTerm Json (mkConst ``Json) stx", "start": [176, 1], "end": [177, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.evalJson", "code": "@[implemented_by evalJsonUnsafe]\nprivate opaque evalJson (stx : Syntax) : TermElabM Json", "start": [179, 1], "end": [180, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Widget.elabWidgetCmd", "code": "@[command_elab widgetCmd] def elabWidgetCmd : CommandElab := fun\n  | stx@`(#widget $id:ident $props) => do\n    let props : Json \u2190 runTermElabM fun _ => evalJson props\n    saveWidgetInfo id.getId props stx\n  | _ => throwUnsupportedSyntax", "start": [184, 1], "end": [188, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Format.lean", "imports": ["lake-packages/std/Std/Tactic/OpenPrivate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Format.prettyExtra", "code": "def prettyExtra (f : Format) (w : Nat := defWidth) (indent : Nat := 0) (column := 0) : String :=\n  let act : StateM State Unit := prettyM f w indent\n  State.out <| act (State.mk \"\" column) |>.snd", "start": [11, 1], "end": [19, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Server/CodeActions.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Server/FileWorker/RequestHandling.lean", "lake-packages/lean4/src/lean/Lean/Server/InfoUtils.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Server.LazyCodeAction", "code": "structure LazyCodeAction where\n  \n  eager : CodeAction\n  lazy? : Option (IO CodeAction) := none", "start": [17, 1], "end": [25, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.CodeActionResolveData", "code": "structure CodeActionResolveData where\n  params : CodeActionParams\n  \n  providerName : Name\n  \n  providerResultIndex : Nat\n  deriving ToJson, FromJson", "start": [27, 1], "end": [34, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.CodeAction.getFileSource!", "code": "def CodeAction.getFileSource! (ca : CodeAction) : DocumentUri :=\n  let r : Except String DocumentUri := do\n    let some data := ca.data?\n      | throw s!\"no data param on code action {ca.title}\"\n    let data : CodeActionResolveData \u2190 fromJson? data\n    return data.params.textDocument.uri\n  match r with\n  | Except.ok uri => uri\n  | Except.error e => panic! e", "start": [36, 1], "end": [44, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.CodeActionProvider", "code": "def CodeActionProvider := CodeActionParams \u2192 Snapshot \u2192 RequestM (Array LazyCodeAction)", "start": [53, 1], "end": [68, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.evalCodeActionProviderUnsafe", "code": "private unsafe def evalCodeActionProviderUnsafe [MonadEnv M] [MonadOptions M] [MonadError M] [Monad M] (declName : Name) : M CodeActionProvider := do\n  evalConstCheck CodeActionProvider ``CodeActionProvider declName", "start": [84, 1], "end": [85, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.evalCodeActionProvider", "code": "@[implemented_by evalCodeActionProviderUnsafe]\nprivate opaque evalCodeActionProvider [MonadEnv M] [MonadOptions M] [MonadError M] [Monad M] (declName : Name) : M CodeActionProvider", "start": [87, 1], "end": [89, 134], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.handleCodeAction", "code": "def handleCodeAction (params : CodeActionParams) : RequestM (RequestTask (Array CodeAction)) := do\n  let doc \u2190 readDoc\n  let pos := doc.meta.text.lspPosToUtf8Pos params.range.end\n  withWaitFindSnap doc (fun s => s.endPos \u2265 pos)\n    (notFoundX := return #[])\n    fun snap => do\n      let caps \u2190 RequestM.runCoreM snap do\n        let env \u2190 getEnv\n        let names := codeActionProviderExt.getState env |>.toArray\n        let caps \u2190 names.mapM evalCodeActionProvider\n        return Array.zip names caps\n      caps.concatMapM fun (providerName, cap) => do\n        let cas \u2190 cap params snap\n        cas.mapIdxM fun i lca => do\n          if lca.lazy?.isNone then return lca.eager\n          let data : CodeActionResolveData := {\n            params, providerName, providerResultIndex := i\n          }\n          let j : Json := toJson data\n          let ca := { lca.eager with data? := some j }\n          return ca", "start": [91, 1], "end": [116, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Server.handleCodeActionResolve", "code": "def handleCodeActionResolve (param : CodeAction) : RequestM (RequestTask CodeAction) := do\n  let doc \u2190 readDoc\n  let some data := param.data?\n    | throw (RequestError.invalidParams \"Expected a data field on CodeAction.\")\n  let data : CodeActionResolveData \u2190 liftExcept <| Except.mapError RequestError.invalidParams <| fromJson? data\n  let pos := doc.meta.text.lspPosToUtf8Pos data.params.range.end\n  withWaitFindSnap doc (fun s => s.endPos \u2265 pos)\n    (notFoundX := throw <| RequestError.internalError \"snapshot not found\")\n    fun snap => do\n      let cap \u2190 RequestM.runCoreM snap <| evalCodeActionProvider data.providerName\n      let cas \u2190 cap data.params snap\n      let some ca := cas[data.providerResultIndex]?\n        | throw <| RequestError.internalError s!\"Failed to resolve code action index {data.providerResultIndex}.\"\n      let some lazy := ca.lazy?\n        | throw <| RequestError.internalError s!\"Can't resolve; nothing further to resolve.\"\n      let r \u2190 liftM lazy\n      return r", "start": [121, 1], "end": [141, 15], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/SizeOf.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "lake-packages/lean4/src/lean/Lean/Meta/Instances.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.mkLocalInstances", "code": "private partial def mkLocalInstances (params : Array Expr) (k : Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  loop 0 #[]\nwhere\n  loop (i : Nat) (insts : Array Expr) : MetaM \u03b1 := do\n    if i < params.size then\n      let param := params[i]!\n      let paramType \u2190 inferType param\n      let instType? \u2190 forallTelescopeReducing paramType fun xs _ => do\n        let type := mkAppN param xs\n        try\n          let sizeOf \u2190 mkAppM `SizeOf #[type]\n          let instType \u2190 mkForallFVars xs sizeOf\n          return some instType\n        catch _ =>\n          return none\n      match instType? with\n      | none => loop (i+1) insts\n      | some instType =>\n        let instName \u2190 mkFreshUserName `inst\n        withLocalDecl instName BinderInfo.instImplicit instType fun inst =>\n          loop (i+1) (insts.push inst)\n    else\n      k insts", "start": [11, 1], "end": [34, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isInductiveHypothesis?", "code": "private def isInductiveHypothesis? (motiveFVars : Array Expr) (fvar : Expr) : MetaM (Option Expr) := do\n  forallTelescopeReducing (\u2190 inferType fvar) fun _ type =>\n    if type.isApp && motiveFVars.contains type.getAppFn then\n      return some type.appArg!\n    else\n      return none", "start": [36, 1], "end": [45, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isInductiveHypothesis", "code": "private def isInductiveHypothesis (motiveFVars : Array Expr) (fvar : Expr) : MetaM Bool :=\n  return (\u2190 isInductiveHypothesis? motiveFVars fvar).isSome", "start": [47, 1], "end": [48, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isRecField?", "code": "private def isRecField? (motiveFVars : Array Expr) (minorFVars : Array Expr) (fvar : Expr) : MetaM (Option Nat) := do\n  let mut idx := 0\n  for minorFVar in minorFVars do\n    if let some fvar' \u2190 isInductiveHypothesis? motiveFVars minorFVar then\n      if fvar == fvar'.getAppFn then\n        return some idx\n    idx := idx + 1\n  return none", "start": [50, 1], "end": [61, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfMotives", "code": "private partial def mkSizeOfMotives (motiveFVars : Array Expr) (k : Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  loop 0 #[]\nwhere\n  loop (i : Nat) (motives : Array Expr) : MetaM \u03b1 := do\n    if i < motiveFVars.size then\n      let type \u2190 inferType motiveFVars[i]!\n      let motive \u2190 forallTelescopeReducing type fun xs _ => do\n        mkLambdaFVars xs <| mkConst ``Nat\n      trace[Meta.sizeOf] \"motive: {motive}\"\n      loop (i+1) (motives.push motive)\n    else\n      k motives", "start": [63, 1], "end": [74, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ignoreFieldType", "code": "private partial def ignoreFieldType (type : Expr) : MetaM Bool := do\n  let type \u2190 whnf type\n  if type.isForall then\n    if type.isArrow && type.bindingDomain!.isConstOf ``Unit then\n      ignoreFieldType type.bindingBody!\n    else\n      return true\n  else\n    return false", "start": [76, 1], "end": [85, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.ignoreField", "code": "private def ignoreField (x : Expr) : MetaM Bool := do\n  let type \u2190 inferType x\n  ignoreFieldType type", "start": [87, 1], "end": [89, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfRecFieldFormIH", "code": "private partial def mkSizeOfRecFieldFormIH (ih : Expr) : MetaM Expr := do\n  if (\u2190 whnf (\u2190 inferType ih)).isForall then\n     mkSizeOfRecFieldFormIH (mkApp ih (mkConst ``Unit.unit))\n  else\n     return ih", "start": [91, 1], "end": [96, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfMinors", "code": "private partial def mkSizeOfMinors (motiveFVars : Array Expr) (minorFVars : Array Expr) (minorFVars' : Array Expr) (k : Array Expr \u2192 MetaM \u03b1) : MetaM \u03b1 :=\n  assert! minorFVars.size == minorFVars'.size\n  loop 0 #[]\nwhere\n  loop (i : Nat) (minors : Array Expr) : MetaM \u03b1 := do\n    if i < minorFVars.size then\n      forallTelescopeReducing (\u2190 inferType minorFVars[i]!) fun xs _ => do\n      forallBoundedTelescope (\u2190 inferType minorFVars'[i]!) xs.size fun xs' _ => do\n        let mut minor \u2190 mkNumeral (mkConst ``Nat) 1\n        for x in xs, x' in xs' do\n          unless (\u2190 isInductiveHypothesis motiveFVars x) do\n          unless (\u2190 ignoreField x) do match (\u2190 isRecField? motiveFVars xs x) with\n            | some idx => minor \u2190 mkAdd minor (\u2190 mkSizeOfRecFieldFormIH xs'[idx]!)\n            | none     => minor \u2190 mkAdd minor (\u2190 mkAppM ``SizeOf.sizeOf #[x'])\n        minor \u2190 mkLambdaFVars xs' minor\n        trace[Meta.sizeOf] \"minor: {minor}\"\n        loop (i+1) (minors.push minor)\n    else\n      k minors", "start": [98, 1], "end": [117, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfFn", "code": "partial def mkSizeOfFn (recName : Name) (declName : Name): MetaM Unit := do\n  trace[Meta.sizeOf] \"recName: {recName}\"\n  let recInfo : RecursorVal \u2190 getConstInfoRec recName\n  forallTelescopeReducing recInfo.type fun xs _ =>\n    let levelParams := recInfo.levelParams.tail! let params := xs[:recInfo.numParams]\n    let motiveFVars := xs[recInfo.numParams : recInfo.numParams + recInfo.numMotives]\n    let minorFVars := xs[recInfo.getFirstMinorIdx : recInfo.getFirstMinorIdx + recInfo.numMinors]\n    let indices := xs[recInfo.getFirstIndexIdx : recInfo.getFirstIndexIdx + recInfo.numIndices]\n    let major := xs[recInfo.getMajorIdx]!\n    let nat := mkConst ``Nat\n    mkLocalInstances params fun localInsts =>\n    mkSizeOfMotives motiveFVars fun motives => do\n      let us := levelOne :: levelParams.map mkLevelParam let recFn := mkConst recName us\n      let val := mkAppN recFn (params ++ motives)\n      forallBoundedTelescope (\u2190 inferType val) recInfo.numMinors fun minorFVars' _ =>\n      mkSizeOfMinors motiveFVars minorFVars minorFVars' fun minors => do\n        withInstImplicitAsImplict params do\n          let sizeOfParams := params ++ localInsts ++ indices ++ #[major]\n          let sizeOfType \u2190 mkForallFVars sizeOfParams nat\n          let val := mkAppN val (minors ++ indices ++ #[major])\n          let sizeOfValue \u2190 mkLambdaFVars sizeOfParams val\n          trace[Meta.sizeOf] \"declName: {declName}\"\n          trace[Meta.sizeOf] \"type: {sizeOfType}\"\n          trace[Meta.sizeOf] \"val: {sizeOfValue}\"\n          addDecl <| Declaration.defnDecl {\n            name        := declName\n            levelParams := levelParams\n            type        := sizeOfType\n            value       := sizeOfValue\n            safety      := DefinitionSafety.safe\n            hints       := ReducibilityHints.abbrev\n          }", "start": [119, 1], "end": [155, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfFns", "code": "def mkSizeOfFns (typeName : Name) : MetaM (Array Name \u00d7 NameMap Name) := do\n  let indInfo \u2190 getConstInfoInduct typeName\n  let recInfo \u2190 getConstInfoRec (mkRecName typeName)\n  let numExtra := recInfo.numMotives - indInfo.all.length let mut result := #[]\n  let baseName := indInfo.all.head! ++ `_sizeOf let mut i := 1\n  let mut recMap : NameMap Name := {}\n  for indTypeName in indInfo.all do\n    let sizeOfName := baseName.appendIndexAfter i\n    let recName := mkRecName indTypeName\n    mkSizeOfFn recName sizeOfName\n    recMap := recMap.insert recName sizeOfName\n    result := result.push sizeOfName\n    i := i + 1\n  for j in [:numExtra] do\n    let recName := (mkRecName indInfo.all.head!).appendIndexAfter (j+1)\n    let sizeOfName := baseName.appendIndexAfter i\n    mkSizeOfFn recName sizeOfName\n    recMap := recMap.insert recName sizeOfName\n    result := result.push sizeOfName\n    i := i + 1\n  return (result, recMap)", "start": [157, 1], "end": [184, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfSpecLemmaName", "code": "def mkSizeOfSpecLemmaName (ctorName : Name) : Name :=\n  ctorName ++ `sizeOf_spec", "start": [186, 1], "end": [187, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfSpecLemmaInstance", "code": "def mkSizeOfSpecLemmaInstance (ctorApp : Expr) : MetaM Expr :=\n  matchConstCtor ctorApp.getAppFn (fun _ => throwError \"failed to apply 'sizeOf' spec, constructor expected{indentExpr ctorApp}\") fun ctorInfo _ => do\n    let ctorArgs     := ctorApp.getAppArgs\n    let ctorParams   := ctorArgs[:ctorInfo.numParams]\n    let ctorFields   := ctorArgs[ctorInfo.numParams:]\n    let lemmaName  := mkSizeOfSpecLemmaName ctorInfo.name\n    let lemmaInfo  \u2190 getConstInfo lemmaName\n    let lemmaArity \u2190 forallTelescopeReducing lemmaInfo.type fun xs _ => return xs.size\n    let lemmaArgMask := ctorParams.toArray.map some\n    let lemmaArgMask := lemmaArgMask ++ mkArray (lemmaArity - ctorInfo.numParams - ctorInfo.numFields) (none (\u03b1 := Expr))\n    let lemmaArgMask := lemmaArgMask ++ ctorFields.toArray.map some\n    mkAppOptM lemmaName lemmaArgMask", "start": [189, 1], "end": [200, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.Context", "code": "structure Context where\n  indInfo    : InductiveVal\n  sizeOfFns  : Array Name\n  ctorName   : Name\n  params     : Array Expr\n  localInsts : Array Expr\n  recMap     : NameMap Name", "start": [205, 1], "end": [211, 28], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.M", "code": "abbrev M := ReaderT Context MetaM", "start": [213, 1], "end": [213, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.throwUnexpected", "code": "def throwUnexpected {\u03b1} (msg : MessageData) : M \u03b1 := do\n  throwError \"failed to generate sizeOf theorem for {(\u2190 read).ctorName} (use `set_option genSizeOfSpec false` to disable theorem generation), {msg}\"", "start": [215, 1], "end": [216, 149], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.throwFailed", "code": "def throwFailed {\u03b1} : M \u03b1 := do\n  throwError \"failed to generate sizeOf theorem for {(\u2190 read).ctorName}, (use `set_option genSizeOfSpec false` to disable theorem generation)\"", "start": [218, 1], "end": [219, 143], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.recToSizeOf", "code": "private def recToSizeOf (e : Expr) : M Expr := do\n  matchConstRec e.getAppFn (fun _ => throwFailed) fun info us => do\n    match (\u2190 read).recMap.find? info.name with\n    | none => throwUnexpected m!\"expected recursor application {indentExpr e}\"\n    | some sizeOfName =>\n      let args    := e.getAppArgs\n      let indices := args[info.getFirstIndexIdx : info.getFirstIndexIdx + info.numIndices]\n      let major   := args[info.getMajorIdx]!\n      return mkAppN (mkConst sizeOfName us.tail!) ((\u2190 read).params ++ (\u2190 read).localInsts ++ indices ++ #[major])", "start": [221, 1], "end": [230, 114], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.mkMinorProof", "code": "private partial def mkMinorProof (ys : Array Expr) (lhs rhs : Expr) : M Expr := do\n    trace[Meta.sizeOf.minor] \"{lhs} =?= {rhs}\"\n    if (\u2190 isDefEq lhs rhs) then\n      mkEqRefl rhs\n    else\n      match (\u2190 whnfI lhs).natAdd?, (\u2190 whnfI rhs).natAdd? with\n      | some (a\u2081, b\u2081), some (a\u2082, b\u2082) =>\n        let p\u2081 \u2190 mkMinorProof ys a\u2081 a\u2082\n        let p\u2082 \u2190 mkMinorProofStep ys b\u2081 b\u2082\n        mkCongr (\u2190 mkCongrArg (mkConst ``Nat.add) p\u2081) p\u2082\n      | _, _ =>\n        throwUnexpected m!\"expected 'Nat.add' application, lhs is {indentExpr lhs}\\nrhs is{indentExpr rhs}\"", "start": [233, 3], "end": [245, 108], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.mkMinorProofStep", "code": "private partial def mkMinorProofStep (ys : Array Expr) (lhs rhs : Expr) : M Expr := do\n    if (\u2190 isDefEq lhs rhs) then\n      mkEqRefl rhs\n    else\n      let lhs \u2190 recToSizeOf lhs\n      trace[Meta.sizeOf.minor.step] \"{lhs} =?= {rhs}\"\n      let target \u2190 mkEq lhs rhs\n      for y in ys do\n        if (\u2190 isDefEq (\u2190 inferType y) target) then\n          return y\n      mkSizeOfAuxLemma lhs rhs", "start": [247, 3], "end": [263, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.mkSizeOfAuxLemmaProof", "code": "private partial def mkSizeOfAuxLemmaProof (info : InductiveVal) (lhs : Expr) : M Expr := do\n    let lhsArgs := lhs.getAppArgs\n    let sizeOfBaseArgs := lhsArgs[:lhsArgs.size - info.numIndices - 1]\n    let indicesMajor := lhsArgs[lhsArgs.size - info.numIndices - 1:]\n    let sizeOfLevels := lhs.getAppFn.constLevels!\n    let rec\n      \n      mkSizeOf (ys : Array Expr) : M Expr := do\n      for sizeOfFn in (\u2190 read).sizeOfFns do\n        let candidate := mkAppN (mkAppN (mkConst sizeOfFn sizeOfLevels) sizeOfBaseArgs) ys\n        if (\u2190 isTypeCorrect candidate) then\n          return candidate\n      throwFailed\n    let major := lhs.appArg!\n    let majorType \u2190 whnf (\u2190 inferType major)\n    let majorTypeArgs := majorType.getAppArgs\n    match majorType.getAppFn.const? with\n    | none => throwFailed\n    | some (_, us) =>\n      let recName := mkRecName info.name\n      let recInfo \u2190 getConstInfoRec recName\n      let r := mkConst recName (levelZero :: us)\n      let r := mkAppN r majorTypeArgs[:info.numParams]\n      forallBoundedTelescope (\u2190 inferType r) recInfo.numMotives fun motiveFVars _ => do\n        let mut r := r\n        for motiveFVar in motiveFVars do\n          let motive \u2190 forallTelescopeReducing (\u2190 inferType motiveFVar) fun ys _ => do\n            let lhs \u2190 mkSizeOf ys\n            let rhs \u2190 mkAppM ``SizeOf.sizeOf #[ys.back]\n            mkLambdaFVars ys (\u2190 mkEq lhs rhs)\n          r := mkApp r motive\n        forallBoundedTelescope (\u2190 inferType r) recInfo.numMinors fun minorFVars _ => do\n          let mut r := r\n          for minorFVar in minorFVars do\n            let minor \u2190 forallTelescopeReducing (\u2190 inferType minorFVar) fun ys target => do\n              let target \u2190 whnf target\n              match target.eq? with\n              | none => throwFailed\n              | some (_, lhs, rhs) =>\n                if (\u2190 isDefEq lhs rhs) then\n                  mkLambdaFVars ys (\u2190 mkEqRefl rhs)\n                else\n                  let lhs \u2190 unfoldDefinition lhs let ctorApp := rhs.appArg!\n                  let specLemma \u2190 mkSizeOfSpecLemmaInstance ctorApp\n                  let specEq \u2190 whnf (\u2190 inferType specLemma)\n                  match specEq.eq? with\n                  | none => throwFailed\n                  | some (_, _, rhsExpanded) =>\n                    let lhs_eq_rhsExpanded \u2190 mkMinorProof ys lhs rhsExpanded\n                    let rhsExpanded_eq_rhs \u2190 mkEqSymm specLemma\n                    mkLambdaFVars ys (\u2190 mkEqTrans lhs_eq_rhsExpanded rhsExpanded_eq_rhs)\n            r := mkApp r minor\n          return mkAppN r indicesMajor", "start": [265, 3], "end": [328, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.mkSizeOfAuxLemma", "code": "private partial def mkSizeOfAuxLemma (lhs rhs : Expr) : M Expr := do\n    trace[Meta.sizeOf.aux] \"{lhs} =?= {rhs}\"\n    match lhs.getAppFn.const? with\n    | none => throwFailed\n    | some (fName, us) =>\n      let thmLevelParams \u2190 us.mapM fun\n        | Level.param n => return n\n        | _ => throwFailed\n      let thmName  := fName.appendAfter \"_eq\"\n      if (\u2190 getEnv).contains thmName then\n        return mkAppN (mkConst thmName us) lhs.getAppArgs\n      else\n        let x := lhs.appArg!\n        let xType \u2190 whnf (\u2190 inferType x)\n        matchConstInduct xType.getAppFn (fun _ => throwFailed) fun info _ => do\n          let params := xType.getAppArgs[:info.numParams]\n          forallTelescopeReducing (\u2190 inferType (mkAppN xType.getAppFn params)) fun indices _ => do\n            let majorType := mkAppN (mkAppN xType.getAppFn params) indices\n            withLocalDeclD `x majorType fun major => do\n              let lhsArgs := lhs.getAppArgs\n              let lhsArgsNew := lhsArgs[:lhsArgs.size - 1 - indices.size] ++ indices ++ #[major]\n              let lhsNew := mkAppN lhs.getAppFn lhsArgsNew\n              let rhsNew \u2190 mkAppM ``SizeOf.sizeOf #[major]\n              let eq \u2190 mkEq lhsNew rhsNew\n              let thmParams := lhsArgsNew\n              let thmType \u2190 mkForallFVars thmParams eq\n              let thmValue \u2190 mkSizeOfAuxLemmaProof info lhsNew\n              let thmValue \u2190 mkLambdaFVars thmParams thmValue\n              trace[Meta.sizeOf] \"thmValue: {thmValue}\"\n              addDecl <| Declaration.thmDecl {\n                name        := thmName\n                levelParams := thmLevelParams\n                type        := thmType\n                value       := thmValue\n              }\n              return mkAppN (mkConst thmName us) lhs.getAppArgs", "start": [330, 3], "end": [385, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.SizeOfSpecNested.main", "code": "partial def main (lhs rhs : Expr) : M Expr := do\n  if (\u2190 isDefEq lhs rhs) then\n    mkEqRefl rhs\n  else\n    \n    let lhs \u2190 whnfI lhs            let lhs \u2190 unfoldDefinition lhs loop lhs rhs\nwhere\n  loop (lhs rhs : Expr) : M Expr := do\n    trace[Meta.sizeOf.loop] \"{lhs} =?= {rhs}\"\n    if (\u2190 isDefEq lhs rhs) then\n      mkEqRefl rhs\n    else\n      match (\u2190 whnfI lhs).natAdd?, (\u2190 whnfI rhs).natAdd? with\n      | some (a\u2081, b\u2081), some (a\u2082, b\u2082) =>\n        let p\u2081 \u2190 loop a\u2081 a\u2082\n        let p\u2082 \u2190 step b\u2081 b\u2082\n        mkCongr (\u2190 mkCongrArg (mkConst ``Nat.add) p\u2081) p\u2082\n      | _, _ =>\n        throwUnexpected m!\"expected 'Nat.add' application, lhs is {indentExpr lhs}\\nrhs is{indentExpr rhs}\"\n\n  step (lhs rhs : Expr) : M Expr := do\n    if (\u2190 isDefEq lhs rhs) then\n      mkEqRefl rhs\n    else\n      let lhs \u2190 recToSizeOf lhs\n      mkSizeOfAuxLemma lhs rhs", "start": [390, 1], "end": [417, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfSpecTheorem", "code": "private def mkSizeOfSpecTheorem (indInfo : InductiveVal) (sizeOfFns : Array Name) (recMap : NameMap Name) (ctorName : Name) : MetaM Unit := do\n  let ctorInfo \u2190 getConstInfoCtor ctorName\n  let us := ctorInfo.levelParams.map mkLevelParam\n  let simpAttr \u2190 ofExcept <| getAttributeImpl (\u2190 getEnv) `simp\n  forallTelescopeReducing ctorInfo.type fun xs _ => do\n    let params := xs[:ctorInfo.numParams]\n    let fields := xs[ctorInfo.numParams:]\n    let ctorApp := mkAppN (mkConst ctorName us) xs\n    mkLocalInstances params fun localInsts => do\n      let lhs \u2190 mkAppM ``SizeOf.sizeOf #[ctorApp]\n      let mut rhs \u2190 mkNumeral (mkConst ``Nat) 1\n      for field in fields do\n        unless (\u2190 ignoreField field) do\n          rhs \u2190 mkAdd rhs (\u2190 mkAppM ``SizeOf.sizeOf #[field])\n      let target \u2190 mkEq lhs rhs\n      trace[Meta.sizeOf] \"ctor: {ctorInfo.name}, target: {target}\"\n      let thmName   := mkSizeOfSpecLemmaName ctorName\n      let thmParams := params ++ localInsts ++ fields\n      let thmType \u2190 mkForallFVars thmParams target\n      let thmValue \u2190 if indInfo.isNested then\n        SizeOfSpecNested.main lhs rhs |>.run {\n          indInfo, sizeOfFns, ctorName, params, localInsts, recMap\n        }\n      else\n        mkEqRefl rhs\n      let thmValue \u2190 mkLambdaFVars thmParams thmValue\n      trace[Meta.sizeOf] \"sizeOf spec theorem name: {thmName}\"\n      trace[Meta.sizeOf] \"sizeOf spec theorem type: {thmType}\"\n      trace[Meta.sizeOf] \"sizeOf spec theorem value: {thmValue}\"\n      unless (\u2190 isDefEq (\u2190 inferType thmValue) thmType) do\n        throwError \"type mismatch\"\n      addDecl <| Declaration.thmDecl {\n        name        := thmName\n        levelParams := ctorInfo.levelParams\n        type        := thmType\n        value       := thmValue\n      }\n      simpAttr.add thmName default AttributeKind.global", "start": [421, 1], "end": [458, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfSpecTheorems", "code": "private def mkSizeOfSpecTheorems (indTypeNames : Array Name) (sizeOfFns : Array Name) (recMap : NameMap Name) : MetaM Unit := do\n  for indTypeName in indTypeNames do\n    let indInfo \u2190 getConstInfoInduct indTypeName\n    for ctorName in indInfo.ctors do\n      mkSizeOfSpecTheorem indInfo sizeOfFns recMap ctorName\n  return ()", "start": [460, 1], "end": [465, 12], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkSizeOfInstances", "code": "def mkSizeOfInstances (typeName : Name) : MetaM Unit := do\n  if (\u2190 getEnv).contains ``SizeOf && genSizeOf.get (\u2190 getOptions) && !(\u2190 isInductivePredicate typeName) then\n    withTraceNode `Meta.sizeOf (fun _ => return m!\"{typeName}\") do\n      let indInfo \u2190 getConstInfoInduct typeName\n      unless indInfo.isUnsafe do\n        let (fns, recMap) \u2190 mkSizeOfFns typeName\n        for indTypeName in indInfo.all, fn in fns do\n          let indInfo \u2190 getConstInfoInduct indTypeName\n          forallTelescopeReducing indInfo.type fun xs _ =>\n            let params := xs[:indInfo.numParams]\n            withInstImplicitAsImplict params do\n              let indices := xs[indInfo.numParams:]\n              mkLocalInstances params fun localInsts => do\n                let us := indInfo.levelParams.map mkLevelParam\n                let indType := mkAppN (mkConst indTypeName us) xs\n                let sizeOfIndType \u2190 mkAppM ``SizeOf #[indType]\n                withLocalDeclD `m indType fun m => do\n                  let v \u2190 mkLambdaFVars #[m] <| mkAppN (mkConst fn us) (params ++ localInsts ++ indices ++ #[m])\n                  let sizeOfMk \u2190 mkAppM ``SizeOf.mk #[v]\n                  let instDeclName := indTypeName ++ `_sizeOf_inst\n                  let instDeclType \u2190 mkForallFVars (xs ++ localInsts) sizeOfIndType\n                  let instDeclValue \u2190 mkLambdaFVars (xs ++ localInsts) sizeOfMk\n                  trace[Meta.sizeOf] \">> {instDeclName} : {instDeclType}\"\n                  addDecl <| Declaration.defnDecl {\n                    name        := instDeclName\n                    levelParams := indInfo.levelParams\n                    type        := instDeclType\n                    value       := instDeclValue\n                    safety      := .safe\n                    hints       := .abbrev\n                  }\n                  addInstance instDeclName AttributeKind.global (eval_prio default)\n        if genSizeOfSpec.get (\u2190 getOptions) then\n          mkSizeOfSpecTheorems indInfo.all.toArray fns recMap", "start": [477, 1], "end": [510, 62], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/ExprTraverse.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/SubExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.forgetPos", "code": "private def forgetPos (t : (Pos \u2192 Expr \u2192 M Expr) \u2192 (Pos \u2192 Expr \u2192 M Expr)) (visit : Expr \u2192 M Expr) (e : Expr) : M Expr :=\n  t (fun _ => visit) Pos.root e", "start": [16, 1], "end": [18, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.traverseLambdaWithPos", "code": "def traverseLambdaWithPos\n  (f : Pos \u2192 Expr \u2192 M Expr) (p : Pos) (e : Expr) : M Expr := visit #[] p e\n  where visit (fvars : Array Expr) (p : Pos) :  Expr \u2192 M Expr\n    | (Expr.lam n d b c) => do\n      let d \u2190 f p.pushBindingDomain <| d.instantiateRev fvars\n      withLocalDecl n c d fun x =>\n        visit (fvars.push x) p.pushBindingBody b\n    | e => do\n      let body \u2190 f p <| e.instantiateRev fvars\n      mkLambdaFVars fvars body", "start": [20, 1], "end": [30, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.traverseForallWithPos", "code": "def traverseForallWithPos\n  (f : Pos \u2192 Expr \u2192 M Expr) (p : Pos) (e : Expr) : M Expr := visit #[] p e\n  where visit fvars (p : Pos): Expr \u2192 M Expr\n    | (Expr.forallE n d b c) => do\n      let d \u2190 f p.pushBindingDomain <| d.instantiateRev fvars\n      withLocalDecl n c d fun x =>\n        visit (fvars.push x) p.pushBindingBody b\n    | e   => do\n      let body \u2190 f p <| e.instantiateRev fvars\n      mkForallFVars fvars body", "start": [32, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.traverseLetWithPos", "code": "def traverseLetWithPos\n  (f : Pos \u2192 Expr \u2192 M Expr) (p : Pos) (e : Expr) : M Expr := visit #[] p e\n  where visit fvars (p : Pos)\n    | Expr.letE n t v b _ => do\n      let type \u2190 f p.pushLetVarType <| t.instantiateRev fvars\n      let value \u2190 f p.pushLetValue <| v.instantiateRev fvars\n      withLetDecl n type value fun x =>\n        visit (fvars.push x) p.pushLetBody b\n    | e => do\n      let body \u2190 f p <| e.instantiateRev fvars\n      mkLetFVars (usedLetOnly := false) fvars body", "start": [44, 1], "end": [57, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.traverseChildrenWithPos", "code": "def traverseChildrenWithPos (visit : Pos \u2192 Expr \u2192 M Expr) (p : Pos) (e: Expr) : M Expr :=\n  match e with\n  | Expr.forallE ..    => traverseForallWithPos   visit p e\n  | Expr.lam ..        => traverseLambdaWithPos   visit p e\n  | Expr.letE ..       => traverseLetWithPos      visit p e\n  | Expr.app ..        => Expr.traverseAppWithPos visit p e\n  | Expr.mdata _ b     => e.updateMData! <$> visit p b\n  | Expr.proj _ _ b    => e.updateProj! <$> visit p.pushProj b\n  | _                  => pure e", "start": [59, 1], "end": [69, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.traverseLambda", "code": "def traverseLambda (visit : Expr \u2192 M Expr) := forgetPos traverseLambdaWithPos visit", "start": [71, 1], "end": [75, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.traverseForall", "code": "def traverseForall (visit : Expr \u2192 M Expr) := forgetPos traverseForallWithPos visit", "start": [77, 1], "end": [81, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.traverseLet", "code": "def traverseLet (visit : Expr \u2192 M Expr) := forgetPos traverseLetWithPos visit", "start": [83, 1], "end": [84, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.traverseChildren", "code": "def traverseChildren (visit : Expr \u2192 M Expr) := forgetPos traverseChildrenWithPos visit", "start": [86, 1], "end": [94, 88], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/LevelDefEq.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Util/CollectMVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/DecLevel.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/InferType.lean"], "premises": [{"full_name": "Lean.Meta.strictOccursMax", "code": "private def strictOccursMax (lvl : Level) : Level \u2192 Bool\n  | Level.max u v => visit u || visit v\n  | _               => false\nwhere\n  visit : Level \u2192 Bool\n    | Level.max u v => visit u || visit v\n    | u               => u != lvl && lvl.occurs u", "start": [13, 1], "end": [22, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkMaxArgsDiff", "code": "private def mkMaxArgsDiff (mvarId : LMVarId) : Level \u2192 Level \u2192 Level\n  | Level.max u v,     acc => mkMaxArgsDiff mvarId v <| mkMaxArgsDiff mvarId u acc\n  | l@(Level.mvar id), acc => if id != mvarId then mkLevelMax' acc l else acc\n  | l,                   acc => mkLevelMax' acc l", "start": [24, 1], "end": [28, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.solveSelfMax", "code": "private def solveSelfMax (mvarId : LMVarId) (v : Level) : MetaM Unit := do\n  assert! v.isMax\n  let n \u2190 mkFreshLevelMVar\n  assignLevelMVar mvarId <| mkMaxArgsDiff mvarId v n", "start": [30, 1], "end": [36, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.postponeIsLevelDefEq", "code": "private def postponeIsLevelDefEq (lhs : Level) (rhs : Level) : MetaM Unit := do\n  let ref \u2190 getRef\n  let ctx \u2190 read\n  trace[Meta.isLevelDefEq.stuck] \"{lhs} =?= {rhs}\"\n  modifyPostponed fun postponed => postponed.push { lhs := lhs, rhs := rhs, ref := ref, ctx? := ctx.defEqCtx? }", "start": [38, 1], "end": [42, 112], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isMVarWithGreaterDepth", "code": "private def isMVarWithGreaterDepth (v : Level) (mvarId : LMVarId) : MetaM Bool :=\n  match v with\n  | Level.mvar mvarId' => return (\u2190 mvarId'.getLevel) > (\u2190 mvarId.getLevel)\n  | _ => return false", "start": [44, 1], "end": [47, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.solve", "code": "private partial def solve (u v : Level) : MetaM LBool := do\n    match u, v with\n    | Level.mvar mvarId, _ =>\n      if (\u2190 mvarId.isReadOnly) then\n        return LBool.undef\n      else if (\u2190 isMVarWithGreaterDepth v mvarId) then\n        assignLevelMVar v.mvarId! u\n        return LBool.true\n      else if !u.occurs v then\n        assignLevelMVar u.mvarId! v\n        return LBool.true\n      else if v.isMax && !strictOccursMax u v then\n        solveSelfMax u.mvarId! v\n        return LBool.true\n      else\n        return LBool.undef\n    | _, Level.mvar .. => return LBool.undef | Level.zero, Level.max v\u2081 v\u2082 =>\n      Bool.toLBool <$> (isLevelDefEqAux levelZero v\u2081 <&&> isLevelDefEqAux levelZero v\u2082)\n    | Level.zero, Level.imax _ v\u2082 =>\n      Bool.toLBool <$> isLevelDefEqAux levelZero v\u2082\n    | Level.zero, Level.succ .. => return LBool.false\n    | Level.succ u, v =>\n      if v.isParam then\n        return LBool.false\n      else if u.isMVar && u.occurs v then\n        return LBool.undef\n      else\n        match (\u2190 Meta.decLevel? v) with\n        | some v => Bool.toLBool <$> isLevelDefEqAux u v\n        | none   => return LBool.undef\n    | _, _ => return LBool.undef", "start": [51, 3], "end": [84, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isLevelDefEqAuxImpl", "code": "@[export lean_is_level_def_eq]\n  partial def isLevelDefEqAuxImpl : Level \u2192 Level \u2192 MetaM Bool\n    | Level.succ lhs, Level.succ rhs => isLevelDefEqAux lhs rhs\n    | lhs, rhs =>\n      withTraceNode `Meta.isLevelDefEq (return m!\"{exceptBoolEmoji \u00b7} {lhs} =?= {rhs}\") do\n      if lhs.getLevelOffset == rhs.getLevelOffset then\n        return lhs.getOffset == rhs.getOffset\n      else\n        let lhs' \u2190 instantiateLevelMVars lhs\n        let lhs' := lhs'.normalize\n        let rhs' \u2190 instantiateLevelMVars rhs\n        let rhs' := rhs'.normalize\n        if lhs != lhs' || rhs != rhs' then\n          isLevelDefEqAux lhs' rhs'\n        else\n          let r \u2190 solve lhs rhs;\n          if r != LBool.undef then\n            return r == LBool.true\n          else\n            let r \u2190 solve rhs lhs;\n            if r != LBool.undef then\n              return r == LBool.true\n            else if !(\u2190 hasAssignableLevelMVar lhs <||> hasAssignableLevelMVar rhs) then\n              let ctx \u2190 read\n              if ctx.config.isDefEqStuckEx && (lhs.isMVar || rhs.isMVar) then do\n                trace[Meta.isLevelDefEq.stuck] \"{lhs} =?= {rhs}\"\n                Meta.throwIsDefEqStuck\n              else\n                return false\n            else\n              postponeIsLevelDefEq lhs rhs\n              return true", "start": [86, 3], "end": [117, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Injective.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Types.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Refl.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Injection.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Subst.lean"], "premises": [{"full_name": "Lean.Meta.mkAnd?", "code": "private def mkAnd? (args : Array Expr) : Option Expr := Id.run do\n  if args.isEmpty then\n    return none\n  else\n    let mut result := args.back\n    for arg in args.reverse[1:] do\n      result := mkApp2 (mkConst ``And) arg result\n    return result", "start": [17, 1], "end": [24, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.elimOptParam", "code": "def elimOptParam (type : Expr) : CoreM Expr := do\n  Core.transform type fun e =>\n    if e.isAppOfArity  ``optParam 2 then\n      return TransformStep.visit (e.getArg! 0)\n    else\n      return .continue", "start": [26, 1], "end": [31, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveTheoremTypeCore?", "code": "private partial def mkInjectiveTheoremTypeCore? (ctorVal : ConstructorVal) (useEq : Bool) : MetaM (Option Expr) := do\n  let us := ctorVal.levelParams.map mkLevelParam\n  let type \u2190 elimOptParam ctorVal.type\n  forallBoundedTelescope type ctorVal.numParams fun params type =>\n  forallTelescope type fun args1 resultType => do\n    let jp (args2 args2New : Array Expr) : MetaM (Option Expr) := do\n      let lhs := mkAppN (mkAppN (mkConst ctorVal.name us) params) args1\n      let rhs := mkAppN (mkAppN (mkConst ctorVal.name us) params) args2\n      let eq \u2190 mkEq lhs rhs\n      let mut eqs := #[]\n      for arg1 in args1, arg2 in args2 do\n        let arg1Type \u2190 inferType arg1\n        if !(\u2190 isProp arg1Type) && arg1 != arg2 then\n          eqs := eqs.push (\u2190 mkEqHEq arg1 arg2)\n      if let some andEqs := mkAnd? eqs then\n        let result \u2190 if useEq then\n          mkEq eq andEqs\n        else\n          mkArrow eq andEqs\n        mkForallFVars params (\u2190 mkForallFVars args1 (\u2190 mkForallFVars args2New result))\n      else\n        return none\n    let rec mkArgs2 (i : Nat) (type : Expr) (args2 args2New : Array Expr) : MetaM (Option Expr) := do\n      if h : i < args1.size then\n        match (\u2190 whnf type) with\n        | Expr.forallE n d b _ =>\n          let arg1 := args1.get \u27e8i, h\u27e9\n          if arg1.occurs resultType then\n            mkArgs2 (i + 1) (b.instantiate1 arg1) (args2.push arg1) args2New\n          else\n            withLocalDecl n (if useEq then BinderInfo.default else BinderInfo.implicit) d fun arg2 =>\n              mkArgs2 (i + 1) (b.instantiate1 arg2) (args2.push arg2) (args2New.push arg2)\n        | _ => throwError \"unexpected constructor type for '{ctorVal.name}'\"\n      else\n        jp args2 args2New\n    if useEq then\n      mkArgs2 0 type #[] #[]\n    else\n      withNewBinderInfos (params.map fun param => (param.fvarId!, BinderInfo.implicit)) <|\n      withNewBinderInfos (args1.map fun arg1 => (arg1.fvarId!, BinderInfo.implicit)) <|\n        mkArgs2 0 type #[] #[]", "start": [33, 1], "end": [73, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveTheoremType?", "code": "private def mkInjectiveTheoremType? (ctorVal : ConstructorVal) : MetaM (Option Expr) :=\n  mkInjectiveTheoremTypeCore? ctorVal false", "start": [75, 1], "end": [76, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.injTheoremFailureHeader", "code": "private def injTheoremFailureHeader (ctorName : Name) : MessageData :=\n  m!\"failed to prove injectivity theorem for constructor '{ctorName}', use 'set_option genInjectivity false' to disable the generation\"", "start": [78, 1], "end": [79, 136], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.throwInjectiveTheoremFailure", "code": "private def throwInjectiveTheoremFailure {\u03b1} (ctorName : Name) (mvarId : MVarId) : MetaM \u03b1 :=\n  throwError \"{injTheoremFailureHeader ctorName}{indentD <| MessageData.ofGoal mvarId}\"", "start": [81, 1], "end": [82, 88], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.solveEqOfCtorEq", "code": "private def solveEqOfCtorEq (ctorName : Name) (mvarId : MVarId) (h : FVarId) : MetaM Unit := do\n  match (\u2190 injection mvarId h) with\n  | InjectionResult.solved => unreachable!\n  | InjectionResult.subgoal mvarId .. =>\n    (\u2190  mvarId.splitAnd).forM fun mvarId =>\n      unless (\u2190 mvarId.assumptionCore) do\n        throwInjectiveTheoremFailure ctorName mvarId", "start": [84, 1], "end": [90, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveTheoremValue", "code": "private def mkInjectiveTheoremValue (ctorName : Name) (targetType : Expr) : MetaM Expr :=\n  forallTelescopeReducing targetType fun xs type => do\n    let mvar \u2190 mkFreshExprSyntheticOpaqueMVar type\n    solveEqOfCtorEq ctorName mvar.mvarId! xs.back.fvarId!\n    mkLambdaFVars xs mvar", "start": [92, 1], "end": [96, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveTheoremNameFor", "code": "def mkInjectiveTheoremNameFor (ctorName : Name) : Name :=\n  ctorName ++ `inj", "start": [98, 1], "end": [99, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveTheorem", "code": "private def mkInjectiveTheorem (ctorVal : ConstructorVal) : MetaM Unit := do\n  let some type \u2190 mkInjectiveTheoremType? ctorVal\n    | return ()\n  let value \u2190 mkInjectiveTheoremValue ctorVal.name type\n  let name := mkInjectiveTheoremNameFor ctorVal.name\n  addDecl <| Declaration.thmDecl {\n    name\n    levelParams := ctorVal.levelParams\n    type        := (\u2190 instantiateMVars type)\n    value       := (\u2190 instantiateMVars value)\n  }", "start": [101, 1], "end": [111, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveEqTheoremNameFor", "code": "def mkInjectiveEqTheoremNameFor (ctorName : Name) : Name :=\n  ctorName ++ `injEq", "start": [113, 1], "end": [114, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveEqTheoremType?", "code": "private def mkInjectiveEqTheoremType? (ctorVal : ConstructorVal) : MetaM (Option Expr) :=\n  mkInjectiveTheoremTypeCore? ctorVal true", "start": [116, 1], "end": [117, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveEqTheoremValue", "code": "private def mkInjectiveEqTheoremValue (ctorName : Name) (targetType : Expr) : MetaM Expr := do\n  forallTelescopeReducing targetType fun xs type => do\n    let mvar \u2190 mkFreshExprSyntheticOpaqueMVar type\n    let [mvarId\u2081, mvarId\u2082] \u2190 mvar.mvarId!.apply (mkConst ``Eq.propIntro)\n      | throwError \"unexpected number of subgoals when proving injective theorem for constructor '{ctorName}'\"\n    let (h, mvarId\u2081) \u2190 mvarId\u2081.intro1\n    let (_, mvarId\u2082) \u2190 mvarId\u2082.intro1\n    solveEqOfCtorEq ctorName mvarId\u2081 h\n    let mvarId\u2082 \u2190 mvarId\u2082.casesAnd\n    if let some mvarId\u2082 \u2190 mvarId\u2082.substEqs then\n      try mvarId\u2082.refl catch _ => throwError (injTheoremFailureHeader ctorName)\n    mkLambdaFVars xs mvar", "start": [119, 1], "end": [130, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveEqTheorem", "code": "private def mkInjectiveEqTheorem (ctorVal : ConstructorVal) : MetaM Unit := do\n  let some type \u2190 mkInjectiveEqTheoremType? ctorVal\n    | return ()\n  let value \u2190 mkInjectiveEqTheoremValue ctorVal.name type\n  let name := mkInjectiveEqTheoremNameFor ctorVal.name\n  addDecl <| Declaration.thmDecl {\n    name\n    levelParams := ctorVal.levelParams\n    type        := (\u2190 instantiateMVars type)\n    value       := (\u2190 instantiateMVars value)\n  }\n  addSimpTheorem (ext := simpExtension) name (post := true) (inv := false) AttributeKind.global (prio := eval_prio default)", "start": [132, 1], "end": [143, 124], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkInjectiveTheorems", "code": "def mkInjectiveTheorems (declName : Name) : MetaM Unit := do\n  if (\u2190 getEnv).contains ``Eq.propIntro && genInjectivity.get (\u2190 getOptions) &&  !(\u2190 isInductivePredicate declName) then\n    let info \u2190 getConstInfoInduct declName\n    unless info.isUnsafe do\n      withLCtx {} {} do\n      for ctor in info.ctors do\n        withTraceNode `Meta.injective (fun _ => return m!\"{ctor}\") do\n          let ctorVal \u2190 getConstInfoCtor ctor\n          if ctorVal.numFields > 0 then\n            mkInjectiveTheorem ctorVal\n            mkInjectiveEqTheorem ctorVal", "start": [150, 1], "end": [165, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Structure.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Structure.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.getStructureName", "code": "def getStructureName (struct : Expr) : MetaM Name :=\n  match struct.getAppFn with\n  | Expr.const declName .. => do\n    unless isStructure (\u2190 getEnv) declName do\n      throwError \"'{declName}' is not a structure\"\n    return declName\n  | _ => throwError \"expected structure\"", "start": [13, 1], "end": [19, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/CasesOn.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/KAbstract.lean", "lake-packages/lean4/src/lean/Lean/Meta/Check.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.CasesOnApp", "code": "structure CasesOnApp where\n  declName     : Name\n  us           : List Level\n  params       : Array Expr\n  motive       : Expr\n  indices      : Array Expr\n  major        : Expr\n  alts         : Array Expr\n  altNumParams : Array Nat\n  remaining    : Array Expr\n  \n  propOnly     : Bool", "start": [11, 1], "end": [22, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.toCasesOnApp?", "code": "def toCasesOnApp? (e : Expr) : MetaM (Option CasesOnApp) := do\n  let f := e.getAppFn\n  let .const declName us := f | return none\n  unless isCasesOnRecursor (\u2190 getEnv) declName do return none\n  let indName := declName.getPrefix\n  let .inductInfo info \u2190 getConstInfo indName | return none\n  let args := e.getAppArgs\n  unless args.size >= info.numParams + 1  + info.numIndices + 1  + info.numCtors do return none\n  let params    := args[:info.numParams]\n  let motive    := args[info.numParams]!\n  let indices   := args[info.numParams + 1 : info.numParams + 1 + info.numIndices]\n  let major     := args[info.numParams + 1 + info.numIndices]!\n  let alts      := args[info.numParams + 1 + info.numIndices + 1 : info.numParams + 1 + info.numIndices + 1 + info.numCtors]\n  let remaining := args[info.numParams + 1 + info.numIndices + 1 + info.numCtors :]\n  let propOnly  := info.levelParams.length == us.length\n  let mut altNumParams := #[]\n  for ctor in info.ctors do\n    let .ctorInfo ctorInfo \u2190 getConstInfo ctor | unreachable!\n    altNumParams := altNumParams.push ctorInfo.numFields\n  return some { declName, us, params, motive, indices, major, alts, remaining, propOnly, altNumParams }", "start": [24, 1], "end": [44, 104], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CasesOnApp.toExpr", "code": "def CasesOnApp.toExpr (c : CasesOnApp) : Expr :=\n  mkAppN (mkAppN (mkApp (mkAppN (mkApp (mkAppN (mkConst c.declName c.us) c.params) c.motive) c.indices) c.major) c.alts) c.remaining", "start": [46, 1], "end": [48, 133], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CasesOnApp.addArg", "code": "def CasesOnApp.addArg (c : CasesOnApp) (arg : Expr) (checkIfRefined : Bool := false) : MetaM CasesOnApp := do\n  lambdaTelescope c.motive fun motiveArgs motiveBody => do\n    unless motiveArgs.size == c.indices.size + 1 do\n      throwError \"failed to add argument to `casesOn` application, motive must be lambda expression with #{c.indices.size + 1} binders\"\n    let argType \u2190 inferType arg\n    let discrs := c.indices ++ #[c.major]\n    let mut argTypeAbst := argType\n    for motiveArg in motiveArgs.reverse, discr in discrs.reverse do\n      argTypeAbst := (\u2190 kabstract argTypeAbst discr).instantiate1 motiveArg\n    let motiveBody \u2190 mkArrow argTypeAbst motiveBody\n    let us \u2190 if c.propOnly then pure c.us else pure ((\u2190 getLevel motiveBody) :: c.us.tail!)\n    let motive \u2190 mkLambdaFVars motiveArgs motiveBody\n    let remaining := #[arg] ++ c.remaining\n    let aux := mkAppN (mkConst c.declName us) c.params\n    let aux := mkApp aux motive\n    let aux := mkAppN aux discrs\n    check aux\n    unless (\u2190 isTypeCorrect aux) do\n      throwError \"failed to add argument to `casesOn` application, type error when constructing the new motive{indentExpr aux}\"\n    let auxType \u2190 inferType aux\n    let alts \u2190 updateAlts argType auxType\n    return { c with us, motive, alts, remaining }\nwhere\n  updateAlts (argType : Expr) (auxType : Expr) : MetaM (Array Expr) := do\n    let mut auxType := auxType\n    let mut altsNew := #[]\n    let mut refined := false\n    for alt in c.alts, numParams in c.altNumParams do\n      auxType \u2190 whnfD auxType\n      match auxType with\n      | .forallE _ d b _ =>\n        let (altNew, refinedAt) \u2190 forallBoundedTelescope d (some numParams) fun xs d => do\n          forallBoundedTelescope d (some 1) fun x _ => do\n            let alt := alt.beta xs\n            let alt \u2190 mkLambdaFVars x alt if checkIfRefined then\n              return (\u2190 mkLambdaFVars xs alt, !(\u2190 isDefEq argType (\u2190 inferType x[0]!)))\n            else\n              return (\u2190 mkLambdaFVars xs alt, true)\n        if refinedAt then\n          refined := true\n        auxType := b.instantiate1 altNew\n        altsNew := altsNew.push altNew\n      | _ => throwError \"unexpected type at `casesOnAddArg`\"\n    unless refined do\n      throwError \"failed to add argument to `casesOn` application, argument type was not refined by `casesOn`\"\n    return altsNew", "start": [50, 1], "end": [107, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CasesOnApp.addArg?", "code": "def CasesOnApp.addArg? (c : CasesOnApp) (arg : Expr) (checkIfRefined : Bool := false) : MetaM (Option CasesOnApp) :=\n  try\n    return some (\u2190 c.addArg arg checkIfRefined)\n  catch _ =>\n    return none", "start": [109, 1], "end": [114, 16], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Tactic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cleanup.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Constructor.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assert.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Congr.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Generalize.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Induction.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/ElimInfo.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/AuxLemma.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Clear.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/AC.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Contradiction.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/SplitIf.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Unfold.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Rename.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Refl.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Delta.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/LinearArith.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Replace.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Split.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Intro.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Revert.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/IndPredBelow.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Constructions.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/Match.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.IndPredBelow.Context", "code": "structure Context where\n  motives : Array (Name \u00d7 Expr)\n  typeInfos : Array InductiveVal\n  belowNames : Array Name\n  headers : Array Expr\n  numParams : Nat", "start": [18, 1], "end": [26, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.Variables", "code": "structure Variables where\n  target : Array Expr\n  indVal : Array Expr\n  params : Array Expr\n  args : Array Expr\n  motives : Array Expr\n  innerType : Expr\n  deriving Inhabited", "start": [28, 1], "end": [39, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.BrecOnVariables", "code": "structure BrecOnVariables where\n  params : Array FVarId\n  motives : Array FVarId\n  indices : Array FVarId\n  witness : FVarId\n  indHyps : Array FVarId", "start": [41, 1], "end": [49, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.mkContext", "code": "def mkContext (declName : Name) : MetaM Context := do\n  let indVal \u2190 getConstInfoInduct declName\n  let typeInfos \u2190 indVal.all.toArray.mapM getConstInfoInduct\n  let motiveTypes \u2190 typeInfos.mapM motiveType\n  let motives \u2190 motiveTypes.mapIdxM fun j motive =>\n    return (\u2190 motiveName motiveTypes j.val, motive)\n  let headers \u2190 typeInfos.mapM $ mkHeader motives indVal.numParams\n  return {\n    motives := motives\n    typeInfos := typeInfos\n    numParams := indVal.numParams\n    headers := headers\n    belowNames := indVal.all.toArray.map (\u00b7 ++ `below)\n  }\nwhere\n  motiveName (motiveTypes : Array Expr) (i : Nat) : MetaM Name :=\n    if motiveTypes.size > 1\n    then mkFreshUserName s!\"motive_{i.succ}\"\n    else mkFreshUserName \"motive\"\n\n  mkHeader\n      (motives : Array (Name \u00d7 Expr))\n      (numParams : Nat)\n      (indVal : InductiveVal) : MetaM Expr := do\n    let header \u2190 forallTelescopeReducing indVal.type fun xs t => do\n      withNewBinderInfos (xs.map fun x => (x.fvarId!, BinderInfo.implicit)) $\n      mkForallFVars xs (\u2190 mkArrow (mkAppN (mkIndValConst indVal) xs) t)\n    addMotives motives numParams header\n\n  addMotives (motives : Array (Name \u00d7 Expr)) (numParams : Nat) : Expr \u2192 MetaM Expr :=\n    motives.foldrM (fun (motiveName, motive) t =>\n      forallTelescopeReducing t fun xs s => do\n        let motiveType \u2190 instantiateForall motive xs[:numParams]\n        withLocalDecl motiveName BinderInfo.implicit motiveType fun motive => do\n          mkForallFVars (xs.insertAt! numParams motive) s)\n\n  motiveType (indVal : InductiveVal) : MetaM Expr :=\n    forallTelescopeReducing indVal.type fun xs _ => do\n      mkForallFVars xs (\u2190 mkArrow (mkAppN (mkIndValConst indVal) xs) (mkSort levelZero))\n\n  mkIndValConst (indVal : InductiveVal) : Expr :=\n    mkConst indVal.name $ indVal.levelParams.map mkLevelParam", "start": [51, 1], "end": [92, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.mkCtorType", "code": "partial def mkCtorType\n    (ctx : Context)\n    (belowIdx : Nat)\n    (originalCtor : ConstructorVal) : MetaM Expr :=\n  forallTelescopeReducing originalCtor.type fun xs t => addHeaderVars\n    { innerType := t\n      indVal := #[]\n      motives := #[]\n      params := xs[:ctx.numParams]\n      args := xs[ctx.numParams:]\n      target := xs[:ctx.numParams] }\nwhere\n  addHeaderVars (vars : Variables) := do\n    let headersWithNames \u2190 ctx.headers.mapIdxM fun idx header =>\n      return (ctx.belowNames[idx]!, fun _ : Array Expr => pure header)\n\n    withLocalDeclsD headersWithNames fun xs =>\n      addMotives { vars with indVal := xs }\n\n  addMotives (vars : Variables) := do\n    let motiveBuilders \u2190 ctx.motives.mapM fun (motiveName, motiveType) =>\n      return (motiveName, BinderInfo.implicit, fun _ : Array Expr =>\n        instantiateForall motiveType vars.params)\n    withLocalDecls motiveBuilders fun xs =>\n      modifyBinders { vars with target := vars.target ++ xs, motives := xs } 0\n\n  modifyBinders (vars : Variables) (i : Nat) := do\n    if i < vars.args.size then\n      let binder := vars.args[i]!\n      let binderType \u2190 inferType binder\n      if (\u2190 checkCount binderType) then\n        mkBelowBinder vars binder binderType fun indValIdx x =>\n          mkMotiveBinder vars indValIdx binder binderType fun y =>\n            withNewBinderInfos #[(binder.fvarId!, BinderInfo.implicit)] do\n            modifyBinders { vars with target := vars.target ++ #[binder, x, y]} i.succ\n      else modifyBinders { vars with target := vars.target.push binder } i.succ\n    else rebuild vars\n\n  rebuild (vars : Variables) :=\n    vars.innerType.withApp fun _ args => do\n      let hApp :=\n        mkAppN\n          (mkConst originalCtor.name $ ctx.typeInfos[0]!.levelParams.map mkLevelParam)\n          (vars.params ++ vars.args)\n      let innerType := mkAppN vars.indVal[belowIdx]! $\n        vars.params ++ vars.motives ++ args[ctx.numParams:] ++ #[hApp]\n      let x \u2190 mkForallFVars vars.target innerType\n      return replaceTempVars vars x\n\n  replaceTempVars (vars : Variables) (ctor : Expr) :=\n    let levelParams :=\n      ctx.typeInfos[0]!.levelParams.map mkLevelParam\n\n    ctor.replaceFVars vars.indVal $ ctx.belowNames.map fun indVal =>\n      mkConst indVal levelParams\n\n  checkCount (domain : Expr) : MetaM Bool := do\n    let run (x : StateRefT Nat MetaM Expr) : MetaM (Expr \u00d7 Nat) := StateRefT'.run x 0\n    let (_, cnt) \u2190 run <| transform domain fun e => do\n      if let some name := e.constName? then\n        if let some _ := ctx.typeInfos.findIdx? fun indVal => indVal.name == name then\n          modify (\u00b7 + 1)\n      return .continue\n\n    if cnt > 1 then\n      throwError \"only arrows are allowed as premises. Multiple recursive occurrences detected:{indentExpr domain}\"\n\n    return cnt == 1\n\n  mkBelowBinder\n      (vars : Variables)\n      (binder : Expr)\n      (domain : Expr)\n      {\u03b1 : Type} (k : Nat \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n    forallTelescopeReducing domain fun xs t => do\n      let fail _ := do\n        throwError \"only trivial inductive applications supported in premises:{indentExpr t}\"\n\n      t.withApp fun f args => do\n        if let some name := f.constName? then\n          if let some idx := ctx.typeInfos.findIdx?\n            fun indVal => indVal.name == name then\n            let hApp := mkAppN binder xs\n            let t :=\n              mkAppN vars.indVal[idx]! $\n                vars.params ++ vars.motives ++ args[ctx.numParams:] ++ #[hApp]\n            let newDomain \u2190 mkForallFVars xs t\n\n            withLocalDecl (\u2190copyVarName binder.fvarId!) binder.binderInfo newDomain (k idx)\n          else fail ()\n        else fail ()\n\n  mkMotiveBinder\n      (vars : Variables)\n      (indValIdx : Nat)\n      (binder : Expr)\n      (domain : Expr)\n      {\u03b1 : Type} (k : Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n    forallTelescopeReducing domain fun xs t => do\n      t.withApp fun _ args => do\n        let hApp := mkAppN binder xs\n        let t := mkAppN vars.motives[indValIdx]! $ args[ctx.numParams:] ++ #[hApp]\n        let newDomain \u2190 mkForallFVars xs t\n\n        withLocalDecl (\u2190copyVarName binder.fvarId!) binder.binderInfo newDomain k\n\n  copyVarName (oldName : FVarId) : MetaM Name := do\n    let binderDecl \u2190 oldName.getDecl\n    mkFreshUserName binderDecl.userName", "start": [94, 1], "end": [202, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.mkConstructor", "code": "def mkConstructor (ctx : Context) (i : Nat) (ctor : Name) : MetaM Constructor := do\n  let ctorInfo \u2190 getConstInfoCtor ctor\n  let name := ctor.updatePrefix ctx.belowNames[i]!\n  let type \u2190 mkCtorType ctx i ctorInfo\n  return {\n    name := name\n    type := type }", "start": [204, 1], "end": [210, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.mkInductiveType", "code": "def mkInductiveType\n    (ctx : Context)\n    (i : Fin ctx.typeInfos.size)\n    (indVal : InductiveVal) : MetaM InductiveType := do\n  return {\n    name := ctx.belowNames[i]!\n    type := ctx.headers[i]!\n    ctors := (\u2190 indVal.ctors.mapM (mkConstructor ctx i))\n  }", "start": [212, 1], "end": [220, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.mkBelowDecl", "code": "def mkBelowDecl (ctx : Context) : MetaM Declaration := do\n  let lparams := ctx.typeInfos[0]!.levelParams\n  return Declaration.inductDecl\n    lparams\n    (ctx.numParams + ctx.motives.size)\n    (\u2190ctx.typeInfos.mapIdxM $ mkInductiveType ctx).toList\n    ctx.typeInfos[0]!.isUnsafe", "start": [222, 1], "end": [228, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.backwardsChaining", "code": "partial def backwardsChaining (m : MVarId) (depth : Nat) : MetaM Bool := do\n  if depth = 0 then return false\n  else\n    m.withContext do\n    let lctx \u2190 getLCtx\n    let mTy \u2190 m.getType\n    lctx.anyM fun localDecl =>\n      if localDecl.isAuxDecl then\n        return false\n      else\n        commitWhen do\n        let (mvars, _, t) \u2190 forallMetaTelescope localDecl.type\n        if \u2190isDefEq mTy t then\n          m.assign (mkAppN localDecl.toExpr mvars)\n          mvars.allM fun v =>\n            v.mvarId!.isAssigned <||> backwardsChaining v.mvarId! (depth - 1)\n        else return false", "start": [230, 1], "end": [246, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.proveBrecOn", "code": "partial def proveBrecOn (ctx : Context) (indVal : InductiveVal) (type : Expr) : MetaM Expr := do\n  let main \u2190 mkFreshExprSyntheticOpaqueMVar type\n  let (m, vars) \u2190 intros main.mvarId!\n  let [m] \u2190 applyIH m vars |\n    throwError \"applying the induction hypothesis should only return one goal\"\n  let ms \u2190 induction m vars\n  let ms \u2190 applyCtors ms\n  let maxDepth := maxBackwardChainingDepth.get $ \u2190getOptions\n  ms.forM (closeGoal maxDepth)\n  instantiateMVars main\nwhere\n  intros (m : MVarId) : MetaM (MVarId \u00d7 BrecOnVariables) := do\n    let (params, m) \u2190 m.introNP indVal.numParams\n    let (motives, m) \u2190 m.introNP ctx.motives.size\n    let (indices, m) \u2190 m.introNP indVal.numIndices\n    let (witness, m) \u2190 m.intro1P\n    let (indHyps, m) \u2190 m.introNP ctx.motives.size\n    return (m, \u27e8params, motives, indices, witness, indHyps\u27e9)\n\n  applyIH (m : MVarId) (vars : BrecOnVariables) : MetaM (List MVarId) := do\n    match (\u2190 vars.indHyps.findSomeM?\n      fun ih => do try pure <| some <| (\u2190 m.apply <| mkFVar ih) catch _ => pure none) with\n    | some goals => pure goals\n    | none => throwError \"cannot apply induction hypothesis: {MessageData.ofGoal m}\"\n\n  induction (m : MVarId) (vars : BrecOnVariables) : MetaM (List MVarId) := do\n    let params := vars.params.map mkFVar\n    let motives := vars.motives.map mkFVar\n    let levelParams := indVal.levelParams.map mkLevelParam\n    let motives \u2190 ctx.motives.mapIdxM fun idx (_, motive) => do\n      let motive \u2190 instantiateForall motive params\n      forallTelescopeReducing motive fun xs _ => do\n      mkLambdaFVars xs <| mkAppN (mkConst ctx.belowNames[idx]! levelParams) $ (params ++ motives ++ xs)\n    let recursorInfo \u2190 getConstInfo $ mkRecName indVal.name\n    let recLevels :=\n      if recursorInfo.numLevelParams > levelParams.length\n      then levelZero::levelParams\n      else levelParams\n    let recursor := mkAppN (mkConst recursorInfo.name $ recLevels) $ params ++ motives\n    m.apply recursor\n\n  applyCtors (ms : List MVarId) : MetaM $ List MVarId := do\n    let mss \u2190 ms.toArray.mapIdxM fun _ m => do\n      let m \u2190 introNPRec m\n      (\u2190 m.getType).withApp fun below args =>\n      m.withContext do\n        args.back.withApp fun ctor _ => do\n        let ctorName := ctor.constName!.updatePrefix below.constName!\n        let ctor := mkConst ctorName below.constLevels!\n        let ctorInfo \u2190 getConstInfoCtor ctorName\n        let (mvars, _, _) \u2190 forallMetaTelescope ctorInfo.type\n        let ctor := mkAppN ctor mvars\n        m.apply ctor\n    return mss.foldr List.append []\n\n  introNPRec (m : MVarId) : MetaM MVarId := do\n    if (\u2190 m.getType).isForall then introNPRec (\u2190 m.intro1P).2 else return m\n\n  closeGoal (maxDepth : Nat) (m : MVarId) : MetaM Unit := do\n    unless (\u2190 m.isAssigned) do\n      let m \u2190 introNPRec m\n      unless (\u2190 backwardsChaining m maxDepth) do\n        m.withContext do\n        throwError \"couldn't solve by backwards chaining ({``maxBackwardChainingDepth} = {maxDepth}): {MessageData.ofGoal m}\"", "start": [248, 1], "end": [311, 126], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.mkBrecOnDecl", "code": "def mkBrecOnDecl (ctx : Context) (idx : Nat) : MetaM Declaration := do\n  let type \u2190 mkType\n  let indVal := ctx.typeInfos[idx]!\n  let name := indVal.name ++ brecOnSuffix\n  return Declaration.thmDecl {\n    name := name\n    levelParams := indVal.levelParams\n    type := type\n    value := \u2190proveBrecOn ctx indVal type }\nwhere\n  mkType : MetaM Expr :=\n    forallTelescopeReducing ctx.headers[idx]! fun xs _ => do\n    let params := xs[:ctx.numParams]\n    let motives := xs[ctx.numParams:ctx.numParams + ctx.motives.size].toArray\n    let indices := xs[ctx.numParams + ctx.motives.size:]\n    let motiveBinders \u2190 ctx.motives.mapIdxM $ mkIH params motives\n    withLocalDeclsD motiveBinders fun ys => do\n    mkForallFVars (xs ++ ys) (mkAppN motives[idx]! indices)\n  mkIH\n      (params : Array Expr)\n      (motives : Array Expr)\n      (idx : Fin ctx.motives.size)\n      (motive : Name \u00d7 Expr) : MetaM $ Name \u00d7 (Array Expr \u2192 MetaM Expr) := do\n    let name :=\n      if ctx.motives.size > 1\n      then mkFreshUserName s!\"ih_{idx.val.succ}\"\n      else mkFreshUserName \"ih\"\n    let ih \u2190 instantiateForall motive.2 params\n    let mkDomain (_ : Array Expr) : MetaM Expr :=\n      forallTelescopeReducing ih fun ys _ => do\n        let levels := ctx.typeInfos[idx]!.levelParams.map mkLevelParam\n        let args := params ++ motives ++ ys\n        let premise :=\n          mkAppN\n            (mkConst ctx.belowNames[idx.val]! levels) args\n        let conclusion :=\n          mkAppN motives[idx]! ys\n        mkForallFVars ys (\u2190mkArrow premise conclusion)\n    return (\u2190name, mkDomain)", "start": [313, 1], "end": [351, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.getBelowIndices", "code": "partial def getBelowIndices (ctorName : Name) : MetaM $ Array Nat := do\n  let ctorInfo \u2190 getConstInfoCtor ctorName\n  let belowCtorInfo \u2190 getConstInfoCtor (ctorName.updatePrefix $ ctorInfo.induct ++ `below)\n  forallTelescopeReducing ctorInfo.type fun xs _ => do\n  loop xs belowCtorInfo.type #[] 0 0\n\nwhere\n  loop\n      (xs : Array Expr)\n      (rest : Expr)\n      (belowIndices : Array Nat)\n      (xIdx yIdx : Nat) : MetaM $ Array Nat := do\n    if xIdx \u2265 xs.size then return belowIndices else\n    let x := xs[xIdx]!\n    let xTy \u2190 inferType x\n    let yTy := rest.bindingDomain!\n    if (\u2190 isDefEq xTy yTy) then\n      let rest \u2190 instantiateForall rest #[x]\n      loop xs rest (belowIndices.push yIdx) (xIdx + 1) (yIdx + 1)\n    else\n      forallBoundedTelescope rest (some 1) fun _ rest =>\n      loop xs rest belowIndices xIdx (yIdx + 1)", "start": [353, 1], "end": [375, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.belowType", "code": "private def belowType (motive : Expr) (xs : Array Expr) (idx : Nat) : MetaM $ Name \u00d7 Expr := do\n  (\u2190 inferType xs[idx]!).withApp fun type args => do\n    let indName := type.constName!\n    let indInfo \u2190 getConstInfoInduct indName\n    let belowArgs := args[:indInfo.numParams] ++ #[motive] ++ args[indInfo.numParams:] ++ #[xs[idx]!]\n    let belowType := mkAppN (mkConst (indName ++ `below) type.constLevels!) belowArgs\n    return (indName, belowType)", "start": [377, 1], "end": [383, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.mkBelowMatcher", "code": "partial def mkBelowMatcher\n    (matcherApp : MatcherApp)\n    (belowMotive : Expr)\n    (below : Expr)\n    (idx : Nat) : MetaM $ Expr \u00d7 MetaM Unit := do\n  let mkMatcherInput \u2190 getMkMatcherInputInContext matcherApp\n  let (indName, _, motive, matchType) \u2190\n    forallBoundedTelescope mkMatcherInput.matchType mkMatcherInput.numDiscrs fun xs t => do\n    let (indName, belowType) \u2190 belowType belowMotive xs idx\n    let matchType \u2190\n      withLocalDeclD (\u2190mkFreshUserName `h_below) belowType fun h_below => do\n      mkForallFVars (xs.push h_below) t\n    let motive \u2190 newMotive belowType xs\n    pure (indName, belowType.replaceFVars xs matcherApp.discrs, motive, matchType)\n\n  let lhss \u2190 mkMatcherInput.lhss.mapM <| addBelowPattern indName\n  let alts \u2190 mkMatcherInput.lhss.zip lhss |>.toArray.zip matcherApp.alts |>.mapIdxM fun idx ((oldLhs, lhs), alt) => do\n    withExistingLocalDecls (oldLhs.fvarDecls ++ lhs.fvarDecls) do\n    lambdaTelescope alt fun xs t => do\n    let oldFVars := oldLhs.fvarDecls.toArray\n    let fvars := lhs.fvarDecls.toArray.map (\u00b7.toExpr)\n    let xs :=\n      match oldFVars.size, fvars.size with\n      | 0, _+1 => xs[1:]\n      | _, _ => xs\n    let t := t.replaceFVars xs[:oldFVars.size] fvars[:oldFVars.size]\n    trace[Meta.IndPredBelow.match] \"xs = {xs}; oldFVars = {oldFVars.map (\u00b7.toExpr)}; fvars = {fvars}; new = {fvars[:oldFVars.size] ++ xs[oldFVars.size:] ++ fvars[oldFVars.size:]}\"\n    let newAlt \u2190 mkLambdaFVars (fvars[:oldFVars.size] ++ xs[oldFVars.size:] ++ fvars[oldFVars.size:]) t\n    trace[Meta.IndPredBelow.match] \"alt {idx}:\\n{alt} \u21a6 {newAlt}\"\n    pure newAlt\n\n  let matcherName \u2190 mkFreshUserName mkMatcherInput.matcherName\n  withExistingLocalDecls (lhss.foldl (init := []) fun s v => s ++ v.fvarDecls) do\n    for lhs in lhss do\n      trace[Meta.IndPredBelow.match] \"{lhs.patterns.map (\u00b7.toMessageData)}\"\n  let res \u2190 Match.mkMatcher { matcherName, matchType, discrInfos := mkArray (mkMatcherInput.numDiscrs + 1) {}, lhss }\n  res.addMatcher\n  check res.matcher\n  let newApp := mkApp res.matcher motive\n  let newApp := mkAppN newApp <| matcherApp.discrs.push below\n  let newApp := mkAppN newApp alts\n  return (newApp, res.addMatcher)\n\nwhere\n  addBelowPattern (indName : Name) (lhs : AltLHS) : MetaM AltLHS := do\n    withExistingLocalDecls lhs.fvarDecls do\n    let patterns := lhs.patterns.toArray\n    let originalPattern := patterns[idx]!\n    let (fVars, belowPattern) \u2190 convertToBelow indName patterns[idx]!\n    withExistingLocalDecls fVars.toList do\n    let patterns := patterns.push belowPattern\n    let patterns := patterns.set! idx (\u2190toInaccessible originalPattern)\n    return { lhs with patterns := patterns.toList, fvarDecls := lhs.fvarDecls ++ fVars.toList }\n\n  \n  convertToBelow (indName : Name)\n      (originalPattern : Pattern) : MetaM $ Array LocalDecl \u00d7 Pattern := do\n    match originalPattern with\n    | Pattern.ctor ctorName us params fields =>\n      let ctorInfo \u2190 getConstInfoCtor ctorName\n\n      let belowCtor \u2190 getConstInfoCtor $ ctorName.updatePrefix $ ctorInfo.induct ++ `below\n      let belowIndices \u2190 IndPredBelow.getBelowIndices ctorName\n      let belowIndices := belowIndices[ctorInfo.numParams:].toArray.map (\u00b7 - belowCtor.numParams)\n\n      let mut belowFieldOpts := mkArray belowCtor.numFields none\n      let fields := fields.toArray\n      for fieldIdx in [:fields.size] do\n        belowFieldOpts := belowFieldOpts.set! belowIndices[fieldIdx]! (some fields[fieldIdx]!)\n\n      let belowParams := params.toArray.push belowMotive\n      let belowCtorExpr := mkAppN (mkConst belowCtor.name us) belowParams\n      let (additionalFVars, belowFields) \u2190 transformFields belowCtorExpr indName belowFieldOpts\n\n      withExistingLocalDecls additionalFVars.toList do\n      let ctor := Pattern.ctor belowCtor.name us belowParams.toList belowFields.toList\n      trace[Meta.IndPredBelow.match] \"{originalPattern.toMessageData} \u21a6 {ctor.toMessageData}\"\n      return (additionalFVars, ctor)\n    | Pattern.as varId p hId =>\n      let (additionalFVars, p) \u2190 convertToBelow indName p\n      return (additionalFVars, Pattern.as varId p hId)\n    | Pattern.var varId =>\n      let var := mkFVar varId\n      let (_, tgtType) \u2190 belowType belowMotive #[var] 0\n      withLocalDeclD (\u2190mkFreshUserName `h) tgtType fun h => do\n      let localDecl \u2190 getFVarLocalDecl h\n      return (#[localDecl], Pattern.var h.fvarId!)\n    | p => return (#[], p)\n\n  transformFields belowCtor indName belowFieldOpts :=\n    let rec loop\n      (belowCtor : Expr)\n      (belowFieldOpts : Array $ Option Pattern)\n      (belowFields : Array Pattern)\n      (additionalFVars : Array LocalDecl) : MetaM (Array LocalDecl \u00d7 Array Pattern) := do\n      if belowFields.size \u2265 belowFieldOpts.size then pure (additionalFVars, belowFields) else\n      if let some belowField := belowFieldOpts[belowFields.size]! then\n        let belowFieldExpr \u2190 belowField.toExpr\n        let belowCtor := mkApp belowCtor belowFieldExpr\n        let patTy \u2190 inferType belowFieldExpr\n        patTy.withApp fun f _ => do\n        let constName := f.constName?\n        if constName == indName then\n          let (fvars, transformedField) \u2190 convertToBelow indName belowField\n          withExistingLocalDecls fvars.toList do\n          let belowFieldOpts := belowFieldOpts.set! (belowFields.size + 1) transformedField\n          let belowField :=\n            match belowField with\n            | Pattern.ctor .. => Pattern.inaccessible belowFieldExpr\n            | _ => belowField\n          loop belowCtor belowFieldOpts (belowFields.push belowField) (additionalFVars ++ fvars)\n        else\n          loop belowCtor belowFieldOpts (belowFields.push belowField) additionalFVars\n      else\n        let ctorType \u2190 inferType belowCtor\n        withLocalDeclD (\u2190mkFreshUserName `a) ctorType.bindingDomain! fun a => do\n        let localDecl \u2190 getFVarLocalDecl a\n        loop (mkApp belowCtor a) belowFieldOpts (belowFields.push $ Pattern.var a.fvarId!) (additionalFVars.push localDecl)\n    loop belowCtor belowFieldOpts #[] #[]\n\n  toInaccessible : Pattern \u2192 MetaM Pattern\n  | Pattern.inaccessible p => return Pattern.inaccessible p\n  | Pattern.var v => return Pattern.var v\n  | p => return Pattern.inaccessible $ \u2190p.toExpr\n\n  newMotive (belowType : Expr) (ys : Array Expr) : MetaM Expr :=\n    lambdaTelescope matcherApp.motive fun xs t => do\n    let numDiscrs := matcherApp.discrs.size\n    withLocalDeclD (\u2190mkFreshUserName `h_below) (belowType.replaceFVars ys xs) fun h_below => do\n    let motive \u2190 mkLambdaFVars (xs[:numDiscrs] ++ #[h_below] ++ xs[numDiscrs:]) t\n    trace[Meta.IndPredBelow.match] \"motive := {motive}\"\n    return motive", "start": [385, 1], "end": [551, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.findBelowIdx", "code": "def findBelowIdx (xs : Array Expr) (motive : Expr) : MetaM $ Option (Expr \u00d7 Nat) := do\n  xs.findSomeM? fun x => do\n  let xTy \u2190 inferType x\n  xTy.withApp fun f _ =>\n  match f.constName?, xs.indexOf? x with\n  | some name, some idx => do\n    if (\u2190 isInductivePredicate name) then\n      let (_, belowTy) \u2190 belowType motive xs idx\n      let below \u2190 mkFreshExprSyntheticOpaqueMVar belowTy\n      try\n        trace[Meta.IndPredBelow.match] \"{\u2190Meta.ppGoal below.mvarId!}\"\n        if (\u2190 backwardsChaining below.mvarId! 10) then\n          trace[Meta.IndPredBelow.match] \"Found below term in the local context: {below}\"\n          if (\u2190 xs.anyM (isDefEq below)) then pure none else pure (below, idx.val)\n        else\n          trace[Meta.IndPredBelow.match] \"could not find below term in the local context\"\n          pure none\n      catch _ => pure none\n    else pure none\n  | _, _ => pure none", "start": [553, 1], "end": [572, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.IndPredBelow.mkBelow", "code": "def mkBelow (declName : Name) : MetaM Unit := do\n  if (\u2190 isInductivePredicate declName) then\n    let x \u2190 getConstInfoInduct declName\n    if x.isRec && !x.isNested then\n      let ctx \u2190 IndPredBelow.mkContext declName\n      let decl \u2190 IndPredBelow.mkBelowDecl ctx\n      addDecl decl\n      trace[Meta.IndPredBelow] \"added {ctx.belowNames}\"\n      ctx.belowNames.forM Lean.mkCasesOn\n      for i in [:ctx.typeInfos.size] do\n        try\n          let decl \u2190 IndPredBelow.mkBrecOnDecl ctx i\n          addDecl decl\n        catch e => trace[Meta.IndPredBelow] \"failed to prove brecOn for {ctx.belowNames[i]!}\\n{e.toMessageData}\"\n    else trace[Meta.IndPredBelow] \"Nested or not recursive\"\n  else trace[Meta.IndPredBelow] \"Not inductive predicate\"", "start": [574, 1], "end": [592, 58], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Match.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Match/CaseArraySizes.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/Match.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatchPatternAttr.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/CaseValues.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match/MatchEqs.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/ExprDefEq.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Offset.lean", "lake-packages/lean4/src/lean/Lean/Util/OccursCheck.lean", "lake-packages/lean4/src/lean/Lean/Meta/UnificationHint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.isAbstractedUnassignedMVar", "code": "def isAbstractedUnassignedMVar : Expr \u2192 MetaM Bool\n  | .lam _ _ b _ => isAbstractedUnassignedMVar b\n  | .app a _ => isAbstractedUnassignedMVar a\n  | .mvar mvarId => do\n    if (\u2190 mvarId.isReadOnlyOrSyntheticOpaque) then\n      pure false\n    else if (\u2190 mvarId.isAssigned) then\n      pure false\n    else\n      pure true\n  | _ => pure false", "start": [12, 1], "end": [31, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqEtaStruct", "code": "private def isDefEqEtaStruct (a b : Expr) : MetaM Bool := do\n  matchConstCtor b.getAppFn (fun _ => return false) fun ctorVal us => do\n    if (\u2190 useEtaStruct ctorVal.induct) then\n      matchConstCtor a.getAppFn (fun _ => go ctorVal us) fun _ _ => return false\n    else\n      return false\nwhere\n  go ctorVal us := do\n    if ctorVal.numParams + ctorVal.numFields != b.getAppNumArgs then\n      trace[Meta.isDefEq.eta.struct] \"failed, insufficient number of arguments at{indentExpr b}\"\n      return false\n    else\n      if !isStructureLike (\u2190 getEnv) ctorVal.induct then\n        trace[Meta.isDefEq.eta.struct] \"failed, type is not a structure{indentExpr b}\"\n        return false\n      else if (\u2190 isDefEq (\u2190 inferType a) (\u2190 inferType b)) then\n        checkpointDefEq do\n          let args := b.getAppArgs\n          let params := args[:ctorVal.numParams].toArray\n          for i in [ctorVal.numParams : args.size] do\n            let j := i - ctorVal.numParams\n            let proj \u2190 mkProjFn ctorVal us params j a\n            if \u2190 isProof proj then\n              unless \u2190 isAbstractedUnassignedMVar args[i]! do\n                continue\n            trace[Meta.isDefEq.eta.struct] \"{a} =?= {b} @ [{j}], {proj} =?= {args[i]!}\"\n            unless (\u2190 isDefEq proj args[i]!) do\n              trace[Meta.isDefEq.eta.struct] \"failed, unexpect arg #{i}, projection{indentExpr proj}\\nis not defeq to{indentExpr args[i]!}\"\n              return false\n          return true\n      else\n        return false", "start": [33, 1], "end": [86, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqEta", "code": "private def isDefEqEta (a b : Expr) : MetaM LBool := do\n  if a.isLambda && !b.isLambda then\n    let bType \u2190 inferType b\n    let bType \u2190 whnfD bType\n    match bType with\n    | Expr.forallE n d _ c =>\n      let b' := mkLambda n c d (mkApp b (mkBVar 0))\n      toLBoolM <| checkpointDefEq <| Meta.isExprDefEqAux a b'\n    | _ => return .undef\n  else\n    return .undef", "start": [88, 1], "end": [115, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqNative", "code": "def isDefEqNative (s t : Expr) : MetaM LBool := do\n  let isDefEq (s t) : MetaM LBool := toLBoolM <| Meta.isExprDefEqAux s t\n  let s? \u2190 reduceNative? s\n  let t? \u2190 reduceNative? t\n  match s?, t? with\n  | some s, some t => isDefEq s t\n  | some s, none   => isDefEq s t\n  | none,   some t => isDefEq s t\n  | none,   none   => pure LBool.undef", "start": [117, 1], "end": [126, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqNat", "code": "def isDefEqNat (s t : Expr) : MetaM LBool := do\n  let isDefEq (s t) : MetaM LBool := toLBoolM <| Meta.isExprDefEqAux s t\n  if s.hasFVar || s.hasMVar || t.hasFVar || t.hasMVar then\n    pure LBool.undef\n  else\n    let s? \u2190 reduceNat? s\n    let t? \u2190 reduceNat? t\n    match s?, t? with\n    | some s, some t => isDefEq s t\n    | some s, none   => isDefEq s t\n    | none,   some t => isDefEq s t\n    | none,   none   => pure LBool.undef", "start": [128, 1], "end": [140, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqStringLit", "code": "def isDefEqStringLit (s t : Expr) : MetaM LBool := do\n  let isDefEq (s t) : MetaM LBool := toLBoolM <| Meta.isExprDefEqAux s t\n  if s.isStringLit && t.isAppOf ``String.mk then\n    isDefEq s.toCtorIfLit t\n  else if s.isAppOf `String.mk && t.isStringLit then\n    isDefEq s t.toCtorIfLit\n  else\n    pure LBool.undef", "start": [142, 1], "end": [150, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isEtaUnassignedMVar", "code": "def isEtaUnassignedMVar (e : Expr) : MetaM Bool := do\n  match e.etaExpanded? with\n  | some (Expr.mvar mvarId) =>\n    if (\u2190 mvarId.isReadOnlyOrSyntheticOpaque) then\n      pure false\n    else if (\u2190 mvarId.isAssigned) then\n      pure false\n    else\n      pure true\n  | _   => pure false", "start": [152, 1], "end": [164, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.trySynthPending", "code": "private def trySynthPending (e : Expr) : MetaM Bool := do\n  let mvarId? \u2190 getStuckMVar? e\n  match mvarId? with\n  | some mvarId => Meta.synthPending mvarId\n  | none        => pure false", "start": [166, 1], "end": [170, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DefEqArgsFirstPassResult", "code": "inductive DefEqArgsFirstPassResult where\n  \n  | failed\n  \n  | ok (postponedImplicit : Array Nat) (postponedHO : Array Nat)", "start": [172, 1], "end": [208, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqArgsFirstPass", "code": "private def isDefEqArgsFirstPass\n    (paramInfo : Array ParamInfo) (args\u2081 args\u2082 : Array Expr) : MetaM DefEqArgsFirstPassResult := do\n  let mut postponedImplicit := #[]\n  let mut postponedHO := #[]\n  for i in [:paramInfo.size] do\n    let info := paramInfo[i]!\n    let a\u2081 := args\u2081[i]!\n    let a\u2082 := args\u2082[i]!\n    if info.dependsOnHigherOrderOutParam || info.higherOrderOutParam then\n      trace[Meta.isDefEq] \"found messy {a\u2081} =?= {a\u2082}\"\n      postponedHO := postponedHO.push i\n    else if info.isExplicit then\n      if info.isProp then\n        unless \u2190 isAbstractedUnassignedMVar a\u2081 <||> isAbstractedUnassignedMVar a\u2082 do\n          continue\n      unless (\u2190 Meta.isExprDefEqAux a\u2081 a\u2082) do\n        return .failed\n    else if (\u2190 isEtaUnassignedMVar a\u2081 <||> isEtaUnassignedMVar a\u2082) then\n      unless (\u2190 Meta.isExprDefEqAux a\u2081 a\u2082) do\n        return .failed\n    else\n      if info.isProp then\n        unless \u2190 isAbstractedUnassignedMVar a\u2081 <||> isAbstractedUnassignedMVar a\u2082 do\n          continue\n      postponedImplicit := postponedImplicit.push i\n  return .ok postponedImplicit postponedHO", "start": [210, 1], "end": [274, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqArgs", "code": "private partial def isDefEqArgs (f : Expr) (args\u2081 args\u2082 : Array Expr) : MetaM Bool := do\n  unless args\u2081.size == args\u2082.size do return false\n  let finfo \u2190 getFunInfoNArgs f args\u2081.size\n  let .ok postponedImplicit postponedHO \u2190 isDefEqArgsFirstPass finfo.paramInfo args\u2081 args\u2082 | pure false\n  for i in [finfo.paramInfo.size:args\u2081.size] do\n    unless (\u2190 Meta.isExprDefEqAux args\u2081[i]! args\u2082[i]!) do\n      return false\n  for i in postponedImplicit do\n    \n    let a\u2081   := args\u2081[i]!\n    let a\u2082   := args\u2082[i]!\n    let info := finfo.paramInfo[i]!\n    if info.isInstImplicit then\n      discard <| trySynthPending a\u2081\n      discard <| trySynthPending a\u2082\n    unless (\u2190 withAtLeastTransparency TransparencyMode.default <| Meta.isExprDefEqAux a\u2081 a\u2082) do\n      return false\n  for i in postponedHO do\n    let a\u2081   := args\u2081[i]!\n    let a\u2082   := args\u2082[i]!\n    let info := finfo.paramInfo[i]!\n    if info.isInstImplicit then\n      unless (\u2190 withAtLeastTransparency TransparencyMode.default <| Meta.isExprDefEqAux a\u2081 a\u2082) do\n       return false\n    else\n      unless (\u2190 Meta.isExprDefEqAux a\u2081 a\u2082) do\n        return false\n  return true", "start": [276, 1], "end": [306, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqBindingDomain", "code": "@[specialize] partial def isDefEqBindingDomain (fvars : Array Expr) (ds\u2082 : Array Expr) (k : MetaM Bool) : MetaM Bool :=\n  let rec loop (i : Nat) := do\n    if h : i < fvars.size then do\n      let fvar := fvars.get \u27e8i, h\u27e9\n      let fvarDecl \u2190 getFVarLocalDecl fvar\n      let fvarType := fvarDecl.type\n      let d\u2082       := ds\u2082[i]!\n      if (\u2190 Meta.isExprDefEqAux fvarType d\u2082) then\n        match (\u2190 isClass? fvarType) with\n        | some className => withNewLocalInstance className fvar <| loop (i+1)\n        | none           => loop (i+1)\n      else\n        pure false\n    else\n      k\n  loop 0", "start": [308, 1], "end": [334, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqBindingAux", "code": "private partial def isDefEqBindingAux (lctx : LocalContext) (fvars : Array Expr) (e\u2081 e\u2082 : Expr) (ds\u2082 : Array Expr) : MetaM Bool :=\n  let process (n : Name) (d\u2081 d\u2082 b\u2081 b\u2082 : Expr) : MetaM Bool := do\n    let d\u2081     := d\u2081.instantiateRev fvars\n    let d\u2082     := d\u2082.instantiateRev fvars\n    let fvarId \u2190 mkFreshFVarId\n    let lctx   := lctx.mkLocalDecl fvarId n d\u2081\n    let fvars  := fvars.push (mkFVar fvarId)\n    isDefEqBindingAux lctx fvars b\u2081 b\u2082 (ds\u2082.push d\u2082)\n  match e\u2081, e\u2082 with\n  | Expr.forallE n d\u2081 b\u2081 _, Expr.forallE _ d\u2082 b\u2082 _ => process n d\u2081 d\u2082 b\u2081 b\u2082\n  | Expr.lam     n d\u2081 b\u2081 _, Expr.lam     _ d\u2082 b\u2082 _ => process n d\u2081 d\u2082 b\u2081 b\u2082\n  | _,                      _                      =>\n    withReader (fun ctx => { ctx with lctx := lctx }) do\n      isDefEqBindingDomain fvars ds\u2082 do\n        Meta.isExprDefEqAux (e\u2081.instantiateRev fvars) (e\u2082.instantiateRev fvars)", "start": [336, 1], "end": [354, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqBinding", "code": "@[inline] private def isDefEqBinding (a b : Expr) : MetaM Bool := do\n  let lctx \u2190 getLCtx\n  isDefEqBindingAux lctx #[] a b #[]", "start": [356, 1], "end": [358, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkTypesAndAssign", "code": "private def checkTypesAndAssign (mvar : Expr) (v : Expr) : MetaM Bool :=\n  withTraceNodeBefore `Meta.isDefEq.assign.checkTypes (return m!\"({mvar} : {\u2190 inferType mvar}) := ({v} : {\u2190 inferType v})\") do\n    if !mvar.isMVar then\n      trace[Meta.isDefEq.assign.checkTypes] \"metavariable expected\"\n      return false\n    else\n      let mvarType \u2190 inferType mvar\n      let vType \u2190 inferType v\n      if (\u2190 withTransparency TransparencyMode.default <| Meta.isExprDefEqAux mvarType vType) then\n        mvar.mvarId!.assign v\n        pure true\n      else\n        pure false", "start": [360, 1], "end": [373, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkLambdaFVarsWithLetDeps", "code": "private partial def mkLambdaFVarsWithLetDeps (xs : Array Expr) (v : Expr) : MetaM (Option Expr) := do\n  if not (\u2190 hasLetDeclsInBetween) then\n    mkLambdaFVars xs v\n  else\n    let ys \u2190 addLetDeps\n    mkLambdaFVars ys v\n\nwhere\n  \n  hasLetDeclsInBetween : MetaM Bool := do\n    let check (lctx : LocalContext) : Bool := Id.run do\n      let start := lctx.getFVar! xs[0]! |>.index\n      let stop  := lctx.getFVar! xs.back |>.index\n      for i in [start+1:stop] do\n        match lctx.getAt? i with\n        | some localDecl =>\n          if localDecl.isLet then\n            return true\n        | _ => pure ()\n      return false\n    if xs.size <= 1 then\n      return false\n    else\n      return check (\u2190 getLCtx)\n\n  \n  collectLetDeclsFrom (e : Expr) : ReaderT Nat (StateRefT FVarIdHashSet MetaM) Unit := do\n    let rec visit (e : Expr) : MonadCacheT Expr Unit (ReaderT Nat (StateRefT FVarIdHashSet MetaM)) Unit :=\n      checkCache e fun _ => do\n        match e with\n        | Expr.forallE _ d b _   => visit d; visit b\n        | Expr.lam _ d b _       => visit d; visit b\n        | Expr.letE _ t v b _    => visit t; visit v; visit b\n        | Expr.app f a           => visit f; visit a\n        | Expr.mdata _ b         => visit b\n        | Expr.proj _ _ b        => visit b\n        | Expr.fvar fvarId       =>\n          let localDecl \u2190 fvarId.getDecl\n          if localDecl.isLet && localDecl.index > (\u2190 read) then\n            modify fun s => s.insert localDecl.fvarId\n        | _ => pure ()\n    visit (\u2190 instantiateMVars e) |>.run\n\n  \n  collectLetDepsAux : Nat \u2192 ReaderT Nat (StateRefT FVarIdHashSet MetaM) Unit\n    | 0   => return ()\n    | i+1 => do\n      if i+1 == (\u2190 read) then\n        return ()\n      else\n        match (\u2190 getLCtx).getAt? (i+1) with\n        | none => collectLetDepsAux i\n        | some localDecl =>\n          if (\u2190 get).contains localDecl.fvarId then\n            collectLetDeclsFrom localDecl.type\n            match localDecl.value? with\n            | some val => collectLetDeclsFrom val\n            | _ =>  pure ()\n          collectLetDepsAux i\n\n  \n  collectLetDeps : MetaM FVarIdHashSet := do\n    let lctx \u2190 getLCtx\n    let start := lctx.getFVar! xs[0]! |>.index\n    let stop  := lctx.getFVar! xs.back |>.index\n    let s := xs.foldl (init := {}) fun s x => s.insert x.fvarId!\n    let (_, s) \u2190 collectLetDepsAux stop |>.run start |>.run s\n    return s\n\n  \n  addLetDeps : MetaM (Array Expr) := do\n    let lctx \u2190 getLCtx\n    let s \u2190 collectLetDeps\n    \n    let start := lctx.getFVar! xs[0]! |>.index\n    let stop  := lctx.getFVar! xs.back |>.index\n    let mut ys := #[]\n    for i in [start:stop+1] do\n      match lctx.getAt? i with\n      | none => pure ()\n      | some localDecl =>\n        if s.contains localDecl.fvarId then\n          ys := ys.push localDecl.toExpr\n    return ys", "start": [375, 1], "end": [496, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkAuxMVar", "code": "def mkAuxMVar (lctx : LocalContext) (localInsts : LocalInstances) (type : Expr) (numScopeArgs : Nat := 0) : MetaM Expr := do\n  mkFreshExprMVarAt lctx localInsts type MetavarKind.natural Name.anonymous numScopeArgs", "start": [656, 1], "end": [657, 89], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.State", "code": "structure State where\n  cache : ExprStructMap Expr := {}", "start": [664, 1], "end": [665, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.Context", "code": "structure Context where\n  mvarId        : MVarId\n  mvarDecl      : MetavarDecl\n  fvars         : Array Expr\n  hasCtxLocals  : Bool\n  rhs           : Expr", "start": [667, 1], "end": [672, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.CheckAssignmentM", "code": "abbrev CheckAssignmentM := ReaderT Context $ StateRefT State MetaM", "start": [674, 1], "end": [674, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.throwCheckAssignmentFailure", "code": "def throwCheckAssignmentFailure : CheckAssignmentM \u03b1 :=\n  throw <| Exception.internal checkAssignmentExceptionId", "start": [676, 1], "end": [677, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.throwOutOfScopeFVar", "code": "def throwOutOfScopeFVar : CheckAssignmentM \u03b1 :=\n  throw <| Exception.internal outOfScopeExceptionId", "start": [679, 1], "end": [680, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.findCached?", "code": "private def findCached? (e : Expr) : CheckAssignmentM (Option Expr) := do\n  return (\u2190 get).cache.find? e", "start": [682, 1], "end": [683, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.cache", "code": "private def cache (e r : Expr) : CheckAssignmentM Unit := do\n  modify fun s => { s with cache := s.cache.insert e r }", "start": [685, 1], "end": [686, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.addAssignmentInfo", "code": "private def addAssignmentInfo (msg : MessageData) : CheckAssignmentM MessageData := do\n  let ctx \u2190 read\n  return m!\"{msg} @ {mkMVar ctx.mvarId} {ctx.fvars} := {ctx.rhs}\"", "start": [692, 1], "end": [694, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.run", "code": "@[inline] def run (x : CheckAssignmentM Expr) (mvarId : MVarId) (fvars : Array Expr) (hasCtxLocals : Bool) (v : Expr) : MetaM (Option Expr) := do\n  let mvarDecl \u2190 mvarId.getDecl\n  let ctx := { mvarId := mvarId, mvarDecl := mvarDecl, fvars := fvars, hasCtxLocals := hasCtxLocals, rhs := v : Context }\n  let x : CheckAssignmentM (Option Expr) :=\n    catchInternalIds [outOfScopeExceptionId, checkAssignmentExceptionId]\n      (do let e \u2190 x; return some e)\n      (fun _ => pure none)\n  x.run ctx |>.run' {}", "start": [696, 1], "end": [703, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.checkFVar", "code": "partial def checkFVar (fvar : Expr) : CheckAssignmentM Expr := do\n    let ctxMeta \u2190 readThe Meta.Context\n    let ctx \u2190 read\n    if ctx.mvarDecl.lctx.containsFVar fvar then\n      pure fvar\n    else\n      let lctx := ctxMeta.lctx\n      match lctx.findFVar? fvar with\n      | some (.ldecl (value := v) ..) => check v\n      | _ =>\n        if ctx.fvars.contains fvar then pure fvar\n        else\n          traceM `Meta.isDefEq.assign.outOfScopeFVar do addAssignmentInfo fvar\n          throwOutOfScopeFVar", "start": [707, 3], "end": [720, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.checkMVar", "code": "partial def checkMVar (mvar : Expr) : CheckAssignmentM Expr := do\n    let mvarId := mvar.mvarId!\n    let ctx  \u2190 read\n    if mvarId == ctx.mvarId then\n      traceM `Meta.isDefEq.assign.occursCheck <| addAssignmentInfo \"occurs check failed\"\n      throwCheckAssignmentFailure\n    else match (\u2190 getExprMVarAssignment? mvarId) with\n      | some v => check v\n      | none   =>\n        match (\u2190 mvarId.findDecl?) with\n        | none          => throwUnknownMVar mvarId\n        | some mvarDecl =>\n          if ctx.hasCtxLocals then\n            throwCheckAssignmentFailure else if mvarDecl.lctx.isSubPrefixOf ctx.mvarDecl.lctx ctx.fvars then\n            \n            pure mvar\n          else if mvarDecl.depth != (\u2190 getMCtx).depth || mvarDecl.kind.isSyntheticOpaque then\n            traceM `Meta.isDefEq.assign.readOnlyMVarWithBiggerLCtx <| addAssignmentInfo (mkMVar mvarId)\n            throwCheckAssignmentFailure\n          else\n            let ctxMeta \u2190 readThe Meta.Context\n            if ctxMeta.config.ctxApprox && ctx.mvarDecl.lctx.isSubPrefixOf mvarDecl.lctx then\n              \n              let toErase \u2190 mvarDecl.lctx.foldlM (init := #[]) fun toErase localDecl => do\n                if ctx.mvarDecl.lctx.contains localDecl.fvarId then\n                  return toErase\n                else if ctx.fvars.any fun fvar => fvar.fvarId! == localDecl.fvarId then\n                  if (\u2190 findLocalDeclDependsOn localDecl fun fvarId => toErase.contains fvarId) then\n                    return toErase.push localDecl.fvarId\n                  else\n                    return toErase\n                else\n                  return toErase.push localDecl.fvarId\n              let lctx := toErase.foldl (init := mvarDecl.lctx) fun lctx toEraseFVar =>\n                lctx.erase toEraseFVar\n              \n              let localInsts := mvarDecl.localInstances.filter fun localInst => !toErase.contains localInst.fvar.fvarId!\n              let mvarType \u2190 check mvarDecl.type\n              let newMVar \u2190 mkAuxMVar lctx localInsts mvarType mvarDecl.numScopeArgs\n              mvarId.assign newMVar\n              pure newMVar\n            else\n              traceM `Meta.isDefEq.assign.readOnlyMVarWithBiggerLCtx <| addAssignmentInfo (mkMVar mvarId)\n              throwCheckAssignmentFailure", "start": [722, 3], "end": [779, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.assignToConstFun", "code": "partial def assignToConstFun (mvar : Expr) (numArgs : Nat) (newMVar : Expr) : MetaM Bool := do\n    let mvarType \u2190 inferType mvar\n    forallBoundedTelescope mvarType numArgs fun xs _ => do\n      if xs.size != numArgs then pure false\n      else\n        let some v \u2190 mkLambdaFVarsWithLetDeps xs newMVar | return false\n        match (\u2190 checkAssignmentAux mvar.mvarId! #[] false v) with\n        | some v => checkTypesAndAssign mvar v\n        | none   => return false", "start": [781, 3], "end": [795, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.checkAssignmentAux", "code": "partial def checkAssignmentAux (mvarId : MVarId) (fvars : Array Expr) (hasCtxLocals : Bool) (v : Expr) : MetaM (Option Expr) := do\n    run (check v) mvarId fvars hasCtxLocals v", "start": [798, 3], "end": [799, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.checkApp", "code": "partial def checkApp (e : Expr) : CheckAssignmentM Expr :=\n    e.withApp fun f args => do\n      let ctxMeta \u2190 readThe Meta.Context\n      if f.isMVar && ctxMeta.config.ctxApprox && args.all Expr.isFVar then\n        let f \u2190 check f\n        catchInternalId outOfScopeExceptionId\n          (do\n            let args \u2190 args.mapM check\n            return mkAppN f args)\n          (fun ex => do\n            if !f.isMVar then\n              throw ex\n            else if (\u2190 f.mvarId!.isDelayedAssigned) then\n              throw ex\n            else\n              let eType \u2190 inferType e\n              let mvarType \u2190 check eType\n              \n              let ctx \u2190 read\n              let newMVar \u2190 mkAuxMVar ctx.mvarDecl.lctx ctx.mvarDecl.localInstances mvarType\n              if (\u2190 assignToConstFun f args.size newMVar) then\n                pure newMVar\n              else\n                throw ex)\n      else\n        let f \u2190 check f\n        let args \u2190 args.mapM check\n        return mkAppN f args", "start": [801, 3], "end": [829, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignment.check", "code": "partial def check (e : Expr) : CheckAssignmentM Expr := do\n    if !e.hasExprMVar && !e.hasFVar then\n      return e\n    else checkCache e fun _ =>\n      match e with\n      | Expr.mdata _ b       => return e.updateMData! (\u2190 check b)\n      | Expr.proj _ _ s      => return e.updateProj! (\u2190 check s)\n      | Expr.lam _ d b _     => return e.updateLambdaE! (\u2190 check d) (\u2190 check b)\n      | Expr.forallE _ d b _ => return e.updateForallE! (\u2190 check d) (\u2190 check b)\n      | Expr.letE _ t v b _  => return e.updateLet! (\u2190 check t) (\u2190 check v) (\u2190 check b)\n      | Expr.bvar ..         => return e\n      | Expr.sort ..         => return e\n      | Expr.const ..        => return e\n      | Expr.lit ..          => return e\n      | Expr.fvar ..         => checkFVar e\n      | Expr.mvar ..         => checkMVar e\n      | Expr.app ..          =>\n        try\n          checkApp e\n        catch ex => match ex with\n          | .internal id =>\n            \n            if (id == outOfScopeExceptionId || id == checkAssignmentExceptionId) && e.isHeadBetaTarget then\n              checkApp e.headBeta\n            else\n              throw ex\n          | _ => throw ex", "start": [831, 3], "end": [866, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.CheckAssignmentQuick.check", "code": "partial def check\n    (hasCtxLocals : Bool)\n    (mctx : MetavarContext) (lctx : LocalContext) (mvarDecl : MetavarDecl) (mvarId : MVarId) (fvars : Array Expr) (e : Expr) : Bool :=\n  let rec visit (e : Expr) : Bool :=\n    if !e.hasExprMVar && !e.hasFVar then\n      true\n    else match e with\n    | Expr.mdata _ b       => visit b\n    | Expr.proj _ _ s      => visit s\n    | Expr.app f a         => visit f && visit a\n    | Expr.lam _ d b _     => visit d && visit b\n    | Expr.forallE _ d b _ => visit d && visit b\n    | Expr.letE _ t v b _  => visit t && visit v && visit b\n    | Expr.bvar ..         => true\n    | Expr.sort ..         => true\n    | Expr.const ..        => true\n    | Expr.lit ..          => true\n    | Expr.fvar fvarId ..  =>\n      if mvarDecl.lctx.contains fvarId then true\n      else match lctx.find? fvarId with\n        | some (LocalDecl.ldecl ..) => false | _ =>\n          if fvars.any fun x => x.fvarId! == fvarId then true\n          else false | Expr.mvar mvarId'    =>\n      match mctx.getExprAssignmentCore? mvarId' with\n      | some _ => false | none   =>\n        if mvarId' == mvarId then false else match mctx.findDecl? mvarId' with\n          | none           => false\n          | some mvarDecl' =>\n            if hasCtxLocals then false else if mvarDecl'.lctx.isSubPrefixOf mvarDecl.lctx fvars then true\n            else false visit e", "start": [885, 1], "end": [920, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.checkAssignment", "code": "def checkAssignment (mvarId : MVarId) (fvars : Array Expr) (v : Expr) : MetaM (Option Expr) := do\n  \n  for fvar in fvars do\n    unless (\u2190 occursCheck mvarId (\u2190 inferType fvar)) do\n      return none\n  if !v.hasExprMVar && !v.hasFVar then\n    pure (some v)\n  else\n    let mvarDecl \u2190 mvarId.getDecl\n    let hasCtxLocals := fvars.any fun fvar => mvarDecl.lctx.containsFVar fvar\n    let ctx \u2190 read\n    let mctx \u2190 getMCtx\n    if CheckAssignmentQuick.check hasCtxLocals mctx ctx.lctx mvarDecl mvarId fvars v then\n      pure (some v)\n    else\n      let v \u2190 instantiateMVars v\n      CheckAssignment.checkAssignmentAux mvarId fvars hasCtxLocals v", "start": [924, 1], "end": [950, 69], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.processAssignmentFOApproxAux", "code": "private def processAssignmentFOApproxAux (mvar : Expr) (args : Array Expr) (v : Expr) : MetaM Bool :=\n  match v with\n  | .mdata _ e   => processAssignmentFOApproxAux mvar args e\n  | Expr.app f a =>\n    if args.isEmpty then\n      pure false\n    else\n      Meta.isExprDefEqAux args.back a <&&> Meta.isExprDefEqAux (mkAppRange mvar 0 (args.size - 1) args) f\n  | _            => pure false", "start": [952, 1], "end": [960, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.processAssignmentFOApprox", "code": "private partial def processAssignmentFOApprox (mvar : Expr) (args : Array Expr) (v : Expr) : MetaM Bool :=\n  let rec loop (v : Expr) := do\n    let cfg \u2190 getConfig\n    if !cfg.foApprox then\n      pure false\n    else\n      trace[Meta.isDefEq.foApprox] \"{mvar} {args} := {v}\"\n      let v := v.headBeta\n      if (\u2190 checkpointDefEq <| processAssignmentFOApproxAux mvar args v) then\n        pure true\n      else\n        match (\u2190 unfoldDefinition? v) with\n        | none   => pure false\n        | some v => loop v\n  loop v", "start": [962, 1], "end": [992, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpAssignmentArgAux", "code": "private partial def simpAssignmentArgAux (e : Expr) : MetaM Expr := do\n  match e with\n  | .mdata _ e   => simpAssignmentArgAux e\n  | .fvar fvarId =>\n    let some value \u2190 fvarId.getValue? | return e\n    simpAssignmentArgAux value\n  | _ => return e", "start": [994, 1], "end": [1000, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.simpAssignmentArg", "code": "private def simpAssignmentArg (arg : Expr) : MetaM Expr := do\n  let arg \u2190 if arg.getAppFn.hasExprMVar then instantiateMVars arg else pure arg\n  simpAssignmentArgAux arg", "start": [1002, 1], "end": [1007, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.assignConst", "code": "private def assignConst (mvar : Expr) (numArgs : Nat) (v : Expr) : MetaM Bool := do\n  let mvarDecl \u2190 mvar.mvarId!.getDecl\n  forallBoundedTelescope mvarDecl.type numArgs fun xs _ => do\n    if xs.size != numArgs then\n      pure false\n    else\n      let some v \u2190 mkLambdaFVarsWithLetDeps xs v | pure false\n      match (\u2190 checkAssignment mvar.mvarId! #[] v) with\n      | none   => pure false\n      | some v =>\n        trace[Meta.isDefEq.constApprox] \"{mvar} := {v}\"\n        checkTypesAndAssign mvar v", "start": [1009, 1], "end": [1022, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.processConstApprox", "code": "private partial def processConstApprox (mvar : Expr) (args : Array Expr) (patternVarPrefix : Nat) (v : Expr) : MetaM Bool := do\n  trace[Meta.isDefEq.constApprox] \"{mvar} {args} := {v}\"\n  let rec defaultCase : MetaM Bool := assignConst mvar args.size v\n  let cfg \u2190 getConfig\n  let mvarId := mvar.mvarId!\n  let mvarDecl \u2190 mvarId.getDecl\n  let numArgs := args.size\n  if mvarDecl.numScopeArgs != numArgs && !cfg.constApprox then\n    return false\n  else if patternVarPrefix == 0 then\n    defaultCase\n  else\n    let argsPrefix : Array Expr := args[:patternVarPrefix]\n    let type \u2190 instantiateForall mvarDecl.type argsPrefix\n    let suffixSize := numArgs - argsPrefix.size\n    forallBoundedTelescope type suffixSize fun xs _ => do\n      if xs.size != suffixSize then\n        defaultCase\n      else\n        let some v \u2190 mkLambdaFVarsWithLetDeps xs v | defaultCase\n        let rec go (argsPrefix : Array Expr) (v : Expr) : MetaM Bool := do\n          trace[Meta.isDefEq] \"processConstApprox.go {mvar} {argsPrefix} := {v}\"\n          let rec cont : MetaM Bool := do\n            if argsPrefix.isEmpty then\n              defaultCase\n            else\n              let some v \u2190 mkLambdaFVarsWithLetDeps #[argsPrefix.back] v | defaultCase\n              go argsPrefix.pop v\n          match (\u2190 checkAssignment mvarId argsPrefix v) with\n          | none      => cont\n          | some vNew =>\n            let some vNew \u2190 mkLambdaFVarsWithLetDeps argsPrefix vNew | cont\n            if argsPrefix.any (fun arg => mvarDecl.lctx.containsFVar arg) then\n              \n              (isTypeCorrect vNew <&&> checkTypesAndAssign mvar vNew) <||> cont\n            else\n              checkTypesAndAssign mvar vNew <||> cont\n        go argsPrefix v", "start": [1024, 1], "end": [1077, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.processAssignment", "code": "private partial def processAssignment (mvarApp : Expr) (v : Expr) : MetaM Bool :=\n  withTraceNodeBefore `Meta.isDefEq.assign (return m!\"{mvarApp} := {v}\") do\n    let mvar := mvarApp.getAppFn\n    let mvarDecl \u2190 mvar.mvarId!.getDecl\n    let rec process (i : Nat) (args : Array Expr) (v : Expr) := do\n      let cfg \u2190 getConfig\n      let useFOApprox (args : Array Expr) : MetaM Bool :=\n        processAssignmentFOApprox mvar args v <||> processConstApprox mvar args i v\n      if h : i < args.size then\n        let arg := args.get \u27e8i, h\u27e9\n        let arg \u2190 simpAssignmentArg arg\n        let args := args.set \u27e8i, h\u27e9 arg\n        match arg with\n        | Expr.fvar fvarId =>\n          if args[0:i].any fun prevArg => prevArg == arg then\n            useFOApprox args\n          else if mvarDecl.lctx.contains fvarId && !cfg.quasiPatternApprox then\n            useFOApprox args\n          else\n            process (i+1) args v\n        | _ =>\n          useFOApprox args\n      else\n        let v \u2190 instantiateMVars v if v.getAppFn == mvar then\n          useFOApprox args\n        else\n          let mvarId := mvar.mvarId!\n          match (\u2190 checkAssignment mvarId args v) with\n          | none   => useFOApprox args\n          | some v => do\n            trace[Meta.isDefEq.assign.beforeMkLambda] \"{mvar} {args} := {v}\"\n            let some v \u2190 mkLambdaFVarsWithLetDeps args v | return false\n            if args.any (fun arg => mvarDecl.lctx.containsFVar arg) then\n              \n              if (\u2190 isTypeCorrect v) then\n                checkTypesAndAssign mvar v\n              else\n                trace[Meta.isDefEq.assign.typeError] \"{mvar} := {v}\"\n                useFOApprox args\n            else\n              checkTypesAndAssign mvar v\n    process 0 mvarApp.getAppArgs v", "start": [1079, 1], "end": [1125, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.processAssignment'", "code": "private def processAssignment' (mvarApp : Expr) (v : Expr) : MetaM Bool := do\n  if (\u2190 processAssignment mvarApp v) then\n    return true\n  else\n    let vNew \u2190 whnf v\n    if vNew != v then\n      if mvarApp == vNew then\n        return true\n      else\n        processAssignment mvarApp vNew\n    else\n      return false", "start": [1127, 1], "end": [1146, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDeltaCandidate?", "code": "private def isDeltaCandidate? (t : Expr) : MetaM (Option ConstantInfo) := do\n  match t.getAppFn with\n  | Expr.const c _ =>\n    match (\u2190 getUnfoldableConst? c) with\n    | r@(some info) => if info.hasValue then return r else return none\n    | _             => return none\n  | _ => pure none", "start": [1148, 1], "end": [1154, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isListLevelDefEq", "code": "private def isListLevelDefEq (us vs : List Level) : MetaM LBool :=\n  toLBoolM <| isListLevelDefEqAux us vs", "start": [1156, 1], "end": [1158, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqLeft", "code": "private def isDefEqLeft (fn : Name) (t s : Expr) : MetaM LBool := do\n  trace[Meta.isDefEq.delta.unfoldLeft] fn\n  toLBoolM <| Meta.isExprDefEqAux t s", "start": [1160, 1], "end": [1163, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqRight", "code": "private def isDefEqRight (fn : Name) (t s : Expr) : MetaM LBool := do\n  trace[Meta.isDefEq.delta.unfoldRight] fn\n  toLBoolM <| Meta.isExprDefEqAux t s", "start": [1165, 1], "end": [1168, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqLeftRight", "code": "private def isDefEqLeftRight (fn : Name) (t s : Expr) : MetaM LBool := do\n  trace[Meta.isDefEq.delta.unfoldLeftRight] fn\n  toLBoolM <| Meta.isExprDefEqAux t s", "start": [1170, 1], "end": [1173, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.tryHeuristic", "code": "private def tryHeuristic (t s : Expr) : MetaM Bool := do\n  let mut t := t\n  let mut s := s\n  let tFn := t.getAppFn\n  let sFn := s.getAppFn\n  let info \u2190 getConstInfo tFn.constName!\n  \n  unless info.hints.isRegular || isMatcherCore (\u2190 getEnv) tFn.constName! do\n    unless t.hasExprMVar || s.hasExprMVar do\n      return false\n  withTraceNodeBefore `Meta.isDefEq.delta (return m!\"{t} =?= {s}\") do\n    \n    checkpointDefEq do\n      isDefEqArgs tFn t.getAppArgs s.getAppArgs <&&>\n        isListLevelDefEqAux tFn.constLevels! sFn.constLevels!", "start": [1175, 1], "end": [1220, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfold", "code": "private abbrev unfold (e : Expr) (failK : MetaM \u03b1) (successK : Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n  match (\u2190 unfoldDefinition? e) with\n  | some e => successK e\n  | none   => failK", "start": [1222, 1], "end": [1226, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldBothDefEq", "code": "private def unfoldBothDefEq (fn : Name) (t s : Expr) : MetaM LBool := do\n  match t, s with\n  | Expr.const _ ls\u2081, Expr.const _ ls\u2082 => isListLevelDefEq ls\u2081 ls\u2082\n  | Expr.app _ _,     Expr.app _ _     =>\n    if (\u2190 tryHeuristic t s) then\n      pure LBool.true\n    else\n      unfold t\n       (unfold s (pure LBool.undef) (fun s => isDefEqRight fn t s))\n       (fun t => unfold s (isDefEqLeft fn t s) (fun s => isDefEqLeftRight fn t s))\n  | _, _ => pure LBool.false", "start": [1228, 1], "end": [1239, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.sameHeadSymbol", "code": "private def sameHeadSymbol (t s : Expr) : Bool :=\n  match t.getAppFn, s.getAppFn with\n  | Expr.const c\u2081 _, Expr.const c\u2082 _ => c\u2081 == c\u2082\n  | _,               _               => false", "start": [1241, 1], "end": [1244, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldComparingHeadsDefEq", "code": "private def unfoldComparingHeadsDefEq (tInfo sInfo : ConstantInfo) (t s : Expr) : MetaM LBool :=\n  unfold t\n    (unfold s\n      (pure LBool.undef) (fun s => isDefEqRight sInfo.name t s))\n    (fun tNew =>\n      if sameHeadSymbol tNew s then\n        isDefEqLeft tInfo.name tNew s\n      else\n        unfold s\n          (isDefEqLeft tInfo.name tNew s)\n          (fun sNew =>\n            if sameHeadSymbol t sNew then\n              isDefEqRight sInfo.name t sNew\n            else\n              isDefEqLeftRight tInfo.name tNew sNew))", "start": [1246, 1], "end": [1267, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldDefEq", "code": "private def unfoldDefEq (tInfo sInfo : ConstantInfo) (t s : Expr) : MetaM LBool :=\n  if !t.hasExprMVar && !s.hasExprMVar then\n    \n    if tInfo.hints.lt sInfo.hints then\n      unfold t (unfoldComparingHeadsDefEq tInfo sInfo t s) fun t => isDefEqLeft tInfo.name t s\n    else if sInfo.hints.lt tInfo.hints then\n      unfold s (unfoldComparingHeadsDefEq tInfo sInfo t s) fun s => isDefEqRight sInfo.name t s\n    else\n      unfoldComparingHeadsDefEq tInfo sInfo t s\n  else\n    unfoldComparingHeadsDefEq tInfo sInfo t s", "start": [1269, 1], "end": [1285, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldReducibeDefEq", "code": "private def unfoldReducibeDefEq (tInfo sInfo : ConstantInfo) (t s : Expr) : MetaM LBool := do\n  if (\u2190 shouldReduceReducibleOnly) then\n    unfoldDefEq tInfo sInfo t s\n  else\n    let tReducible \u2190 isReducible tInfo.name\n    let sReducible \u2190 isReducible sInfo.name\n    if tReducible && !sReducible then\n      unfold t (unfoldDefEq tInfo sInfo t s) fun t => isDefEqLeft tInfo.name t s\n    else if !tReducible && sReducible then\n      unfold s (unfoldDefEq tInfo sInfo t s) fun s => isDefEqRight sInfo.name t s\n    else\n      unfoldDefEq tInfo sInfo t s", "start": [1287, 1], "end": [1306, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unfoldNonProjFnDefEq", "code": "private partial def unfoldNonProjFnDefEq (tInfo sInfo : ConstantInfo) (t s : Expr) : MetaM LBool := do\n  let tProjInfo? \u2190 getProjectionFnInfo? tInfo.name\n  let sProjInfo? \u2190 getProjectionFnInfo? sInfo.name\n  if let some tNew \u2190 packedInstanceOf? tProjInfo? t sInfo.name then\n    isDefEqLeft tInfo.name tNew s\n  else if let some sNew \u2190 packedInstanceOf? sProjInfo? s tInfo.name then\n    isDefEqRight sInfo.name t sNew\n  else  match tProjInfo?, sProjInfo? with\n    | some _, none => unfold s (unfoldDefEq tInfo sInfo t s) fun s => isDefEqRight sInfo.name t s\n    | none, some _ => unfold t (unfoldDefEq tInfo sInfo t s) fun t => isDefEqLeft tInfo.name t s\n    | _, _ => unfoldReducibeDefEq tInfo sInfo t s\nwhere\n  packedInstanceOf? (projInfo? : Option ProjectionFunctionInfo) (e : Expr) (declName : Name) : MetaM (Option Expr) := do\n    let some { fromClass := true, .. } := projInfo? | return none let some e \u2190 unfoldDefinition? e | return none\n    let e \u2190 whnfCore e\n    if e.isAppOf declName then return some e\n    let .const name _ := e.getAppFn | return none\n    packedInstanceOf? (\u2190 getProjectionFnInfo? name) e declName", "start": [1308, 1], "end": [1352, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqDelta", "code": "private def isDefEqDelta (t s : Expr) : MetaM LBool := do\n  let tInfo? \u2190 isDeltaCandidate? t\n  let sInfo? \u2190 isDeltaCandidate? s\n  match tInfo?, sInfo? with\n  | none,       none       => pure LBool.undef\n  | some tInfo, none       => unfold t (pure LBool.undef) fun t => isDefEqLeft tInfo.name t s\n  | none,       some sInfo => unfold s (pure LBool.undef) fun s => isDefEqRight sInfo.name t s\n  | some tInfo, some sInfo =>\n    if tInfo.name == sInfo.name then\n      unfoldBothDefEq tInfo.name t s\n    else\n      unfoldNonProjFnDefEq tInfo sInfo t s", "start": [1354, 1], "end": [1386, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isAssigned", "code": "private def isAssigned : Expr \u2192 MetaM Bool\n  | Expr.mvar mvarId => mvarId.isAssigned\n  | _                => pure false", "start": [1388, 1], "end": [1390, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.expandDelayedAssigned?", "code": "private def expandDelayedAssigned? (t : Expr) : MetaM (Option Expr) := do\n  let tFn := t.getAppFn\n  if !tFn.isMVar then return none\n  let some { fvars, mvarIdPending } \u2190 getDelayedMVarAssignment? tFn.mvarId! | return none\n  let tNew \u2190 instantiateMVars t\n  if tNew != t then return some tNew\n  \n  unless (\u2190 getConfig).assignSyntheticOpaque do return none\n  let tArgs := t.getAppArgs\n  if tArgs.size < fvars.size then return none\n  return some (mkAppRange (mkMVar mvarIdPending) fvars.size tArgs.size tArgs)", "start": [1392, 1], "end": [1419, 78], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isAssignable", "code": "private def isAssignable : Expr \u2192 MetaM Bool\n  | Expr.mvar mvarId => do let b \u2190 mvarId.isReadOnlyOrSyntheticOpaque; pure (!b)\n  | _                => pure false", "start": [1421, 1], "end": [1423, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.etaEq", "code": "private def etaEq (t s : Expr) : Bool :=\n  match t.etaExpanded? with\n  | some t => t == s\n  | none   => false", "start": [1425, 1], "end": [1428, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.withProofIrrelTransparency", "code": "private def withProofIrrelTransparency (k : MetaM \u03b1) : MetaM \u03b1 :=\n  withAtLeastTransparency .default k", "start": [1430, 1], "end": [1451, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqProofIrrel", "code": "private def isDefEqProofIrrel (t s : Expr) : MetaM LBool := do\n  if (\u2190 getConfig).proofIrrelevance then\n    match (\u2190 isProofQuick t) with\n    | LBool.false =>\n      pure LBool.undef\n    | LBool.true  =>\n      let tType \u2190 inferType t\n      let sType \u2190 inferType s\n      toLBoolM <| withProofIrrelTransparency <| Meta.isExprDefEqAux tType sType\n    | LBool.undef =>\n      let tType \u2190 inferType t\n      if (\u2190 isProp tType) then\n        let sType \u2190 inferType s\n        toLBoolM <| withProofIrrelTransparency <| Meta.isExprDefEqAux tType sType\n      else\n        pure LBool.undef\n  else\n    pure LBool.undef", "start": [1453, 1], "end": [1470, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqMVarSelf", "code": "private def isDefEqMVarSelf (mvar : Expr) (args\u2081 args\u2082 : Array Expr) : MetaM Bool := do\n  if args\u2081.size != args\u2082.size then\n    pure false\n  else if (\u2190 isDefEqArgs mvar args\u2081 args\u2082) then\n    pure true\n  else if !(\u2190 isAssignable mvar) then\n    pure false\n  else\n    let cfg \u2190 getConfig\n    let mvarId := mvar.mvarId!\n    let mvarDecl \u2190 mvarId.getDecl\n    if mvarDecl.numScopeArgs == args\u2081.size || cfg.constApprox then\n      let type \u2190 inferType (mkAppN mvar args\u2081)\n      let auxMVar \u2190 mkAuxMVar mvarDecl.lctx mvarDecl.localInstances type\n      assignConst mvar args\u2081.size auxMVar\n    else\n      pure false", "start": [1472, 1], "end": [1492, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.consumeLet", "code": "private def consumeLet : Expr \u2192 Expr\n  | e@(Expr.letE _ _ _ b _) => if b.hasLooseBVars then e else consumeLet b\n  | e                       => e", "start": [1494, 1], "end": [1497, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqQuick", "code": "private partial def isDefEqQuick (t s : Expr) : MetaM LBool :=\n  let t := consumeLet t\n  let s := consumeLet s\n  match t, s with\n  | .lit  l\u2081,      .lit l\u2082     => return (l\u2081 == l\u2082).toLBool\n  | .sort u,       .sort v     => toLBoolM <| isLevelDefEqAux u v\n  | .lam ..,       .lam ..     => if t == s then pure LBool.true else toLBoolM <| isDefEqBinding t s\n  | .forallE ..,   .forallE .. => if t == s then pure LBool.true else toLBoolM <| isDefEqBinding t s\n  | .fvar fvarId\u2081, .fvar fvarId\u2082 => do\n    if (\u2190 fvarId\u2081.isLetVar <||> fvarId\u2082.isLetVar) then\n      return LBool.undef\n    else if fvarId\u2081 == fvarId\u2082 then\n      return LBool.true\n    else\n      isDefEqProofIrrel t s\n  | t, s =>\n    isDefEqQuickOther t s", "start": [1501, 1], "end": [1519, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqQuickOther", "code": "private partial def isDefEqQuickOther (t s : Expr) : MetaM LBool := do\n  \n  if let some t := patternAnnotation? t then\n    isDefEqQuick t s\n  else if let some s := patternAnnotation? s then\n    isDefEqQuick t s\n  else if t == s then\n    return LBool.true\n  else if etaEq t s || etaEq s t then\n    return LBool.true  else\n    let tFn := t.getAppFn\n    let sFn := s.getAppFn\n    if !tFn.isMVar && !sFn.isMVar then\n      return LBool.undef\n    else if (\u2190 isAssigned tFn) then\n      let t \u2190 instantiateMVars t\n      isDefEqQuick t s\n    else if (\u2190 isAssigned sFn) then\n      let s \u2190 instantiateMVars s\n      isDefEqQuick t s\n    else if let some t \u2190 expandDelayedAssigned? t then\n      isDefEqQuick t s\n    else if let some s \u2190 expandDelayedAssigned? s then\n      isDefEqQuick t s\n    \n    else if tFn.isMVar && sFn.isMVar && tFn == sFn then\n      Bool.toLBool <$> isDefEqMVarSelf tFn t.getAppArgs s.getAppArgs\n    else\n      let tAssign? \u2190 isAssignable tFn\n      let sAssign? \u2190 isAssignable sFn\n      let assignableMsg (b : Bool) := if b then \"[assignable]\" else \"[nonassignable]\"\n      trace[Meta.isDefEq] \"{t} {assignableMsg tAssign?} =?= {s} {assignableMsg sAssign?}\"\n      if tAssign? && !sAssign? then\n        toLBoolM <| processAssignment' t s\n      else if !tAssign? && sAssign? then\n        toLBoolM <| processAssignment' s t\n      else if !tAssign? && !sAssign? then\n        \n        match (\u2190 isDefEqProofIrrel t s) with\n        | LBool.true => return LBool.true\n        | LBool.false => return LBool.false\n        | _ =>\n          if tFn.isMVar || sFn.isMVar then\n            let ctx \u2190 read\n            if ctx.config.isDefEqStuckEx then do\n              trace[Meta.isDefEq.stuck] \"{t} =?= {s}\"\n              Meta.throwIsDefEqStuck\n            else\n              return LBool.false\n          else\n            return LBool.undef\n      else\n        isDefEqQuickMVarMVar t s", "start": [1521, 1], "end": [1642, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqQuickMVarMVar", "code": "private partial def isDefEqQuickMVarMVar (t s : Expr) : MetaM LBool := do\n  if s.isMVar && !t.isMVar then\n     \n     if (\u2190 checkpointDefEq (processAssignment s t)) then\n       return LBool.true\n     else\n       toLBoolM <| processAssignment t s\n  else\n     if (\u2190 checkpointDefEq (processAssignment t s)) then\n       return LBool.true\n     else\n       toLBoolM <| processAssignment s t", "start": [1644, 1], "end": [1657, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.whenUndefDo", "code": "@[inline] def whenUndefDo (x : MetaM LBool) (k : MetaM Bool) : MetaM Bool := do\n  let status \u2190 x\n  match status with\n  | LBool.true  => pure true\n  | LBool.false => pure false\n  | LBool.undef => k", "start": [1661, 1], "end": [1666, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unstuckMVar", "code": "@[specialize] private def unstuckMVar (e : Expr) (successK : Expr \u2192 MetaM Bool) (failK : MetaM Bool): MetaM Bool := do\n  match (\u2190 getStuckMVar? e) with\n  | some mvarId =>\n    trace[Meta.isDefEq.stuckMVar] \"found stuck MVar {mkMVar mvarId} : {\u2190 inferType (mkMVar mvarId)}\"\n    if (\u2190 Meta.synthPending mvarId) then\n      let e \u2190 instantiateMVars e\n      successK e\n    else\n      failK\n  | none   => failK", "start": [1668, 1], "end": [1677, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqOnFailure", "code": "private def isDefEqOnFailure (t s : Expr) : MetaM Bool := do\n  withTraceNodeBefore `Meta.isDefEq.onFailure (return m!\"{t} =?= {s}\") do\n    unstuckMVar t (fun t => Meta.isExprDefEqAux t s) <|\n    unstuckMVar s (fun s => Meta.isExprDefEqAux t s) <|\n    tryUnificationHints t s <||> tryUnificationHints s t", "start": [1679, 1], "end": [1683, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqProj", "code": "private def isDefEqProj : Expr \u2192 Expr \u2192 MetaM Bool\n  | Expr.proj m i t, Expr.proj n j s => pure (i == j && m == n) <&&> Meta.isExprDefEqAux t s\n  | Expr.proj structName 0 s, v => isDefEqSingleton structName s v\n  | v, Expr.proj structName 0 s => isDefEqSingleton structName s v\n  | _, _ => pure false\nwhere\n  \n  isDefEqSingleton (structName : Name) (s : Expr) (v : Expr) : MetaM Bool := do\n    if isClass (\u2190 getEnv) structName then\n      \n      return false\n    let ctorVal := getStructureCtor (\u2190 getEnv) structName\n    if ctorVal.numFields != 1 then\n      return false let sType \u2190 whnf (\u2190 inferType s)\n    let sTypeFn := sType.getAppFn\n    if !sTypeFn.isConstOf structName then\n      return false\n    let s \u2190 whnf s\n    let sFn := s.getAppFn\n    if !sFn.isMVar then\n      return false\n    if (\u2190 isAssignable sFn) then\n      let ctorApp := mkApp (mkAppN (mkConst ctorVal.name sTypeFn.constLevels!) sType.getAppArgs) v\n      processAssignment' s ctorApp\n    else\n      return false", "start": [1685, 1], "end": [1726, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqApp", "code": "private def isDefEqApp (t s : Expr) : MetaM Bool := do\n  let tFn := t.getAppFn\n  let sFn := s.getAppFn\n  if tFn.isConst && sFn.isConst && tFn.constName! == sFn.constName! then\n    \n    if (\u2190 checkpointDefEq (isDefEqArgs tFn t.getAppArgs s.getAppArgs <&&> isListLevelDefEqAux tFn.constLevels! sFn.constLevels!)) then\n      return true\n    else\n      isDefEqOnFailure t s\n  else if (\u2190 checkpointDefEq (Meta.isExprDefEqAux tFn s.getAppFn <&&> isDefEqArgs tFn t.getAppArgs s.getAppArgs)) then\n    return true\n  else\n    isDefEqOnFailure t s", "start": [1728, 1], "end": [1744, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqUnitLike", "code": "private def isDefEqUnitLike (t : Expr) (s : Expr) : MetaM Bool := do\n  let tType \u2190 whnf (\u2190 inferType t)\n  matchConstStruct tType.getAppFn (fun _ => return false) fun _ _ ctorVal => do\n    if ctorVal.numFields != 0 then\n      return false\n    else if (\u2190 useEtaStruct ctorVal.induct) then\n      Meta.isExprDefEqAux tType (\u2190 inferType s)\n    else\n      return false", "start": [1746, 1], "end": [1755, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isDefEqProjInst", "code": "private def isDefEqProjInst (t : Expr) (s : Expr) : MetaM LBool := do\n  if (\u2190 getTransparency) != .instances then return .undef\n  let t? \u2190 unfoldProjInstWhenIntances? t\n  let s? \u2190 unfoldProjInstWhenIntances? s\n  if t?.isSome || s?.isSome then\n    toLBoolM <| Meta.isExprDefEqAux (t?.getD t) (s?.getD s)\n  else\n    return .undef", "start": [1757, 1], "end": [1769, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isExprDefEqExpensive", "code": "private def isExprDefEqExpensive (t : Expr) (s : Expr) : MetaM Bool := do\n  whenUndefDo (isDefEqEta t s) do\n  whenUndefDo (isDefEqEta s t) do\n  if (\u2190 isDefEqProj t s) then return true\n  whenUndefDo (isDefEqNative t s) do\n  whenUndefDo (isDefEqNat t s) do\n  whenUndefDo (isDefEqOffset t s) do\n  whenUndefDo (isDefEqDelta t s) do\n  if (\u2190 (isDefEqEtaStruct t s <||> isDefEqEtaStruct s t)) then\n    return true\n  if t.isConst && s.isConst then\n    if t.constName! == s.constName! then isListLevelDefEqAux t.constLevels! s.constLevels! else return false\n  else if (\u2190 pure t.isApp <&&> pure s.isApp <&&> isDefEqApp t s) then\n    return true\n  else\n    whenUndefDo (isDefEqProjInst t s) do\n    whenUndefDo (isDefEqStringLit t s) do\n    if (\u2190 isDefEqUnitLike t s) then return true else\n    isDefEqOnFailure t s", "start": [1771, 1], "end": [1793, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DefEqCacheKind", "code": "inductive DefEqCacheKind where\n  | transient | permanent", "start": [1795, 1], "end": [1797, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getDefEqCacheKind", "code": "private def getDefEqCacheKind (t s : Expr) : MetaM DefEqCacheKind := do\n  if t.hasMVar || s.hasMVar || (\u2190 read).canUnfold?.isSome then\n    return .transient\n  else\n    return .permanent", "start": [1799, 1], "end": [1803, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DefEqCacheKeyInfo", "code": "structure DefEqCacheKeyInfo where\n  kind : DefEqCacheKind\n  key  : Expr \u00d7 Expr", "start": [1805, 1], "end": [1810, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkCacheKey", "code": "private def mkCacheKey (t s : Expr) : MetaM DefEqCacheKeyInfo := do\n  let kind \u2190 getDefEqCacheKind t s\n  let key := if Expr.quickLt t s then (t, s) else (s, t)\n  return { key, kind }", "start": [1812, 1], "end": [1815, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getCachedResult", "code": "private def getCachedResult (keyInfo : DefEqCacheKeyInfo) : MetaM LBool := do\n  let cache \u2190 match keyInfo.kind with\n    | .transient => pure (\u2190 get).cache.defEqTrans\n    | .permanent => pure (\u2190 get).cache.defEqPerm\n  let cache := match (\u2190 getTransparency) with\n    | .reducible => cache.reducible\n    | .instances => cache.instances\n    | .default   => cache.default\n    | .all       => cache.all\n  match cache.find? keyInfo.key with\n  | some val => return val.toLBool\n  | none => return .undef", "start": [1817, 1], "end": [1828, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DefEqCache.update", "code": "def DefEqCache.update (cache : DefEqCache) (mode : TransparencyMode) (key : Expr \u00d7 Expr) (result : Bool) : DefEqCache :=\n  match mode with\n  | .reducible => { cache with reducible := cache.reducible.insert key result }\n  | .instances => { cache with instances := cache.instances.insert key result }\n  | .default   => { cache with default   := cache.default.insert key result }\n  | .all       => { cache with all       := cache.all.insert key result }", "start": [1830, 1], "end": [1835, 74], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.cacheResult", "code": "private def cacheResult (keyInfo : DefEqCacheKeyInfo) (result : Bool) : MetaM Unit := do\n  let mode \u2190 getTransparency\n  let key := keyInfo.key\n  match keyInfo.kind with\n  | .permanent => modifyDefEqPermCache fun c => c.update mode key result\n  | .transient =>\n    \n    let key := (\u2190 instantiateMVars key.1, \u2190 instantiateMVars key.2)\n    modifyDefEqTransientCache fun c => c.update mode key result", "start": [1837, 1], "end": [1849, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.isExprDefEqAuxImpl", "code": "@[export lean_is_expr_def_eq]\npartial def isExprDefEqAuxImpl (t : Expr) (s : Expr) : MetaM Bool := withIncRecDepth do\n  withTraceNodeBefore `Meta.isDefEq (return m!\"{t} =?= {s}\") do\n  checkMaxHeartbeats \"isDefEq\"\n  whenUndefDo (isDefEqQuick t s) do\n  whenUndefDo (isDefEqProofIrrel t s) do\n  \n  let t' \u2190 whnfCore t\n  let s' \u2190 whnfCore s\n  if t != t' || s != s' then\n    isExprDefEqAuxImpl t' s'\n  else\n    \n    let t \u2190 instantiateMVars t\n    let s \u2190 instantiateMVars s\n    let numPostponed \u2190 getNumPostponed\n    let k \u2190 mkCacheKey t s\n    match (\u2190 getCachedResult k) with\n    | .true  =>\n      trace[Meta.isDefEq.cache] \"cache hit 'true' for {t} =?= {s}\"\n      return true\n    | .false =>\n      trace[Meta.isDefEq.cache] \"cache hit 'false' for {t} =?= {s}\"\n      return false\n    | .undef =>\n      let result \u2190 isExprDefEqExpensive t s\n      if numPostponed == (\u2190 getNumPostponed) then\n        trace[Meta.isDefEq.cache] \"cache {result} for {t} =?= {s}\"\n        cacheResult k result\n      return result", "start": [1851, 1], "end": [1894, 20], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/Inductive.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.compatibleCtors", "code": "def compatibleCtors (ctorName\u2081 ctorName\u2082 : Name) : MetaM Bool := do\n  let ctorInfo\u2081 \u2190 getConstInfoCtor ctorName\u2081\n  let ctorInfo\u2082 \u2190 getConstInfoCtor ctorName\u2082\n  if ctorInfo\u2081.induct != ctorInfo\u2082.induct then\n    return false\n  else\n    let (_, _, ctorType\u2081) \u2190 forallMetaTelescope ctorInfo\u2081.type\n    let (_, _, ctorType\u2082) \u2190 forallMetaTelescope ctorInfo\u2082.type\n    isDefEq ctorType\u2081 ctorType\u2082", "start": [12, 1], "end": [21, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/ExprLens.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/SubExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.lensCoord", "code": "private def lensCoord (g : Expr \u2192 M Expr) : Nat \u2192 Expr \u2192 M Expr\n  | 0, e@(Expr.app f a)         => return e.updateApp! (\u2190 g f) a\n  | 1, e@(Expr.app f a)         => return e.updateApp! f (\u2190 g a)\n  | 0, e@(Expr.lam _ y b _)     => return e.updateLambdaE! (\u2190 g y) b\n  | 1,   (Expr.lam n y b c)     => withLocalDecl n c y fun x => do mkLambdaFVars #[x] <|\u2190 g <| b.instantiateRev #[x]\n  | 0, e@(Expr.forallE _ y b _) => return e.updateForallE! (\u2190 g y) b\n  | 1,   (Expr.forallE n y b c) => withLocalDecl n c y fun x => do mkForallFVars #[x] <|\u2190 g <| b.instantiateRev #[x]\n  | 0, e@(Expr.letE _ y a b _)  => return e.updateLet! (\u2190 g y) a b\n  | 1, e@(Expr.letE _ y a b _)  => return e.updateLet! y (\u2190 g a) b\n  | 2,   (Expr.letE n y a b _)  => withLetDecl n y a fun x => do mkLetFVars #[x] <|\u2190 g <| b.instantiateRev #[x]\n  | 0, e@(Expr.proj _ _ b)      => e.updateProj! <$> g b\n  | n, e@(Expr.mdata _ a)       => e.updateMData! <$> lensCoord g n a\n  | 3, _                        => throwError \"Lensing on types is not supported\"\n  | c, e                        => throwError \"Invalid coordinate {c} for {e}\"", "start": [25, 1], "end": [43, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.lensAux", "code": "private def lensAux (g : Expr \u2192 M Expr) : List Nat \u2192 Expr \u2192 M Expr\n  | [], e => g e\n  | head::tail, e => lensCoord (lensAux g tail) head e", "start": [45, 1], "end": [47, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.replaceSubexpr", "code": "def replaceSubexpr (replace : (subexpr : Expr) \u2192 M Expr) (p : Pos) (root : Expr) : M Expr :=\n  lensAux replace p.toArray.toList root", "start": [49, 1], "end": [53, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.viewCoordAux", "code": "private def viewCoordAux (k : Array Expr \u2192 Expr \u2192 M \u03b1) (fvars: Array Expr) : Nat \u2192 Expr \u2192 M \u03b1\n  | 3, _                      => throwError \"Internal: Types should be handled by viewAux\"\n  | 0, (Expr.app f _)         => k fvars f\n  | 1, (Expr.app _ a)         => k fvars a\n  | 0, (Expr.lam _ y _ _)     => k fvars y\n  | 1, (Expr.lam n y b c)     => withLocalDecl n c (y.instantiateRev fvars) fun x => k (fvars.push x) b\n  | 0, (Expr.forallE _ y _ _) => k fvars y\n  | 1, (Expr.forallE n y b c) => withLocalDecl n c (y.instantiateRev fvars) fun x => k (fvars.push x) b\n  | 0, (Expr.letE _ y _ _ _)  => k fvars y\n  | 1, (Expr.letE _ _ a _ _)  => k fvars a\n  | 2, (Expr.letE n y a b _)  => withLetDecl n (y.instantiateRev fvars) (a.instantiateRev fvars) fun x => k (fvars.push x) b\n  | 0, (Expr.proj _ _ b)      => k fvars b\n  | n, (Expr.mdata _ a)       => viewCoordAux k fvars n a\n  | c, e                      => throwError \"Invalid coordinate {c} for {e}\"", "start": [55, 1], "end": [71, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.viewAux", "code": "private def viewAux (k : Array Expr \u2192 Expr \u2192 M \u03b1) (fvars : Array Expr) : List Nat \u2192 Expr \u2192 M \u03b1\n  | [],         e => k fvars <| e.instantiateRev fvars\n  | 3::tail,    e => do\n    let y \u2190 inferType <| e.instantiateRev fvars\n    viewAux (fun otherFvars => k (fvars ++ otherFvars)) #[] tail y\n  | head::tail, e => viewCoordAux (fun fvars => viewAux k fvars tail) fvars head e", "start": [73, 1], "end": [78, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.viewSubexpr", "code": "def viewSubexpr\n  (visit : (fvars : Array Expr) \u2192 (subexpr : Expr) \u2192 M \u03b1)\n  (p : Pos) (root : Expr) :  M \u03b1 :=\n   viewAux visit #[] p.toArray.toList root", "start": [80, 1], "end": [87, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.foldAncestorsAux", "code": "private def foldAncestorsAux\n  (k : Array Expr \u2192 Expr \u2192 Nat \u2192 \u03b1 \u2192 M \u03b1)\n  (acc : \u03b1) (address : List Nat) (fvars : Array Expr) (current : Expr) : M \u03b1 :=\n  match address with\n  | [] => return acc\n  | 3 :: tail => do\n    let current := current.instantiateRev fvars\n    let y \u2190 inferType current\n    let acc \u2190 k fvars current 3 acc\n    foldAncestorsAux (fun otherFvars => k (fvars ++ otherFvars)) acc tail #[] y\n  | head :: tail => do\n    let acc \u2190 k fvars (current.instantiateRev fvars) head acc\n    viewCoordAux (foldAncestorsAux k acc tail) fvars head current", "start": [89, 1], "end": [101, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.foldAncestors", "code": "def foldAncestors\n  (k : (fvars: Array Expr) \u2192 (subexpr : Expr) \u2192 (nextCoord : Nat) \u2192 \u03b1 \u2192 M \u03b1)\n  (init : \u03b1) (p : Pos) (e : Expr) : M \u03b1 :=\n  foldAncestorsAux k init p.toArray.toList #[] e", "start": [103, 1], "end": [109, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.viewCoordRaw", "code": "private def viewCoordRaw: Expr \u2192 Nat \u2192 M Expr\n  | e                     , 3 => throwError \"Can't viewRaw the type of {e}\"\n  | (Expr.app f _)        , 0 => pure f\n  | (Expr.app _ a)        , 1 => pure a\n  | (Expr.lam _ y _ _)    , 0 => pure y\n  | (Expr.lam _ _ b _)    , 1 => pure b\n  | (Expr.forallE _ y _ _), 0 => pure y\n  | (Expr.forallE _ _ b _), 1 => pure b\n  | (Expr.letE _ y _ _ _) , 0 => pure y\n  | (Expr.letE _ _ a _ _) , 1 => pure a\n  | (Expr.letE _ _ _ b _) , 2 => pure b\n  | (Expr.proj _ _ b)     , 0 => pure b\n  | (Expr.mdata _ a)      , n => viewCoordRaw a n\n  | e                     , c => throwError \"Bad coordinate {c} for {e}\"", "start": [123, 1], "end": [137, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.viewSubexpr", "code": "def viewSubexpr (p : Pos) (root : Expr) : M Expr :=\n  p.foldlM viewCoordRaw root", "start": [140, 1], "end": [147, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.viewBindersCoord", "code": "private def viewBindersCoord : Nat \u2192 Expr \u2192 Option (Name \u00d7 Expr)\n  | 1, (Expr.lam n y _ _)     => some (n, y)\n  | 1, (Expr.forallE n y _ _) => some (n, y)\n  | 2, (Expr.letE n y _ _ _)  => some (n, y)\n  | _, _                      => none", "start": [149, 1], "end": [153, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.viewBinders", "code": "def viewBinders (p : Pos) (root : Expr) : M (Array (Name \u00d7 Expr)) := do\n  let (acc, _) \u2190 p.foldlM (fun (acc, e) c => do\n    let e\u2082 \u2190 viewCoordRaw e c\n    let acc :=\n      match viewBindersCoord c e with\n      | none => acc\n      | some b => acc.push b\n    return (acc, e\u2082)\n  ) (#[], root)\n  return acc", "start": [155, 1], "end": [165, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Core.numBinders", "code": "def numBinders (p : Pos) (e : Expr) : M Nat :=\n  Array.size <$> viewBinders p e", "start": [167, 1], "end": [169, 33], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta/AbstractNestedProofs.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Closure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.AbstractNestedProofs.getLambdaBody", "code": "def getLambdaBody (e : Expr) : Expr :=\n  match e with\n  | .lam _ _ b _ => getLambdaBody b\n  | _ => e", "start": [11, 1], "end": [14, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractNestedProofs.isNonTrivialProof", "code": "def isNonTrivialProof (e : Expr) : MetaM Bool := do\n  if !(\u2190 isProof e) then\n    pure false\n  else\n    (getLambdaBody e).withApp fun f args =>\n      pure $ !f.isAtomic || args.any fun arg => !arg.isAtomic", "start": [16, 1], "end": [23, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractNestedProofs.Context", "code": "structure Context where\n  baseName : Name", "start": [25, 1], "end": [26, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractNestedProofs.State", "code": "structure State where\n  nextIdx : Nat := 1", "start": [28, 1], "end": [29, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractNestedProofs.M", "code": "abbrev M := ReaderT Context $ MonadCacheT ExprStructEq Expr $ StateRefT State MetaM", "start": [31, 1], "end": [31, 84], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractNestedProofs.mkAuxLemma", "code": "private def mkAuxLemma (e : Expr) : M Expr := do\n  let ctx \u2190 read\n  let s \u2190 get\n  let lemmaName \u2190 mkAuxName (ctx.baseName ++ `proof) s.nextIdx\n  modify fun s => { s with nextIdx := s.nextIdx + 1 }\n  \n  mkAuxTheoremFor lemmaName e (zeta := true)", "start": [33, 1], "end": [41, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.AbstractNestedProofs.visit", "code": "partial def visit (e : Expr) : M Expr := do\n  if e.isAtomic then\n    pure e\n  else\n    let visitBinders (xs : Array Expr) (k : M Expr) : M Expr := do\n      let localInstances \u2190 getLocalInstances\n      let mut lctx \u2190 getLCtx\n      for x in xs do\n        let xFVarId := x.fvarId!\n        let localDecl \u2190 xFVarId.getDecl\n        let type      \u2190 visit localDecl.type\n        let localDecl := localDecl.setType type\n        let localDecl \u2190 match localDecl.value? with\n           | some value => let value \u2190 visit value; pure <| localDecl.setValue value\n           | none       => pure localDecl\n        lctx :=lctx.modifyLocalDecl xFVarId fun _ => localDecl\n      withLCtx lctx localInstances k\n    checkCache { val := e : ExprStructEq } fun _ => do\n      if (\u2190 isNonTrivialProof e) then\n        mkAuxLemma e\n      else match e with\n        | .lam ..      => lambdaLetTelescope e fun xs b => visitBinders xs do mkLambdaFVars xs (\u2190 visit b) (usedLetOnly := false)\n        | .letE ..     => lambdaLetTelescope e fun xs b => visitBinders xs do mkLambdaFVars xs (\u2190 visit b) (usedLetOnly := false)\n        | .forallE ..  => forallTelescope e fun xs b => visitBinders xs do mkForallFVars xs (\u2190 visit b)\n        | .mdata _ b   => return e.updateMData! (\u2190 visit b)\n        | .proj _ _ b  => return e.updateProj! (\u2190 visit b)\n        | .app ..      => e.withApp fun f args => return mkAppN f (\u2190 args.mapM visit)\n        | _            => pure e", "start": [43, 1], "end": [70, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.abstractNestedProofs", "code": "def abstractNestedProofs (mainDeclName : Name) (e : Expr) : MetaM Expr :=\n  AbstractNestedProofs.visit e |>.run { baseName := mainDeclName } |>.run |>.run' { nextIdx := 1 }", "start": [74, 1], "end": [76, 99], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/BuiltinNotation.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/KAbstract.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/MatchUtil.lean", "lake-packages/lean4/src/lean/Lean/Elab/SyntheticMVars.lean", "lake-packages/lean4/src/lean/Lean/Compiler/BorrowedAnnotation.lean"], "premises": [{"full_name": "Lean.Elab.Term.elabCoe", "code": "@[builtin_term_elab coeNotation] def elabCoe : TermElab := fun stx expectedType? => do\n  let stx := stx[1]\n  tryPostponeIfNoneOrMVar expectedType?\n  let e \u2190 elabTerm stx none\n  if expectedType?.isNone then\n    throwError \"invalid coercion notation, expected type is not known\"\n  ensureHasType expectedType? e", "start": [14, 1], "end": [20, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabAnonymousCtor", "code": "@[builtin_term_elab anonymousCtor] def elabAnonymousCtor : TermElab := fun stx expectedType? =>\n  match stx with\n  | `(\u27e8$args,*\u27e9) => do\n    tryPostponeIfNoneOrMVar expectedType?\n    match expectedType? with\n    | some expectedType =>\n      let expectedType \u2190 whnf expectedType\n      matchConstInduct expectedType.getAppFn\n        (fun _ => throwError \"invalid constructor \u27e8...\u27e9, expected type must be an inductive type {indentExpr expectedType}\")\n        (fun ival _ => do\n          match ival.ctors with\n          | [ctor] =>\n            if isPrivateNameFromImportedModule (\u2190 getEnv) ctor then\n              throwError \"invalid \u27e8...\u27e9 notation, constructor for `{ival.name}` is marked as private\"\n            let cinfo \u2190 getConstInfoCtor ctor\n            let numExplicitFields \u2190 forallTelescopeReducing cinfo.type fun xs _ => do\n              let mut n := 0\n              for i in [cinfo.numParams:xs.size] do\n                if (\u2190 getFVarLocalDecl xs[i]!).binderInfo.isExplicit then\n                  n := n + 1\n              return n\n            let args := args.getElems\n            if args.size < numExplicitFields then\n              throwError \"invalid constructor \u27e8...\u27e9, insufficient number of arguments, constructs '{ctor}' has #{numExplicitFields} explicit fields, but only #{args.size} provided\"\n            let newStx \u2190 if args.size == numExplicitFields then\n              `($(mkCIdentFrom stx ctor (canonical := true)) $(args)*)\n            else if numExplicitFields == 0 then\n              throwError \"invalid constructor \u27e8...\u27e9, insufficient number of arguments, constructs '{ctor}' does not have explicit fields, but #{args.size} provided\"\n            else\n              let extra := args[numExplicitFields-1:args.size]\n              let newLast \u2190 `(\u27e8$[$extra],*\u27e9)\n              let newArgs := args[0:numExplicitFields-1].toArray.push newLast\n              `($(mkCIdentFrom stx ctor (canonical := true)) $(newArgs)*)\n            withMacroExpansion stx newStx $ elabTerm newStx expectedType?\n          | _ => throwError \"invalid constructor \u27e8...\u27e9, expected type must be an inductive type with only one constructor {indentExpr expectedType}\")\n    | none => throwError \"invalid constructor \u27e8...\u27e9, expected type must be known\"\n  | _ => throwUnsupportedSyntax", "start": [22, 1], "end": [58, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabBorrowed", "code": "@[builtin_term_elab borrowed] def elabBorrowed : TermElab := fun stx expectedType? =>\n  match stx with\n  | `(@& $e) => return markBorrowed (\u2190 elabTerm e expectedType?)\n  | _ => throwUnsupportedSyntax", "start": [60, 1], "end": [63, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandShow", "code": "@[builtin_macro Lean.Parser.Term.show] def expandShow : Macro := fun stx =>\n  match stx with\n  | `(show $type by%$b $tac) => `(show $type from by%$b $tac)\n  | _                        => Macro.throwUnsupported", "start": [65, 1], "end": [68, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabShow", "code": "@[builtin_term_elab Lean.Parser.Term.show] def elabShow : TermElab := fun stx expectedType? => do\n  match stx with\n  | `(show $type from $val)  =>\n    \n    let type \u2190 withSynthesize (mayPostpone := true) do\n      let type \u2190 elabType type\n      if let some expectedType := expectedType? then\n        discard <| isDefEq expectedType type\n      return type\n    \n    let thisId := mkIdentFrom stx `this\n    let valNew \u2190 `(let_fun $thisId : $(\u2190 exprToSyntax type) := $val; $thisId)\n    elabTerm valNew expectedType?\n  | _ => throwUnsupportedSyntax", "start": [70, 1], "end": [103, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandHave", "code": "@[builtin_macro Lean.Parser.Term.have] def expandHave : Macro := fun stx =>\n  match stx with\n  | `(have $hy:hygieneInfo $bs* $[: $type]? := $val; $body) =>\n    `(have $(HygieneInfo.mkIdent hy `this (canonical := true)) $bs* $[: $type]? := $val; $body)\n  | `(have $hy:hygieneInfo $bs* $[: $type]? $alts; $body)   =>\n    `(have $(HygieneInfo.mkIdent hy `this (canonical := true)) $bs* $[: $type]? $alts; $body)\n  | `(have $x:ident $bs* $[: $type]? := $val; $body) => `(let_fun $x $bs* $[: $type]? := $val; $body)\n  | `(have $x:ident $bs* $[: $type]? $alts; $body)   => `(let_fun $x $bs* $[: $type]? $alts; $body)\n  | `(have _%$x     $bs* $[: $type]? := $val; $body) => `(let_fun _%$x $bs* $[: $type]? := $val; $body)\n  | `(have _%$x     $bs* $[: $type]? $alts; $body)   => `(let_fun _%$x $bs* $[: $type]? $alts; $body)\n  | `(have $pattern:term $[: $type]? := $val; $body) => `(let_fun $pattern:term $[: $type]? := $val; $body)\n  | _                                                => Macro.throwUnsupported", "start": [105, 1], "end": [116, 79], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandSuffices", "code": "@[builtin_macro Lean.Parser.Term.suffices] def expandSuffices : Macro\n  | `(suffices%$tk $x:ident      : $type from $val; $body)            => `(have%$tk $x : $type := $body; $val)\n  | `(suffices%$tk _%$x          : $type from $val; $body)            => `(have%$tk _%$x : $type := $body; $val)\n  | `(suffices%$tk $hy:hygieneInfo $type from $val; $body)            => `(have%$tk $hy:hygieneInfo : $type := $body; $val)\n  | `(suffices%$tk $x:ident      : $type by%$b $tac:tacticSeq; $body) => `(have%$tk $x : $type := $body; by%$b $tac)\n  | `(suffices%$tk _%$x          : $type by%$b $tac:tacticSeq; $body) => `(have%$tk _%$x : $type := $body; by%$b $tac)\n  | `(suffices%$tk $hy:hygieneInfo $type by%$b $tac:tacticSeq; $body) => `(have%$tk $hy:hygieneInfo : $type := $body; by%$b $tac)\n  | _                                                                 => Macro.throwUnsupported", "start": [118, 1], "end": [125, 96], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabParserMacroAux", "code": "private def elabParserMacroAux (prec e : Term) (withAnonymousAntiquot : Bool) : TermElabM Syntax := do\n  let (some declName) \u2190 getDeclName?\n    | throwError \"invalid `leading_parser` macro, it must be used in definitions\"\n  match extractMacroScopes declName with\n  | { name := .str _ s, .. } =>\n    let kind := quote declName\n    let mut p \u2190 ``(withAntiquot\n      (mkAntiquot $(quote s) $kind $(quote withAnonymousAntiquot))\n      (leadingNode $kind $prec $e))\n    if (\u2190 getLCtx).all (\u00b7.isAuxDecl) then\n      p \u2190 ``(withCache $kind $p)\n    return p\n  | _  => throwError \"invalid `leading_parser` macro, unexpected declaration name\"", "start": [128, 1], "end": [141, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabLeadingParserMacro", "code": "@[builtin_term_elab \u00ableading_parser\u00bb] def elabLeadingParserMacro : TermElab :=\n  adaptExpander fun\n    | `(leading_parser $[: $prec?]? $[(withAnonymousAntiquot := $anon?)]? $e) =>\n        elabParserMacroAux (prec?.getD (quote Parser.maxPrec)) e (anon?.all (\u00b7.raw.isOfKind ``Parser.Term.trueVal))\n    | _ => throwUnsupportedSyntax", "start": [143, 1], "end": [147, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabTParserMacroAux", "code": "private def elabTParserMacroAux (prec lhsPrec e : Term) : TermElabM Syntax := do\n  let declName? \u2190 getDeclName?\n  match declName? with\n  | some declName => let kind := quote declName; ``(Lean.Parser.trailingNode $kind $prec $lhsPrec $e)\n  | none          => throwError \"invalid `trailing_parser` macro, it must be used in definitions\"", "start": [149, 1], "end": [153, 98], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabTrailingParserMacro", "code": "@[builtin_term_elab \u00abtrailing_parser\u00bb] def elabTrailingParserMacro : TermElab :=\n  adaptExpander fun stx => match stx with\n  | `(trailing_parser$[:$prec?]?$[:$lhsPrec?]? $e) =>\n    elabTParserMacroAux (prec?.getD <| quote Parser.maxPrec) (lhsPrec?.getD <| quote 0) e\n  | _ => throwUnsupportedSyntax", "start": [155, 1], "end": [159, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabPanic", "code": "@[builtin_term_elab Lean.Parser.Term.panic] def elabPanic : TermElab := fun stx expectedType? => do\n  match stx with\n  | `(panic! $arg) =>\n    let pos \u2190 getRefPosition\n    let env \u2190 getEnv\n    let stxNew \u2190 match (\u2190 getDeclName?) with\n    | some declName => `(panicWithPosWithDecl $(quote (toString env.mainModule)) $(quote (toString declName)) $(quote pos.line) $(quote pos.column) $arg)\n    | none => `(panicWithPos $(quote (toString env.mainModule)) $(quote pos.line) $(quote pos.column) $arg)\n    withMacroExpansion stx stxNew $ elabTerm stxNew expectedType?\n  | _ => throwUnsupportedSyntax", "start": [161, 1], "end": [170, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandUnreachable", "code": "@[builtin_macro Lean.Parser.Term.unreachable]  def expandUnreachable : Macro := fun _ =>\n  `(panic! \"unreachable code has been reached\")", "start": [172, 1], "end": [173, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandAssert", "code": "@[builtin_macro Lean.Parser.Term.assert]  def expandAssert : Macro\n  | `(assert! $cond; $body) =>\n    match cond.raw.reprint with\n    | some code => `(if $cond then $body else panic! (\"assertion violation: \" ++ $(quote code)))\n    | none => `(if $cond then $body else panic! (\"assertion violation\"))\n  | _ => Macro.throwUnsupported", "start": [175, 1], "end": [181, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandDbgTrace", "code": "@[builtin_macro Lean.Parser.Term.dbgTrace]  def expandDbgTrace : Macro\n  | `(dbg_trace $arg:interpolatedStr; $body) => `(dbgTrace (s! $arg) fun _ => $body)\n  | `(dbg_trace $arg:term; $body)            => `(dbgTrace (toString $arg) fun _ => $body)\n  | _                                        => Macro.throwUnsupported", "start": [183, 1], "end": [186, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabSorry", "code": "@[builtin_term_elab \u00absorry\u00bb] def elabSorry : TermElab := fun stx expectedType? => do\n  let stxNew \u2190 `(sorryAx _ false)\n  withMacroExpansion stx stxNew <| elabTerm stxNew expectedType?", "start": [188, 1], "end": [190, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.mkPairs", "code": "partial def mkPairs (elems : Array Term) : MacroM Term :=\n  let rec loop (i : Nat) (acc : Term) := do\n    if i > 0 then\n      let i    := i - 1\n      let elem := elems[i]!\n      let acc \u2190 `(Prod.mk $elem $acc)\n      loop i acc\n    else\n      pure acc\n  loop (elems.size - 1) elems.back", "start": [192, 1], "end": [202, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.hasCDot", "code": "partial def hasCDot : Syntax \u2192 Bool\n  | Syntax.node _ k args =>\n    if k == ``Term.paren || k == ``Term.typeAscription || k == ``Term.tuple then false\n    else if k == ``Term.cdot then true\n    else args.any hasCDot\n  | _ => false", "start": [205, 1], "end": [210, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandCDot?", "code": "partial def expandCDot? (stx : Term) : MacroM (Option Term) := do\n  if hasCDot stx then\n    let (newStx, binders) \u2190 (go stx).run #[]\n    `(fun $binders* => $(\u27e8newStx\u27e9))\n  else\n    pure none\nwhere\n  \n  go : Syntax \u2192 StateT (Array Ident) MacroM Syntax\n    | stx@`(($(_))) => pure stx\n    | stx@`(\u00b7) => withFreshMacroScope do\n      let id \u2190 mkFreshIdent stx (canonical := true)\n      modify (\u00b7.push id)\n      pure id\n    | stx => match stx with\n      | .node _ k args => do\n        let args \u2190 args.mapM go\n        return .node (.fromRef stx (canonical := true)) k args\n      | _ => pure stx", "start": [212, 1], "end": [240, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabCDotFunctionAlias?", "code": "def elabCDotFunctionAlias? (stx : Term) : TermElabM (Option Expr) := do\n  let some stx \u2190 liftMacroM <| expandCDotArg? stx | pure none\n  let stx \u2190 liftMacroM <| expandMacros stx\n  match stx with\n  | `(fun $binders* => $f $args*) =>\n    if binders == args then\n      try Term.resolveId? f catch _ => return none\n    else\n      return none\n  | `(fun $binders* => binop% $f $a $b) =>\n    if binders == #[a, b] then\n      try Term.resolveId? f catch _ => return none\n    else\n      return none\n  | _ => return none\nwhere\n  expandCDotArg? (stx : Term) : MacroM (Option Term) :=\n    match stx with\n    | `(($e)) => Term.expandCDot? e\n    | _ => Term.expandCDot? stx", "start": [242, 1], "end": [265, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandParen", "code": "@[builtin_macro Lean.Parser.Term.paren] def expandParen : Macro\n  | `(($e)) => return (\u2190 expandCDot? e).getD e\n  | _       => Macro.throwUnsupported", "start": [267, 1], "end": [269, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandTuple", "code": "@[builtin_macro Lean.Parser.Term.tuple] def expandTuple : Macro\n  | `(()) => ``(Unit.unit)\n  | `(($e, $es,*)) => do\n    let pairs \u2190 mkPairs (#[e] ++ es)\n    return (\u2190 expandCDot? pairs).getD pairs\n  | _ => Macro.throwUnsupported", "start": [271, 1], "end": [276, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.expandTypeAscription", "code": "@[builtin_macro Lean.Parser.Term.typeAscription] def expandTypeAscription : Macro\n  | `(($e : $(type)?)) => do\n    match (\u2190 expandCDot? e) with\n    | some e => `(($e : $(type)?))\n    | none   => Macro.throwUnsupported\n  | _ => Macro.throwUnsupported", "start": [278, 1], "end": [283, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabTypeAscription", "code": "@[builtin_term_elab typeAscription] def elabTypeAscription : TermElab\n  | `(($e : $type)), _ => do\n    let type \u2190 withSynthesize (mayPostpone := true) <| elabType type\n    let e \u2190 elabTerm e type\n    ensureHasType type e\n  | `(($e :)), expectedType? => do\n    let e \u2190 withSynthesize (mayPostpone := false) <| elabTerm e none\n    ensureHasType expectedType? e\n  | _, _ => throwUnsupportedSyntax", "start": [285, 1], "end": [293, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.isSubstCandidate", "code": "private def isSubstCandidate (lhs rhs : Expr) : MetaM Bool :=\n  if lhs.isFVar then\n    return !(\u2190 dependsOn rhs lhs.fvarId!)\n  else\n    return false", "start": [295, 1], "end": [300, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.withLocalIdentFor", "code": "private def withLocalIdentFor (stx : Term) (e : Expr) (k : Term \u2192 TermElabM Expr) : TermElabM Expr := do\n  if e.isFVar then\n    k stx\n  else\n    let id \u2190 mkFreshUserName `h\n    let aux \u2190 withLocalDeclD id (\u2190 inferType e) fun x => do mkLambdaFVars #[x] (\u2190 k (mkIdentFrom stx id))\n    return mkApp aux e", "start": [302, 1], "end": [312, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabSubst", "code": "@[builtin_term_elab subst] def elabSubst : TermElab := fun stx expectedType? => do\n  let expectedType? \u2190 tryPostponeIfHasMVars? expectedType?\n  match stx with\n  | `($heqStx \u25b8 $hStx) => do\n     synthesizeSyntheticMVars\n     let mut heq \u2190 withSynthesize <| elabTerm heqStx none\n     let heqType \u2190 inferType heq\n     let heqType \u2190 instantiateMVars heqType\n     match (\u2190 Meta.matchEq? heqType) with\n     | none => throwError \"invalid `\u25b8` notation, argument{indentExpr heq}\\nhas type{indentExpr heqType}\\nequality expected\"\n     | some (\u03b1, lhs, rhs) =>\n       let mut lhs := lhs\n       let mut rhs := rhs\n       let mkMotive (lhs typeWithLooseBVar : Expr) := do\n         withLocalDeclD (\u2190 mkFreshUserName `x) \u03b1 fun x => do\n           withLocalDeclD (\u2190 mkFreshUserName `h) (\u2190 mkEq lhs x) fun h => do\n             mkLambdaFVars #[x, h] $ typeWithLooseBVar.instantiate1 x\n       match expectedType? with\n       | some expectedType =>\n         let mut expectedAbst \u2190 kabstract expectedType rhs\n         unless expectedAbst.hasLooseBVars do\n           expectedAbst \u2190 kabstract expectedType lhs\n           unless expectedAbst.hasLooseBVars do\n             throwError \"invalid `\u25b8` notation, expected result type of cast is {indentExpr expectedType}\\nhowever, the equality {indentExpr heq}\\nof type {indentExpr heqType}\\ndoes not contain the expected result type on either the left or the right hand side\"\n           heq \u2190 mkEqSymm heq\n           (lhs, rhs) := (rhs, lhs)\n         let hExpectedType := expectedAbst.instantiate1 lhs\n         let (h, badMotive?) \u2190 withRef hStx do\n           let h \u2190 elabTerm hStx hExpectedType\n           try\n             return (\u2190 ensureHasType hExpectedType h, none)\n           catch ex =>\n             let hType \u2190 inferType h\n             let hTypeAbst \u2190 kabstract hType rhs\n             unless hTypeAbst.hasLooseBVars do\n               throw ex\n             let hTypeNew := hTypeAbst.instantiate1 lhs\n             unless (\u2190 isDefEq hExpectedType hTypeNew) do\n               throw ex\n             let motive \u2190 mkMotive rhs hTypeAbst\n             if !(\u2190 isTypeCorrect motive) then\n               return (h, some motive)\n             else\n               return (\u2190 mkEqRec motive h (\u2190 mkEqSymm heq), none)\n         let motive \u2190 mkMotive lhs expectedAbst\n         if badMotive?.isSome || !(\u2190 isTypeCorrect motive) then\n           if \u2190 (isSubstCandidate lhs rhs <||> isSubstCandidate rhs lhs) then\n             withLocalIdentFor heqStx heq fun heqStx => do\n               let h \u2190 instantiateMVars h\n               if h.hasMVar then\n                 let stxNew \u2190 `(by subst $heqStx; exact $hStx)\n                 withMacroExpansion stx stxNew (elabTerm stxNew expectedType)\n               else\n                 withLocalIdentFor hStx h fun hStx => do\n                   let stxNew \u2190 `(by subst $heqStx; exact $hStx)\n                   withMacroExpansion stx stxNew (elabTerm stxNew expectedType)\n           else\n             throwError \"invalid `\u25b8` notation, failed to compute motive for the substitution\"\n         else\n           mkEqRec motive h heq\n       | none =>\n         let h \u2190 elabTerm hStx none\n         let hType \u2190 inferType h\n         let hTypeAbst \u2190 kabstract hType lhs\n         let motive \u2190 mkMotive lhs hTypeAbst\n         unless (\u2190 isTypeCorrect motive) do\n           throwError \"invalid `\u25b8` notation, failed to compute motive for the substitution\"\n         mkEqRec motive h heq\n  | _ => throwUnsupportedSyntax", "start": [314, 1], "end": [386, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabStateRefT", "code": "@[builtin_term_elab stateRefT] def elabStateRefT : TermElab := fun stx _ => do\n  let \u03c3 \u2190 elabType stx[1]\n  let mut mStx := stx[2]\n  if mStx.getKind == ``Lean.Parser.Term.macroDollarArg then\n    mStx := mStx[1]\n  let m \u2190 elabTerm mStx (\u2190 mkArrow (mkSort levelOne) (mkSort levelOne))\n  let \u03c9 \u2190 mkFreshExprMVar (mkSort levelOne)\n  let stWorld \u2190 mkAppM ``STWorld #[\u03c9, m]\n  discard <| mkInstMVar stWorld\n  mkAppM ``StateRefT' #[\u03c9, \u03c3, m]", "start": [388, 1], "end": [397, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.elabNoindex", "code": "@[builtin_term_elab noindex] def elabNoindex : TermElab := fun stx expectedType? => do\n  let e \u2190 elabTerm stx[1] expectedType?\n  return DiscrTree.mkNoindexAnnotation e", "start": [399, 1], "end": [401, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/ConfigOptions.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/LCtx.lean", "lake-packages/lean4/src/lean/Lean/CoreM.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Basic.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.Phase", "code": "inductive Phase where\n  \n  | base\n  \n  | mono\n  \n  | impure\n  deriving Inhabited", "start": [12, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CompilerM.State", "code": "structure CompilerM.State where\n  \n  lctx     : LCtx := {}\n  \n  nextIdx : Nat := 1\n  deriving Inhabited", "start": [25, 1], "end": [36, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CompilerM.Context", "code": "structure CompilerM.Context where\n  phase : Phase\n  config : ConfigOptions\n  deriving Inhabited", "start": [38, 1], "end": [41, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CompilerM", "code": "abbrev CompilerM := ReaderT CompilerM.Context $ StateRefT CompilerM.State CoreM", "start": [43, 1], "end": [43, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.withPhase", "code": "@[inline] def withPhase (phase : Phase) (x : CompilerM \u03b1) : CompilerM \u03b1 :=\n  withReader (fun ctx => { ctx with phase }) x", "start": [48, 1], "end": [49, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getPhase", "code": "def getPhase : CompilerM Phase :=\n  return (\u2190 read).phase", "start": [51, 1], "end": [52, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.inBasePhase", "code": "def inBasePhase : CompilerM Bool :=\n  return (\u2190 getPhase) matches .base", "start": [54, 1], "end": [55, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getType", "code": "def getType (fvarId : FVarId) : CompilerM Expr := do\n  let lctx := (\u2190 get).lctx\n  if let some decl := lctx.letDecls.find? fvarId then\n    return decl.type\n  else if let some decl := lctx.params.find? fvarId then\n    return decl.type\n  else if let some decl := lctx.funDecls.find? fvarId then\n    return decl.type\n  else\n    throwError \"unknown free variable {fvarId.name}\"", "start": [64, 1], "end": [73, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getBinderName", "code": "def getBinderName (fvarId : FVarId) : CompilerM Name := do\n  let lctx := (\u2190 get).lctx\n  if let some decl := lctx.letDecls.find? fvarId then\n    return decl.binderName\n  else if let some decl := lctx.params.find? fvarId then\n    return decl.binderName\n  else if let some decl := lctx.funDecls.find? fvarId then\n    return decl.binderName\n  else\n    throwError \"unknown free variable {fvarId.name}\"", "start": [75, 1], "end": [84, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.findParam?", "code": "def findParam? (fvarId : FVarId) : CompilerM (Option Param) :=\n  return (\u2190 get).lctx.params.find? fvarId", "start": [86, 1], "end": [87, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.findLetDecl?", "code": "def findLetDecl? (fvarId : FVarId) : CompilerM (Option LetDecl) :=\n  return (\u2190 get).lctx.letDecls.find? fvarId", "start": [89, 1], "end": [90, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.findFunDecl?", "code": "def findFunDecl? (fvarId : FVarId) : CompilerM (Option FunDecl) :=\n  return (\u2190 get).lctx.funDecls.find? fvarId", "start": [92, 1], "end": [93, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.findLetValue?", "code": "def findLetValue? (fvarId : FVarId) : CompilerM (Option LetValue) := do\n  let some { value, .. } \u2190 findLetDecl? fvarId | return none\n  return some value", "start": [95, 1], "end": [97, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isConstructorApp", "code": "def isConstructorApp (fvarId : FVarId) : CompilerM Bool := do\n  let some (.const declName _ _) \u2190 findLetValue? fvarId | return false\n  return (\u2190 getEnv).find? declName matches some (.ctorInfo ..)", "start": [99, 1], "end": [101, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Arg.isConstructorApp", "code": "def Arg.isConstructorApp (arg : Arg) : CompilerM Bool := do\n  let .fvar fvarId := arg | return false\n  LCNF.isConstructorApp fvarId", "start": [103, 1], "end": [105, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getParam", "code": "def getParam (fvarId : FVarId) : CompilerM Param := do\n  let some param \u2190 findParam? fvarId | throwError \"unknown parameter {fvarId.name}\"\n  return param", "start": [107, 1], "end": [109, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getLetDecl", "code": "def getLetDecl (fvarId : FVarId) : CompilerM LetDecl := do\n  let some decl \u2190 findLetDecl? fvarId | throwError \"unknown let-declaration {fvarId.name}\"\n  return decl", "start": [111, 1], "end": [113, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getFunDecl", "code": "def getFunDecl (fvarId : FVarId) : CompilerM FunDecl := do\n  let some decl \u2190 findFunDecl? fvarId | throwError \"unknown local function {fvarId.name}\"\n  return decl", "start": [115, 1], "end": [117, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.modifyLCtx", "code": "@[inline] def modifyLCtx (f : LCtx \u2192 LCtx) : CompilerM Unit := do\n   modify fun s => { s with lctx := f s.lctx }", "start": [119, 1], "end": [120, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eraseLetDecl", "code": "def eraseLetDecl (decl : LetDecl) : CompilerM Unit := do\n  modifyLCtx fun lctx => lctx.eraseLetDecl decl", "start": [122, 1], "end": [123, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eraseFunDecl", "code": "def eraseFunDecl (decl : FunDecl) (recursive := true) : CompilerM Unit := do\n  modifyLCtx fun lctx => lctx.eraseFunDecl decl recursive", "start": [125, 1], "end": [126, 58], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eraseCode", "code": "def eraseCode (code : Code) : CompilerM Unit := do\n  modifyLCtx fun lctx => lctx.eraseCode code", "start": [128, 1], "end": [129, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eraseParam", "code": "def eraseParam (param : Param) : CompilerM Unit :=\n  modifyLCtx fun lctx => lctx.eraseParam param", "start": [131, 1], "end": [132, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eraseParams", "code": "def eraseParams (params : Array Param) : CompilerM Unit :=\n  modifyLCtx fun lctx => lctx.eraseParams params", "start": [134, 1], "end": [135, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eraseCodeDecl", "code": "def eraseCodeDecl (decl : CodeDecl) : CompilerM Unit := do\n  match decl with\n  | .let decl => eraseLetDecl decl\n  | .jp decl | .fun decl => eraseFunDecl decl", "start": [137, 1], "end": [140, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eraseCodeDecls", "code": "def eraseCodeDecls (decls : Array CodeDecl) : CompilerM Unit := do\n  decls.forM fun decl => eraseCodeDecl decl", "start": [142, 1], "end": [146, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.eraseDecl", "code": "def eraseDecl (decl : Decl) : CompilerM Unit := do\n  eraseParams decl.params\n  eraseCode decl.value", "start": [148, 1], "end": [150, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Decl.erase", "code": "abbrev Decl.erase (decl : Decl) : CompilerM Unit :=\n  eraseDecl decl", "start": [152, 1], "end": [153, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FVarSubst", "code": "abbrev FVarSubst := HashMap FVarId Expr", "start": [155, 1], "end": [168, 40], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normExprImp", "code": "private partial def normExprImp (s : FVarSubst) (e : Expr) (translator : Bool) : Expr :=\n  go e\nwhere\n  goApp (e : Expr) : Expr :=\n    match e with\n    | .app f a => e.updateApp! (goApp f) (go a)\n    | _ => go e\n\n  go (e : Expr) : Expr :=\n    if e.hasFVar then\n      match e with\n      | .fvar fvarId => match s.find? fvarId with\n        | some e => if translator then e else go e\n        | none => e\n      | .lit .. | .const .. | .sort .. | .mvar .. | .bvar .. => e\n      | .app f a => e.updateApp! (goApp f) (go a) |>.headBeta\n      | .mdata _ b => e.updateMData! (go b)\n      | .proj _ _ b => e.updateProj! (go b)\n      | .forallE _ d b _ => e.updateForallE! (go d) (go b)\n      | .lam _ d b _ => e.updateLambdaE! (go d) (go b)\n      | .letE .. => unreachable! else\n      e", "start": [170, 1], "end": [203, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.NormFVarResult", "code": "inductive NormFVarResult where\n  | \n    fvar (fvarId : FVarId)\n  | \n    erased\n  deriving Inhabited", "start": [205, 1], "end": [215, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normFVarImp", "code": "private partial def normFVarImp (s : FVarSubst) (fvarId : FVarId) (translator : Bool) : NormFVarResult :=\n  match s.find? fvarId with\n  | some (.fvar fvarId') =>\n    if translator then\n      .fvar fvarId'\n    else\n      normFVarImp s fvarId' translator\n  | some e =>\n    if e.isErased then\n      .erased\n    else\n      panic! s!\"invalid LCNF substitution of free variable with expression {e}\"\n  | none => .fvar fvarId", "start": [217, 1], "end": [237, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normArgImp", "code": "private partial def normArgImp (s : FVarSubst) (arg : Arg) (translator : Bool) : Arg :=\n  match arg with\n  | .erased => arg\n  | .fvar fvarId =>\n    match s.find? fvarId with\n    | some (.fvar fvarId') =>\n      let arg' := .fvar fvarId'\n      if translator then arg' else normArgImp s arg' translator\n    | some e => if e.isErased then .erased else .type e\n    | none => arg\n  | .type e => arg.updateType! (normExprImp s e translator)", "start": [239, 1], "end": [254, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normArgsImp", "code": "private def normArgsImp (s : FVarSubst) (args : Array Arg) (translator : Bool) : Array Arg :=\n  args.mapMono (normArgImp s \u00b7 translator)", "start": [256, 1], "end": [257, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normLetValueImp", "code": "private partial def normLetValueImp (s : FVarSubst) (e : LetValue) (translator : Bool) : LetValue :=\n  match e with\n  | .erased | .value .. => e\n  | .proj _ _ fvarId => match normFVarImp s fvarId translator with\n    | .fvar fvarId' => e.updateProj! fvarId'\n    | .erased => .erased\n  | .const _ _ args => e.updateArgs! (normArgsImp s args translator)\n  | .fvar fvarId args => match normFVarImp s fvarId translator with\n    | .fvar fvarId' => e.updateFVar! fvarId' (normArgsImp s args translator)\n    | .erased => .erased", "start": [259, 1], "end": [273, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.MonadFVarSubst", "code": "class MonadFVarSubst (m : Type \u2192 Type) (translator : outParam Bool) where\n  getSubst : m FVarSubst", "start": [275, 1], "end": [279, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.MonadFVarSubstState", "code": "class MonadFVarSubstState (m : Type \u2192 Type) where\n  modifySubst : (FVarSubst \u2192 FVarSubst) \u2192 m Unit", "start": [286, 1], "end": [287, 49], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.addFVarSubst", "code": "@[inline] def addFVarSubst [MonadFVarSubstState m] (fvarId : FVarId) (fvarId' : FVarId) : m Unit :=\n  modifySubst fun s => s.insert fvarId (.fvar fvarId')", "start": [294, 1], "end": [298, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.addSubst", "code": "@[inline] def addSubst [MonadFVarSubstState m] (fvarId : FVarId) (e : Expr) : m Unit :=\n  modifySubst fun s => s.insert fvarId e", "start": [300, 1], "end": [307, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normFVar", "code": "@[inline, inherit_doc normFVarImp] def normFVar [MonadFVarSubst m t] [Monad m] (fvarId : FVarId) : m NormFVarResult :=\n  return normFVarImp (\u2190 getSubst) fvarId t", "start": [309, 1], "end": [310, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normExpr", "code": "@[inline, inherit_doc normExprImp] def normExpr [MonadFVarSubst m t] [Monad m] (e : Expr) : m Expr :=\n  return normExprImp (\u2190 getSubst) e t", "start": [312, 1], "end": [313, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normArg", "code": "@[inline, inherit_doc normArgImp] def normArg [MonadFVarSubst m t] [Monad m] (arg : Arg) : m Arg :=\n  return normArgImp (\u2190 getSubst) arg t", "start": [315, 1], "end": [316, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normLetValue", "code": "@[inline, inherit_doc normLetValueImp] def normLetValue [MonadFVarSubst m t] [Monad m] (e : LetValue) : m LetValue :=\n  return normLetValueImp (\u2190 getSubst) e t", "start": [318, 1], "end": [319, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normExprCore", "code": "@[inherit_doc normExprImp]\nabbrev normExprCore (s : FVarSubst) (e : Expr) (translator : Bool) : Expr :=\n  normExprImp s e translator", "start": [321, 1], "end": [323, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normArgs", "code": "def normArgs [MonadFVarSubst m t] [Monad m] (args : Array Arg) : m (Array Arg) :=\n  return normArgsImp (\u2190 getSubst) args t", "start": [325, 1], "end": [329, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkFreshBinderName", "code": "def mkFreshBinderName (binderName := `_x): CompilerM Name := do\n  let declName := .num binderName (\u2190 get).nextIdx\n  modify fun s => { s with nextIdx := s.nextIdx + 1 }\n  return declName", "start": [331, 1], "end": [334, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.ensureNotAnonymous", "code": "def ensureNotAnonymous (binderName : Name) (baseName : Name) : CompilerM Name :=\n  if binderName.isAnonymous then\n    mkFreshBinderName baseName\n  else\n    return binderName", "start": [336, 1], "end": [340, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkParam", "code": "def mkParam (binderName : Name) (type : Expr) (borrow : Bool) : CompilerM Param := do\n  let fvarId \u2190 mkFreshFVarId\n  let binderName \u2190 ensureNotAnonymous binderName `_y\n  let param := { fvarId, binderName, type, borrow }\n  modifyLCtx fun lctx => lctx.addParam param\n  return param", "start": [346, 1], "end": [351, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkLetDecl", "code": "def mkLetDecl (binderName : Name) (type : Expr) (value : LetValue) : CompilerM LetDecl := do\n  let fvarId \u2190 mkFreshFVarId\n  let binderName \u2190 ensureNotAnonymous binderName `_x\n  let decl := { fvarId, binderName, type, value }\n  modifyLCtx fun lctx => lctx.addLetDecl decl\n  return decl", "start": [353, 1], "end": [358, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkFunDecl", "code": "def mkFunDecl (binderName : Name) (type : Expr) (params : Array Param) (value : Code) : CompilerM FunDecl := do\n  let fvarId \u2190 mkFreshFVarId\n  let binderName \u2190 ensureNotAnonymous binderName `_f\n  let funDecl := { fvarId, binderName, type, params, value }\n  modifyLCtx fun lctx => lctx.addFunDecl funDecl\n  return funDecl", "start": [360, 1], "end": [365, 17], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkLetDeclErased", "code": "def mkLetDeclErased : CompilerM LetDecl := do\n  mkLetDecl (\u2190 mkFreshBinderName `_x) erasedExpr .erased", "start": [367, 1], "end": [368, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkReturnErased", "code": "def mkReturnErased : CompilerM Code := do\n  let auxDecl \u2190 mkLetDeclErased\n  return .let auxDecl (.return auxDecl.fvarId)", "start": [370, 1], "end": [372, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateParamImp", "code": "private unsafe def updateParamImp (p : Param) (type : Expr) : CompilerM Param := do\n  if ptrEq type p.type then\n    return p\n  else\n    let p := { p with type }\n    modifyLCtx fun lctx => lctx.addParam p\n    return p", "start": [374, 1], "end": [380, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.Param.update", "code": "@[implemented_by updateParamImp] opaque Param.update (p : Param) (type : Expr) : CompilerM Param", "start": [382, 1], "end": [382, 97], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateLetDeclImp", "code": "private unsafe def updateLetDeclImp (decl : LetDecl) (type : Expr) (value : LetValue) : CompilerM LetDecl := do\n  if ptrEq type decl.type && ptrEq value decl.value then\n    return decl\n  else\n    let decl := { decl with type, value }\n    modifyLCtx fun lctx => lctx.addLetDecl decl\n    return decl", "start": [384, 1], "end": [390, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl.update", "code": "@[implemented_by updateLetDeclImp] opaque LetDecl.update (decl : LetDecl) (type : Expr) (value : LetValue) : CompilerM LetDecl", "start": [392, 1], "end": [392, 127], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.LetDecl.updateValue", "code": "def LetDecl.updateValue (decl : LetDecl) (value : LetValue) : CompilerM LetDecl :=\n  decl.update decl.type value", "start": [394, 1], "end": [395, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.updateFunDeclImp", "code": "private unsafe def updateFunDeclImp (decl: FunDecl) (type : Expr) (params : Array Param) (value : Code) : CompilerM FunDecl := do\n  if ptrEq type decl.type && ptrEq params decl.params && ptrEq value decl.value then\n    return decl\n  else\n    let decl := { decl with type, params, value }\n    modifyLCtx fun lctx => lctx.addFunDecl decl\n    return decl", "start": [397, 1], "end": [403, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.update", "code": "@[implemented_by updateFunDeclImp] opaque FunDeclCore.update (decl: FunDecl) (type : Expr) (params : Array Param) (value : Code) : CompilerM FunDecl", "start": [405, 1], "end": [405, 149], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.update'", "code": "abbrev FunDeclCore.update' (decl : FunDecl) (type : Expr) (value : Code) : CompilerM FunDecl :=\n  decl.update type decl.params value", "start": [407, 1], "end": [408, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.FunDeclCore.updateValue", "code": "abbrev FunDeclCore.updateValue (decl : FunDecl) (value : Code) : CompilerM FunDecl :=\n  decl.update decl.type decl.params value", "start": [410, 1], "end": [411, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normParam", "code": "@[inline] def normParam [MonadLiftT CompilerM m] [Monad m] [MonadFVarSubst m t] (p : Param) : m Param := do\n  p.update (\u2190 normExpr p.type)", "start": [413, 1], "end": [414, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normParams", "code": "def normParams [MonadLiftT CompilerM m] [Monad m] [MonadFVarSubst m t] (ps : Array Param) : m (Array Param) :=\n  ps.mapMonoM normParam", "start": [416, 1], "end": [417, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normLetDecl", "code": "def normLetDecl [MonadLiftT CompilerM m] [Monad m] [MonadFVarSubst m t] (decl : LetDecl) : m LetDecl := do\n  decl.update (\u2190 normExpr decl.type) (\u2190 normLetValue decl.value)", "start": [419, 1], "end": [420, 65], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.NormalizerM", "code": "abbrev NormalizerM (_translator : Bool) := ReaderT FVarSubst CompilerM", "start": [422, 1], "end": [422, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.withNormFVarResult", "code": "@[inline] def withNormFVarResult [MonadLiftT CompilerM m] [Monad m] (result : NormFVarResult) (x : FVarId \u2192 m Code) : m Code := do\n  match result with\n  | .fvar fvarId => x fvarId\n  | .erased => mkReturnErased", "start": [427, 1], "end": [434, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normFunDeclImp", "code": "partial def normFunDeclImp (decl : FunDecl) : NormalizerM t FunDecl  := do\n    let type \u2190 normExpr decl.type\n    let params \u2190 normParams decl.params\n    let value \u2190 normCodeImp decl.value\n    decl.update type params value", "start": [437, 3], "end": [441, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normCodeImp", "code": "partial def normCodeImp (code : Code) : NormalizerM t Code := do\n    match code with\n    | .let decl k => return code.updateLet! (\u2190 normLetDecl decl) (\u2190 normCodeImp k)\n    | .fun decl k | .jp decl k => return code.updateFun! (\u2190 normFunDeclImp decl) (\u2190 normCodeImp k)\n    | .return fvarId => withNormFVarResult (\u2190 normFVar fvarId) fun fvarId => return code.updateReturn! fvarId\n    | .jmp fvarId args => withNormFVarResult (\u2190 normFVar fvarId) fun fvarId => return code.updateJmp! fvarId (\u2190 normArgs args)\n    | .unreach type => return code.updateUnreach! (\u2190 normExpr type)\n    | .cases c =>\n      let resultType \u2190 normExpr c.resultType\n      withNormFVarResult (\u2190 normFVar c.discr) fun discr => do\n        let alts \u2190 c.alts.mapMonoM fun alt =>\n          match alt with\n          | .alt _ params k => return alt.updateAlt! (\u2190 normParams params) (\u2190 normCodeImp k)\n          | .default k => return alt.updateCode (\u2190 normCodeImp k)\n        return code.updateCases! resultType discr alts", "start": [443, 3], "end": [457, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normFunDecl", "code": "@[inline] def normFunDecl [MonadLiftT CompilerM m] [Monad m] [MonadFVarSubst m t] (decl : FunDecl) : m FunDecl := do\n  normFunDeclImp (t := t) decl (\u2190 getSubst)", "start": [460, 1], "end": [461, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.normCode", "code": "@[inline] def normCode [MonadLiftT CompilerM m] [Monad m] [MonadFVarSubst m t] (code : Code) : m Code := do\n  normCodeImp (t := t) code (\u2190 getSubst)", "start": [463, 1], "end": [465, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.replaceExprFVars", "code": "def replaceExprFVars (e : Expr) (s : FVarSubst) (translator : Bool) : CompilerM Expr :=\n  (normExpr e : NormalizerM translator Expr).run s", "start": [467, 1], "end": [468, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.replaceFVars", "code": "def replaceFVars (code : Code) (s : FVarSubst) (translator : Bool) : CompilerM Code :=\n  (normCode code : NormalizerM translator Code).run s", "start": [470, 1], "end": [471, 54], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkFreshJpName", "code": "def mkFreshJpName : CompilerM Name := do\n  mkFreshBinderName `_jp", "start": [473, 1], "end": [474, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.mkAuxParam", "code": "def mkAuxParam (type : Expr) (borrow := false) : CompilerM Param := do\n  mkParam (\u2190 mkFreshBinderName `_y) type borrow", "start": [476, 1], "end": [477, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getConfig", "code": "def getConfig : CompilerM ConfigOptions :=\n  return (\u2190 read).config", "start": [479, 1], "end": [480, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CompilerM.run", "code": "def CompilerM.run (x : CompilerM \u03b1) (s : State := {}) (phase : Phase := .base) : CoreM \u03b1 := do\n  x { phase, config := toConfigOptions (\u2190 getOptions) } |>.run' s", "start": [482, 1], "end": [483, 66], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Array/Init/Basic.lean", "imports": ["lake-packages/std/Std/Data/List/Init/Lemmas.lean", "lake-packages/std/Std/Tactic/NoMatch.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Array.toListAppend", "code": "@[inline] def toListAppend (as : Array \u03b1) (l : List \u03b1) : List \u03b1 :=\n  as.foldr List.cons l", "start": [17, 1], "end": [19, 23], "kind": "commanddeclaration"}, {"full_name": "Array.ofFn", "code": "def ofFn {n} (f : Fin n \u2192 \u03b1) : Array \u03b1 := go 0 (mkEmpty n) where\n  \n  go (i : Nat) (acc : Array \u03b1) : Array \u03b1 :=\n    if h : i < n then go (i+1) (acc.push (f \u27e8i, h\u27e9)) else acc\ntermination_by _ => n - i", "start": [21, 1], "end": [30, 26], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Ord.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordering.swap", "code": "def swap : Ordering \u2192 Ordering\n  | .lt => .gt\n  | .eq => .eq\n  | .gt => .lt", "start": [11, 1], "end": [15, 15], "kind": "commanddeclaration"}, {"full_name": "Ordering.then", "code": "@[macro_inline] def \u00abthen\u00bb : Ordering \u2192 Ordering \u2192 Ordering\n  | .eq, f => f\n  | o, _ => o", "start": [17, 1], "end": [37, 14], "kind": "commanddeclaration"}, {"full_name": "Ordering.isEq", "code": "def isEq : Ordering \u2192 Bool\n  | eq => true\n  | _ => false", "start": [39, 1], "end": [44, 15], "kind": "commanddeclaration"}, {"full_name": "Ordering.isNe", "code": "def isNe : Ordering \u2192 Bool\n  | eq => false\n  | _ => true", "start": [46, 1], "end": [51, 14], "kind": "commanddeclaration"}, {"full_name": "Ordering.isLT", "code": "def isLT : Ordering \u2192 Bool\n  | lt => true\n  | _ => false", "start": [53, 1], "end": [58, 15], "kind": "commanddeclaration"}, {"full_name": "Ordering.isGT", "code": "def isGT : Ordering \u2192 Bool\n  | gt => true\n  | _ => false", "start": [60, 1], "end": [65, 15], "kind": "commanddeclaration"}, {"full_name": "Ordering.isGE", "code": "def isGE : Ordering \u2192 Bool\n  | lt => false\n  | _ => true", "start": [67, 1], "end": [72, 14], "kind": "commanddeclaration"}, {"full_name": "compareLex", "code": "@[inline] def compareLex (cmp\u2081 cmp\u2082 : \u03b1 \u2192 \u03b2 \u2192 Ordering) (a : \u03b1) (b : \u03b2) : Ordering :=\n  (cmp\u2081 a b).then (cmp\u2082 a b)", "start": [76, 1], "end": [82, 29], "kind": "commanddeclaration"}, {"full_name": "compareOn", "code": "@[inline] def compareOn [ord : Ord \u03b2] (f : \u03b1 \u2192 \u03b2) (x y : \u03b1) : Ordering :=\n  compare (f x) (f y)", "start": [84, 1], "end": [88, 22], "kind": "commanddeclaration"}, {"full_name": "Ord.toBEq", "code": "protected def toBEq (ord : Ord \u03b1) : BEq \u03b1 where\n  beq x y := ord.compare x y == .eq", "start": [93, 1], "end": [97, 36], "kind": "commanddeclaration"}, {"full_name": "Ord.toLT", "code": "protected def toLT (_ : Ord \u03b1) : LT \u03b1 :=\n  ltOfOrd", "start": [99, 1], "end": [103, 10], "kind": "commanddeclaration"}, {"full_name": "Ord.toLE", "code": "protected def toLE (_ : Ord \u03b1) : LE \u03b1 :=\n  leOfOrd", "start": [105, 1], "end": [109, 10], "kind": "commanddeclaration"}, {"full_name": "Ord.opposite", "code": "protected def opposite (ord : Ord \u03b1) : Ord \u03b1 where\n  compare x y := ord.compare y x", "start": [111, 1], "end": [115, 33], "kind": "commanddeclaration"}, {"full_name": "Ord.on", "code": "protected def on (ord : Ord \u03b2) (f : \u03b1 \u2192 \u03b2) : Ord \u03b1 where\n  compare := compareOn f", "start": [117, 1], "end": [121, 25], "kind": "commanddeclaration"}, {"full_name": "Ord.lex", "code": "protected def lex (_ : Ord \u03b1) (_ : Ord \u03b2) : Ord (\u03b1 \u00d7 \u03b2) :=\n  lexOrd", "start": [123, 1], "end": [127, 9], "kind": "commanddeclaration"}, {"full_name": "Ord.lex'", "code": "protected def lex' (ord\u2081 ord\u2082 : Ord \u03b1) : Ord \u03b1 where\n  compare := compareLex ord\u2081.compare ord\u2082.compare", "start": [129, 1], "end": [134, 50], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/NameMapAttribute.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Attributes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.NameMapExtension", "code": "def NameMapExtension (\u03b1 : Type) := SimplePersistentEnvExtension (Name \u00d7 \u03b1) (NameMap \u03b1)", "start": [10, 1], "end": [11, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMapExtension.find?", "code": "def NameMapExtension.find? (ext : NameMapExtension \u03b1) (env : Environment) : Name \u2192 Option \u03b1 :=\n  (SimplePersistentEnvExtension.getState ext env).find?", "start": [16, 1], "end": [18, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMapExtension.add", "code": "def NameMapExtension.add [Monad M] [MonadEnv M] [MonadError M]\n  (ext : NameMapExtension \u03b1) (k : Name) (v : \u03b1) :  M Unit := do\n  if let some _ := ext.find? (\u2190 getEnv) k then\n    throwError \"Already exists entry for {ext.name} {k}\"\n  else\n     ext.addEntry (\u2190 getEnv) (k, v) |> setEnv", "start": [20, 1], "end": [26, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.registerNameMapExtension", "code": "def registerNameMapExtension (\u03b1) (name : Name := by exact decl_name%) :\n    IO (NameMapExtension \u03b1) := do\n  registerSimplePersistentEnvExtension {\n    name\n    addImportedFn := fun ass =>\n      ass.foldl (init := \u2205) fun names as =>\n        as.foldl (init := names) fun names (a, b) => names.insert a b\n    addEntryFn    := fun s n => s.insert n.1 n.2\n    toArrayFn     := fun es => es.toArray\n  }", "start": [28, 1], "end": [38, 4], "kind": "commanddeclaration"}, {"full_name": "Lean.NameMapAttributeImpl", "code": "structure NameMapAttributeImpl (\u03b1 : Type) where\n  \n  name : Name\n  \n  ref : Name := by exact decl_name%\n  \n  descr : String\n  \n  add (src : Name) (stx : Syntax) : AttrM \u03b1\n  deriving Inhabited", "start": [40, 1], "end": [51, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.registerNameMapAttribute", "code": "def registerNameMapAttribute (impl : NameMapAttributeImpl \u03b1) : IO (NameMapExtension \u03b1) := do\n  let ext \u2190 registerNameMapExtension \u03b1 impl.ref\n  registerBuiltinAttribute {\n    name := impl.name\n    descr := impl.descr\n    add := fun src stx _kind => do\n      let a : \u03b1 \u2190 impl.add src stx\n      ext.add src a\n  }\n  return ext", "start": [53, 1], "end": [64, 13], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Util/TermUnsafe.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/lean4/src/lean/Lean/Meta/Closure.lean", "lake-packages/lean4/src/lean/Lean/Compiler/ImplementedByAttr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.TermUnsafe.mkAuxName", "code": "def mkAuxName (hint : Name) : TermElabM Name :=\n  withFreshMacroScope do\n    let name := (\u2190 getDeclName?).getD Name.anonymous ++ hint\n    pure $ addMacroScope (\u2190 getMainModule) name (\u2190 getCurrMacroScope)", "start": [24, 1], "end": [28, 70], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Linter/UnnecessarySeqFocus.lean", "imports": ["lake-packages/std/Std/Lean/AttributeExtra.lean", "lake-packages/std/Std/Lean/Command.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Linter/Util.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Std.Linter.UnnecessarySeqFocus.getLinterUnnecessarySeqFocus", "code": "def getLinterUnnecessarySeqFocus (o : Options) : Bool :=\n  getLinterValue linter.unnecessarySeqFocus o", "start": [47, 1], "end": [49, 46], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnnecessarySeqFocus.Entry", "code": "structure Entry where\n  \n  stx : Syntax\n  \n  used : Bool", "start": [75, 1], "end": [84, 14], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnnecessarySeqFocus.M", "code": "abbrev M (\u03c9) := StateRefT (HashMap String.Range Entry) (ST \u03c9)", "start": [86, 1], "end": [87, 62], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnnecessarySeqFocus.isSeqFocus", "code": "@[inline] def isSeqFocus (k : SyntaxNodeKind) : Bool :=\n  k == ``Parser.Tactic.\u00abtactic_<;>_\u00bb || k == ``Parser.Tactic.Conv.\u00abconv_<;>_\u00bb", "start": [89, 1], "end": [91, 78], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnnecessarySeqFocus.getTactics", "code": "@[specialize] partial def getTactics {\u03c9} (stx : Syntax) : M \u03c9 Unit := do\n  if let .node _ k args := stx then\n    if isSeqFocus k then\n      let r := stx.getRange? true\n      if let some r := r then\n        modify fun m => m.insert r { stx, used := false }\n    args.forM getTactics", "start": [93, 1], "end": [100, 25], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnnecessarySeqFocus.getPath", "code": "def getPath : Info \u2192 PersistentArray InfoTree \u2192 List ((n : Nat) \u00d7 Fin n) \u2192 Option Info\n  | i, _, [] => some i\n  | _, c, \u27e8n, i, h\u27e9::ns =>\n    if e : c.size = n then\n      if let .node i c' := c[i]'(e \u25b8 h) then getPath i c' ns else none\n    else none", "start": [102, 1], "end": [111, 14], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnnecessarySeqFocus.markUsedTacticsList", "code": "partial def markUsedTacticsList (trees : PersistentArray InfoTree) : M \u03c9 Unit :=\n  trees.forM markUsedTactics", "start": [115, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnnecessarySeqFocus.markUsedTactics", "code": "partial def markUsedTactics : InfoTree \u2192 M \u03c9 Unit\n  | .node i c => do\n    if let .ofTacticInfo i := i then\n      if let some r := i.stx.getRange? true then\n      if let some entry := (\u2190 get).find? r then\n      if i.stx.getKind == ``Parser.Tactic.\u00abtactic_<;>_\u00bb then\n        let isBad := do\n          unless i.goalsBefore.length == 1 || !multigoalAttr.hasTag env i.stx[0].getKind do\n            none\n          let .ofTacticInfo i \u2190 getPath (.ofTacticInfo i) c\n            [\u27e81, 0\u27e9, \u27e82, 1\u27e9, \u27e81, 0\u27e9, \u27e85, 0\u27e9] | none\n          guard <| i.goalsAfter.length == 1\n        modify fun s => if isBad.isSome then s.insert r { entry with used := true } else s.erase r\n      else if i.stx.getKind == ``Parser.Tactic.Conv.\u00abconv_<;>_\u00bb then\n        let isBad := do\n          unless i.goalsBefore.length == 1 || !multigoalAttr.hasTag env i.stx[0].getKind do\n            none\n          let .ofTacticInfo i \u2190 getPath (.ofTacticInfo i) c\n            [\u27e81, 0\u27e9, \u27e81, 0\u27e9, \u27e81, 0\u27e9, \u27e81, 0\u27e9, \u27e81, 0\u27e9, \u27e82, 1\u27e9, \u27e81, 0\u27e9, \u27e85, 0\u27e9] | none\n          guard <| i.goalsAfter.length == 1\n        modify fun s => if isBad.isSome then s.insert r { entry with used := true } else s.erase r\n    markUsedTacticsList c\n  | .context _ t => markUsedTactics t\n  | .hole _ => pure ()", "start": [119, 1], "end": [147, 23], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnnecessarySeqFocus.unnecessarySeqFocusLinter", "code": "def unnecessarySeqFocusLinter : Linter where run := withSetOptionIn fun stx => do\n  unless getLinterUnnecessarySeqFocus (\u2190 getOptions) && (\u2190 getInfoState).enabled do\n    return\n  if (\u2190 get).messages.hasErrors then\n    return\n  let trees \u2190 getInfoTrees\n  let env \u2190 getEnv\n  let go {\u03c9} : M \u03c9 Unit := do\n    getTactics stx\n    markUsedTacticsList env trees\n  let (_, map) := runST fun _ => go.run {}\n  let unused := map.fold (init := #[]) fun acc r { stx, used } =>\n    if used then acc.push (stx[1].getRange?.getD r, stx[1]) else acc\n  let key (r : String.Range) := (r.start.byteIdx, (-r.stop.byteIdx : Int))\n  let mut last : String.Range := \u27e80, 0\u27e9\n  for (r, stx) in let _ := @lexOrd; let _ := @ltOfOrd.{0}; unused.qsort (key \u00b7.1 < key \u00b7.1) do\n    if last.start \u2264 r.start && r.stop \u2264 last.stop then continue\n    logLint linter.unnecessarySeqFocus stx\n      \"Used `tac1 <;> tac2` where `(tac1; tac2)` would suffice\"\n    last := r", "start": [151, 1], "end": [171, 14], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Linter/UnreachableTactic.lean", "imports": ["lake-packages/std/Std/Lean/Command.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Linter/Util.lean", "lake-packages/std/Std/Tactic/Unreachable.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Std.Linter.UnreachableTactic.getLinterUnreachableTactic", "code": "def getLinterUnreachableTactic (o : Options) : Bool := getLinterValue linter.unreachableTactic o", "start": [29, 1], "end": [30, 97], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnreachableTactic.M", "code": "abbrev M := StateRefT (HashMap String.Range Syntax) IO", "start": [32, 1], "end": [33, 55], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnreachableTactic.isIgnoreTacticKind", "code": "def isIgnoreTacticKind (ignoreTacticKinds : NameHashSet) (k : SyntaxNodeKind) : Bool :=\n  match k with\n  | .str _ \"quot\" => true\n  | _ => ignoreTacticKinds.contains k", "start": [49, 1], "end": [53, 38], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnreachableTactic.addIgnoreTacticKind", "code": "def addIgnoreTacticKind (kind : SyntaxNodeKind) : IO Unit :=\n  ignoreTacticKindsRef.modify (\u00b7.insert kind)", "start": [55, 1], "end": [60, 46], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnreachableTactic.getTactics", "code": "@[specialize] partial def getTactics (stx : Syntax) : M Unit := do\n  if let .node _ k args := stx then\n    if !isIgnoreTacticKind ignoreTacticKinds k then\n      args.forM getTactics\n    if isTacKind k then\n      if let some r := stx.getRange? true then\n        modify fun m => m.insert r stx", "start": [63, 1], "end": [70, 39], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnreachableTactic.eraseUsedTacticsList", "code": "partial def eraseUsedTacticsList (trees : PersistentArray InfoTree) : M Unit :=\n  trees.forM eraseUsedTactics", "start": [74, 1], "end": [76, 30], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnreachableTactic.eraseUsedTactics", "code": "partial def eraseUsedTactics : InfoTree \u2192 M Unit\n  | .node i c => do\n    if let .ofTacticInfo i := i then\n      if let some r := i.stx.getRange? true then\n        modify (\u00b7.erase r)\n    eraseUsedTacticsList c\n  | .context _ t => eraseUsedTactics t\n  | .hole _ => pure ()", "start": [78, 1], "end": [86, 23], "kind": "commanddeclaration"}, {"full_name": "Std.Linter.UnreachableTactic.unreachableTacticLinter", "code": "def unreachableTacticLinter : Linter where run := withSetOptionIn fun stx => do\n  unless getLinterUnreachableTactic (\u2190 getOptions) && (\u2190 getInfoState).enabled do\n    return\n  if (\u2190 get).messages.hasErrors then\n    return\n  let cats := (Parser.parserExtension.getState (\u2190 getEnv)).categories\n  let tactics := cats.find! `tactic |>.kinds\n  let convs := cats.find! `conv |>.kinds\n  let trees \u2190 getInfoTrees\n  let go : M Unit := do\n    getTactics (\u2190 ignoreTacticKindsRef.get) (fun k => tactics.contains k || convs.contains k) stx\n    eraseUsedTacticsList trees\n  let (_, map) \u2190 go.run {}\n  let unreachable := map.toArray\n  let key (r : String.Range) := (r.start.byteIdx, (-r.stop.byteIdx : Int))\n  let mut last : String.Range := \u27e80, 0\u27e9\n  for (r, stx) in let _ := @lexOrd; let _ := @ltOfOrd.{0}; unreachable.qsort (key \u00b7.1 < key \u00b7.1) do\n    if stx.getKind \u2208 [``Std.Tactic.unreachable, ``Std.Tactic.unreachableConv] then continue\n    if last.start \u2264 r.start && r.stop \u2264 last.stop then continue\n    logLint linter.unreachableTactic stx \"this tactic is never executed\"\n    last := r", "start": [90, 1], "end": [111, 14], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/BuiltinTactic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Reduce.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Replace.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.Conv.mkLHSGoal", "code": "def mkLHSGoal (e : Expr) : MetaM Expr :=\n  if let some _ := Expr.eq? e then\n    return mkLHSGoalRaw e\n  else\n    return mkLHSGoalRaw (\u2190 whnf e)", "start": [15, 1], "end": [24, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.mkConvGoalFor", "code": "def mkConvGoalFor (lhs : Expr) (tag : Name := .anonymous) : MetaM (Expr \u00d7 Expr) := do\n  let lhsType \u2190 inferType lhs\n  let rhs \u2190 mkFreshExprMVar lhsType\n  let targetNew := mkLHSGoalRaw (\u2190 mkEq lhs rhs)\n  let newGoal \u2190 mkFreshExprSyntheticOpaqueMVar targetNew tag\n  return (rhs, newGoal)", "start": [26, 1], "end": [33, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.markAsConvGoal", "code": "def markAsConvGoal (mvarId : MVarId) : MetaM MVarId := do\n  let target \u2190 mvarId.getType\n  if isLHSGoal? target |>.isSome then\n    return mvarId mvarId.replaceTargetDefEq (\u2190 mkLHSGoal (\u2190 mvarId.getType))", "start": [35, 1], "end": [39, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.convert", "code": "def convert (lhs : Expr) (conv : TacticM Unit) : TacticM (Expr \u00d7 Expr) := do\n  let (rhs, newGoal) \u2190 mkConvGoalFor lhs\n  let savedGoals \u2190 getGoals\n  try\n    setGoals [newGoal.mvarId!]\n    conv\n    for mvarId in (\u2190 getGoals) do\n      liftM <| mvarId.refl <|> mvarId.inferInstance <|> pure ()\n    pruneSolvedGoals\n    unless (\u2190 getGoals).isEmpty do\n      throwError \"convert tactic failed, there are unsolved goals\\n{goalsToMessageData (\u2190 getGoals)}\"\n    pure ()\n  finally\n    setGoals savedGoals\n  return (\u2190 instantiateMVars rhs, \u2190 instantiateMVars newGoal)", "start": [41, 1], "end": [58, 62], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.getLhsRhsCore", "code": "def getLhsRhsCore (mvarId : MVarId) : MetaM (Expr \u00d7 Expr) :=\n  mvarId.withContext do\n    let some (_, lhs, rhs) \u2190 matchEq? (\u2190 mvarId.getType) | throwError \"invalid 'conv' goal\"\n    return (lhs, rhs)", "start": [60, 1], "end": [63, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.getLhsRhs", "code": "def getLhsRhs : TacticM (Expr \u00d7 Expr) := do\n  getLhsRhsCore (\u2190 getMainGoal)", "start": [65, 1], "end": [66, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.getLhs", "code": "def getLhs : TacticM Expr :=\n  return (\u2190 getLhsRhs).1", "start": [68, 1], "end": [69, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.getRhs", "code": "def getRhs : TacticM Expr :=\n  return (\u2190 getLhsRhs).2", "start": [71, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.updateLhs", "code": "def updateLhs (lhs' : Expr) (h : Expr) : TacticM Unit := do\n  let mvarId \u2190 getMainGoal\n  let rhs \u2190 getRhs\n  let newGoal \u2190 mkFreshExprSyntheticOpaqueMVar (mkLHSGoalRaw (\u2190 mkEq lhs' rhs)) (\u2190 mvarId.getTag)\n  mvarId.assign (\u2190 mkEqTrans h newGoal)\n  replaceMainGoal [newGoal.mvarId!]", "start": [74, 1], "end": [80, 36], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.changeLhs", "code": "def changeLhs (lhs' : Expr) : TacticM Unit := do\n  let rhs \u2190 getRhs\n  liftMetaTactic1 fun mvarId => do\n    mvarId.replaceTargetDefEq (mkLHSGoalRaw (\u2190 mkEq lhs' rhs))", "start": [82, 1], "end": [86, 63], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalWhnf", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.whnf] def evalWhnf : Tactic := fun _ =>\n   withMainContext do\n     changeLhs (\u2190 whnf (\u2190 getLhs))", "start": [88, 1], "end": [90, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalReduce", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.reduce] def evalReduce : Tactic := fun _ =>\n   withMainContext do\n     changeLhs (\u2190 reduce (\u2190 getLhs))", "start": [92, 1], "end": [94, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalZeta", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.zeta] def evalZeta : Tactic := fun _ =>\n   withMainContext do\n     changeLhs (\u2190 zetaReduce (\u2190 getLhs))", "start": [96, 1], "end": [98, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalSepByIndentConv", "code": "def evalSepByIndentConv (stx : Syntax) : TacticM Unit := do\n  for arg in stx.getArgs, i in [:stx.getArgs.size] do\n    if i % 2 == 0 then\n      evalTactic arg\n    else\n      saveTacticInfoForToken arg", "start": [100, 1], "end": [106, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalConvSeq1Indented", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.convSeq1Indented] def evalConvSeq1Indented : Tactic := fun stx => do\n  evalSepByIndentConv stx[0]", "start": [108, 1], "end": [109, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalConvSeqBracketed", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.convSeqBracketed] def evalConvSeqBracketed : Tactic := fun stx => do\n  let initInfo \u2190 mkInitialTacticInfo stx[0]\n  withRef stx[2] <| closeUsingOrAdmit do\n    withInfoContext (pure ()) initInfo\n    evalSepByIndentConv stx[1]\n    evalTactic (\u2190 `(tactic| all_goals (try rfl)))", "start": [111, 1], "end": [117, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalNestedConv", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.nestedConv] def evalNestedConv : Tactic := fun stx => do\n  evalConvSeqBracketed stx[0]", "start": [119, 1], "end": [120, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalConvSeq", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.convSeq] def evalConvSeq : Tactic := fun stx => do\n  evalTactic stx[0]", "start": [122, 1], "end": [123, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalConvConvSeq", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.convConvSeq] def evalConvConvSeq : Tactic := fun stx =>\n  withMainContext do\n    let (lhsNew, proof) \u2190 convert (\u2190 getLhs) (evalTactic stx[2][0])\n    updateLhs lhsNew proof", "start": [125, 1], "end": [128, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalParen", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.paren] def evalParen : Tactic := fun stx =>\n  evalTactic stx[1]", "start": [130, 1], "end": [131, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.remarkAsConvGoal", "code": "def remarkAsConvGoal : TacticM Unit := do\n  let newGoals \u2190 (\u2190 getUnsolvedGoals).mapM fun mvarId => mvarId.withContext do\n    let target \u2190 mvarId.getType\n    if let some (_, _, rhs) \u2190 matchEq? target then\n      if rhs.getAppFn.isMVar then\n        mvarId.replaceTargetDefEq (\u2190 mkLHSGoal target)\n      else\n        return mvarId\n    else\n      return mvarId\n  setGoals newGoals", "start": [133, 1], "end": [144, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalNestedTacticCore", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.nestedTacticCore] def evalNestedTacticCore : Tactic := fun stx => do\n  let seq := stx[2]\n  evalTactic seq; remarkAsConvGoal", "start": [146, 1], "end": [148, 35], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalNestedTactic", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.nestedTactic] def evalNestedTactic : Tactic := fun stx => do\n  let seq := stx[2]\n  let target \u2190 getMainTarget\n  if let some _ := isLHSGoal? target then\n    liftMetaTactic1 fun mvarId =>\n      mvarId.replaceTargetDefEq target.mdataExpr!\n  focus do evalTactic seq; remarkAsConvGoal", "start": [150, 1], "end": [156, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalConvTactic", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.convTactic] def evalConvTactic : Tactic := fun stx =>\n  evalTactic stx[2]", "start": [158, 1], "end": [159, 20], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.convTarget", "code": "private def convTarget (conv : Syntax) : TacticM Unit := withMainContext do\n   let target \u2190 getMainTarget\n   let (targetNew, proof) \u2190 convert target (withTacticInfoContext (\u2190 getRef) (evalTactic conv))\n   liftMetaTactic1 fun mvarId => mvarId.replaceTargetEq targetNew proof\n   evalTactic (\u2190 `(tactic| try rfl))", "start": [161, 1], "end": [165, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.convLocalDecl", "code": "private def convLocalDecl (conv : Syntax) (hUserName : Name) : TacticM Unit := withMainContext do\n   let localDecl \u2190 getLocalDeclFromUserName hUserName\n   let (typeNew, proof) \u2190 convert localDecl.type (withTacticInfoContext (\u2190 getRef) (evalTactic conv))\n   liftMetaTactic1 fun mvarId =>\n     return some (\u2190 mvarId.replaceLocalDecl localDecl.fvarId typeNew proof).mvarId", "start": [167, 1], "end": [171, 83], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalConv", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.conv] def evalConv : Tactic := fun stx => do\n  match stx with\n  | `(tactic| conv%$tk $[at $loc?]? in $(occs)? $p =>%$arr $code) =>\n    evalTactic (\u2190 `(tactic| conv%$tk $[at $loc?]? =>%$arr pattern $(occs)? $p; ($code:convSeq)))\n  | `(tactic| conv%$tk $[at $loc?]? =>%$arr $code) =>\n    withRef (mkNullNode #[tk, arr]) do\n      if let some loc := loc? then\n        convLocalDecl code loc.getId\n      else\n        convTarget code\n  | _ => throwUnsupportedSyntax", "start": [173, 1], "end": [184, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Conv.evalFirst", "code": "@[builtin_tactic Lean.Parser.Tactic.Conv.first] partial def evalFirst : Tactic :=\n  Tactic.evalFirst", "start": [186, 1], "end": [187, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/TryThis.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Server/CodeActions.lean", "lake-packages/std/Std/Lean/Format.lean", "lake-packages/lean4/src/lean/Lean/Widget/UserWidget.lean", "lake-packages/std/Std/Lean/Name.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Lean/Position.lean"], "premises": [{"full_name": "Std.Tactic.TryThis.tryThisWidget", "code": "@[widget] def tryThisWidget : Widget.UserWidgetDefinition where\n  name := \"Tactic replacement\"\n  javascript := \"\nimport * as React from 'react';\nimport { EditorContext } from '@leanprover/infoview';\nconst e = React.createElement;\nexport default function(props) {\n  const editorConnection = React.useContext(EditorContext)\n  function onClick() {\n    editorConnection.api.applyEdit({\n      changes: { [props.pos.uri]: [{ range: props.range, newText: props.suggestion }] }\n    })\n  }\n  return e('div', {className: 'ml1'}, e('pre', {className: 'font-code pre-wrap'}, [\n    'Try this: ',\n    e('a', {onClick, className: 'link pointer dim', title: 'Apply suggestion'}, props.suggestion),\n    props.info\n  ]))\n}\"", "start": [23, 1], "end": [45, 3], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.TryThis.tryThisProvider", "code": "@[code_action_provider] def tryThisProvider : CodeActionProvider := fun params snap => do\n  let doc \u2190 readDoc\n  pure <| snap.infoTree.foldInfo (init := #[]) fun _ctx info result => Id.run do\n    let .ofUserWidgetInfo { stx, widgetId := ``tryThisWidget, props } := info | result\n    let some stxRange := stx.getRange? | result\n    let stxRange := doc.meta.text.utf8RangeToLspRange stxRange\n    unless stxRange.start.line \u2264 params.range.end.line do return result\n    unless params.range.start.line \u2264 stxRange.end.line do return result\n    let .ok newText := props.getObjValAs? String \"suggestion\" | panic! \"bad type\"\n    let .ok range := props.getObjValAs? Lsp.Range \"range\" | panic! \"bad type\"\n    result.push {\n      eager.title := \"Apply 'Try this'\"\n      eager.kind? := \"quickfix\"\n      eager.isPreferred? := true\n      eager.edit? := some <| .ofTextEdit params.textDocument.uri { range, newText }\n    }", "start": [47, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.TryThis.replaceMVarsByUnderscores", "code": "partial def replaceMVarsByUnderscores [Monad m] [MonadQuotation m]\n    (s : Syntax) : m Syntax :=\n  s.replaceM fun s => do\n    let `(?$id:ident) := s | pure none\n    if id.getId.hasNum || id.getId.isInternal then `(?_) else pure none", "start": [68, 1], "end": [73, 72], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.TryThis.delabToRefinableSyntax", "code": "def delabToRefinableSyntax (e : Expr) : TermElabM Term :=\n  return \u27e8\u2190 replaceMVarsByUnderscores (\u2190 delab e)\u27e9", "start": [75, 1], "end": [77, 51], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.TryThis.inputWidth", "code": "def inputWidth : Nat := 100", "start": [79, 1], "end": [80, 28], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.TryThis.getInputWidth", "code": "def getInputWidth (o : Options) : Nat := format.inputWidth.get o", "start": [89, 1], "end": [90, 65], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.TryThis.addSuggestion", "code": "def addSuggestion (ref : Syntax) {kind : Name} (suggestion : TSyntax kind)\n    (suggestionForMessage? : Option MessageData := none)\n    (origSpan? : Option Syntax := none)\n    (extraMsg : String := \"\") : MetaM Unit := do\n  logInfoAt ref m!\"Try this: {suggestionForMessage?.getD suggestion}\"\n  if let some range := (origSpan?.getD ref).getRange? then\n    let map \u2190 getFileMap\n    let text \u2190 PrettyPrinter.ppCategory kind suggestion\n    let start := findLineStart map.source range.start\n    let body := map.source.findAux (\u00b7 \u2260 ' ') range.start start\n    let text := Format.prettyExtra text (w := getInputWidth (\u2190 getOptions))\n      (indent := (body - start).1) (column := (range.start - start).1)\n    let stxRange := ref.getRange?.getD range\n    let stxRange :=\n    { start := map.lineStart (map.toPosition stxRange.start).line\n      stop := map.lineStart ((map.toPosition stxRange.stop).line + 1) }\n    let range := map.utf8RangeToLspRange range\n    let json := Json.mkObj [(\"suggestion\", text), (\"range\", toJson range), (\"info\", extraMsg)]\n    Widget.saveWidgetInfo ``tryThisWidget json (.ofRange stxRange)", "start": [92, 1], "end": [126, 67], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.TryThis.addExactSuggestion", "code": "def addExactSuggestion (ref : Syntax) (e : Expr)\n    (origSpan? : Option Syntax := none) (addSubgoalsMsg := false) : TermElabM Unit := do\n  let stx \u2190 delabToRefinableSyntax e\n  let mvars \u2190 getMVars e\n  let tac \u2190 if mvars.isEmpty then `(tactic| exact $stx) else `(tactic| refine $stx)\n  let msg := if mvars.isEmpty then m!\"exact {e}\" else m!\"refine {e}\"\n  let extraMsg \u2190 if !addSubgoalsMsg || mvars.isEmpty then pure \"\" else\n    let mut str := \"\\nRemaining subgoals:\"\n    for g in mvars do\n      let e \u2190 PrettyPrinter.ppExpr (\u2190 instantiateMVars (\u2190 g.getType))\n      str := str ++ Format.pretty (\"\\n\u22a2 \" ++ e)\n    pure str\n  addSuggestion ref tac (suggestionForMessage? := msg)\n    (origSpan? := origSpan?) (extraMsg := extraMsg)", "start": [128, 1], "end": [150, 52], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.TryThis.addTermSuggestion", "code": "def addTermSuggestion (ref : Syntax) (e : Expr)\n    (origSpan? : Option Syntax := none) : TermElabM Unit := do\n  addSuggestion ref (\u2190 delabToRefinableSyntax e)\n    (suggestionForMessage? := e) (origSpan? := origSpan?)", "start": [152, 1], "end": [163, 58], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Meta.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/AbstractNestedProofs.lean", "lake-packages/lean4/src/lean/Lean/Meta/Transform.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eval.lean", "lake-packages/lean4/src/lean/Lean/Meta/AbstractMVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/ForEachExpr.lean", "lake-packages/lean4/src/lean/Lean/Meta/Reduce.lean", "lake-packages/lean4/src/lean/Lean/Meta/SynthInstance.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eqns.lean", "lake-packages/lean4/src/lean/Lean/Meta/WHNF.lean", "lake-packages/lean4/src/lean/Lean/Meta/ExprLens.lean", "lake-packages/lean4/src/lean/Lean/Meta/Inductive.lean", "lake-packages/lean4/src/lean/Lean/Meta/Closure.lean", "lake-packages/lean4/src/lean/Lean/Meta/ExprDefEq.lean", "lake-packages/lean4/src/lean/Lean/Meta/DecLevel.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/RecursorInfo.lean", "lake-packages/lean4/src/lean/Lean/Meta/ReduceEval.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Match.lean", "lake-packages/lean4/src/lean/Lean/Meta/CollectFVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/GeneralizeTelescope.lean", "lake-packages/lean4/src/lean/Lean/Meta/IndPredBelow.lean", "lake-packages/lean4/src/lean/Lean/Meta/CongrTheorems.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic.lean", "lake-packages/lean4/src/lean/Lean/Meta/CasesOn.lean", "lake-packages/lean4/src/lean/Lean/Meta/Structure.lean", "lake-packages/lean4/src/lean/Lean/Meta/InferType.lean", "lake-packages/lean4/src/lean/Lean/Meta/Coe.lean", "lake-packages/lean4/src/lean/Lean/Meta/Constructions.lean", "lake-packages/lean4/src/lean/Lean/Meta/Injective.lean", "lake-packages/lean4/src/lean/Lean/Meta/LevelDefEq.lean", "lake-packages/lean4/src/lean/Lean/Meta/GeneralizeVars.lean", "lake-packages/lean4/src/lean/Lean/Meta/ExprTraverse.lean", "lake-packages/lean4/src/lean/Lean/Meta/KAbstract.lean", "lake-packages/lean4/src/lean/Lean/Meta/UnificationHint.lean", "lake-packages/lean4/src/lean/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Lean/Meta/FunInfo.lean", "lake-packages/lean4/src/lean/Lean/Meta/Instances.lean", "lake-packages/lean4/src/lean/Lean/Meta/SizeOf.lean", "lake-packages/lean4/src/lean/Lean/Meta/PPGoal.lean", "lake-packages/lean4/src/lean/Lean/Meta/AppBuilder.lean"], "premises": []}
{"path": "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Simp.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Location.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Lean/Elab/BuiltinNotation.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Config.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Replace.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.SimpKind", "code": "inductive SimpKind where\n  | simp\n  | simpAll\n  | dsimp\n  deriving Inhabited, BEq", "start": [23, 1], "end": [27, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.tacticToDischarge", "code": "def tacticToDischarge (tacticCode : Syntax) : TacticM (IO.Ref Term.State \u00d7 Simp.Discharge) := do\n  let tacticCode \u2190 `(tactic| try ($tacticCode:tacticSeq))\n  let ref \u2190 IO.mkRef (\u2190 getThe Term.State)\n  let ctx \u2190 readThe Term.Context\n  let disch : Simp.Discharge := fun e => do\n    let mvar \u2190 mkFreshExprSyntheticOpaqueMVar e `simp.discharger\n    let s \u2190 ref.get\n    let runTac? : TermElabM (Option Expr) :=\n      try\n        \n        withoutModifyingStateWithInfoAndMessages do\n          Term.withSynthesize (mayPostpone := false) <| Term.runTactic mvar.mvarId! tacticCode\n          let result \u2190 instantiateMVars mvar\n          if result.hasExprMVar then\n            return none\n          else\n            return some result\n      catch _ =>\n        return none\n    let (result?, s) \u2190 liftM (m := MetaM) <| Term.TermElabM.run runTac? ctx s\n    ref.set s\n    return result?\n  return (ref, disch)", "start": [29, 1], "end": [59, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Simp.DischargeWrapper", "code": "inductive Simp.DischargeWrapper where\n  | default\n  | custom (ref : IO.Ref Term.State) (discharge : Simp.Discharge)", "start": [61, 1], "end": [63, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.Simp.DischargeWrapper.with", "code": "def Simp.DischargeWrapper.with (w : Simp.DischargeWrapper) (x : Option Simp.Discharge \u2192 TacticM \u03b1) : TacticM \u03b1 := do\n  match w with\n  | default => x none\n  | custom ref d =>\n    ref.set (\u2190 getThe Term.State)\n    try\n      x d\n    finally\n      set (\u2190 ref.get)", "start": [65, 1], "end": [73, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.mkDischargeWrapper", "code": "private def mkDischargeWrapper (optDischargeSyntax : Syntax) : TacticM Simp.DischargeWrapper := do\n  if optDischargeSyntax.isNone then\n    return Simp.DischargeWrapper.default\n  else\n    let (ref, d) \u2190 tacticToDischarge optDischargeSyntax[0][3]\n    return Simp.DischargeWrapper.custom ref d", "start": [75, 1], "end": [80, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.elabSimpConfig", "code": "def elabSimpConfig (optConfig : Syntax) (kind : SimpKind) : TermElabM Meta.Simp.Config := do\n  match kind with\n  | .simp    => elabSimpConfigCore optConfig\n  | .simpAll => return (\u2190 elabSimpConfigCtxCore optConfig).toConfig\n  | .dsimp   => return { (\u2190 elabDSimpConfigCore optConfig) with }", "start": [85, 1], "end": [89, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.addDeclToUnfoldOrTheorem", "code": "private def addDeclToUnfoldOrTheorem (thms : Meta.SimpTheorems) (id : Origin) (e : Expr) (post : Bool) (inv : Bool) (kind : SimpKind) : MetaM Meta.SimpTheorems := do\n  if e.isConst then\n    let declName := e.constName!\n    let info \u2190 getConstInfo declName\n    if (\u2190 isProp info.type) then\n      thms.addConst declName (post := post) (inv := inv)\n    else\n      if inv then\n        throwError \"invalid '\u2190' modifier, '{declName}' is a declaration name to be unfolded\"\n      if kind == .dsimp then\n        return thms.addDeclToUnfoldCore declName\n      else\n        thms.addDeclToUnfold declName\n  else\n    thms.add id #[] e (post := post) (inv := inv)", "start": [91, 1], "end": [105, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.addSimpTheorem", "code": "private def addSimpTheorem (thms : Meta.SimpTheorems) (id : Origin) (stx : Syntax) (post : Bool) (inv : Bool) : TermElabM Meta.SimpTheorems := do\n  let (levelParams, proof) \u2190 Term.withoutModifyingElabMetaStateWithInfo <| withRef stx <| Term.withoutErrToSorry do\n    let e \u2190 Term.elabTerm stx none\n    Term.synthesizeSyntheticMVars (mayPostpone := false) (ignoreStuckTC := true)\n    let e \u2190 instantiateMVars e\n    let e := e.eta\n    if e.hasMVar then\n      let r \u2190 abstractMVars e\n      return (r.paramNames, r.expr)\n    else\n      return (#[], e)\n  thms.add id levelParams proof (post := post) (inv := inv)", "start": [107, 1], "end": [118, 60], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ElabSimpArgsResult", "code": "structure ElabSimpArgsResult where\n  ctx     : Simp.Context\n  starArg : Bool := false", "start": [120, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.ResolveSimpIdResult", "code": "inductive ResolveSimpIdResult where\n  | none\n  | expr (e : Expr)\n  | ext  (ext : SimpExtension)", "start": [124, 1], "end": [127, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.elabSimpArgs", "code": "def elabSimpArgs (stx : Syntax) (ctx : Simp.Context) (eraseLocal : Bool) (kind : SimpKind) : TacticM ElabSimpArgsResult := do\n  if stx.isNone then\n    return { ctx }\n  else\n    \n    withMainContext do\n      let mut thmsArray := ctx.simpTheorems\n      let mut thms      := thmsArray[0]!\n      let mut starArg   := false\n      for arg in stx[1].getSepArgs do\n        if arg.getKind == ``Lean.Parser.Tactic.simpErase then\n          let fvar \u2190 if eraseLocal || starArg then Term.isLocalIdent? arg[1] else pure none\n          if let some fvar := fvar then\n            thms := thms.eraseCore (.fvar fvar.fvarId!)\n          else\n            let declName \u2190 resolveGlobalConstNoOverloadWithInfo arg[1]\n            if ctx.config.autoUnfold then\n              thms := thms.eraseCore (.decl declName)\n            else\n              thms \u2190 thms.erase (.decl declName)\n        else if arg.getKind == ``Lean.Parser.Tactic.simpLemma then\n          let post :=\n            if arg[0].isNone then\n              true\n            else\n              arg[0][0].getKind == ``Parser.Tactic.simpPost\n          let inv  := !arg[1].isNone\n          let term := arg[2]\n\n          match (\u2190 resolveSimpIdTheorem? term) with\n          | .expr e  =>\n            let name \u2190 mkFreshId\n            thms \u2190 addDeclToUnfoldOrTheorem thms (.stx name arg) e post inv kind\n          | .ext ext =>\n            thmsArray := thmsArray.push (\u2190 ext.getTheorems)\n          | .none    =>\n            let name \u2190 mkFreshId\n            thms \u2190 addSimpTheorem thms (.stx name arg) term post inv\n        else if arg.getKind == ``Lean.Parser.Tactic.simpStar then\n          starArg := true\n        else\n          throwUnsupportedSyntax\n      return { ctx := { ctx with simpTheorems := thmsArray.set! 0 thms }, starArg }\nwhere\n  resolveSimpIdTheorem? (simpArgTerm : Term) : TacticM ResolveSimpIdResult := do\n    let resolveExt (n : Name) : TacticM ResolveSimpIdResult := do\n      if let some ext \u2190 getSimpExtension? n then\n        return .ext ext\n      else\n        return .none\n    match simpArgTerm with\n    | `($id:ident) =>\n      try\n        if let some e \u2190 Term.resolveId? simpArgTerm (withInfo := true) then\n          return .expr e\n        else\n          resolveExt id.getId.eraseMacroScopes\n      catch _ =>\n        resolveExt id.getId.eraseMacroScopes\n    | _ =>\n      if let some e \u2190 Term.elabCDotFunctionAlias? simpArgTerm then\n        return .expr e\n      else\n        return .none", "start": [129, 1], "end": [204, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.simpOnlyBuiltins", "code": "@[inline] def simpOnlyBuiltins : List Name := [``eq_self, ``iff_self]", "start": [206, 1], "end": [206, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.MkSimpContextResult", "code": "structure MkSimpContextResult where\n  ctx              : Simp.Context\n  dischargeWrapper : Simp.DischargeWrapper", "start": [208, 1], "end": [210, 43], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.mkSimpContext", "code": "def mkSimpContext (stx : Syntax) (eraseLocal : Bool) (kind := SimpKind.simp) (ignoreStarArg : Bool := false) : TacticM MkSimpContextResult := do\n  if !stx[2].isNone then\n    if kind == SimpKind.simpAll then\n      throwError \"'simp_all' tactic does not support 'discharger' option\"\n    if kind == SimpKind.dsimp then\n      throwError \"'dsimp' tactic does not support 'discharger' option\"\n  let dischargeWrapper \u2190 mkDischargeWrapper stx[2]\n  let simpOnly := !stx[3].isNone\n  let simpTheorems \u2190 if simpOnly then\n    simpOnlyBuiltins.foldlM (\u00b7.addConst \u00b7) ({} : SimpTheorems)\n  else\n    getSimpTheorems\n  let congrTheorems \u2190 getSimpCongrTheorems\n  let r \u2190 elabSimpArgs stx[4] (eraseLocal := eraseLocal) (kind := kind) {\n    config      := (\u2190 elabSimpConfig stx[1] (kind := kind))\n    simpTheorems := #[simpTheorems], congrTheorems\n  }\n  if !r.starArg || ignoreStarArg then\n    return { r with dischargeWrapper }\n  else\n    let ctx := r.ctx\n    let mut simpTheorems := ctx.simpTheorems\n    let hs \u2190 getPropHyps\n    for h in hs do\n      unless simpTheorems.isErased (.fvar h) do\n        simpTheorems \u2190 simpTheorems.addTheorem (.fvar h) (\u2190 h.getDecl).toExpr\n    let ctx := { ctx with simpTheorems }\n    return { ctx, dischargeWrapper }", "start": [212, 1], "end": [245, 37], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.traceSimpCall", "code": "def traceSimpCall (stx : Syntax) (usedSimps : UsedSimps) : MetaM Unit := do\n  let mut stx := stx\n  if stx[3].isNone then\n    stx := stx.setArg 3 (mkNullNode #[mkAtom \"only\"])\n  let mut args := #[]\n  let mut localsOrStar := some #[]\n  let lctx \u2190 getLCtx\n  let env \u2190 getEnv\n  for (thm, _) in usedSimps.toArray.qsort (\u00b7.2 < \u00b7.2) do\n    match thm with\n    | .decl declName inv => if env.contains declName && (inv || !simpOnlyBuiltins.contains declName) then\n        args := args.push (if inv then\n          (\u2190 `(Parser.Tactic.simpLemma| \u2190 $(mkIdent (\u2190 unresolveNameGlobal declName)):ident))\n        else\n          (\u2190 `(Parser.Tactic.simpLemma| $(mkIdent (\u2190 unresolveNameGlobal declName)):ident)))\n    | .fvar fvarId => if let some ldecl := lctx.find? fvarId then\n        localsOrStar := localsOrStar.bind fun locals =>\n          if !ldecl.userName.isInaccessibleUserName &&\n              (lctx.findFromUserName? ldecl.userName).get!.fvarId == ldecl.fvarId then\n            some (locals.push ldecl.userName)\n          else\n            none\n      | .stx _ thmStx => args := args.push thmStx\n    | .other _ => pure ()     if let some locals := localsOrStar then\n    args := args ++ (\u2190 locals.mapM fun id => `(Parser.Tactic.simpLemma| $(mkIdent id):ident))\n  else\n    args := args.push (\u2190 `(Parser.Tactic.simpStar| *))\n  let argsStx := if args.isEmpty then #[] else #[mkAtom \"[\", (mkAtom \",\").mkSep args, mkAtom \"]\"]\n  stx := stx.setArg 4 (mkNullNode argsStx)\n  logInfoAt stx[0] m!\"Try this: {stx}\"", "start": [252, 1], "end": [288, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.simpLocation", "code": "def simpLocation (ctx : Simp.Context) (discharge? : Option Simp.Discharge := none) (loc : Location) : TacticM UsedSimps := do\n  match loc with\n  | Location.targets hyps simplifyTarget =>\n    withMainContext do\n      let fvarIds \u2190 getFVarIds hyps\n      go fvarIds simplifyTarget\n  | Location.wildcard =>\n    withMainContext do\n      go (\u2190 (\u2190 getMainGoal).getNondepPropHyps) (simplifyTarget := true)\nwhere\n  go (fvarIdsToSimp : Array FVarId) (simplifyTarget : Bool) : TacticM UsedSimps := do\n    let mvarId \u2190 getMainGoal\n    let (result?, usedSimps) \u2190 simpGoal mvarId ctx (simplifyTarget := simplifyTarget) (discharge? := discharge?) (fvarIdsToSimp := fvarIdsToSimp)\n    match result? with\n    | none => replaceMainGoal []\n    | some (_, mvarId) => replaceMainGoal [mvarId]\n    return usedSimps", "start": [290, 1], "end": [320, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalSimp", "code": "@[builtin_tactic Lean.Parser.Tactic.simp] def evalSimp : Tactic := fun stx => do\n  let { ctx, dischargeWrapper } \u2190 withMainContext <| mkSimpContext stx (eraseLocal := false)\n  let usedSimps \u2190 dischargeWrapper.with fun discharge? =>\n    simpLocation ctx discharge? (expandOptLocation stx[5])\n  if tactic.simp.trace.get (\u2190 getOptions) then\n    traceSimpCall stx usedSimps", "start": [325, 1], "end": [330, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalSimpAll", "code": "@[builtin_tactic Lean.Parser.Tactic.simpAll] def evalSimpAll : Tactic := fun stx => do\n  let { ctx, .. } \u2190 mkSimpContext stx (eraseLocal := true) (kind := .simpAll) (ignoreStarArg := true)\n  let (result?, usedSimps) \u2190 simpAll (\u2190 getMainGoal) ctx\n  match result? with\n  | none => replaceMainGoal []\n  | some mvarId => replaceMainGoal [mvarId]\n  if tactic.simp.trace.get (\u2190 getOptions) then\n    traceSimpCall stx usedSimps", "start": [332, 1], "end": [339, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.dsimpLocation", "code": "def dsimpLocation (ctx : Simp.Context) (loc : Location) : TacticM Unit := do\n  match loc with\n  | Location.targets hyps simplifyTarget =>\n    withMainContext do\n      let fvarIds \u2190 getFVarIds hyps\n      go fvarIds simplifyTarget\n  | Location.wildcard =>\n    withMainContext do\n      go (\u2190 (\u2190 getMainGoal).getNondepPropHyps) (simplifyTarget := true)\nwhere\n  go (fvarIdsToSimp : Array FVarId) (simplifyTarget : Bool) : TacticM Unit := do\n    let mvarId \u2190 getMainGoal\n    let (result?, usedSimps) \u2190 dsimpGoal mvarId ctx (simplifyTarget := simplifyTarget) (fvarIdsToSimp := fvarIdsToSimp)\n    match result? with\n    | none => replaceMainGoal []\n    | some mvarId => replaceMainGoal [mvarId]\n    if tactic.simp.trace.get (\u2190 getOptions) then\n      traceSimpCall (\u2190 getRef) usedSimps", "start": [341, 1], "end": [358, 41], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.evalDSimp", "code": "@[builtin_tactic Lean.Parser.Tactic.dsimp] def evalDSimp : Tactic := fun stx => do\n  let { ctx, .. } \u2190 withMainContext <| mkSimpContext stx (eraseLocal := false) (kind := .dsimp)\n  dsimpLocation ctx (expandOptLocation stx[5])", "start": [360, 1], "end": [362, 47], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Lean/Parser.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Parser.Tactic.simpArg", "code": "def simpArg := simpStar.binary `orelse (simpErase.binary `orelse simpLemma)", "start": [10, 1], "end": [14, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.getSimpArgs?", "code": "def getSimpArgs? : Syntax \u2192 Option (Array Syntax)\n  | `(simpArgs| [$args,*]) => pure args.getElems\n  | _ => none", "start": [19, 1], "end": [22, 14], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.dsimpArg", "code": "def dsimpArg := simpErase.binary `orelse simpLemma", "start": [25, 1], "end": [29, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.Parser.Tactic.getDSimpArgs?", "code": "def getDSimpArgs? : Syntax \u2192 Option (Array Syntax)\n  | `(dsimpArgs| [$args,*]) => pure args.getElems\n  | _                       => none", "start": [34, 1], "end": [37, 36], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/BaseTypes.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Types.lean", "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/CompilerM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.BaseTypeExtState", "code": "structure BaseTypeExtState where\n  \n  base : PHashMap Name Expr := {}\n  deriving Inhabited", "start": [11, 1], "end": [19, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getOtherDeclBaseType", "code": "def getOtherDeclBaseType (declName : Name) (us : List Level) : CoreM Expr := do\n  let info \u2190 getConstInfo declName\n  let type \u2190 match baseTypeExt.getState (\u2190 getEnv) |>.base.find? declName with\n    | some type => pure type\n    | none =>\n      let type \u2190 Meta.MetaM.run' <| toLCNFType info.type\n      modifyEnv fun env => baseTypeExt.modifyState env fun s => { s with base := s.base.insert declName type }\n      pure type\n  return type.instantiateLevelParamsNoCache info.levelParams us", "start": [24, 1], "end": [32, 64], "kind": "commanddeclaration"}]}
{"path": "lake-packages/lean4/src/lean/Lean/Compiler/LCNF/Util.lean", "imports": ["lake-packages/lean4/src/lean/Lean/MonadEnv.lean", "lake-packages/lean4/src/lean/Lean/CoreM.lean", "lake-packages/lean4/src/lean/Lean/Util/Recognizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Compiler.LCNF.isCompilerRelevantMData", "code": "def isCompilerRelevantMData (_mdata : MData) : Bool :=\n  false", "start": [11, 1], "end": [17, 8], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isLcCast?", "code": "def isLcCast? (e : Expr) : Option Expr :=\n  if e.isAppOfArity ``lcCast 3 then\n    some e.appArg!\n  else\n    none", "start": [19, 1], "end": [26, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CasesInfo", "code": "structure CasesInfo where\n  declName     : Name\n  arity        : Nat\n  numParams    : Nat\n  discrPos     : Nat\n  altsRange    : Std.Range\n  altNumParams : Array Nat\n  motivePos    : Nat", "start": [28, 1], "end": [40, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.CasesInfo.numAlts", "code": "def CasesInfo.numAlts (c : CasesInfo) : Nat :=\n  c.altNumParams.size", "start": [42, 1], "end": [43, 22], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getCasesOnInductiveVal?", "code": "private def getCasesOnInductiveVal? (declName : Name) : CoreM (Option InductiveVal) := do\n  unless isCasesOnRecursor (\u2190 getEnv) declName do return none\n  let .inductInfo val \u2190 getConstInfo declName.getPrefix | return none\n  return some val", "start": [45, 1], "end": [48, 18], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getCasesInfo?", "code": "def getCasesInfo? (declName : Name) : CoreM (Option CasesInfo) := do\n  let some val \u2190 getCasesOnInductiveVal? declName | return none\n  let numParams    := val.numParams\n  let motivePos    := numParams\n  let arity        := numParams + 1  + val.numIndices + 1  + val.numCtors\n  let discrPos     := numParams + 1  + val.numIndices\n  let altsRange    := { start := discrPos + 1,  stop := arity }\n  let altNumParams \u2190 val.ctors.toArray.mapM fun ctor => do\n    let .ctorInfo ctorVal \u2190 getConstInfo ctor | unreachable!\n    return ctorVal.numFields\n  return some { declName, numParams, motivePos, arity, discrPos, altsRange, altNumParams }", "start": [50, 1], "end": [61, 91], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isCasesApp?", "code": "def isCasesApp? (e : Expr) : CoreM (Option CasesInfo) := do\n  let .const declName _ := e.getAppFn | return none\n  if let some info \u2190 getCasesInfo? declName then\n    assert! info.arity == e.getAppNumArgs\n    return some info\n  else\n    return none", "start": [63, 1], "end": [69, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.getCtorArity?", "code": "def getCtorArity? (declName : Name) : CoreM (Option Nat) := do\n  let .ctorInfo val \u2190 getConstInfo declName | return none\n  return val.numParams + val.numFields", "start": [71, 1], "end": [73, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.builtinRuntimeTypes", "code": "def builtinRuntimeTypes : List Name := [\n  ``String,\n  ``UInt8, ``UInt16, ``UInt32, ``UInt64, ``USize,\n  ``Float,\n  ``Thunk, ``Task,\n  ``Array, ``ByteArray, ``FloatArray,\n  ``Nat, ``Int\n]", "start": [75, 1], "end": [85, 2], "kind": "commanddeclaration"}, {"full_name": "Lean.Compiler.LCNF.isRuntimeBultinType", "code": "def isRuntimeBultinType (declName : Name) : Bool :=\n  builtinRuntimeTypes.contains declName", "start": [87, 1], "end": [91, 40], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Data/Array/Basic.lean", "imports": ["lake-packages/std/Std/Data/Ord.lean", "lake-packages/std/Std/Data/Array/Init/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Array.range", "code": "def range (n : Nat) : Array Nat :=\n  n.fold (flip Array.push) #[]", "start": [18, 1], "end": [20, 31], "kind": "commanddeclaration"}, {"full_name": "Array.reduceOption", "code": "def reduceOption (l : Array (Option \u03b1)) : Array \u03b1 :=\n  l.filterMap id", "start": [22, 1], "end": [24, 17], "kind": "commanddeclaration"}, {"full_name": "Array.flatten", "code": "def flatten (arr : Array (Array \u03b1)) : Array \u03b1 :=\n  arr.foldl (init := #[]) fun acc a => acc.append a", "start": [26, 1], "end": [28, 52], "kind": "commanddeclaration"}, {"full_name": "Array.zipWithIndex", "code": "def zipWithIndex (arr : Array \u03b1) : Array (\u03b1 \u00d7 Nat) :=\n  arr.mapIdx fun i a => (a, i)", "start": [30, 1], "end": [32, 31], "kind": "commanddeclaration"}, {"full_name": "Array.equalSet", "code": "def equalSet [BEq \u03b1] (xs ys : Array \u03b1) : Bool :=\n  xs.all (ys.contains \u00b7) && ys.all (xs.contains \u00b7)", "start": [34, 1], "end": [41, 51], "kind": "commanddeclaration"}, {"full_name": "Array.qsortOrd", "code": "def qsortOrd [ord : Ord \u03b1] (xs : Array \u03b1) : Array \u03b1 :=\n  xs.qsort \u03bb x y => compare x y |>.isLT", "start": [44, 1], "end": [48, 40], "kind": "commanddeclaration"}, {"full_name": "Array.minD", "code": "@[inline]\nprotected def minD [ord : Ord \u03b1]\n    (xs : Array \u03b1) (d : \u03b1) (start := 0) (stop := xs.size) : \u03b1 :=\n  xs.foldl (init := d) (start := start) (stop := stop) \u03bb min x =>\n    if compare x min |>.isLT then x else min", "start": [51, 1], "end": [60, 45], "kind": "commanddeclaration"}, {"full_name": "Array.min?", "code": "@[inline]\nprotected def min? [ord : Ord \u03b1]\n    (xs : Array \u03b1) (start := 0) (stop := xs.size) : Option \u03b1 :=\n  if h : start < xs.size then\n    some $ xs.minD (xs.get \u27e8start, h\u27e9) start stop\n  else\n    none", "start": [63, 1], "end": [74, 9], "kind": "commanddeclaration"}, {"full_name": "Array.minI", "code": "@[inline]\nprotected def minI [ord : Ord \u03b1] [Inhabited \u03b1]\n    (xs : Array \u03b1) (start := 0) (stop := xs.size) : \u03b1 :=\n  xs.minD default start stop", "start": [77, 1], "end": [85, 29], "kind": "commanddeclaration"}, {"full_name": "Array.maxD", "code": "@[inline]\nprotected def maxD [ord : Ord \u03b1]\n    (xs : Array \u03b1) (d : \u03b1) (start := 0) (stop := xs.size) : \u03b1 :=\n  xs.minD (ord := ord.opposite) d start stop", "start": [88, 1], "end": [96, 45], "kind": "commanddeclaration"}, {"full_name": "Array.max?", "code": "@[inline]\nprotected def max? [ord : Ord \u03b1]\n    (xs : Array \u03b1) (start := 0) (stop := xs.size) : Option \u03b1 :=\n  xs.min? (ord := ord.opposite) start stop", "start": [99, 1], "end": [107, 43], "kind": "commanddeclaration"}, {"full_name": "Array.maxI", "code": "@[inline]\nprotected def maxI [ord : Ord \u03b1] [Inhabited \u03b1]\n    (xs : Array \u03b1) (start := 0) (stop := xs.size) : \u03b1 :=\n  xs.minI (ord := ord.opposite) start stop", "start": [110, 1], "end": [118, 43], "kind": "commanddeclaration"}, {"full_name": "Subarray.empty", "code": "protected def empty : Subarray \u03b1 where\n  as := #[]\n  start := 0\n  stop := 0\n  h\u2081 := Nat.le_refl 0\n  h\u2082 := Nat.le_refl 0", "start": [125, 1], "end": [133, 22], "kind": "commanddeclaration"}, {"full_name": "Subarray.isEmpty", "code": "@[inline]\ndef isEmpty (as : Subarray \u03b1) : Bool :=\n  as.start == as.stop", "start": [141, 1], "end": [146, 22], "kind": "commanddeclaration"}, {"full_name": "Subarray.contains", "code": "@[inline]\ndef contains [BEq \u03b1] (as : Subarray \u03b1) (a : \u03b1) : Bool :=\n  as.any (\u00b7 == a)", "start": [148, 1], "end": [153, 18], "kind": "commanddeclaration"}, {"full_name": "Subarray.popHead?", "code": "def popHead? (as : Subarray \u03b1) : Option (\u03b1 \u00d7 Subarray \u03b1) :=\n  if h : as.start < as.stop\n    then\n      let head := as.as.get \u27e8as.start, Nat.lt_of_lt_of_le h as.h\u2082\u27e9\n      let tail :=\n        { as with\n          start := as.start + 1\n          h\u2081 := Nat.le_of_lt_succ $ Nat.succ_lt_succ h  }\n      some (head, tail)\n    else\n      none", "start": [155, 1], "end": [169, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/Lint/Basic.lean", "imports": ["lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/std/Std/Lean/NameMapAttribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.Lint.isAutoDecl", "code": "def isAutoDecl (decl : Name) : CoreM Bool := do\n  if decl.hasMacroScopes then return true\n  if decl.isInternal then return true\n  if let Name.str n s := decl then\n    if s.startsWith \"proof_\" || s.startsWith \"match_\" then return true\n    if (\u2190 getEnv).isConstructor n && [\"injEq\", \"inj\", \"sizeOf_spec\"].any (\u00b7 == s) then\n      return true\n    if let ConstantInfo.inductInfo _ := (\u2190 getEnv).find? n then\n      if [casesOnSuffix, recOnSuffix, brecOnSuffix, binductionOnSuffix, belowSuffix, \"ibelow\",\n          \"ndrec\", \"ndrecOn\", \"noConfusionType\", \"noConfusion\", \"ofNat\", \"toCtorIdx\"\n        ].any (\u00b7 == s) then\n        return true\n      if let some _ := isSubobjectField? (\u2190 getEnv) n s then\n        return true\n  pure false", "start": [27, 1], "end": [47, 13], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.Linter", "code": "structure Linter where\n  \n  test : Name \u2192 MetaM (Option MessageData)\n  \n  noErrorsFound : MessageData\n  \n  errorsFound : MessageData\n  \n  isFast := true", "start": [49, 1], "end": [59, 17], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.NamedLinter", "code": "structure NamedLinter extends Linter where\n  \n  name : Name\n  \n  declName : Name", "start": [61, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.getLinter", "code": "def getLinter (name declName : Name) : CoreM NamedLinter := unsafe\n  return { \u2190 evalConstCheck Linter ``Linter declName with name, declName }", "start": [68, 1], "end": [70, 75], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.Lint.shouldBeLinted", "code": "def shouldBeLinted [Monad m] [MonadEnv m] (linter : Name) (decl : Name) : m Bool :=\n  return !((nolintAttr.getParam? (\u2190 getEnv) decl).getD #[]).contains linter", "start": [128, 1], "end": [131, 76], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Linter.lean", "imports": ["lake-packages/std/Std/Linter/UnreachableTactic.lean", "lake-packages/std/Std/Linter/UnnecessarySeqFocus.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Tactic/ByCases.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "expandIfThenElse", "code": "private def expandIfThenElse\n    (ifTk thenTk elseTk pos neg : Syntax)\n    (mkIf : Term \u2192 Term \u2192 MacroM Term) : MacroM (TSyntax `tactic) := do\n  let mkCase tk holeOrTacticSeq mkName : MacroM (Term \u00d7 Array (TSyntax `tactic)) := do\n    if holeOrTacticSeq.isOfKind ``Parser.Term.syntheticHole then\n      pure (\u27e8holeOrTacticSeq\u27e9, #[])\n    else if holeOrTacticSeq.isOfKind ``Parser.Term.hole then\n      pure (\u2190 mkName, #[])\n    else\n      let hole \u2190 withFreshMacroScope mkName\n      let holeId := hole.raw[1]\n      let case \u2190 (open TSyntax.Compat in `(tactic|\n          case $holeId:ident =>%$tk\n            with_annotate_state $tk skip\n            $holeOrTacticSeq))\n      pure (hole, #[case])\n  let (posHole, posCase) \u2190 mkCase thenTk pos `(?pos)\n  let (negHole, negCase) \u2190 mkCase elseTk neg `(?neg)\n  `(tactic| (open Classical in refine%$ifTk $(\u2190 mkIf posHole negHole); $[$(posCase ++ negCase)]*))", "start": [22, 1], "end": [41, 99], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/GuardExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eval.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Std.Tactic.GuardExpr.MatchKind", "code": "inductive MatchKind\n\n| syntactic\n\n| defEq (red : TransparencyMode := .reducible)\n\n| alphaEq", "start": [15, 1], "end": [26, 10], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardExpr.colon.toMatchKind", "code": "def colon.toMatchKind : TSyntax ``colon \u2192 Option MatchKind\n  | `(colon| :) => some .defEq\n  | `(colon| :~) => some (.defEq .default)\n  | `(colon| :\u209b) => some .syntactic\n  | `(colon| :\u2090) => some .alphaEq\n  | _ => none", "start": [61, 1], "end": [67, 14], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardExpr.colonEq.toMatchKind", "code": "def colonEq.toMatchKind : TSyntax ``colonEq \u2192 Option MatchKind\n  | `(colonEq| :=) => some .defEq\n  | `(colonEq| :=~) => some (.defEq .default)\n  | `(colonEq| :=\u209b) => some .syntactic\n  | `(colonEq| :=\u2090) => some .alphaEq\n  | _ => none", "start": [69, 1], "end": [75, 14], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardExpr.equal.toMatchKind", "code": "def equal.toMatchKind : TSyntax ``equal \u2192 Option MatchKind\n  | `(equal| =) => some .defEq\n  | `(equal| =~) => some (.defEq .default)\n  | `(equal| =\u209b) => some .syntactic\n  | `(equal| =\u2090) => some .alphaEq\n  | _ => none", "start": [77, 1], "end": [83, 14], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardExpr.MatchKind.isEq", "code": "def MatchKind.isEq (a b : Expr) : MatchKind \u2192 MetaM Bool\n  | .syntactic => return a.consumeMData == b.consumeMData\n  | .alphaEq => return a.eqv b\n  | .defEq red => withoutModifyingState <| withTransparency red <| Lean.Meta.isDefEqGuarded a b", "start": [85, 1], "end": [89, 96], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardExpr.elabAndEvalMatchKind", "code": "def elabAndEvalMatchKind (mk : MatchKind) (a b : Term) : TermElabM Bool :=\n  Term.withoutErrToSorry do\n    let a \u2190 Term.elabTerm a none\n    let b \u2190 Term.elabTerm b none\n    _ \u2190 isDefEqGuarded (\u2190 inferType a) (\u2190 inferType b)\n    Term.synthesizeSyntheticMVarsNoPostponing\n    mk.isEq (\u2190 instantiateMVars a) (\u2190 instantiateMVars b)", "start": [105, 1], "end": [115, 58], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardExpr.evalGuardExpr", "code": "@[inherit_doc guardExpr, tactic guardExpr, tactic guardExprConv]\ndef evalGuardExpr : Tactic := fun\n  | `(tactic| guard_expr $r $eq:equal $p)\n  | `(conv| guard_expr $r $eq:equal $p) => withMainContext do\n    let some mk := equal.toMatchKind eq | throwUnsupportedSyntax\n    let res \u2190 elabAndEvalMatchKind mk r p\n    unless res do throwError \"failed: {r}{eq} {p} is not true\"\n  | _ => throwUnsupportedSyntax", "start": [117, 1], "end": [125, 32], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardExpr.evalGuardTarget", "code": "@[inherit_doc guardTarget, tactic guardTarget, tactic guardTargetConv]\ndef evalGuardTarget : Tactic :=\n  let go eq r getTgt := withMainContext do\n    let t \u2190 getTgt >>= instantiateMVars\n    let r \u2190 elabTerm r (\u2190 inferType t)\n    let some mk := equal.toMatchKind eq | throwUnsupportedSyntax\n    unless \u2190 mk.isEq r t do throwError \"target of main goal is {t}, not {r}\"\n  fun\n  | `(tactic| guard_target $eq $r) => go eq r getMainTarget\n  | `(conv| guard_target $eq $r) => go eq r Conv.getLhs\n  | _ => throwUnsupportedSyntax", "start": [140, 1], "end": [150, 32], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardExpr.evalGuardHyp", "code": "@[inherit_doc guardHyp, tactic guardHyp, tactic guardHypConv]\ndef evalGuardHyp : Tactic := fun\n  | `(tactic| guard_hyp $h $[$c $ty]? $[$eq $val]?)\n  | `(conv| guard_hyp $h $[$c $ty]? $[$eq $val]?) => withMainContext do\n    let fvarid \u2190 getFVarId h\n    let lDecl \u2190\n      match (\u2190 getLCtx).find? fvarid with\n      | none => throwError m!\"hypothesis {h} not found\"\n      | some lDecl => pure lDecl\n    if let (some c, some p) := (c, ty) then\n      let some mk := colon.toMatchKind c | throwUnsupportedSyntax\n      let e \u2190 elabTerm p none\n      let hty \u2190 instantiateMVars lDecl.type\n      unless \u2190 mk.isEq e hty do throwError m!\"hypothesis {h} has type {hty}, not {e}\"\n    match lDecl.value?, val with\n    | none, some _        => throwError m!\"{h} is not a let binding\"\n    | some _, none        => throwError m!\"{h} is a let binding\"\n    | some hval, some val =>\n      let some mk := eq.bind colonEq.toMatchKind | throwUnsupportedSyntax\n      let e \u2190 elabTerm val lDecl.type\n      let hval \u2190 instantiateMVars hval\n      unless \u2190 mk.isEq e hval do throwError m!\"hypothesis {h} has value {hval}, not {e}\"\n    | none, none          => pure ()\n  | _ => throwUnsupportedSyntax", "start": [171, 1], "end": [194, 32], "kind": "commanddeclaration"}, {"full_name": "Std.Tactic.GuardExpr.evalGuardExprCmd", "code": "@[inherit_doc guardExprCmd, command_elab guardExprCmd]\ndef evalGuardExprCmd : Lean.Elab.Command.CommandElab\n  | `(command| #guard_expr $r $eq:equal $p) =>\n    Lean.Elab.Command.runTermElabM fun _ => do\n      let some mk := equal.toMatchKind eq | throwUnsupportedSyntax\n      let res \u2190 elabAndEvalMatchKind mk r p\n      unless res do throwError \"failed: {r}{eq} {p} is not true\"\n  | _ => throwUnsupportedSyntax", "start": [206, 1], "end": [214, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/ShowTerm.lean", "imports": ["lake-packages/std/Std/Tactic/TryThis.lean", "lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Lean/Tactic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.evalTacticAtRaw", "code": "def evalTacticAtRaw (tac : Syntax) (mvarId : MVarId) : TacticM (List MVarId) := do\n  setGoals [mvarId]\n  evalTactic tac\n  getGoals", "start": [10, 1], "end": [17, 11], "kind": "commanddeclaration"}]}
{"path": "lake-packages/std/Std/Tactic/SeqFocus.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/ElabRules.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "lake-packages/std/Std/Lean/Meta/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.LocalDecl.setKind", "code": "def LocalDecl.setKind : LocalDecl \u2192 LocalDeclKind \u2192 LocalDecl\n  | cdecl index fvarId userName type bi _, kind =>\n      cdecl index fvarId userName type bi kind\n  | ldecl index fvarId userName type value nonDep _, kind =>\n      ldecl index fvarId userName type value nonDep kind", "start": [12, 1], "end": [19, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.setKind", "code": "def setKind (lctx : LocalContext) (fvarId : FVarId)\n    (kind : LocalDeclKind) : LocalContext :=\n  lctx.modifyLocalDecl fvarId (\u00b7.setKind kind)", "start": [24, 1], "end": [29, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.LocalContext.sortFVarsByContextOrder", "code": "def sortFVarsByContextOrder (lctx : LocalContext) (hyps : Array FVarId) :\n    Array FVarId :=\n  let hyps := hyps.map \u03bb fvarId =>\n    match lctx.fvarIdToDecl.find? fvarId with\n    | none => (0, fvarId)\n    | some ldecl => (ldecl.index, fvarId)\n  hyps.qsort (\u03bb h i => h.fst < i.fst) |>.map (\u00b7.snd)", "start": [31, 1], "end": [41, 53], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.sortFVarsByContextOrder", "code": "def Meta.sortFVarsByContextOrder [Monad m] [MonadLCtx m]\n    (hyps : Array FVarId) : m (Array FVarId) :=\n  return (\u2190 getLCtx).sortFVarsByContextOrder hyps", "start": [46, 1], "end": [53, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.getExprMVarDecl", "code": "def getExprMVarDecl [Monad m] [MonadError m] (mctx : MetavarContext)\n    (mvarId : MVarId) : m MetavarDecl := do\n  if let some mdecl := mctx.decls.find? mvarId then\n    return mdecl\n  else\n    throwError \"unknown metavariable '?{mvarId.name}'\"", "start": [58, 1], "end": [67, 55], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.declareExprMVar", "code": "def declareExprMVar (mctx : MetavarContext) (mvarId : MVarId)\n    (mdecl : MetavarDecl) : MetavarContext :=\n  { mctx with decls := mctx.decls.insert mvarId mdecl }", "start": [69, 1], "end": [75, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.isExprMVarAssignedOrDelayedAssigned", "code": "def isExprMVarAssignedOrDelayedAssigned (mctx : MetavarContext)\n    (mvarId : MVarId) : Bool :=\n  mctx.eAssignment.contains mvarId || mctx.dAssignment.contains mvarId", "start": [77, 1], "end": [86, 71], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.isExprMVarDeclared", "code": "def isExprMVarDeclared (mctx : MetavarContext) (mvarId : MVarId) : Bool :=\n  mctx.decls.contains mvarId", "start": [88, 1], "end": [92, 29], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.delayedAssignExprMVar", "code": "def delayedAssignExprMVar (mctx : MetavarContext) (mvarId : MVarId)\n    (ass : DelayedMetavarAssignment) : MetavarContext :=\n  { mctx with dAssignment := mctx.dAssignment.insert mvarId ass }", "start": [94, 1], "end": [100, 66], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.eraseExprMVarAssignment", "code": "def eraseExprMVarAssignment (mctx : MetavarContext) (mvarId : MVarId) :\n    MetavarContext :=\n  { mctx with\n    eAssignment := mctx.eAssignment.erase mvarId\n    dAssignment := mctx.dAssignment.erase mvarId }", "start": [102, 1], "end": [109, 51], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.modifyExprMVarDecl", "code": "def modifyExprMVarDecl (mctx : MetavarContext) (mvarId : MVarId)\n    (f : MetavarDecl \u2192 MetavarDecl) : MetavarContext :=\n  if let some mdecl := mctx.decls.find? mvarId then\n    { mctx with decls := mctx.decls.insert mvarId (f mdecl) }\n  else\n    mctx", "start": [111, 1], "end": [123, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.modifyExprMVarLCtx", "code": "def modifyExprMVarLCtx (mctx : MetavarContext) (mvarId : MVarId)\n    (f : LocalContext \u2192 LocalContext) : MetavarContext :=\n  mctx.modifyExprMVarDecl mvarId \u03bb mdecl => { mdecl with lctx := f mdecl.lctx }", "start": [125, 1], "end": [134, 80], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.setFVarKind", "code": "def setFVarKind (mctx : MetavarContext) (mvarId : MVarId) (fvarId : FVarId)\n    (kind : LocalDeclKind) : MetavarContext :=\n  mctx.modifyExprMVarLCtx mvarId (\u00b7.setKind fvarId kind)", "start": [136, 1], "end": [143, 57], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.setFVarBinderInfo", "code": "def setFVarBinderInfo (mctx : MetavarContext) (mvarId : MVarId)\n    (fvarId : FVarId) (bi : BinderInfo) : MetavarContext :=\n  mctx.modifyExprMVarLCtx mvarId (\u00b7.setBinderInfo fvarId bi)", "start": [145, 1], "end": [152, 61], "kind": "commanddeclaration"}, {"full_name": "Lean.MetavarContext.unassignedExprMVars", "code": "def unassignedExprMVars (mctx : MetavarContext) (includeDelayed := false) :\n    Array MVarId := Id.run do\n  let mut result := #[]\n  for (mvarId, _) in mctx.decls do\n    if ! mctx.eAssignment.contains mvarId &&\n        (includeDelayed || ! mctx.dAssignment.contains mvarId) then\n      result := result.push mvarId\n  return result", "start": [154, 1], "end": [166, 16], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.isAssignedOrDelayedAssigned", "code": "def isAssignedOrDelayedAssigned [Monad m] [MonadMCtx m] (mvarId : MVarId) :\n    m Bool :=\n  return (\u2190 getMCtx).isExprMVarAssignedOrDelayedAssigned mvarId", "start": [173, 1], "end": [182, 64], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.isDeclared", "code": "def isDeclared [Monad m] [MonadMCtx m] (mvarId : MVarId) : m Bool :=\n  return (\u2190 getMCtx).isExprMVarDeclared mvarId", "start": [184, 1], "end": [188, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.delayedAssign", "code": "def delayedAssign [MonadMCtx m] (mvarId : MVarId)\n    (ass : DelayedMetavarAssignment) : m Unit :=\n  modifyMCtx (\u00b7.delayedAssignExprMVar mvarId ass)", "start": [190, 1], "end": [196, 50], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.eraseAssignment", "code": "def eraseAssignment [MonadMCtx m] (mvarId : MVarId) : m Unit :=\n  modifyMCtx (\u00b7.eraseExprMVarAssignment mvarId)", "start": [198, 1], "end": [202, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.modifyDecl", "code": "def modifyDecl [MonadMCtx m] (mvarId : MVarId)\n    (f : MetavarDecl \u2192 MetavarDecl) : m Unit :=\n  modifyMCtx (\u00b7.modifyExprMVarDecl mvarId f)", "start": [204, 1], "end": [213, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.modifyLCtx", "code": "def modifyLCtx [MonadMCtx m] (mvarId : MVarId)\n    (f : LocalContext \u2192 LocalContext) : m Unit :=\n  modifyMCtx (\u00b7.modifyExprMVarLCtx mvarId f)", "start": [215, 1], "end": [224, 45], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.setFVarKind", "code": "def setFVarKind [MonadMCtx m] (mvarId : MVarId) (fvarId : FVarId)\n    (kind : LocalDeclKind) : m Unit :=\n  modifyMCtx (\u00b7.setFVarKind mvarId fvarId kind)", "start": [226, 1], "end": [232, 48], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.setFVarBinderInfo", "code": "def setFVarBinderInfo [MonadMCtx m] (mvarId : MVarId) (fvarId : FVarId)\n    (bi : BinderInfo) : m Unit :=\n  modifyMCtx (\u00b7.setFVarBinderInfo mvarId fvarId bi)", "start": [234, 1], "end": [240, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.getMVarDependencies", "code": "partial def getMVarDependencies (mvarId : MVarId) (includeDelayed := false) :\n    MetaM (HashSet MVarId) :=\n  (\u00b7.snd) <$> (go mvarId).run {}\nwhere\n  \n  addMVars (e : Expr) : StateRefT (HashSet MVarId) MetaM Unit := do\n    let mvars \u2190 getMVars e\n    let mut s \u2190 get\n    set ({} : HashSet MVarId) for mvarId in mvars do\n      if \u2190 pure includeDelayed <||> notM (mvarId.isDelayedAssigned) then\n        s := s.insert mvarId\n    set s\n    mvars.forM go\n\n  \n  go (mvarId : MVarId) : StateRefT (HashSet MVarId) MetaM Unit :=\n    withIncRecDepth do\n      let mdecl \u2190 mvarId.getDecl\n      addMVars mdecl.type\n      for ldecl in mdecl.lctx do\n        addMVars ldecl.type\n        if let (some val) := ldecl.value? then\n          addMVars val\n      if let (some ass) \u2190 getDelayedMVarAssignment? mvarId then\n        let pendingMVarId := ass.mvarIdPending\n        if \u2190 notM pendingMVarId.isAssignedOrDelayedAssigned then\n          modify (\u00b7.insert pendingMVarId)\n        go pendingMVarId", "start": [242, 1], "end": [275, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.replace", "code": "def replace (g : MVarId) (hyp : FVarId) (proof : Expr) (typeNew : Option Expr := none) :\n    MetaM AssertAfterResult :=\n  g.withContext do\n    let typeNew \u2190 match typeNew with\n    | some t => pure t\n    | none => inferType proof\n    let ldecl \u2190 hyp.getDecl\n    let (_, ldecl') \u2190 findMaxFVar typeNew |>.run ldecl\n    let result \u2190 g.assertAfter ldecl'.fvarId ldecl.userName typeNew proof\n    (return { result with mvarId := \u2190 result.mvarId.clear hyp }) <|> pure result\nwhere\n  \n  findMaxFVar (e : Expr) : StateRefT LocalDecl MetaM Unit :=\n    e.forEach' fun e => do\n      if e.isFVar then\n        let ldecl' \u2190 e.fvarId!.getDecl\n        modify fun ldecl => if ldecl'.index > ldecl.index then ldecl' else ldecl\n        return false\n      else\n        return e.hasFVar", "start": [277, 1], "end": [305, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.getTypeCleanup", "code": "def getTypeCleanup (mvarId : MVarId) : MetaM Expr :=\n  return (\u2190 instantiateMVars (\u2190 mvarId.getType)).cleanupAnnotations", "start": [307, 1], "end": [310, 68], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.getUnassignedExprMVars", "code": "def getUnassignedExprMVars [Monad m] [MonadMCtx m] (includeDelayed := false) :\n    m (Array MVarId) :=\n  return (\u2190 getMCtx).unassignedExprMVars (includeDelayed := includeDelayed)", "start": [317, 1], "end": [323, 76], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.unhygienic", "code": "def unhygienic [MonadWithOptions m] (x : m \u03b1) : m \u03b1 :=\n  withOptions (tactic.hygienic.set \u00b7 false) x", "start": [325, 1], "end": [329, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.mkFreshIdWithPrefix", "code": "def mkFreshIdWithPrefix [Monad m] [MonadNameGenerator m] (\u00abprefix\u00bb : Name) :\n    m Name := do\n  let ngen \u2190 getNGen\n  let r := { ngen with namePrefix := \u00abprefix\u00bb }.curr\n  setNGen ngen.next\n  pure r", "start": [331, 1], "end": [341, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.repeat'Core", "code": "def repeat'Core [Monad m] [MonadError m] [MonadMCtx m]\n    (f : MVarId \u2192 m (List MVarId)) (gs : List MVarId) (maxIters := 100000) :\n    m (Bool \u00d7 List MVarId) := do\n  let (progress, acc) \u2190 go maxIters false gs [] #[]\n  pure (progress, (\u2190 acc.filterM fun g => not <$> g.isAssigned).toList)\nwhere\n  \n  go : Nat \u2192 Bool \u2192 List MVarId \u2192 List (List MVarId) \u2192 Array MVarId \u2192 m (Bool \u00d7 Array MVarId)\n  | _, p, [], [], acc => pure (p, acc)\n  | n, p, [], gs::stk, acc => go n p gs stk acc\n  | n, p, g::gs, stk, acc => do\n    if \u2190 g.isAssigned then\n      go n p gs stk acc\n    else\n      match n with\n      | 0 => pure <| (p, acc.push g ++ gs |> stk.foldl .appendList)\n      | n+1 =>\n        match \u2190 observing (f g) with\n        | .ok gs' => go n true gs' (gs::stk) acc\n        | .error _ => go n p gs stk (acc.push g)\ntermination_by _ n p gs stk _ => (n, stk, gs)", "start": [343, 1], "end": [375, 46], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.repeat'", "code": "def repeat' [Monad m] [MonadError m] [MonadMCtx m]\n    (f : MVarId \u2192 m (List MVarId)) (gs : List MVarId) (maxIters := 100000) : m (List MVarId) :=\n  repeat'Core f gs maxIters <&> (\u00b7.2)", "start": [377, 1], "end": [385, 38], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.repeat1'", "code": "def repeat1' [Monad m] [MonadError m] [MonadMCtx m]\n    (f : MVarId \u2192 m (List MVarId)) (gs : List MVarId) (maxIters := 100000) : m (List MVarId) := do\n  let (.true, gs) \u2190 repeat'Core f gs maxIters | throwError \"repeat1' made no progress\"\n  pure gs", "start": [387, 1], "end": [396, 10], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.saturate1", "code": "partial def saturate1 [Monad m] [MonadError m] [MonadRecDepth m] [MonadLiftT (ST IO.RealWorld) m]\n    (goal : MVarId) (tac : MVarId \u2192 m (Option (Array MVarId))) : m (Option (Array MVarId)) := do\n  let some goals \u2190 tac goal | return none\n  let acc \u2190 ST.mkRef #[]\n  goals.forM (go acc)\n  return some (\u2190 acc.get)\nwhere\n  \n  go (acc : IO.Ref (Array MVarId)) (goal : MVarId) : m Unit :=\n    withIncRecDepth do\n      match \u2190 tac goal with\n      | none => acc.modify \u03bb s => s.push goal\n      | some goals => goals.forM (go acc)", "start": [398, 1], "end": [419, 42], "kind": "commanddeclaration"}]}
